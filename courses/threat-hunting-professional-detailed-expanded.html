



<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>Threat Hunting Professional Course Curriculum | CipherHall</title>
    <meta name="description" content="Begin your free professional threat hunting course. This curriculum covers the hunter's mindset, MITRE ATT&CK, host/network analysis, SIEM querying, and detection engineering." />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png" />
    <link rel="shortcut icon" href="/favicon.png" type="image/x-icon" />
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png" />
    <link rel="canonical" href="https://www.cipherhall.com/courses/threat-hunting-professional-detailed-expanded.html" />

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Course",
      "name": "Threat Hunting: A Proactive Defense Approach",
      "description": "A comprehensive, 20-lesson course designed to build a professional-level skill set in proactive threat hunting, from fundamentals to advanced techniques in host, network, and cloud analysis.",
      "provider": {
        "@type": "Organization",
        "name": "CipherHall",
        "sameAs": "https://www.cipherhall.com"
      },
      "hasCourseInstance": {
        "@type": "CourseInstance",
        "courseMode": "Online",
        "instructor": {
          "@type": "Person",
          "name": "Leo Rivera"
        }
      }
    }
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Exo+2:wght@700;800;900&display=swap" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" />
    <link rel="stylesheet" href="assets/css/coursepages.css">
</head>
  <body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
      <div class="loader-icon">
        <i class="fas fa-graduation-cap"></i>
      </div>
      <div class="loader-text">Loading Course Content...</div>
    </div>

    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- Music Player (fixed at top right) -->
    <div class="header-controls">
      <div class="music-dropdown" id="music-dropdown">
        <button class="btn btn-secondary">
          <span id="music-button-text">STUDY MUSIC</span>
          <i id="music-icon" class="fa-solid fa-music"></i>
        </button>
        <div class="music-dropdown-content" id="music-dropdown-content">
          <a
            href="#"
            data-src="https://www.learningcontainer.com/wp-content/uploads/2020/02/Kalimba.mp3"
            >1. Coffee Shop Vibes</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3"
            >2. City Lights Lofi</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-15.mp3"
            >3. Mellow Thoughts</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-13.mp3"
            >4. Rainy Mood</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3"
            >5. Time Alone</a
          >
          <a href="#" id="stop-music-link"
            ><i class="fa-solid fa-stop-circle"></i> Stop Music</a
          >
        </div>
      </div>

      <button class="btn btn-secondary" id="resetProgressBtn">
        <i class="fas fa-redo"></i>
        Reset Progress
      </button>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal" style="display: none">
      <div class="modal-overlay"></div>
      <div class="modal-content">
        <span class="close" id="closeAuthModal">&times;</span>
        <div class="auth-tabs">
          <button id="tabSignIn" class="auth-tab active">Sign In</button>
          <button id="tabSignUp" class="auth-tab">Sign Up</button>
        </div>
        <div
          id="authLoader"
          style="display: none; text-align: center; padding: 2rem"
        >
          <i
            class="fas fa-spinner fa-spin fa-2x"
            style="color: var(--color-green)"
          ></i>
          <p style="margin-top: 0.5rem">Authenticating...</p>
        </div>
        <div id="signInForm" class="auth-form">
          <h2>Sign In to CyberSec Academy</h2>
          <button id="googleSignIn" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignInForm">
            <input
              type="email"
              id="signInEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signInPassword"
              placeholder="Password"
              required
            />
            <button type="submit" class="btn btn-primary">Sign In</button>
          </form>
        </div>
        <div id="signUpForm" class="auth-form" style="display: none">
          <h2>Join CyberSec Academy</h2>
          <button id="googleSignUp" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignUpForm">
            <input
              type="text"
              id="signUpName"
              placeholder="Full Name"
              required
            />
            <input
              type="email"
              id="signUpEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signUpPassword"
              placeholder="Password (min. 8 characters)"
              required
            />
            <button type="submit" class="btn btn-secondary">
              Create Account
            </button>
          </form>
        </div>
        <div id="authMessage"></div>
      </div>
    </div>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="course-info">
          <h1 class="course-title" id="courseTitle">Loading...</h1>
          <div class="course-progress">
            <div class="progress-header">
              <span class="progress-label">Course Progress</span>
              <span class="progress-percentage" id="courseProgressPercent"
                >0%</span
              >
            </div>
            <div class="progress-bar">
              <div
                class="progress-fill"
                id="courseProgressFill"
                style="width: 0%"
              ></div>
            </div>
            <div class="progress-stats">
              <span id="completedLessons">0</span>
              <span id="totalLessons">0</span>
            </div>
          </div>
          <a href="/dashboard.html" class="back-to-dashboard">
            <i class="fas fa-arrow-left"></i>
            Back to Dashboard
          </a>
        </div>
      </div>

      <nav class="lesson-nav" id="lessonNav">
        <!-- Lessons will be loaded dynamically -->
      </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <header class="content-header">
        <div class="lesson-header">
          <div class="lesson-header-left">
            <span class="lesson-number" id="currentLessonNumber">1</span>
            <h1 class="lesson-header-title" id="currentLessonTitle">
              Loading...
            </h1>
          </div>
          <div class="lesson-actions">
            <button class="mbtn btn-primary" id="menuToggle">
              <i class="fas fa-bars"></i>
            </button>
          </div>
        </div>
      </header>

      <div class="content-body" id="contentBody">
        <div class="lesson-content" id="lessonContent">
          <!-- Lesson content will be loaded dynamically -->
        </div>
      </div>

      <footer class="lesson-navigation">
        <div class="nav-info" id="navInfo">Lesson 1 of 10</div>
        <div class="nav-controls">
          <button class="btn btn-secondary" id="prevLessonBtn" disabled>
            <i class="fas fa-chevron-left"></i>
            Previous
          </button>
          <button class="btn btn-primary" id="nextLessonBtn" disabled>
            Next
            <i class="fas fa-chevron-right"></i>
          </button>
        </div>
      </footer>
    </main>

    <!-- Achievement Notification -->
    <div id="achievementNotification" class="achievement-notification">
      <div class="notification-header">
        <div class="notification-icon" id="notificationIcon">
          <i class="fas fa-trophy"></i>
        </div>
        <div class="notification-content">
          <h3 id="notificationTitle">Achievement Unlocked!</h3>
          <p id="notificationDescription">Description here...</p>
        </div>
      </div>
      <div class="notification-reward" id="notificationReward">
        <i class="fas fa-coins"></i>
        <span id="notificationPoints">+100 Points</span>
      </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast">
      <span id="toastMessage"></span>
    </div>

    <script>
      // =====================================================
      // SYNCHRONIZED COURSE SYSTEM WITH DASHBOARD INTEGRATION
      // =====================================================

      // Supabase Configuration - Replace with your config
      const supabaseUrl = "https://lzcmzulemfubjaksoqor.supabase.co";
      const supabaseKey =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx6Y216dWxlbWZ1Ympha3NvcW9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzMzM5MDgsImV4cCI6MjA3MDkwOTkwOH0.crhPH4YWtRsr1BJTpAQcmPbWSpwIWRbzoI4sRb2_fPI";
      const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

      // =====================================================
      // COURSE DATA STRUCTURE - REPLACE WITH YOUR COURSE JSON
      // =====================================================
      const COURSE_DATA ={
    "id": "threat-hunting-professional-detailed-expanded",
    "title": "Threat Hunting: A Proactive Defense Approach",
    "description": "A comprehensive, 20-lesson course designed to build a professional-level skill set in proactive threat hunting. This syllabus takes students from the fundamentals of the hunting mindset and lab setup to advanced techniques in host, network, and cloud analysis, culminating in the operationalization of hunts into durable detections. All labs use benign or simulated datasets.",
    "category": "cybersecurity_operations",
    "difficulty": "Intermediate to Advanced",
    "duration": "60 hours",
    "instructor": "Dr. Evelyn Reed",
    "lessons": [
        {
            "id": "lesson-1",
            "title": "Module 1: Foundations - Introduction to Threat Hunting",
            "duration": "90 min",
            "objectives": [
                "Define threat hunting and its role in a modern security program.",
                "Differentiate between proactive hunting and reactive incident response.",
                "Understand the relationship between threat hunting and the Security Operations Center (SOC).",
                "Explore the motivations and goals of a threat hunter."
            ],
            "content": {
                "overview": "This foundational lesson introduces the discipline of threat hunting. We will explore why traditional, reactive security measures are no longer sufficient and how proactive hunting—the process of actively searching for adversaries in your network—provides a critical layer of defense against advanced threats that bypass automated systems.",
                "sections": [
                    {
                        "title": "Proactive vs. Reactive Defense",
                        "content": "<p>Traditional security is often reactive: an alert fires from a SIEM or EDR, and an analyst responds. This model assumes your automated defenses will always catch the adversary. Threat hunting operates on a different assumption: <strong>assume you are already compromised</strong>. The hunter's job is not to wait for an alert, but to proactively search for the subtle signs of attacker behavior (Indicators of Attack) that automated tools may have missed.</p>"
                    },
                    {
                        "title": "The Role of the Hunter",
                        "content": "<p>A threat hunter acts as a senior member of the security team. They leverage deep knowledge of attacker techniques and the organization's environment to search for threats. The output of a successful hunt is not just finding a threat, but creating a new, automated detection rule to catch that threat in the future, thereby improving the organization's overall security posture.</p>"
                    }
                ],
                "activities": [
                    {
                        "title": "Compare Detection vs. Hunting",
                        "description": "Create a table comparing traditional alert-based detection with proactive threat hunting across several criteria: Trigger (Alert vs. Hypothesis), Assumption (Assume Clean vs. Assume Compromised), Data Sources (Alerts vs. Raw Telemetry), and Outcome (Alert Triage vs. New Detection)."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the core assumption that drives threat hunting?",
                        "options": ["The network is always secure.", "Automated alerts will catch every threat.", "The network is already compromised, and a threat may be lurking undetected.", "Threat hunters only work during a security breach."],
                        "correct": 2,
                        "explanation": "The 'assume breach' mindset is the fundamental philosophical shift that separates proactive hunting from reactive defense."
                    },
                    {
                        "id": 2,
                        "question": "What is the ultimate goal of a successful threat hunt?",
                        "options": ["To prove that the network is clean.", "To find a single malicious file.", "To find an active adversary and generate a new, automated detection rule to prevent similar attacks in the future.", "To write a report."],
                        "correct": 2,
                        "explanation": "A mature hunting program uses each hunt to improve the organization's automated defenses, effectively 'vaccinating' the network against that technique."
                    }
                ]
            }
        },
        {
            "id": "lesson-2",
            "title": "Module 1: Foundations - The Hunter's Mindset & Frameworks",
            "duration": "120 min",
            "objectives": [
                "Understand the principle of hypothesis-driven hunting.",
                "Differentiate between Indicators of Compromise (IOCs) and Indicators of Attack (IOAs).",
                "Learn the structure and purpose of the MITRE ATT&CK Framework.",
                "Introduce other analysis models like the Diamond Model of Intrusion Analysis."
            ],
            "content": {
                "overview": "Effective hunting is not random searching; it is a structured, scientific process. This lesson introduces the mindset and frameworks that guide a hunter's actions, teaching you how to formulate hypotheses and use industry-standard models like MITRE ATT&CK to understand and categorize adversary behavior.",
                "sections": [
                    {
                        "title": "Hypothesis-Driven Hunting",
                        "content": "<p>A hunt begins with a hypothesis, an educated guess about attacker activity. For example: 'An attacker is using PowerShell to achieve persistence via WMI event subscriptions.' This hypothesis gives the hunt focus. The hunter can then identify the specific data sources (e.g., Sysmon logs, PowerShell logs) and queries needed to prove or disprove the hypothesis.</p>"
                    },
                    {
                        "title": "IOCs vs. IOAs",
                        "content": "<ul><li><strong>Indicator of Compromise (IOC):</strong> A static, forensic artifact of an intrusion. Examples include a malicious file hash, a C2 domain name, or a registry key. IOCs are useful but brittle; attackers can change them easily.</li><li><strong>Indicator of Attack (IOA):</strong> A description of the *behavior* or *technique* an attacker used. For example, 'A Word document spawned a PowerShell process which made a network connection.' IOAs are more durable because they describe the attacker's TTPs (Tactics, Techniques, and Procedures), which are harder for them to change. Threat hunting focuses on finding IOAs.</li></ul>"
                    },
                    {
                        "title": "The MITRE ATT&CK Framework",
                        "content": "<p>The ATT&CK framework is the industry-standard encyclopedia of adversary TTPs. It provides a common language for defenders to describe and categorize attacker behavior. Hunters use it to formulate hypotheses (e.g., 'Let's hunt for Technique T1053.005 - Scheduled Task') and to map their findings, providing rich context to their reports.</p>"
                    }
                ],
                "activities": [
                    {
                        "title": "Formulate Hunting Hypotheses",
                        "description": "Using the MITRE ATT&CK Enterprise Matrix, choose three different techniques. For each technique, formulate a one-sentence hunting hypothesis. For example, for T1003.001 - LSASS Memory, the hypothesis might be: 'An attacker is dumping credentials from the LSASS process to escalate privileges.'"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "A file hash (`a1b2c3...`) is an example of what?",
                        "options": ["An Indicator of Attack (IOA)", "An Indicator of Compromise (IOC)", "A Tactic", "A Technique"],
                        "correct": 1,
                        "explanation": "A file hash is a static artifact. While useful, it's considered a lower-level indicator because an attacker can easily change it by recompiling their malware."
                    },
                    {
                        "id": 2,
                        "question": "Why is the MITRE ATT&CK framework essential for threat hunters?",
                        "options": ["It is an antivirus program.", "It provides a comprehensive, standardized knowledge base of attacker techniques, which helps hunters formulate hypotheses and classify their findings.", "It is a SIEM tool.", "It provides a list of all known malicious IP addresses."],
                        "correct": 1,
                        "explanation": "ATT&CK provides the 'what' to hunt for. It's the library of known-bad behaviors that a hunter uses to guide their investigations."
                    }
                ]
            }
        },
        {
            "id": "lesson-3",
            "title": "Module 1: Foundations - Lab Setup for Hunting",
            "duration": "120 min",
            "objectives": [
                "Design an isolated lab environment suitable for data collection and analysis.",
                "Install and configure Sysmon on a Windows VM to generate rich host telemetry.",
                "Set up an ELK stack (Elasticsearch, Logstash, Kibana) to act as a simple SIEM.",
                "Configure a data pipeline to forward and parse Sysmon logs into Elasticsearch."
            ],
            "content": {
                "overview": "Threat hunting is a data-driven discipline. To practice, we need a lab that can generate, collect, and store the rich telemetry that hunters rely on. This lesson is a hands-on guide to building a minimal but powerful hunting lab, including a Windows 'victim' machine with Sysmon and an ELK stack for our SIEM.",
                "sections": [
                    {
                        "title": "Host Telemetry with Sysmon",
                        "content": "<p>Standard Windows Event Logs are often not detailed enough for effective hunting. <strong>Sysmon (System Monitor)</strong> is a free tool from Microsoft that provides deep, kernel-level logging of critical system activity. It generates high-quality events for process creation (including parent processes and command lines), network connections, file creation, registry modifications, and much more. Sysmon is the single most valuable data source for a Windows threat hunter.</p>"
                    },
                    {
                        "title": "Log Collection with the ELK Stack",
                        "content": "<p>We need a central place to search and analyze our logs. The ELK stack is a popular open-source solution:</p><ul><li><strong>Elasticsearch:</strong> A powerful search and analytics engine that stores the log data.</li><li><strong>Logstash / Filebeat:</strong> Agents that collect logs from the source (our Windows VM) and forward them to Elasticsearch.</li><li><strong>Kibana:</strong> A web interface for searching, visualizing, and creating dashboards with the data in Elasticsearch.</li></ul>"
                    }
                ],
                "activities": [
                    {
                        "title": "Install and Configure Sysmon and ELK",
                        "description": "Following a step-by-step guide, create two VMs: a Windows 10 VM and a Linux VM. On the Windows VM, install Sysmon with a robust configuration file (like the one from SwiftOnSecurity). On the Linux VM, deploy the ELK stack using Docker Compose. Install and configure a log shipping agent (like Winlogbeat) on the Windows VM to send Sysmon events to your ELK instance. Generate some benign activity (opening notepad, pinging google.com) and verify that the corresponding Sysmon events appear in Kibana."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary benefit of using Sysmon over standard Windows Event Logs?",
                        "options": ["Sysmon is faster.", "Sysmon provides much more detailed, security-relevant telemetry, such as parent process information, command lines, and network connection details.", "Sysmon is the only tool that can collect logs.", "There is no benefit."],
                        "correct": 1,
                        "explanation": "Sysmon was specifically designed to provide the deep visibility needed for threat hunting and incident response, logging details that are absent from the default logs."
                    },
                    {
                        "id": 2,
                        "question": "In an ELK stack, what is the primary role of Kibana?",
                        "options": ["To store log data.", "To collect logs from endpoints.", "To provide a web-based user interface for searching, visualizing, and dashboarding the log data.", "To generate alerts."],
                        "correct": 2,
                        "explanation": "Kibana is the visualization layer of the ELK stack, acting as the hunter's primary interface to the data stored in Elasticsearch."
                    }
                ]
            }
        },
        {
            "id": "lesson-4",
            "title": "Module 1: Foundations - Data Sources & Collection",
            "duration": "90 min",
            "objectives": [
              "Identify the most critical data sources for threat hunting.",
              "Differentiate between host, network, and cloud telemetry.",
              "Understand the importance of data normalization and parsing.",
              "Learn the basics of baselining to identify 'normal' activity."
            ],
            "content": {
              "overview": "A hunter is only as good as their data. This lesson provides a comprehensive overview of the essential data sources that a threat hunter needs access to, covering host, network, and cloud telemetry. We will also discuss the critical pre-processing steps of parsing and normalization that make this data usable for analysis.",
              "sections": [
                {
                  "title": "Key Data Sources",
                  "content": "<ul><li><strong>Host Telemetry:</strong> Sysmon, Windows Event Logs, PowerShell Logs, Linux `auditd`, EDR logs. This data provides deep visibility into what is happening on an endpoint.</li><li><strong>Network Telemetry:</strong> NetFlow, PCAP, DNS logs, proxy logs, VPN logs. This data provides visibility into communications between hosts and to the internet. Tools like Zeek and Suricata are used to generate rich network security monitoring (NSM) data from raw packet captures.</li><li><strong>Cloud Telemetry:</strong> AWS CloudTrail, Azure Activity Logs, GCP Cloud Audit Logs. This data records every API call made in your cloud environment and is critical for hunting cloud-based threats.</li><li><strong>Authentication Telemetry:</strong> Logs from Active Directory, Okta, or other identity providers.</li></ul>"
                },
                {
                    "title": "Data Normalization and Parsing",
                    "content": "<p>Raw logs come in hundreds of different formats. For a SIEM to be effective, this data must be parsed and normalized into a common schema. Parsing is the process of breaking a raw log line (e.g., a syslog message) into structured fields (e.g., `source_ip`, `user_name`, `process_name`). Normalization ensures that the same field name is used for the same concept across all data sources (e.g., always using `source_ip`, not `src_ip` or `clientIP`). This allows a hunter to write a single query that works across multiple data types.</p>"
                }
              ],
              "codeExamples": [
                {
                    "title": "PowerShell Script to Enable Command-Line Logging",
                    "language": "powershell",
                    "code": "# A defender runs this PowerShell script via Group Policy to enable a critical source of telemetry.\n# This setting logs the full command line for every process created, which is essential for hunting.\n$path = 'HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\Audit'\nSet-ItemProperty -Path $path -Name ProcessCreationIncludeCmdLine_Enabled -Value 1"
                },
                {
                    "title": "Simple Python Script to Parse a Log Line",
                    "language": "python",
                    "code": "# A defender might write a simple script like this to parse a custom log format.\n# It uses regular expressions to extract structured fields from a raw string.\nimport re\n\nlog_line = '_time=167... src_ip=10.1.1.5 dest_ip=8.8.8.8 user=admin action=login_failed'\n\ndef parse_log(log_line):\n    # A more robust solution would not use this simple regex, but it shows the concept.\n    kv_pattern = re.compile(r'(\\w+)=([^\\s]+)')\n    log_dict = dict(kv_pattern.findall(log_line))\n    return log_dict\n\nprint(parse_log(log_line))"
                },
                {
                    "title": "Logstash Grok Pattern for Normalization",
                    "language": "grok",
                    "code": "# Logstash is part of the ELK stack. A defender writes Grok patterns to parse and normalize logs.\n# This pattern takes a raw syslog message and breaks it into standard fields.\n# filter {\n#   grok {\n#     match => { \"message\" => \"%{SYSLOGTIMESTAMP:timestamp} %{HOSTNAME:hostname} %{PROG:process_name}: %{GREEDYDATA:message_body}\" }\n#   }\n# }"
                },
                {
                    "title": "Querying Windows Event Logs with PowerShell",
                    "language": "powershell",
                    "code": "# A hunter can use PowerShell for quick analysis of local or remote Windows Event Logs.\n# This command gets all successful logon events (Event ID 4624) from the Security log\n# in the last 24 hours.\nGet-WinEvent -FilterHashtable @{LogName='Security'; ID=4624; StartTime=(Get-Date).AddDays(-1)} | Select-Object TimeCreated, Message"
                }
              ],
              "activities": [
                {
                  "title": "Collect & Parse Sample Logs",
                  "description": "Using your lab's Windows VM, generate several different types of benign events (e.g., log in, create a file, start a process). Find the corresponding events in the Sysmon logs inside Kibana. Examine the raw JSON of the events and identify the key fields (`process.name`, `process.command_line`, `host.name`, etc.)."
                }
              ]
            },
            "quiz": {
              "passingScore": 80,
              "questions": [
                {
                  "id": 1,
                  "question": "For hunting on a Windows endpoint, what is generally considered the single most valuable log source?",
                  "options": ["Firewall logs", "Sysmon logs", "DNS logs", "Printer logs"],
                  "correct": 1,
                  "explanation": "Sysmon provides an unparalleled level of detail about process, network, and registry activity, which is exactly what a threat hunter needs."
                },
                {
                  "id": 2,
                  "question": "What is data normalization in the context of a SIEM?",
                  "options": ["Making the data smaller.", "The process of transforming log data from different sources into a common, standard schema (e.g., always using the field name `source_ip`).", "Deleting old data.", "Encrypting the data."],
                  "correct": 1,
                  "explanation": "Normalization is critical because it allows analysts to write queries that work across diverse data sources, greatly simplifying the hunting process."
                }
              ]
            }
        },
        {
            "id": "lesson-5",
            "title": "Module 2: Host-Based Hunting (Windows) - Process Analysis",
            "duration": "120 min",
            "objectives": [
              "Understand Sysmon Event ID 1 (Process Creation) in detail.",
              "Analyze process trees to identify suspicious parent-child relationships.",
              "Hunt for process masquerading and other command-line obfuscation.",
              "Write SIEM queries to find anomalous process execution patterns."
            ],
            "content": {
              "overview": "The process is the fundamental unit of execution, and analyzing process creation events is the bedrock of host-based threat hunting. This lesson is a deep dive into Sysmon Event ID 1, teaching you how to hunt for the tell-tale signs of malicious execution, such as legitimate processes spawning unusual children.",
              "sections": [
                {
                  "title": "Anatomy of Sysmon Event ID 1",
                  "content": "<p>A single Sysmon Process Creation event contains a wealth of forensic data:</p><ul><li><strong>Process GUID & PID:</strong> A unique identifier for the process instance.</li><li><strong>Image:</strong> The full path to the executable file.</li><li><strong>CommandLine:</strong> The full command line used to launch the process, including all arguments. This is critical.</li><li><strong>ParentImage & ParentCommandLine:</strong> The image and command line of the process that launched this one.</li><li><strong>User:</strong> The user account that initiated the process.</li></ul>"
                },
                {
                  "title": "Suspicious Parent-Child Relationships",
                  "content": "<p>One of the most effective hunting techniques is to look for anomalous process trees. Attackers often execute code via legitimate Windows processes to blend in. A hunter knows what normal behavior looks like and hunts for deviations. Examples of suspicious relationships include:</p><ul><li>Microsoft Word (`winword.exe`) spawning PowerShell (`powershell.exe`).</li><li>A web server (`iis.exe`) spawning `cmd.exe`.</li><li>`services.exe` spawning a process that is not a standard Windows service.</li></ul>"
                }
              ],
              "codeExamples":[
              {
                "title": "Splunk Query for Suspicious Parent-Child Process",
                "language": "spl",
                "code": "(* This SPL query is a high-fidelity hunt for a common lateral movement technique.\n   A defender would run this in Splunk to find if any user's Office application\n   has ever spawned a command shell, which is highly indicative of a malicious macro. *)\n\nindex=sysmon EventCode=1 ParentImage IN (\"*\\\\winword.exe\", \"*\\\\excel.exe\", \"*\\\\powerpnt.exe\") Image IN (\"*\\\\cmd.exe\", \"*\\\\powershell.exe\")\n| stats count by ParentImage, Image, CommandLine, User"
              },
              {
                "title": "KQL Query for Process Masquerading",
                "language": "kql",
                "code": "// This KQL query is for Microsoft Sentinel or Defender for Endpoint.\n// It helps a hunter find 'process masquerading' (T1036.005).\n// It looks for processes named like a legitimate system binary (e.g., svchost.exe)\n// but running from an unusual, non-system directory.\nDeviceProcessEvents\n| where FileName in ('svchost.exe', 'lsass.exe', 'wininit.exe')\n    and FolderPath !startswith \"C:\\\\Windows\\\\System32\""
              },
              {
                "title": "PowerShell Script to Find Recently Created Executables",
                "language": "powershell",
                "code": "# A defender could run this script during a live investigation on a host.\n# It finds all executable files in a user's profile that were created in the last day,\n# a common location for malware droppers.\nGet-ChildItem -Path $env:USERPROFILE -Include *.exe,*.dll,*.ps1 -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.CreationTime -gt (Get-Date).AddDays(-1) }"
              },
              {
                "title": "Sigma Rule for Command-Line Obfuscation",
                "language": "yaml",
                "code": "# Defenders use Sigma to create rules that detect suspicious command-line patterns.\n# This rule detects the tell-tale signs of PowerShell command-line obfuscation,\n# like the use of the encoded command flag or unusual carets (^).\ntitle: PowerShell Obfuscation\nstatus: stable\nlogsource:\n    product: windows\n    category: process_creation\ndetection:\n    selection_flags:\n        CommandLine|contains|all:\n            - 'powershell'\n            - '-e'\n            - '-enc'\n    selection_carets:\n        CommandLine|contains: '^'\n    condition: selection_flags or selection_carets"
              }
              ],
              "activities": [
                {
                  "title": "Hunt for Anomalous Parents in Simulated Data",
                  "description": "Given a CSV file of simulated Sysmon process creation events, use your SIEM (or Python/PowerShell scripts) to find all processes that were spawned by a parent process that is not typically expected. For example, find any instance of `notepad.exe` spawning `powershell.exe`."
                }
              ]
            },
            "quiz": {
              "passingScore": 80,
              "questions": [
                {
                  "id": 1,
                  "question": "When analyzing Sysmon Event ID 1 (Process Creation), which field is often the most valuable for a threat hunter?",
                  "options": ["The Process GUID", "The Process ID (PID)", "The ParentImage and CommandLine", "The timestamp"],
                  "correct": 2,
                  "explanation": "The parent process context and the full command line provide the richest information for identifying anomalous and malicious execution."
                },
                {
                  "id": 2,
                  "question": "A hunter observes an alert where `winlogon.exe` spawned a process named `svchost.exe` from the `C:\\Temp\\` directory. This is likely an example of what technique?",
                  "options": ["Normal system behavior.", "Process masquerading.", "A network scan.", "Data encryption."],
                  "correct": 1,
                  "explanation": "The real `svchost.exe` lives in `C:\\Windows\\System32`. Malware often uses legitimate names in illegitimate locations to hide. This is process masquerading (ATT&CK T1036.005)."
                }
              ]
            }
        },
        {
            "id": "lesson-6",
            "title": "Module 2: Host-Based Hunting (Windows) - File & Registry Analysis",
            "duration": "120 min",
            "objectives": [
              "Understand Sysmon Event IDs for file and registry activity.",
              "Hunt for malware droppers by analyzing file creation in unusual locations.",
              "Hunt for persistence by analyzing modifications to autorun registry keys.",
              "Write SIEM queries to correlate file and registry events."
            ],
            "content": {
              "overview": "Beyond process execution, malware's interaction with the file system and registry provides critical clues for hunters. This lesson focuses on using Sysmon's file and registry event logs to hunt for common malware behaviors like dropping payloads and establishing persistence.",
              "sections": [
                {
                  "title": "Key Sysmon Events",
                  "content": "<ul><li><strong>Event ID 11 (FileCreate):</strong> Logs when a file is created. This is perfect for hunting for droppers by looking for executable files being created in temporary or user-writable directories.</li><li><strong>Event ID 12/13/14 (Registry Events):</strong> Log when a registry key or value is created, deleted, or renamed. A hunter will filter these events to focus on known persistence locations like the `Run` keys.</li></ul>"
                }
              ],
              "codeExamples":[
              {
                "title": "Splunk Query to Find Executables Dropped in Temp Folders",
                "language": "spl",
                "code": "(* A defender runs this query in Splunk to find a very common dropper behavior.\n   It hunts for any process creating a new executable file (.exe, .dll, etc.)\n   in a directory commonly abused by malware. *)\n\nindex=sysmon EventCode=11 TargetFilename IN (\"*\\\\AppData\\\\*\", \"*\\\\Temp\\\\*\", \"*C:\\\\Users\\\\Public\\\\*\") TargetFilename IN (\"*.exe\", \"*.dll\", \"*.vbs\", \"*.ps1\")\n| stats count by ProcessId, Image, TargetFilename, User"
              },
              {
                "title": "KQL Query to Hunt for Registry Run Key Modification",
                "language": "kql",
                "code": "// This KQL query is for Microsoft Sentinel. It is a high-fidelity hunt for persistence.\n// It looks for any process modifying the content of the well-known 'Run' keys in the registry.\nDeviceRegistryEvents\n| where RegistryKey has_all (\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\")\n| where ActionType == \"RegistryValueSet\""
              },
              {
                "title": "PowerShell Script to Check Alternate Data Streams (ADS)",
                "language": "powershell",
                "code": "# Malware can hide its data in NTFS Alternate Data Streams to evade some tools.\n# A defender uses this script to recursively scan a directory and find any file\n# that has an ADS attached to it, which is an anomalous finding.\nGet-ChildItem -Path C:\\Users -Recurse | ForEach-Object {\n    Get-Item $_.FullName -Stream * | Where-Object { $_.Stream -ne ':$DATA' }\n}"
              },
              {
                "title": "Sigma Rule for a Suspicious File Extension",
                "language": "yaml",
                "code": "# A classic defense evasion technique is to hide an executable with a double extension.\n# This Sigma rule helps a defender hunt for files that look like a document or image\n# but are actually an executable file.\ntitle: Masquerading File Extension\nstatus: stable\nlogsource:\n    product: windows\n    category: file_creation\ndetection:\n    selection:\n        TargetFilename|contains|all:\n            - '.pdf.exe'\n            - '.jpg.scr'\n            - '.txt.vbs'\n    condition: selection"
              }
              ],
              "activities": [
                {
                  "title": "Hunt for Persistence in Simulated Logs",
                  "description": "Given a CSV file of simulated Sysmon registry events, write a query (using Python/PowerShell or by importing into your SIEM) to find any event that shows a process writing a new value to any `CurrentVersion\\Run` key. Report the process name and the value it wrote."
                }
              ]
            },
            "quiz": {
              "passingScore": 80,
              "questions": [
                {
                  "id": 1,
                  "question": "A hunter analyzing Sysmon Event ID 11 (FileCreate) finds a process `outlook.exe` creating a file named `invoice.pdf.exe` in the `C:\\Users\\Bob\\AppData\\Local\\Temp\\` directory. This is a strong indicator of what?",
                  "options": ["A normal email attachment being saved.", "A phishing attack where a malicious dropper is being saved to disk.", "A file being printed.", "A software update."],
                  "correct": 1,
                  "explanation": "This chain contains multiple indicators: Outlook spawning a file, the file being dropped in a temporary directory, and the use of a deceptive double extension. This is a classic malware dropper pattern."
                },
                {
                  "id": 2,
                  "question": "Which Sysmon Event IDs are most useful for hunting persistence?",
                  "options": ["Event ID 1 (Process Creation)", "Event ID 3 (Network Connection)", "Event IDs 12, 13, and 14 (Registry Events)", "Event ID 11 (File Create)"],
                  "correct": 2,
                  "explanation": "Because registry modifications are a primary method for achieving persistence on Windows, the registry-specific event IDs are the most direct and valuable data source for this type of hunt."
                }
              ]
            }
        },
        {
            "id": "lesson-7",
            "title": "Module 2: Host-Based Hunting (Windows) - Persistence Deep Dive",
            "duration": "90 min",
            "objectives": [
              "Explore persistence techniques beyond registry run keys.",
              "Hunt for persistence via Scheduled Tasks and WMI Event Subscriptions.",
              "Analyze logs for signs of malicious Service creation.",
              "Use `Autoruns` to consolidate persistence hunting."
            ],
            "content": {
              "overview": "While registry run keys are common, sophisticated adversaries use a wide variety of other techniques to ensure their code survives a reboot. This lesson goes deeper into these advanced persistence TTPs and teaches you how to hunt for them using specific log sources and tools.",
              "sections": [
                {
                  "title": "Scheduled Tasks",
                  "content": "<p>Attackers can use the built-in Windows Task Scheduler to run their malware at a specific time, on user logon, or on another trigger. Hunters can detect this by monitoring for the execution of `schtasks.exe` or by auditing the Windows Event Log for Task Scheduler events (Event ID 4698).</p>"
                },
                {
                  "title": "WMI Event Subscriptions",
                  "content": "<p>Windows Management Instrumentation (WMI) can be used to create a persistent subscription that executes code when a specific event occurs (e.g., a process starting or a user logging on). This is a powerful and stealthy technique. Hunters can detect it by monitoring for unusual child processes of the WMI provider host (`WmiPrvSE.exe`).</p>"
                }
              ],
              "codeExamples":[
              {
                "title": "Splunk Query to Hunt for Scheduled Task Creation",
                "language": "spl",
                "code": "(* This Splunk query helps a defender find persistence via scheduled tasks.\n   It looks for the process creation event for `schtasks.exe` that includes the '/create' flag.\n   The hunter would then investigate the `CommandLine` to see what is being scheduled. *)\n\nindex=sysmon EventCode=1 Image=\"*\\\\schtasks.exe\" CommandLine IN (\"*/create*\", \"*/Create*\")\n| table _time, User, ParentImage, CommandLine"
              },
              {
                "title": "KQL Query for Suspicious Child Process of WMI",
                "language": "kql",
                "code": "// This KQL query is for hunting a common WMI persistence pattern in Microsoft Sentinel.\n// WMI spawning common scripting engines like powershell.exe or cmd.exe is highly suspicious.\nDeviceProcessEvents\n| where InitiatingProcessFileName =~ \"WmiPrvSE.exe\"\n| where FileName in~ (\"powershell.exe\", \"cmd.exe\", \"cscript.exe\", \"wscript.exe\")"
              },
              {
                "title": "Use `Autoruns` for Comprehensive Analysis",
                "language": "bash",
                "code": "# `Autoruns` from Sysinternals is the single best tool for a defender investigating persistence.\n# It automatically checks dozens of locations (Run keys, scheduled tasks, services, etc.).\n# This command exports all findings to a CSV file for analysis and comparison over time.\nautorunsc.exe -a * -ct > autoruns_baseline.csv"
              },
              {
                "title": "PowerShell Script to List WMI Subscriptions",
                "language": "powershell",
                "code": "# A defender can run this script during a live investigation to query for the presence of\n# potentially malicious WMI persistence subscriptions.\nGet-WmiObject -Namespace root\\Subscription -Class __FilterToConsumerBinding | ForEach-Object {\n    $filter = Get-WmiObject -Query \"SELECT * FROM __EventFilter WHERE __PATH = '$($_.Filter)'\"\n    $consumer = Get-WmiObject -Query \"SELECT * FROM __EventConsumer WHERE __PATH = '$($_.Consumer)'\"\n    Write-Output \"Filter: $($filter.Query), Consumer: $($consumer.CommandLineTemplate)\"\n}"
              }
              ],
              "activities": [
                {
                  "title": "Create and Detect a Benign Scheduled Task",
                  "description": "In your Windows lab VM (with Sysmon logging to ELK), create a benign scheduled task that launches `notepad.exe` when you log on. Now, go into Kibana and find the Sysmon and Windows Event Log entries that were generated by this action. Create a query that could be used to hunt for this type of activity in the future."
                }
              ]
            },
            "quiz": {
              "passingScore": 80,
              "questions": [
                {
                  "id": 1,
                  "question": "A hunter is looking for the execution of `schtasks.exe /create ...`. This is a hunt for which ATT&CK tactic?",
                  "options": ["Credential Access", "Lateral Movement", "Persistence", "Exfiltration"],
                  "correct": 2,
                  "explanation": "Creating a scheduled task (T1053.005) is one of the most common and effective techniques used by adversaries to maintain persistence on a compromised host."
                },
                {
                  "id": 2,
                  "question": "What is the primary advantage of using a tool like `Autoruns`?",
                  "options": ["It can block all malware automatically.", "It provides a single, comprehensive view of nearly all possible autorun entry points (persistence locations) on a Windows system, saving a huge amount of manual effort.", "It only checks registry run keys.", "It is a SIEM."],
                  "correct": 1,
                  "explanation": "Autoruns consolidates dozens of different persistence hunting techniques into a single tool, making it an incredibly efficient starting point for any persistence investigation."
                }
              ]
            }
        },
        {
            "id": "lesson-8",
            "title": "Module 2: Host-Based Hunting (Windows) - Lateral Movement",
            "duration": "90 min",
            "objectives": [
              "Define lateral movement and its goal in an attack.",
              "Hunt for suspicious use of remote services (PsExec, WMI).",
              "Analyze authentication logs (Event ID 4624) to track suspicious logons.",
              "Identify signs of credential theft techniques like Pass-the-Hash."
            ],
            "content": {
              "overview": "Once an attacker has a foothold on one machine, their next goal is almost always to move laterally to other machines on the network to find more valuable data or gain higher privileges. This lesson covers the common techniques used for lateral movement within a Windows environment and how to hunt for them in the logs.",
              "sections": [
                {
                  "title": "Remote Service Execution",
                  "content": "<p>Attackers often use legitimate administrative tools to move laterally, as this helps them blend in. Common techniques include:</p><ul><li><strong>PsExec:</strong> A legitimate Sysinternals tool that allows an admin to run commands on a remote machine. Attackers use it to execute their malware on other hosts. Detection involves looking for a service named 'PSEXESVC' being created on the destination host.</li><li><strong>WMI:</strong> An attacker can use WMI to remotely start processes on other machines. Detection involves looking for network connections to the WMI port (135) followed by suspicious process creation on the destination.</li></ul>"
                },
                {
                    "title": "Authentication Log Analysis",
                    "content": "<p>Windows logon events (Event ID 4624) are a crucial data source for tracking lateral movement. A hunter needs to pay close attention to the **Logon Type**. For example:</p><ul><li><strong>Logon Type 3 (Network):</strong> Indicates a user connecting to a file share (`\\hostname\C$`).</li><li><strong>Logon Type 10 (RemoteInteractive):</strong> Indicates an RDP session.</li></ul><p>By correlating these events across hosts, a hunter can trace an attacker's path through the network.</p>"
                }
              ],
              "codeExamples": [
              {
                "title": "Splunk Query to Hunt for PsExec-like Activity",
                "language": "spl",
                "code": "(* This Splunk query hunts for the primary artifact of PsExec usage.\n   When PsExec runs, it creates and starts a temporary service on the target machine.\n   Finding a service being created with a suspicious name and then deleted is a high-fidelity indicator. *)\n\nindex=sysmon EventCode=1 Image=\"*\\\\services.exe\" ParentImage=\"*\\\\services.exe\" CommandLine IN (\"*create*\", \"*start*\", \"*delete*\")\n| stats values(CommandLine) as Actions by host, User\n| where mvcount(Actions) >= 2 AND like(mvindex(Actions,0), \"%create%\")"
              },
              {
                "title": "KQL Query for Suspicious Remote Logons",
                "language": "kql",
                "code": "// This KQL query is for Microsoft Sentinel. It hunts for suspicious patterns in authentication logs.\n// This specific query looks for network logons (Type 3) that are coming from an unusual\n// or non-administrative workstation, which could be a sign of an attacker moving laterally.\nSecurityEvent\n| where EventID == 4624 and LogonType == 3\n// A defender would enrich this with a list of known admin workstations and servers\n| where IpAddress !in (known_admin_ips)\n| summarize count() by Account, IpAddress, WorkstationName"
              },
              {
                "title": "PowerShell Script to Check RDP Sessions",
                "language": "powershell",
                "code": "# A defender runs this during a live investigation to see who is currently logged into a server via RDP.\n# The `qwinsta` command (Query Session) lists all terminal services sessions.\nqwinsta\n\n# A hunter could also parse the RDP event logs (TerminalServices-LocalSessionManager)\nGet-WinEvent -LogName 'Microsoft-Windows-TerminalServices-LocalSessionManager/Operational' | Where-Object { $_.ID -eq 21 } # Session Logon"
              },
              {
                "title": "Sigma Rule for Remote Service Creation",
                "language": "yaml",
                "code": "# Defenders use this Sigma rule to detect when one host uses the 'sc.exe' utility\n# to create a new service on another host, a very common lateral movement technique.\ntitle: Remote Service Creation with SC.exe\nstatus: stable\nlogsource:\n    product: windows\n    category: process_creation\ndetection:\n    selection:\n        Image|endswith: '\\sc.exe'\n        CommandLine|contains|all:\n            - 'create'\n            - '\\\\'\n    condition: selection"
              }
              ],
              "activities": [
                {
                  "title": "Trace Lateral Movement from Benign Event Logs",
                  "description": "Given a set of simulated Windows Event Logs from two machines, 'Workstation-1' and 'Server-1', find the events that show a user successfully logging into Workstation-1 with Logon Type 2 (Interactive), and then later, an event on Server-1 showing the same user logging in with Logon Type 3 (Network) from Workstation-1's IP address. This demonstrates how to manually trace a user's path between hosts."
                }
              ]
            },
            "quiz": {
              "passingScore": 80,
              "questions": [
                {
                  "id": 1,
                  "question": "An attacker compromising one machine and then using that machine to access another is an example of what?",
                  "options": ["Persistence", "Initial Access", "Lateral Movement", "Exfiltration"],
                  "correct": 2,
                  "explanation": "Lateral movement describes the techniques adversaries use to move through a network after gaining an initial foothold."
                },
                {
                  "id": 2,
                  "question": "A hunter is analyzing Windows authentication logs. What Logon Type would indicate a Remote Desktop Protocol (RDP) session?",
                  "options": ["Logon Type 2 (Interactive)", "Logon Type 3 (Network)", "Logon Type 5 (Service)", "Logon Type 10 (RemoteInteractive)"],
                  "correct": 3,
                  "explanation": "Logon Type 10 is specifically for interactive logons that come over a remote protocol like RDP, making it a critical indicator for hunters to monitor."
                }
              ]
            }
        },
        {
            "id": "lesson-9",
            "title": "Module 3: Host-Based Hunting (Linux & Cloud) - Linux Host Hunting",
            "duration": "90 min",
            "objectives": [
              "Understand key log sources on Linux (`auditd`, `syslog`, authentication logs).",
              "Hunt for suspicious process execution and command-line arguments.",
              "Analyze authentication logs (`/var/log/auth.log`) for suspicious logins.",
              "Detect persistence via `cron` jobs and `systemd` services."
            ],
            "content": {
              "overview": "While many corporate environments are Windows-dominant, most cloud infrastructure and servers run on Linux. This lesson covers the fundamentals of threat hunting on Linux hosts, focusing on the key log files and techniques for finding common adversary TTPs.",
              "sections": [
                {
                  "title": "Key Log Sources and Tools",
                  "content": "<ul><li><strong>`auditd` (The Audit Daemon):</strong> The Linux equivalent of Sysmon. It can be configured to generate detailed logs for syscalls, process execution, and file access. It is the most valuable data source for Linux hunting.</li><li><strong>Authentication Logs:</strong> On Debian-based systems, `/var/log/auth.log` (or `/var/log/secure` on RedHat-based systems) records all authentication attempts, `sudo` usage, and SSH logins.</li><li><strong>Bash History:</strong> Each user's `~/.bash_history` file can reveal the exact commands they have run.</li></ul>"
                }
              ],
              "codeExamples": [
              {
                "title": "Query `auditd` Logs with `ausearch`",
                "language": "bash",
                "code": "# A defender uses the `ausearch` command to query the audit logs for specific events.\n# This command hunts for all process execution events (syscall `execve`) and formats the output.\nausearch -sc execve -i"
              },
              {
                "title": "Splunk Query to Hunt for Interactive Shells",
                "language": "spl",
                "code": "(* Attackers often spawn interactive shells in reverse from a compromised server.\n   This Splunk query hunts for a common sign of this: a web server process\n   spawning a shell process, which is highly anomalous. *)\n\nindex=linux sourcetype=auditd type=SYSCALL proctitle IN (\"httpd\", \"nginx\", \"apache2\") a0=bash\n| table _time, host, proctitle, exe"
              },
              {
                "title": "Bash Script to Find Suspicious Cron Jobs",
                "language": "bash",
                "code": "# Malware on Linux often uses cron jobs for persistence.\n# A defender would run this script to audit all cron jobs on a system and flag any that\n# look suspicious (e.g., are obfuscated or run from `/tmp`).\n(crontab -l; cat /etc/crontab /etc/cron.*/*) | grep -v '^[[:space:]]*#'"
              },
              {
                "title": "Grep for Failed SSH Logins",
                "language": "bash",
                "code": "# This is a simple but effective hunt that a defender would run on a Linux server.\n# It searches the authentication log for failed password attempts, which could indicate a brute-force attack.\ngrep \"Failed password for\" /var/log/auth.log | cut -d' ' -f9,11 | sort | uniq -c"
              }
              ],
              "activities": [
                {
                  "title": "Analyze Benign Linux Auth Logs",
                  "description": "Given a sample `auth.log` file, use `grep`, `awk`, and `sort` to answer several questions: 1. Which user had the most successful `sudo` commands? 2. How many unique IP addresses had a failed SSH login attempt? 3. Was there a successful login from an IP address that also had previous failed attempts?"
                }
              ]
            },
            "quiz": {
              "passingScore": 80,
              "questions": [
                {
                  "id": 1,
                  "question": "On a Linux system, what is the most comprehensive data source for hunting, analogous to Sysmon on Windows?",
                  "options": ["`/var/log/syslog`", "The `auditd` service", "`~/.bash_history`", "The `/etc/passwd` file"],
                  "correct": 1,
                  "explanation": "The Linux Audit Daemon (`auditd`) can be configured to provide deep, kernel-level logging of syscalls and other events, making it the richest data source for hunters."
                },
                {
                  "id": 2,
                  "question": "A hunter observes an entry in `/etc/crontab` that executes a script from the `/tmp/` directory every 5 minutes. This is a strong indicator of what?",
                  "options": ["A normal system update.", "Persistence.", "A user logging out.", "A network connection."],
                  "correct": 1,
                  "explanation": "`cron` is the standard Linux job scheduler, and it is one of the most common techniques adversaries use to achieve persistence on Linux hosts (ATT&CK T1053.003)."
                }
              ]
            }
        },
        {
            "id": "lesson-10",
            "title": "Module 3: Host-Based Hunting (Linux & Cloud) - Cloud Hunting Basics",
            "duration": "120 min",
            "objectives": [
                "Understand the importance of cloud provider audit logs (CloudTrail, Cloud Audit Logs).",
                "Hunt for suspicious IAM activity, such as privilege escalation.",
                "Hunt for misconfigurations in cloud storage and databases.",
                "Correlate cloud events with host and network telemetry."
            ],
            "content": {
                "overview": "Threat hunting in the cloud requires a different set of skills and data sources. Instead of focusing only on individual hosts, a cloud hunter must analyze the logs of the cloud control plane itself. This lesson introduces the core concepts of hunting for adversary activity within a major cloud provider's environment.",
                "sections": [
                    {
                        "title": "Hunting in CloudTrail (AWS)",
                        "content": "<p>AWS CloudTrail records every single API call made in your AWS account. It is the definitive record of who did what, when, and from where. A hunter can query CloudTrail to find a huge range of malicious activity:</p><ul><li><strong>IAM Privilege Escalation:</strong> An attacker with low privileges creating a new admin user for themselves. Hunt for events like `CreateUser`, `AttachUserPolicy`.</li><li><strong>Defense Evasion:</strong> An attacker trying to cover their tracks. Hunt for events like `DeleteTrail`, `StopLogging`.</li><li><strong>Resource Abuse:</strong> An attacker launching a large number of VMs for cryptomining. Hunt for a spike in `RunInstances` events from an unusual user or region.</li></ul>"
                    },
                    {
                        "title": "Correlating Cloud and Host Events",
                        "content": "<p>The most powerful hunts combine data sources. For example, a hunter might observe a suspicious process running on an EC2 instance in their host logs (Sysmon). They can then pivot to the CloudTrail logs to answer the question: 'Who launched this instance and when?' This correlation allows the hunter to trace the attack back to the initial point of compromise, which might have been a stolen set of developer credentials.</p>"
                    }
                ],
                "codeExamples":[
                {
                    "title": "AWS CLI Query to Hunt for IAM Policy Changes",
                    "language": "bash",
                    "code": "# A defender runs this AWS CLI command to hunt for a very suspicious activity:\n# a user or role having a new IAM policy attached to it. This is a key indicator\n# of a privilege escalation attempt.\naws cloudtrail lookup-events \\\n  --lookup-attributes AttributeKey=EventName,AttributeValue=AttachUserPolicy \\\n  --query 'Events[].CloudTrailEvent' \\\n  --output text"
                },
                {
                    "title": "Splunk Query to Detect CloudTrail Logging Disabled",
                    "language": "spl",
                    "code": "(* This is a high-severity alert for any SIEM. A defender must know immediately if an attacker\n   is attempting to disable CloudTrail to cover their tracks. *)\n\nindex=aws sourcetype=aws:cloudtrail eventName IN (\"StopLogging\", \"DeleteTrail\")\n| table _time, userIdentity.arn, eventName, awsRegion, sourceIPAddress"
                },
                {
                    "title": "KQL Query for Suspicious GCS Bucket Access",
                    "language": "kql",
                    "code": "// A defender uses this query in Azure Sentinel (connected to GCP) to hunt for data exfiltration.\n// It looks for a large number of objects being downloaded from a Google Cloud Storage bucket\n// by an account that is not a known service account.\nlet serviceAccounts = dynamic([\"project@...\", \"...\" ]);\nGCPCloudAudit\n| where Operation =~ \"storage.objects.get\"\n| where PrincipalEmail !in (serviceAccounts)\n| summarize count() by PrincipalEmail, acls.callerIp\n| where count_ > 100 // High threshold for bulk download"
                },
                {
                    "title": "Sigma Rule for Creating a New EC2 Instance with a New IAM Role",
                    "language": "yaml",
                    "code": "# A sophisticated attacker might create a new instance with a new, privileged role attached.\n# This Sigma rule helps a defender correlate these two cloud events happening in a short time frame\n# to detect this advanced TTP.\ntitle: EC2 Instance Launched With New Role\nstatus: experimental\nlogsource:\n    service: cloudtrail\ndetection:\n    selection_create_role:\n        eventName: 'CreateRole'\n    selection_run_instance:\n        eventName: 'RunInstances'\n        responseElements.instancesSet.items.iamInstanceProfile.arn: # Field containing the new role ARN\n    timeframe: 10m\n    condition: selection_create_role and selection_run_instance"
                }
              ],
                "activities": [
                    {
                        "title": "Analyze Benign CloudTrail Logs",
                        "description": "Given a sample JSON file of benign CloudTrail logs, write a script (using Python or `jq`) to find all events where the `eventName` is `ConsoleLogin` and the `responseElements.ConsoleLogin` is `Success`. For each of these events, extract and print the timestamp, the user's identity (ARN), and their source IP address. This simulates a basic login audit."
                    }
                ]
            },
            "quiz": {
              "passingScore": 80,
              "questions": [
                {
                  "id": 1,
                  "question": "Which cloud log source is most critical for hunting for suspicious IAM activity like an attacker creating a new admin user?",
                  "options": ["VPC Flow Logs", "EC2 instance syslogs", "AWS CloudTrail / GCP Cloud Audit Logs", "Billing logs"],
                  "correct": 2,
                  "explanation": "Cloud provider audit logs are the source of truth for all API activity against the cloud control plane, which includes all IAM-related events."
                },
                {
                  "id": 2,
                  "question": "A hunter observes an alert for `DeleteTrail` in the AWS CloudTrail logs. This is a strong indicator of which ATT&CK tactic?",
                  "options": ["Initial Access", "Persistence", "Defense Evasion", "Impact"],
                  "correct": 2,
                  "explanation": "Deleting or stopping the audit trail is a classic defense evasion technique (T1562.008) used by attackers to cover their tracks and prevent investigation."
                }
              ]
            }
        },
        {
            "id": "lesson-11",
            "title": "Module 4: Network-Based Hunting - PCAP & Zeek/Suricata Fundamentals",
            "duration": "120 min",
            "objectives": [
                "Understand the difference between full packet capture (PCAP) and network flow data.",
                "Introduce Network Security Monitoring (NSM) tools like Zeek and Suricata.",
                "Use Zeek to process a PCAP and generate rich, structured log files.",
                "Analyze Zeek's `conn.log` and `http.log` to investigate benign traffic."
            ],
            "content": {
                "overview": "While host logs provide deep visibility, network telemetry is essential for seeing the full picture of an attack. This lesson introduces the fundamentals of network traffic analysis, comparing raw packet capture with the much more powerful structured logs generated by Network Security Monitoring (NSM) tools.",
                "sections": [
                    {
                        "title": "PCAP vs. NSM Logs",
                        "content": "<ul><li><strong>PCAP (Packet Capture):</strong> This is the raw, byte-for-byte copy of every packet that crosses the wire. It is the ultimate ground truth but is very large and difficult to search through.</li><li><strong>NSM Logs (Zeek/Suricata):</strong> These tools act as a 'network flight data recorder'. They listen to network traffic but instead of saving every packet, they parse the protocols and generate high-level, structured, human-readable log files. For example, instead of seeing a thousand individual packets, Zeek will produce a single line in `http.log` summarizing the entire HTTP request.</li></ul>"
                    },
                    {
                        "title": "Introduction to Zeek",
                        "content": "<p>Zeek (formerly Bro) is an open-source NSM tool. It is not an active intrusion detection system (IDS) that blocks traffic. Instead, it is a passive sensor that provides incredibly detailed logs about the traffic it sees. Its logs (like `conn.log`, `http.log`, `dns.log`, `ssl.log`) are the primary data source for network threat hunters.</p>"
                    }
                ],
                "codeExamples": [
                {
                    "title": "Analyze a PCAP with Tshark",
                    "language": "bash",
                    "code": "# Tshark is the command-line version of Wireshark. A defender uses it for quick analysis of PCAPs.\n# This command reads a PCAP file and prints a summary of the two endpoints for each conversation.\ntshark -r benign.pcap -T fields -e ip.src -e ip.dst -e tcp.srcport -e tcp.dstport -e udp.srcport -e udp.dstport"
                },
                {
                    "title": "Process a PCAP with Zeek",
                    "language": "bash",
                    "code": "# This is the fundamental workflow for a network hunter.\n# The command tells Zeek to read a raw PCAP file and produce its full set of structured log files\n# (`conn.log`, `http.log`, `dns.log`, etc.) in the current directory.\nzeek -r benign.pcap"
                },
                {
                    "title": "Analyze Zeek Logs with `zeek-cut`",
                    "language": "bash",
                    "code": "# After processing a PCAP, a defender uses `zeek-cut` to extract specific columns from the logs.\n# This command shows the timestamp, source IP, destination IP, and duration for every connection\n# recorded in the connection log.\ncat conn.log | zeek-cut ts id.orig_h id.resp_h duration"
                },
                {
                    "title": "Analyze HTTP Traffic with `zeek-cut`",
                    "language": "bash",
                    "code": "# This command helps a defender investigate web traffic.\n# It extracts the source IP, host requested, URI, and User-Agent from the `http.log`.\ncat http.log | zeek-cut ts id.orig_h host uri user_agent"
                }
              ],
                "activities": [
                    {
                        "title": "Analyze a Benign PCAP with Zeek",
                        "description": "Given a sample PCAP file of benign web browsing activity, use the `zeek -r` command to generate the full set of Zeek logs. Then, use `zeek-cut` and other command-line tools to answer several questions: 1. What was the longest-duration TCP connection? 2. What were all the unique HTTP User-Agents seen in the traffic? 3. Which website was visited most frequently?"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary advantage of using Zeek logs over raw PCAP files for threat hunting?",
                        "options": ["Zeek logs are encrypted.", "Zeek logs provide high-level, structured summaries of network activity, which are much easier and faster to search than raw packets.", "Zeek can block malicious traffic.", "PCAP files do not contain the full packet data."],
                        "correct": 1,
                        "explanation": "Zeek turns a massive, unstructured data source (PCAP) into a small, structured, and easily searchable set of logs, which is exactly what a hunter needs to analyze large amounts of traffic."
                    },
                    {
                        "id": 2,
                        "question": "In the Zeek logs, which log file would you look in to find a summary of all TCP, UDP, and ICMP connections?",
                        "options": ["`http.log`", "`dns.log`", "`conn.log`", "`ssl.log`"],
                        "correct": 2,
                        "explanation": "`conn.log` is the connection log. It is the foundational log that tracks every network connection at Layer 3/4, regardless of the application protocol."
                    }
                ]
            }
        },
        {
            "id": "lesson-12",
            "title": "Module 4: Network-Based Hunting - Hunting in DNS Traffic",
            "duration": "90 min",
            "objectives": [
                "Understand why DNS traffic is a critical data source for hunters.",
                "Hunt for signs of C2 communication using DNS.",
                "Detect DNS tunneling and Domain Generation Algorithms (DGAs).",
                "Analyze Zeek's `dns.log` for anomalous queries."
            ],
            "content": {
                "overview": "DNS is the phonebook of the internet, and nearly every network connection begins with a DNS query. Because of this, DNS logs provide a high-level overview of all the domains your systems are trying to contact, making it one of the richest data sources for hunting C2 activity.",
                "sections": [
                    {
                        "title": "Detecting C2 Beaconing",
                        "content": "<p>Malware often uses DNS as its primary C2 channel. A hunter can find this by looking for suspicious query patterns:</p><ul><li><strong>High Frequency Queries:</strong> A host repeatedly querying for the same obscure domain every few seconds is a strong sign of beaconing.</li><li><strong>Anomalous Query Types:</strong> Malware might use unusual record types like `TXT` or `CNAME` to encode data.</li></ul>"
                    },
                    {
                        "title": "DNS Tunneling and DGAs",
                        "content": "<ul><li><strong>DNS Tunneling:</strong> A technique where an attacker exfiltrates data by encoding it in a series of DNS queries (e.g., `<base64-encoded-data>.evil.com`). The attacker's malicious DNS server receives these queries and reconstructs the data.</li><li><strong>Domain Generation Algorithms (DGA):</strong> Sophisticated malware doesn't use a hardcoded list of C2 domains. Instead, it generates thousands of pseudo-random domains per day and tries to contact them. The attacker only needs to register one of these domains for the C2 to work. A hunter detects DGAs by looking for hosts that generate a large number of failed DNS lookups (NXDOMAIN errors) for domains with high entropy (random-looking names).</li></ul>"
                    }
                ],
                "codeExamples": [
                {
                    "title": "Splunk Query to Find High-Entropy Domains",
                    "language": "spl",
                    "code": "(* A defender uses this query in Splunk to hunt for DGA activity.\n   It calculates the entropy of the domain name for each DNS query and flags domains\n   that look too random, which is a key characteristic of DGAs. (Requires an entropy calculation app/macro). *)\n\nindex=zeek sourcetype=zeek:dns\n| eval domain_entropy = shannon_entropy(query)\n| where domain_entropy > 4.5\n| stats count by query, src_ip\n| sort - count"
                },
                {
                    "title": "KQL Query to Hunt for High TXT Query Ratio",
                    "language": "kql",
                    "code": "// DNS tunneling often abuses TXT records. A defender uses this KQL query in Sentinel\n// to find hosts where the ratio of TXT queries to normal A/AAAA queries is anomalously high.\nDnsEvents\n| summarize a_queries = countif(QueryType == \"A\" or QueryType == \"AAAA\"), txt_queries = countif(QueryType == \"TXT\") by ClientIP\n| where txt_queries > 10 and a_queries > 0\n| extend txt_ratio = toreal(txt_queries) / toreal(a_queries)\n| where txt_ratio > 0.5"
                },
                {
                    "title": "Find Most Frequent DNS Queries with `zeek-cut`",
                    "language": "bash",
                    "code": "# This is a simple but powerful command-line hunt. A defender uses it to analyze a Zeek DNS log.\n# It counts the number of times each unique domain was queried and sorts it.\n# This quickly reveals repetitive beaconing behavior.\ncat dns.log | zeek-cut query | sort | uniq -c | sort -rn | head -20"
                },
                {
                    "title": "Python Script to Detect DGA-like Domains",
                    "language": "python",
                    "code": "# This script shows the logic a defender would use to score domains for randomness.\n# It combines several heuristics (entropy, number ratio) to identify domains likely generated by an algorithm.\n# import math\n\ndef is_dga_like(domain):\n    entropy = shannon_entropy(domain.split('.')[0])\n    digit_ratio = sum(c.isdigit() for c in domain) / len(domain)\n    if entropy > 4.0 and digit_ratio > 0.2:\n        return True\n    return False\n\n# for domain in all_domains:\n#     if is_dga_like(domain):\n#         print(f'[ALERT] DGA-like domain detected: {domain}')"
                }
              ],
                "activities": [
                    {
                        "title": "Hunt for Anomalies in DNS Logs",
                        "description": "Given a simulated `dns.log` file from Zeek that contains benign traffic mixed with some simulated DGA and beaconing traffic, use command-line tools (`awk`, `sort`, `uniq`, etc.) to perform several hunts: 1. Find the top 10 most frequently requested domains. 2. Find all the queries that resulted in an `NXDOMAIN` (non-existent domain) error. 3. Find any queries for domains that are unusually long (e.g., > 30 characters)."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "A hunter observes a host on their network making DNS queries for thousands of random-looking domains (e.g., `asdf89uh23rff.com`, `89uh23rfnoia.com`) and receiving an `NXDOMAIN` (non-existent) response for almost all of them. This is a strong indicator of what?",
                        "options": ["Normal web browsing.", "A Domain Generation Algorithm (DGA).", "A port scan.", "A network misconfiguration."],
                        "correct": 1,
                        "explanation": "This specific pattern—a high volume of failed lookups for high-entropy domains—is the classic signature of DGA-based C2 communication."
                    },
                    {
                        "id": 2,
                        "question": "What is DNS tunneling?",
                        "options": ["A method for making DNS faster.", "The process of encrypting DNS traffic.", "A technique for exfiltrating data by encoding it into a series of DNS queries, often using TXT records.", "A type of VPN."],
                        "correct": 2,
                        "explanation": "DNS tunneling abuses the DNS protocol itself to carry data for another purpose, often allowing an attacker to bypass firewalls that allow DNS traffic but block other protocols."
                    }
                ]
            }
        },
        {
            "id": "lesson-13",
            "title": "Module 4: Network-Based Hunting - Hunting in HTTP/S Traffic",
            "duration": "120 min",
            "objectives": [
                "Hunt for suspicious User-Agent strings and other anomalous HTTP headers.",
                "Understand how TLS/SSL metadata (JA3/JA3S) can be used to fingerprint malware.",
                "Detect C2 communication hidden in seemingly normal web traffic.",
                "Analyze Zeek's `http.log` and `ssl.log` for indicators of compromise."
            ],
            "content": {
                "overview": "HTTP and HTTPS are the dominant protocols on the internet, and attackers love to use them for C2 because this traffic blends in with normal web browsing and is allowed through most firewalls. This lesson focuses on the subtle indicators within web traffic that can reveal a hidden threat.",
                "sections": [
                    {
                        "title": "Hunting in HTTP Headers",
                        "content": "<p>Even without seeing the content of a request, the HTTP headers can be very revealing:</p><ul><li><strong>User-Agent:</strong> Legitimate web browsers have very specific, complex User-Agent strings. Many types of malware use a non-standard, simple User-Agent (like `curl/7.58.0` or a blank string) that stands out immediately.</li><li><strong>POST Requests:</strong> Malware often uses POST requests to exfiltrate data. A hunter will look for POSTs to unusual, non-API-like URIs, or POSTs with a strange content type.</li></ul>"
                    },
                    {
                        "title": "Hunting in Encrypted Traffic (JA3/JA3S)",
                        "content": "<p>While we can't see the content of HTTPS traffic, we can still analyze the metadata of the TLS handshake. <strong>JA3</strong> is a method for creating an MD5 hash of the way a client announces itself during the TLS setup (the ciphers it supports, the extensions it offers, etc.). Specific client applications (like a browser or a piece of malware) will almost always use the same set of parameters, resulting in the same JA3 hash. This allows a defender to fingerprint malware's TLS client, even though the traffic is encrypted. <strong>JA3S</strong> is the same concept for the server's response.</p>"
                    }
                ],
                "codeExamples": [
                {
                    "title": "Splunk Query to Find Rare User-Agents",
                    "language": "spl",
                    "code": "(* Attackers often use uncommon or default User-Agent strings for their malware.\n   This Splunk query finds the rarest User-Agent strings seen in the environment,\n   which are the most likely to be malicious. *)\n\nindex=zeek sourcetype=zeek:http\n| rare limit=20 user_agent"
                },
                {
                    "title": "KQL Query to Hunt for known-bad JA3 Hashes",
                    "language": "kql",
                    "code": "// A defender can maintain a list of JA3 hashes associated with known malware families.\n// This KQL query (for Azure Sentinel/MDE) hunts through TLS logs for any connection\n// that uses one of these known-bad JA3 fingerprints.\nlet known_bad_ja3 = dynamic([\"e7d4b428d...\", \"d4e5a914c...\"]);\nVMConnection\n| extend Ja3Hash = todynamic(AdditionalFields).ja3\n| where Ja3Hash in (known_bad_ja3)"
                },
                {
                    "title": "Find All POST Requests with `zeek-cut`",
                    "language": "bash",
                    "code": "# A defender uses this command-line hunt to quickly review all HTTP POST requests.\n# They would look for POSTs to suspicious domains or URIs that don't look like normal web forms.\ncat http.log | zeek-cut method host uri | grep POST"
                },
                {
                    "title": "Python Script to Calculate JA3 Hash with Scapy",
                    "language": "python",
                    "code": "# This script demonstrates the logic behind JA3. It uses Scapy to parse a ClientHello\n# packet and builds the string of TLS artifacts that would then be hashed to create the fingerprint.\n# (This is a simplified implementation for educational purposes)\n\n# from scapy.all import TLSClientHello\n\n# def get_ja3_string(client_hello):\n#     tls_version = client_hello.version\n#     cipher_suites = \":\".join(map(str, client_hello.ciphers))\n#     extensions = \":\".join(map(str, client_hello.exts))\n#     # ... and so on for elliptic curves and formats\n#     return f\"{tls_version},{cipher_suites},{extensions},...\"\n# # The final string would be MD5 hashed"
                }
              ],
                "activities": [
                    {
                        "title": "Hunt for Anomalous User-Agents",
                        "description": "Given a simulated `http.log` from Zeek, write a command-line pipeline (using `zeek-cut`, `sort`, `uniq`, etc.) that will list all unique User-Agent strings and the number of times they appeared. Analyze the list to find any that look suspicious (e.g., they are very simple, are missing, or identify themselves as a non-browser tool like `curl` or `wget`)."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "When hunting in HTTP logs, why is the `User-Agent` string a valuable indicator?",
                        "options": ["It shows the user's password.", "Malware often uses hardcoded, non-standard, or missing User-Agent strings that differ significantly from the complex and consistent strings used by legitimate web browsers.", "It is always encrypted.", "It shows the destination IP address."],
                        "correct": 1,
                        "explanation": "Because attackers are often lazy or use standard HTTP libraries, their malware's User-Agent often stands out as being different from the millions of legitimate browser connections, making it a powerful hunting pivot."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary benefit of using JA3/JA3S hashing for threat hunting?",
                        "options": ["It decrypts TLS traffic.", "It blocks malicious connections.", "It allows a defender to create a fingerprint of the client-side or server-side TLS implementation, which can be used to identify specific malware families even when the traffic is encrypted.", "It tells you the username of the person making the connection."],
                        "correct": 2,
                        "explanation": "JA3 is a technique for fingerprinting encrypted clients based on the *metadata* of their connection, not the content. This makes it an invaluable tool for hunting in the modern, encrypted internet."
                    }
                ]
            }
        },
        {
            "id": "lesson-14",
            "title": "Module 4: Network-Based Hunting - Detecting Beaconing & C2",
            "duration": "90 min",
            "objectives": [
              "Define C2 beaconing and its key characteristics (frequency, jitter, size).",
              "Use statistical analysis and data visualization to find beaconing behavior.",
              "Hunt for beaconing in different log sources (firewall, Zeek, proxy).",
              "Differentiate between legitimate and malicious periodic traffic."
            ],
            "content": {
              "overview": "Command-and-control (C2) beaconing is the heartbeat of a malware infection. It's the periodic communication that allows the implant to receive tasks and exfiltrate data. Detecting this often subtle, 'low and slow' traffic is a quintessential threat hunting skill. This lesson focuses on the data analysis techniques used to find these regular signals in the noise.",
              "sections": [
                {
                  "title": "Characteristics of Beaconing",
                  "content": "<ul><li><strong>Regularity:</strong> The most obvious sign is a connection to the same destination at a very regular interval (e.g., every 5 minutes).</li><li><strong>Jitter:</strong> To evade simple statistical detection, attackers often add 'jitter', or a small amount of randomization, to the beacon interval (e.g., every 5 minutes +/- 30 seconds).</li><li><strong>Consistent Size:</strong> Beacons are often small and have a very consistent payload size for both the request and response.</li></ul>"
                }
              ],
              "codeExamples":[
              {
                "title": "Splunk Query to Find Beacons using Stats",
                "language": "spl",
                "code": "(* This is an advanced Splunk query that defenders use to hunt for beaconing.\n   It groups connections by source and destination, calculates the time difference between connections,\n   and then calculates the standard deviation of those time differences.\n   A very low standard deviation indicates a highly regular, programmatic connection. *)\n\nindex=firewall\n| sort 0 + _time\n| streamstats current=f window=1 global=f by src_ip, dest_ip values(_time) as last_time\n| eval delta = _time - last_time\n| stats count, stdev(delta) as jitter by src_ip, dest_ip\n| where count > 50 and jitter < 5"
              },
              {
                "title": "KQL Query to Find Beacons (Simplified)",
                "language": "kql",
                "code": "// This simplified KQL query for Sentinel hunts for beaconing.\n// It groups connections by source, destination, and a 1-hour time window.\n// It then looks for a high number of connections with very few bytes transferred in each direction,\n// which is characteristic of simple check-in beacons.\nCommonSecurityLog\n| summarize ConnectionCount=count(), TotalBytesSent=sum(SentBytes), TotalBytesReceived=sum(ReceivedBytes) by SourceIP, DestinationIP, bin(TimeGenerated, 1h)\n| where ConnectionCount > 100\n| extend AvgBytesSent = TotalBytesSent / ConnectionCount\n| where AvgBytesSent < 256"
              },
              {
                "title": "Analyze Zeek Logs for Beacons with RITA",
                "language": "bash",
                "code": "# RITA is an open-source tool specifically designed to hunt for beaconing in Zeek logs.\n# A defender would import their Zeek logs into RITA and let its algorithms automatically analyze them.\n# The `show-beacons` command provides a clean report of likely C2 activity.\n\nrita import /path/to/zeek_logs my_dataset\nrita show-beacons my_dataset"
              },
              {
                "title": "Python Script to Calculate Beaconing 'Jitter'",
                "language": "python",
                "code": "# This script shows the core logic that a tool like RITA or a SIEM query would use.\n# A defender gives it a list of timestamps for a specific connection pair and it calculates\n# the standard deviation (jitter) to measure how regular the connection is.\nimport statistics\n\n# Timestamps of connections from a benign, user-driven session (high jitter)\nuser_traffic = [100, 105, 120, 150, 152]\n# Timestamps of connections from a malware beacon (low jitter)\nmalware_beacon = [300, 360, 421, 480, 542] # every ~60 seconds\n\ndef calculate_jitter(timestamps):\n    deltas = [timestamps[i+1] - timestamps[i] for i in range(len(timestamps)-1)]\n    if len(deltas) < 2: return 0\n    return statistics.stdev(deltas)\n\nprint(f'User Jitter: {calculate_jitter(user_traffic):.2f}')\nprint(f'Malware Jitter: {calculate_jitter(malware_beacon):.2f}')"
              }
              ],
              "activities": [
                {
                  "title": "Inspect Benign PCAP for Beaconing Patterns",
                  "description": "Given a simulated PCAP file containing both benign user traffic and a simulated C2 beacon, process it with Zeek. Analyze the `conn.log`. Using command-line tools or a simple script, calculate the time deltas between connections for various source/destination pairs. Identify the connection pair that has a very low standard deviation in its time deltas—this is your beacon."
                }
              ]
            },
            "quiz": {
              "passingScore": 80,
              "questions": [
                {
                  "id": 1,
                  "question": "What is 'jitter' in the context of C2 beaconing?",
                  "options": ["A measure of how fast the connection is.", "A small amount of randomization added to the beaconing interval to make it less predictable.", "The encryption key used by the beacon.", "A type of network error."],
                  "correct": 1,
                  "explanation": "Jitter is an evasion technique used by attackers to defeat simple statistical analysis that only looks for perfectly regular beaconing."
                },
                {
                  "id": 2,
                  "question": "When hunting for beaconing, a data analyst is primarily looking for what characteristic in connection logs?",
                  "options": ["High volume of data transfer.", "Connections to many different destinations.", "Repetitive connections to the same destination with a low standard deviation in their time intervals.", "Encrypted connections."],
                  "correct": 2,
                  "explanation": "Statistical regularity is the primary fingerprint of automated, programmatic C2 communication. Human-generated traffic is, by its nature, much more random."
                }
              ]
            }
        },
        {
            "id": "lesson-15",
            "title": "Module 4: Network-Based Hunting - Detecting Data Exfiltration",
            "duration": "90 min",
            "objectives": [
                "Define data exfiltration and common techniques (large transfers, DNS tunneling).",
                "Hunt for signs of internal data staging.",
                "Use NetFlow and firewall logs to hunt for large outbound data transfers.",
                "Analyze traffic for protocols that are unusual for your environment."
            ],
            "content": {
                "overview": "The ultimate goal for many adversaries is to steal sensitive data. The process of smuggling this data out of the network is called 'exfiltration'. This lesson covers the common TTPs used for data exfiltration and the data sources a hunter uses to detect them.",
                "sections": [
                    {
                        "title": "Data Staging",
                        "content": "<p>Before exfiltrating data, attackers often collect it from multiple sources and aggregate it in one place, a process called 'staging'. This might involve creating a large, encrypted archive (like a `.zip` or `.rar` file) in a temporary directory on a compromised server. A hunter can detect this by monitoring file creation events (Sysmon Event ID 11) for unusually large archive files being created, or by monitoring for the execution of archiving tools like `7z.exe` on servers where they don't belong.</p>"
                    },
                    {
                        "title": "Detecting Large Outbound Transfers",
                        "content": "<p>The most straightforward exfiltration method is to simply send the data out. A hunter can detect this by analyzing NetFlow data or firewall logs to find connections with an anomalously high number of bytes sent from an internal host to an external destination. The key is to have a baseline of what 'normal' large transfers look like in your environment.</p>"
                    }
                ],
                "codeExamples": [
                {
                    "title": "Splunk Query for Large Outbound Transfers",
                    "language": "spl",
                    "code": "(* This Splunk query hunts for potential data exfiltration. It analyzes firewall logs\n   to find internal hosts that are sending an unusually large amount of data (e.g., > 100MB)\n   to an external destination. *)\n\nindex=firewall action=allow direction=outbound\n| stats sum(bytes_out) as TotalBytes by src_ip, dest_ip\n| where TotalBytes > 100000000\n| eval TotalMB = round(TotalBytes/1024/1024, 2)\n| table src_ip, dest_ip, TotalMB\n| sort - TotalMB"
                },
                {
                    "title": "KQL Query for Data Staging (File Creation)",
                    "language": "kql",
                    "code": "// A defender uses this KQL query in Sentinel to hunt for data staging activity.\n// It looks for the creation of common archive files, which could be an attacker preparing data for exfiltration.\nDeviceFileEvents\n| where FileName has_any (\".zip\", \".rar\", \".7z\") and ActionType == \"FileCreated\"\n// Exclude common locations to reduce noise\n| where FolderPath !contains \"\\\\Downloads\\\\\""
                },
                {
                    "title": "Hunt for Unusual Protocols with `zeek-cut`",
                    "language": "bash",
                    "code": "# Most corporate environments have very predictable network traffic.\n# This command helps a defender find outliers by showing all the services/protocols observed\n# in the Zeek connection log. Seeing an unexpected protocol like `IRC` could be a sign of a C2 channel.\ncat conn.log | zeek-cut service | sort | uniq -c | sort -rn"
                },
                {
                    "title": "Sigma Rule for Archiving Tools",
                    "language": "yaml",
                    "code": "# A defender uses this Sigma rule to detect the execution of common command-line\n# archiving tools, which can be a sign of data staging by an attacker.\ntitle: Suspicious Archiving Tool Execution\nstatus: stable\nlogsource:\n    product: windows\n    category: process_creation\ndetection:\n    selection:\n        Image|endswith:\n            - '\\7z.exe'\n            - '\\rar.exe'\n            - '\\winzip.exe'\n        CommandLine|contains: ' a '\n    condition: selection"
                }
              ],
                "activities": [
                    {
                        "title": "Analyze Benign PCAP with Bulk Data Transfer",
                        "description": "Given a simulated PCAP that contains normal web browsing and a single, large benign file upload (e.g., to a file sharing site), process it with Zeek. Analyze the `conn.log`. Using command-line tools, find the connection that has the highest number of `orig_bytes` (bytes sent from the originator/client). Verify that this corresponds to the file upload event."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "An attacker compromising multiple servers, copying sensitive data from each to a single location, and compressing it into a single .zip file is performing what activity?",
                        "options": ["Persistence", "Lateral Movement", "Data Staging", "Initial Access"],
                        "correct": 2,
                        "explanation": "Data staging is the process of collecting and consolidating data before exfiltrating it."
                    },
                    {
                        "id": 2,
                        "question": "Which data source is most effective for hunting for large-volume data exfiltration over the network?",
                        "options": ["Registry logs", "Sysmon process creation logs", "Firewall logs or NetFlow data", "Authentication logs"],
                        "correct": 2,
                        "explanation": "Firewall logs and NetFlow data are specifically designed to provide summary information about network connections, including the total number of bytes transferred, which is exactly what a hunter needs for this type of analysis."
                    }
                ]
            }
        },
        {
            "id": "lesson-16",
            "title": "Module 5: Analytics & Automation - SIEM Querying Masterclass",
            "duration": "120 min",
            "objectives": [
                "Understand the core components of a SIEM query language.",
                "Practice advanced statistical and aggregation commands (`stats`, `summarize`).",
                "Learn how to join and correlate different data sources.",
                "Optimize queries for performance on large datasets."
            ],
            "content": {
                "overview": "The SIEM is the hunter's primary workspace. Mastering the query language of your SIEM is a non-negotiable skill. This lesson is a masterclass in writing effective, efficient, and complex queries using the languages of the two most common SIEM platforms: Splunk (SPL) and Microsoft Sentinel (KQL).",
                "sections": [
                    {
                        "title": "Core Querying Concepts",
                        "content": "<p>While the syntax differs, most query languages share the same core concepts:</p><ul><li><strong>Filtering:</strong> Selecting events based on a condition (e.g., `EventCode=1`, `where ActionType == \"FileCreated\"`).</li><li><strong>Aggregation:</strong> Grouping events by a field and performing a calculation (e.g., `| stats count by src_ip`, `| summarize by Account`).</li><li><strong>Enrichment & Transformation:</strong> Creating new fields based on existing data (e.g., `| eval`, `| extend`).</li><li><strong>Joins & Lookups:</strong> Enriching your events with data from an external source (e.g., joining network events with a threat intelligence feed).</li></ul>"
                    }
                ],
                "codeExamples": [
                {
                    "title": "Splunk Query: Find First Time Seen Process",
                    "language": "spl",
                    "code": "(* This advanced Splunk query helps a defender find new or unusual software.\n   It uses a subsearch and the `map` command to find processes that have been seen running today\n   but have never been seen running before in the past 30 days. *)\n\nindex=sysmon EventCode=1 earliest=-30d@d latest=@d [search index=sysmon EventCode=1 earliest=@d \n| stats count by Image | fields Image]\n| stats earliest(_time) as first_seen by Image\n| where first_seen >= relative_time(now(), \"-24h\")"
                },
                {
                    "title": "KQL Query: Join Network and Process Events",
                    "language": "kql",
                    "code": "// A hunter uses this KQL query to correlate different data types.\n// It finds processes that made a network connection and then enriches that information\n// with the process's command line, which is in a different table.\nDeviceNetworkEvents\n| where RemoteIP != \"127.0.0.1\"\n| lookup kind=inner (DeviceProcessEvents) on DeviceId, InitiatingProcessId"
                },
                {
                    "title": "Splunk Query: Find Outlier Logon Hours",
                    "language": "spl",
                    "code": "(* This hunt looks for users logging on at unusual times.\n   It calculates the normal logon hours for each user and then uses the `anomalydetection`\n   command to find logins that are statistical outliers. *)\n\nindex=security EventCode=4624 LogonType=2\n| bucket _time span=1h\n| stats count by _time, User\n| streamstats window=30 global=f by User avg(count) as moving_avg\n| eventstats global=f by User avg(moving_avg) as overall_avg, stdev(moving_avg) as overall_stdev\n| where moving_avg > overall_avg + (2 * overall_stdev)"
                },
                {
                    "title": "KQL Query: Statistical Rarity",
                    "language": "kql",
                    "code": "// This is a powerful generic hunting query in KQL.\n// It calculates the frequency of every command line seen in the environment.\n// It then flags command lines that are extremely rare, as attackers often use unique\n// or slightly modified commands that stand out statistically.\nDeviceProcessEvents\n| summarize ProcessCount=count() by ProcessCommandLine\n| where ProcessCount < 3"
                }
              ],
                "activities": [
                    {
                        "title": "Write Queries to Find Anomalies",
                        "description": "Given a benign, simulated log dataset (e.g., a CSV of Sysmon events), import it into your lab SIEM. Write and execute three different queries: 1. A query to find the rarest parent process for `cmd.exe`. 2. A query to find the user with the highest number of unique network connections. 3. A query to find the hour of the day with the fewest process executions."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "The `stats count by src_ip` part of a Splunk query is an example of what?",
                        "options": ["Filtering", "Aggregation", "Joining", "Sorting"],
                        "correct": 1,
                        "explanation": "Aggregation is the process of grouping events by a common field (in this case, `src_ip`) and then performing a calculation (in this case, `count`) on each group."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary benefit of joining different data sources (e.g., process logs and network logs) in a hunt?",
                        "options": ["It makes the query run faster.", "It provides a richer, more correlated context for an event, allowing for higher-fidelity detections.", "It is required for all hunts.", "It reduces the amount of data stored."],
                        "correct": 1,
                        "explanation": "Correlation is key. A network connection is interesting, but knowing that the network connection was made by `powershell.exe` which was spawned by `excel.exe` is a much more powerful and actionable finding."
                    }
                ]
            }
        },
        {
            "id": "lesson-17",
            "title": "Module 5: Analytics & Automation - Endpoint Hunting with EDR",
            "duration": "90 min",
            "objectives": [
                "Understand the core capabilities of an Endpoint Detection and Response (EDR) tool.",
                "Differentiate between SIEM hunting (long-term, broad) and EDR hunting (real-time, deep).",
                "Practice analyzing process trees and command-line arguments in an EDR interface.",
                "Learn to pivot from an EDR alert to a broader hunt."
            ],
            "content": {
                "overview": "While a SIEM provides a broad, historical view, an EDR provides a deep, real-time view into the activity on an endpoint. This lesson covers the capabilities of modern EDR solutions and how a hunter uses them to perform deep-dive investigations on a specific host and pivot to organization-wide hunts.",
                "sections": [
                    {
                        "title": "EDR Capabilities",
                        "content": "<p>EDR tools (like Microsoft Defender for Endpoint, CrowdStrike Falcon, SentinelOne) deploy an agent to each endpoint. This agent provides capabilities beyond simple logging:</p><ul><li><strong>Real-time Process Tree:</strong> Provides a live, graphical view of all processes and their parent-child relationships.</li><li><strong>Deep Telemetry:</strong> Records not just process creation, but also module loads, cross-process events, and script execution content.</li><li><strong>Live Response:</strong> Allows an analyst to remotely connect to the endpoint to pull files, kill processes, or isolate the host from the network.</li><li><strong>Proactive Hunting:</strong> EDRs have their own powerful query languages (like KQL for MDE) that allow a hunter to search for TTPs across all endpoints in the organization in near real-time.</li></ul>"
                    }
                ],
                "codeExamples": [
                {
                    "title": "KQL Query for a Suspicious Process Tree (MDE)",
                    "language": "kql",
                    "code": "// A hunter runs this query in Microsoft Defender for Endpoint to find a common attack pattern.\n// It looks for any instance where a Microsoft Office application spawned the `certutil.exe`\n// utility, which can be abused to download malicious files.\nDeviceProcessEvents\n| where InitiatingProcessFileName in~ (\"winword.exe\", \"excel.exe\", \"powerpnt.exe\")\n| where FileName =~ \"certutil.exe\"\n| where ProcessCommandLine has \"-urlcache\" and ProcessCommandLine has \"-f\""
                },
                {
                    "title": "CrowdStrike SPL Query for 'Living off the Land' Binaries",
                    "language": "spl",
                    "code": "(* This query, for an EDR like CrowdStrike that uses SPL, hunts for 'Living off the Land' behavior.\n   It finds instances where legitimate but frequently abused Windows binaries were executed\n   and shows the command line that was used. *)\n\nevent_simpleName=ProcessRollup2 FileName IN (powershell.exe, cmd.exe, wscript.exe, cscript.exe, mshta.exe)\n| stats count by aid, ComputerName, FileName, CommandLine"
                },
                {
                    "title": "Isolate a Host with a Defender for Endpoint API Call",
                    "language": "python",
                    "code": "# EDRs provide APIs for automation. A defender could integrate this logic into a SOAR playbook.\n# When a high-severity alert fires, this script could automatically isolate the compromised machine\n# from the network to contain the threat.\nimport requests\n\n# def isolate_machine(token, machine_id, comment):\n#     url = f'https://api.securitycenter.microsoft.com/api/machines/{machine_id}/isolate'\n#     headers = { 'Authorization': f'Bearer {token}' }\n#     data = { 'Comment': comment, 'IsolationType': 'Full' }\n#     response = requests.post(url, headers=headers, json=data)\n#     return response.status_code"
                },
                {
                    "title": "Live Response: Get a File with PowerShell",
                    "language": "powershell",
                    "code": "# EDRs often have a 'Live Response' feature that gives a hunter a remote shell.\n# From that shell, they could run this command to retrieve a suspicious file from the\n# endpoint for further analysis, without needing to RDP to the machine.\nGet-File -Path \"C:\\Users\\Bob\\AppData\\Local\\Temp\\malicious.exe\""
                }
              ],
                "activities": [
                    {
                        "title": "Analyze Benign EDR Dataset",
                        "description": "Given a CSV export of benign EDR process events, load it into a tool of your choice (Excel, Python, SIEM). Use the data to reconstruct the process tree for a browser launching (e.g., find the `chrome.exe` process and its child GPU and renderer processes). This exercise teaches the fundamentals of analyzing parent-child process relationships."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is a key advantage of hunting in an EDR platform compared to a SIEM?",
                        "options": ["EDR data is stored for longer.", "EDR provides richer, real-time endpoint telemetry and the ability to take immediate response actions on the host.", "EDR is cheaper.", "EDR does not require an agent."],
                        "correct": 1,
                        "explanation": "EDR excels at providing deep, real-time visibility into endpoint behavior and allows for direct interaction with the host (live response), whereas a SIEM is better for long-term analysis and correlation across many different log sources."
                    },
                    {
                        "id": 2,
                        "question": "Analyzing a 'process tree' in an EDR allows a hunter to:",
                        "options": ["See the network connections a process made.", "Understand the parent-child relationships between processes, which helps to identify anomalous execution chains.", "See the files a process created.", "See the registry keys a process modified."],
                        "correct": 1,
                        "explanation": "The process tree provides critical context. A process might be benign on its own, but the fact that it was launched by an unusual parent process is often a strong indicator of attack."
                    }
                ]
            }
        },
        {
            "id": "lesson-18",
            "title": "Module 5: Analytics & Automation - Anomaly Detection Techniques",
            "duration": "90 min",
            "objectives": [
              "Understand the concept of baselining to define 'normal' activity.",
              "Use frequency analysis to find rare and unusual events.",
              "Apply statistical methods (mean, standard deviation) to detect outliers.",
              "Develop a hypothesis for an anomaly-driven hunt."
            ],
            "content": {
              "overview": "While threat-driven hunting looks for known-bad behaviors, anomaly-driven hunting looks for anything that deviates from the normal baseline. This lesson introduces the statistical and analytical techniques that a hunter can use to find the 'weird' in their data, which often turns out to be malicious.",
              "sections": [
                {
                  "title": "Frequency Analysis",
                  "content": "<p>This is one of the most powerful and simplest hunting techniques. In most environments, the majority of activity is highly repetitive and normal. Malicious activity, especially in its early stages, is often rare. By simply counting every event and focusing on the least frequent ones, a hunter can often uncover threats.</p><ul><li><strong>Rarest Command Line:</strong> What is the command line that has only ever been seen once in your environment?</li><li><strong>Rarest Process:</strong> What executable has only ever been run on a single machine?</li><li><strong>Rarest User-Agent:</strong> Which user-agent has only made one request?</li></ul>"
                }
              ],
              "codeExamples":[
              {
                "title": "Python Script for Frequency Analysis of Processes",
                "language": "python",
                "code": "# A defender can use this script on a CSV export of process logs to find rare events.\n# This is a fundamental building block for anomaly detection.\nfrom collections import Counter\nimport csv\n\ndef find_rare_processes(log_file, threshold=5):\n    processes = []\n    with open(log_file, 'r') as f:\n        reader = csv.DictReader(f)\n        for row in reader:\n            processes.append(row['process_name'])\n    \n    counts = Counter(processes)\n    print(f'--- Processes seen less than {threshold} times ---')\n    for process, count in counts.items():\n        if count < threshold:\n            print(f'{process} (seen {count} times)')\n\n# Usage:\n# find_rare_processes('process_logs.csv')"
              },
              {
                "title": "Splunk Query to Find Rare Processes",
                "language": "spl",
                "code": "(* This Splunk query automates frequency analysis for a defender.\n   The `rare` command is a built-in function that performs this exact task.\n   This hunts for processes that are outliers in the environment. *)\n\nindex=sysmon EventCode=1\n| rare limit=20 Image"
              },
              {
                "title": "KQL Query for Outlier Detection (Logon Hours)",
                "language": "kql",
                "code": "// A hunter uses statistical functions to find outliers.\n// This KQL query uses the `series_decompose_anomalies` function to find anomalous\n// spikes in logon activity compared to the normal historical baseline.\nSecurityEvent\n| where EventID == 4624\n| make-series LogonCount=count() on TimeGenerated from ago(30d) to now() step 1h\n| extend Anomalies = series_decompose_anomalies(LogonCount)\n| where Anomalies[-1] > 1.5 // Find where the last data point was anomalous"
              },
              {
                "title": "Bash Script for First-Seen Domain Analysis",
                "language": "bash",
                "code": "# A defender could run this against their Zeek DNS logs each day.\n# It compares today's domains with a baseline of all domains seen previously.\n# Any new domain is potentially suspicious and warrants investigation.\n\ncat today_dns.log | zeek-cut query | sort -u > today_domains.txt\n\ncomm -13 all_previous_domains.txt today_domains.txt > new_domains_seen_today.txt\n\ncat today_domains.txt >> all_previous_domains.txt\nsort -u all_previous_domains.txt -o all_previous_domains.txt"
              }
              ],
              "activities": [
                {
                  "title": "Use Python to Detect Rare Process Executions",
                  "description": "Given a CSV file containing simulated process execution logs from a large environment, write a Python script using the `collections.Counter` module to count the occurrences of each unique process name. Print a list of all processes that have been seen 5 or fewer times."
                }
              ]
            },
            "quiz": {
              "passingScore": 80,
              "questions": [
                {
                  "id": 1,
                  "question": "What is the core idea behind 'frequency analysis' as a threat hunting technique?",
                  "options": ["Benign activity is common and repetitive, while malicious activity is often rare and unique.", "All rare events are malicious.", "All common events are benign.", "Looking at how frequently your SIEM alerts."],
                  "correct": 0,
                  "explanation": "Frequency analysis works by separating the common, baseline activity from the rare outliers. These outliers are not always malicious, but they are the most interesting places for a hunter to start their investigation."
                },
                {
                  "id": 2,
                  "question": "What is a 'baseline' in the context of threat hunting?",
                  "options": ["A list of all malicious file hashes.", "A snapshot of what 'normal' activity looks like in your specific environment over a period of time.", "The minimum set of logs required.", "A compliance document."],
                  "correct": 1,
                  "explanation": "A baseline is a model of normal behavior. Anomaly detection is the process of finding deviations from that baseline."
                }
              ]
            }
        },
        {
            "id": "lesson-19",
            "title": "Module 6: Operations & Capstone - Building Detection Rules",
            "duration": "120 min",
            "objectives": [
                "Understand the lifecycle of a detection rule (Hunt -> Rule -> Tune -> Deploy).",
                "Write robust detection logic in the Sigma format.",
                "Use `sigmac` to convert Sigma rules into queries for your SIEM.",
                "Practice writing YARA rules to detect malware artifacts."
            ],
            "content": {
                "overview": "The final output of a successful hunt is the creation of a new, durable detection rule. This process, known as 'detection engineering', is what allows the hunting team to scale its impact and continuously improve the organization's automated defenses. This lesson is a hands-on guide to writing high-quality detection rules in the industry-standard formats of Sigma and YARA.",
                "sections": [
                    {
                        "title": "The Detection Lifecycle",
                        "content": "<ol><li><strong>Hunt:</strong> A threat hunter discovers a new adversary technique that bypassed existing defenses.</li><li><strong>Rule Creation:</strong> The hunter translates the observed behavior (the IOA) into a draft detection rule (e.g., in Sigma).</li><li><strong>Tuning:</strong> The hunter tests the rule against historical data to ensure it is high-fidelity and doesn't generate an unacceptable number of false positives.</li><li><strong>Deployment:</strong> The tuned rule is deployed into the production SIEM or EDR, where it can now generate alerts automatically for the SOC team to respond to.</li></ol>"
                    }
                ],
                "codeExamples": [
                {
                    "title": "A Sigma Rule with a More Complex Condition",
                    "language": "yaml",
                    "code": "# This advanced Sigma rule shows how a defender can combine multiple conditions.\n# It hunts for suspicious PowerShell download activity.\ntitle: PowerShell Downloading File\nstatus: stable\nlogsource:\n    product: windows\n    category: process_creation\ndetection:\n    selection_class:\n        CommandLine|contains: 'System.Net.WebClient'\n    selection_method:\n        CommandLine|contains|all:\n            - 'DownloadFile'\n            - 'DownloadString'\n    filter_legitimate_scripts:\n        CommandLine|contains: 'C:\\Program Files\\...'\n    condition: (selection_class and selection_method) and not filter_legitimate_scripts"
                },
                {
                    "title": "A YARA Rule Combining Strings and PE info",
                    "language": "yara",
                    "code": "/* Defenders create complex YARA rules to get more specific detections.\n   This rule looks for a file that is a Windows executable, imports a suspicious API,\n   and contains a specific string. All three conditions must be true.\n*/\nimport \"pe\"\n\nrule Suspicious_Dropper_Behavior {\n    meta:\n        author = \"Threat Hunter\"\n    strings:\n        $s1 = \"your_payload.exe\"\n    condition:\n        pe.is_pe and pe.imports(\"urlmon.dll\", \"URLDownloadToFileA\") and $s1\n}"
                },
                {
                    "title": "Convert Sigma to KQL with `sigmac`",
                    "language": "bash",
                    "code": "# A defender uses `sigmac` to make their rules portable.\n# This converts the PowerShell download rule into a query that can be run in Microsoft Sentinel.\nsigmac -t kusto -c my_config.yml powershell_download.yml"
                },
                {
                    "title": "Falco Rule with Lists and Macros",
                    "language": "yaml",
                    "code": "# Falco allows for more complex logic using macros and lists.\n# A defender would define a list of sensitive file paths and then create a rule\n# that alerts whenever a container process tries to access any file in that list.\n- list: sensitive_files\n  items: [/etc/shadow, /etc/passwd]\n\n- macro: sensitive_file_access\n  condition: open_read and fd.name in (sensitive_files)\n\n- rule: Read sensitive file in container\n  desc: A container process read a sensitive file.\n  condition: sensitive_file_access and container\n  output: \"Sensitive file opened for reading in container (user=%user.name file=%fd.name)\"\n  priority: CRITICAL"
                }
              ],
                "activities": [
                    {
                        "title": "Write a Sigma Rule from a Hunt",
                        "description": "Based on your findings from a previous lesson's activity (e.g., 'A Word document spawned `cmd.exe`'), write a complete Sigma rule in a YAML file that would detect this specific behavior. Include a title, log source, detection section with selection criteria, and a condition. Use `sigmac` to validate your rule's syntax."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the correct operational flow for a threat hunter after finding a new TTP?",
                        "options": ["Immediately block the IP address.", "Document the finding and create a new, automated detection rule for the SOC to use in the future.", "Keep the finding secret.", "Delete the logs related to the event."],
                        "correct": 1,
                        "explanation": "The primary goal of hunting is to scale the defenders' capabilities. This is achieved by taking the manual hunt and turning it into an automated detection that protects the organization going forward."
                    },
                    {
                        "id": 2,
                        "question": "A YARA rule is primarily used to:",
                        "options": ["Block network traffic.", "Define and hunt for patterns (like strings or byte sequences) in files on disk or in memory.", "Query a SIEM.", "Analyze a PCAP file."],
                        "correct": 1,
                        "explanation": "YARA is the standard for file-based pattern matching, used extensively by malware researchers and threat hunters to create signatures for malicious files."
                    }
                ]
            }
        },
        {
            "id": "lesson-20",
            "title": "Module 6: Capstone Project & Course Review",
            "duration": "180 min",
            "objectives": [
              "Apply the full threat hunting lifecycle to a complex, simulated dataset.",
              "Start with a high-level hypothesis and pivot based on the data.",
              "Correlate data from host, network, and cloud log sources to tell the full story of an attack.",
              "Produce a professional hunt report that details the hypothesis, findings, and a recommended new detection rule."
            ],
            "content": {
              "overview": "This final capstone project integrates all the skills from the course into a single, realistic scenario. You will be given a large, multi-source dataset representing a 'day in the life' of a small corporate network. Hidden within this benign data is a simulated, multi-stage attack. Your job is to start with a hypothesis, hunt through the data, find the full attack chain, and report on it.",
              "sections": [
                {
                  "title": "The Scenario and Dataset",
                  "content": "<p>You will be given access to a pre-populated ELK stack containing one day of logs. The dataset includes:</p><ul><li>Sysmon logs from several Windows workstations and servers.</li><li>Zeek logs from a network tap.</li><li>AWS CloudTrail logs from the organization's cloud environment.</li></ul><p>Your hunt will start with a single, high-level hypothesis, such as: 'An attacker is using PowerShell for execution'.</p>"
                },
                {
                    "title": "The Hunting Workflow",
                    "content":"<ol><li><strong>Hypothesis:</strong> Start with your initial hypothesis and develop a query to investigate it.</li><li><strong>Investigate & Pivot:</strong> Analyze the results of your query. This initial finding will be the 'thread' you pull on. You might find a suspicious PowerShell command on one host. From there, you will pivot your investigation, asking new questions: 'What process spawned this PowerShell?', 'What network connections did it make?', 'What other activity happened on this host around the same time?'.</li><li><strong>Trace the Kill Chain:</strong> Continue pivoting between data sources (Sysmon, Zeek, CloudTrail) to trace the full lifecycle of the simulated attack, from initial access to final impact.</li><li><strong>Report and Recommend:</strong> Document your entire investigation. Create a timeline of events, list all discovered IOCs, and map the TTPs to the MITRE ATT&CK framework. Your final recommendation will be a high-fidelity Sigma rule that would have detected this attack automatically.</li></ol>"
                }
              ],
              "activities": [
                {
                  "title": "Perform a Full Hunt on a Simulated Dataset",
                  "description": "Execute the full capstone workflow on the provided dataset. Your final deliverable is a multi-page PDF report detailing your hypothesis, your investigation workflow (including the queries you used), a timeline of the simulated attack, and the final Sigma rule you developed."
                }
              ]
            },
            "quiz": {
              "passingScore": 80,
              "questions": [
                {
                  "id": 1,
                  "question": "What does it mean to 'pivot' during a threat hunt?",
                  "options": ["To give up on the hunt.", "To take a single indicator you've found (like a suspicious IP address) and use it as a search key to find all other related activity in all your data sources.", "To write the final report.", "To create a chart."],
                  "correct": 1,
                  "explanation": "Pivoting is the core analytic technique of hunting. Each piece of data you find becomes a new search term, allowing you to branch out and uncover the full scope of the attack."
                },
                {
                  "id": 2,
                  "question": "What is the most important component of the capstone project's final report?",
                  "options": ["A list of every log entry you looked at.", "The proposed new detection rule (e.g., in Sigma format) that would automate the detection of the attack you found.", "The total number of events in the dataset.", "The name of the simulated attacker."],
                  "correct": 1,
                  "explanation": "The ultimate goal of threat hunting is to create durable, automated defenses. The final detection rule is the codification of the knowledge gained during the hunt and is the most valuable outcome."
                }
              ]
            }
        }
    ]
}  // =====================================================
      // GLOBAL VARIABLES
      // =====================================================
      let currentUser = null;
      let currentLessonIndex = 0;
      let courseProgress = {};
      let userStats = {};
      let quizState = {
        currentQuestion: 0,
        answers: [],
        score: 0,
        isComplete: false,
      };

      // Enhanced session tracking
      let courseSession = {
        startTime: null,
        totalStudyTime: 0,
        lessonsStarted: 0,
        lessonsCompleted: 0,
        pageLoadTime: new Date(),
        interactionCount: 0,
        lastActivityTime: new Date(),
      };

      // Music Player Variables
      let audioPlayer = new Audio();

      // Achievement notification system
      let notificationQueue = [];
      let isShowingNotification = false;

      // =====================================================
      // INITIALIZATION
      // =====================================================
      document.addEventListener("DOMContentLoaded", async () => {
        try {
          showLoadingScreen();
          await checkAuth();

          if (currentUser) {
            // Initialize session tracking
            startCourseSession();

            // Load course data and progress
            await loadCourseData();
            await loadUserProfile();
            await loadProgress();

            // Initialize UI
            initializeEventListeners();
            renderSidebar();
            loadLesson(currentLessonIndex);

            // Initialize additional features
            initMusicPlayer();
            addMusicIndicator();
            initializeActivityTracking();

            hideLoadingScreen();
          } else {
            openAuthModal();
          }
        } catch (error) {
          console.error("Error initializing course:", error);
          hideLoadingScreen();
          showToast("Failed to initialize course system", "error");
        }
      });

      // =====================================================
      // AUTHENTICATION SYSTEM
      // =====================================================
      async function checkAuth() {
        try {
          const {
            data: { session },
            error,
          } = await supabase.auth.getSession();

          if (error) {
            console.error("Auth error:", error);
            currentUser = null;
            openAuthModal();
            return;
          }

          if (!session) {
            currentUser = null;
            openAuthModal();
            return;
          }

          currentUser = session.user;
          updateUIWithUser();
        } catch (error) {
          console.error("Error checking auth:", error);
          currentUser = null;
          openAuthModal();
        }
      }

      function updateUIWithUser() {
        if (!currentUser) return;

        const name =
          currentUser.user_metadata?.full_name ||
          currentUser.email.split("@")[0];
        const userElements = document.querySelectorAll("[data-user-name]");
        userElements.forEach((el) => (el.textContent = name));
      }

      // =====================================================
      // USER PROFILE & STATS MANAGEMENT
      // =====================================================
      async function loadUserProfile() {
        try {
          // 🔍 Step 1: Try to fetch existing profile
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("*")
            .eq("id", currentUser.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (!profile) {
            // 🆕 Step 2: Create new profile if missing
            await createUserProfile();
          } else {
            // ✅ Step 3: Use existing profile
            userStats = profile;
            await updateLastActivity();
          }
        } catch (error) {
          console.error("❌ Error loading user profile:", error);
          showToast("Failed to load user profile", "error");
        }
      }
      async function createUserProfile() {
        try {
          const newProfile = {
            id: currentUser.id,
            full_name: currentUser.user_metadata?.full_name || "",
            email: currentUser.email,
            level: "Script Kiddie",
            total_points: 0,
            completed_courses: 0,
            current_streak: 0,
            total_certificates: 0,
            total_achievements: 0,
            sections_visited: 0,
            bonus_points: 0,
            in_progress_courses: 0,
            settings_changed: 0,
            midnight_sessions: 0,
            early_sessions: 0,
            weekend_sessions: 0,
            last_activity: new Date().toISOString(),
            created_at: new Date().toISOString(),
          };

          const { error } = await supabase
            .from("profiles")
            .insert([newProfile]);

          if (!error) {
            userStats = newProfile;
            // Award first login achievement
            setTimeout(() => checkAndUnlockAchievement("first_login"), 1000);
          }
        } catch (error) {
          console.error("Error creating user profile:", error);
        }
      }

      async function updateLastActivity() {
        try {
          const now = new Date();

          // Update activity tracking
          courseSession.lastActivityTime = now;

          // Update database
          await supabase
            .from("profiles")
            .update({
              last_activity: now.toISOString(),
            })
            .eq("id", currentUser.id);

          // Check time-based achievements
          await checkTimeBasedAchievements(now);
        } catch (error) {
          console.error("Error updating last activity:", error);
        }
      }

      // =====================================================
      // COURSE SESSION MANAGEMENT
      // =====================================================
      function startCourseSession() {
        courseSession.startTime = new Date();
        courseSession.pageLoadTime = new Date();

        logUserActivity("course_session_start", {
          course_id: COURSE_DATA.id,
          course_title: COURSE_DATA.title,
          user_agent: navigator.userAgent,
          screen_resolution: `${screen.width}x${screen.height}`,
        });

        // Check daily streak
        checkDailyStreak();
      }

      function initializeActivityTracking() {
        // Track page focus/blur for accurate study time
        document.addEventListener("visibilitychange", handleVisibilityChange);

        // Track user interactions
        ["click", "keydown", "scroll", "mousemove"].forEach((event) => {
          document.addEventListener(event, trackUserInteraction, {
            passive: true,
          });
        });

        // Periodic activity updates
        setInterval(updateStudyTime, 60000); // Every minute

        // Save session data before page unload
        window.addEventListener("beforeunload", saveSessionData);
      }

      function handleVisibilityChange() {
        if (document.hidden) {
          courseSession.lastActivityTime = new Date();
        } else {
          // Page became visible again - update activity
          updateLastActivity();
        }
      }

      function trackUserInteraction() {
        courseSession.interactionCount++;
        courseSession.lastActivityTime = new Date();

        // Throttle activity updates
        if (courseSession.interactionCount % 50 === 0) {
          updateLastActivity();
        }
      }

      function updateStudyTime() {
        if (!courseSession.startTime || document.hidden) return;

        const now = new Date();
        const sessionDuration = now - courseSession.startTime;
        courseSession.totalStudyTime = Math.floor(sessionDuration / 1000 / 60); // in minutes

        // Update progress with study time
        saveProgress();
      }

      function saveSessionData() {
        if (!currentUser || !courseSession.startTime) return;

        const sessionData = {
          user_id: currentUser.id,
          course_id: COURSE_DATA.id,
          session_duration: courseSession.totalStudyTime,
          lessons_viewed: courseSession.lessonsStarted,
          lessons_completed: courseSession.lessonsCompleted,
          interactions: courseSession.interactionCount,
          session_date: courseSession.startTime.toISOString().split("T")[0],
        };

        // Store in localStorage as backup
        localStorage.setItem(
          "course_session_backup",
          JSON.stringify(sessionData)
        );

        // Try to save to database
        logUserActivity("course_session_end", sessionData);
      }

      // =====================================================
      // COURSE DATA & PROGRESS MANAGEMENT
      // =====================================================
      async function loadCourseData() {
        try {
          // Update course info in UI
          document.getElementById("courseTitle").textContent =
            COURSE_DATA.title;
          document.getElementById("totalLessons").textContent =
            COURSE_DATA.lessons.length;

          // Log course access
          logUserActivity("course_access", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
          });
        } catch (error) {
          console.error("Error loading course data:", error);
        }
      }

      async function loadProgress() {
        try {
          // Get existing progress from database
          const { data, error } = await supabase
            .from("course_progress")
            .select("*")
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (data) {
            courseProgress = JSON.parse(data.lesson_progress || "{}");
            currentLessonIndex = data.current_lesson || 0;

            // Update session tracking
            courseSession.lessonsStarted = Object.keys(courseProgress).length;
            courseSession.lessonsCompleted = Object.values(
              courseProgress
            ).filter((p) => p.completed).length;
          } else {
            // Initialize new progress
            courseProgress = {};
            currentLessonIndex = 0;
            await saveProgress();

            // Award first course start achievement
            await checkAndUnlockAchievement("first_course_start");
          }

          updateProgressDisplay();
        } catch (error) {
          console.error("Error loading progress:", error);
          showToast("Failed to load progress", "error");
        }
      }

      async function saveProgress() {
        try {
          if (!currentUser) return;

          const now = new Date();
          const progressData = {
            user_id: currentUser.id,
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            current_lesson: currentLessonIndex,
            lesson_progress: JSON.stringify(courseProgress),
            progress: calculateOverallProgress(),
            lessons_completed: getCompletedLessonsCount(),
            lessons_started: Object.keys(courseProgress).length,
            study_time_minutes: courseSession.totalStudyTime,
            last_accessed: now.toISOString(),
            updated_at: now.toISOString(),
          };

          // Upsert progress
          const { error } = await supabase
            .from("course_progress")
            .upsert([progressData]);

          if (error) throw error;

          // Update user stats
          await updateUserStats();

          updateProgressDisplay();
        } catch (error) {
          console.error("Error saving progress:", error);
          showToast("Failed to save progress", "error");
        }
      }

      async function updateUserStats() {
        try {
          // Get all course progress for this user
          const { data: allProgress, error } = await supabase
            .from("course_progress")
            .select("progress, course_id, study_time_minutes")
            .eq("user_id", currentUser.id);

          if (error) throw error;

          // Calculate stats
          const completedCourses =
            allProgress?.filter((p) => p.progress >= 100).length || 0;
          const inProgressCourses =
            allProgress?.filter((p) => p.progress > 0 && p.progress < 100)
              .length || 0;
          const totalStudyTime =
            allProgress?.reduce(
              (sum, p) => sum + (p.study_time_minutes || 0),
              0
            ) || 0;

          // Calculate points (500 per completed course + achievement points)
          const coursePoints = completedCourses * 500;
          const bonusPoints = userStats.bonus_points || 0;
          const totalPoints = coursePoints + bonusPoints;

          // Update profile
          const updateData = {
            completed_courses: completedCourses,
            in_progress_courses: inProgressCourses,
            total_points: totalPoints,
            total_study_time: totalStudyTime,
            last_activity: new Date().toISOString(),
          };

          const { error: updateError } = await supabase
            .from("profiles")
            .update(updateData)
            .eq("id", currentUser.id);

          if (updateError) throw updateError;

          // Update local stats
          Object.assign(userStats, updateData);
        } catch (error) {
          console.error("Error updating user stats:", error);
        }
      }

      function calculateOverallProgress() {
        const completedLessons = getCompletedLessonsCount();
        return Math.round(
          (completedLessons / COURSE_DATA.lessons.length) * 100
        );
      }

      function getCompletedLessonsCount() {
        return Object.values(courseProgress).filter(
          (lesson) => lesson.completed
        ).length;
      }

      function updateProgressDisplay() {
        const completedCount = getCompletedLessonsCount();
        const progressPercent = calculateOverallProgress();

        // Update UI elements
        const elements = {
          completedLessons: completedCount,
          courseProgressPercent: `${progressPercent}%`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });

        // Update progress bar
        const progressBar = document.getElementById("courseProgressFill");
        if (progressBar) progressBar.style.width = `${progressPercent}%`;
      }

      // =====================================================
      // LESSON MANAGEMENT
      // =====================================================
      function loadLesson(index) {
        if (index < 0 || index >= COURSE_DATA.lessons.length) return;

        const lesson = COURSE_DATA.lessons[index];
        currentLessonIndex = index;

        // Mark lesson as started and track activity
        if (!courseProgress[lesson.id]) {
          courseProgress[lesson.id] = {
            started: true,
            completed: false,
            startedAt: new Date().toISOString(),
            timeSpent: 0,
          };

          courseSession.lessonsStarted++;
          saveProgress();

          // Log lesson start
          logUserActivity("lesson_start", {
            lesson_id: lesson.id,
            lesson_title: lesson.title,
            lesson_index: index,
          });
        }

        // Update lesson start time for time tracking
        courseProgress[lesson.id].currentSessionStart = new Date();

        // Update sidebar and navigation
        renderSidebar();
        updateNavigationButtons();

        // Update header info
        updateLessonHeader(lesson, index);

        // Render lesson content
        renderLessonContent(lesson);

        // Smooth scroll and animations
        window.scrollTo({ top: 0, behavior: "smooth" });
        document.getElementById("contentBody").scrollTop = 0;

        const contentBody = document.getElementById("contentBody");
        contentBody.classList.add("fade-in");
        setTimeout(() => contentBody.classList.remove("fade-in"), 500);

        // Check lesson-based achievements
        checkLessonAchievements(index + 1);
      }

      function updateLessonHeader(lesson, index) {
        const elements = {
          currentLessonNumber: index + 1,
          currentLessonTitle: lesson.title,
          navInfo: `Lesson ${index + 1} of ${COURSE_DATA.lessons.length}`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });
      }

      function renderSidebar() {
        const lessonNav = document.getElementById("lessonNav");
        if (!lessonNav) return;

        lessonNav.innerHTML = "";

        COURSE_DATA.lessons.forEach((lesson, index) => {
          const lessonItem = document.createElement("div");
          lessonItem.className = "lesson-item";

          // Determine lesson status
          const lessonProgress = courseProgress[lesson.id];
          const isCompleted = lessonProgress?.completed || false;
          const isInProgress = lessonProgress?.started || false;
          const isLocked = !isCompleted && !canAccessLesson(index);
          const isActive = index === currentLessonIndex;

          // Apply status classes
          if (isCompleted) lessonItem.classList.add("completed");
          if (isLocked) lessonItem.classList.add("locked");
          if (isActive) lessonItem.classList.add("active");

          // Determine status display
          let statusClass = "not-started";
          let statusIcon = index + 1;

          if (isCompleted) {
            statusClass = "completed";
            statusIcon = "✓";
          } else if (isInProgress) {
            statusClass = "in-progress";
            statusIcon = "◐";
          }

          // Create lesson item HTML
          lessonItem.innerHTML = `
            <div class="lesson-status ${statusClass}">${statusIcon}</div>
            <div class="lesson-info">
                <div class="lesson-title">${lesson.title}</div>
                <div class="lesson-meta">
                    ${
                      isCompleted
                        ? "Completed"
                        : isInProgress
                        ? "In Progress"
                        : isLocked
                        ? "Locked"
                        : "Not Started"
                    }
                </div>
            </div>
            <div class="lesson-duration">${lesson.duration}</div>
        `;

          // Add click handler if not locked
          if (!isLocked) {
            lessonItem.addEventListener("click", () => {
              if (index !== currentLessonIndex) {
                // Track lesson time before switching
                trackLessonTime();

                currentLessonIndex = index;
                loadLesson(index);
                closeSidebar();
              }
            });
          }

          lessonNav.appendChild(lessonItem);
        });
      }

      function canAccessLesson(index) {
        if (index === 0) return true; // First lesson always accessible

        // Can access if previous lesson is completed
        const previousLessonId = COURSE_DATA.lessons[index - 1].id;
        return courseProgress[previousLessonId]?.completed || false;
      }

      function trackLessonTime() {
        const currentLesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonProgress = courseProgress[currentLesson.id];

        if (lessonProgress?.currentSessionStart) {
          const sessionTime = Math.floor(
            (new Date() - new Date(lessonProgress.currentSessionStart)) /
              1000 /
              60
          );
          lessonProgress.timeSpent =
            (lessonProgress.timeSpent || 0) + sessionTime;
          delete lessonProgress.currentSessionStart;
        }
      }

      // =====================================================
      // LESSON CONTENT RENDERING
      // =====================================================
      function renderLessonContent(lesson) {
        const contentContainer = document.getElementById("lessonContent");
        if (!contentContainer) return;

        let contentHTML = `
        <div class="content-section">
            <h2>Learning Objectives</h2>
            <ul>
                ${lesson.objectives.map((obj) => `<li>${obj}</li>`).join("")}
            </ul>
        </div>
        
        <div class="content-section">
            <h2>Overview</h2>
            <p>${lesson.content.overview}</p>
        </div>
    `;

        // Render content sections
        lesson.content.sections.forEach((section) => {
          contentHTML += `
            <div class="content-section">
                <h2>${section.title}</h2>
                ${section.content}
                ${
                  section.image
                    ? `<img src="${section.image}" alt="${section.title}" class="content-image" loading="lazy">`
                    : ""
                }
            </div>
        `;
        });

        // Render code examples
        if (
          lesson.content.codeExamples &&
          lesson.content.codeExamples.length > 0
        ) {
          contentHTML += `<div class="content-section"><h2>Code Examples</h2></div>`;

          lesson.content.codeExamples.forEach((example, index) => {
            const codeId = `code-${lesson.id}-${index}`;
            contentHTML += `
                <div class="code-section">
                    <div class="code-header">
                        <span class="code-title">${example.title}</span>
                        <button class="copy-btn" onclick="copyCode('${codeId}')">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <pre class="code-block"><code id="${codeId}" class="language-${
              example.language
            }">${escapeHtml(example.code)}</code></pre>
                </div>
            `;
          });
        }

        // Render quiz
        contentHTML += renderQuiz(lesson.quiz);

        contentContainer.innerHTML = contentHTML;

        // Highlight code syntax if Prism is available
        setTimeout(() => {
          if (window.Prism) {
            Prism.highlightAll();
          }
        }, 100);
      }

      // =====================================================
      // QUIZ SYSTEM
      // =====================================================
      function renderQuiz(quiz) {
        const currentLessonProgress =
          courseProgress[COURSE_DATA.lessons[currentLessonIndex].id];
        const isCompleted = currentLessonProgress?.completed || false;

        let quizHTML = `
        <div class="quiz-section" id="quizSection">
            <div class="quiz-header">
                <h2 class="quiz-title">
                    <i class="fas fa-clipboard-check"></i>
                    Knowledge Check
                </h2>
                <p class="quiz-info">
                    Complete this quiz with ${quiz.passingScore}% or higher to unlock the next lesson.
                </p>
            </div>
    `;

        if (isCompleted) {
          const savedScore = currentLessonProgress.quizScore || 0;
          quizHTML += `
            <div class="quiz-results show">
                <div class="quiz-score pass">${savedScore}%</div>
                <div class="quiz-message">
                    <strong>Lesson Completed!</strong><br>
                    You've successfully passed this lesson's quiz.
                </div>
            </div>
        `;
        } else {
          // Render quiz questions
          quiz.questions.forEach((question, qIndex) => {
            quizHTML += `
                <div class="quiz-question ${
                  qIndex === 0 ? "active" : ""
                }" data-question="${qIndex}">
                    <div class="question-header">
                        <span class="question-number">Question ${
                          qIndex + 1
                        }</span>
                        <span class="question-progress">${qIndex + 1}/${
              quiz.questions.length
            }</span>
                    </div>
                    <div class="question-text">${question.question}</div>
                    <div class="question-options">
                        ${question.options
                          .map(
                            (option, oIndex) => `
                            <div class="option" data-option="${oIndex}" onclick="selectOption(${qIndex}, ${oIndex})">
                                <span class="option-letter">${String.fromCharCode(
                                  65 + oIndex
                                )}</span>
                                <span class="option-text">${option}</span>
                            </div>
                        `
                          )
                          .join("")}
                    </div>
                </div>
            `;
          });

          quizHTML += `
            <div class="quiz-controls">
                <button class="btn btn-secondary" id="prevQuestionBtn" onclick="previousQuestion()" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <div>
                    <button class="btn btn-secondary" id="nextQuestionBtn" onclick="nextQuestion()" disabled>
                        Next
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <button class="btn btn-primary" id="submitQuizBtn" onclick="submitQuiz()" style="display: none;">
                        <i class="fas fa-check"></i>
                        Submit Quiz
                    </button>
                </div>
            </div>

            <div class="quiz-results" id="quizResults">
                <div class="quiz-score" id="quizScore">0%</div>
                <div class="quiz-message" id="quizMessage"></div>
                <div class="quiz-actions">
                    <button class="btn btn-primary" id="continueBtn" onclick="completeLesson()" style="display: none;">
                        <i class="fas fa-arrow-right"></i>
                        Continue to Next Lesson
                    </button>
                    <button class="btn btn-secondary" onclick="retakeQuiz()">
                        <i class="fas fa-redo"></i>
                        Retake Quiz
                    </button>
                </div>
            </div>
        `;
        }

        quizHTML += "</div>";
        return quizHTML;
      }

      // Quiz interaction functions
      function selectOption(questionIndex, optionIndex) {
        // Clear previous selections
        document
          .querySelectorAll(`[data-question="${questionIndex}"] .option`)
          .forEach((opt) => {
            opt.classList.remove("selected");
          });

        // Select current option
        const selectedOption = document.querySelector(
          `[data-question="${questionIndex}"] [data-option="${optionIndex}"]`
        );
        selectedOption.classList.add("selected");

        // Store answer
        quizState.answers[questionIndex] = optionIndex;

        // Update navigation
        const isLastQuestion =
          questionIndex ===
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length - 1;
        if (isLastQuestion) {
          document.getElementById("submitQuizBtn").style.display =
            "inline-flex";
          document.getElementById("nextQuestionBtn").style.display = "none";
        } else {
          document.getElementById("nextQuestionBtn").disabled = false;
        }
      }

      function nextQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const nextQuestionEl = currentQuestionEl.nextElementSibling;

        if (
          nextQuestionEl &&
          nextQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          nextQuestionEl.classList.add("active");
          quizState.currentQuestion++;
          updateQuizNavigation();
        }
      }

      function previousQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const prevQuestionEl = currentQuestionEl.previousElementSibling;

        if (
          prevQuestionEl &&
          prevQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          prevQuestionEl.classList.add("active");
          quizState.currentQuestion--;
          updateQuizNavigation();
        }
      }

      function updateQuizNavigation() {
        const totalQuestions =
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length;
        const prevBtn = document.getElementById("prevQuestionBtn");
        const nextBtn = document.getElementById("nextQuestionBtn");
        const submitBtn = document.getElementById("submitQuizBtn");

        prevBtn.disabled = quizState.currentQuestion === 0;

        const hasAnswer =
          quizState.answers[quizState.currentQuestion] !== undefined;
        const isLastQuestion = quizState.currentQuestion === totalQuestions - 1;

        if (isLastQuestion) {
          nextBtn.style.display = "none";
          submitBtn.style.display = hasAnswer ? "inline-flex" : "none";
        } else {
          nextBtn.style.display = "inline-flex";
          nextBtn.disabled = !hasAnswer;
          submitBtn.style.display = "none";
        }
      }

      async function submitQuiz() {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const quiz = lesson.quiz;
        let correctAnswers = 0;

        // Hide questions and controls
        document
          .querySelectorAll(".quiz-question")
          .forEach((q) => (q.style.display = "none"));
        document.querySelector(".quiz-controls").style.display = "none";

        // Calculate score and highlight answers
        quiz.questions.forEach((question, index) => {
          const userAnswer = quizState.answers[index];
          const correctAnswer = question.correct;
          const isCorrect = userAnswer === correctAnswer;

          if (isCorrect) correctAnswers++;

          // Highlight answers
          const questionEl = document.querySelector(
            `[data-question="${index}"]`
          );
          const options = questionEl.querySelectorAll(".option");

          options[correctAnswer].classList.add("correct");
          if (userAnswer !== correctAnswer && userAnswer !== undefined) {
            options[userAnswer].classList.add("incorrect");
          }
        });

        const score = Math.round(
          (correctAnswers / quiz.questions.length) * 100
        );
        const passed = score >= quiz.passingScore;

        // Update quiz results UI
        const quizScore = document.getElementById("quizScore");
        const quizMessage = document.getElementById("quizMessage");
        const quizActions = document.querySelector(".quiz-actions");

        quizScore.textContent = `${score}%`;
        quizScore.className = `quiz-score ${passed ? "pass" : "fail"}`;

        if (passed) {
          quizMessage.innerHTML = `
            <strong>Congratulations!</strong><br>
            You passed with ${score}%. You can now proceed to the next lesson.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-primary" onclick="completeLesson()">
                <i class="fas fa-arrow-right"></i>
                Continue to Next Lesson
            </button>
        `;

          // Mark lesson as completed
          await markLessonComplete(score);
        } else {
          quizMessage.innerHTML = `
            <strong>Not quite there yet.</strong><br>
            You scored ${score}%. You need ${quiz.passingScore}% to pass. Review the material and try again.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-secondary" onclick="retakeQuiz()">
                <i class="fas fa-redo"></i>
                Retake Quiz
            </button>
        `;
        }

        document.getElementById("quizResults").classList.add("show");

        // Log quiz completion
        logUserActivity("quiz_completed", {
          lesson_id: lesson.id,
          lesson_title: lesson.title,
          score: score,
          passed: passed,
          attempts: (courseProgress[lesson.id]?.quizAttempts || 0) + 1,
        });

        // Scroll to results
        document
          .getElementById("quizResults")
          .scrollIntoView({ behavior: "smooth" });
      }

      function retakeQuiz() {
        // Reset quiz state
        quizState = {
          currentQuestion: 0,
          answers: [],
          score: 0,
          isComplete: false,
        };

        // Track quiz retry
        const lessonId = COURSE_DATA.lessons[currentLessonIndex].id;
        if (!courseProgress[lessonId]) courseProgress[lessonId] = {};
        courseProgress[lessonId].quizAttempts =
          (courseProgress[lessonId].quizAttempts || 0) + 1;

        // Reload lesson content
        loadLesson(currentLessonIndex);

        // Scroll to quiz
        setTimeout(() => {
          document
            .getElementById("quizSection")
            .scrollIntoView({ behavior: "smooth" });
        }, 500);
      }

      async function markLessonComplete(score) {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonId = lesson.id;

        // Track lesson completion time
        trackLessonTime();

        // Update lesson progress
        courseProgress[lessonId] = {
          ...courseProgress[lessonId],
          completed: true,
          quizScore: score,
          completedAt: new Date().toISOString(),
          finalScore: score,
        };

        // Update session tracking
        courseSession.lessonsCompleted++;

        // Save progress to database
        await saveProgress();

        // Update UI
        renderSidebar();
        updateNavigationButtons();

        // Check various achievements
        await checkLessonCompletionAchievements();
        await checkPerfectScoreAchievements(score);
        await checkStudyTimeAchievements();

        // Log lesson completion
        logUserActivity("lesson_completed", {
          lesson_id: lessonId,
          lesson_title: lesson.title,
          final_score: score,
          time_spent: courseProgress[lessonId].timeSpent || 0,
          lesson_number: currentLessonIndex + 1,
        });

        showToast("Lesson completed successfully!", "success");
      }

      async function completeLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          // Move to next lesson
          currentLessonIndex++;
          loadLesson(currentLessonIndex);
        } else {
          // Course completion
          await completeCourse();
        }
      }

      async function completeCourse() {
        try {
          const completionTime = courseSession.totalStudyTime;

          // Update course progress to 100% completed
          await supabase
            .from("course_progress")
            .update({
              progress: 100,
              completed_at: new Date().toISOString(),
              completion_time_minutes: completionTime,
            })
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Award course completion achievements
          await checkAndUnlockAchievement("course_completion_1");
          await checkSpeedCompletionAchievements(completionTime);
          await checkCourseStreakAchievements();

          // Update user stats
          await updateUserStats();

          // Show completion message
          showToast(
            "Congratulations! Course completed successfully!",
            "certificate"
          );

          // Log course completion
          logUserActivity("course_completed", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            completion_time_minutes: completionTime,
            total_lessons: COURSE_DATA.lessons.length,
            average_quiz_score: calculateAverageQuizScore(),
          });

          // Redirect to dashboard after delay
          setTimeout(() => {
            window.location.href = "/dashboard.html";
          }, 3000);
        } catch (error) {
          console.error("Error completing course:", error);
          showToast("Error marking course as complete", "error");
        }
      }

      // =====================================================
      // ACHIEVEMENT INTEGRATION SYSTEM
      // =====================================================
      async function checkAndUnlockAchievement(
        achievementId,
        skipNotification = false
      ) {
        try {
          // Prevent duplicate checks
          const cacheKey = `achievement_${achievementId}_${currentUser.id}`;
          if (sessionStorage.getItem(cacheKey)) return false;

          // Check if already unlocked
          const { data: existing, error } = await supabase
            .from("user_achievements")
            .select("id")
            .eq("user_id", currentUser.id)
            .eq("achievement_id", achievementId)
            .single();

          if (existing) {
            sessionStorage.setItem(cacheKey, "true");
            return false;
          }

          // Award achievement
          const achievementData = {
            user_id: currentUser.id,
            achievement_id: achievementId,
            unlocked_at: new Date().toISOString(),
            points_awarded: getAchievementPoints(achievementId),
            context: "course_system",
          };

          const { data, error: insertError } = await supabase
            .from("user_achievements")
            .insert([achievementData])
            .select()
            .single();

          if (insertError) {
            if (insertError.code === "23505") return false; // Already exists
            throw insertError;
          }

          // Update user points
          await supabase.rpc('increment_user_stats', {
  user_id_param: currentUser.id,
  points_to_add: achievementData.points_awarded,
  achievements_to_add: 1
});

          // Cache and queue notification
          sessionStorage.setItem(cacheKey, "true");

          if (!skipNotification) {
            queueAchievementNotification({
              id: achievementId,
              name: getAchievementName(achievementId),
              description: getAchievementDescription(achievementId),
              points: achievementData.points_awarded,
              rarity: getAchievementRarity(achievementId),
              icon: getAchievementIcon(achievementId),
            });
          }

          return true;
        } catch (error) {
          console.error("Error unlocking achievement:", error);
          return false;
        }
      }

      // Helper functions for achievement data (replace with your actual achievement definitions)
      function getAchievementPoints(id) {
        const pointsMap = {
          first_course_start: 75,
          first_lesson: 100,
          course_completion_1: 500,
          perfect_score: 250,
          speed_demon: 750,
          marathon_learner: 500,
          night_owl: 200,
          early_bird: 200,
          weekend_warrior: 150,
          // Add more as needed
        };
        return pointsMap[id] || 100;
      }

      function getAchievementName(id) {
        const nameMap = {
          first_course_start: "Learning Initiated",
          first_lesson: "First Steps",
          course_completion_1: "Course Conqueror",
          perfect_score: "Perfectionist",
          speed_demon: "Speed Demon",
          // Add more as needed
        };
        return nameMap[id] || "Achievement Unlocked";
      }

      function getAchievementDescription(id) {
        const descMap = {
          first_course_start: "Start your first cybersecurity course",
          first_lesson: "Complete your first lesson",
          course_completion_1: "Complete your first course",
          perfect_score: "Score 100% on any quiz",
          speed_demon: "Complete a course in under 2 hours",
          // Add more as needed
        };
        return descMap[id] || "Achievement description";
      }

      function getAchievementRarity(id) {
        const rarityMap = {
          first_course_start: "common",
          first_lesson: "bronze",
          course_completion_1: "silver",
          perfect_score: "gold",
          speed_demon: "legendary",
          // Add more as needed
        };
        return rarityMap[id] || "common";
      }

      function getAchievementIcon(id) {
        const iconMap = {
          first_course_start: "fas fa-play",
          first_lesson: "fas fa-baby",
          course_completion_1: "fas fa-trophy",
          perfect_score: "fas fa-star",
          speed_demon: "fas fa-rocket",
          // Add more as needed
        };
        return iconMap[id] || "fas fa-award";
      }

      async function checkLessonAchievements(lessonNumber) {
        if (lessonNumber === 1) {
          await checkAndUnlockAchievement("first_lesson");
        }

        // Check if user has completed multiple lessons in one day
        const today = new Date().toISOString().split("T")[0];
        const todayCompletions = Object.values(courseProgress).filter(
          (p) => p.completed && p.completedAt?.startsWith(today)
        ).length;

        if (todayCompletions >= 3) {
          await checkAndUnlockAchievement("lesson_marathon");
        }
      }

      async function checkLessonCompletionAchievements() {
        const completedCount = getCompletedLessonsCount();

        // Lesson-based achievements
        const lessonMilestones = [1, 5, 10, 25, 50, 100];
        for (const milestone of lessonMilestones) {
          if (completedCount >= milestone) {
            await checkAndUnlockAchievement(`lessons_${milestone}`);
          }
        }

        // Course completion achievements
        if (completedCount === COURSE_DATA.lessons.length) {
          await checkAndUnlockAchievement("course_completion_1");

          // Check for additional course completion achievements
          const { data: allCourses } = await supabase
            .from("course_progress")
            .select("course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100);

          const totalCompleted = allCourses?.length || 0;

          const courseMilestones = [1, 5, 10, 25];
          for (const milestone of courseMilestones) {
            if (totalCompleted >= milestone) {
              await checkAndUnlockAchievement(`course_completion_${milestone}`);
            }
          }
        }
      }

      async function checkPerfectScoreAchievements(score) {
        if (score === 100) {
          await checkAndUnlockAchievement("perfect_score");

          // Check for consecutive perfect scores
          const recentScores = Object.values(courseProgress)
            .filter((p) => p.completed && p.quizScore)
            .slice(-5) // Last 5 completed
            .map((p) => p.quizScore);

          if (
            recentScores.length >= 3 &&
            recentScores.every((s) => s === 100)
          ) {
            await checkAndUnlockAchievement("perfectionist_streak");
          }
        }
      }

      async function checkSpeedCompletionAchievements(completionTime) {
        // Speed demon: Complete course in under 2 hours (120 minutes)
        if (completionTime <= 120) {
          await checkAndUnlockAchievement("speed_demon");
        }

        // Quick learner: Complete course in under 4 hours (240 minutes)
        if (completionTime <= 240) {
          await checkAndUnlockAchievement("quick_learner");
        }
      }

      async function checkStudyTimeAchievements() {
        const totalTime = courseSession.totalStudyTime;

        // Marathon learner: Study for 8+ hours in a course session
        if (totalTime >= 480) {
          // 8 hours
          await checkAndUnlockAchievement("marathon_learner");
        }

        // Dedicated learner: Study for 4+ hours
        if (totalTime >= 240) {
          // 4 hours
          await checkAndUnlockAchievement("dedicated_learner");
        }
      }

      async function checkCourseStreakAchievements() {
        try {
          // Check for consecutive course completions
          const { data: recentCourses, error } = await supabase
            .from("course_progress")
            .select("completed_at, course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100)
            .order("completed_at", { ascending: false })
            .limit(10);

          if (error || !recentCourses) return;

          // Check for courses completed on consecutive days
          let consecutiveDays = 1;
          for (let i = 1; i < recentCourses.length; i++) {
            const prevDate = new Date(
              recentCourses[i - 1].completed_at
            ).toDateString();
            const currentDate = new Date(
              recentCourses[i].completed_at
            ).toDateString();
            const dayDiff =
              Math.abs(new Date(prevDate) - new Date(currentDate)) /
              (1000 * 60 * 60 * 24);

            if (dayDiff <= 1) {
              consecutiveDays++;
            } else {
              break;
            }
          }

          if (consecutiveDays >= 3) {
            await checkAndUnlockAchievement("learning_streak");
          }
        } catch (error) {
          console.error("Error checking course streak achievements:", error);
        }
      }

      // =====================================================
      // TIME-BASED ACHIEVEMENTS
      // =====================================================
      async function checkTimeBasedAchievements(timestamp) {
        const hour = timestamp.getHours();
        const dayOfWeek = timestamp.getDay();

        // Night owl (after midnight, before 6 AM)
        if (hour >= 0 && hour < 6) {
          await incrementTimeBasedCounter("midnight_sessions", "night_owl");
        }

        // Early bird (4 AM to 6 AM)
        if (hour >= 4 && hour < 6) {
          await incrementTimeBasedCounter("early_sessions", "early_bird");
        }

        // Weekend warrior (Saturday = 6, Sunday = 0)
        if (dayOfWeek === 0 || dayOfWeek === 6) {
          await incrementTimeBasedCounter(
            "weekend_sessions",
            "weekend_warrior"
          );
        }
      }

      async function incrementTimeBasedCounter(counterType, achievementId) {
        try {
          const dateStr = new Date().toISOString().split("T")[0];
          const cacheKey = `${counterType}_${currentUser.id}_${dateStr}`;

          // Prevent multiple increments per day
          if (sessionStorage.getItem(cacheKey)) return;

          // Update counter
          await supabase
            .from("profiles")
            .update({
              [counterType]: supabase.sql`${counterType} + 1`,
            })
            .eq("id", currentUser.id);

          // Cache to prevent double counting
          sessionStorage.setItem(cacheKey, "true");

          // Check related achievement
          if (achievementId) {
            await checkAndUnlockAchievement(achievementId, true);
          }
        } catch (error) {
          console.error(`Error incrementing ${counterType}:`, error);
        }
      }

      async function checkDailyStreak() {
        try {
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("last_activity, current_streak, last_streak_date")
            .eq("id", currentUser.id)
            .single();

          if (error) throw error;

          const now = new Date();
          const today = now.toDateString();
          const lastActivity = profile.last_activity
            ? new Date(profile.last_activity)
            : null;
          const lastStreakDate = profile.last_streak_date
            ? new Date(profile.last_streak_date).toDateString()
            : null;

          let newStreak = profile.current_streak || 0;
          let shouldUpdateStreak = false;

          if (!lastActivity) {
            // First time user
            newStreak = 1;
            shouldUpdateStreak = true;
          } else {
            const daysSinceLastActivity = Math.floor(
              (now - lastActivity) / (1000 * 60 * 60 * 24)
            );

            if (lastStreakDate === today) {
              // Already counted today's streak
              return newStreak;
            } else if (
              daysSinceLastActivity === 1 ||
              (daysSinceLastActivity === 0 && lastStreakDate !== today)
            ) {
              // Consecutive day or same day but not counted yet
              newStreak += 1;
              shouldUpdateStreak = true;
            } else if (daysSinceLastActivity > 1) {
              // Streak broken
              newStreak = 1;
              shouldUpdateStreak = true;
            }
          }

          if (shouldUpdateStreak) {
            await supabase
              .from("profiles")
              .update({
                current_streak: newStreak,
                last_activity: now.toISOString(),
                last_streak_date: now.toISOString(),
              })
              .eq("id", currentUser.id);

            userStats.current_streak = newStreak;

            showToast(`Daily streak: ${newStreak} days!`, "success");
            await checkStreakAchievements(newStreak);
          }

          return newStreak;
        } catch (error) {
          console.error("Error checking daily streak:", error);
          return 0;
        }
      }

      async function checkStreakAchievements(currentStreak) {
        const streakMilestones = [3, 7, 14, 30, 100, 365];

        for (const milestone of streakMilestones) {
          if (currentStreak >= milestone) {
            await checkAndUnlockAchievement(`streak_${milestone}`);
          }
        }
      }

      // =====================================================
      // USER ACTIVITY LOGGING
      // =====================================================
      async function logUserActivity(activityType, metadata = {}) {
        try {
          const now = new Date();

          const activityData = {
            user_id: currentUser.id,
            activity_type: activityType,
            timestamp: now.toISOString(),
            course_id: COURSE_DATA.id,
            lesson_index: currentLessonIndex,
            session_duration: courseSession.totalStudyTime,
            metadata: JSON.stringify(metadata),
            created_at: now.toISOString(),
          };

          // Try to log to activities table
          const { error } = await supabase
            .from("user_activities")
            .insert([activityData]);

          if (error && error.code !== "42P01") {
            console.warn("Activity logging failed:", error.message);
          }

          // Always update last activity in profile
          await supabase
            .from("profiles")
            .update({ last_activity: now.toISOString() })
            .eq("id", currentUser.id);
        } catch (error) {
          console.error("Error logging user activity:", error);
        }
      }

      // =====================================================
      // NAVIGATION SYSTEM
      // =====================================================
      function updateNavigationButtons() {
        const prevBtn = document.getElementById("prevLessonBtn");
        const nextBtn = document.getElementById("nextLessonBtn");

        if (!prevBtn || !nextBtn) return;

        // Previous button
        prevBtn.disabled = currentLessonIndex === 0;

        // Next button logic
        const isLastLesson =
          currentLessonIndex === COURSE_DATA.lessons.length - 1;
        const canGoNext =
          currentLessonIndex < COURSE_DATA.lessons.length - 1 &&
          canAccessLesson(currentLessonIndex + 1);

        if (isLastLesson) {
          const isCurrentCompleted =
            courseProgress[COURSE_DATA.lessons[currentLessonIndex].id]
              ?.completed;
          nextBtn.disabled = !isCurrentCompleted;
          nextBtn.innerHTML = '<i class="fas fa-trophy"></i> Complete Course';
        } else {
          nextBtn.disabled = !canGoNext;
          nextBtn.innerHTML = 'Next <i class="fas fa-chevron-right"></i>';
        }
      }

      // Navigation button event handlers
      function goToPreviousLesson() {
        if (currentLessonIndex > 0) {
          trackLessonTime(); // Track time spent on current lesson
          currentLessonIndex--;
          loadLesson(currentLessonIndex);
        }
      }

      function goToNextLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          const canGoNext = canAccessLesson(currentLessonIndex + 1);
          if (canGoNext) {
            trackLessonTime();
            currentLessonIndex++;
            loadLesson(currentLessonIndex);
          } else {
            showToast("Complete the current lesson quiz to proceed", "warning");
          }
        } else {
          // Complete course
          completeCourse();
        }
      }

      // =====================================================
      // SIDEBAR FUNCTIONS
      // =====================================================
      function toggleSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.toggle("open");
        if (overlay) overlay.classList.toggle("active");
      }

      function closeSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.remove("open");
        if (overlay) overlay.classList.remove("active");
      }

      // =====================================================
      // ACHIEVEMENT NOTIFICATION SYSTEM
      // =====================================================
      function queueAchievementNotification(achievement) {
        notificationQueue.push(achievement);
        processNotificationQueue();
      }

      function processNotificationQueue() {
        if (isShowingNotification || notificationQueue.length === 0) return;

        isShowingNotification = true;
        const achievement = notificationQueue.shift();
        showAchievementNotification(achievement);

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          isShowingNotification = false;
          processNotificationQueue();
        }, duration + 500);
      }

      function showAchievementNotification(achievement) {
        const notification = document.getElementById("achievementNotification");
        if (!notification) return;

        const icon = document.getElementById("notificationIcon");
        const title = document.getElementById("notificationTitle");
        const description = document.getElementById("notificationDescription");
        const points = document.getElementById("notificationPoints");

        if (icon) {
          icon.innerHTML = `<i class="${achievement.icon}"></i>`;
          icon.className = `notification-icon ${achievement.rarity}`;
        }
        if (title) title.textContent = achievement.name;
        if (description) description.textContent = achievement.description;
        if (points) points.textContent = `+${achievement.points} Points`;

        notification.className = `achievement-notification ${achievement.rarity}`;
        notification.classList.add("show");

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          notification.classList.remove("show");
        }, duration);
      }

      // =====================================================
      // UTILITY FUNCTIONS
      // =====================================================
      function calculateAverageQuizScore() {
        const scores = Object.values(courseProgress)
          .filter((p) => p.completed && p.quizScore)
          .map((p) => p.quizScore);

        if (scores.length === 0) return 0;
        return Math.round(
          scores.reduce((sum, score) => sum + score, 0) / scores.length
        );
      }

      async function resetProgress() {
        if (
          !confirm(
            "Are you sure you want to reset your progress? This action cannot be undone."
          )
        ) {
          return;
        }

        try {
          // Track lesson time before reset
          trackLessonTime();

          // Reset local state
          courseProgress = {};
          currentLessonIndex = 0;
          courseSession = {
            startTime: new Date(),
            totalStudyTime: 0,
            lessonsStarted: 0,
            lessonsCompleted: 0,
            pageLoadTime: new Date(),
            interactionCount: 0,
            lastActivityTime: new Date(),
          };

          // Delete from database
          await supabase
            .from("course_progress")
            .delete()
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Log reset activity
          logUserActivity("progress_reset", {
            course_id: COURSE_DATA.id,
            reset_reason: "manual",
          });

          // Reinitialize
          await saveProgress();
          renderSidebar();
          loadLesson(0);

          showToast("Progress reset successfully", "success");
        } catch (error) {
          console.error("Error resetting progress:", error);
          showToast("Failed to reset progress", "error");
        }
      }

      function copyCode(codeId) {
        const codeElement = document.getElementById(codeId);
        if (!codeElement) return;

        const text = codeElement.textContent;

        navigator.clipboard
          .writeText(text)
          .then(() => {
            showToast("Code copied to clipboard!", "success");

            // Track code copy for achievements
            logUserActivity("code_copied", {
              code_section: codeId,
              lesson_id: COURSE_DATA.lessons[currentLessonIndex].id,
            });
          })
          .catch((err) => {
            console.error("Failed to copy code:", err);
            showToast("Failed to copy code", "error");

            // Fallback for older browsers
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            try {
              document.execCommand("copy");
              showToast("Code copied to clipboard!", "success");
            } catch (fallbackError) {
              showToast(
                "Copy failed - please select and copy manually",
                "error"
              );
            }
            document.body.removeChild(textArea);
          });
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // =====================================================
      // UI FEEDBACK SYSTEMS
      // =====================================================
      function showToast(message, type = "success") {
        const toast = document.getElementById("toast");
        const messageEl = document.getElementById("toastMessage");

        if (!toast || !messageEl) {
          console.log(`Toast: ${message} (${type})`);
          return;
        }

        messageEl.textContent = message;
        toast.className = `toast ${type} show`;

        setTimeout(() => {
          toast.classList.remove("show");
        }, 4000);
      }

      function showLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) loadingScreen.classList.remove("hidden");
      }

      function hideLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) {
          setTimeout(() => {
            loadingScreen.classList.add("hidden");
          }, 1000);
        }
      }

      // =====================================================
      // MUSIC PLAYER INTEGRATION
      // =====================================================
      function initMusicPlayer() {
        const btnText = document.getElementById("music-button-text");
        const icon = document.getElementById("music-icon");
        const dropdown = document.getElementById("music-dropdown-content");

        if (!btnText || !icon || !dropdown) return;

        function setUI(state) {
          btnText.textContent =
            state === "Playing" ? "PAUSE MUSIC" : "STUDY MUSIC";
          icon.className =
            state === "Playing"
              ? "fa-solid fa-circle-pause"
              : "fa-solid fa-music";
        }

        // Load saved music state
        const savedSrc = localStorage.getItem("cybersec_music_src");
        const savedTime = parseFloat(
          localStorage.getItem("cybersec_music_time") || 0
        );

        if (savedSrc) {
          audioPlayer.src = savedSrc;
          audioPlayer.currentTime = savedTime;
          audioPlayer
            .play()
            .then(() => setUI("Playing"))
            .catch(() => setUI("Stopped"));
        }

        // Music button click handler
        document
          .getElementById("music-dropdown")
          .querySelector("button")
          .addEventListener("click", (e) => {
            e.stopPropagation();
            dropdown.style.display =
              dropdown.style.display === "block" ? "none" : "block";

            if (audioPlayer.src && !audioPlayer.paused) {
              audioPlayer.pause();
              setUI("Stopped");
            } else if (audioPlayer.src) {
              audioPlayer.play().then(() => setUI("Playing"));
            }
          });

        // Music selection handlers
        dropdown.querySelectorAll("a[data-src]").forEach((link) => {
          link.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.src = link.dataset.src;
            audioPlayer.play().then(() => setUI("Playing"));
            localStorage.setItem("cybersec_music_src", link.dataset.src);
            dropdown.style.display = "none";
          });
        });

        // Stop music handler
        const stopLink = document.getElementById("stop-music-link");
        if (stopLink) {
          stopLink.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            audioPlayer.removeAttribute("src");
            setUI("Stopped");
            localStorage.removeItem("cybersec_music_src");
            localStorage.removeItem("cybersec_music_time");
            dropdown.style.display = "none";
          });
        }

        // Save music state before page unload
        window.addEventListener("beforeunload", () => {
          if (!audioPlayer.paused && audioPlayer.src) {
            localStorage.setItem("cybersec_music_src", audioPlayer.src);
            localStorage.setItem(
              "cybersec_music_time",
              audioPlayer.currentTime
            );
          }
        });

        // Close dropdown when clicking outside
        window.addEventListener("click", (e) => {
          if (!e.target.closest("#music-dropdown")) {
            dropdown.style.display = "none";
          }
        });
      }

      // Show initial music indicator
      function addMusicIndicator() {
        const musicBtn = document.querySelector("#music-dropdown");
        if (musicBtn) {
          const indicator = document.createElement("div");
          indicator.className = "music-indicator";
          indicator.innerHTML = `<i class="fa-solid fa-music"></i> Try Study Music!`;

          musicBtn.style.position = "relative";
          musicBtn.appendChild(indicator);

          setTimeout(() => indicator.remove(), 3000);
        }
      }

      // Initialize Event Listeners
      function initializeEventListeners() {
        // Navigation buttons
        document
          .getElementById("prevLessonBtn")
          ?.addEventListener("click", goToPreviousLesson);
        document
          .getElementById("nextLessonBtn")
          ?.addEventListener("click", goToNextLesson);

        // Reset progress button
        document
          .getElementById("resetProgressBtn")
          ?.addEventListener("click", resetProgress);

        // Mobile menu toggle
        document
          .getElementById("menuToggle")
          ?.addEventListener("click", toggleSidebar);
        document
          .getElementById("sidebarOverlay")
          ?.addEventListener("click", closeSidebar);

        // Keyboard shortcuts
        document.addEventListener("keydown", handleKeyboardShortcuts);

        // Window resize handler
        window.addEventListener("resize", handleWindowResize);

        // Content interaction tracking
        document.getElementById("contentBody")?.addEventListener(
          "scroll",
          debounce(() => {
            trackUserInteraction();
          }, 1000)
        );
      }

      // Keyboard Shortcuts
      function handleKeyboardShortcuts(e) {
        if (document.querySelector(".quiz-question.active")) return;

        if (e.key === "ArrowLeft" && e.ctrlKey) {
          e.preventDefault();
          goToPreviousLesson();
        } else if (e.key === "ArrowRight" && e.ctrlKey) {
          e.preventDefault();
          goToNextLesson();
        }
      }

      // Window Resize Handler
      function handleWindowResize() {
        if (window.innerWidth > 768) {
          closeSidebar();
        }
      }

      // Debounce Helper
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Initialize responsive behavior
      if (window.innerWidth <= 768) {
        document.getElementById("menuToggle").style.display = "inline-flex";
      }

      // Auto-save progress periodically
      setInterval(async () => {
        if (currentUser && Object.keys(courseProgress).length > 0) {
          await saveProgress();
        }
      }, 60000); // Save every minute

      // System initialization logging
      console.log("CyberSec Academy Course System Initialized");
      console.log("Current Course:", COURSE_DATA.title);
      console.log("Total Lessons:", COURSE_DATA.lessons.length);

      // Google OAuth Integration
      const googleBtn = document.querySelector(".btn-google");
      if (googleBtn) {
        googleBtn.addEventListener("click", async () => {
          const { data, error } = await supabase.auth.signInWithOAuth({
            provider: "google",
            options: {
              redirectTo: window.location.origin + "/courses/threat-hunting-professional-detailed-expanded.html",
            },
          });

          if (error) {
            console.error("Google login error:", error.message);
            showToast("Google login failed: " + error.message, "error");
          }
        });
      }

      // Check for existing session
      supabase.auth.getSession().then(({ data }) => {
        if (data.session) {
          console.log("User already logged in:", data.session.user);
          currentUser = data.session.user;
          startCourseSession();
        }
      });

      // Add missing auth modal functions
      function openAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "flex";
        }
      }

      function closeAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Add auth tab switching functionality
      document.getElementById("tabSignIn")?.addEventListener("click", () => {
        document.getElementById("tabSignIn").classList.add("active");
        document.getElementById("tabSignUp").classList.remove("active");
        document.getElementById("signInForm").style.display = "block";
        document.getElementById("signUpForm").style.display = "none";
      });

      document.getElementById("tabSignUp")?.addEventListener("click", () => {
        document.getElementById("tabSignUp").classList.add("active");
        document.getElementById("tabSignIn").classList.remove("active");
        document.getElementById("signUpForm").style.display = "block";
        document.getElementById("signInForm").style.display = "none";
      });

      document
        .getElementById("closeAuthModal")
        ?.addEventListener("click", closeAuthModal);

      // Improved error handling for auth session
      supabase.auth.onAuthStateChange((event, session) => {
        if (event === "SIGNED_IN") {
          currentUser = session.user;
          closeAuthModal();
          startCourseSession();
        } else if (event === "SIGNED_OUT") {
          currentUser = null;
          openAuthModal();
        }
      });

      // Add form submission handlers
      document
        .getElementById("emailSignInForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signInEmail").value;
          const password = document.getElementById("signInPassword").value;

          try {
            const { data, error } = await supabase.auth.signInWithPassword({
              email,
              password,
            });

            if (error) throw error;

            closeAuthModal();
          } catch (error) {
            showToast(error.message, "error");
          }
        });

      document
        .getElementById("emailSignUpForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signUpEmail").value;
          const password = document.getElementById("signUpPassword").value;
          const name = document.getElementById("signUpName").value;

          try {
            const { data, error } = await supabase.auth.signUp({
              email,
              password,
              options: {
                data: {
                  full_name: name,
                },
              },
            });

            if (error) throw error;

            showToast(
              "Account created successfully! Please check your email.",
              "success"
            );
          } catch (error) {
            showToast(error.message, "error");
          }
        });
    </script>
  </body>
</html>

