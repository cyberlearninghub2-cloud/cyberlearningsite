


<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>Web Application Security Course Curriculum | CipherHall</title>
    <meta name="description" content="Begin your free Web Application Security course. This curriculum covers the OWASP Top 10, including SQLi, XSS, CSRF, Broken Access Control, and secure development." />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png" />
    <link rel="shortcut icon" href="/favicon.png" type="image/x-icon" />
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png" />
    <link rel="canonical" href="https://www.cipherhall.com/courses/web-application-security.html" />
<meta name="robots" content="noindex, nofollow" />
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Course",
      "name": "Web Application Security",
      "description": "A comprehensive course covering the essential principles and practices of modern web application security, from foundational concepts to advanced defense mechanisms.",
      "provider": {
        "@type": "Organization",
        "name": "CipherHall",
        "sameAs": "https://www.cipherhall.com"
      },
      "hasCourseInstance": {
        "@type": "CourseInstance",
        "courseMode": "Online",
        "instructor": {
          "@type": "Person",
          "name": "Dr. Anya Sharma"
        }
      }
    }
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Exo+2:wght@700;800;900&display=swap" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" />
    <link rel="stylesheet" href="assets/css/coursepages.css">
</head>
  <body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
      <div class="loader-icon">
        <i class="fas fa-graduation-cap"></i>
      </div>
      <div class="loader-text">Loading Course Content...</div>
    </div>

    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- Music Player (fixed at top right) -->
    <div class="header-controls">
      <div class="music-dropdown" id="music-dropdown">
        <button class="btn btn-secondary">
          <span id="music-button-text">STUDY MUSIC</span>
          <i id="music-icon" class="fa-solid fa-music"></i>
        </button>
        <div class="music-dropdown-content" id="music-dropdown-content">
          <a
            href="#"
            data-src="https://www.learningcontainer.com/wp-content/uploads/2020/02/Kalimba.mp3"
            >1. Coffee Shop Vibes</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3"
            >2. City Lights Lofi</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-15.mp3"
            >3. Mellow Thoughts</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-13.mp3"
            >4. Rainy Mood</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3"
            >5. Time Alone</a
          >
          <a href="#" id="stop-music-link"
            ><i class="fa-solid fa-stop-circle"></i> Stop Music</a
          >
        </div>
      </div>

      <button class="btn btn-secondary" id="resetProgressBtn">
        <i class="fas fa-redo"></i>
        Reset Progress
      </button>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal" style="display: none">
      <div class="modal-overlay"></div>
      <div class="modal-content">
        <span class="close" id="closeAuthModal">&times;</span>
        <div class="auth-tabs">
          <button id="tabSignIn" class="auth-tab active">Sign In</button>
          <button id="tabSignUp" class="auth-tab">Sign Up</button>
        </div>
        <div
          id="authLoader"
          style="display: none; text-align: center; padding: 2rem"
        >
          <i
            class="fas fa-spinner fa-spin fa-2x"
            style="color: var(--color-green)"
          ></i>
          <p style="margin-top: 0.5rem">Authenticating...</p>
        </div>
        <div id="signInForm" class="auth-form">
          <h2>Sign In to CipherHall</h2>
          <button id="googleSignIn" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignInForm">
            <input
              type="email"
              id="signInEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signInPassword"
              placeholder="Password"
              required
            />
            <button type="submit" class="btn btn-primary">Sign In</button>
          </form>
        </div>
        <div id="signUpForm" class="auth-form" style="display: none">
          <h2>Join CipherHall</h2>
          <button id="googleSignUp" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignUpForm">
            <input
              type="text"
              id="signUpName"
              placeholder="Full Name"
              required
            />
            <input
              type="email"
              id="signUpEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signUpPassword"
              placeholder="Password (min. 8 characters)"
              required
            />
            <button type="submit" class="btn btn-secondary">
              Create Account
            </button>
          </form>
        </div>
        <div id="authMessage"></div>
      </div>
    </div>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="course-info">
          <h1 class="course-title" id="courseTitle">Loading...</h1>
          <div class="course-progress">
            <div class="progress-header">
              <span class="progress-label">Course Progress</span>
              <span class="progress-percentage" id="courseProgressPercent"
                >0%</span
              >
            </div>
            <div class="progress-bar">
              <div
                class="progress-fill"
                id="courseProgressFill"
                style="width: 0%"
              ></div>
            </div>
            <div class="progress-stats">
              <span id="completedLessons">0</span>
              <span id="totalLessons">0</span>
            </div>
          </div>
          <a href="/dashboard.html" class="back-to-dashboard">
            <i class="fas fa-arrow-left"></i>
            Back to Dashboard
          </a>
        </div>
      </div>

      <nav class="lesson-nav" id="lessonNav">
        <!-- Lessons will be loaded dynamically -->
      </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <header class="content-header">
        <div class="lesson-header">
          <div class="lesson-header-left">
            <span class="lesson-number" id="currentLessonNumber">1</span>
            <h1 class="lesson-header-title" id="currentLessonTitle">
              Loading...
            </h1>
          </div>
          <div class="lesson-actions">
            <button class="mbtn btn-primary" id="menuToggle">
              <i class="fas fa-bars"></i>
            </button>
          </div>
        </div>
      </header>

      <div class="content-body" id="contentBody">
        <div class="lesson-content" id="lessonContent">
          <!-- Lesson content will be loaded dynamically -->
        </div>
      </div>

      <footer class="lesson-navigation">
        <div class="nav-info" id="navInfo">Lesson 1 of 10</div>
        <div class="nav-controls">
          <button class="btn btn-secondary" id="prevLessonBtn" disabled>
            <i class="fas fa-chevron-left"></i>
            Previous
          </button>
          <button class="btn btn-primary" id="nextLessonBtn" disabled>
            Next
            <i class="fas fa-chevron-right"></i>
          </button>
        </div>
      </footer>
    </main>

    <!-- Achievement Notification -->
    <div id="achievementNotification" class="achievement-notification">
      <div class="notification-header">
        <div class="notification-icon" id="notificationIcon">
          <i class="fas fa-trophy"></i>
        </div>
        <div class="notification-content">
          <h3 id="notificationTitle">Achievement Unlocked!</h3>
          <p id="notificationDescription">Description here...</p>
        </div>
      </div>
      <div class="notification-reward" id="notificationReward">
        <i class="fas fa-coins"></i>
        <span id="notificationPoints">+100 Points</span>
      </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast">
      <span id="toastMessage"></span>
    </div>

    <script>
      // =====================================================
      // SYNCHRONIZED COURSE SYSTEM WITH DASHBOARD INTEGRATION
      // =====================================================

      // Supabase Configuration - Replace with your config
      const supabaseUrl = "https://lzcmzulemfubjaksoqor.supabase.co";
      const supabaseKey =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx6Y216dWxlbWZ1Ympha3NvcW9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzMzM5MDgsImV4cCI6MjA3MDkwOTkwOH0.crhPH4YWtRsr1BJTpAQcmPbWSpwIWRbzoI4sRb2_fPI";
      const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

      // =====================================================
      // COURSE DATA STRUCTURE - REPLACE WITH YOUR COURSE JSON
      // =====================================================

      const COURSE_DATA = {
        id: "web-application-security-full-course",
        title: "Web Application Security – Full 20 Lesson Syllabus",
        description:
          "A comprehensive course covering the essential principles and practices of modern web application security, from foundational concepts to advanced defense mechanisms.",
        category: "cybersecurity",
        difficulty: "Intermediate to Advanced",
        duration: "40 hours",
        instructor: "Dr. Evelyn Reed",
        lessons: [
          {
            id: "lesson-1",
            title: "Introduction to Web Application Security",
            duration: "90 min",
            objectives: [
              "Understand why web security is critical in the modern digital landscape.",
              "Explain the CIA triad (Confidentiality, Integrity, Availability) and its relevance.",
              "Recognize common attack motivations and categorize various threat actors.",
              "Analyze a real-world data breach to identify the impact and violated security principles.",
            ],
            content: {
              overview:
                "This foundational lesson introduces the critical importance of web application security. We will explore the core principles of the CIA triad, dissect the motivations behind cyber attacks, and analyze a real-world case study to understand the tangible consequences of security vulnerabilities.",
              sections: [
                {
                  title: "The Critical Need for Web Security",
                  content:
                    "<p>In an interconnected world, web applications are the gateway to sensitive data and critical services. A security failure can lead to devastating financial loss, reputational damage, and legal consequences. Understanding how to build and maintain secure applications is no longer optional—it's an essential requirement for developers, administrators, and organizations.</p><h3>Key Risk Areas:</h3><ul><li><strong>Data Breaches:</strong> Exposure of personal, financial, or proprietary information.</li><li><strong>Service Disruption:</strong> Attacks like Denial of Service (DoS) can bring business operations to a halt.</li><li><strong>Financial Fraud:</strong> Unauthorized transactions and theft of financial assets.</li><li><strong>Reputation Damage:</strong> Loss of customer trust, which can be difficult or impossible to regain.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1555949963-ff980e82135c?w=800&h=400&fit=crop",
                },
                {
                  title: "The CIA Triad: Core Security Principles",
                  content:
                    "<p>The CIA triad is a foundational model for guiding information security policies and practices.</p><h3>The Three Pillars:</h3><ul><li><strong>Confidentiality:</strong> Ensuring that data is accessible only to authorized individuals. It's about preventing unauthorized disclosure.</li><li><strong>Integrity:</strong> Maintaining the consistency, accuracy, and trustworthiness of data. Data must not be altered in an unauthorized or undetected manner.</li><li><strong>Availability:</strong> Guaranteeing that information and services are accessible to authorized users when needed.</li></ul><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Real-World Example</strong></div><p>A ransomware attack violates <strong>Availability</strong> by locking legitimate users out of their data. If the attackers also exfiltrate and publish the data, it violates <strong>Confidentiality</strong>. If they alter records, they violate <strong>Integrity</strong>.</p></div>",
                  image:
                    "https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?w=800&h=400&fit=crop",
                },
                {
                  title: "Threat Actors and Motivations",
                  content:
                    "<p>Understanding who might attack your application and why is key to building effective defenses.</p><h3>Common Threat Actors:</h3><ul><li><strong>Cybercriminals:</strong> Primarily motivated by financial gain (e.g., ransomware, credit card theft).</li><li><strong>Hacktivists:</strong> Motivated by political or social agendas (e.g., Anonymous).</li><li><strong>State-Sponsored Actors:</strong> Nation-states seeking intelligence or to disrupt other nations.</li><li><strong>Insider Threats:</strong> Disgruntled employees or contractors with privileged access.</li><li><strong>Script Kiddies:</strong> Amateurs using existing tools without deep knowledge, often for bragging rights.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1593642702821-c8da6758f0c6?w=800&h=400&fit=crop",
                },
              ],
              activities: [
                {
                  title: "Case Study Analysis: The 2017 Equifax Breach",
                  description:
                    "Read about the Equifax data breach, which exposed the personal information of 147 million people. In your analysis, identify which elements of the CIA triad were violated and explain how. Consider the threat actor's likely motivation.",
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "Which principle of the CIA triad ensures that data is not altered or destroyed in an unauthorized manner?",
                  options: [
                    "Confidentiality",
                    "Integrity",
                    "Availability",
                    "Authorization",
                  ],
                  correct: 1,
                  explanation:
                    "Integrity is the principle that ensures the accuracy and trustworthiness of data by preventing unauthorized modifications.",
                },
                {
                  id: 2,
                  question:
                    "A Distributed Denial of Service (DDoS) attack primarily targets which aspect of the CIA triad?",
                  options: [
                    "Confidentiality",
                    "Integrity",
                    "Availability",
                    "Non-repudiation",
                  ],
                  correct: 2,
                  explanation:
                    "DDoS attacks are designed to overwhelm a system's resources, making it inaccessible to legitimate users, which is a direct attack on its Availability.",
                },
                {
                  id: 3,
                  question:
                    "A 'hacktivist' is a threat actor primarily motivated by:",
                  options: [
                    "Financial gain",
                    "Political or social agendas",
                    "Espionage",
                    "Intellectual curiosity",
                  ],
                  correct: 1,
                  explanation:
                    "Hacktivists use their skills to promote a political or social cause, often through website defacement or data leaks.",
                },
              ],
            },
          },
          {
            id: "lesson-2",
            title: "Web Basics Refresher",
            duration: "75 min",
            objectives: [
              "Review the core HTTP methods (GET, POST, PUT, DELETE) and their intended use.",
              "Explain the mechanics of sessions, cookies, and tokens for state management.",
              "Understand the importance of the Same-Origin Policy (SOP) and Cross-Origin Resource Sharing (CORS).",
            ],
            content: {
              overview:
                "Before diving into vulnerabilities, it's crucial to have a solid grasp of the fundamental technologies that power the web. This lesson revisits HTTP, state management with cookies and sessions, and the browser's core security model.",
              sections: [
                {
                  title: "Understanding HTTP Methods",
                  content:
                    "<p>HTTP methods define the action to be performed on a resource.</p><ul><li><strong>GET:</strong> Requests data from a specified resource. Should be safe and idempotent.</li><li><strong>POST:</strong> Submits data to be processed to a specified resource, often causing a change in state.</li><li><strong>PUT:</strong> Updates a specified resource with the request payload.</li><li><strong>DELETE:</strong> Deletes a specified resource.</li></ul><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Security Note</strong></div><p>Never use GET requests for state-changing actions (e.g., deleting a user). They can be triggered by simple links and are logged in browser history and server logs, potentially exposing sensitive data.</p></div>",
                },
                {
                  title: "Sessions, Cookies, and Tokens",
                  content:
                    "<p>HTTP is stateless, so we need mechanisms to track user identity across multiple requests.</p><ul><li><strong>Cookies:</strong> Small pieces of data stored by the browser. A server can set a cookie, and the browser will send it back with every subsequent request to that server.</li><li><strong>Sessions:</strong> A server-side mechanism to store user data. The server gives the client a session ID (usually in a cookie), which acts as a key to retrieve the user's information on subsequent requests.</li><li><strong>Tokens (e.g., JWT):</strong> A self-contained credential that contains user information and a cryptographic signature. The server issues a token, and the client sends it in the `Authorization` header. This is common in APIs and single-page applications.</li></ul>",
                },
                {
                  title: "Same-Origin Policy (SOP) & CORS",
                  content:
                    "<p>SOP is a critical browser security feature that restricts how a document or script loaded from one origin can interact with a resource from another origin.</p><ul><li><strong>Origin:</strong> A combination of protocol (http/https), domain, and port.</li><li><strong>CORS (Cross-Origin Resource Sharing):</strong> A mechanism that uses additional HTTP headers to tell browsers to give a web application running at one origin, access to selected resources from a different origin. If `Access-Control-Allow-Origin: *` is set, any origin can access the resource, which can be dangerous.</li></ul>",
                },
              ],
              codeExamples: [
                {
                  title: "Inspecting a POST Request with Browser Dev Tools",
                  language: "bash",
                  code: "# 1. Open your browser's Developer Tools (F12 or Ctrl+Shift+I).\n# 2. Go to the 'Network' tab.\n# 3. Log in to a website.\n# 4. Find the login request (often named 'login', 'auth', etc.).\n# 5. Inspect the 'Headers' tab to see the Request Method (POST), Headers, and Form Data (username/password).\n# 6. Check the 'Response' tab for server headers, including `Set-Cookie` for the session ID.",
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "Which HTTP method is designed to be idempotent and safe, meaning it can be called multiple times without different outcomes?",
                  options: ["POST", "PUT", "GET", "PATCH"],
                  correct: 2,
                  explanation:
                    "GET is designed to retrieve data and should not have side effects, making it both safe and idempotent.",
                },
                {
                  id: 2,
                  question:
                    "What is the primary purpose of the Same-Origin Policy (SOP)?",
                  options: [
                    "To prevent a malicious script on one page from obtaining sensitive data from another web page.",
                    "To ensure all web traffic is encrypted.",
                    "To manage user sessions.",
                    "To allow unrestricted access between different domains.",
                  ],
                  correct: 0,
                  explanation:
                    "SOP is a fundamental security mechanism that restricts scripts from one origin from interacting with resources from another, preventing data theft.",
                },
                {
                  id: 3,
                  question:
                    "In token-based authentication (like JWT), where is the user's state primarily stored?",
                  options: [
                    "In a server-side session object.",
                    "In the browser's local storage.",
                    "Inside the token itself on the client-side.",
                    "In a global variable on the server.",
                  ],
                  correct: 2,
                  explanation:
                    "JWTs are self-contained, meaning the user's claims and identity information are stored within the token, which is held by the client. This makes the authentication stateless on the server side.",
                },
              ],
            },
          },
          {
            id: "lesson-3",
            title: "Authentication & Authorization",
            duration: "120 min",
            objectives: [
              "Compare and contrast session-based and token-based authentication mechanisms.",
              "Learn the principles of secure password storage, including hashing and salting.",
              "Understand common authorization models like Role-Based Access Control (RBAC) and Attribute-Based Access Control (ABAC).",
            ],
            content: {
              overview:
                "Authentication confirms who a user is, while authorization determines what they are allowed to do. This lesson covers the core mechanisms for managing user identity securely and enforcing access policies effectively.",
              sections: [
                {
                  title: "Session-Based vs. Token-Based Authentication",
                  content:
                    "<p>Both methods solve the problem of stateless HTTP, but in different ways.</p><h3>Session-Based:</h3><ul><li><strong>Stateful:</strong> The server stores session data for each user.</li><li><strong>Mechanism:</strong> A session ID is created on the server and sent to the client as a cookie. The client sends the session ID back with each request.</li><li><strong>Pros:</strong> Session data is not exposed to the client; session can be easily invalidated on the server.</li><li><strong>Cons:</strong> Requires server-side storage, can be challenging to scale in distributed systems.</li></ul><h3>Token-Based (e.g., JWT):</h3><ul><li><strong>Stateless:</strong> The server does not need to store token information.</li><li><strong>Mechanism:</strong> The server signs a token containing user claims and sends it to the client. The client stores the token and sends it in the `Authorization` header.</li><li><strong>Pros:</strong> Scalable, works well with microservices and mobile apps.</li><li><strong>Cons:</strong> Token data is visible to the client (though not tamper-proof); invalidation is more complex.</li></ul>",
                },
                {
                  title: "Secure Password Storage",
                  content:
                    "<p>Storing passwords in plaintext is one of the most severe and inexcusable security flaws. Proper password storage is non-negotiable.</p><h3>Best Practices:</h3><ol><li><strong>Never Store Plaintext Passwords:</strong> Assume your database will be breached.</li><li><strong>Use a Strong Hashing Algorithm:</strong> Use modern, slow, adaptive hashing functions like Argon2 (preferred), scrypt, or bcrypt. Avoid fast algorithms like MD5 or SHA-1, which are vulnerable to brute-force attacks.</li><li><strong>Use a Unique Salt for Every Password:</strong> A salt is a random string added to the password before hashing. This ensures that even if two users have the same password, their stored hashes will be different, defeating rainbow table attacks.</li></ol><div class='info-box tip'><div class='info-box-header'><i class='fas fa-lightbulb'></i><strong>What is a Pepper?</strong></div><p>A 'pepper' is a secret value added before hashing, similar to a salt, but it's the same for all passwords and is stored separately from the database (e.g., in a config file). It adds an extra layer of protection if only the database is compromised.</p></div>",
                },
                {
                  title: "Authorization Models: RBAC vs. ABAC",
                  content:
                    "<p>Once a user is authenticated, you need to decide what they can access.</p><h3>Role-Based Access Control (RBAC):</h3><ul><li>Permissions are assigned to roles (e.g., 'admin', 'editor', 'viewer').</li><li>Users are then assigned one or more roles.</li><li>This is a simple and widely used model. Example: An 'editor' role can create and edit posts, but not delete users.</li></ul><h3>Attribute-Based Access Control (ABAC):</h3><ul><li>Access is granted based on a combination of attributes of the user, the resource, and the environment.</li><li>It uses policies and rules. Example: 'Allow users from the 'Finance' department to access 'Financial Reports' on the corporate network during business hours.'</li><li>ABAC is more fine-grained and flexible than RBAC but also more complex to implement.</li></ul>",
                },
              ],
              codeExamples: [
                {
                  title: "Secure Password Hashing in Python",
                  language: "python",
                  code: 'from werkzeug.security import generate_password_hash, check_password_hash\n\npassword = "MySuperSecretPa$$w0rd"\n\n# SECURE: Using a modern library that handles hashing and salting correctly.\n# This generates a hash that includes the algorithm, salt, and hash value.\nsecure_hash = generate_password_hash(password, method=\'pbkdf2:sha256\', salt_length=16)\nprint(f"Secure Hash: {secure_hash}")\n\n# Verification\nis_correct = check_password_hash(secure_hash, password)\nprint(f"Password is correct: {is_correct}")',
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the primary purpose of adding a 'salt' to a password before hashing it?",
                  options: [
                    "To make the hash shorter.",
                    "To encrypt the password.",
                    "To ensure unique hashes for identical passwords, preventing rainbow table attacks.",
                    "To make the hashing process faster.",
                  ],
                  correct: 2,
                  explanation:
                    "A unique salt for each password ensures that even if two users choose the same password, their stored hashes will be different. This mitigates pre-computed hash attacks (rainbow tables).",
                },
                {
                  id: 2,
                  question:
                    "Which of the following is a key characteristic of stateless, token-based authentication?",
                  options: [
                    "The server must store session information for every active user.",
                    "The server does not need to store session state; the token contains all necessary info.",
                    "It requires a new token for every single request.",
                    "It is less scalable than session-based authentication.",
                  ],
                  correct: 1,
                  explanation:
                    "Token-based authentication is stateless because the self-contained token provides the server with enough information to verify the user's identity and permissions without needing to look up session data.",
                },
                {
                  id: 3,
                  question:
                    "Assigning permissions to a group named 'Administrators' and then adding users to that group is an example of which access control model?",
                  options: [
                    "Discretionary Access Control (DAC)",
                    "Mandatory Access Control (MAC)",
                    "Attribute-Based Access Control (ABAC)",
                    "Role-Based Access Control (RBAC)",
                  ],
                  correct: 3,
                  explanation:
                    "This is a classic example of Role-Based Access Control (RBAC), where permissions are associated with roles, and users inherit permissions by being assigned to those roles.",
                },
              ],
            },
          },
          {
            id: "lesson-4",
            title: "Injection Attacks (SQLi, Command Injection)",
            duration: "120 min",
            objectives: [
              "Identify and exploit SQL injection (SQLi) vulnerabilities in web applications.",
              "Explain the risks and mechanisms of command injection attacks.",
              "Apply fundamental mitigation techniques like parameterized queries (prepared statements) and Object-Relational Mapping (ORM).",
            ],
            content: {
              overview:
                "Injection attacks occur when untrusted data is sent to an interpreter as part of a command or query. This lesson focuses on two of the most critical injection flaws: SQL Injection, which targets databases, and Command Injection, which targets the host operating system.",
              sections: [
                {
                  title: "SQL Injection (SQLi)",
                  content:
                    "<p>SQL Injection is a code injection technique used to attack data-driven applications, in which malicious SQL statements are inserted into an entry field for execution (e.g., to dump the database contents to the attacker).</p><h3>Example of a Vulnerable Query:</h3><code>query = \"SELECT * FROM users WHERE username = '\" + username + \"' AND password = '\" + password + \"';\"</code><p>If an attacker enters `' OR '1'='1` as the username, the query becomes `SELECT * FROM users WHERE username = '' OR '1'='1' ...`, bypassing the authentication.</p><h3>Mitigation: Parameterized Queries</h3><p>Parameterized queries (or prepared statements) separate the SQL command from the user-supplied data. The database driver ensures that the data is treated as a literal value, not as executable code.</p>",
                  image:
                    "https://images.unsplash.com/photo-1585079542156-2755d9c8a094?w=800&h=400&fit=crop",
                },
                {
                  title: "Command Injection",
                  content:
                    "<p>Command injection is an attack in which the goal is the execution of arbitrary commands on the host operating system via a vulnerable application. These attacks are possible when an application passes unsafe user-supplied data (forms, cookies, HTTP headers etc.) to a system shell.</p><h3>Example of a Vulnerable Script:</h3><code># A script that pings a user-supplied IP address\n$ip = $_GET['ip'];\nsystem(\"ping -c 1 \" . $ip);</code><p>An attacker could provide the input `8.8.8.8; ls -la`, causing the server to execute `ping -c 1 8.8.8.8; ls -la`, revealing a directory listing.</p><h3>Mitigation: Avoid System Calls</h3><p>The best defense is to avoid calling out to OS commands with user input. Use built-in library functions instead. If you must, use functions that specifically handle command arguments safely and validate input strictly against an allow-list.</p>",
                  image:
                    "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop",
                },
              ],
              activities: [
                {
                  title: "Exploit and Fix SQLi in DVWA",
                  description:
                    "Using the Damn Vulnerable Web Application (DVWA), perform a basic SQL injection attack to retrieve user information from the database. Afterwards, examine the fixed source code to understand how prepared statements prevent the attack.",
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the most effective way to prevent SQL Injection attacks?",
                  options: [
                    "Sanitizing user input by removing quotes.",
                    "Using an Object-Relational Mapper (ORM) or parameterized queries.",
                    "Hashing all user input before it reaches the database.",
                    "Using a Web Application Firewall (WAF).",
                  ],
                  correct: 1,
                  explanation:
                    "While a WAF can help, the most robust and correct way to prevent SQLi is at the code level by using ORMs or parameterized queries, which ensure user input is treated as data, not code.",
                },
                {
                  id: 2,
                  question:
                    "An attacker submits the value `127.0.0.1 && cat /etc/passwd` to a form field that is used in a system ping command. What type of attack is this?",
                  options: [
                    "Cross-Site Scripting (XSS)",
                    "SQL Injection (SQLi)",
                    "Cross-Site Request Forgery (CSRF)",
                    "Command Injection",
                  ],
                  correct: 3,
                  explanation:
                    "This is a command injection attack. The `&&` is a shell operator that allows the attacker to chain a second command (`cat /etc/passwd`) to the intended ping command.",
                },
              ],
            },
          },
          {
            id: "lesson-5",
            title: "Broken Authentication",
            duration: "90 min",
            objectives: [
              "Recognize the symptoms and risks of weak session management.",
              "Understand common session hijacking techniques, including cookie theft.",
              "Implement stronger security practices for sessions and introduce Multi-Factor Authentication (MFA).",
            ],
            content: {
              overview:
                "Broken Authentication covers flaws in the design and implementation of managing user identity. If authentication is broken, attackers can impersonate legitimate users, gaining access to their data and functionality.",
              sections: [
                {
                  title: "Weak Session Management",
                  content:
                    "<p>A 'session' begins when a user logs in and ends when they log out. The session is managed by a session token (or cookie). Flaws in how these tokens are generated, transmitted, and protected can lead to a compromise.</p><h3>Common Weaknesses:</h3><ul><li><strong>Predictable Session IDs:</strong> If session IDs are sequential or easy to guess, an attacker can hijack a session by simply guessing a valid ID.</li><li><strong>Insecure Transmission:</strong> Session cookies sent over unencrypted HTTP can be sniffed by anyone on the same network.</li><li><strong>No Timeout:</strong> Sessions that never expire increase the window of opportunity for an attacker to steal a valid session token.</li><li><strong>Session Fixation:</strong> An attacker tricks a user into using a session ID chosen by the attacker. When the user logs in, the attacker can use that same session ID to impersonate them.</li></ul>",
                },
                {
                  title: "Session Hijacking Techniques",
                  content:
                    "<p>The goal of session hijacking is to steal a valid session token, allowing the attacker to impersonate a user.</p><h3>Methods:</h3><ul><li><strong>XSS Exploitation:</strong> A Cross-Site Scripting vulnerability can be used to run JavaScript that steals the user's session cookie (`document.cookie`) and sends it to the attacker.</li><li><strong>Network Sniffing:</strong> On an unsecured Wi-Fi network, an attacker can intercept traffic and capture session cookies sent over HTTP.</li><li><strong>Malware:</strong> Malware on a user's computer can access browser data, including stored session cookies.</li></ul><div class='info-box tip'><div class='info-box-header'><i class='fas fa-lightbulb'></i><strong>Cookie Security Attributes</strong></div><p>Use the `HttpOnly` flag to prevent JavaScript from accessing the cookie, mitigating XSS-based theft. Use the `Secure` flag to ensure the cookie is only sent over HTTPS.</p></div>",
                },
                {
                  title: "Implementing Stronger Practices",
                  content:
                    "<p>Strengthening authentication involves multiple layers of defense.</p><h3>Best Practices:</h3><ul><li><strong>Regenerate Session ID on Login:</strong> To prevent session fixation, always generate a new session ID immediately after a user successfully authenticates.</li><li><strong>Enforce Multi-Factor Authentication (MFA):</strong> Require a second factor of authentication (e.g., a code from an authenticator app, a text message, or a hardware key) in addition to a password. This provides a strong defense even if passwords are stolen.</li><li><strong>Implement Secure Logout:</strong> A logout function must invalidate the session on the server side, not just delete the cookie on the client side.</li></ul>",
                },
              ],
              activities: [
                {
                  title: "Simulate a Session Cookie Theft Attack",
                  description:
                    "In a controlled lab environment, use a simple XSS payload to display a user's session cookie. Then, use browser developer tools to manually insert that stolen cookie into your own browser to hijack the user's session.",
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the purpose of the `HttpOnly` flag on a session cookie?",
                  options: [
                    "It ensures the cookie is only sent over HTTPS.",
                    "It makes the cookie expire after a set time.",
                    "It prevents client-side scripts (like JavaScript) from accessing the cookie.",
                    "It encrypts the cookie's value.",
                  ],
                  correct: 2,
                  explanation:
                    "The `HttpOnly` flag tells the browser that the cookie should only be accessed by the server, not by client-side scripts. This is a primary defense against session theft via XSS.",
                },
                {
                  id: 2,
                  question:
                    "Which of these is a critical step to prevent session fixation attacks?",
                  options: [
                    "Using long, random session IDs.",
                    "Setting a short session timeout.",
                    "Regenerating the session ID immediately after successful authentication.",
                    "Enforcing a strong password policy.",
                  ],
                  correct: 2,
                  explanation:
                    "Session fixation involves an attacker tricking a user into using a known session ID. By creating a new session ID upon login, the old (pre-authentication) session is discarded, thwarting the attack.",
                },
                {
                  id: 3,
                  question:
                    "Multi-Factor Authentication (MFA) protects against which common attack?",
                  options: [
                    "SQL Injection",
                    "Denial of Service",
                    "Stolen or weak passwords",
                    "Security Misconfiguration",
                  ],
                  correct: 2,
                  explanation:
                    "MFA adds another layer of security. Even if an attacker has the user's password, they cannot log in without the second factor (e.g., the code from their phone).",
                },
              ],
            },
          },
          {
            id: "lesson-6",
            title: "Sensitive Data Exposure",
            duration: "90 min",
            objectives: [
              "Understand the importance of securing data in transit using HTTPS/TLS.",
              "Differentiate between security needs for data at rest versus data in transit.",
              "Apply proper key and password management techniques.",
            ],
            content: {
              overview:
                "This lesson focuses on the failure to adequately protect sensitive information. This can include anything from passwords and credit card numbers to health records and personal information. We'll cover protecting data both as it travels over the network and as it's stored on disk.",
              sections: [
                {
                  title: "Securing Data in Transit with HTTPS/TLS",
                  content:
                    "<p>Any data sent between a client and a server over a network can be intercepted. Encrypting this data is essential.</p><ul><li><strong>HTTP (Hypertext Transfer Protocol):</strong> Transmits data in plaintext. Anyone on the network can read it.</li><li><strong>HTTPS (HTTP Secure):</strong> Uses Transport Layer Security (TLS) to create an encrypted, authenticated channel between the client and server.</li></ul><h3>Key Benefits of TLS:</h3><ul><li><strong>Confidentiality:</strong> Protects against eavesdropping.</li><li><strong>Integrity:</strong> Protects against man-in-the-middle attacks altering data.</li><li><strong>Authentication:</strong> The TLS certificate verifies that you are communicating with the correct server.</li></ul><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Always Use HTTPS</strong></div><p>Modern best practice is to use HTTPS for all traffic, not just for login pages or sensitive forms. This prevents partial content sniffing and protects user privacy.</p></div>",
                },
                {
                  title: "Protecting Data at Rest",
                  content:
                    "<p>Data at rest is data that is stored on a physical medium, like a hard drive or in a database.</p><h3>Common Protection Strategies:</h3><ul><li><strong>Disk-Level Encryption:</strong> Encrypts the entire hard drive. This protects data if the physical hardware is stolen, but not from an attacker who has compromised the running OS.</li><li><strong>Database Encryption:</strong> Some database systems offer transparent data encryption (TDE) for tables or columns.</li><li><strong>Application-Level Encryption:</strong> The application itself encrypts sensitive fields before storing them in the database. This provides strong protection but requires careful key management.</li></ul><h3>What to Encrypt:</h3><p>Encrypt all personally identifiable information (PII), financial records, health information, and other business-sensitive data. Do not rely solely on database access controls.</p>",
                },
                {
                  title: "Key and Password Management",
                  content:
                    "<p>The security of your encryption is only as strong as the security of your keys.</p><h3>Best Practices:</h3><ul><li><strong>Do Not Hardcode Secrets:</strong> Never store passwords, API keys, or encryption keys directly in your source code. Use environment variables or a dedicated secrets management service (like HashiCorp Vault or AWS Secrets Manager).</li><li><strong>Password Storage:</strong> As covered in Lesson 3, always hash and salt passwords using a strong, adaptive algorithm like Argon2 or bcrypt.</li><li><strong>Key Rotation:</strong> Regularly change (rotate) encryption keys to limit the damage if a key is compromised.</li></ul>",
                },
              ],
              activities: [
                {
                  title: "Enable HTTPS with a Self-Signed Certificate",
                  description:
                    "For a local development server (e.g., Node.js or Python), use a tool like OpenSSL to generate a self-signed TLS certificate. Configure your web server to use this certificate to serve traffic over HTTPS and observe how the browser warns about the untrusted certificate authority.",
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the primary purpose of using HTTPS instead of HTTP?",
                  options: [
                    "To make the website load faster.",
                    "To compress the web traffic.",
                    "To encrypt data in transit, providing confidentiality and integrity.",
                    "To manage user sessions securely.",
                  ],
                  correct: 2,
                  explanation:
                    "HTTPS uses TLS to encrypt the communication channel between the client and server, preventing eavesdropping and tampering by network attackers.",
                },
                {
                  id: 2,
                  question:
                    "Which of the following is the best practice for storing an API key within an application's source code repository?",
                  options: [
                    "Store it directly in a configuration file and commit it.",
                    "Encrypt the key and store the encrypted version in the code.",
                    "Do not store it in the repository; load it from an environment variable or a secrets management service.",
                    "Store it in a text file listed in the .gitignore file.",
                  ],
                  correct: 2,
                  explanation:
                    "Secrets like API keys should never be committed to source code. The standard secure practice is to inject them into the application's environment at runtime.",
                },
                {
                  id: 3,
                  question:
                    "Hashing passwords protects them from being exposed in case of a:",
                  options: [
                    "Cross-Site Scripting (XSS) attack.",
                    "Database breach.",
                    "Denial of Service (DoS) attack.",
                    "Cross-Site Request Forgery (CSRF) attack.",
                  ],
                  correct: 1,
                  explanation:
                    "If an attacker steals the database, properly hashed passwords cannot be reversed to their plaintext form, protecting user accounts from being taken over.",
                },
              ],
            },
          },
          {
            id: "lesson-7",
            title: "Broken Access Control (IDOR, Privilege Escalation)",
            duration: "100 min",
            objectives: [
              "Differentiate between horizontal and vertical privilege escalation.",
              "Identify and exploit Insecure Direct Object References (IDOR) vulnerabilities.",
              "Implement strong, centralized access control checks to prevent unauthorized access.",
            ],
            content: {
              overview:
                "Access control enforces policies that prevent users from acting outside of their intended permissions. Broken Access Control leads to unauthorized information disclosure, modification, or destruction of all data, or performing a business function outside the user's limits.",
              sections: [
                {
                  title: "Understanding Privilege Escalation",
                  content:
                    "<p>Privilege escalation is the act of exploiting a bug, design flaw, or configuration oversight in an application to gain elevated access to resources that are normally protected.</p><h3>Types of Escalation:</h3><ul><li><strong>Vertical Privilege Escalation:</strong> A lower-privileged user gains access to functions or resources reserved for higher-privileged users (e.g., a regular user accessing an admin panel).</li><li><strong>Horizontal Privilege Escalation:</strong> A user gains access to resources belonging to another user with the same level of permissions (e.g., User A accessing User B's private messages).</li></ul>",
                },
                {
                  title: "Insecure Direct Object References (IDOR)",
                  content:
                    "<p>IDOR is a common type of horizontal privilege escalation. It occurs when an application provides direct access to objects based on user-supplied input. An attacker can manipulate these references to access unauthorized data.</p><h3>Example:</h3><p>A user views their invoice at the URL `https://example.com/invoices?id=123`. The application's backend code might look like this:</p><code>invoiceId = request.getParameter(\"id\");\nquery = \"SELECT * FROM invoices WHERE id = \" + invoiceId;</code><p>An attacker can simply change the `id` parameter in the URL (`.../invoices?id=124`) to view another user's invoice. The application fails to verify that the logged-in user is actually authorized to view the requested invoice.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Don't Rely on Obscurity</strong></div><p>Using non-sequential or hard-to-guess IDs (like UUIDs) can make IDOR harder to exploit, but it's not a substitute for proper access control checks. It's security by obscurity.</p></div>",
                },
                {
                  title: "Implementing Strong Access Control",
                  content:
                    "<p>The key to preventing these flaws is to enforce access control checks on every single request.</p><h3>Best Practices:</h3><ul><li><strong>Centralize and Reuse Checks:</strong> Implement access control logic in a single, well-vetted module or middleware that is called by all relevant parts of your application. Don't scatter checks throughout the codebase.</li><li><strong>Deny by Default:</strong> The default policy should be to deny access. Explicitly grant access to specific roles or users.</li><li><strong>Verify on Every Request:</strong> For any function that accesses a user-specific resource, the backend code must verify that the currently authenticated user has the right to access the requested resource ID. For example: `SELECT * FROM invoices WHERE id = ? AND owner_id = ?;` (where `owner_id` is from the user's session).</li></ul>",
                },
              ],
              activities: [
                {
                  title: "Exploit an IDOR Vulnerability in OWASP Juice Shop",
                  description:
                    "Find a functionality in Juice Shop that allows you to access another user's data (such as their shopping basket or user profile) by manipulating an ID in the request. After successfully exploiting it, think about what server-side check is missing.",
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "A regular user is able to access the application's admin dashboard by browsing directly to `/admin`. This is an example of:",
                  options: [
                    "Horizontal Privilege Escalation",
                    "Vertical Privilege Escalation",
                    "Session Fixation",
                    "SQL Injection",
                  ],
                  correct: 1,
                  explanation:
                    "This is vertical privilege escalation because a user with lower privileges (regular user) is gaining access to a function reserved for a higher privilege level (admin).",
                },
                {
                  id: 2,
                  question:
                    "What is the root cause of an Insecure Direct Object Reference (IDOR) vulnerability?",
                  options: [
                    "Weak password policies.",
                    "Lack of input validation.",
                    "Failure to verify that the logged-in user is authorized to access the requested object.",
                    "Use of sequential numeric IDs.",
                  ],
                  correct: 2,
                  explanation:
                    "The core issue in IDOR is that the application trusts the user-supplied ID and doesn't perform the crucial second step of checking if the current user has ownership or permission for that specific object.",
                },
                {
                  id: 3,
                  question:
                    "Which of the following is the most effective way to prevent broken access control vulnerabilities?",
                  options: [
                    "Hiding sensitive URLs from regular users.",
                    "Using long, unpredictable UUIDs instead of integers for resource IDs.",
                    "Implementing a single, reusable authorization check in a middleware for every request.",
                    "Logging all access control failures.",
                  ],
                  correct: 2,
                  explanation:
                    "Centralizing the access control logic ensures that it is applied consistently across the application and is easier to maintain and audit, reducing the chance of missing a check.",
                },
              ],
            },
          },
          {
            id: "lesson-8",
            title: "Cross-Site Scripting (XSS)",
            duration: "120 min",
            objectives: [
              "Explain the differences between Reflected, Stored, and DOM-based XSS.",
              "Learn and apply output encoding as the primary defense against XSS.",
              "Understand and implement a basic Content Security Policy (CSP) to mitigate XSS impact.",
            ],
            content: {
              overview:
                "Cross-Site Scripting (XSS) is a vulnerability that allows an attacker to inject malicious scripts (usually JavaScript) into a web page viewed by other users. This script can steal session cookies, deface websites, or redirect the user to a malicious site.",
              sections: [
                {
                  title: "Types of XSS",
                  content:
                    "<h3>Reflected XSS:</h3><p>The malicious script comes from the current HTTP request. An attacker might craft a URL like `https://example.com/search?q=&lt;script&gt;alert('XSS')&lt;/script&gt;` and trick a user into clicking it. The script is then reflected off the web server to the victim's browser.</p><h3>Stored XSS:</h3><p>The malicious script is permanently stored on the target servers, such as in a database, in a message forum, a visitor log, or a comment field. The victim retrieves the malicious script from the server when it requests the stored information.</p><h3>DOM-based XSS:</h3><p>The vulnerability exists in the client-side code rather than the server-side code. The attack payload is executed as a result of modifying the DOM 'environment' in the victim's browser.</p>",
                  image:
                    "https://images.unsplash.com/photo-1599507593499-a3f7d7d97667?w=800&h=400&fit=crop",
                },
                {
                  title: "Primary Defense: Output Encoding",
                  content:
                    "<p>The most effective way to prevent XSS is to ensure that any user-supplied data is properly encoded before it is rendered on the page. This tells the browser to treat the data as text, not as executable code.</p><h3>Example:</h3><p>The malicious input `&lt;script&gt;alert(1)&lt;/script&gt;` should be encoded to:</p><code>&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;</code><p>When the browser parses this encoded string, it will display the literal text `&lt;script&gt;alert(1)&lt;/script&gt;` on the page instead of executing the script.</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Context is Key</strong></div><p>The type of encoding depends on where the data is being placed. HTML entity encoding is used for data placed in the HTML body. Attribute encoding is for HTML attributes. JavaScript string encoding for JavaScript contexts, and URL encoding for URLs.</p></div>",
                },
                {
                  title: "Defense in Depth: Content Security Policy (CSP)",
                  content:
                    "<p>CSP is a browser security mechanism, delivered via an HTTP header, that allows you to specify which dynamic resources are allowed to load. It acts as a second layer of defense.</p><h3>Example CSP Header:</h3><code>Content-Security-Policy: default-src 'self'; script-src 'self' https://trusted-cdn.com;</code><p>This policy tells the browser:</p><ul><li>By default, only load resources from the same origin (`'self'`).</li><li>For scripts, only allow them from the same origin (`'self'`) or from `https://trusted-cdn.com`.</li></ul><p>This would prevent an XSS payload from loading a malicious script from an untrusted third-party domain.</p>",
                },
              ],
              activities: [
                {
                  title: "Inject a Script in DVWA",
                  description:
                    "Use the Stored XSS page in DVWA to inject a JavaScript payload (`&lt;script&gt;alert('XSS')&lt;/script&gt;`) into the comment box. When you and other users view the page, the alert should pop up. Then, try the same on the high-security version and observe how proper sanitization prevents the attack.",
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "An attacker posts a comment on a blog with a malicious script. Every user who views the blog post is affected. What type of XSS is this?",
                  options: [
                    "Reflected XSS",
                    "DOM-based XSS",
                    "Stored XSS",
                    "Server-Side XSS",
                  ],
                  correct: 2,
                  explanation:
                    "This is Stored XSS because the malicious payload is saved on the server (in the blog's database) and served to every user who visits the page.",
                },
                {
                  id: 2,
                  question:
                    "What is the primary and most effective defense against Cross-Site Scripting?",
                  options: [
                    "Using a Web Application Firewall (WAF).",
                    "Validating and sanitizing input from the user.",
                    "Applying context-aware output encoding before rendering user data.",
                    "Implementing a strict Content Security Policy (CSP).",
                  ],
                  correct: 2,
                  explanation:
                    "While input validation and CSP are important layers of defense, the fundamental fix for XSS is to correctly encode output so the browser treats user-supplied content as data, not as code.",
                },
                {
                  id: 3,
                  question:
                    "What does a Content Security Policy (CSP) help prevent?",
                  options: [
                    "SQL Injection attacks.",
                    "The execution of unauthorized scripts and loading of unauthorized resources.",
                    "Broken authentication.",
                    "Insecure direct object references.",
                  ],
                  correct: 1,
                  explanation:
                    "CSP is a policy that tells the browser which sources of content (like scripts, styles, and images) are trusted. It can significantly mitigate the impact of an XSS attack by preventing the malicious script from loading or executing.",
                },
              ],
            },
          },
          {
            id: "lesson-9",
            title: "Cross-Site Request Forgery (CSRF)",
            duration: "90 min",
            objectives: [
              "Understand the attack flow of a CSRF attack and how it tricks authenticated users.",
              "Implement the Synchronizer Token Pattern (CSRF tokens) as a primary defense.",
              "Apply SameSite cookie attributes as a modern, browser-level defense.",
            ],
            content: {
              overview:
                "Cross-Site Request Forgery (CSRF) is an attack that forces an end user to execute unwanted actions on a web application in which they're currently authenticated. A successful CSRF attack can trick the user into performing state-changing requests like transferring funds, changing their email address, or deleting their account.",
              sections: [
                {
                  title: "How CSRF Works",
                  content:
                    "<p>The attack relies on the fact that browsers automatically include authentication cookies with requests to a domain.</p><ol><li>A user logs into a trusted website, `bank.com`, which uses cookies to manage the session.</li><li>The user then visits a malicious website, `evil.com`.</li><li>`evil.com` contains a hidden form or image tag that automatically submits a request to `bank.com`, for example, to transfer money: `<form action='https://bank.com/transfer' method='POST'><input type='hidden' name='to' value='attacker'><input type='hidden' name='amount' value='1000'></form>`</li><li>The browser, seeing a request to `bank.com`, automatically attaches the user's session cookie.</li><li>`bank.com` sees a valid request from an authenticated user and processes the transfer. The user never knew it happened.</li></ol>",
                },
                {
                  title: "Defense: Anti-CSRF Tokens",
                  content:
                    "<p>The most common defense is the Synchronizer Token Pattern. The server generates a unique, random token for each user session and embeds it in a hidden field in every state-changing form.</p><h3>Mechanism:</h3><ol><li>When a user visits a form, the server includes a token: `<input type='hidden' name='csrf_token' value='random_unguessable_string'>`.</li><li>When the user submits the form, this token is sent back to the server.</li><li>The server validates that the submitted token matches the one it has stored for the user's session.</li></ol><p>An attacker on `evil.com` cannot guess this token, so any forged request they submit will be missing the valid token and will be rejected by the server.</p>",
                },
                {
                  title: "Modern Defense: SameSite Cookies",
                  content:
                    "<p>The `SameSite` cookie attribute tells the browser whether to send cookies with cross-site requests. It's a powerful, modern defense that can prevent CSRF at the browser level.</p><h3>Attribute Values:</h3><ul><li><strong>Strict:</strong> The browser will not send the cookie on any cross-site request. This is the most secure but can break some legitimate functionality like links from external sites.</li><li><strong>Lax:</strong> The browser will send the cookie on top-level GET requests (e.g., clicking a link), but not on cross-site POST/PUT/DELETE requests. This is a good balance of security and usability.</li><li><strong>None:</strong> The browser will always send the cookie. This requires the `Secure` attribute to be set.</li></ul><div class='info-box tip'><div class='info-box-header'><i class='fas fa-lightbulb'></i><strong>Defense in Depth</strong></div><p>Best practice is to use both anti-CSRF tokens and SameSite cookies. The SameSite attribute provides protection in modern browsers, while tokens provide a robust fallback for older browsers and other edge cases.</p></div>",
                },
              ],
              activities: [
                {
                  title: "Perform a CSRF Attack in DVWA",
                  description:
                    "Using the CSRF page in DVWA (at low security), craft a simple HTML page that contains a form to change the user's password. Host this page and open it while you are logged into DVWA in another tab. Observe how visiting your malicious page successfully changes the password without your interaction.",
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "A CSRF attack exploits the trust a website has in...",
                  options: [
                    "the user's input.",
                    "the user's browser.",
                    "its own database.",
                    "third-party APIs.",
                  ],
                  correct: 1,
                  explanation:
                    "CSRF works because the website trusts that a request coming from a user's browser is intentional. It sees a valid session cookie and assumes the user initiated the action, even though it was triggered by a malicious site.",
                },
                {
                  id: 2,
                  question:
                    "How does an anti-CSRF token prevent a forged request?",
                  options: [
                    "It encrypts the form data.",
                    "It ensures the user is logged in.",
                    "It provides a secret value that an attacker's site cannot guess, so the server can verify the request's origin.",
                    "It blocks requests from different IP addresses.",
                  ],
                  correct: 2,
                  explanation:
                    "The anti-CSRF token is a secret, unique value tied to the user's session. Since the attacker's website cannot access or predict this token, any forged request it sends will be missing the valid token and will be rejected.",
                },
                {
                  id: 3,
                  question:
                    "Setting a cookie's SameSite attribute to 'Lax' helps prevent CSRF by:",
                  options: [
                    "Preventing the cookie from being sent on cross-site POST requests.",
                    "Encrypting the cookie.",
                    "Deleting the cookie after the user closes the browser.",
                    "Blocking all cross-site requests entirely.",
                  ],
                  correct: 0,
                  explanation:
                    "`SameSite=Lax` instructs the browser not to include the cookie on most cross-site requests, including POST requests, which are typically used for state-changing actions. This effectively stops the CSRF attack at the browser level.",
                },
              ],
            },
          },
          {
            id: "lesson-10",
            title: "Security Misconfiguration",
            duration: "90 min",
            objectives: [
              "Identify common server and application security misconfigurations.",
              "Understand the risks of running software with default credentials and settings.",
              "Apply security hardening best practices, including securing HTTP headers.",
            ],
            content: {
              overview:
                "This vulnerability category is a catch-all for mistakes made when setting up a server, framework, or application. It can be as simple as leaving default usernames and passwords unchanged, or as complex as misconfigured cloud services. It often provides an easy entry point for attackers.",
              sections: [
                {
                  title: "Common Misconfigurations",
                  content:
                    "<ul><li><strong>Default Credentials:</strong> Many applications, databases, and network devices ship with default admin accounts (e.g., admin/admin). Failing to change these is a huge security hole.</li><li><strong>Verbose Error Messages:</strong> Error pages that reveal detailed internal information (stack traces, database versions, file paths) can give attackers a roadmap of your system.</li><li><strong>Unnecessary Services Enabled:</strong> Running unnecessary services or having unneeded ports open increases the attack surface of your server.</li><li><strong>Improper File and Directory Permissions:</strong> Incorrect permissions can allow an attacker to read sensitive configuration files or write malicious files to the server.</li><li><strong>Misconfigured Cloud Services:</strong> A very common issue today is misconfigured permissions on cloud storage (like an Amazon S3 bucket) that makes private data public.</li></ul>",
                },
                {
                  title: "Hardening Best Practices",
                  content:
                    "<p>Hardening is the process of securing a system by reducing its surface of vulnerability. It's about turning off what you don't need and locking down what you do.</p><h3>Key Steps:</h3><ol><li><strong>Follow the Principle of Least Privilege:</strong> Every user, service, and process should have only the minimum permissions necessary to perform its function.</li><li><strong>Automate your Build Process:</strong> Have a repeatable, automated process for deploying new servers and applications. This ensures that secure configurations are applied consistently every time.</li><li><strong>Disable Directory Listing:</strong> Your web server should not be configured to show the contents of a directory if no index file is present.</li></ol>",
                },
                {
                  title: "Securing HTTP Headers",
                  content:
                    "<p>Many security features can be enabled simply by setting the correct HTTP response headers. This is a crucial part of hardening your application.</p><h3>Important Security Headers:</h3><ul><li><strong>`Strict-Transport-Security` (HSTS):</strong> Tells the browser to only communicate with the server over HTTPS.</li><li><strong>`X-Content-Type-Options: nosniff`</strong>: Prevents the browser from trying to guess the content type of a resource, which can help mitigate some XSS attacks.</li><li><strong>`X-Frame-Options: DENY` / `Content-Security-Policy: frame-ancestors 'none'`</strong>: Prevents your site from being embedded in an iframe, which is the primary defense against Clickjacking.</li></ul><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Configuration is Code</strong></div><p>Treat your server configuration files with the same care as your application code. Store them in version control, review changes, and test them thoroughly.</p></div>",
                },
              ],
              activities: [
                {
                  title: "Scan a Misconfigured App with OWASP ZAP",
                  description:
                    "Set up a vulnerable application like DVWA or Juice Shop. Use the automated scanner in OWASP ZAP to scan the application. Review the ZAP report, paying close attention to alerts related to missing security headers, verbose error messages, and other configuration issues.",
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "A web application's error page displays a full database stack trace, including the database version and table names. This is an example of what?",
                  options: [
                    "Cross-Site Scripting",
                    "Broken Authentication",
                    "Security Misconfiguration",
                    "Injection",
                  ],
                  correct: 2,
                  explanation:
                    "This is a classic Security Misconfiguration known as 'Information Leakage' or 'Verbose Error Messages'. It provides an attacker with valuable information about the backend system.",
                },
                {
                  id: 2,
                  question:
                    "What is the primary purpose of the HTTP `Strict-Transport-Security` (HSTS) header?",
                  options: [
                    "To prevent Cross-Site Scripting.",
                    "To enforce that browsers only connect to the server using HTTPS.",
                    "To block Cross-Site Request Forgery.",
                    "To disable browser caching.",
                  ],
                  correct: 1,
                  explanation:
                    "HSTS is a security policy that helps protect websites against protocol downgrade attacks and cookie hijacking by telling browsers to exclusively use HTTPS for all future connections.",
                },
                {
                  id: 3,
                  question:
                    "Which of the following is a key principle of system hardening?",
                  options: [
                    "Enabling all features by default for maximum functionality.",
                    "Running all processes as the root user for simplicity.",
                    "Reducing the attack surface by disabling unnecessary services and ports.",
                    "Logging as little as possible to save disk space.",
                  ],
                  correct: 2,
                  explanation:
                    "A core concept of hardening is reducing the attack surface. The fewer services, ports, and software packages are running, the fewer potential vulnerabilities an attacker can exploit.",
                },
              ],
            },
          },
          {
            id: "lesson-11",
            title: "Insecure Deserialization",
            duration: "100 min",
            objectives: [
              "Explain what serialization and deserialization are and why they are used.",
              "Understand how insecure deserialization can lead to object injection and remote code execution.",
              "Identify and use safe serialization frameworks and techniques as a mitigation.",
            ],
            content: {
              overview:
                "Insecure Deserialization flaws occur when an application deserializes untrusted data without sufficient validation. This can lead to serious attacks, including denial of service, access control bypass, and, most critically, remote code execution (RCE).",
              sections: [
                {
                  title: "What is Serialization?",
                  content:
                    "<p><strong>Serialization</strong> is the process of converting an object (e.g., a data structure in memory) into a format that can be stored (e.g., in a file or database) or transmitted (e.g., across a network) and then reconstructed later. <strong>Deserialization</strong> is the reverse process: taking the stored data and converting it back into an object.</p><h3>Common Formats:</h3><ul><li><strong>JSON:</strong> Generally safe as it typically only represents data, not executable code.</li><li><strong>XML:</strong> Can be risky depending on the parser's features (see XXE).</li><li><strong>Language-Specific Formats:</strong> Java Serialization, Python's `pickle`, PHP's `unserialize()`. These are very dangerous because they can serialize not just data, but entire executable objects.</li></ul>",
                },
                {
                  title: "The Vulnerability",
                  content:
                    "<p>The vulnerability arises when an application deserializes data provided by a user (e.g., from a cookie, a hidden form field, or an API parameter) without validating what it's creating.</p><p>An attacker can create a malicious serialized object. When the application deserializes this object, it may instantiate a class that was not intended. Some classes, when instantiated or destroyed, have side effects and execute code (e.g., 'magic methods' like `__wakeup()` in PHP or `__reduce()` in Python). By carefully crafting the object chain, an attacker can trigger these side effects to run arbitrary commands on the server.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>The Core Danger</strong></div><p>Insecure deserialization is effectively a 'magic' remote code execution vulnerability waiting to happen. It bypasses many traditional defenses because it's exploiting the application's own internal logic.</p></div>",
                },
                {
                  title: "Mitigation Strategies",
                  content:
                    "<p>The most effective way to prevent this is to avoid deserializing untrusted data altogether.</p><h3>Best Practices:</h3><ul><li><strong>Use Safe Formats:</strong> Prefer simple, data-only formats like JSON for communication. Avoid native serialization formats if possible.</li><li><strong>Do Not Trust Input:</strong> If you must deserialize data from an untrusted source, perform strict type checking and validation *before* the deserialization process begins.</li><li><strong>Integrity Checks:</strong> If passing serialized objects to a client, sign them with a strong MAC (Message Authentication Code) to prevent tampering. The server should validate the signature before deserializing.</li><li><strong>Use Secure Libraries:</strong> Some libraries offer 'safe' deserialization methods that only allow the creation of primitive data types, preventing object injection.</li></ul>",
                },
              ],
              activities: [
                {
                  title: "Exploit Insecure Deserialization in a Lab",
                  description:
                    "Using a provided lab environment (e.g., from PortSwigger Web Security Academy), analyze an application that uses a serialized object in a cookie. Use a tool like ysoserial to generate a malicious serialized object that, when deserialized by the server, executes a command like `whoami` or deletes a file.",
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the most severe potential impact of an insecure deserialization vulnerability?",
                  options: [
                    "Cross-Site Scripting (XSS)",
                    "Denial of Service (DoS)",
                    "Remote Code Execution (RCE)",
                    "Information Leakage",
                  ],
                  correct: 2,
                  explanation:
                    "While DoS and other impacts are possible, the most critical risk is Remote Code Execution, where an attacker can run arbitrary commands on the server, effectively taking it over.",
                },
                {
                  id: 2,
                  question:
                    "Which of the following data formats is generally considered the most dangerous to deserialize from an untrusted source?",
                  options: ["JSON", "Python Pickle", "CSV", "Plain Text"],
                  correct: 1,
                  explanation:
                    "Language-specific formats like Python's pickle or Java's native serialization are the most dangerous because they are designed to reconstruct not just data, but complex, executable objects, which is the mechanism attackers exploit.",
                },
                {
                  id: 3,
                  question:
                    "What is the most effective defense against insecure deserialization?",
                  options: [
                    "Validating user input after deserialization.",
                    "Avoiding the deserialization of untrusted, user-supplied data.",
                    "Using a Web Application Firewall.",
                    "Logging all deserialization errors.",
                  ],
                  correct: 1,
                  explanation:
                    "The safest approach is to not deserialize data from untrusted sources at all. If that is not possible, strict validation and integrity checks must be performed before the deserialization process.",
                },
              ],
            },
          },
          {
            id: "lesson-12",
            title: "XML External Entities (XXE)",
            duration: "90 min",
            objectives: [
              "Understand the purpose of XML entities and how they can be abused.",
              "Learn how a weakly configured XML parser can be exploited to read local files or perform server-side requests.",
              "Configure XML parsers securely to disable dangerous features.",
            ],
            content: {
              overview:
                "XML External Entity (XXE) injection is a web security vulnerability that allows an attacker to interfere with an application's processing of XML data. It often allows an attacker to view files on the application server's filesystem and to interact with any backend or external systems that the application itself can access.",
              sections: [
                {
                  title: "Understanding XML Entities",
                  content:
                    '<p>XML allows for the definition of custom \'entities\' which act like variables or shortcuts. An \'external entity\' is one whose value is loaded from an external resource, such as a file or URL.</p><h3>Example of a Benign Entity:</h3><code><!DOCTYPE foo [ <!ENTITY myentity "Hello World"> ]></code><p>Later in the XML, `&myentity;` would be replaced with "Hello World".</p><h3>The Vulnerability:</h3><p>The problem arises when an XML parser is configured to process external entities from a user-supplied XML document. An attacker can define an external entity that points to a local file on the server.</p><code><!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]></code><p>If the application then includes `&xxe;` in its response, the contents of the `/etc/passwd` file will be returned to the attacker.</p>',
                },
                {
                  title: "Types of XXE Attacks",
                  content:
                    "<ul><li><strong>File Disclosure:</strong> As seen above, used to read sensitive files from the server's filesystem.</li><li><strong>Server-Side Request Forgery (SSRF):</strong> The attacker can force the server to make requests to other internal systems that are not directly accessible from the outside. <code><!ENTITY xxe SYSTEM \"http://169.254.169.254/latest/meta-data/iam/security-credentials/admin\"></code> (This is a common way to steal cloud credentials).</li><li><strong>Denial of Service (DoS):</strong> An attacker can define nested entities that expand exponentially (a 'billion laughs' attack), consuming all the server's memory and crashing it.</li></ul>",
                },
                {
                  title: "Mitigation: Secure Parser Configuration",
                  content:
                    "<p>The vulnerability is not in the XML language itself, but in the default configurations of many XML parsers. The solution is to explicitly disable the dangerous features.</p><h3>Example (Java - JAXP):</h3><code>DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n// Disable DTDs completely, which is the safest approach\ndbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n// Or, if you need DTDs, disable external entities specifically\ndbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\ndbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);</code><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Framework Defaults</strong></div><p>Modern versions of many frameworks and libraries now disable these features by default, but it's crucial to verify this for your specific technology stack and not assume it's secure.</p></div>",
                },
              ],
              activities: [
                {
                  title: "Exploit an XXE Vulnerability",
                  description:
                    "In a lab environment, find an application feature that accepts XML input (e.g., a file upload or API endpoint). Craft an XML payload with a malicious external entity to read the contents of `/etc/passwd` or a similar local file from the server and display it in the response.",
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the primary risk of an XML External Entity (XXE) vulnerability?",
                  options: [
                    "Cross-Site Scripting",
                    "Remote Code Execution",
                    "Sensitive data disclosure and Server-Side Request Forgery (SSRF)",
                    "SQL Injection",
                  ],
                  correct: 2,
                  explanation:
                    "XXE is most commonly exploited to read local files on the server (data disclosure) or to force the server to make requests to other internal or external resources (SSRF).",
                },
                {
                  id: 2,
                  question:
                    'The payload `<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>` is designed to do what?',
                  options: [
                    "Define an entity named 'xxe' whose value is the content of the /etc/passwd file.",
                    "Delete the /etc/passwd file.",
                    "Create a new user named 'xxe'.",
                    "Cause a Denial of Service attack.",
                  ],
                  correct: 0,
                  explanation:
                    "This payload defines an external entity 'xxe' and tells the XML parser to load its value from the local file `/etc/passwd`. If the application uses this entity, the file's contents will be exposed.",
                },
                {
                  id: 3,
                  question:
                    "What is the most effective way to prevent XXE vulnerabilities?",
                  options: [
                    "Sanitizing XML data to remove the string 'SYSTEM'.",
                    "Using a Web Application Firewall.",
                    "Configuring the XML parser to disable DTDs (Document Type Definitions) or external entities.",
                    "Only accepting XML from trusted users.",
                  ],
                  correct: 2,
                  explanation:
                    "The root cause of XXE is the parser's behavior. The most direct and reliable fix is to configure the parser itself to disable the processing of external entities and DTDs, which contain the vulnerable functionality.",
                },
              ],
            },
          },
          {
            id: "lesson-13",
            title: "Using Components with Known Vulnerabilities",
            duration: "90 min",
            objectives: [
              "Understand the significant risks posed by using outdated or vulnerable third-party libraries.",
              "Learn from real-world examples like Log4Shell to see the scale of the impact.",
              "Perform dependency scanning to identify and manage vulnerable components in a project.",
            ],
            content: {
              overview:
                "Modern applications are rarely built from scratch; they are assembled using numerous open-source and commercial libraries and frameworks. This lesson covers the risks of using these components when they contain known security vulnerabilities, a problem that has become one of the biggest threats in web security.",
              sections: [
                {
                  title: "The Supply Chain Risk",
                  content:
                    "<p>When you include a third-party library in your project, you are implicitly trusting its code and the code of all of *its* dependencies (transitive dependencies). A single vulnerability in any one of these components can make your entire application vulnerable.</p><h3>Why is this so common?</h3><ul><li><strong>Lack of Awareness:</strong> Developers may not know which versions of components they are using or if those versions have known vulnerabilities.</li><li><strong>Complex Dependency Trees:</strong> A modern project can have hundreds or thousands of transitive dependencies, making manual tracking impossible.</li><li><strong>Patching Reluctance:</strong> Teams may be hesitant to update libraries for fear of breaking functionality.</li></ul>",
                },
                {
                  title: "Case Study: Log4Shell (CVE-2021-44228)",
                  content:
                    "<p>Log4Shell was a critical remote code execution vulnerability in Log4j, a very widely used Java logging library. By simply tricking an application into logging a malicious string, an attacker could execute arbitrary code on the server. Because Log4j was used in countless applications, frameworks, and services, the impact was massive and widespread, affecting everything from cloud providers to consumer electronics.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>The Lesson of Log4Shell</strong></div><p>Log4Shell demonstrated that even a seemingly innocuous utility like a logging library can be the source of a catastrophic vulnerability. It highlighted the urgent need for Software Bill of Materials (SBOM) and automated dependency scanning.</p></div>",
                },
                {
                  title: "Performing Dependency Scanning",
                  content:
                    "<p>You cannot protect against what you do not know you have. The first step is to identify all the components in your application and check them against a database of known vulnerabilities.</p><h3>Tools and Techniques:</h3><ul><li><strong>Software Composition Analysis (SCA) Tools:</strong> These tools automate the process. Examples include OWASP Dependency-Check, Snyk, GitHub Dependabot, and many commercial products.</li><li><strong>Package Manager Features:</strong> Many modern package managers have built-in audit capabilities (e.g., `npm audit`, `pip-audit`).</li><li><strong>Integration into CI/CD:</strong> The best practice is to integrate these scans directly into your CI/CD pipeline. This can automatically fail a build if a new, critical vulnerability is introduced, preventing it from ever reaching production.</li></ul>",
                },
              ],
              activities: [
                {
                  title: "Run Dependency-Check on a Project",
                  description:
                    "Take a sample project (e.g., a simple Node.js/npm or Python/pip application). Use a tool like OWASP Dependency-Check or `npm audit` to scan its dependencies. Review the generated report to identify any libraries with known CVEs (Common Vulnerabilities and Exposures) and determine if patches are available.",
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question: "What is a 'transitive dependency'?",
                  options: [
                    "A library your code directly imports.",
                    "A library that another library you use depends on.",
                    "A library with no known vulnerabilities.",
                    "A library written in a different programming language.",
                  ],
                  correct: 1,
                  explanation:
                    "A transitive dependency is an indirect dependency. If your project uses Library A, and Library A uses Library B, then Library B is a transitive dependency of your project.",
                },
                {
                  id: 2,
                  question:
                    "The Log4Shell vulnerability was so severe because:",
                  options: [
                    "It was a SQL injection flaw.",
                    "The Log4j library was extremely widespread, and the vulnerability allowed for unauthenticated remote code execution.",
                    "It only affected outdated web browsers.",
                    "It required physical access to the server to exploit.",
                  ],
                  correct: 1,
                  explanation:
                    "The combination of Log4j's ubiquity and the critical severity of the RCE vulnerability made it one of the most significant security events in recent history.",
                },
                {
                  id: 3,
                  question:
                    "What is the primary goal of Software Composition Analysis (SCA) tools?",
                  options: [
                    "To scan source code for bugs.",
                    "To automatically identify all third-party components in an application and check them for known vulnerabilities.",
                    "To test the application's authentication mechanisms.",
                    "To analyze network traffic for intrusions.",
                  ],
                  correct: 1,
                  explanation:
                    "SCA tools are designed to automate the process of creating a software inventory (a Software Bill of Materials or SBOM) and checking that inventory against databases of known vulnerabilities (CVEs).",
                },
              ],
            },
          },
          {
            id: "lesson-14",
            title: "Insufficient Logging & Monitoring",
            duration: "75 min",
            objectives: [
              "Understand why comprehensive logging is a critical component of a security program.",
              "Identify key security events that should always be logged.",
              "Learn the basics of monitoring and alerting to enable rapid intrusion detection.",
            ],
            content: {
              overview:
                "Without proper logging and monitoring, you are effectively blind to attacks. Even if you have strong preventative controls, you need to be able to detect, investigate, and respond to a breach when it occurs. Insufficient logging makes it difficult or impossible to understand how an attacker got in, what they did, and how to stop them.",
              sections: [
                {
                  title: "Why Logging is Critical for Security",
                  content:
                    "<p>Logging provides the data needed for forensic investigation after an incident. It helps you answer critical questions:</p><ul><li><strong>When</strong> did the attack happen?</li><li><strong>Who</strong> was the attacker (IP address, user account)?</li><li><strong>What</strong> systems were compromised?</li><li><strong>How</strong> did they get in (which vulnerability was exploited)?</li><li><strong>What</strong> data was accessed or exfiltrated?</li></ul><p>Without logs, these questions are unanswerable, and you cannot be confident you have fully contained the breach.</p>",
                },
                {
                  title: "What to Log",
                  content:
                    "<p>You should log events that are relevant to security, not just debugging information. The goal is to create an audit trail.</p><h3>Key Events to Log:</h3><ul><li><strong>Authentication Events:</strong> All successful and failed login attempts.</li><li><strong>Access Control Failures:</strong> Any attempt by a user to access a resource they are not authorized for.</li><li><strong>Input Validation Failures:</strong> Every time the application rejects user input as potentially malicious (e.g., detecting XSS or SQLi patterns).</li><li><strong>High-Value Transactions:</strong> Critical business functions like password changes, email changes, fund transfers, and admin actions.</li><li><strong>Outbound Connections:</strong> If your server makes outbound API calls, log them. This can help detect SSRF attacks.</li></ul><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Log Rich Context</strong></div><p>A good log entry includes a timestamp, the source IP address, the user ID (if authenticated), the event that occurred, and the outcome (success/failure). Don't log sensitive data like passwords or session tokens!</p></div>",
                },
                {
                  title: "From Logging to Monitoring and Alerting",
                  content:
                    "<p>Collecting logs is only the first step. The logs must be centralized and actively monitored to be useful for detection.</p><h3>Monitoring Basics:</h3><ul><li><strong>Centralization:</strong> Ship logs from all your servers to a central location (e.g., an ELK stack or a SIEM service).</li><li><strong>Alerting:</strong> Create automated alerts for suspicious patterns. For example:</li><ul><li>More than 10 failed login attempts for a single user in 1 minute (potential brute force).</li><li>A successful login from a new country.</li><li>An admin action performed outside of business hours.</li></ul><li><strong>Dashboards:</strong> Visualize log data to spot trends and anomalies that might indicate an attack.</li></ul>",
                },
              ],
              activities: [
                {
                  title: "Review Logs for Attack Attempts",
                  description:
                    "Given a sample web server access log, use command-line tools like `grep` and `awk` to search for signs of a security scan or attack. Look for common patterns like requests for `wp-admin.php`, SQL injection attempts (`' OR '1'='1'`), or directory traversal (`../../..`).",
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question: "What is the primary purpose of security logging?",
                  options: [
                    "To improve application performance.",
                    "To provide a detailed audit trail for detecting and investigating security incidents.",
                    "To store user data.",
                    "To help with debugging application errors.",
                  ],
                  correct: 1,
                  explanation:
                    "While logs can help with debugging, their primary security purpose is to create a forensic trail that allows for the detection, investigation, and response to security incidents.",
                },
                {
                  id: 2,
                  question:
                    "Which of the following events is LEAST critical to log for security purposes?",
                  options: [
                    "A failed login attempt.",
                    "A successful CSS file load.",
                    "A user changing their password.",
                    "An attempt to access an unauthorized admin page.",
                  ],
                  correct: 1,
                  explanation:
                    "While all web requests are logged in access logs, a successful CSS file load is a normal, low-risk event. The other options are all high-value security events that indicate either a potential attack or a significant change to an account.",
                },
                {
                  id: 3,
                  question:
                    "Simply collecting logs on individual servers is not enough; they should be centralized. Why?",
                  options: [
                    "To save disk space on the web servers.",
                    "To make them easier for developers to read.",
                    "To allow for correlation of events across multiple systems and to prevent attackers from tampering with or deleting the logs on a compromised machine.",
                    "Because it is required by law in all countries.",
                  ],
                  correct: 2,
                  explanation:
                    "Centralizing logs is crucial for two main reasons: it allows you to see the bigger picture by correlating events from different sources, and it protects the logs' integrity. An attacker who compromises a server will often try to erase their tracks by deleting the local logs.",
                },
              ],
            },
          },
          {
            id: "lesson-15",
            title: "Clickjacking & UI Redress Attacks",
            duration: "60 min",
            objectives: [
              "Explain the mechanism of a clickjacking attack using transparent iframes.",
              "Learn about legacy 'frame-busting' JavaScript techniques.",
              "Implement the `X-Frame-Options` and CSP `frame-ancestors` headers as the primary defense.",
            ],
            content: {
              overview:
                "Clickjacking, also known as a UI redress attack, is a malicious technique of tricking a user into clicking on something different from what the user perceives, thus potentially revealing confidential information or taking control of their computer while clicking on seemingly innocuous web pages.",
              sections: [
                {
                  title: "How Clickjacking Works",
                  content:
                    "<p>The attacker creates a malicious webpage that contains an invisible `iframe`. This `iframe` loads a legitimate, target website where the user is authenticated.</p><ol><li>The attacker's page displays a tempting button or link, like 'Click here to win a prize!'.</li><li>The invisible `iframe` containing the target website (e.g., your bank or social media) is positioned directly on top of the fake button. The 'Delete Account' button on the legitimate site is perfectly aligned with the visible 'Win a Prize' button.</li><li>When the user thinks they are clicking the 'Win a Prize' button, they are actually clicking the 'Delete Account' button within the invisible `iframe`.</li><li>Because the request is initiated from the legitimate site's context, the browser sends the user's session cookies, and the action is performed successfully.</li></ol>",
                },
                {
                  title: "Legacy Defense: Frame-Busting",
                  content:
                    "<p>In the past, developers used JavaScript snippets called 'frame-busters' or 'frame-killers' to prevent their sites from being framed. A typical script would look like this:</p><code>if (top.location != self.location) {\n  top.location = self.location;\n}</code><p>This script checks if the current page is the top-level window. If not, it tries to force the top window to redirect to itself, thus 'busting' out of the `iframe`. However, these scripts can often be bypassed by clever attackers and are no longer considered a reliable defense.</p>",
                },
                {
                  title: "Modern Defense: HTTP Headers",
                  content:
                    "<p>The correct and most reliable way to prevent clickjacking is by using HTTP response headers that instruct the browser on how it should handle framing.</p><h3>X-Frame-Options:</h3><p>This is an older but still widely supported header. It has three possible values:</p><ul><li><strong>`DENY`</strong>: The page cannot be displayed in a frame, regardless of the site attempting to do so.</li><li><strong>`SAMEORIGIN`</strong>: The page can only be displayed in a frame on the same origin as the page itself.</li><li><strong>`ALLOW-FROM uri`</strong>: The page can only be displayed in a frame on the specified origin. (Note: This has limited browser support).</li></ul><h3>Content-Security-Policy (CSP) `frame-ancestors`:</h3><p>This is the modern, more flexible replacement for `X-Frame-Options`. It is part of CSP Level 2.</p><code>Content-Security-Policy: frame-ancestors 'none';</code><p>This is equivalent to `X-Frame-Options: DENY`.</p><code>Content-Security-Policy: frame-ancestors 'self' https://trusted.com;</code><p>This allows framing by your own site and by `https://trusted.com`, offering more control than `X-Frame-Options`.</p>",
                },
              ],
              activities: [
                {
                  title: "Create a Clickjacking Proof-of-Concept",
                  description:
                    "Create a simple HTML page. On this page, create a visible button. Then, add an `iframe` that loads a vulnerable website (one that does not have clickjacking defenses). Use CSS to make the `iframe` transparent and position it so a critical button on the vulnerable site is directly underneath your visible button.",
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the core technique behind a clickjacking attack?",
                  options: [
                    "Injecting a malicious script into a webpage.",
                    "Stealing a user's session cookie.",
                    "Loading a target website in a transparent iframe and tricking a user into clicking on it.",
                    "Sending a large volume of traffic to a server to cause a denial of service.",
                  ],
                  correct: 2,
                  explanation:
                    "Clickjacking works by loading the legitimate site in an invisible iframe and overlaying it with a deceptive UI, causing the user's clicks to be passed through to the hidden site.",
                },
                {
                  id: 2,
                  question:
                    "Which HTTP response header is the most modern and effective way to prevent clickjacking?",
                  options: [
                    "`X-XSS-Protection`",
                    "`X-Content-Type-Options`",
                    "`Strict-Transport-Security`",
                    "`Content-Security-Policy: frame-ancestors 'none';`",
                  ],
                  correct: 3,
                  explanation:
                    "While `X-Frame-Options` is also a valid defense, the `frame-ancestors` directive within CSP is the modern standard and offers more flexibility.",
                },
                {
                  id: 3,
                  question:
                    "The header `X-Frame-Options: SAMEORIGIN` does what?",
                  options: [
                    "Prevents the page from being framed by any site.",
                    "Allows the page to be framed by any site.",
                    "Allows the page to be framed only by pages from the exact same origin.",
                    "Allows the page to be framed only over HTTPS.",
                  ],
                  correct: 2,
                  explanation:
                    "`SAMEORIGIN` enforces a policy where the page can be put in an iframe, but only if the parent page hosting the iframe is from the same origin (protocol, domain, and port).",
                },
              ],
            },
          },
          {
            id: "lesson-16",
            title: "Rate Limiting & DoS Protections",
            duration: "75 min",
            objectives: [
              "Recognize automated attacks like credential stuffing and brute-forcing.",
              "Apply rate limiting to authentication and other sensitive API endpoints.",
              "Understand the role of a Web Application Firewall (WAF) in providing basic DoS defenses.",
            ],
            content: {
              overview:
                "Automated attacks can overwhelm an application, leading to a denial of service (DoS) for legitimate users or allowing an attacker to guess passwords through brute force. This lesson covers techniques to mitigate these attacks by controlling the rate at which requests are accepted.",
              sections: [
                {
                  title:
                    "Automated Attacks: Brute-Force and Credential Stuffing",
                  content:
                    "<h3>Brute-Force Attack:</h3><p>An attacker attempts to guess a user's password by systematically trying thousands or millions of possibilities against a login form. Without rate limiting, an attacker can make an unlimited number of attempts.</p><h3>Credential Stuffing:</h3><p>This is a more targeted form of brute-forcing. Attackers take lists of usernames and passwords stolen from a data breach at one company and systematically try them against other websites. This is effective because many people reuse passwords across multiple services.</p>",
                },
                {
                  title: "Implementing Rate Limiting",
                  content:
                    "<p>Rate limiting is the practice of controlling the number of requests a user (or IP address) can make in a given time period. It's a critical defense for any sensitive endpoint.</p><h3>Where to Apply Rate Limiting:</h3><ul><li><strong>Login Pages:</strong> To prevent brute-force and credential stuffing. A good policy might be 10 failed attempts per IP address per hour.</li><li><strong>Password Reset Forms:</strong> To prevent an attacker from spamming a user with password reset emails.</li><li><strong>API Endpoints:</strong> To prevent abuse and ensure fair usage for all clients.</li><li><strong>Resource-Intensive Operations:</strong> Any part of the application that is slow or computationally expensive to protect against application-level DoS.</li></ul><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Account Lockouts</strong></div><p>Another common defense is to lock an account after a certain number of failed login attempts. However, this must be implemented carefully, as it can be abused by an attacker to intentionally lock out legitimate users (a form of DoS).</p></div>",
                },
                {
                  title: "Web Application Firewalls (WAF) and DDoS Defense",
                  content:
                    "<p>A WAF is a device or service that sits in front of a web application and inspects HTTP traffic, filtering out malicious requests.</p><h3>How WAFs Help:</h3><ul><li><strong>Basic Rate Limiting:</strong> Most WAFs can provide simple rate limiting based on IP address.</li><li><strong>Signature-Based Blocking:</strong> They can block requests that match known attack patterns for SQLi, XSS, etc.</li><li><strong>Geoblocking:</strong> Block traffic from specific countries.</li></ul><h3>DDoS Mitigation:</h3><p>A Distributed Denial of Service (DDoS) attack involves flooding a server with traffic from thousands of compromised machines. Application-level rate limiting cannot stop this. This requires a specialized DDoS mitigation service (like Cloudflare or Akamai) that can absorb and filter massive volumes of traffic before it ever reaches your server.</p>",
                },
              ],
              activities: [
                {
                  title: "Simulate Brute-Force Login Attempts",
                  description:
                    "Write a simple script (e.g., in Python using the `requests` library) that attempts to log into a test application's login form repeatedly with a list of common passwords. First, run it against an endpoint with no rate limiting and observe the results. Then, implement a simple IP-based rate limit on the server and run the script again to see it get blocked.",
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the primary purpose of applying rate limiting to a login page?",
                  options: [
                    "To make the page load faster.",
                    "To prevent automated brute-force and credential stuffing attacks.",
                    "To block users from certain countries.",
                    "To encrypt user passwords.",
                  ],
                  correct: 1,
                  explanation:
                    "Rate limiting slows down automated attacks significantly, making it impractical for an attacker to try thousands of passwords in a short period. This is a key defense against password guessing.",
                },
                {
                  id: 2,
                  question:
                    "An attacker uses a list of username/password pairs from a previous breach on Company A to try and log into accounts on Company B. This attack is called:",
                  options: [
                    "Phishing",
                    "Brute-Forcing",
                    "Credential Stuffing",
                    "Clickjacking",
                  ],
                  correct: 2,
                  explanation:
                    "This is the definition of credential stuffing. It exploits the common user behavior of password reuse across different services.",
                },
                {
                  id: 3,
                  question:
                    "Which of the following is best suited to defend against a large-scale volumetric DDoS attack?",
                  options: [
                    "Application-level rate limiting.",
                    "A Web Application Firewall (WAF).",
                    "A specialized cloud-based DDoS mitigation service.",
                    "Implementing account lockouts.",
                  ],
                  correct: 2,
                  explanation:
                    "Volumetric DDoS attacks require a massive network infrastructure to absorb the flood of traffic. This is the core function of services like Cloudflare, Akamai, and AWS Shield.",
                },
              ],
            },
          },
          {
            id: "lesson-17",
            title: "Security Headers & Best Practices",
            duration: "90 min",
            objectives: [
              "Perform a comprehensive review of critical HTTP security headers like HSTS, CSP, and X-Content-Type-Options.",
              "Configure a set of secure default headers for a web application.",
              "Understand how security headers prevent specific attacks like MIME sniffing and protocol downgrade attacks.",
            ],
            content: {
              overview:
                "HTTP security headers are a fundamental part of web application security. They provide an additional layer of defense by instructing the browser to behave in a more secure way. This lesson is a deep dive into the most important headers and how to configure them correctly.",
              sections: [
                {
                  title:
                    "Headers for Enforcing Encryption and Preventing Framing",
                  content:
                    "<h3>HTTP Strict Transport Security (HSTS)</h3><p><code>Strict-Transport-Security: max-age=31536000; includeSubDomains</code></p><p>This header tells a browser that it should only ever connect to the site using HTTPS. It prevents protocol downgrade attacks and helps protect against cookie hijacking. `max-age` defines the time in seconds to remember this policy.</p><h3>Content-Security-Policy (CSP) `frame-ancestors` & X-Frame-Options</h3><p><code>Content-Security-Policy: frame-ancestors 'self';</code> or <code>X-Frame-Options: SAMEORIGIN</code></p><p>As covered in Lesson 15, these headers are the primary defense against Clickjacking by controlling whether your site can be embedded in an `iframe`.</p>",
                },
                {
                  title: "Headers for Preventing Content-Based Attacks",
                  content:
                    "<h3>X-Content-Type-Options</h3><p><code>X-Content-Type-Options: nosniff</code></p><p>This header prevents the browser from performing 'MIME sniffing'. If a server sends a file with a declared `Content-Type` of `text/plain`, but the file looks like JavaScript, some browsers might execute it. `nosniff` tells the browser to always respect the server's declared `Content-Type`, which helps mitigate some XSS vectors.</p><h3>Content Security Policy (CSP)</h3><p><code>Content-Security-Policy: default-src 'self'; script-src 'self' https://apis.google.com;</code></p><p>CSP is the most powerful and complex security header. It's a whitelist of sources for content like scripts, styles, images, and fonts. It is a very effective defense-in-depth measure against XSS.</p>",
                },
                {
                  title: "Other Important Headers",
                  content:
                    "<h3>Referrer-Policy</h3><p><code>Referrer-Policy: strict-origin-when-cross-origin</code></p><p>This header controls how much referrer information (the URL of the previous page) is included with requests. It can prevent leaking sensitive information in URLs to third parties.</p><h3>Permissions-Policy (formerly Feature-Policy)</h3><p><code>Permissions-Policy: geolocation=(), microphone=()</code></p><p>This header allows a site to control which browser features (like camera, microphone, geolocation, etc.) can be used by the page and any embedded `iframes`.</p><div class='info-box tip'><div class='info-box-header'><i class='fas fa-lightbulb'></i><strong>Test Your Headers</strong></div><p>Use an online tool like Scott Helme's securityheaders.com to scan your website's headers and get a grade. This is an excellent way to check your work and learn about new best practices.</p></div>",
                },
              ],
              activities: [
                {
                  title: "Add and Test Security Headers",
                  description:
                    "Take a simple web application (e.g., a basic Node/Express or Flask app). Add middleware to inject a comprehensive set of security headers (HSTS, CSP, X-Content-Type-Options, etc.). Deploy the application and use a tool like securityheaders.com or your browser's developer tools to verify that the headers are being sent correctly.",
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "The `Strict-Transport-Security` (HSTS) header helps to mitigate which type of attack?",
                  options: [
                    "SQL Injection",
                    "Protocol downgrade attacks and cookie hijacking.",
                    "Cross-Site Scripting (XSS)",
                    "Denial of Service",
                  ],
                  correct: 1,
                  explanation:
                    "HSTS instructs the browser to always use HTTPS, preventing an attacker from downgrading the connection to insecure HTTP in a man-in-the-middle attack.",
                },
                {
                  id: 2,
                  question:
                    "What is the purpose of the `X-Content-Type-Options: nosniff` header?",
                  options: [
                    "To block all content from being loaded.",
                    "To tell the browser not to guess the MIME type of a file and to trust the `Content-Type` header sent by the server.",
                    "To enable server-side content sniffing.",
                    "To prevent clickjacking attacks.",
                  ],
                  correct: 1,
                  explanation:
                    "This header is a security feature that prevents browsers from MIME-sniffing a response away from the declared content-type, which can be a vector for XSS attacks.",
                },
                {
                  id: 3,
                  question:
                    "Which header provides the most powerful and granular control over which resources (scripts, styles, images) a browser is allowed to load for a given page?",
                  options: [
                    "`X-Frame-Options`",
                    "`Referrer-Policy`",
                    "`Content-Security-Policy` (CSP)",
                    "`Access-Control-Allow-Origin`",
                  ],
                  correct: 2,
                  explanation:
                    "Content Security Policy (CSP) is designed specifically for this purpose. It allows developers to create a whitelist of allowed content sources, acting as a major defense against XSS.",
                },
              ],
            },
          },
          {
            id: "lesson-18",
            title: "Secure API & Microservice Security",
            duration: "100 min",
            objectives: [
              "Identify common security risks in REST and GraphQL APIs.",
              "Understand the roles of API keys and OAuth2 scopes in securing APIs.",
              "Apply strict input validation and access control to API endpoints.",
            ],
            content: {
              overview:
                "As applications move towards microservice architectures and client-side frameworks, APIs have become the backbone of modern software. Securing these APIs is critical, as they are often a primary target for attackers. This lesson covers vulnerabilities specific to APIs and best practices for securing them.",
              sections: [
                {
                  title:
                    "Common API Security Risks (OWASP API Security Top 10)",
                  content:
                    "<ul><li><strong>Broken Object Level Authorization (BOLA):</strong> Similar to IDOR, this is when an API endpoint allows a user to access or manipulate data objects they shouldn't have access to. This is the #1 API vulnerability.</li><li><strong>Broken Authentication:</strong> Weak or missing authentication on API endpoints.</li><li><strong>Excessive Data Exposure:</strong> An API that returns more data than is needed by the client application. An attacker can inspect the raw API response to find sensitive information that is filtered out by the UI.</li><li><strong>Lack of Resources & Rate Limiting:</strong> Failure to apply rate limiting can lead to DoS or allow for automated attacks against the API.</li><li><strong>Mass Assignment:</strong> When a framework automatically binds client-sent data to internal object variables. An attacker might be able to update fields they shouldn't, like an `isAdmin` flag.</li></ul>",
                },
                {
                  title: "API Authentication and Authorization",
                  content:
                    "<h3>API Keys:</h3><p>A simple method where the client sends a secret key in an HTTP header (e.g., `X-API-Key`). This identifies the client application but does not authenticate the end-user. It's suitable for public or machine-to-machine APIs.</p><h3>OAuth2 and OpenID Connect (OIDC):</h3><p>OAuth2 is an authorization framework that allows a user to grant a third-party application limited access to their data on another service, without sharing their password. OIDC is a layer built on top of OAuth2 that provides identity verification (authentication).</p><ul><li><strong>Access Tokens:</strong> Short-lived tokens (like JWTs) that are sent in the `Authorization: Bearer <token>` header to access protected API endpoints.</li><li><strong>Scopes:</strong> OAuth2 scopes define granular permissions. An application might request the `read_profile` scope but not the `write_profile` scope, following the principle of least privilege.</li></ul>",
                },
                {
                  title: "GraphQL Security",
                  content:
                    "<p>GraphQL APIs have their own unique security challenges compared to traditional REST APIs.</p><h3>Key Risks:</h3><ul><li><strong>Introspection Queries:</strong> By default, GraphQL allows anyone to query the schema to see all available types, queries, and mutations. This should be disabled in production.</li><li><strong>Deeply Nested Queries:</strong> A malicious query with many levels of nesting can overwhelm the database and cause a DoS. Implement query depth limiting and complexity analysis.</li><li><strong>Field-Level Authorization:</strong> In GraphQL, you must enforce authorization checks on a per-field basis, not just at the endpoint level, as users can request any combination of fields.</li></ul>",
                },
              ],
              activities: [
                {
                  title: "Secure an API with OAuth2",
                  description:
                    "Using a demo application and an OAuth2 service (like Auth0 or Okta), implement an API endpoint that is initially public. Then, modify it to require a valid JWT access token for access. Attempt to call the API without a token, with an invalid token, and finally with a valid token to see the security in action.",
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "An API endpoint at `/api/users/{userId}` allows any authenticated user to view the data for any `userId`. This is a classic example of what vulnerability?",
                  options: [
                    "Excessive Data Exposure",
                    "Broken Object Level Authorization (BOLA)",
                    "Security Misconfiguration",
                    "Mass Assignment",
                  ],
                  correct: 1,
                  explanation:
                    "This is the most common API vulnerability, Broken Object Level Authorization. The API fails to check if the authenticated user making the request is authorized to access the specific object (`userId`) they are requesting.",
                },
                {
                  id: 2,
                  question:
                    "A mobile app calls an API to get user profile information. The API returns the full user object from the database, including the hashed password and personal notes, even though the app only displays the username and profile picture. This is known as:",
                  options: [
                    "Injection",
                    "Broken Authentication",
                    "Excessive Data Exposure",
                    "Insufficient Logging",
                  ],
                  correct: 2,
                  explanation:
                    "The API is exposing more data than the consumer needs. An attacker could intercept the API traffic to get this extra sensitive information. The API should be refactored to only return the necessary fields.",
                },
                {
                  id: 3,
                  question:
                    "In the context of OAuth2, what is the purpose of 'scopes'?",
                  options: [
                    "To identify the user.",
                    "To define the granular permissions that an access token has (e.g., read-only vs. write access).",
                    "To encrypt the communication channel.",
                    "To set the expiration time of the token.",
                  ],
                  correct: 1,
                  explanation:
                    "Scopes are used to implement the principle of least privilege. An application should only request the scopes (permissions) it absolutely needs to function, and the API should validate that the provided token has the required scope for the requested operation.",
                },
              ],
            },
          },
          {
            id: "lesson-19",
            title: "Secure Development & DevSecOps",
            duration: "100 min",
            objectives: [
              "Understand core secure coding principles like input validation and least privilege.",
              "Learn the difference between SAST, DAST, and IAST security testing tools.",
              "Recognize how to integrate security practices into a modern CI/CD pipeline (DevSecOps).",
            ],
            content: {
              overview:
                "This lesson shifts the focus from finding individual vulnerabilities to building a process for developing secure software from the ground up. DevSecOps is a cultural and technical movement about integrating security into every phase of the software development lifecycle, from design to deployment.",
              sections: [
                {
                  title: "Secure Coding Principles",
                  content:
                    "<p>These are foundational principles that should guide all development work.</p><ul><li><strong>Validate All Input:</strong> Treat all data from external sources (users, APIs, files) as untrusted. Validate it for type, length, format, and range. Use allow-lists over block-lists.</li><li><strong>Principle of Least Privilege:</strong> Every component and user should operate with the minimum level of privilege necessary to do its job.</li><li><strong>Defense in Depth:</strong> Don't rely on a single security control. Use multiple, layered defenses (e.g., input validation + parameterized queries + WAF).</li><li><strong>Fail Securely:</strong> Applications should fail in a way that does not expose sensitive information or leave the system in an insecure state. Catch exceptions and show generic error messages.</li><li><strong>Don't Reinvent the Wheel:</strong> Use well-vetted, industry-standard libraries for security functions like cryptography and authentication. Don't try to write your own.</li></ul>",
                },
                {
                  title: "Automated Security Testing Tools",
                  content:
                    "<h3>SAST (Static Application Security Testing)</h3><p>Also known as 'white-box' testing. SAST tools analyze the application's source code or compiled binaries for potential security flaws without actually running the application. They are good at finding issues like SQL injection or buffer overflows.</p><h3>DAST (Dynamic Application Security Testing)</h3><p>Also known as 'black-box' testing. DAST tools interact with the running application from the outside, like an attacker would. They send malicious payloads and analyze the responses to find vulnerabilities. OWASP ZAP is a DAST tool.</p><h3>IAST (Interactive Application Security Testing)</h3><p>IAST combines elements of SAST and DAST. It uses instrumentation within the running application to monitor its internal state and data flow, allowing it to pinpoint vulnerabilities with high accuracy and low false positives.</p>",
                },
                {
                  title: "Integrating Security into the CI/CD Pipeline",
                  content:
                    "<p>The goal of DevSecOps is to 'shift left'—to find and fix security issues as early in the development process as possible, making it faster and cheaper.</p><h3>A Typical DevSecOps Pipeline:</h3><ol><li><strong>Pre-commit Hooks:</strong> Run checks for hardcoded secrets before code is even committed.</li><li><strong>Commit Stage:</strong> Run SAST and Software Composition Analysis (SCA) scans on every code push or pull request. Fail the build if critical vulnerabilities are found.</li><li><strong>Test Stage:</strong> Deploy the application to a staging environment and run automated DAST scans against it.</li><li><strong>Production Stage:</strong> Continuously monitor the application in production for attacks and new vulnerabilities.</li></ol><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Security as Code</strong></div><p>In a DevSecOps model, security policies, compliance checks, and infrastructure configurations are all defined as code, allowing them to be versioned, automated, and tested just like the application itself.</p></div>",
                },
              ],
              activities: [
                {
                  title: "Run a SAST Tool on Source Code",
                  description:
                    "Download and install a SAST tool like SonarQube or use a cloud-based one like Snyk. Point it at a repository of sample code with known vulnerabilities. Run the scan and analyze the report. See how the tool identifies the exact line of code where the vulnerability exists and often provides suggestions for fixing it.",
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question: "What does it mean to 'shift left' in DevSecOps?",
                  options: [
                    "To move all security responsibilities to the operations team.",
                    "To address security concerns as early as possible in the development lifecycle.",
                    "To only perform security testing right before releasing to production.",
                    "To outsource all security work to a third party.",
                  ],
                  correct: 1,
                  explanation:
                    "'Shifting left' refers to moving security activities earlier (to the left) in the typical representation of a CI/CD pipeline, starting from the very beginning of development rather than waiting until the end.",
                },
                {
                  id: 2,
                  question:
                    "A security tool that analyzes an application's source code for vulnerabilities without executing it is known as what?",
                  options: ["DAST", "IAST", "WAF", "SAST"],
                  correct: 3,
                  explanation:
                    "Static Application Security Testing (SAST) tools perform 'white-box' analysis of the static source code, making them ideal for integration early in the CI/CD pipeline.",
                },
                {
                  id: 3,
                  question:
                    "Which of the following is a core principle of secure coding?",
                  options: [
                    "Trusting all data that comes from authenticated users.",
                    "Writing your own custom encryption algorithms for better security.",
                    "Validating all external input and using allow-lists where possible.",
                    "Running the application with the highest possible privileges to avoid permissions errors.",
                  ],
                  correct: 2,
                  explanation:
                    "Treating all input as untrusted is a foundational concept. Validating input rigorously helps prevent a wide range of injection-style vulnerabilities.",
                },
              ],
            },
          },
          {
            id: "lesson-20",
            title: "Practical Labs & Final Project",
            duration: "180 min",
            objectives: [
              "Apply the concepts learned throughout the course in a hands-on, practical environment.",
              "Perform a basic penetration test against a deliberately vulnerable web application.",
              "Document findings in a professional security report, including descriptions, risk ratings, and remediation advice.",
            ],
            content: {
              overview:
                "This final lesson is a capstone project that brings everything together. You will act as a security analyst tasked with testing a vulnerable application. The goal is not just to find vulnerabilities, but to understand their impact and communicate your findings effectively.",
              sections: [
                {
                  title: "The Target: OWASP Juice Shop",
                  content:
                    "<p>OWASP Juice Shop is a modern and sophisticated insecure web application, perfect for security training. It contains dozens of vulnerabilities from the OWASP Top Ten and beyond. Unlike older applications like DVWA, Juice Shop's vulnerabilities are often more subtle and representative of real-world applications.</p><h3>Your Mission:</h3><p>Your task is to explore Juice Shop and identify as many vulnerabilities as you can. The application has a built-in scoreboard that will help you track your progress.</p>",
                },
                {
                  title: "The Penetration Testing Process",
                  content:
                    "<p>Follow a structured approach to your testing.</p><ol><li><strong>Reconnaissance:</strong> Explore the application. Understand its features, user roles, and the technologies it uses. Use your browser's developer tools to inspect requests and responses.</li><li><strong>Scanning:</strong> Use an automated tool like OWASP ZAP or Burp Suite Community Edition to perform a baseline scan of the application. This will find the 'low-hanging fruit'.</li><li><strong>Manual Exploitation:</strong> This is the most important part. Go through the application feature by feature and manually test for the vulnerabilities we've discussed:</li><ul><li>Test all input fields for SQLi and XSS.</li><li>Analyze API calls for IDOR/BOLA.</li><li>Attempt to bypass authentication and access control.</li><li>Look for sensitive data in responses and source code.</li><li>Try to exploit CSRF on state-changing forms.</li></ul></ol>",
                },
                {
                  title: "Writing the Security Report",
                  content:
                    "<p>A penetration test is only as valuable as its report. The report is what communicates the risk to the business and tells developers how to fix the problems.</p><h3>A Good Report Includes:</h3><ul><li><strong>Executive Summary:</strong> A high-level overview of the findings for a non-technical audience. What is the overall security posture?</li><li><strong>Vulnerability Details:</strong> For each finding, include:</li><ul><li><strong>Name:</strong> (e.g., Stored Cross-Site Scripting in Comment Field)</li><li><strong>Description:</strong> A clear explanation of the vulnerability.</li><li><strong>Steps to Reproduce:</strong> A precise, step-by-step guide for someone else to replicate the finding.</li><li><strong>Risk Rating:</strong> An assessment of the impact and likelihood (e.g., Critical, High, Medium, Low).</li><li><strong>Remediation Advice:</strong> Specific, actionable guidance for developers on how to fix the vulnerability.</li></ul></ul>",
                },
              ],
              activities: [
                {
                  title: "Final Project: Test Juice Shop and Write a Report",
                  description:
                    "Spend the lab time actively testing the OWASP Juice Shop application. Try to complete at least 10 challenges on the scoreboard. As you find vulnerabilities, document them. Your final submission for the course will be a professional security report detailing at least three of your findings, complete with a risk rating and remediation advice for each.",
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the primary goal of the reconnaissance phase of a penetration test?",
                  options: [
                    "To exploit vulnerabilities.",
                    "To write the final report.",
                    "To understand the target application's functionality, technology stack, and attack surface.",
                    "To crash the server.",
                  ],
                  correct: 2,
                  explanation:
                    "Reconnaissance is about gathering information. Before you can effectively attack an application, you must understand how it works and what technologies it is built on.",
                },
                {
                  id: 2,
                  question:
                    "In a security report, what is the purpose of the 'Steps to Reproduce' section?",
                  options: [
                    "To make the report longer.",
                    "To provide a clear, unambiguous way for developers to confirm the vulnerability's existence.",
                    "To explain the history of the vulnerability.",
                    "To provide a list of tools used.",
                  ],
                  correct: 1,
                  explanation:
                    "This section is crucial for developers. It allows them to reliably replicate the vulnerability, which is the first step in diagnosing the root cause and developing a fix.",
                },
                {
                  id: 3,
                  question:
                    "Why is manual testing still essential even when automated scanners like OWASP ZAP are used?",
                  options: [
                    "Automated scanners are too expensive.",
                    "Manual testing is faster.",
                    "Automated scanners can find all vulnerabilities, so manual testing is not needed.",
                    "Automated scanners are good at finding technical flaws but often miss business logic errors and complex authorization issues that require a human's understanding of the application's context.",
                  ],
                  correct: 3,
                  explanation:
                    "Scanners are powerful but have limits. They can't understand the business logic of an application. For example, a scanner would not know that a user with a 'viewer' role should not be able to access an 'edit' function; this requires manual testing by a human who understands the application's intent.",
                },
              ],
            },
          },
        ],
      };
      // =====================================================
      // GLOBAL VARIABLES
      // =====================================================
      let currentUser = null;
      let currentLessonIndex = 0;
      let courseProgress = {};
      let userStats = {};
      let quizState = {
        currentQuestion: 0,
        answers: [],
        score: 0,
        isComplete: false,
        timeStarted: null,
        timeCompleted: null,
        currentQuestionIndex: 0,
      };

      // Enhanced session tracking
      let courseSession = {
        startTime: null,
        totalStudyTime: 0,
        lessonsStarted: 0,
        lessonsCompleted: 0,
        pageLoadTime: new Date(),
        lastActive: new Date(),
        interactions: 0,
        completedSections: [],
        totalTime: 0,
        interactionCount: 0,
        lastActivityTime: new Date(),
      };

      // Music Player Variables
      let audioPlayer = new Audio();

      // Achievement notification system
      let notificationQueue = [];
      let isShowingNotification = false;

      // =====================================================
      // INITIALIZATION
      // =====================================================
      document.addEventListener("DOMContentLoaded", async () => {
        try {
          showLoadingScreen();
          await checkAuth();

          if (currentUser) {
            // Initialize session tracking
            startCourseSession();

            // Load course data and progress
            await loadCourseData();
            await loadUserProfile();
            await loadProgress();

            // Initialize UI
            initializeEventListeners();
            renderSidebar();
            loadLesson(currentLessonIndex);

            // Initialize additional features
            initMusicPlayer();
            addMusicIndicator();
            initializeActivityTracking();

            hideLoadingScreen();
          } else {
            openAuthModal();
          }
        } catch (error) {
          console.error("Error initializing course:", error);
          hideLoadingScreen();
          showToast("Failed to initialize course system", "error");
        }
      });

      // =====================================================
      // AUTHENTICATION SYSTEM
      // =====================================================
      async function checkAuth() {
        try {
          const {
            data: { session },
            error,
          } = await supabase.auth.getSession();

          if (error) {
            console.error("Auth error:", error);
            currentUser = null;
            openAuthModal();
            return;
          }

          if (!session) {
            currentUser = null;
            openAuthModal();
            return;
          }

          currentUser = session.user;
          updateUIWithUser();
        } catch (error) {
          console.error("Error checking auth:", error);
          currentUser = null;
          openAuthModal();
        }
      }

      function updateUIWithUser() {
        if (!currentUser) return;

        const name =
          currentUser.user_metadata?.full_name ||
          currentUser.email.split("@")[0];
        const userElements = document.querySelectorAll("[data-user-name]");
        userElements.forEach((el) => (el.textContent = name));
      }

      // =====================================================
      // USER PROFILE & STATS MANAGEMENT
      // =====================================================
      async function loadUserProfile() {
        try {
          // 🔍 Step 1: Try to fetch existing profile
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("*")
            .eq("id", currentUser.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (!profile) {
            // 🆕 Step 2: Create new profile if missing
            await createUserProfile();
          } else {
            // ✅ Step 3: Use existing profile
            userStats = profile;
            await updateLastActivity();
          }
        } catch (error) {
          console.error("❌ Error loading user profile:", error);
          showToast("Failed to load user profile", "error");
        }
      }
      async function createUserProfile() {
        try {
          const newProfile = {
            id: currentUser.id,
            full_name: currentUser.user_metadata?.full_name || "",
            email: currentUser.email,
            level: "Script Kiddie",
            total_points: 0,
            completed_courses: 0,
            current_streak: 0,
            total_certificates: 0,
            total_achievements: 0,
            sections_visited: 0,
            bonus_points: 0,
            in_progress_courses: 0,
            settings_changed: 0,
            midnight_sessions: 0,
            early_sessions: 0,
            weekend_sessions: 0,
            last_activity: new Date().toISOString(),
            created_at: new Date().toISOString(),
          };

          const { error } = await supabase
            .from("profiles")
            .insert([newProfile]);

          if (!error) {
            userStats = newProfile;
            // Award first login achievement
            setTimeout(() => checkAndUnlockAchievement("first_login"), 1000);
          }
        } catch (error) {
          console.error("Error creating user profile:", error);
        }
      }

      async function updateLastActivity() {
        try {
          const now = new Date();

          // Update activity tracking
          courseSession.lastActivityTime = now;

          // Update database
          await supabase
            .from("profiles")
            .update({
              last_activity: now.toISOString(),
            })
            .eq("id", currentUser.id);

          // Check time-based achievements
          await checkTimeBasedAchievements(now);
        } catch (error) {
          console.error("Error updating last activity:", error);
        }
      }

      // =====================================================
      // COURSE SESSION MANAGEMENT
      // =====================================================
      function startCourseSession() {
        courseSession.startTime = new Date();
        courseSession.pageLoadTime = new Date();

        logUserActivity("course_session_start", {
          course_id: COURSE_DATA.id,
          course_title: COURSE_DATA.title,
          user_agent: navigator.userAgent,
          screen_resolution: `${screen.width}x${screen.height}`,
        });

        // Check daily streak
        checkDailyStreak();
      }

      function initializeActivityTracking() {
        // Track page focus/blur for accurate study time
        document.addEventListener("visibilitychange", handleVisibilityChange);

        // Track user interactions
        ["click", "keydown", "scroll", "mousemove"].forEach((event) => {
          document.addEventListener(event, trackUserInteraction, {
            passive: true,
          });
        });

        // Periodic activity updates
        setInterval(updateStudyTime, 60000); // Every minute

        // Save session data before page unload
        window.addEventListener("beforeunload", saveSessionData);
      }

      function handleVisibilityChange() {
        if (document.hidden) {
          courseSession.lastActivityTime = new Date();
        } else {
          // Page became visible again - update activity
          updateLastActivity();
        }
      }

      function trackUserInteraction() {
        courseSession.interactionCount++;
        courseSession.lastActivityTime = new Date();

        // Throttle activity updates
        if (courseSession.interactionCount % 50 === 0) {
          updateLastActivity();
        }
      }

      function updateStudyTime() {
        if (!courseSession.startTime || document.hidden) return;

        const now = new Date();
        const sessionDuration = now - courseSession.startTime;
        courseSession.totalStudyTime = Math.floor(sessionDuration / 1000 / 60); // in minutes

        // Update progress with study time
        saveProgress();
      }

      function saveSessionData() {
        if (!currentUser || !courseSession.startTime) return;

        const sessionData = {
          user_id: currentUser.id,
          course_id: COURSE_DATA.id,
          session_duration: courseSession.totalStudyTime,
          lessons_viewed: courseSession.lessonsStarted,
          lessons_completed: courseSession.lessonsCompleted,
          interactions: courseSession.interactionCount,
          session_date: courseSession.startTime.toISOString().split("T")[0],
        };

        // Store in localStorage as backup
        localStorage.setItem(
          "course_session_backup",
          JSON.stringify(sessionData)
        );

        // Try to save to database
        logUserActivity("course_session_end", sessionData);
      }

      // =====================================================
      // COURSE DATA & PROGRESS MANAGEMENT
      // =====================================================
      async function loadCourseData() {
        try {
          // Update course info in UI
          document.getElementById("courseTitle").textContent =
            COURSE_DATA.title;
          document.getElementById("totalLessons").textContent =
            COURSE_DATA.lessons.length;

          // Log course access
          logUserActivity("course_access", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
          });
        } catch (error) {
          console.error("Error loading course data:", error);
        }
      }

      async function loadProgress() {
        try {
          // Get existing progress from database
          const { data, error } = await supabase
            .from("course_progress")
            .select("*")
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (data) {
            courseProgress = JSON.parse(data.lesson_progress || "{}");
            currentLessonIndex = data.current_lesson || 0;

            // Update session tracking
            courseSession.lessonsStarted = Object.keys(courseProgress).length;
            courseSession.lessonsCompleted = Object.values(
              courseProgress
            ).filter((p) => p.completed).length;
          } else {
            // Initialize new progress
            courseProgress = {};
            currentLessonIndex = 0;
            await saveProgress();

            // Award first course start achievement
            await checkAndUnlockAchievement("first_course_start");
          }

          updateProgressDisplay();
        } catch (error) {
          console.error("Error loading progress:", error);
          showToast("Failed to load progress", "error");
        }
      }

      async function saveProgress() {
        try {
          if (!currentUser) return;

          const now = new Date();
          const progressData = {
            user_id: currentUser.id,
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            current_lesson: currentLessonIndex,
            lesson_progress: JSON.stringify(courseProgress),
            progress: calculateOverallProgress(),
            lessons_completed: getCompletedLessonsCount(),
            lessons_started: Object.keys(courseProgress).length,
            study_time_minutes: courseSession.totalStudyTime,
            last_accessed: now.toISOString(),
            updated_at: now.toISOString(),
          };

          // Upsert progress
          const { error } = await supabase
            .from("course_progress")
            .upsert([progressData]);

          if (error) throw error;

          // Update user stats
          await updateUserStats();

          updateProgressDisplay();
        } catch (error) {
          console.error("Error saving progress:", error);
          showToast("Failed to save progress", "error");
        }
      }

      async function updateUserStats() {
        try {
          // Get all course progress for this user
          const { data: allProgress, error } = await supabase
            .from("course_progress")
            .select("progress, course_id, study_time_minutes")
            .eq("user_id", currentUser.id);

          if (error) throw error;

          // Calculate stats
          const completedCourses =
            allProgress?.filter((p) => p.progress >= 100).length || 0;
          const inProgressCourses =
            allProgress?.filter((p) => p.progress > 0 && p.progress < 100)
              .length || 0;
          const totalStudyTime =
            allProgress?.reduce(
              (sum, p) => sum + (p.study_time_minutes || 0),
              0
            ) || 0;

          // Calculate points (500 per completed course + achievement points)
          const coursePoints = completedCourses * 500;
          const bonusPoints = userStats.bonus_points || 0;
          const totalPoints = coursePoints + bonusPoints;

          // Update profile
          const updateData = {
            completed_courses: completedCourses,
            in_progress_courses: inProgressCourses,
            total_points: totalPoints,
            total_study_time: totalStudyTime,
            last_activity: new Date().toISOString(),
          };

          const { error: updateError } = await supabase
            .from("profiles")
            .update(updateData)
            .eq("id", currentUser.id);

          if (updateError) throw updateError;

          // Update local stats
          Object.assign(userStats, updateData);
        } catch (error) {
          console.error("Error updating user stats:", error);
        }
      }

      function calculateOverallProgress() {
        const completedLessons = getCompletedLessonsCount();
        return Math.round(
          (completedLessons / COURSE_DATA.lessons.length) * 100
        );
      }

      function getCompletedLessonsCount() {
        return Object.values(courseProgress).filter(
          (lesson) => lesson.completed
        ).length;
      }

      function updateProgressDisplay() {
        const completedCount = getCompletedLessonsCount();
        const progressPercent = calculateOverallProgress();

        // Update UI elements
        const elements = {
          completedLessons: completedCount,
          courseProgressPercent: `${progressPercent}%`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });

        // Update progress bar
        const progressBar = document.getElementById("courseProgressFill");
        if (progressBar) progressBar.style.width = `${progressPercent}%`;
      }

      // =====================================================
      // LESSON MANAGEMENT
      // =====================================================
      function loadLesson(index) {
        if (index < 0 || index >= COURSE_DATA.lessons.length) return;

        const lesson = COURSE_DATA.lessons[index];
        currentLessonIndex = index;

        // Mark lesson as started and track activity
        if (!courseProgress[lesson.id]) {
          courseProgress[lesson.id] = {
            started: true,
            completed: false,
            startedAt: new Date().toISOString(),
            timeSpent: 0,
          };

          courseSession.lessonsStarted++;
          saveProgress();

          // Log lesson start
          logUserActivity("lesson_start", {
            lesson_id: lesson.id,
            lesson_title: lesson.title,
            lesson_index: index,
          });
        }

        // Update lesson start time for time tracking
        courseProgress[lesson.id].currentSessionStart = new Date();

        // Update sidebar and navigation
        renderSidebar();
        updateNavigationButtons();

        // Update header info
        updateLessonHeader(lesson, index);

        // Render lesson content
        renderLessonContent(lesson);

        // Smooth scroll and animations
        window.scrollTo({ top: 0, behavior: "smooth" });
        document.getElementById("contentBody").scrollTop = 0;

        const contentBody = document.getElementById("contentBody");
        contentBody.classList.add("fade-in");
        setTimeout(() => contentBody.classList.remove("fade-in"), 500);

        // Check lesson-based achievements
        checkLessonAchievements(index + 1);
      }

      function updateLessonHeader(lesson, index) {
        const elements = {
          currentLessonNumber: index + 1,
          currentLessonTitle: lesson.title,
          navInfo: `Lesson ${index + 1} of ${COURSE_DATA.lessons.length}`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });
      }

      function renderSidebar() {
        const lessonNav = document.getElementById("lessonNav");
        if (!lessonNav) return;

        lessonNav.innerHTML = "";

        COURSE_DATA.lessons.forEach((lesson, index) => {
          const lessonItem = document.createElement("div");
          lessonItem.className = "lesson-item";

          // Determine lesson status
          const lessonProgress = courseProgress[lesson.id];
          const isCompleted = lessonProgress?.completed || false;
          const isInProgress = lessonProgress?.started || false;
          const isLocked = !isCompleted && !canAccessLesson(index);
          const isActive = index === currentLessonIndex;

          // Apply status classes
          if (isCompleted) lessonItem.classList.add("completed");
          if (isLocked) lessonItem.classList.add("locked");
          if (isActive) lessonItem.classList.add("active");

          // Determine status display
          let statusClass = "not-started";
          let statusIcon = index + 1;

          if (isCompleted) {
            statusClass = "completed";
            statusIcon = "✓";
          } else if (isInProgress) {
            statusClass = "in-progress";
            statusIcon = "◐";
          }

          // Create lesson item HTML
          lessonItem.innerHTML = `
            <div class="lesson-status ${statusClass}">${statusIcon}</div>
            <div class="lesson-info">
                <div class="lesson-title">${lesson.title}</div>
                <div class="lesson-meta">
                    ${
                      isCompleted
                        ? "Completed"
                        : isInProgress
                        ? "In Progress"
                        : isLocked
                        ? "Locked"
                        : "Not Started"
                    }
                </div>
            </div>
            <div class="lesson-duration">${lesson.duration}</div>
        `;

          // Add click handler if not locked
          if (!isLocked) {
            lessonItem.addEventListener("click", () => {
              if (index !== currentLessonIndex) {
                // Track lesson time before switching
                trackLessonTime();

                currentLessonIndex = index;
                loadLesson(index);
                closeSidebar();
              }
            });
          }

          lessonNav.appendChild(lessonItem);
        });
      }

      function canAccessLesson(index) {
        if (index === 0) return true; // First lesson always accessible

        // Can access if previous lesson is completed
        const previousLessonId = COURSE_DATA.lessons[index - 1].id;
        return courseProgress[previousLessonId]?.completed || false;
      }

      function trackLessonTime() {
        const currentLesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonProgress = courseProgress[currentLesson.id];

        if (lessonProgress?.currentSessionStart) {
          const sessionTime = Math.floor(
            (new Date() - new Date(lessonProgress.currentSessionStart)) /
              1000 /
              60
          );
          lessonProgress.timeSpent =
            (lessonProgress.timeSpent || 0) + sessionTime;
          delete lessonProgress.currentSessionStart;
        }
      }

      // =====================================================
      // LESSON CONTENT RENDERING
      // =====================================================
      function renderLessonContent(lesson) {
        const contentContainer = document.getElementById("lessonContent");
        if (!contentContainer) return;

        let contentHTML = `
        <div class="content-section">
            <h2>Learning Objectives</h2>
            <ul>
                ${lesson.objectives.map((obj) => `<li>${obj}</li>`).join("")}
            </ul>
        </div>
        
        <div class="content-section">
            <h2>Overview</h2>
            <p>${lesson.content.overview}</p>
        </div>
    `;

        // Render content sections
        lesson.content.sections.forEach((section) => {
          contentHTML += `
            <div class="content-section">
                <h2>${section.title}</h2>
                ${section.content}
                ${
                  section.image
                    ? `<img src="${section.image}" alt="${section.title}" class="content-image" loading="lazy">`
                    : ""
                }
            </div>
        `;
        });

        // Render code examples
        if (
          lesson.content.codeExamples &&
          lesson.content.codeExamples.length > 0
        ) {
          contentHTML += `<div class="content-section"><h2>Code Examples</h2></div>`;

          lesson.content.codeExamples.forEach((example, index) => {
            const codeId = `code-${lesson.id}-${index}`;
            contentHTML += `
                <div class="code-section">
                    <div class="code-header">
                        <span class="code-title">${example.title}</span>
                        <button class="copy-btn" onclick="copyCode('${codeId}')">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <pre class="code-block"><code id="${codeId}" class="language-${
              example.language
            }">${escapeHtml(example.code)}</code></pre>
                </div>
            `;
          });
        }

        // Render quiz
        contentHTML += renderQuiz(lesson.quiz);

        contentContainer.innerHTML = contentHTML;

        // Highlight code syntax if Prism is available
        setTimeout(() => {
          if (window.Prism) {
            Prism.highlightAll();
          }
        }, 100);
      }

      // =====================================================
      // QUIZ SYSTEM
      // =====================================================
      function renderQuiz(quiz) {
        const currentLessonProgress =
          courseProgress[COURSE_DATA.lessons[currentLessonIndex].id];
        const isCompleted = currentLessonProgress?.completed || false;

        let quizHTML = `
        <div class="quiz-section" id="quizSection">
            <div class="quiz-header">
                <h2 class="quiz-title">
                    <i class="fas fa-clipboard-check"></i>
                    Knowledge Check
                </h2>
                <p class="quiz-info">
                    Complete this quiz with ${quiz.passingScore}% or higher to unlock the next lesson.
                </p>
            </div>
    `;

        if (isCompleted) {
          const savedScore = currentLessonProgress.quizScore || 0;
          quizHTML += `
            <div class="quiz-results show">
                <div class="quiz-score pass">${savedScore}%</div>
                <div class="quiz-message">
                    <strong>Lesson Completed!</strong><br>
                    You've successfully passed this lesson's quiz.
                </div>
            </div>
        `;
        } else {
          // Render quiz questions
          quiz.questions.forEach((question, qIndex) => {
            quizHTML += `
                <div class="quiz-question ${
                  qIndex === 0 ? "active" : ""
                }" data-question="${qIndex}">
                    <div class="question-header">
                        <span class="question-number">Question ${
                          qIndex + 1
                        }</span>
                        <span class="question-progress">${qIndex + 1}/${
              quiz.questions.length
            }</span>
                    </div>
                    <div class="question-text">${question.question}</div>
                    <div class="question-options">
                        ${question.options
                          .map(
                            (option, oIndex) => `
                            <div class="option" data-option="${oIndex}" onclick="selectOption(${qIndex}, ${oIndex})">
                                <span class="option-letter">${String.fromCharCode(
                                  65 + oIndex
                                )}</span>
                                <span class="option-text">${option}</span>
                            </div>
                        `
                          )
                          .join("")}
                    </div>
                </div>
            `;
          });

          quizHTML += `
            <div class="quiz-controls">
                <button class="btn btn-secondary" id="prevQuestionBtn" onclick="previousQuestion()" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <div>
                    <button class="btn btn-secondary" id="nextQuestionBtn" onclick="nextQuestion()" disabled>
                        Next
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <button class="btn btn-primary" id="submitQuizBtn" onclick="submitQuiz()" style="display: none;">
                        <i class="fas fa-check"></i>
                        Submit Quiz
                    </button>
                </div>
            </div>

            <div class="quiz-results" id="quizResults">
                <div class="quiz-score" id="quizScore">0%</div>
                <div class="quiz-message" id="quizMessage"></div>
                <div class="quiz-actions">
                    <button class="btn btn-primary" id="continueBtn" onclick="completeLesson()" style="display: none;">
                        <i class="fas fa-arrow-right"></i>
                        Continue to Next Lesson
                    </button>
                    <button class="btn btn-secondary" onclick="retakeQuiz()">
                        <i class="fas fa-redo"></i>
                        Retake Quiz
                    </button>
                </div>
            </div>
        `;
        }

        quizHTML += "</div>";
        return quizHTML;
      }

      // Quiz interaction functions
      function selectOption(questionIndex, optionIndex) {
        // Clear previous selections
        document
          .querySelectorAll(`[data-question="${questionIndex}"] .option`)
          .forEach((opt) => {
            opt.classList.remove("selected");
          });

        // Select current option
        const selectedOption = document.querySelector(
          `[data-question="${questionIndex}"] [data-option="${optionIndex}"]`
        );
        selectedOption.classList.add("selected");

        // Store answer
        quizState.answers[questionIndex] = optionIndex;

        // Update navigation
        const isLastQuestion =
          questionIndex ===
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length - 1;
        if (isLastQuestion) {
          document.getElementById("submitQuizBtn").style.display =
            "inline-flex";
          document.getElementById("nextQuestionBtn").style.display = "none";
        } else {
          document.getElementById("nextQuestionBtn").disabled = false;
        }
      }

      function nextQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const nextQuestionEl = currentQuestionEl.nextElementSibling;

        if (
          nextQuestionEl &&
          nextQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          nextQuestionEl.classList.add("active");
          quizState.currentQuestion++;
          updateQuizNavigation();
        }
      }

      function previousQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const prevQuestionEl = currentQuestionEl.previousElementSibling;

        if (
          prevQuestionEl &&
          prevQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          prevQuestionEl.classList.add("active");
          quizState.currentQuestion--;
          updateQuizNavigation();
        }
      }

      function updateQuizNavigation() {
        const totalQuestions =
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length;
        const prevBtn = document.getElementById("prevQuestionBtn");
        const nextBtn = document.getElementById("nextQuestionBtn");
        const submitBtn = document.getElementById("submitQuizBtn");

        prevBtn.disabled = quizState.currentQuestion === 0;

        const hasAnswer =
          quizState.answers[quizState.currentQuestion] !== undefined;
        const isLastQuestion = quizState.currentQuestion === totalQuestions - 1;

        if (isLastQuestion) {
          nextBtn.style.display = "none";
          submitBtn.style.display = hasAnswer ? "inline-flex" : "none";
        } else {
          nextBtn.style.display = "inline-flex";
          nextBtn.disabled = !hasAnswer;
          submitBtn.style.display = "none";
        }
      }

      async function submitQuiz() {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const quiz = lesson.quiz;
        let correctAnswers = 0;

        // Hide questions and controls
        document
          .querySelectorAll(".quiz-question")
          .forEach((q) => (q.style.display = "none"));
        document.querySelector(".quiz-controls").style.display = "none";

        // Calculate score and highlight answers
        quiz.questions.forEach((question, index) => {
          const userAnswer = quizState.answers[index];
          const correctAnswer = question.correct;
          const isCorrect = userAnswer === correctAnswer;

          if (isCorrect) correctAnswers++;

          // Highlight answers
          const questionEl = document.querySelector(
            `[data-question="${index}"]`
          );
          const options = questionEl.querySelectorAll(".option");

          options[correctAnswer].classList.add("correct");
          if (userAnswer !== correctAnswer && userAnswer !== undefined) {
            options[userAnswer].classList.add("incorrect");
          }
        });

        const score = Math.round(
          (correctAnswers / quiz.questions.length) * 100
        );
        const passed = score >= quiz.passingScore;

        // Update quiz results UI
        const quizScore = document.getElementById("quizScore");
        const quizMessage = document.getElementById("quizMessage");
        const quizActions = document.querySelector(".quiz-actions");

        quizScore.textContent = `${score}%`;
        quizScore.className = `quiz-score ${passed ? "pass" : "fail"}`;

        if (passed) {
          quizMessage.innerHTML = `
            <strong>Congratulations!</strong><br>
            You passed with ${score}%. You can now proceed to the next lesson.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-primary" onclick="completeLesson()">
                <i class="fas fa-arrow-right"></i>
                Continue to Next Lesson
            </button>
        `;

          // Mark lesson as completed
          await markLessonComplete(score);
        } else {
          quizMessage.innerHTML = `
            <strong>Not quite there yet.</strong><br>
            You scored ${score}%. You need ${quiz.passingScore}% to pass. Review the material and try again.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-secondary" onclick="retakeQuiz()">
                <i class="fas fa-redo"></i>
                Retake Quiz
            </button>
        `;
        }

        document.getElementById("quizResults").classList.add("show");

        // Log quiz completion
        logUserActivity("quiz_completed", {
          lesson_id: lesson.id,
          lesson_title: lesson.title,
          score: score,
          passed: passed,
          attempts: (courseProgress[lesson.id]?.quizAttempts || 0) + 1,
        });

        // Scroll to results
        document
          .getElementById("quizResults")
          .scrollIntoView({ behavior: "smooth" });
      }

      function retakeQuiz() {
        // Reset quiz state
        quizState = {
          currentQuestion: 0,
          answers: [],
          score: 0,
          isComplete: false,
        };

        // Track quiz retry
        const lessonId = COURSE_DATA.lessons[currentLessonIndex].id;
        if (!courseProgress[lessonId]) courseProgress[lessonId] = {};
        courseProgress[lessonId].quizAttempts =
          (courseProgress[lessonId].quizAttempts || 0) + 1;

        // Reload lesson content
        loadLesson(currentLessonIndex);

        // Scroll to quiz
        setTimeout(() => {
          document
            .getElementById("quizSection")
            .scrollIntoView({ behavior: "smooth" });
        }, 500);
      }

      async function markLessonComplete(score) {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonId = lesson.id;

        // Track lesson completion time
        trackLessonTime();

        // Update lesson progress
        courseProgress[lessonId] = {
          ...courseProgress[lessonId],
          completed: true,
          quizScore: score,
          completedAt: new Date().toISOString(),
          finalScore: score,
        };

        // Update session tracking
        courseSession.lessonsCompleted++;

        // Save progress to database
        await saveProgress();

        // Update UI
        renderSidebar();
        updateNavigationButtons();

        // Check various achievements
        await checkLessonCompletionAchievements();
        await checkPerfectScoreAchievements(score);
        await checkStudyTimeAchievements();

        // Log lesson completion
        logUserActivity("lesson_completed", {
          lesson_id: lessonId,
          lesson_title: lesson.title,
          final_score: score,
          time_spent: courseProgress[lessonId].timeSpent || 0,
          lesson_number: currentLessonIndex + 1,
        });

        showToast("Lesson completed successfully!", "success");
      }

      async function completeLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          // Move to next lesson
          currentLessonIndex++;
          loadLesson(currentLessonIndex);
        } else {
          // Course completion
          await completeCourse();
        }
      }

      async function completeCourse() {
        try {
          const completionTime = courseSession.totalStudyTime;

          // Update course progress to 100% completed
          await supabase
            .from("course_progress")
            .update({
              progress: 100,
              completed_at: new Date().toISOString(),
              completion_time_minutes: completionTime,
            })
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Award course completion achievements
          await checkAndUnlockAchievement("course_completion_1");
          await checkSpeedCompletionAchievements(completionTime);
          await checkCourseStreakAchievements();

          // Update user stats
          await updateUserStats();

          // Show completion message
          showToast(
            "Congratulations! Course completed successfully!",
            "certificate"
          );

          // Log course completion
          logUserActivity("course_completed", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            completion_time_minutes: completionTime,
            total_lessons: COURSE_DATA.lessons.length,
            average_quiz_score: calculateAverageQuizScore(),
          });

          // Redirect to dashboard after delay
          setTimeout(() => {
            window.location.href = "/dashboard.html";
          }, 3000);
        } catch (error) {
          console.error("Error completing course:", error);
          showToast("Error marking course as complete", "error");
        }
      }

      // =====================================================
      // ACHIEVEMENT INTEGRATION SYSTEM
      // =====================================================
      async function checkAndUnlockAchievement(
        achievementId,
        skipNotification = false
      ) {
        try {
          // Prevent duplicate checks
          const cacheKey = `achievement_${achievementId}_${currentUser.id}`;
          if (sessionStorage.getItem(cacheKey)) return false;

          // Check if already unlocked
          const { data: existing, error } = await supabase
            .from("user_achievements")
            .select("id")
            .eq("user_id", currentUser.id)
            .eq("achievement_id", achievementId)
            .single();

          if (existing) {
            sessionStorage.setItem(cacheKey, "true");
            return false;
          }

          // Award achievement
          const achievementData = {
            user_id: currentUser.id,
            achievement_id: achievementId,
            unlocked_at: new Date().toISOString(),
            points_awarded: getAchievementPoints(achievementId),
            context: "course_system",
          };

          const { data, error: insertError } = await supabase
            .from("user_achievements")
            .insert([achievementData])
            .select()
            .single();

          if (insertError) {
            if (insertError.code === "23505") return false; // Already exists
            throw insertError;
          }

          // Update user points
        await supabase.rpc('increment_user_stats', {
  user_id_param: currentUser.id,
  points_to_add: achievementData.points_awarded,
  achievements_to_add: 1
});

          // Cache and queue notification
          sessionStorage.setItem(cacheKey, "true");

          if (!skipNotification) {
            queueAchievementNotification({
              id: achievementId,
              name: getAchievementName(achievementId),
              description: getAchievementDescription(achievementId),
              points: achievementData.points_awarded,
              rarity: getAchievementRarity(achievementId),
              icon: getAchievementIcon(achievementId),
            });
          }

          return true;
        } catch (error) {
          console.error("Error unlocking achievement:", error);
          return false;
        }
      }

      // Helper functions for achievement data (replace with your actual achievement definitions)
      function getAchievementPoints(id) {
        const pointsMap = {
          first_course_start: 75,
          first_lesson: 100,
          course_completion_1: 500,
          perfect_score: 250,
          speed_demon: 750,
          marathon_learner: 500,
          night_owl: 200,
          early_bird: 200,
          weekend_warrior: 150,
          // Add more as needed
        };
        return pointsMap[id] || 100;
      }

      function getAchievementName(id) {
        const nameMap = {
          first_course_start: "Learning Initiated",
          first_lesson: "First Steps",
          course_completion_1: "Course Conqueror",
          perfect_score: "Perfectionist",
          speed_demon: "Speed Demon",
          // Add more as needed
        };
        return nameMap[id] || "Achievement Unlocked";
      }

      function getAchievementDescription(id) {
        const descMap = {
          first_course_start: "Start your first cybersecurity course",
          first_lesson: "Complete your first lesson",
          course_completion_1: "Complete your first course",
          perfect_score: "Score 100% on any quiz",
          speed_demon: "Complete a course in under 2 hours",
          // Add more as needed
        };
        return descMap[id] || "Achievement description";
      }

      function getAchievementRarity(id) {
        const rarityMap = {
          first_course_start: "common",
          first_lesson: "bronze",
          course_completion_1: "silver",
          perfect_score: "gold",
          speed_demon: "legendary",
          // Add more as needed
        };
        return rarityMap[id] || "common";
      }

      function getAchievementIcon(id) {
        const iconMap = {
          first_course_start: "fas fa-play",
          first_lesson: "fas fa-baby",
          course_completion_1: "fas fa-trophy",
          perfect_score: "fas fa-star",
          speed_demon: "fas fa-rocket",
          // Add more as needed
        };
        return iconMap[id] || "fas fa-award";
      }

      async function checkLessonAchievements(lessonNumber) {
        if (lessonNumber === 1) {
          await checkAndUnlockAchievement("first_lesson");
        }

        // Check if user has completed multiple lessons in one day
        const today = new Date().toISOString().split("T")[0];
        const todayCompletions = Object.values(courseProgress).filter(
          (p) => p.completed && p.completedAt?.startsWith(today)
        ).length;

        if (todayCompletions >= 3) {
          await checkAndUnlockAchievement("lesson_marathon");
        }
      }

      async function checkLessonCompletionAchievements() {
        const completedCount = getCompletedLessonsCount();

        // Lesson-based achievements
        const lessonMilestones = [1, 5, 10, 25, 50, 100];
        for (const milestone of lessonMilestones) {
          if (completedCount >= milestone) {
            await checkAndUnlockAchievement(`lessons_${milestone}`);
          }
        }

        // Course completion achievements
        if (completedCount === COURSE_DATA.lessons.length) {
          await checkAndUnlockAchievement("course_completion_1");

          // Check for additional course completion achievements
          const { data: allCourses } = await supabase
            .from("course_progress")
            .select("course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100);

          const totalCompleted = allCourses?.length || 0;

          const courseMilestones = [1, 5, 10, 25];
          for (const milestone of courseMilestones) {
            if (totalCompleted >= milestone) {
              await checkAndUnlockAchievement(`course_completion_${milestone}`);
            }
          }
        }
      }

      async function checkPerfectScoreAchievements(score) {
        if (score === 100) {
          await checkAndUnlockAchievement("perfect_score");

          // Check for consecutive perfect scores
          const recentScores = Object.values(courseProgress)
            .filter((p) => p.completed && p.quizScore)
            .slice(-5) // Last 5 completed
            .map((p) => p.quizScore);

          if (
            recentScores.length >= 3 &&
            recentScores.every((s) => s === 100)
          ) {
            await checkAndUnlockAchievement("perfectionist_streak");
          }
        }
      }

      async function checkSpeedCompletionAchievements(completionTime) {
        // Speed demon: Complete course in under 2 hours (120 minutes)
        if (completionTime <= 120) {
          await checkAndUnlockAchievement("speed_demon");
        }

        // Quick learner: Complete course in under 4 hours (240 minutes)
        if (completionTime <= 240) {
          await checkAndUnlockAchievement("quick_learner");
        }
      }

      async function checkStudyTimeAchievements() {
        const totalTime = courseSession.totalStudyTime;

        // Marathon learner: Study for 8+ hours in a course session
        if (totalTime >= 480) {
          // 8 hours
          await checkAndUnlockAchievement("marathon_learner");
        }

        // Dedicated learner: Study for 4+ hours
        if (totalTime >= 240) {
          // 4 hours
          await checkAndUnlockAchievement("dedicated_learner");
        }
      }

      async function checkCourseStreakAchievements() {
        try {
          // Check for consecutive course completions
          const { data: recentCourses, error } = await supabase
            .from("course_progress")
            .select("completed_at, course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100)
            .order("completed_at", { ascending: false })
            .limit(10);

          if (error || !recentCourses) return;

          // Check for courses completed on consecutive days
          let consecutiveDays = 1;
          for (let i = 1; i < recentCourses.length; i++) {
            const prevDate = new Date(
              recentCourses[i - 1].completed_at
            ).toDateString();
            const currentDate = new Date(
              recentCourses[i].completed_at
            ).toDateString();
            const dayDiff =
              Math.abs(new Date(prevDate) - new Date(currentDate)) /
              (1000 * 60 * 60 * 24);

            if (dayDiff <= 1) {
              consecutiveDays++;
            } else {
              break;
            }
          }

          if (consecutiveDays >= 3) {
            await checkAndUnlockAchievement("learning_streak");
          }
        } catch (error) {
          console.error("Error checking course streak achievements:", error);
        }
      }

      // =====================================================
      // TIME-BASED ACHIEVEMENTS
      // =====================================================
      async function checkTimeBasedAchievements(timestamp) {
        const hour = timestamp.getHours();
        const dayOfWeek = timestamp.getDay();

        // Night owl (after midnight, before 6 AM)
        if (hour >= 0 && hour < 6) {
          await incrementTimeBasedCounter("midnight_sessions", "night_owl");
        }

        // Early bird (4 AM to 6 AM)
        if (hour >= 4 && hour < 6) {
          await incrementTimeBasedCounter("early_sessions", "early_bird");
        }

        // Weekend warrior (Saturday = 6, Sunday = 0)
        if (dayOfWeek === 0 || dayOfWeek === 6) {
          await incrementTimeBasedCounter(
            "weekend_sessions",
            "weekend_warrior"
          );
        }
      }

      async function incrementTimeBasedCounter(counterType, achievementId) {
        try {
          const dateStr = new Date().toISOString().split("T")[0];
          const cacheKey = `${counterType}_${currentUser.id}_${dateStr}`;

          // Prevent multiple increments per day
          if (sessionStorage.getItem(cacheKey)) return;

          // Update counter
       await supabase.rpc('increment_profile_counter', {
  user_id_param: currentUser.id,
  counter_field: counterType,
  increment_value: 1
});

          // Cache to prevent double counting
          sessionStorage.setItem(cacheKey, "true");

          // Check related achievement
          if (achievementId) {
            await checkAndUnlockAchievement(achievementId, true);
          }
        } catch (error) {
          console.error(`Error incrementing ${counterType}:`, error);
        }
      }

      async function checkDailyStreak() {
        try {
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("last_activity, current_streak, last_streak_date")
            .eq("id", currentUser.id)
            .single();

          if (error) throw error;

          const now = new Date();
          const today = now.toDateString();
          const lastActivity = profile.last_activity
            ? new Date(profile.last_activity)
            : null;
          const lastStreakDate = profile.last_streak_date
            ? new Date(profile.last_streak_date).toDateString()
            : null;

          let newStreak = profile.current_streak || 0;
          let shouldUpdateStreak = false;

          if (!lastActivity) {
            // First time user
            newStreak = 1;
            shouldUpdateStreak = true;
          } else {
            const daysSinceLastActivity = Math.floor(
              (now - lastActivity) / (1000 * 60 * 60 * 24)
            );

            if (lastStreakDate === today) {
              // Already counted today's streak
              return newStreak;
            } else if (
              daysSinceLastActivity === 1 ||
              (daysSinceLastActivity === 0 && lastStreakDate !== today)
            ) {
              // Consecutive day or same day but not counted yet
              newStreak += 1;
              shouldUpdateStreak = true;
            } else if (daysSinceLastActivity > 1) {
              // Streak broken
              newStreak = 1;
              shouldUpdateStreak = true;
            }
          }

          if (shouldUpdateStreak) {
            await supabase
              .from("profiles")
              .update({
                current_streak: newStreak,
                last_activity: now.toISOString(),
                last_streak_date: now.toISOString(),
              })
              .eq("id", currentUser.id);

            userStats.current_streak = newStreak;

            showToast(`Daily streak: ${newStreak} days!`, "success");
            await checkStreakAchievements(newStreak);
          }

          return newStreak;
        } catch (error) {
          console.error("Error checking daily streak:", error);
          return 0;
        }
      }

      async function checkStreakAchievements(currentStreak) {
        const streakMilestones = [3, 7, 14, 30, 100, 365];

        for (const milestone of streakMilestones) {
          if (currentStreak >= milestone) {
            await checkAndUnlockAchievement(`streak_${milestone}`);
          }
        }
      }

      // =====================================================
      // USER ACTIVITY LOGGING
      // =====================================================
      async function logUserActivity(activityType, metadata = {}) {
        try {
          const now = new Date();

          const activityData = {
            user_id: currentUser.id,
            activity_type: activityType,
            timestamp: now.toISOString(),
            course_id: COURSE_DATA.id,
            lesson_index: currentLessonIndex,
            session_duration: courseSession.totalStudyTime,
            metadata: JSON.stringify(metadata),
            created_at: now.toISOString(),
          };

          // Try to log to activities table
          const { error } = await supabase
            .from("user_activities")
            .insert([activityData]);

          if (error && error.code !== "42P01") {
            console.warn("Activity logging failed:", error.message);
          }

          // Always update last activity in profile
          await supabase
            .from("profiles")
            .update({ last_activity: now.toISOString() })
            .eq("id", currentUser.id);
        } catch (error) {
          console.error("Error logging user activity:", error);
        }
      }

      // =====================================================
      // NAVIGATION SYSTEM
      // =====================================================
      function updateNavigationButtons() {
        const prevBtn = document.getElementById("prevLessonBtn");
        const nextBtn = document.getElementById("nextLessonBtn");

        if (!prevBtn || !nextBtn) return;

        // Previous button
        prevBtn.disabled = currentLessonIndex === 0;

        // Next button logic
        const isLastLesson =
          currentLessonIndex === COURSE_DATA.lessons.length - 1;
        const canGoNext =
          currentLessonIndex < COURSE_DATA.lessons.length - 1 &&
          canAccessLesson(currentLessonIndex + 1);

        if (isLastLesson) {
          const isCurrentCompleted =
            courseProgress[COURSE_DATA.lessons[currentLessonIndex].id]
              ?.completed;
          nextBtn.disabled = !isCurrentCompleted;
          nextBtn.innerHTML = '<i class="fas fa-trophy"></i> Complete Course';
        } else {
          nextBtn.disabled = !canGoNext;
          nextBtn.innerHTML = 'Next <i class="fas fa-chevron-right"></i>';
        }
      }

      // Navigation button event handlers
      function goToPreviousLesson() {
        if (currentLessonIndex > 0) {
          trackLessonTime(); // Track time spent on current lesson
          currentLessonIndex--;
          loadLesson(currentLessonIndex);
        }
      }

      function goToNextLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          const canGoNext = canAccessLesson(currentLessonIndex + 1);
          if (canGoNext) {
            trackLessonTime();
            currentLessonIndex++;
            loadLesson(currentLessonIndex);
          } else {
            showToast("Complete the current lesson quiz to proceed", "warning");
          }
        } else {
          // Complete course
          completeCourse();
        }
      }

      // =====================================================
      // SIDEBAR FUNCTIONS
      // =====================================================
      function toggleSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.toggle("open");
        if (overlay) overlay.classList.toggle("active");
      }

      function closeSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.remove("open");
        if (overlay) overlay.classList.remove("active");
      }

      // =====================================================
      // ACHIEVEMENT NOTIFICATION SYSTEM
      // =====================================================
      function queueAchievementNotification(achievement) {
        notificationQueue.push(achievement);
        processNotificationQueue();
      }

      function processNotificationQueue() {
        if (isShowingNotification || notificationQueue.length === 0) return;

        isShowingNotification = true;
        const achievement = notificationQueue.shift();
        showAchievementNotification(achievement);

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          isShowingNotification = false;
          processNotificationQueue();
        }, duration + 500);
      }

      function showAchievementNotification(achievement) {
        const notification = document.getElementById("achievementNotification");
        if (!notification) return;

        const icon = document.getElementById("notificationIcon");
        const title = document.getElementById("notificationTitle");
        const description = document.getElementById("notificationDescription");
        const points = document.getElementById("notificationPoints");

        if (icon) {
          icon.innerHTML = `<i class="${achievement.icon}"></i>`;
          icon.className = `notification-icon ${achievement.rarity}`;
        }
        if (title) title.textContent = achievement.name;
        if (description) description.textContent = achievement.description;
        if (points) points.textContent = `+${achievement.points} Points`;

        notification.className = `achievement-notification ${achievement.rarity}`;
        notification.classList.add("show");

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          notification.classList.remove("show");
        }, duration);
      }

      // =====================================================
      // UTILITY FUNCTIONS
      // =====================================================
      function calculateAverageQuizScore() {
        const scores = Object.values(courseProgress)
          .filter((p) => p.completed && p.quizScore)
          .map((p) => p.quizScore);

        if (scores.length === 0) return 0;
        return Math.round(
          scores.reduce((sum, score) => sum + score, 0) / scores.length
        );
      }

      async function resetProgress() {
        if (
          !confirm(
            "Are you sure you want to reset your progress? This action cannot be undone."
          )
        ) {
          return;
        }

        try {
          // Track lesson time before reset
          trackLessonTime();

          // Reset local state
          courseProgress = {};
          currentLessonIndex = 0;
          courseSession = {
            startTime: new Date(),
            totalStudyTime: 0,
            lessonsStarted: 0,
            lessonsCompleted: 0,
            pageLoadTime: new Date(),
            interactionCount: 0,
            lastActivityTime: new Date(),
          };

          // Delete from database
          await supabase
            .from("course_progress")
            .delete()
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Log reset activity
          logUserActivity("progress_reset", {
            course_id: COURSE_DATA.id,
            reset_reason: "manual",
          });

          // Reinitialize
          await saveProgress();
          renderSidebar();
          loadLesson(0);

          showToast("Progress reset successfully", "success");
        } catch (error) {
          console.error("Error resetting progress:", error);
          showToast("Failed to reset progress", "error");
        }
      }

      function copyCode(codeId) {
        const codeElement = document.getElementById(codeId);
        if (!codeElement) return;

        const text = codeElement.textContent;

        navigator.clipboard
          .writeText(text)
          .then(() => {
            showToast("Code copied to clipboard!", "success");

            // Track code copy for achievements
            logUserActivity("code_copied", {
              code_section: codeId,
              lesson_id: COURSE_DATA.lessons[currentLessonIndex].id,
            });
          })
          .catch((err) => {
            console.error("Failed to copy code:", err);
            showToast("Failed to copy code", "error");

            // Fallback for older browsers
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            try {
              document.execCommand("copy");
              showToast("Code copied to clipboard!", "success");
            } catch (fallbackError) {
              showToast(
                "Copy failed - please select and copy manually",
                "error"
              );
            }
            document.body.removeChild(textArea);
          });
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // =====================================================
      // UI FEEDBACK SYSTEMS
      // =====================================================
      function showToast(message, type = "success") {
        const toast = document.getElementById("toast");
        const messageEl = document.getElementById("toastMessage");

        if (!toast || !messageEl) {
          console.log(`Toast: ${message} (${type})`);
          return;
        }

        messageEl.textContent = message;
        toast.className = `toast ${type} show`;

        setTimeout(() => {
          toast.classList.remove("show");
        }, 4000);
      }

      function showLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) loadingScreen.classList.remove("hidden");
      }

      function hideLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) {
          setTimeout(() => {
            loadingScreen.classList.add("hidden");
          }, 1000);
        }
      }

      // =====================================================
      // MUSIC PLAYER INTEGRATION
      // =====================================================
      function initMusicPlayer() {
        const btnText = document.getElementById("music-button-text");
        const icon = document.getElementById("music-icon");
        const dropdown = document.getElementById("music-dropdown-content");

        if (!btnText || !icon || !dropdown) return;

        function setUI(state) {
          btnText.textContent =
            state === "Playing" ? "PAUSE MUSIC" : "STUDY MUSIC";
          icon.className =
            state === "Playing"
              ? "fa-solid fa-circle-pause"
              : "fa-solid fa-music";
        }

        // Load saved music state
        const savedSrc = localStorage.getItem("cybersec_music_src");
        const savedTime = parseFloat(
          localStorage.getItem("cybersec_music_time") || 0
        );

        if (savedSrc) {
          audioPlayer.src = savedSrc;
          audioPlayer.currentTime = savedTime;
          audioPlayer
            .play()
            .then(() => setUI("Playing"))
            .catch(() => setUI("Stopped"));
        }

        // Music button click handler
        document
          .getElementById("music-dropdown")
          .querySelector("button")
          .addEventListener("click", (e) => {
            e.stopPropagation();
            dropdown.style.display =
              dropdown.style.display === "block" ? "none" : "block";

            if (audioPlayer.src && !audioPlayer.paused) {
              audioPlayer.pause();
              setUI("Stopped");
            } else if (audioPlayer.src) {
              audioPlayer.play().then(() => setUI("Playing"));
            }
          });

        // Music selection handlers
        dropdown.querySelectorAll("a[data-src]").forEach((link) => {
          link.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.src = link.dataset.src;
            audioPlayer.play().then(() => setUI("Playing"));
            localStorage.setItem("cybersec_music_src", link.dataset.src);
            dropdown.style.display = "none";
          });
        });

        // Stop music handler
        const stopLink = document.getElementById("stop-music-link");
        if (stopLink) {
          stopLink.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            audioPlayer.removeAttribute("src");
            setUI("Stopped");
            localStorage.removeItem("cybersec_music_src");
            localStorage.removeItem("cybersec_music_time");
            dropdown.style.display = "none";
          });
        }

        // Save music state before page unload
        window.addEventListener("beforeunload", () => {
          if (!audioPlayer.paused && audioPlayer.src) {
            localStorage.setItem("cybersec_music_src", audioPlayer.src);
            localStorage.setItem(
              "cybersec_music_time",
              audioPlayer.currentTime
            );
          }
        });

        // Close dropdown when clicking outside
        window.addEventListener("click", (e) => {
          if (!e.target.closest("#music-dropdown")) {
            dropdown.style.display = "none";
          }
        });
      }

      // Show initial music indicator
      function addMusicIndicator() {
        const musicBtn = document.querySelector("#music-dropdown");
        if (musicBtn) {
          const indicator = document.createElement("div");
          indicator.className = "music-indicator";
          indicator.innerHTML = `<i class="fa-solid fa-music"></i> Try Study Music!`;

          musicBtn.style.position = "relative";
          musicBtn.appendChild(indicator);

          setTimeout(() => indicator.remove(), 3000);
        }
      }

      // Initialize Event Listeners
      function initializeEventListeners() {
        // Navigation buttons
        document
          .getElementById("prevLessonBtn")
          ?.addEventListener("click", goToPreviousLesson);
        document
          .getElementById("nextLessonBtn")
          ?.addEventListener("click", goToNextLesson);

        // Reset progress button
        document
          .getElementById("resetProgressBtn")
          ?.addEventListener("click", resetProgress);

        // Mobile menu toggle
        document
          .getElementById("menuToggle")
          ?.addEventListener("click", toggleSidebar);
        document
          .getElementById("sidebarOverlay")
          ?.addEventListener("click", closeSidebar);

        // Keyboard shortcuts
        document.addEventListener("keydown", handleKeyboardShortcuts);

        // Window resize handler
        window.addEventListener("resize", handleWindowResize);

        // Content interaction tracking
        document.getElementById("contentBody")?.addEventListener(
          "scroll",
          debounce(() => {
            trackUserInteraction();
          }, 1000)
        );
      }

      // Keyboard Shortcuts
      function handleKeyboardShortcuts(e) {
        if (document.querySelector(".quiz-question.active")) return;

        if (e.key === "ArrowLeft" && e.ctrlKey) {
          e.preventDefault();
          goToPreviousLesson();
        } else if (e.key === "ArrowRight" && e.ctrlKey) {
          e.preventDefault();
          goToNextLesson();
        }
      }

      // Window Resize Handler
      function handleWindowResize() {
        if (window.innerWidth > 768) {
          closeSidebar();
        }
      }

      // Debounce Helper
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Initialize responsive behavior
      if (window.innerWidth <= 768) {
        document.getElementById("menuToggle").style.display = "inline-flex";
      }

      // Auto-save progress periodically
      setInterval(async () => {
        if (currentUser && Object.keys(courseProgress).length > 0) {
          await saveProgress();
        }
      }, 60000); // Save every minute

      // System initialization logging
      console.log("CyberSec Academy Course System Initialized");
      console.log("Current Course:", COURSE_DATA.title);
      console.log("Total Lessons:", COURSE_DATA.lessons.length);

      // Google OAuth Integration
      const googleBtn = document.querySelector(".btn-google");
      if (googleBtn) {
        googleBtn.addEventListener("click", async () => {
          const { data, error } = await supabase.auth.signInWithOAuth({
            provider: "google",
            options: {
              redirectTo:
                window.location.origin +
                "/courses/web-application-security.html",
            },
          });

          if (error) {
            console.error("Google login error:", error.message);
            showToast("Google login failed: " + error.message, "error");
          }
        });
      }

      // Check for existing session
      supabase.auth.getSession().then(({ data }) => {
        if (data.session) {
          console.log("User already logged in:", data.session.user);
          currentUser = data.session.user;
          startCourseSession();
        }
      });

      // Add missing auth modal functions
      function openAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "flex";
        }
      }

      function closeAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Add auth tab switching functionality
      document.getElementById("tabSignIn")?.addEventListener("click", () => {
        document.getElementById("tabSignIn").classList.add("active");
        document.getElementById("tabSignUp").classList.remove("active");
        document.getElementById("signInForm").style.display = "block";
        document.getElementById("signUpForm").style.display = "none";
      });

      document.getElementById("tabSignUp")?.addEventListener("click", () => {
        document.getElementById("tabSignUp").classList.add("active");
        document.getElementById("tabSignIn").classList.remove("active");
        document.getElementById("signUpForm").style.display = "block";
        document.getElementById("signInForm").style.display = "none";
      });

      document
        .getElementById("closeAuthModal")
        ?.addEventListener("click", closeAuthModal);

      // Improved error handling for auth session
      supabase.auth.onAuthStateChange((event, session) => {
        if (event === "SIGNED_IN") {
          currentUser = session.user;
          closeAuthModal();
          startCourseSession();
        } else if (event === "SIGNED_OUT") {
          currentUser = null;
          openAuthModal();
        }
      });

      // Add form submission handlers
      document
        .getElementById("emailSignInForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signInEmail").value;
          const password = document.getElementById("signInPassword").value;

          try {
            const { data, error } = await supabase.auth.signInWithPassword({
              email,
              password,
            });

            if (error) throw error;

            closeAuthModal();
          } catch (error) {
            showToast(error.message, "error");
          }
        });

      document
        .getElementById("emailSignUpForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signUpEmail").value;
          const password = document.getElementById("signUpPassword").value;
          const name = document.getElementById("signUpName").value;

          try {
            const { data, error } = await supabase.auth.signUp({
              email,
              password,
              options: {
                data: {
                  full_name: name,
                },
              },
            });

            if (error) throw error;

            showToast(
              "Account created successfully! Please check your email.",
              "success"
            );
          } catch (error) {
            showToast(error.message, "error");
          }
        });
    </script>
  </body>
</html>

