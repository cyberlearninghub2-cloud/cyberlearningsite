


<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Exo+2:wght@700;800;900&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css"
    />
    <link rel="stylesheet" href="assets/css/coursepages.css">
    
    <!-- ========== Start: SEO & Schema Enhancement ========== -->
    <title>Introduction to Malware Analysis - Complete Course | CipherHall</title>
    <meta name="description" content="Begin our expert-led Malware Analysis course. Learn to build a safe lab, perform static and dynamic analysis, master reverse engineering basics, and report on threats.">
    
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png" />
    <link rel="shortcut icon" href="/favicon.png" type="image/x-icon" />
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png" />
    <link rel="canonical" href="https://www.cipherhall.com/courses/malware-analysis-introduction-safe-expanded.html" />

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Course",
      "name": "Introduction to Malware Analysis - Complete Course",
      "description": "An introductory course focused on the ethical and safe analysis of malware for defensive purposes. All labs use benign or synthetic samples in a controlled environment, emphasizing blue-team skills, safe techniques, and the protection of systems.",
      "provider": {
        "@type": "Organization",
        "name": "CipherHall",
        "sameAs": "https://www.cipherhall.com"
      },
      "hasCourseInstance": {
        "@type": "CourseInstance",
        "courseMode": "Online",
        "instructor": {
          "@type": "Person",
          "name": "Dr. Chen Wei"
        }
      }
    }
    </script>
    <!-- ========== End: SEO & Schema Enhancement ========== -->
</head>
  <body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
      <div class="loader-icon">
        <i class="fas fa-graduation-cap"></i>
      </div>
      <div class="loader-text">Loading Course Content...</div>
    </div>

    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- Music Player (fixed at top right) -->
    <div class="header-controls">
      <div class="music-dropdown" id="music-dropdown">
        <button class="btn btn-secondary">
          <span id="music-button-text">STUDY MUSIC</span>
          <i id="music-icon" class="fa-solid fa-music"></i>
        </button>
        <div class="music-dropdown-content" id="music-dropdown-content">
          <a
            href="#"
            data-src="https://www.learningcontainer.com/wp-content/uploads/2020/02/Kalimba.mp3"
            >1. Coffee Shop Vibes</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3"
            >2. City Lights Lofi</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-15.mp3"
            >3. Mellow Thoughts</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-13.mp3"
            >4. Rainy Mood</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3"
            >5. Time Alone</a
          >
          <a href="#" id="stop-music-link"
            ><i class="fa-solid fa-stop-circle"></i> Stop Music</a
          >
        </div>
      </div>

      <button class="btn btn-secondary" id="resetProgressBtn">
        <i class="fas fa-redo"></i>
        Reset Progress
      </button>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal" style="display: none">
      <div class="modal-overlay"></div>
      <div class="modal-content">
        <span class="close" id="closeAuthModal">&times;</span>
        <div class="auth-tabs">
          <button id="tabSignIn" class="auth-tab active">Sign In</button>
          <button id="tabSignUp" class="auth-tab">Sign Up</button>
        </div>
        <div
          id="authLoader"
          style="display: none; text-align: center; padding: 2rem"
        >
          <i
            class="fas fa-spinner fa-spin fa-2x"
            style="color: var(--color-green)"
          ></i>
          <p style="margin-top: 0.5rem">Authenticating...</p>
        </div>
        <div id="signInForm" class="auth-form">
          <h2>Sign In to CipherHall</h2>
          <button id="googleSignIn" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignInForm">
            <input
              type="email"
              id="signInEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signInPassword"
              placeholder="Password"
              required
            />
            <button type="submit" class="btn btn-primary">Sign In</button>
          </form>
        </div>
        <div id="signUpForm" class="auth-form" style="display: none">
          <h2>Join CipherHall</h2>
          <button id="googleSignUp" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignUpForm">
            <input
              type="text"
              id="signUpName"
              placeholder="Full Name"
              required
            />
            <input
              type="email"
              id="signUpEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signUpPassword"
              placeholder="Password (min. 8 characters)"
              required
            />
            <button type="submit" class="btn btn-secondary">
              Create Account
            </button>
          </form>
        </div>
        <div id="authMessage"></div>
      </div>
    </div>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="course-info">
          <h1 class="course-title" id="courseTitle">Loading...</h1>
          <div class="course-progress">
            <div class="progress-header">
              <span class="progress-label">Course Progress</span>
              <span class="progress-percentage" id="courseProgressPercent"
                >0%</span
              >
            </div>
            <div class="progress-bar">
              <div
                class="progress-fill"
                id="courseProgressFill"
                style="width: 0%"
              ></div>
            </div>
            <div class="progress-stats">
              <span id="completedLessons">0</span>
              <span id="totalLessons">0</span>
            </div>
          </div>
          <a href="/dashboard.html" class="back-to-dashboard">
            <i class="fas fa-arrow-left"></i>
            Back to Dashboard
          </a>
        </div>
      </div>

      <nav class="lesson-nav" id="lessonNav">
        <!-- Lessons will be loaded dynamically -->
      </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <header class="content-header">
        <div class="lesson-header">
          <div class="lesson-header-left">
            <span class="lesson-number" id="currentLessonNumber">1</span>
            <h1 class="lesson-header-title" id="currentLessonTitle">
              Loading...
            </h1>
          </div>
          <div class="lesson-actions">
            <button class="mbtn btn-primary" id="menuToggle">
              <i class="fas fa-bars"></i>
            </button>
          </div>
        </div>
      </header>

      <div class="content-body" id="contentBody">
        <div class="lesson-content" id="lessonContent">
          <!-- Lesson content will be loaded dynamically -->
        </div>
      </div>

      <footer class="lesson-navigation">
        <div class="nav-info" id="navInfo">Lesson 1 of 10</div>
        <div class="nav-controls">
          <button class="btn btn-secondary" id="prevLessonBtn" disabled>
            <i class="fas fa-chevron-left"></i>
            Previous
          </button>
          <button class="btn btn-primary" id="nextLessonBtn" disabled>
            Next
            <i class="fas fa-chevron-right"></i>
          </button>
        </div>
      </footer>
    </main>

    <!-- Achievement Notification -->
    <div id="achievementNotification" class="achievement-notification">
      <div class="notification-header">
        <div class="notification-icon" id="notificationIcon">
          <i class="fas fa-trophy"></i>
        </div>
        <div class="notification-content">
          <h3 id="notificationTitle">Achievement Unlocked!</h3>
          <p id="notificationDescription">Description here...</p>
        </div>
      </div>
      <div class="notification-reward" id="notificationReward">
        <i class="fas fa-coins"></i>
        <span id="notificationPoints">+100 Points</span>
      </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast">
      <span id="toastMessage"></span>
    </div>

    <script>
      // =====================================================
      // SYNCHRONIZED COURSE SYSTEM WITH DASHBOARD INTEGRATION
      // =====================================================

      // Supabase Configuration - Replace with your config
      const supabaseUrl = "https://lzcmzulemfubjaksoqor.supabase.co";
      const supabaseKey =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx6Y216dWxlbWZ1Ympha3NvcW9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzMzM5MDgsImV4cCI6MjA3MDkwOTkwOH0.crhPH4YWtRsr1BJTpAQcmPbWSpwIWRbzoI4sRb2_fPI";
      const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

      // =====================================================
      // COURSE DATA STRUCTURE - REPLACE WITH YOUR COURSE JSON
      // =====================================================
      const COURSE_DATA = {
    "id": "malware-analysis-introduction-safe-expanded",
    "title": "Malware Analysis Introduction (Expanded)",
    "description": "An introductory course focused on the ethical and safe analysis of malware for defensive purposes. All labs use benign or synthetic samples in a controlled environment, emphasizing blue-team skills, safe techniques, and the protection of systems. This expanded version includes more detailed explanations and numerous real-world code examples for defensive analysis.",
    "category": "cybersecurity",
    "difficulty": "Beginner to Intermediate",
    "duration": "40 hours",
    "instructor": "Dr. Chen Wei",
    "lessons": [
        {
            "id": "lesson-1",
            "title": "Ethics, Legality & Lab Safety",
            "duration": "90 min",
            "objectives": [
                "Understand the legal and ethical responsibilities of a malware analyst.",
                "Learn the principles of safe sample handling and chain of custody.",
                "Design a secure, isolated laboratory environment using virtualization.",
                "Differentiate between the safety trade-offs of virtual machines vs. bare-metal analysis systems."
            ],
            "content": {
                "overview": "Before analyzing any potentially malicious code, a strict foundation of safety and ethics is paramount. This lesson covers the rules of engagement, how to handle samples responsibly, and the critical steps for building an isolated lab environment to prevent accidental infection.",
                "sections": [
                    {
                        "title": "Legal and Ethical Framework",
                        "content": "<p>Malware analysis must only be performed on samples you are authorized to possess and in an environment you own and control. Reverse engineering software may be subject to legal restrictions, and sharing samples requires care to avoid causing harm. The primary goal is always defense, not the creation or propagation of malicious code. We will discuss the importance of intent and how it separates an ethical defender from a malicious actor.</p>"
                    },
                    {
                        "title": "The Analysis Laboratory",
                        "content": "<p>A secure lab is the most important tool for an analyst. It is a controlled environment designed to contain the malware and prevent it from escaping to your network or the internet.</p><h3>Key Lab Concepts:</h3><ul><li><strong>Air-Gapped vs. Isolated:</strong> An air-gapped system has no physical connection to any other network. A virtually isolated lab uses software (like a host-only network in a VM) to prevent outside access. For most analysis, virtual isolation is sufficient and more flexible.</li><li><strong>Virtual Machines (VMs):</strong> VMs are essential. They allow you to run the malware in a sandboxed OS. With 'snapshots', you can instantly revert the entire system to a clean state after an analysis, erasing any changes the malware made.</li><li><strong>Bare Metal:</strong> In rare cases, some advanced malware can detect VMs. For these, a dedicated, physically separate 'bare-metal' machine that can be re-imaged after each analysis is used. This is an advanced and less common setup.</li></ul>"
                    }
                ],
                "activities": [
                    {
                        "title": "Set Up a Virtual Machine Analysis Lab",
                        "description": "Install virtualization software (like VirtualBox or VMware Workstation Player). Create a new Windows virtual machine. Configure its network adapter to 'Host-only' to isolate it from your home network and the internet. Take a 'clean' snapshot of the fresh installation."
                    },
                    {
                        "title": "Draft a Safety Standard Operating Procedure (SOP)",
                        "description": "Write a short checklist of safety rules for your lab. Include steps like 'Disconnect from the internet before analysis,' 'Take a clean snapshot before running a sample,' 'Document all steps,' and 'Revert to clean snapshot after analysis.'"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary purpose of using a virtual machine (VM) for malware analysis?",
                        "options": ["To make the malware run faster.", "To provide a sandboxed environment that can be easily reverted to a clean state, containing the malware.", "To share the malware with others easily.", "To get technical support from the malware authors."],
                        "correct": 1,
                        "explanation": "VMs provide containment and the ability to use snapshots, which is critical for safely and efficiently analyzing malware without risking the host machine."
                    },
                    {
                        "id": 2,
                        "question": "An 'air-gapped' analysis lab is one that:",
                        "options": ["Has a very fast internet connection.", "Has no physical connection to any other network.", "Runs on a laptop.", "Is stored in the cloud."],
                        "correct": 1,
                        "explanation": "An air gap is a physical separation from other networks, providing the highest level of isolation."
                    }
                ]
            }
        },
        {
            "id": "lesson-2",
            "title": "Malware Landscape Overview",
            "duration": "75 min",
            "objectives": [
                "Define and differentiate major malware families like viruses, worms, trojans, and ransomware.",
                "Understand the function of spyware, adware, and Remote Access Trojans (RATs).",
                "Identify common distribution methods such as phishing, drive-by downloads, and software bundles.",
                "Recognize the motivations behind different types of malware."
            ],
            "content": {
                "overview": "To defend against malware, you must first understand the adversary. This lesson provides a high-level overview of the modern malware landscape, categorizing different types of threats by their behavior, propagation methods, and objectives.",
                "sections": [
                    {
                        "title": "Major Malware Families",
                        "content": "<ul><li><strong>Virus:</strong> A program that attaches itself to a legitimate file or program. It requires human intervention (like running the host file) to spread.</li><li><strong>Worm:</strong> A standalone program that can replicate and spread across a network automatically, without human help, by exploiting vulnerabilities.</li><li><strong>Trojan:</strong> Disguises itself as a legitimate program but contains a hidden malicious payload. It tricks the user into running it.</li><li><strong>Ransomware:</strong> Encrypts a victim's files and demands a ransom payment for the decryption key.</li><li><strong>Remote Access Trojan (RAT):</strong> Gives an attacker covert remote control over the victim's computer.</li><li><strong>Spyware/Infostealer:</strong> Covertly gathers information from a user's computer, such as keystrokes, passwords, and browsing history.</li></ul>"
                    },
                    {
                        "title": "Infection Vectors",
                        "content":"<p>Malware needs a way to get onto a system. Common methods include:</p><ul><li><strong>Phishing:</strong> An email with a malicious attachment or a link to a malicious website.</li><li><strong>Drive-by Download:</strong> A user visits a compromised website, and malware is downloaded and run automatically by exploiting a browser vulnerability.</li><li><strong>Malvertising:</strong> Malicious code is hidden in online ads.</li><li><strong>Software Bundling:</strong> Unwanted or malicious software is bundled with a legitimate software installer.</li></ul>"
                    }
                ],
                "activities": [
                    {
                        "title": "Create a Malware Mind Map",
                        "description": "Using diagramming software or pen and paper, create a mind map. Start with 'Malware' in the center. Branch out to the major families (Virus, Worm, Trojan, etc.). For each family, add branches for its key characteristic and a common distribution vector (e.g., Trojan -> Disguised as game -> Phishing email)."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "A piece of malware that spreads automatically across a network by exploiting a vulnerability is called a:",
                        "options": ["Virus", "Trojan", "Worm", "Spyware"],
                        "correct": 2,
                        "explanation": "The key characteristic of a worm is its ability to self-propagate across networks without needing a host file or user interaction."
                    },
                    {
                        "id": 2,
                        "question": "Malware that encrypts your files and demands payment to unlock them is known as:",
                        "options": ["Adware", "A rootkit", "A RAT", "Ransomware"],
                        "correct": 3,
                        "explanation": "Ransomware's primary payload is data encryption for the purpose of financial extortion."
                    }
                ]
            }
        },
        {
            "id": "lesson-3",
            "title": "Setting Up the Analysis Lab",
            "duration": "120 min",
            "objectives": [
                "Install and configure virtualization software like VirtualBox or VMware.",
                "Set up network simulation tools like INetSim to safely intercept malware network traffic.",
                "Install essential monitoring tools like Process Monitor, Wireshark, and Regshot.",
                "Create a repeatable workflow for preparing the lab for a new sample."
            ],
            "content": {
                "overview": "This lesson is a hands-on guide to building the core components of your malware analysis lab. We will install the necessary software and configure it to create a safe, observable environment where we can execute and monitor benign samples without risk.",
                "sections": [
                    {
                        "title": "Core Lab Components",
                        "content": "<ul><li><strong>Virtualization:</strong> VMware Workstation/Player or Oracle VirtualBox are the industry standards for creating the analysis VM.</li><li><strong>Network Simulation:</strong> A tool like INetSim is crucial. It acts as a fake internet, responding to DNS queries, HTTP requests, etc. This lets you observe the malware's network activity without it actually connecting to the real internet.</li><li><strong>Monitoring Tools:</strong> We will install a suite of tools on our analysis VM to watch its behavior:<ul><li><strong>Process Monitor (ProcMon):</strong> Records all file system, registry, and process activity.</li><li><strong>Wireshark:</strong> Captures all network traffic for later analysis.</li><li><strong>Regshot:</strong> Takes snapshots of the registry before and after running a sample to easily see what changed.</li></ul></li></ul>"
                    },
                    {
                        "title": "Lab Workflow",
                        "content": "<p>A disciplined workflow is essential for good analysis and safety. Every analysis should follow the same steps: 1. Revert to clean snapshot. 2. Transfer sample. 3. Start network and host monitoring. 4. Run sample. 5. Observe and document. 6. Stop monitoring. 7. Revert to clean snapshot. This ensures no cross-contamination between samples.</p>"
                    }
                ],
                "activities": [
                    {
                        "title": "Install and Configure a Full Lab VM",
                        "description": "Following a step-by-step guide, install Windows in a VM. Install Process Monitor, Wireshark, and other key tools. Configure a separate Linux VM with INetSim and set it as the DNS server for the Windows VM. Test that the Windows VM can 'browse' to fake websites hosted by INetSim."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the purpose of a tool like INetSim in a malware analysis lab?",
                        "options": ["To give the malware a real, high-speed internet connection.", "To simulate common internet services (DNS, HTTP, etc.) so the analyst can observe the malware's network behavior without connecting it to the live internet.", "To scan the malware for viruses.", "To delete the malware after analysis."],
                        "correct": 1,
                        "explanation": "INetSim provides a safe way to trick malware into revealing its network intentions (like C2 domains or download URLs) by emulating the services it expects to find online."
                    },
                    {
                        "id": 2,
                        "question": "Which tool is best suited for monitoring file system and registry changes in real-time?",
                        "options": ["Wireshark", "Process Monitor (ProcMon)", "INetSim", "VirtualBox"],
                        "correct": 1,
                        "explanation": "Process Monitor is a powerful tool from Microsoft that provides a detailed, real-time log of process, file system, and registry activity, making it essential for behavioral analysis."
                    }
                ]
            }
        },
        {
            "id": "lesson-4",
            "title": "Static Analysis Basics (Strings & Metadata)",
            "duration": "90 min",
            "objectives": [
                "Understand the goal of static analysis (analyzing a file without running it).",
                "Learn the basics of the PE (Portable Executable) file format.",
                "Use the 'strings' utility to extract human-readable text from a binary.",
                "Use tools like `pefile` and YARA to parse headers and find suspicious patterns."
            ],
            "content": {
                "overview": "Static analysis is the first step in examining a suspicious file. It involves looking at the file's properties and content without executing any code. This is a very safe process that can yield valuable clues about the file's purpose and functionality, helping to guide the rest of the analysis.",
                "sections": [
                    {
                        "title": "The PE File Format",
                        "content": "<p>Windows executables (.exe, .dll) use the Portable Executable (PE) format. This format contains headers with metadata about the program, such as when it was compiled, what functions it imports from other libraries (e.g., `CreateFileW`, `InternetOpenUrlA`), and where the program's code starts (the Entry Point). Analyzing these imports can give strong hints about the file's capabilities. For example, a program importing network functions is likely to connect to the internet.</p>"
                    },
                    {
                        "title": "Strings Analysis",
                        "content": "<p>The `strings` utility scans a binary file and prints out any sequence of printable characters. This is a simple but powerful technique. The output can reveal hardcoded IP addresses, domain names, file paths, registry keys, or error messages that hint at the program's capabilities. It can also sometimes reveal code snippets or names of attacker tools.</p>"
                    },
                    {
                        "title": "Introduction to YARA",
                        "content": "<p>YARA is a tool designed to help malware researchers identify and classify malware samples. It allows you to create rules that look for certain characteristics, like specific strings or binary patterns. Defenders use YARA to create signatures for new malware families, allowing them to hunt for those threats across their organization.</p>"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Extract File Hashes",
                        "language": "python",
                        "code": "# This defensive script calculates the cryptographic hashes of a file.\n# Hashes are the primary way to uniquely identify a file.\nimport hashlib\ndef get_hashes(file_path):\n    try:\n        with open(file_path, 'rb') as f:\n            data = f.read()\n            print(f'MD5:    {hashlib.md5(data).hexdigest()}')\n            print(f'SHA1:   {hashlib.sha1(data).hexdigest()}')\n            print(f'SHA256: {hashlib.sha256(data).hexdigest()}')\n    except FileNotFoundError:\n        print(f'File not found: {file_path}')\n\n# Usage on a benign system file you are authorized to analyze\nget_hashes('C:\\\\Windows\\\\System32\\\\calc.exe')"
                    },
                    {
                        "title": "Parse PE Imports with pefile",
                        "language": "python",
                        "code": "# This script uses the 'pefile' library to list all imported DLLs and functions.\n# This helps a defender understand the capabilities of an executable without running it.\nimport pefile\ndef list_imports(file_path):\n    try:\n        pe = pefile.PE(file_path)\n        print(f'--- Imports for {file_path} ---')\n        for entry in pe.DIRECTORY_ENTRY_IMPORT:\n            print(f'[+] {entry.dll.decode()}')\n            for imp in entry.imports:\n                print(f'  - {imp.name.decode(errors=\"ignore\")}')\n    except pefile.PEFormatError:\n        print('Not a valid PE file.')\n    except FileNotFoundError:\n        print(f'File not found: {file_path}')\n\n# Usage on a benign system file\nlist_imports('C:\\\\Windows\\\\System32\\\\kernel32.dll')"
                    },
                    {
                        "title": "Find Suspicious Strings with Regex",
                        "language": "python",
                        "code": "# This script opens a binary file safely and searches for patterns like IP addresses and domains.\n# This is a safe, automated way to perform basic strings analysis.\nimport re\ndef find_suspicious_strings(file_path):\n    ip_pattern = re.compile(b'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}')\n    domain_pattern = re.compile(b'[a-zA-Z0-9.-]+\\.(com|org|net|ru|biz)')\n    try:\n        with open(file_path, 'rb') as f:\n            data = f.read()\n            print(f'--- Network Indicators in {file_path} ---')\n            print('IPs found:', [ip.decode() for ip in ip_pattern.findall(data)])\n            print('Domains found:', [d.decode() for d in domain_pattern.findall(data)])\n    except FileNotFoundError:\n        print(f'File not found: {file_path}')\n\n# Usage on a benign sample\nfind_suspicious_strings('C:\\\\Windows\\\\System32\\\\drivers\\\\etc\\\\hosts')"
                    },
                    {
                        "title": "Simple YARA Rule for Suspicious Imports",
                        "language": "yara",
                        "code": "/*\nThis is a simple YARA rule. YARA is a tool for pattern matching. This rule looks\nfor executables that import functions commonly used by malware droppers.\nDefenders use YARA to hunt for malicious files across their systems.\n*/\nrule Suspicious_Imports_Dropper\n{\n    meta:\n        author = \"Ethical Analyst\"\n        description = \"Detects imports often used to download and execute files.\"\n    condition:\n        // Check for the presence of specific function names in the import table\n        pe.imports(\"urlmon.dll\", \"URLDownloadToFileA\") and\n        pe.imports(\"kernel32.dll\", \"WinExec\")\n}"
                    }
                ],
                "activities": [
                    {
                        "title": "Analyze a Benign PE Sample",
                        "description": "Using a benign executable like `putty.exe` or `7z.exe`, run the provided Python scripts against it. Document the compile time, imported functions, and any interesting strings. Write a one-paragraph summary of what you think the program might do based only on this static analysis."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "Static analysis of malware involves:",
                        "options": ["Running the malware in a VM and observing its behavior.", "Analyzing the file's contents and properties without executing it.", "Letting an antivirus program scan the file.", "Deleting the file immediately."],
                        "correct": 1,
                        "explanation": "Static analysis is the examination of a file at rest, making it a very safe initial step."
                    },
                    {
                        "id": 2,
                        "question": "Looking at the 'imports' section of a PE file might reveal what?",
                        "options": ["The author of the malware.", "The target's email address.", "The Windows API functions the program intends to use, hinting at its capabilities.", "The malware's encryption key."],
                        "correct": 2,
                        "explanation": "The imports table lists functions from system DLLs that the program uses. For example, seeing imports like `URLDownloadToFile` and `CreateProcess` suggests the program can download and run other files."
                    }
                ]
            }
        },
        {
            "id": "lesson-5",
            "title": "Behavioral Analysis Basics",
            "duration": "120 min",
            "objectives": [
                "Understand the goal of behavioral (dynamic) analysis.",
                "Use Process Monitor to filter and identify significant system changes.",
                "Use Wireshark to capture and analyze network traffic from a running sample.",
                "Correlate events between different tools to build a picture of the malware's activity."
            ],
            "content": {
                "overview": "Behavioral analysis, also known as dynamic analysis, involves running the malware in our safe, controlled lab environment and observing what it does. This lesson is a hands-on introduction to using our monitoring tools to capture and interpret the actions of a running program.",
                "sections": [
                    {
                        "title": "The Dynamic Analysis Workflow",
                        "content": "<p>A typical dynamic analysis session follows these steps:</p><ol><li>Revert the VM to a clean snapshot.</li><li>Start all monitoring tools (ProcMon, Wireshark, Regshot 'before' snapshot).</li><li>Run the benign sample.</li><li>Interact with the program if necessary (e.g., click buttons).</li><li>Let it run for a few minutes.</li><li>Terminate the sample's process.</li><li>Stop the monitoring tools (Regshot 'after' snapshot and compare).</li><li>Begin analyzing the captured logs.</li></ol>"
                    },
                    {
                        "title": "Interpreting the Data",
                        "content": "<p>The key is to filter out the noise. A normal Windows system has thousands of background processes. The analyst's job is to set filters in tools like ProcMon to focus only on the activity of the malware process. We look for key events like creating files in unusual locations (e.g., `AppData`), modifying registry keys for persistence (e.g., `HKCU\\...\\Run`), or making suspicious network connections.</p>"
                    },
                    {
                        "title": "Correlation is Key",
                        "content": "<p>No single tool tells the whole story. The real skill is in correlating data. For example, you might see a DNS request for a domain in Wireshark, and at the same time, see ProcMon show the process writing a new file to disk. This suggests the process downloaded a file from that domain. Tying these events together builds the narrative of the attack.</p>"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "ProcMon Filter Configuration",
                        "language": "text",
                        "code": "# This is not code, but a representation of a filter set in Process Monitor.\n# This is a critical defensive skill to reduce noise and focus on a suspicious process.\n# To use, open ProcMon -> Filter -> Filter... and add these rules:\n\n# Rule 1: Include only the process of interest\n# Action: Include\n# Column: Process Name\n# Relation: is\n# Value: benign_sample.exe\n\n# Rule 2: Exclude normal, noisy operations\n# Action: Exclude\n# Column: Operation\n# Relation: is\n# Value: RegQueryValue"
                    },
                    {
                        "title": "Wireshark Display Filter",
                        "language": "text",
                        "code": "# This is a Wireshark display filter used by defenders to find C2 traffic.\n# It shows only DNS lookups and HTTP/HTTPS traffic, filtering out other noise.\n# To use, type this into the display filter bar at the top of the Wireshark window.\n\ndns or http or tls"
                    },
                    {
                        "title": "Parse ProcMon CSV Log for Dropped Files",
                        "language": "python",
                        "code": "# After running ProcMon, you can export its log to a CSV file.\n# This defensive script parses that CSV to find all files created by a process.\nimport csv\ndef find_created_files(procmon_csv_path, process_name):\n    created_files = set()\n    try:\n        with open(procmon_csv_path, 'r', encoding='utf-8') as f:\n            reader = csv.DictReader(f)\n            for row in reader:\n                if row['Process Name'] == process_name and row['Operation'] == 'CreateFile':\n                    created_files.add(row['Path'])\n        print(f'--- Files created by {process_name} ---')\n        for path in sorted(list(created_files)):\n            print(path)\n    except FileNotFoundError:\n        print(f'File not found: {procmon_csv_path}')\n\n# Usage after exporting a log from Process Monitor\n# find_created_files('procmon_log.csv', 'benign_installer.exe')"
                    },
                    {
                        "title": "Automate Registry Snapshot Comparison",
                        "language": "python",
                        "code": "# This script simulates the function of Regshot by comparing two text files\n# containing lists of registry keys (exported from `reg query HKEY_CURRENT_USER /s`).\n# Defenders use this to find persistence keys created by malware.\ndef compare_reg_snapshots(before_file, after_file):\n    try:\n        with open(before_file, 'r') as f:\n            before_keys = set(f.read().splitlines())\n        with open(after_file, 'r') as f:\n            after_keys = set(f.read().splitlines())\n        \n        added_keys = after_keys - before_keys\n        print('--- Registry Keys Added ---')\n        for key in sorted(list(added_keys)):\n            # A defender would focus on keys related to persistence\n            if 'CurrentVersion\\\\Run' in key:\n                print(f'[ALERT] Potential persistence key: {key}')\n            else:\n                print(key)\n    except FileNotFoundError:\n        print('Snapshot file not found.')\n\n# Usage: \n# 1. reg query HKEY_CURRENT_USER /s > before.txt\n# 2. Run sample\n# 3. reg query HKEY_CURRENT_USER /s > after.txt\n# 4. compare_reg_snapshots('before.txt', 'after.txt')"
                    }
                ],
                "activities": [
                    {
                        "title": "Analyze a Safe Test Application",
                        "description": "Using a benign software installer (like 7-Zip), perform a full dynamic analysis in your lab VM. Use Process Monitor to see which files it creates in 'Program Files'. Use Regshot to see what registry keys it adds. Use Wireshark to see if it makes any network connections to check for updates."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the first and most important step to take in your VM before running a new malware sample?",
                        "options": ["Update the antivirus software.", "Revert the VM to a clean, pre-analysis snapshot.", "Increase the VM's RAM.", "Check your email."],
                        "correct": 1,
                        "explanation": "Reverting to a clean snapshot ensures that your analysis is not contaminated by artifacts from previous samples and that you have a consistent starting point."
                    },
                    {
                        "id": 2,
                        "question": "If you wanted to see if a program was trying to communicate with a specific domain name, which tool would be most useful?",
                        "options": ["Regshot", "Process Monitor", "Wireshark", "PE Viewer"],
                        "correct": 2,
                        "explanation": "Wireshark captures all network traffic, including DNS requests and HTTP connections, making it the primary tool for network behavior analysis."
                    }
                ]
            }
        },
        {
            "id": "lesson-6",
            "title": "Windows Internals Primer",
            "duration": "90 min",
            "objectives": [
              "Understand the relationship between processes, threads, and handles.",
              "Learn the role of Dynamic-Link Libraries (DLLs) in Windows.",
              "Identify the purpose of key registry hives like HKLM and HKCU.",
              "Differentiate between user-mode and kernel-mode operations."
            ],
            "content": {
              "overview": "To understand how malware manipulates the operating system, you need a basic understanding of how that OS works. This lesson provides a high-level primer on key concepts of the Windows OS that are most relevant to malware analysis.",
              "sections": [
                {
                  "title": "Processes, Threads, and Handles",
                  "content": "<ul><li><strong>Process:</strong> A running instance of a program. It has its own private memory space.</li><li><strong>Thread:</strong> The basic unit of execution within a process. A process can have multiple threads.</li><li><strong>Handle:</strong> A reference to a system resource (like a file, a registry key, or another process) that a program has opened. Malware often manipulates handles to other processes for injection.</li></ul>"
                },
                {
                  "title": "DLLs and the Registry",
                  "content": "<ul><li><strong>DLLs (Dynamic-Link Libraries):</strong> Files containing shared code and data that can be used by multiple programs at once (e.g., `kernel32.dll`, `user32.dll`). Malware often uses or injects into legitimate DLLs.</li><li><strong>The Registry:</strong> A hierarchical database that stores low-level settings for the OS and applications. Malware frequently uses the registry to store its configuration data and to make itself run automatically at startup (persistence). Key hives include `HKEY_CURRENT_USER` (HKCU) for the current user and `HKEY_LOCAL_MACHINE` (HKLM) for system-wide settings.</li></ul>"
                }
              ],
              "codeExamples": [
                    {
                        "title": "List Processes and Parent Processes with PowerShell",
                        "language": "powershell",
                        "code": "# This PowerShell command is used by defenders for live system analysis.\n# It lists running processes and includes the Parent Process ID, which can help\n# identify suspicious process chains (e.g., winword.exe spawning powershell.exe).\nGet-CimInstance Win32_Process | Select-Object ProcessId, Name, ParentProcessId, CommandLine | Format-Table -AutoSize"
                    },
                    {
                        "title": "List Loaded DLLs for a Process with PowerShell",
                        "language": "powershell",
                        "code": "# This command helps a defender see which shared libraries a running process is using.\n# Malware often loads surprising DLLs into legitimate processes.\n# Replace 'notepad' with the process name you want to inspect.\n(Get-Process -Name notepad).Modules | Select-Object ModuleName, FileName"
                    },
                    {
                        "title": "Query a Registry Run Key with PowerShell",
                        "language": "powershell",
                        "code": "# Defenders use this command to check one of the most common malware persistence locations.\n# This command lists all programs set to run automatically for the current user.\nGet-ItemProperty -Path 'HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Run' "
                    },
                    {
                        "title": "List Running Services with Python",
                        "language": "python",
                        "code": "# This cross-platform Python script uses the psutil library for live system inspection.\n# A defender might use this to hunt for suspicious services created by malware.\nimport psutil\ndef list_services():\n    print('--- Running Services ---')\n    for service in psutil.win_service_iter():\n        info = service.as_dict()\n        # A defender might filter for services that are not from Microsoft or are in a stopped state but set to auto-start.\n        if info['status'] == 'running':\n            print(f\"Name: {info['name']}, Status: {info['status']}, Start: {info['start_type']}\")\n\nlist_services()"
                    }
              ],
              "activities": [
                {
                  "title": "Diagram the Lifecycle of a Windows Process",
                  "description": "Create a flowchart that illustrates the creation of a Windows process, from the user double-clicking an EXE, to the OS loading it into memory, loading its imported DLLs, and creating its primary thread."
                }
              ]
            },
            "quiz": {
              "passingScore": 80,
              "questions": [
                {
                  "id": 1,
                  "question": "What is a DLL (Dynamic-Link Library)?",
                  "options": ["A type of malware.", "A file containing shared code that can be used by multiple executables.", "A log file.", "A temporary file created by the operating system."],
                  "correct": 1,
                  "explanation": "DLLs are a fundamental part of Windows, providing shared functionality that prevents every program from having to reinvent the wheel."
                },
                {
                  "id": 2,
                  "question": "Malware often modifies registry keys in `HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run` for what purpose?",
                  "options": ["To crash the computer.", "To achieve persistence, making the malware run automatically every time the user logs in.", "To delete user files.", "To change the desktop wallpaper."],
                  "correct": 1,
                  "explanation": "The 'Run' keys in the registry are one of the most common and oldest techniques used by malware to ensure it survives a reboot."
                }
              ]
            }
        },
        {
            "id": "lesson-7",
            "title": "Dynamic Analysis Tools",
            "duration": "90 min",
            "objectives": [
              "Understand the concept and benefits of an automated sandbox.",
              "Differentiate between manual analysis and automated sandbox analysis.",
              "Learn to interpret the key sections of a sandbox report (network, file, registry activity).",
              "Recognize the limitations of automated sandboxing."
            ],
            "content": {
              "overview": "While manual dynamic analysis provides deep insight, it can be time-consuming. Automated sandboxes are tools that take a sample, run it in a pre-configured and instrumented environment, and automatically generate a report of its behavior. This lesson introduces the concept of sandboxing and how to interpret the results.",
              "sections": [
                {
                  "title": "What is a Sandbox?",
                  "content": "<p>In malware analysis, a sandbox is an automated system that executes a file in an isolated and monitored environment. It records all the actions the file takes and presents them in a structured report. This allows analysts to quickly triage a large number of samples to identify the most interesting ones for deeper manual analysis.</p>"
                },
                {
                  "title": "Interpreting a Sandbox Report",
                  "content": "<p>A typical sandbox report is divided into sections:</p><ul><li><strong>Static Information:</strong> File hashes, PE information, strings.</li><li><strong>Behavioral Summary:</strong> A high-level overview of suspicious activities, often mapped to MITRE ATT&CK techniques.</li><li><strong>Process Tree:</strong> A visual representation of which processes were created by the sample.</li><li><strong>Network Activity:</strong> A list of all DNS queries, HTTP requests, and other network connections.</li><li><strong>File System Activity:</strong> A list of all files created, modified, or deleted.</li><li><strong>Registry Activity:</strong> A list of all registry keys created, modified, or deleted.</li></ul>"
                }
              ],
              "codeExamples": [
                {
                    "title": "Query VirusTotal API for a File Hash",
                    "language": "python",
                    "code": "# Defenders use the VirusTotal API for quick, passive reconnaissance on a file hash.\n# This tells you if the broader security community has already identified the file as malicious.\nimport requests\n\nAPI_KEY = 'YOUR_VT_API_KEY' # Get a free key from the VirusTotal website\nFILE_HASH = '84c82835a5d21bbcf75a61706d8ab549' # Example MD5 for benign EICAR test file\n\ndef query_virustotal(api_key, file_hash):\n    url = f'https://www.virustotal.com/api/v3/files/{file_hash}'\n    headers = {'x-apikey': api_key}\n    response = requests.get(url, headers=headers)\n    if response.status_code == 200:\n        data = response.json()['data']['attributes']\n        detections = data['last_analysis_stats']['malicious']\n        total = data['last_analysis_stats']['harmless'] + detections\n        print(f\"Detections: {detections}/{total}\")\n    else:\n        print(f\"Error: {response.status_code} - {response.text}\")\n\n# query_virustotal(API_KEY, FILE_HASH)"
                },
                {
                    "title": "Parse Sandbox JSON Report for IOCs",
                    "language": "python",
                    "code": "# Sandboxes often produce a JSON report. This script shows how a defender would\n# parse this report to programmatically extract key indicators of compromise.\nimport json\ndef parse_sandbox_report(json_path):\n    try:\n        with open(json_path, 'r') as f:\n            report = json.load(f)\n            # This structure is hypothetical and varies by sandbox\n            network_info = report.get('network', {})\n            dropped_files = report.get('behavior', {}).get('dropped', [])\n            print('--- IOCs from Sandbox Report ---')\n            print('Contacted Domains:', [d['domain'] for d in network_info.get('domains', [])])\n            print('Dropped Files:', [f['filepath'] for f in dropped_files])\n    except (FileNotFoundError, json.JSONDecodeError):\n        print(f'Could not open or parse {json_path}')\n\n# Usage:\n# parse_sandbox_report('cuckoo_report.json')"
                },
                {
                    "title": "Check for Common VM Artifacts with PowerShell",
                    "language": "powershell",
                    "code": "# Malware often checks for signs of a VM. Defenders can run these same checks\n# to understand what the malware might be looking for.\n$vmServices = Get-Service | Where-Object { $_.Name -like '*VBox*' -or $_.Name -like '*VMTools*' }\n$vmProcesses = Get-Process | Where-Object { $_.ProcessName -like '*VBox*' -or $_.ProcessName -like '*vmtoolsd*' }\n\nif ($vmServices -or $vmProcesses) {\n    Write-Host \"[ALERT] VM-related services or processes detected.\"\n} else {\n    Write-Host \"[INFO] No common VM artifacts found.\"\n}"
                },
                {
                    "title": "YARA Rule to Detect Sandbox-Aware Strings",
                    "language": "yara",
                    "code": "/*\nThis YARA rule is used by defenders to find files that might have anti-analysis tricks.\nIt searches for strings that reference common VM products or analysis tools.\n*/\nrule Detect_AntiVM_Strings\n{\n    strings:\n        $vmware = \"VMware\"\n        $vbox = \"VirtualBox\"\n        $qemu = \"QEMU\"\n        $sandbox = \"sandbox\"\n    condition:\n        any of them\n}"
                }
              ],
              "activities": [
                {
                  "title": "Analyze a Sandbox Report",
                  "description": "Using a public sandbox service like Any.Run or a local Cuckoo Sandbox instance, submit a benign sample (e.g., the PuTTY executable). Analyze the resulting report. Identify the process it created, the registry keys it accessed, and any network connections it made."
                }
              ]
            },
            "quiz": {
              "passingScore": 80,
              "questions": [
                {
                  "id": 1,
                  "question": "What is the primary advantage of using an automated sandbox for malware analysis?",
                  "options": ["It is always more accurate than manual analysis.", "It is much faster for triaging a large number of samples by automatically executing and reporting on their behavior.", "It can analyze any type of file, including non-executable files.", "It provides a legal opinion on the malware."],
                  "correct": 1,
                  "explanation": "Speed and automation are the key benefits of sandboxing, allowing an analyst to quickly get a behavioral overview of many files."
                },
                {
                  "id": 2,
                  "question": "A limitation of automated sandboxing is that:",
                  "options": ["It is too slow.", "It cannot capture network traffic.", "Advanced malware may detect it is in a sandbox and refuse to run its malicious payload.", "It requires a supercomputer to run."],
                  "correct": 2,
                  "explanation": "Many modern malware families have anti-sandbox and anti-VM techniques to evade automated analysis, which is why manual analysis is still a critical skill."
                }
              ]
            }
        },
        {
            "id": "lesson-8",
            "title": "Packing & Obfuscation",
            "duration": "90 min",
            "objectives": [
              "Define packing and understand its purpose (to hide code and evade signatures).",
              "Understand the concept of file entropy and how it can indicate packing.",
              "Recognize common packing tools like UPX.",
              "Learn the basic theory of unpacking (running the packed file and dumping the original code from memory)."
            ],
            "content": {
              "overview": "Malware authors don't want their creations to be easily analyzed. They use techniques like packing and obfuscation to hide the true nature of their code. This lesson introduces these concepts and teaches you how to identify when a file has been packed.",
              "sections": [
                {
                  "title": "What is Packing?",
                  "content": "<p>A packer is a tool that takes an executable file, compresses or encrypts it, and wraps it inside another small executable 'stub'. When the packed file is run, the stub code runs first, unpacks the original program into memory, and then transfers execution to it. Malware authors use this to evade antivirus signatures, which are often based on the original, unpacked code.</p>"
                },
                {
                  "title": "Detecting Packing with Entropy",
                  "content": "<p>Entropy is a measure of randomness. Normal compiled code has a relatively low entropy, while compressed or encrypted data is very close to random and has a high entropy. A file with very high entropy (e.g., > 7.0 on a scale of 0-8) is very likely packed. Packers also tend to have very few imported functions, as only the unpacking stub's imports are visible statically.</p>"
                }
              ],
              "codeExamples": [
                {
                  "title": "Calculate Shannon Entropy of a File",
                  "language": "python",
                  "code": "# This defensive script calculates the entropy of a file to help identify packed executables.\n# High entropy is a strong indicator that a file is compressed or encrypted.\nimport math\nfrom collections import Counter\n\ndef calculate_shannon_entropy(file_path):\n    \"\"\"Calculates the Shannon entropy of the data in a file.\"\"\"\n    try:\n        with open(file_path, \"rb\") as f:\n            data = f.read()\n    except FileNotFoundError:\n        print(f\"Error: File '{file_path}' not found.\")\n        return\n\n    if not data:\n        return 0.0\n    byte_counts = Counter(data)\n    file_len = len(data)\n    probabilities = [count / file_len for count in byte_counts.values()]\n    entropy = -sum(p * math.log2(p) for p in probabilities)\n    \n    print(f\"Shannon Entropy of '{file_path}': {entropy:.4f}\")\n    if entropy > 7.2:\n        print(\"[INFO] Entropy is high. The file is likely packed or encrypted.\")\n    else:\n        print(\"[INFO] Entropy is in the normal range for an executable.\")\n\n# Usage: Analyze a known-safe, non-packed file\ncalculate_shannon_entropy(\"C:\\\\Windows\\\\System32\\\\notepad.exe\")"
                },
                 {
                    "title": "Detect Packing with pefile",
                    "language": "python",
                    "code": "# This script uses pefile to look for common signs of packing.\n# Defenders use these heuristics to quickly flag suspicious files for deeper analysis.\nimport pefile\ndef check_packing_heuristics(file_path):\n    try:\n        pe = pefile.PE(file_path)\n        # Heuristic 1: Very few imported DLLs\n        if len(pe.DIRECTORY_ENTRY_IMPORT) < 2:\n            print('[ALERT] Very few imports, might be packed.')\n        # Heuristic 2: Section names common to packers\n        packer_sections = ['UPX0', 'UPX1', '.aspack']\n        for section in pe.sections:\n            if section.Name.decode().strip('\\x00') in packer_sections:\n                print(f'[ALERT] Found common packer section name: {section.Name.decode()}')\n    except Exception as e:\n        print(f'Could not analyze file: {e}')\n\n# Usage:\n# check_packing_heuristics('path/to/benign_packed_sample.exe')"
                },
                {
                    "title": "YARA Rule for UPX Packer",
                    "language": "yara",
                    "code": "/*\nThis YARA rule is a more reliable way to detect files packed with UPX,\n a very common packer. It looks for specific byte sequences (magic numbers)\n and section names that are characteristic of UPX.\n*/\nrule Detect_UPX_Packer\n{\n    strings:\n        $entry_stub = { E8 [4] FF E0 55 89 E5 }\n        $section1 = \"UPX0\"\n        $section2 = \"UPX1\"\n    condition:\n        $entry_stub at pe.entry_point and $section1 and $section2\n}"
                },
                {
                    "title": "Compare File Size vs. Virtual Size with PowerShell",
                    "language": "powershell",
                    "code": "# This command compares the size of a PE section on disk vs. its size in memory.\n# Packers often have a small section on disk that expands to a large size in memory.\n# A large discrepancy is a sign of packing.\n# (Requires a third-party module like PeNet, for demonstration of the concept)\n# Install-Module -Name PeNet -Scope CurrentUser\n# $peFile = Get-PeFile -Path C:\\Windows\\System32\\kernel32.dll\n# $peFile.ImageSectionHeaders | Select-Object Name, SizeOfRawData, VirtualSize"
                }
              ],
              "activities": [
                {
                  "title": "Compare Packed vs. Unpacked Binaries",
                  "description": "Using a benign, packable executable (like putty.exe) and the UPX packer, create a packed version. Run the analysis scripts (entropy, pefile) on both the original and packed versions. Document the differences in entropy, file size, and the number of visible imports."
                }
              ]
            },
            "quiz": {
              "passingScore": 80,
              "questions": [
                {
                  "id": 1,
                  "question": "Why do malware authors use packers?",
                  "options": ["To make their files larger.", "To hide their code from static analysis and evade signature-based antivirus detection.", "To make their programs run faster.", "To add a graphical user interface."],
                  "correct": 1,
                  "explanation": "Packing is an anti-analysis technique. The primary goal is to obfuscate the original malicious code so that security tools and analysts can't easily see what it does."
                },
                {
                  "id": 2,
                  "question": "A high Shannon entropy score for an executable file suggests that the file is:",
                  "options": ["Old.", "Not malicious.", "Likely compressed or encrypted (i.e., packed).", "A text file."],
                  "correct": 2,
                  "explanation": "Entropy measures randomness. Since compressed and encrypted data is highly random, a high entropy is a very strong indicator that a file has been packed."
                }
              ]
            }
        },
        {
            "id": "lesson-9",
            "title": "Reverse Engineering Basics",
            "duration": "120 min",
            "objectives": [
                "Differentiate between disassembly and decompilation.",
                "Understand the basic concepts of x86 assembly language (registers, instructions).",
                "Navigate a simple, benign binary in a disassembler like Ghidra or IDA Free.",
                "Identify the 'main' function or starting point of a program's logic."
            ],
            "content": {
                "overview": "Reverse engineering is the process of deconstructing a program to understand its inner workings. While it is a deep and complex topic, this lesson provides a gentle introduction to the fundamental tools and concepts, using a simple, benign program as our target.",
                "sections": [
                    {
                        "title": "Disassembly vs. Decompilation",
                        "content": "<ul><li><strong>Disassembler:</strong> A tool that translates a program's machine code (binary 1s and 0s) into human-readable assembly language instructions. This is a direct, one-to-one translation.</li><li><strong>Decompiler:</strong> A more advanced tool that attempts to reverse the compilation process further, translating the assembly code into a high-level language like C or C++. This reconstructed code is easier to read but is not always perfect.</li></ul>"
                    },
                    {
                        "title": "Tools of the Trade: Ghidra and IDA",
                        "content": "<p>Ghidra (developed and released by the NSA) and IDA Pro (with its free version) are the two leading tools for reverse engineering. They combine a disassembler, a decompiler, and many other analysis features into a powerful interface that allows an analyst to explore and understand a program's code.</p>"
                    },
                    {
                        "title": "Basic x86 Assembly",
                        "content": "<p>A few key concepts to start: </p><ul><li><strong>Registers:</strong> Small storage locations within the CPU (e.g., EAX, EBX, ECX, EDX).</li><li><strong>Instructions:</strong> Operations the CPU can perform (e.g., `MOV` to move data, `ADD` to add, `JMP` to jump to another code location, `CALL` to call a function).</li><li><strong>Stack:</strong> A memory area used to store temporary data, function arguments, and return addresses.</li></ul>"
                    }
                ],
                "codeExamples":[
                    {
                        "title": "Simple C 'Hello World' for Analysis",
                        "language": "c",
                        "code": "// This is a simple, benign C program. Defenders compile this themselves to create a\n// known-safe executable. They then load this into a tool like Ghidra to learn how a\n// simple program is represented in assembly and decompiled code without the complexity of malware.\n\n#include <stdio.h>\n\nint main() {\n    printf(\"Hello, Analyst!\\n\");\n    return 0;\n}"
                    },
                    {
                        "title": "Example x86 Assembly (from the C code)",
                        "language": "asm",
                        "code": "; This is a simplified representation of what a disassembler would show for the C code.\n; It demonstrates key assembly instructions.\n\n_main:\n    push    ebp          ; Set up the stack frame\n    mov     ebp, esp\n    push    offset aHelloAnalyst ; Push the address of the string \"Hello, Analyst!\" onto the stack\n    call    _printf      ; Call the printf function\n    add     esp, 4         ; Clean up the stack\n    xor     eax, eax     ; Set return value to 0\n    pop     ebp          ; Restore the stack frame\n    ret                  ; Return from the function"
                    },
                    {
                        "title": "Example Decompiled Code (from Ghidra)",
                        "language": "c",
                        "code": "/* \nThis is what Ghidra's decompiler might produce when analyzing the assembly.\nFor a defender, this is much easier to read and understand than the raw assembly.\nIt clearly shows that the program's main purpose is to call the `printf` function.\n*/\n\nundefined4 main(void)\n\n{\n  printf(\"Hello, Analyst!\\n\");\n  return 0;\n}"
                    },
                    {
                        "title": "Ghidra Scripting Skeleton (Jython)",
                        "language": "python",
                        "code": "# Ghidra supports scripting to automate analysis. A defender might write a script\n# to find all references to a suspicious API call across a large binary.\n# This is an advanced technique.\n\n# from ghidra.app.decompiler import DecompInterface\n# from ghidra.util.task import ConsoleTaskMonitor\n\n# def find_xrefs_to_function(func_name):\n#     fm = currentProgram.getFunctionManager()\n#     funcs = fm.getFunctions(True)\n#     for f in funcs:\n#         if f.getName() == func_name:\n#             print(f'Found {func_name} at {f.getEntryPoint()}')\n#             refs = getReferencesTo(f.getEntryPoint())\n#             for ref in refs:\n#                 print(f'  - Referenced from {ref.getFromAddress()}')\n\n# find_xrefs_to_function('CreateProcessA')"
                    }
                ],
                "activities": [
                    {
                        "title": "Explore a Benign Binary in Ghidra",
                        "description": "Download and install Ghidra. Create a new project and import a simple, known-benign executable (e.g., putty.exe or a 'Hello World' program you compiled yourself). Let Ghidra's auto-analysis run. Use the function list to find the 'main' or 'WinMain' function and look at both the assembly listing and the decompiled C code."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "A tool that converts machine code into a high-level language like C is called a:",
                        "options": ["Compiler", "Disassembler", "Debugger", "Decompiler"],
                        "correct": 3,
                        "explanation": "A decompiler attempts to reverse the compilation process to produce more human-readable, high-level code, whereas a disassembler only translates to low-level assembly."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary purpose of using a tool like Ghidra or IDA Pro?",
                        "options": ["To run the malware safely.", "To analyze the structure and code of an executable to understand its functionality.", "To capture network traffic.", "To edit the malware's code."],
                        "correct": 1,
                        "explanation": "These are advanced static analysis tools designed to help a reverse engineer understand the logic of a program by examining its disassembled and decompiled code."
                    }
                ]
            }
        },
        {
            "id": "lesson-10",
            "title": "Common Malware Techniques",
            "duration": "90 min",
            "objectives": [
              "Understand common persistence mechanisms used by malware to survive reboots.",
              "Learn the basic theory behind process injection.",
              "Recognize different methods of command and control (C2) communication.",
              "Identify these techniques by analyzing sandbox reports and memory dumps."
            ],
            "content": {
              "overview": "Malware authors use a common playbook of techniques to achieve their goals. This lesson introduces some of the most frequently observed behaviors, such as how malware stays on a system, hides its processes, and communicates with its operators.",
              "sections": [
                {
                  "title": "Persistence",
                  "content": "<p>Persistence is any technique used by malware to automatically re-execute after a system reboot. This is critical for the malware's long-term survival. Common methods include:</p><ul><li><strong>Registry Run Keys:</strong> Adding a program path to the `HKCU\\...\\Run` key.</li><li><strong>Scheduled Tasks:</strong> Creating a new scheduled task to launch the malware.</li><li><strong>Services:</strong> Creating a new Windows service that starts automatically.</li><li><strong>DLL Hijacking:</strong> Placing a malicious DLL with the same name as a legitimate DLL that a program loads.</li></ul>"
                },
                {
                  "title": "Process Injection",
                  "content": "<p>This is a stealth technique where the malware injects its malicious code into the memory space of a legitimate, running process (like `explorer.exe` or `svchst.exe`). This makes the malware harder to detect because the malicious code is not running in its own, easily identifiable process. The classic method involves the API calls `OpenProcess`, `VirtualAllocEx`, `WriteProcessMemory`, and `CreateRemoteThread`.</p>"
                }
              ],
              "codeExamples":[
                {
                    "title": "List Scheduled Tasks with PowerShell",
                    "language": "powershell",
                    "code": "# Defenders run this command to audit for suspicious scheduled tasks used for persistence.\n# They look for tasks with strange names or actions that run executables from temporary folders.\nGet-ScheduledTask | Where-Object { $_.State -ne 'Disabled' } | Select-Object TaskName, TaskPath, State, @{Name='Actions';Expression={$_.Actions.Execute + ' ' + $_.Actions.Arguments}} | Format-Table -Wrap"
                },
                {
                    "title": "Check for Suspicious Services with PowerShell",
                    "language": "powershell",
                    "code": "# This script helps a defender find potentially malicious services.\n# It specifically looks for services where the executable path is not in the standard System32 folder\n# and is not signed by Microsoft.\nGet-CimInstance -ClassName Win32_Service | ForEach-Object {\n    $path = $_.PathName -replace '\"', '' -split ' ' | Select -First 1\n    if ($path -and (Test-Path $path)) {\n        $signature = Get-AuthenticodeSignature -FilePath $path\n        if ($signature.Status -ne 'Valid' -and $path -notlike \"$($env:SystemRoot)*\") {\n            $_ | Select-Object Name, State, PathName\n        }\n    }\n}"
                },
                {
                    "title": "YARA Rule for Process Injection APIs",
                    "language": "yara",
                    "code": "/*\nThis YARA rule helps defenders find malware that is likely to perform process injection.\nIt doesn't look for the malware's code itself, but for the 'fingerprint' of the\nWindows API functions it needs to call to perform the injection.\n*/\nrule Detect_Process_Injection_APIs\n{\n    strings:\n        $s1 = \"CreateRemoteThread\"\n        $s2 = \"WriteProcessMemory\"\n        $s3 = \"VirtualAllocEx\"\n    condition:\n        all of them\n}"
                },
                {
                    "title": "Parse Sandbox Report for Persistence TIDs",
                    "language": "python",
                    "code": "# This script automates reviewing a sandbox report for known persistence techniques.\n# It helps a defender quickly see how a sample achieves persistence.\nimport json\ndef find_persistence_techniques(report_path):\n    try:\n        with open(report_path, 'r') as f:\n            data = json.load(f)\n            # Assumes the report has a MITRE ATT&CK section\n            signatures = data.get('signatures', [])\n            persistence_tids = []\n            for sig in signatures:\n                if 'Persistence' in sig.get('categories', []):\n                    # A defender would look up these TIDs in the ATT&CK database\n                    persistence_tids.extend(sig.get('mitre_attack_tids', []))\n            print('Found Persistence TIDs:', set(persistence_tids))\n    except Exception as e:\n        print(f'Error processing report: {e}')\n# Usage:\n# find_persistence_techniques('cuckoo_report.json')"
                }
              ],
              "activities": [
                {
                  "title": "Identify Persistence in Sandbox Reports",
                  "description": "Review several sandbox reports (from a service like Any.Run or MalwareBazaar). Look for the 'Persistence' or 'MITRE ATT&CK' section and identify which specific techniques (e.g., T1547.001 - Registry Run Keys) the samples used."
                }
              ]
            },
            "quiz": {
              "passingScore": 80,
              "questions": [
                {
                  "id": 1,
                  "question": "What is the goal of a malware 'persistence' mechanism?",
                  "options": ["To encrypt files.", "To steal passwords.", "To ensure the malware survives a system reboot and runs automatically.", "To spread to other computers."],
                  "correct": 2,
                  "explanation": "Persistence techniques are all about maintaining access to a compromised system over the long term."
                },
                {
                  "id": 2,
                  "question": "Process injection is a technique used by malware primarily for:",
                  "options": ["Crashing the computer.", "Spreading across the network.", "Defense evasion and stealth by hiding its code inside a legitimate process.", "Communicating with its C2 server."],
                  "correct": 2,
                  "explanation": "By running its code within a trusted process, malware can evade detection by some security products and make itself harder for an analyst to find."
                }
              ]
            }
        },
        {
            "id": "lesson-11",
            "title": "Network Behavior Analysis",
            "duration": "90 min",
            "objectives": [
              "Analyze DNS requests to identify potential C2 domain lookups.",
              "Examine HTTP/HTTPS traffic for beaconing and data exfiltration patterns.",
              "Understand the concept of a Command and Control (C2) server.",
              "Use Wireshark filters to isolate and analyze suspicious network flows."
            ],
            "content": {
              "overview": "Most malware needs to communicate over the network to receive commands, download additional payloads, or send stolen data back to its operator. This lesson focuses on analyzing captured network traffic to understand a sample's network-based indicators.",
              "sections": [
                {
                  "title": "Command and Control (C2)",
                  "content": "<p>The C2 (or C&C) server is the attacker-controlled machine that sends commands to the malware and receives data from it. Identifying this C2 traffic is a primary goal of network analysis.</p>"
                },
                {
                  "title": "Beaconing",
                  "content": "<p>Malware often 'beacons' out to its C2 server. This is a periodic, often regularly timed, connection (e.g., every 5 minutes) to say 'I'm still here, do you have any new commands for me?'. This regular, heartbeat-like traffic is a strong indicator of a malware infection when seen in network logs. Attackers may add 'jitter' (random variations in the timing) to make the beaconing less uniform and harder to detect.</p>"
                },
                {
                    "title": "Domain Generation Algorithms (DGA)",
                    "content": "<p>To make their C2 infrastructure resilient, some malware families use DGAs. Instead of having a hardcoded list of domains to contact, the malware generates thousands of new, random-looking domains every day and tries to contact them. The attacker only needs to register one of these domains for the malware to be able to connect to the C2 server. This makes blocking C2 domains very difficult for defenders.</p>"
                }
              ],
              "codeExamples": [
                {
                  "title": "Extract DNS Queries from a PCAP with Scapy",
                  "language": "python",
                  "code": "# This defensive script uses Scapy to parse a PCAP file and extract all DNS queries.\n# This helps an analyst identify domains a program is trying to contact.\n# It does not perform live network traffic capture.\nfrom scapy.all import rdpcap, DNS, DNSQR\n\ndef extract_dns_queries(pcap_file):\n    dns_queries = set()\n    try:\n        pkts = rdpcap(pcap_file)\n        for p in pkts:\n            if p.haslayer(DNS) and p.getlayer(DNS).qr == 0:\n                query = p.getlayer(DNSQR).qname.decode(errors='ignore')\n                dns_queries.add(query)\n        print(f\"--- Unique DNS Queries in '{pcap_file}' ---\")\n        for query in sorted(list(dns_queries)):\n            print(f\"  - {query}\")\n    except FileNotFoundError:\n        print(f'File not found: {pcap_file}')\n\n# Usage with a benign traffic capture from a known-safe application.\nextract_dns_queries(\"benign_traffic.pcap\")"
                },
                 {
                    "title": "List Active Network Connections with PowerShell",
                    "language": "powershell",
                    "code": "# This is a live analysis command that defenders use on a potentially compromised host.\n# It shows all active TCP connections and the process that owns them.\n# A defender would look for connections to strange remote addresses or by unexpected processes.\nGet-NetTCPConnection -State Established | Select-Object LocalAddress, LocalPort, RemoteAddress, RemotePort, OwningProcess, @{Name=\"ProcessName\";Expression={(Get-Process -Id $_.OwningProcess).ProcessName}} | Format-Table"
                },
                {
                    "title": "Parse HTTP Requests from PCAP with PyShark",
                    "language": "python",
                    "code": "# PyShark is a Python wrapper for tshark. This script shows how a defender\n# can inspect HTTP traffic for suspicious User-Agents or URIs.\nimport pyshark\ndef parse_http_from_pcap(pcap_file):\n    try:\n        cap = pyshark.FileCapture(pcap_file, display_filter='http')\n        for pkt in cap:\n            if hasattr(pkt.http, 'user_agent') and hasattr(pkt.http, 'request_uri'):\n                print(f\"URI: {pkt.http.request_uri}, User-Agent: {pkt.http.user_agent}\")\n    except Exception as e:\n        print(f'Error processing pcap: {e}')\n\n# Usage:\n# parse_http_from_pcap('benign_http.pcap')"
                },
                {
                    "title": "YARA Rule for Suspicious User-Agent",
                    "language": "yara",
                    "code": "/*\nDefenders use YARA rules like this to find malware that uses non-standard or\nknown-bad User-Agent strings in its C2 communication. Legitimate browsers have\nvery predictable User-Agents.\n*/\nrule Detect_Suspicious_UserAgent\n{\n    strings:\n        $ua1 = \"User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:40.0) Gecko/20100101 Firefox/40.0\"\n        $ua2 = \"User-Agent: curl/7.58.0\"\n\n    condition:\n        // A file is suspicious if it contains a common malware UA or a tool UA like curl\n        any of them\n}"
                }
              ],
              "activities": [
                {
                  "title": "Analyze a Benign PCAP",
                  "description": "Given a packet capture from a benign application (e.g., a web browser visiting a few sites), use Wireshark and the provided scripts to analyze the traffic. Filter for DNS and HTTP traffic. Identify the domain names that were requested and the User-Agent string sent by the browser."
                }
              ]
            },
            "quiz": {
              "passingScore": 80,
              "questions": [
                {
                  "id": 1,
                  "question": "A regular, heartbeat-like network connection from a compromised host to an external server is known as:",
                  "options": ["A file download", "Beaconing", "Port scanning", "Email spam"],
                  "correct": 1,
                  "explanation": "Beaconing is the term used to describe the periodic check-in traffic from malware to its C2 server."
                },
                {
                  "id": 2,
                  "question": "Analyzing DNS traffic during a malware infection is useful for:",
                  "options": ["Determining the malware's file hash.", "Identifying the domain names of the attacker's C2 servers.", "Figuring out which files were encrypted.", "Understanding which registry keys were modified."],
                  "correct": 1,
                  "explanation": "Before malware can connect to its C2 server via an HTTP request, it usually needs to perform a DNS lookup to find the server's IP address. These lookups are a critical network indicator."
                }
              ]
            }
        },
        {
            "id": "lesson-12",
            "title": "Malware Classification",
            "duration": "75 min",
            "objectives": [
                "Understand the difference between signature-based and behavioral detection.",
                "Learn how heuristic analysis attempts to find suspicious characteristics.",
                "Recognize the role of machine learning in modern malware classification.",
                "Use the information gathered so far to classify benign samples into categories."
            ],
            "content": {
                "overview": "Once we have analyzed a sample, we need to classify it. Is it a trojan? Is it spyware? Does it belong to a known malware family? This lesson covers the different approaches that security systems and analysts use to categorize and classify malware.",
                "sections": [
                    {
                        "title": "Detection Methods",
                        "content": "<ul><li><strong>Signature-Based:</strong> This is the traditional antivirus method. It looks for a unique, static fingerprint (like a hash or a specific sequence of bytes) that matches a known piece of malware. It's fast and accurate for known threats but useless against new ones.</li><li><strong>Heuristic Analysis:</strong> This method uses rules and scoring to identify suspicious *characteristics*. For example, a file might get points for being packed, for importing risky APIs, or for having no version information. If the score passes a threshold, it's flagged as suspicious.</li><li><strong>Behavioral Analysis:</strong> This method, used by sandboxes and EDRs, focuses on what the program *does*. It looks for patterns of behavior associated with malware, like creating a file in the System32 folder and then creating a Run key in the registry.</li><li><strong>Machine Learning:</strong> Modern systems use ML to classify files. Models are trained on millions of benign and malicious files to learn the statistical properties of each. The model can then predict whether a new, unseen file is malicious based on its features (e.g., entropy, imported functions, string patterns).</li></ul>"
                    }
                ],
                "codeExamples":[
                {
                    "title": "Query VirusTotal API for Classifications",
                    "language": "python",
                    "code": "# This script demonstrates how a defender uses a public repository to see how different\n# security vendors classify a file. It's a powerful form of intelligence gathering.\nimport requests\nAPI_KEY = 'YOUR_VT_API_KEY'\nFILE_HASH = '84c82835a5d21bbcf75a61706d8ab549' # Benign EICAR test file hash\ndef get_vt_classifications(api_key, file_hash):\n    url = f'https://www.virustotal.com/api/v3/files/{file_hash}'\n    headers = {'x-apikey': api_key}\n    response = requests.get(url, headers=headers)\n    if response.status_code == 200:\n        results = response.json()['data']['attributes']['last_analysis_results']\n        for vendor, result in results.items():\n            if result['category'] == 'malicious':\n                print(f\"{vendor}: {result['result']}\")\n# get_vt_classifications(API_KEY, FILE_HASH)"
                },
                {
                    "title": "YARA Rule for Heuristic Classification",
                    "language": "yara",
                    "code": "/*\nThis YARA rule doesn't look for a specific malware family. Instead, it uses heuristics.\n A defender would use this to find potentially unwanted programs (PUPs) or adware.\nIt scores a file based on suspicious characteristics.\n*/\nrule Heuristic_Suspicious_Adware\n{\n    strings:\n        $s1 = \"install_adware\"\n        $s2 = \"tracking_cookie\"\n        $s3 = \"user_identifier\"\n    condition:\n        // If the file is a PE file and has at least 2 of the suspicious strings,\n        // it's flagged. This is a heuristic, not a definitive signature.\n        uint16(0) == 0x5A4D and 2 of ($s*)\n}"
                },
                {
                    "title": "Check Authenticode Signature with PowerShell",
                    "language": "powershell",
                    "code": "# Malware is often unsigned or has an invalid digital signature.\n# Defenders use this command to check the signature status of a file. An unsigned\n# file downloaded from the internet is much more suspicious than a signed Microsoft binary.\nGet-AuthenticodeSignature -FilePath C:\\Windows\\System32\\notepad.exe | Select-Object Status, SignerCertificate"
                },
                {
                    "title": "Conceptual Machine Learning Classifier",
                    "language": "python",
                    "code": "# This code is conceptual and will not run without a dataset.\n# It shows the logic a defender would use to build a simple ML classifier.\n# Features are extracted from PE files, and a model is trained to distinguish good from bad.\n# from sklearn.ensemble import RandomForestClassifier\n\n# features = [ [entropy, num_imports, num_sections], ... ] # From many benign files\n# labels = [ 0, 0, 0, ... ] # 0 for benign\n\n# features.extend([ [entropy, ...], ... ]) # From many malicious files\n# labels.extend([ 1, 1, 1, ... ]) # 1 for malicious\n\n# model = RandomForestClassifier()\n# model.fit(features, labels)\n\n# new_file_features = [7.8, 5, 3]\n# prediction = model.predict([new_file_features])\n# print('Prediction (1=malicious):', prediction)"
                }
              ],
                "activities": [
                    {
                        "title": "Classify Benign Samples by Behavior",
                        "description": "Analyze two different benign applications (e.g., a software installer and a portable utility like PuTTY). Write a short behavioral profile for each one. The installer might be classified as a 'File Writer' and 'Registry Modifier', while the utility might be a 'Network Communicator'."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "Traditional antivirus software primarily relies on which detection method?",
                        "options": ["Heuristic analysis", "Behavioral analysis", "Signature-based detection", "Manual reverse engineering"],
                        "correct": 2,
                        "explanation": "Signature-based detection, which involves matching file hashes or byte patterns against a database of known malware, is the cornerstone of traditional AV."
                    },
                    {
                        "id": 2,
                        "question": "A security system that flags a program as 'suspicious' because it tries to modify a registry Run key is using what type of analysis?",
                        "options": ["Signature-based", "Behavioral analysis", "Static property analysis", "Network analysis"],
                        "correct": 1,
                        "explanation": "This is behavioral analysis because the detection is based on the actions the program takes after it is executed, not on its static properties."
                    }
                ]
            }
        },
        {
            "id": "lesson-13",
            "title": "Indicators of Compromise (IOCs)",
            "duration": "90 min",
            "objectives": [
              "Define what an Indicator of Compromise (IOC) is and why it's useful for defenders.",
              "Identify the four main types of IOCs: host-based, network-based, file-based, and behavioral.",
              "Practice extracting IOCs from analysis reports and logs.",
              "Understand how IOCs are used in threat intelligence."
            ],
            "content": {
              "overview": "The output of a malware analysis is a set of Indicators of Compromise (IOCs). These are the forensic artifacts or clues that can be used by defenders to hunt for the same infection on other systems. This lesson covers what IOCs are and how to extract them from your analysis.",
              "sections": [
                {
                  "title": "Types of IOCs",
                  "content": "<p>IOCs are the breadcrumbs left behind by malware. They fall into several categories:</p><ul><li><strong>File-Based:</strong> The hash of the malware file (MD5, SHA1, SHA256), file names, and paths where it is dropped.</li><li><strong>Network-Based:</strong> IP addresses or domain names of C2 servers, suspicious user-agent strings.</li><li><strong>Host-Based:</strong> Registry keys created for persistence, mutex names used by the malware, names of services it creates.</li><li><strong>Behavioral:</strong> A sequence of actions, often mapped to a framework like MITRE ATT&CK (e.g., 'A process creates a scheduled task and then makes an HTTP POST to a specific domain').</li></ul>"
                },
                {
                    "title":"The Pyramid of Pain",
                    "content":"<p>The Pyramid of Pain is a concept in threat intelligence that categorizes indicators by how difficult they are for an adversary to change. It's easy for an attacker to change a file hash (just recompile the code), but it's very difficult for them to change their fundamental Tactics, Techniques, and Procedures (TTPs). As defenders, our goal is to detect and respond to indicators higher up the pyramid, as this has a greater impact on the adversary.</p>"
                }
              ],
              "codeExamples":[
                {
                    "title": "Extract IOCs from a Text Report with Regex",
                    "language": "python",
                    "code": "# Defenders often receive threat intelligence reports as text. This script\n# demonstrates how to parse such a report to automatically extract IOCs.\nimport re\ndef extract_iocs_from_report(report_text):\n    ip_pattern = re.compile(r'\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\b')\n    hash_pattern = re.compile(r'\\b[A-Fa-f0-9]{64}\\b') # SHA256\n    domain_pattern = re.compile(r'\\b[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}\\b')\n\n    print('--- Extracted IOCs ---')\n    print('IPs:', ip_pattern.findall(report_text))\n    print('SHA256s:', hash_pattern.findall(report_text))\n    print('Domains:', domain_pattern.findall(report_text))\n\n# Usage with a sample report string\nreport = 'The malware connected to 10.20.30.40 and foo-c2.com. The dropped file had hash 123...abc.'\n# extract_iocs_from_report(report) # This would not work as hash is not 64 chars\n"
                },
                {
                    "title": "Search the Registry for a Host-Based IOC",
                    "language": "powershell",
                    "code": "# If a threat report says malware creates a specific registry key, a defender\n# can use this command to hunt for that key on their systems.\n$iocPath = 'HKCU:\\Software\\SuspiciousApp'\nif (Test-Path $iocPath) {\n    Write-Host \"[ALERT] Potential IOC found: Registry key $iocPath exists.\"\n} else {\n    Write-Host \"[INFO] IOC path not found.\"\n}"
                },
                {
                    "title": "Search for a File Hash IOC on Disk",
                    "language": "powershell",
                    "code": "# This script shows how a defender would hunt for a file based on its hash.\n# It recursively scans a directory, calculates the hash of each file, and compares it to a known-bad hash.\n$knownBadHash = '...' # The SHA256 hash of the malware\nGet-ChildItem -Path C:\\Users\\ -Recurse -File | ForEach-Object {\n    $hash = (Get-FileHash -Algorithm SHA256 $_.FullName).Hash\n    if ($hash -eq $knownBadHash) {\n        Write-Host \"[ALERT] Malicious file found: $($_.FullName)\"\n    }\n}"
                },
                {
                    "title": "Create a Simple STIX 2.1 IOC Object",
                    "language": "python",
                    "code": "# STIX is a standardized language for threat intelligence. This script shows how\n# a defender would represent a file hash IOC in this structured JSON format.\nimport json\ndef create_stix_file_ioc(file_hash_sha256):\n    stix_object = {\n        \"type\": \"indicator\",\n        \"spec_version\": \"2.1\",\n        \"id\": \"indicator--...\", # This would be a unique ID\n        \"pattern_type\": \"stix\",\n        \"pattern\": f\"[file:hashes.'SHA-256' = '{file_hash_sha256}']\"\n    }\n    print(json.dumps(stix_object, indent=4))\n\n# create_stix_file_ioc('e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855')"
                }
              ],
              "activities": [
                {
                  "title": "Extract IOCs from Sandbox Logs",
                  "description": "Review a sandbox report for a benign sample. Create a list of all potential file-based, host-based, and network-based IOCs you can find. For example, the file's hash, any files it created, any domains it contacted, and any registry keys it modified."
                }
              ]
            },
            "quiz": {
              "passingScore": 80,
              "questions": [
                {
                  "id": 1,
                  "question": "What is an Indicator of Compromise (IOC)?",
                  "options": ["A type of antivirus software.", "A piece of forensic data that can be used to detect a malicious activity or infection.", "A legal document.", "The person who wrote the malware."],
                  "correct": 1,
                  "explanation": "IOCs are the tangible evidence of a compromise that blue teams use to hunt for and respond to threats."
                },
                {
                  "id": 2,
                  "question": "The domain name `malicious-c2-server.com` found in a malware sample's network traffic is an example of what type of IOC?",
                  "options": ["File-based", "Host-based", "Network-based", "Behavioral"],
                  "correct": 2,
                  "explanation": "Domain names, IP addresses, and URLs are all network-based indicators."
                }
              ]
            }
        },
        {
            "id": "lesson-14",
            "title": "Memory Analysis Basics",
            "duration": "120 min",
            "objectives": [
                "Understand why memory analysis is a critical skill.",
                "Learn how to acquire a memory image (RAM dump) from a virtual machine.",
                "Introduce the Volatility framework as the primary tool for memory forensics.",
                "Use basic Volatility plugins to list running processes and network connections from a memory image."
            ],
            "content": {
                "overview": "Some advanced malware, known as 'fileless' malware, tries to exist only in a computer's memory (RAM) and never write its primary payload to the disk. Memory analysis allows us to find this type of threat. It's also crucial for analyzing packed malware, as the unpacked, original code can be found in memory.",
                "sections": [
                    {
                        "title": "Why Analyze Memory?",
                        "content": "<p>Analyzing a memory dump can reveal a wealth of information that is not available from disk-based forensics:</p><ul><li>Running processes (including hidden or injected ones).</li><li>Active network connections.</li><li>Loaded DLLs for each process.</li><li>Unpacked versions of packed executables.</li><li>Injected code and hooks.</li></ul>"
                    },
                    {
                        "title": "The Volatility Framework",
                        "content": "<p>Volatility is an open-source memory forensics framework. It is a command-line tool with a rich set of 'plugins' that can parse a memory image and extract information from it. For example, the `pslist` plugin lists the processes that were running when the memory was captured, and `netscan` can find network artifacts.</p>"
                    },
                    {
                        "title":"Memory Acquisition",
                        "content":"<p>A memory image can be acquired in several ways. In a VM environment, you can often 'suspend' the VM and grab the `.vmsn` or `.vmem` file, which contains the full memory state. For live systems, dedicated tools like `dumpit.exe` or `FTK Imager` are used to create a raw memory capture file.</p>"
                    }
                ],
                "codeExamples":[
                {
                    "title": "Volatility 3 Command: List Processes",
                    "language": "bash",
                    "code": "# Volatility is a command-line tool. A defender runs it against a memory image.\n# This command uses the 'windows.pslist' plugin to list all processes that were running\n# when the memory was captured. This can reveal processes hidden by a rootkit.\npython3 vol.py -f memory_dump.mem windows.pslist"
                },
                {
                    "title": "Volatility 3 Command: Scan for Network Artifacts",
                    "language": "bash",
                    "code": "# This command uses the 'windows.netscan' plugin.\n# It scans the memory image for active and recently terminated network connections.\n# This is a powerful way to find C2 connections even after the process has exited.\npython3 vol.py -f memory_dump.mem windows.netscan"
                },
                {
                    "title": "Volatility 3 Command: Find Injected Code (malfind)",
                    "language": "bash",
                    "code": "# 'malfind' is one of Volatility's most powerful plugins for defenders.\n# It hunts for regions of memory in a process that look like injected code\n# (e.g., memory that is marked as execute-read-write).\npython3 vol.py -f memory_dump.mem windows.malfind"
                },
                {
                    "title": "Automate Volatility Analysis with a Bash Script",
                    "language": "bash",
                    "code": "# A defender would use a script like this to automate their initial memory analysis workflow,\n# running a standard set of plugins and saving the output for review.\nMEMFILE=\"memory_dump.mem\"\nOUTDIR=\"vol_output\"\nmkdir -p $OUTDIR\n\nPLUGINS=\"windows.pslist windows.pstree windows.netscan windows.dlllist\"\n\nfor plugin in $PLUGINS; do\n    echo \"[*] Running $plugin...\"\n    python3 vol.py -f $MEMFILE $plugin > \"$OUTDIR/$plugin.txt\"\ndone\necho \"Analysis complete. See output in $OUTDIR\""
                }
              ],
                "activities": [
                    {
                        "title": "Analyze a Memory Image with Volatility",
                        "description": "Given a pre-captured memory image from a benign Windows system, use the Volatility framework to perform basic analysis. Run the `imageinfo` plugin to identify the OS profile. Then, run `pslist` to see the running processes and `netscan` to see network connections."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "Memory analysis is particularly effective at finding what type of malware?",
                        "options": ["Viruses", "'Fileless' malware that primarily runs in RAM.", "Ransomware", "Adware"],
                        "correct": 1,
                        "explanation": "Fileless malware tries to avoid writing files to disk to evade traditional antivirus. Memory analysis is one of the few ways to detect and analyze such threats."
                    },
                    {
                        "id": 2,
                        "question": "The Volatility Framework is a tool used for:",
                        "options": ["Capturing network traffic.", "Analyzing a memory dump (RAM image) to find forensic artifacts.", "Editing a malware's code.", "Creating malware."],
                        "correct": 1,
                        "explanation": "Volatility is the industry-standard open-source tool for parsing raw memory images and extracting structured information from them."
                    }
                ]
            }
        },
        {
    "id": "lesson-15",
    "title": "Wireless Attack Surface Review (High-Level)",
    "duration": "75 min",
    "objectives": [
        "Categorize the major types of wireless attacks and their real-world impact.",
        "Map layered defensive controls to each attack category to build a defense-in-depth strategy.",
        "Review common attack vectors from a threat modeling perspective, not exploit execution.",
        "Understand the attacker's mindset, objectives, and kill chain to improve defensive posturing."
    ],
    "content": {
        "overview": "This lesson synthesizes our previous discussions into a high-level threat model of the wireless attack surface. We will deconstruct the attacker's methodology, categorize common attacks by their objective (e.g., confidentiality, integrity, availability), and map them to the defensive strategies and hardening techniques learned so far. The goal is to build a holistic, defense-in-depth mindset to prioritize security efforts, not to learn how to execute attacks.",
        "sections": [
            {
                "title": "The Attacker's Mindset & Objectives",
                "content": "<p>Defenders think about building walls; attackers think about finding the weakest brick, the open window, or tricking someone inside to open the door. Understanding their goals is the first step to stopping them.</p><ul><li><strong>Objective: Compromise Confidentiality</strong> (Eavesdropping): Steal data in transit. This is often the first step.</li><li><strong>Objective: Compromise Integrity</strong> (Impersonation/MITM): Alter communications, inject malicious code, or redirect users.</li><li><strong>Objective: Compromise Availability</strong> (Denial of Service): Disrupt business operations, often as a smokescreen for another attack.</li><li><strong>Objective: Gain Access</strong> (Authentication Bypass): Join the network to launch further internal attacks.</li></ul>"
            },
            {
                "title": "Attack Categories, Vectors, and Layered Mitigations",
                "content": "<ul><li><strong>Eavesdropping:</strong> The simplest attack. Attackers passively listen to wireless traffic.<ul><li><strong>Vectors:</strong> Monitoring open/WEP networks, cracking WPA-PSK handshakes.</li><li><strong>Layered Mitigation:</strong> <strong>Encryption</strong> (WPA3>WPA2>WPA>WEP), <strong>Application Layer Security</strong> (HTTPS, VPNs), <strong>Physical Security</strong> (controlling RF propagation).</li></ul></li><li><strong>Impersonation & Man-in-the-Middle (MITM):</strong> Attackers create rogue access points to intercept traffic.<ul><li><strong>Vectors:</strong> Evil Twin APs, KARMA attacks, fake captive portals, downgrade attacks.</li><li><strong>Layered Mitigation:</strong> <strong>Strong Authentication</strong> (802.1X/EAP-TLS with server cert validation), <strong>User Training</strong> (on certificate warnings), <strong>WIDS</strong> (to detect rogue APs and clients).</li></ul></li><li><strong>Denial of Service (DoS):</strong> Attackers render the network unusable.<ul><li><strong>Vectors:</strong> Deauthentication/Disassociation floods, RF jamming, CTS/RTS attacks.</li><li><strong>Layered Mitigation:</strong> <strong>Protocol Hardening</strong> (Protected Management Frames - PMF), <strong>Monitoring</strong> (WIDS to detect flood patterns), <strong>Physical Security</strong> (locating and removing jammers).</li></ul></li><li><strong>Authentication Attacks:</strong> Attackers gain unauthorized network access.<ul><li><strong>Vectors:</strong> WPS PIN attacks, PSK cracking, EAP downgrades.</li><li><strong>Layered Mitigation:</strong> <strong>Disable WPS</strong>, <strong>Strong Credentials</strong> (complex PSK or avoid PSK entirely with 802.1X), <strong>Server Configuration</strong> (rejecting weak EAP methods).</li></ul></li></ul>"
            }
        ],
        "codeExamples": [
            {
                "title": "Simulating WIDS Logic for Deauth Flood Detection",
                "language": "python",
                "code": "# This is a simplified conceptual example of logic a WIDS might use.\n# It counts deauth frames per second from a live capture and alerts if a threshold is exceeded.\n# This does NOT perform any attack; it only monitors.\nfrom scapy.all import sniff, Dot11, Dot11Deauth\nfrom collections import defaultdict\nimport time\n\n# Global counter\ndeauth_counter = defaultdict(int)\nlast_alert_time = 0\nALERT_THRESHOLD = 20  # More than 20 deauths/sec\nALERT_COOLDOWN = 10   # Don't alert more than once every 10 seconds\n\ndef packet_handler(pkt):\n    global last_alert_time\n    if pkt.haslayer(Dot11Deauth):\n        current_second = int(time.time())\n        deauth_counter[current_second] += 1\n        \n        # Check if threshold is breached\n        if deauth_counter[current_second] > ALERT_THRESHOLD:\n            if current_second - last_alert_time > ALERT_COOLDOWN:\n                print(f\"[!] ALERT: Deauth flood detected! {deauth_counter[current_second]} frames in second {current_second}\")\n                last_alert_time = current_second\n        # Clean up old entries (older than 10 seconds)\n        for sec in list(deauth_counter.keys()):\n            if current_second - sec > 10:\n                del deauth_counter[sec]\n\nprint(\"Monitoring for deauthentication floods (simulated WIDS function)...\")\n# Use the correct wireless interface monitor mode name (e.g., wlan0mon)\nsniff(iface=\"wlan0mon\", prn=packet_handler, store=0)"
            }
        ],
        "activities": [
            {
                "title": "Build a Defense-in-Depth Matrix",
                "description": "Create a table with four columns: 1) Attack Objective (e.g., Eavesdropping), 2) Specific Attack Vector (e.g., Cracking WPA2-PSK), 3) Primary Mitigation (e.g., Use WPA3), 4) Secondary/Compensating Control (e.g, Deploy a VPN mandate). This exercise forces you to think beyond a single solution."
            }
        ]
    },
    "quiz": {
        "passingScore": 80,
        "questions": [
            {
                "id": 1,
                "question": "What is the most effective defense against passive eavesdropping on a Wi-Fi network?",
                "options": ["Hiding the SSID (Network Cloaking).", "Using a strong, modern encryption protocol like WPA3.", "MAC address filtering.", "Using a stateful firewall on the router."],
                "correct": 1,
                "explanation": "Encryption is the only control that provides cryptographic confidentiality for data in transit over the airwaves. Hiding the SSID and MAC filtering are trivial to bypass, and a firewall does not protect the wireless medium itself."
            },
            {
                "id": 2,
                "question": "A defense-in-depth strategy for Wi-Fi security is crucial because:",
                "options": ["It allows you to use weaker individual controls.", "It ensures that if one security control fails (e.g., encryption is cracked), others (e.g., client isolation, WIDS) can still prevent a full breach.", "It is required by all wireless compliance standards.", "It simplifies the network configuration."],
                "correct": 1,
                "explanation": "The core principle of defense-in-depth is that no single control is perfect. Multiple, layered controls provide resilience. The failure of one layer should not lead to a catastrophic compromise."
            },
            {
                "id": 3,
                "question": "From an attacker's perspective, which objective is typically achieved FIRST in a wireless attack kill chain?",
                "options": ["Denial of Service", "Gaining Root Access", "Reconnaissance & Eavesdropping", "Data Exfiltration"],
                "correct": 2,
                "explanation": "Attackers almost always start with passive reconnaissance (e.g., scanning for networks, listening to traffic) to understand the target environment before launching active attacks."
            }
        ]
    }
},
        {
            "id": "lesson-16",
            "title": "Document & Script Malware",
            "duration": "90 min",
            "objectives": [
                "Understand how Microsoft Office documents can be weaponized with malicious macros.",
                "Learn about other script-based threats like JavaScript and VBScript droppers.",
                "Use tools like `oledump` to safely analyze the structure of Office documents.",
                "Practice extracting and deobfuscating malicious scripts."
            ],
            "content": {
                "overview": "Not all malware comes in the form of an EXE file. Malicious scripts embedded in documents, PDFs, and web pages are a very common infection vector. This lesson covers how to safely analyze these types of threats, focusing on malicious Office macros.",
                "sections": [
                    {
                        "title": "Malicious Macros",
                        "content": "<p>Macros are small programs, usually written in VBA (Visual Basic for Applications), embedded within Office documents (Word, Excel, etc.). While they have legitimate uses for automation, attackers use them to execute malicious code. Typically, the attacker uses social engineering to trick the user into clicking 'Enable Content', which allows the macro to run. The macro then often uses PowerShell to download and execute a second-stage malware payload from the internet.</p>"
                    },
                    {
                        "title": "Analysis with oledump",
                        "content": "<p>Office documents are structured files. A tool like `oledump.py` can parse this structure and show the different streams of data inside, including any macro code. An analyst can use this tool to safely extract the VBA code for static analysis without ever opening the document in Office.</p>"
                    }
                ],
                "codeExamples":[
                {
                    "title": "Analyze Office Document Streams with oledump",
                    "language": "bash",
                    "code": "# oledump.py is a key tool for defenders analyzing suspicious documents.\n# This command lists all the data 'streams' inside a document.\n# Macro code is indicated by an 'M' or 'm'.\noledump.py benign_macro_sample.docm"
                },
                {
                    "title": "Extract Macro Code with oledump",
                    "language": "bash",
                    "code": "# Once a macro stream is identified (e.g., stream 8), a defender uses this command\n# to extract the VBA source code into a text file for safe inspection, without running it.\noledump.py -s 8 -v benign_macro_sample.docm > macro_code.vba"
                },
                {
                    "title": "Deobfuscate a PowerShell Command with PowerShell",
                    "language": "powershell",
                    "code": "# Malicious macros often contain base64-encoded PowerShell commands to hide their true intent.\n# A defender can take the encoded string and use PowerShell's built-in capabilities to decode it.\n$encodedCommand = '...your base64 string here...'\n$decodedBytes = [System.Convert]::FromBase64String($encodedCommand)\n$decodedText = [System.Text.Encoding]::Unicode.GetString($decodedBytes)\nWrite-Host $decodedText"
                },
                {
                    "title": "YARA Rule to Detect Suspicious Macro Keywords",
                    "language": "yara",
                    "code": "/*\nThis YARA rule is designed to be run against extracted macro code.\nDefenders use it to quickly find macros that perform suspicious actions like\nlaunching other programs ('Shell') or running scripts ('PowerShell').\n*/\nrule Detect_Suspicious_Macro_Actions\n{\n    strings:\n        $s1 = \"AutoOpen\" nocase\n        $s2 = \"Document_Open\" nocase\n        $s3 = \"Shell(\" nocase\n        $s4 = \"powershell\" nocase\n    condition:\n        // A macro is suspicious if it auto-runs and contains shell or powershell commands.\n        ( $s1 or $s2 ) and ( $s3 or $s4 )\n}"
                }
              ],
                "activities": [
                    {
                        "title": "Analyze a Benign Macro Sample with oledump",
                        "description": "Create a simple, benign Word document with a harmless macro (e.g., one that just shows a message box). Save it in the `.docm` format. Then, use the `oledump.py` tool to view the streams within the file and extract the source code of your macro."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the most common payload for a malicious Office macro?",
                        "options": ["To format the document nicely.", "To act as a 'dropper' or 'downloader' that fetches and executes a more powerful malware payload from the internet.", "To check for spelling errors.", "To delete the document."],
                        "correct": 1,
                        "explanation": "Macros are typically the first stage of an attack. Their job is to gain code execution and then download the main malware payload."
                    },
                    {
                        "id": 2,
                        "question": "A tool like `oledump.py` is used by analysts to:",
                        "options": ["Run the malicious macro in a safe sandbox.", "Safely extract macro code from an Office document for static analysis without having to open it in Microsoft Office.", "Edit the text of a Word document.", "Send the document to the attacker."],
                        "correct": 1,
                        "explanation": "Tools like oledump are essential for safely dissecting document-based threats by allowing the analyst to inspect their contents without activating any malicious code."
                    }
                ]
            }
        },
        {
            "id": "lesson-17",
            "title": "Mobile Malware Overview",
            "duration": "75 min",
            "objectives": [
              "Understand the basics of the Android application package (APK) format.",
              "Learn the role of the Android Manifest and permissions.",
              "Use JADX to decompile a benign APK file and view its Java source code.",
              "Briefly contrast the Android and iOS security models."
            ],
            "content": {
              "overview": "As mobile devices have become central to our lives, they have also become a major target for malware. This lesson provides a high-level introduction to mobile malware, focusing primarily on the Android ecosystem, which is more open and therefore a more common target for analysis.",
              "sections": [
                {
                  "title": "Android APK Analysis",
                  "content": "<p>Android apps are distributed as APK files. An APK is essentially a ZIP archive containing the app's code, resources, assets, and a crucial file called `AndroidManifest.xml`.</p><ul><li><strong>AndroidManifest.xml:</strong> This file declares the app's components and, most importantly, the permissions it requires (e.g., access to contacts, SMS, internet). Analyzing the requested permissions is a key first step.</li><li><strong>Decompilation:</strong> Tools like JADX can decompile the app's code back into mostly readable Java, allowing an analyst to understand its logic.</li></ul>"
                },
                {
                  "title": "iOS Security Model",
                  "content": "<p>Apple's iOS is a more closed ecosystem. Apps are primarily distributed through the official App Store, where they undergo a review process. This 'walled garden' approach makes malicious apps less common, though not impossible. Analysis of iOS apps is generally more difficult and requires more specialized tools.</p>"
                }
              ],
              "codeExamples":[
                {
                    "title": "Disassemble an APK with apktool",
                    "language": "bash",
                    "code": "# apktool is a standard tool for mobile malware analysts.\n# It unpacks the APK into a human-readable file structure, converting the binary\n# AndroidManifest.xml into a readable text file and creating Smali (assembly-like) files.\napktool d benign_sample.apk -o ./output_folder"
                },
                {
                    "title": "Parse Android Manifest with Python",
                    "language": "python",
                    "code": "# This script demonstrates how a defender can programmatically audit an Android app's permissions\n# by parsing its manifest file (after being decoded by apktool).\nimport xml.etree.ElementTree as ET\ndef check_android_permissions(manifest_path):\n    try:\n        tree = ET.parse(manifest_path)\n        root = tree.getroot()\n        print(f'--- Permissions for {manifest_path} ---')\n        for perm in root.findall('uses-permission'):\n            permission_name = perm.attrib.get('{http://schemas.android.com/apk/res/android}name')\n            # A defender would have a list of dangerous permissions to flag\n            if 'SMS' in permission_name or 'CONTACTS' in permission_name:\n                print(f'[ALERT] Dangerous permission found: {permission_name}')\n            else:\n                print(permission_name)\n    except Exception as e:\n        print(f'Could not parse manifest: {e}')\n\n# Usage:\n# check_android_permissions('./output_folder/AndroidManifest.xml')"
                },
                {
                    "title": "YARA Rule to Find C2 in DEX files",
                    "language": "yara",
                    "code": "/*\nDefenders can use YARA to scan the compiled code (`classes.dex`) inside an APK.\nThis rule hunts for hardcoded network indicators that might point to a C2 server.\n*/\nrule Detect_C2_In_DEX\n{\n    strings:\n        $ip_pattern = /[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}/\n        $domain_pattern = /[a-zA-Z0-9.-]+\\.(com|org|net)/\n    condition:\n        // Check that the file is a DEX file by its magic number\n        uint32(0) == 0x0A786564 and any of them\n}"
                },
                {
                    "title": "View Decompiled Code with JADX-GUI",
                    "language": "text",
                    "code": "// This is not executable code, but represents the action a defender takes.\n// JADX is a point-and-click decompiler for Android apps.\n// Action: Open JADX-GUI.\n// Action: File -> Open -> select 'benign_sample.apk'.\n// Action: Use the tree view on the left to navigate to the AndroidManifest.xml\n//         and browse the decompiled Java source code."
                }
              ],
              "activities": [
                {
                  "title": "Decompile a Benign APK with JADX",
                  "description": "Download a benign, open-source APK file from a trusted repository like F-Droid. Open the APK file in the JADX-GUI tool. Explore the decompiled Java source code and examine the `AndroidManifest.xml` file to see what permissions the application requests."
                }
              ]
            },
            "quiz": {
              "passingScore": 80,
              "questions": [
                {
                  "id": 1,
                  "question": "What is the most important file inside an APK for an analyst to check first?",
                  "options": ["The application's icon.", "The sound files.", "The `AndroidManifest.xml` file, to see the requested permissions.", "The privacy policy."],
                  "correct": 2,
                  "explanation": "The manifest file provides a quick overview of the app's capabilities and intentions by declaring the permissions it needs to function. An excessive number of dangerous permissions is a major red flag."
                },
                {
                  "id": 2,
                  "question": "A tool like JADX is used to:",
                  "options": ["Install an APK on your phone.", "Decompile an Android APK into readable Java source code for static analysis.", "Run an APK in a sandbox.", "Scan an APK for viruses."],
                  "correct": 1,
                  "explanation": "JADX is a decompiler, which is the mobile equivalent of using Ghidra or IDA to reverse engineer the source code of an application."
                }
              ]
            }
        },
        {
            "id": "lesson-18",
            "title": "Malware Evasion Techniques",
            "duration": "90 min",
            "objectives": [
                "Understand how malware uses anti-VM techniques to detect analysis environments.",
                "Learn about common anti-debug checks.",
                "Recognize how timing checks can be used to thwart automated analysis.",
                "Develop strategies to modify a lab environment to bypass simple evasion checks."
            ],
            "content": {
                "overview": "Malware authors know about malware analysts. Modern, sophisticated malware often includes features specifically designed to detect and evade analysis environments like VMs and sandboxes. This lesson covers these anti-analysis techniques.",
                "sections": [
                    {
                        "title": "Anti-VM Techniques",
                        "content": "<p>Malware can check for tell-tale signs that it's running inside a virtual machine instead of on a real physical computer. These checks include:</p><ul><li>Looking for VM-specific files or registry keys (e.g., 'VBoxGuestAdditions').</li><li>Checking for known VM MAC addresses.</li><li>Measuring subtle hardware differences or CPU instruction timings that differ in a virtualized environment.</li></ul>"
                    },
                    {
                        "title": "Anti-Debug and Anti-Sandbox Techniques",
                        "content": "<p>If malware detects that a debugger is attached to its process, it will often terminate immediately. Similarly, it may refuse to run its malicious payload if it detects the unique environment of an automated sandbox. A common technique is to use a 'sleep' or timing check: the malware will go dormant for a long period (e.g., 10 minutes). Many automated sandboxes will time out and stop their analysis before the sleep period is over, thus never seeing the malicious behavior.</p>"
                    }
                ],
                "codeExamples":[
                {
                    "title": "Simulate a VM BIOS Check with Python",
                    "language": "python",
                    "code": "# This script simulates a check that malware might perform.\n# A defender runs this on their own lab VM to understand how it could be fingerprinted.\nimport wmi\ndef check_vm_bios():\n    try:\n        c = wmi.WMI()\n        bios = c.Win32_BIOS()[0]\n        bios_version = bios.Version.upper()\n        vm_strings = [\"VBOX\", \"VMWARE\", \"VIRTUAL\"]\n        for s in vm_strings:\n            if s in bios_version:\n                print(f'[ALERT] VM artifact found in BIOS version: {bios.Version}')\n                return\n        print('[INFO] No common VM strings in BIOS.')\n    except Exception as e:\n        print(f'Could not perform check: {e}')\n\n# check_vm_bios()"
                },
                {
                    "title": "Simulate an Anti-Debug Check with PowerShell",
                    "language": "powershell",
                    "code": "# Malware can check if a debugger is present. A defender can use this same check\n# to test how a program behaves when it thinks it's being debugged.\nif ([System.Diagnostics.Debugger]::IsAttached) {\n    Write-Host \"Debugger is attached! Malware would exit now.\"\n} else {\n    Write-Host \"No debugger attached. Malware would proceed.\"\n}"
                },
                {
                    "title": "YARA Rule to Detect Anti-VM Instructions",
                    "language": "yara",
                    "code": "/*\nSome VMs have special CPU instructions. Malware can try to execute them and see\nif they work. This YARA rule helps defenders find malware that uses the 'red pill'\nanti-VM technique.\n*/\nrule Detect_Red_Pill_AntiVM\n{\n    strings:\n        // The SIDT instruction is used to query the interrupt descriptor table register.\n        // Its location can differ between real and virtual hardware.\n        $sidt = { 0F 01 0D }\n    condition:\n        $sidt\n}"
                },
                {
                    "title": "Change VM MAC Address with PowerShell",
                    "language": "powershell",
                    "code": "# As a hardening step, a defender can change their VM's MAC address to not use\n# a default vendor OUI (e.g., 08:00:27 for VirtualBox).\n# This can bypass simple MAC-based VM checks.\n# Get-NetAdapter -Name \"Ethernet\" | Set-NetAdapter -MacAddress \"001122334455\" # (Requires admin)\nWrite-Host \"This command would change the MAC address. Run with admin rights to apply.\""
                }
              ],
                "activities": [
                    {
                        "title": "Test Benign Sample Behavior in Different VM Configs",
                        "description": "In your lab VM, change some of its properties (e.g., the amount of RAM, the number of CPU cores). Run a benign application and observe if its behavior changes. Discuss how a malware author could use these properties to create a fingerprint of an analysis environment."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "A piece of malware checks for the existence of a file named `VBoxGuestAdditions.exe`. What is it likely trying to do?",
                        "options": ["Install itself as a service.", "Encrypt the user's files.", "Detect if it is running inside a VirtualBox virtual machine.", "Download an update."],
                        "correct": 2,
                        "explanation": "This is a classic anti-VM technique. The malware looks for artifacts left by virtualization software to determine if it is in an analysis environment."
                    },
                    {
                        "id": 2,
                        "question": "Why might malware use a long 'sleep' call at the beginning of its execution?",
                        "options": ["To save battery power.", "To wait for a specific time of day.", "To evade automated sandboxes that have a limited analysis runtime.", "To give the user a chance to stop it."],
                        "correct": 2,
                        "explanation": "This is a timing-based evasion. The malware waits longer than the sandbox is willing to watch, so its malicious actions are never observed by the automated system."
                    }
                ]
            }
        },
        {
            "id": "lesson-19",
            "title": "Reporting & Intelligence Sharing",
            "duration": "90 min",
            "objectives": [
                "Learn the essential components of a malware analysis report.",
                "Practice mapping observed behaviors to the MITRE ATT&CK framework.",
                "Understand the purpose of threat intelligence sharing standards like STIX/TAXII.",
                "Write a clear, concise report that communicates risk and provides actionable IOCs."
            ],
            "content": {
                "overview": "An analysis is useless if its results are not communicated effectively. The final product of a malware analysis is a report. This lesson covers how to structure a professional report and how the IOCs we generate are used in the broader cyber threat intelligence community.",
                "sections": [
                    {
                        "title": "The Malware Analysis Report",
                        "content": "<p>A good report translates technical findings into business impact. It should include:</p><ul><li><strong>Executive Summary:</strong> A high-level, non-technical overview of the malware's capabilities and risk.</li><li><strong>Static/Dynamic Analysis Details:</strong> A summary of the technical findings.</li><li><strong>Indicators of Compromise (IOCs):</strong> A clear, machine-readable list of all extracted IOCs.</li><li><strong>MITRE ATT&CK Mapping:</strong> A table that maps the observed malware behaviors (e.g., persistence, process injection) to specific ATT&CK technique IDs. This provides a standardized way to describe the adversary's tactics.</li></ul>"
                    },
                    {
                        "title": "Threat Intelligence Sharing",
                        "content": "<p>Standards like STIX (Structured Threat Information eXpression) and TAXII (Trusted Automated eXchange of Intelligence Information) provide a standardized language and protocol for organizations to share threat intelligence (including IOCs) with each other automatically. This allows the community to defend itself more effectively against common threats.</p>"
                    }
                ],
                "codeExamples":[
                {
                    "title": "Create a Detailed STIX 2.1 Report in Python",
                    "language": "python",
                    "code": "# This script shows a defender creating a structured threat intelligence object.\n# This format allows the IOCs to be automatically ingested by security tools.\nimport json\nimport uuid\ndef create_stix_report(file_hash, c2_domain):\n    indicator_id = f\"indicator--{uuid.uuid4()}\"\n    pattern = f\"([file:hashes.'SHA-256' = '{file_hash}'] OR [domain-name:value = '{c2_domain}'])\"\n    report = {\n        \"type\": \"bundle\",\n        \"id\": f\"bundle--{uuid.uuid4()}\",\n        \"objects\": [\n            {\n                \"type\": \"indicator\",\n                \"spec_version\": \"2.1\",\n                \"id\": indicator_id,\n                \"pattern_type\": \"stix\",\n                \"pattern\": pattern\n            }\n        ]\n    }\n    print(json.dumps(report, indent=4))\n# Usage:\n# create_stix_report('...', 'bad-c2.com')"
                },
                {
                    "title": "Query AlienVault OTX API for an IOC",
                    "language": "python",
                    "code": "# Defenders use threat intelligence platforms to enrich their own findings.\n# This script queries the AlienVault OTX API to see if a domain is already known to be malicious.\nimport requests\nAPI_KEY = 'YOUR_OTX_API_KEY'\nDOMAIN = 'google.com' # A benign domain for the example\ndef query_otx(api_key, domain):\n    url = f'https://otx.alienvault.com/api/v1/indicators/domain/{domain}/general'\n    headers = {'X-OTX-API-KEY': api_key}\n    response = requests.get(url, headers=headers)\n    if response.status_code == 200:\n        pulse_count = response.json()['pulse_info']['count']\n        print(f'Domain {domain} is in {pulse_count} threat intelligence pulses.')\n    else:\n        print('Domain not found in OTX or error occurred.')\n\n# query_otx(API_KEY, DOMAIN)"
                },
                {
                    "title": "Create a Markdown Report Template",
                    "language": "markdown",
                    "code": "# This is a template defenders use to structure their reports.\n# It ensures all key sections are included and the information is easy to read.\n\n# Malware Analysis Report: [Sample Name]\n\n## 1. Executive Summary\n\nA brief, non-technical overview of the threat.\n\n## 2. File Identification\n- **MD5:** \n- **SHA256:** \n- **File Size:** \n\n## 3. Behavioral Analysis\n\nA summary of actions observed during dynamic analysis.\n\n## 4. Indicators of Compromise (IOCs)\n\n**File System:**\n- `C:\\path\\to\\dropped.exe`\n\n**Network:**\n- `evil.com`\n\n**Registry:**\n- `HKCU\\Software\\...\\Run\\Malware`\n\n## 5. MITRE ATT&CK Mapping\n\n| Tactic | Technique ID | Name |\n|---|---|---|\n| Persistence | T1547.001 | Registry Run Keys |\n"
                },
                {
                    "title": "Map Keywords to ATT&CK TIDs",
                    "language": "python",
                    "code": "# This is a simple heuristic script that a defender could use to quickly\n# suggest ATT&CK techniques based on keywords found in analysis logs.\n\nATTACK_MAP = {\n    'RegSetValue': 'T1112 - Modify Registry',\n    'CreateRemoteThread': 'T1055 - Process Injection',\n    'schtasks.exe': 'T1053.005 - Scheduled Task'\n}\n\ndef map_log_to_attack(log_file):\n    try:\n        with open(log_file, 'r') as f:\n            log_data = f.read()\n            for keyword, tid in ATTACK_MAP.items():\n                if keyword in log_data:\n                    print(f'Found keyword \"{keyword}\", suggesting MITRE ATT&CK: {tid}')\n    except FileNotFoundError:\n        print('Log file not found.')\n# Usage:\n# map_log_to_attack('procmon_summary.txt')"
                }
              ],
                "activities": [
                    {
                        "title": "Write a Sample IOC Report",
                        "description": "Based on the analysis of a benign sample from a previous lesson, write a short report. The report must include a list of IOCs (file hash, any network domains contacted, any registry keys modified) in a clear, structured format."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary purpose of the MITRE ATT&CK framework in a malware analysis report?",
                        "options": ["To provide a standardized, common language for describing attacker techniques.", "To provide the hash of the malware file.", "To list the contact information of the analyst.", "To explain how to create the malware."],
                        "correct": 0,
                        "explanation": "ATT&CK provides a globally accessible knowledge base of adversary tactics and techniques, which helps analysts to classify and communicate their findings in a universally understood way."
                    },
                    {
                        "id": 2,
                        "question": "The 'Executive Summary' of a malware report is intended for:",
                        "options": ["Deeply technical reverse engineers only.", "A non-technical audience, like management, to understand the overall risk and impact.", "The malware authors.", "An automated system."],
                        "correct": 1,
                        "explanation": "The executive summary is crucial for communicating the 'so what?' of the analysis to decision-makers who may not have a deep technical background."
                    }
                ]
            }
        },
        {
            "id": "lesson-20",
            "title": "Capstone: Full Analysis Walkthrough",
            "duration": "180 min",
            "objectives": [
              "Apply the full analysis methodology (static, behavioral, dynamic) to a new sample.",
              "Correlate findings from different analysis phases to build a complete picture.",
              "Practice overcoming simple obfuscation techniques.",
              "Produce a comprehensive, professional-quality analysis report."
            ],
            "content": {
              "overview": "This final capstone lesson is a practical project that combines all the skills you have learned. You will be given a benign but lightly obfuscated sample and tasked with performing a full analysis from start to finish, culminating in a final report that documents your findings.",
              "sections": [
                {
                  "title": "The Analysis Process",
                  "content": "<p>You will follow the complete workflow:</p><ol><li><strong>Safety First:</strong> Prepare your lab, ensuring network isolation and taking a clean snapshot.</li><li><strong>Static Analysis:</strong> Examine the file with `pefile` and `strings`. Calculate its entropy. Note any initial clues.</li><li><strong>Dynamic/Behavioral Analysis:</strong> Run the sample in your lab with Process Monitor and Wireshark active. Record all its activities.</li><li><strong>Data Consolidation:</strong> Review your logs. What files did it create? What registry keys did it modify? What network connections did it attempt?</li><li><strong>Reporting:</strong> Synthesize all your data into the final report template. Extract all IOCs and map the observed behaviors to the MITRE ATT&CK framework.</li></ol>"
                },
                {
                    "title":"Correlation Example",
                    "content":"<p>During static analysis, you might find a string `config.dat`. During dynamic analysis with ProcMon, you see the process write to a file named `C:\\Users\\Admin\\AppData\\Local\\Temp\\config.dat`. This correlation confirms that the string was not random; it was a filename the malware intended to use, providing a strong host-based IOC.</p>"
                }
              ],
              "codeExamples":[
                {
                    "title": "Master Analysis Automation Script",
                    "language": "python",
                    "code": "# This script shows how a defender might automate their initial triage process.\n# It combines functions from previous lessons into a single pipeline to generate a quick report.\n# (Requires functions like get_hashes, list_imports, find_suspicious_strings to be defined elsewhere)\n\ndef run_full_static_analysis(file_path):\n    print(f'--- Starting Analysis for {file_path} ---')\n    # get_hashes(file_path)\n    # list_imports(file_path)\n    # find_suspicious_strings(file_path)\n    print('--- Analysis Complete ---')\n\n# Usage:\n# run_full_static_analysis('benign_capstone_sample.exe')"
                },
                {
                    "title": "Create System 'Before' Snapshot with PowerShell",
                    "language": "powershell",
                    "code": "# A defender would run a script like this to capture the system state before running malware.\n# This data can then be compared to a post-execution snapshot to find changes.\n$outDir = \".\\state_before\"\nNew-Item -ItemType Directory -Force -Path $outDir\n\nGet-Process | Out-File \"$outDir\\processes.txt\"\nGet-NetTCPConnection | Out-File \"$outDir\\netstat.txt\"\nGet-ScheduledTask | Out-File \"$outDir\\schtasks.txt\"\nreg query HKEY_CURRENT_USER /s > \"$outDir\\registry.txt\"\n\nWrite-Host \"'Before' state captured in $outDir\""
                },
                {
                    "title": "Comprehensive YARA Rule for Capstone",
                    "language": "yara",
                    "code": "/*\nFor the capstone, a defender would create a highly specific YARA rule to detect\nthe sample. This rule combines multiple unique artifacts found during analysis.\n*/\nrule Detect_Capstone_Sample\n{\n    meta:\n        description = \"Detects the benign capstone sample for the final lesson.\"\n    strings:\n        // A unique string found in the binary\n        $s1 = \"CapstoneMagicString123\"\n        // A unique sequence of bytes at the entry point\n        $hex1 = { 55 8B EC 83 E4 F8 81 EC }\n    condition:\n        uint16(0) == 0x5A4D and all of them\n}"
                },
                {
                    "title": "Generate Final Report from IOCs",
                    "language": "python",
                    "code": "# This script takes a dictionary of IOCs and populates the markdown report template.\n# It's the final step in automating the reporting process for a defender.\ndef generate_report_from_iocs(iocs, template_path, output_path):\n    with open(template_path, 'r') as f:\n        template = f.read()\n    \n    template = template.replace('[Sample Name]', iocs['name'])\n    template = template.replace('[MD5]', iocs['hashes']['md5'])\n    # ... and so on for all other IOCs\n\n    with open(output_path, 'w') as f:\n        f.write(template)\n    print(f'Report generated at {output_path}')\n\n# Usage:\n# my_iocs = { 'name': 'capstone.exe', 'hashes': {'md5': '...'}, ...}\n# generate_report_from_iocs(my_iocs, 'template.md', 'final_report.md')"
                }
              ],
              "activities": [
                {
                  "title": "Analyze the Capstone Sample",
                  "description": "Perform a complete static and dynamic analysis of the provided benign capstone sample. Your final deliverable is a multi-page PDF report detailing the sample's properties, behavior, and a full list of extracted Indicators of Compromise."
                }
              ]
            },
            "quiz": {
              "passingScore": 80,
              "questions": [
                {
                  "id": 1,
                  "question": "In the capstone project, when you run the sample, you see it creates a new process and then the original process exits. This is a common technique known as:",
                  "options": ["Persistence", "Process hollowing or a similar injection/spawning technique.", "Data encryption.", "Network beaconing."],
                  "correct": 1,
                  "explanation": "This is a very common behavior where a loader or dropper process is used to launch the main payload, often in a suspended state for injection. It's a key behavioral observation."
                },
                {
                  "id": 2,
                  "question": "The final step of the capstone project, and any real-world analysis, is:",
                  "options": ["Running the malware on your host machine.", "Deleting all your logs and evidence.", "Creating a clear, professional report that communicates your findings to others.", "Contacting the malware author."],
                  "correct": 2,
                  "explanation": "The analysis is only complete once the findings have been documented and communicated in a way that allows defenders to take action."
                }
              ]
            }
        }
    ]
}
      // =====================================================
      // GLOBAL VARIABLES
      // =====================================================
      let currentUser = null;
      let currentLessonIndex = 0;
      let courseProgress = {};
      let userStats = {};
      let quizState = {
        currentQuestion: 0,
        answers: [],
        score: 0,
        isComplete: false,
      };

      // Enhanced session tracking
      let courseSession = {
        startTime: null,
        totalStudyTime: 0,
        lessonsStarted: 0,
        lessonsCompleted: 0,
        pageLoadTime: new Date(),
        interactionCount: 0,
        lastActivityTime: new Date(),
      };

      // Music Player Variables
      let audioPlayer = new Audio();

      // Achievement notification system
      let notificationQueue = [];
      let isShowingNotification = false;

      // =====================================================
      // INITIALIZATION
      // =====================================================
      document.addEventListener("DOMContentLoaded", async () => {
        try {
          showLoadingScreen();
          await checkAuth();

          if (currentUser) {
            // Initialize session tracking
            startCourseSession();

            // Load course data and progress
            await loadCourseData();
            await loadUserProfile();
            await loadProgress();

            // Initialize UI
            initializeEventListeners();
            renderSidebar();
            loadLesson(currentLessonIndex);

            // Initialize additional features
            initMusicPlayer();
            addMusicIndicator();
            initializeActivityTracking();

            hideLoadingScreen();
          } else {
            openAuthModal();
          }
        } catch (error) {
          console.error("Error initializing course:", error);
          hideLoadingScreen();
          showToast("Failed to initialize course system", "error");
        }
      });

      // =====================================================
      // AUTHENTICATION SYSTEM
      // =====================================================
      async function checkAuth() {
        try {
          const {
            data: { session },
            error,
          } = await supabase.auth.getSession();

          if (error) {
            console.error("Auth error:", error);
            currentUser = null;
            openAuthModal();
            return;
          }

          if (!session) {
            currentUser = null;
            openAuthModal();
            return;
          }

          currentUser = session.user;
          updateUIWithUser();
        } catch (error) {
          console.error("Error checking auth:", error);
          currentUser = null;
          openAuthModal();
        }
      }

      function updateUIWithUser() {
        if (!currentUser) return;

        const name =
          currentUser.user_metadata?.full_name ||
          currentUser.email.split("@")[0];
        const userElements = document.querySelectorAll("[data-user-name]");
        userElements.forEach((el) => (el.textContent = name));
      }

      // =====================================================
      // USER PROFILE & STATS MANAGEMENT
      // =====================================================
      async function loadUserProfile() {
        try {
          //  Step 1: Try to fetch existing profile
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("*")
            .eq("id", currentUser.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (!profile) {
            //  Step 2: Create new profile if missing
            await createUserProfile();
          } else {
            //  Step 3: Use existing profile
            userStats = profile;
            await updateLastActivity();
          }
        } catch (error) {
          console.error(" Error loading user profile:", error);
          showToast("Failed to load user profile", "error");
        }
      }
      async function createUserProfile() {
        try {
          const newProfile = {
            id: currentUser.id,
            full_name: currentUser.user_metadata?.full_name || "",
            email: currentUser.email,
            level: "Script Kiddie",
            total_points: 0,
            completed_courses: 0,
            current_streak: 0,
            total_certificates: 0,
            total_achievements: 0,
            sections_visited: 0,
            bonus_points: 0,
            in_progress_courses: 0,
            settings_changed: 0,
            midnight_sessions: 0,
            early_sessions: 0,
            weekend_sessions: 0,
            last_activity: new Date().toISOString(),
            created_at: new Date().toISOString(),
          };

          const { error } = await supabase
            .from("profiles")
            .insert([newProfile]);

          if (!error) {
            userStats = newProfile;
            // Award first login achievement
            setTimeout(() => checkAndUnlockAchievement("first_login"), 1000);
          }
        } catch (error) {
          console.error("Error creating user profile:", error);
        }
      }

      async function updateLastActivity() {
        try {
          const now = new Date();

          // Update activity tracking
          courseSession.lastActivityTime = now;

          // Update database
          await supabase
            .from("profiles")
            .update({
              last_activity: now.toISOString(),
            })
            .eq("id", currentUser.id);

          // Check time-based achievements
          await checkTimeBasedAchievements(now);
        } catch (error) {
          console.error("Error updating last activity:", error);
        }
      }

      // =====================================================
      // COURSE SESSION MANAGEMENT
      // =====================================================
      function startCourseSession() {
        courseSession.startTime = new Date();
        courseSession.pageLoadTime = new Date();

        logUserActivity("course_session_start", {
          course_id: COURSE_DATA.id,
          course_title: COURSE_DATA.title,
          user_agent: navigator.userAgent,
          screen_resolution: `${screen.width}x${screen.height}`,
        });

        // Check daily streak
        checkDailyStreak();
      }

      function initializeActivityTracking() {
        // Track page focus/blur for accurate study time
        document.addEventListener("visibilitychange", handleVisibilityChange);

        // Track user interactions
        ["click", "keydown", "scroll", "mousemove"].forEach((event) => {
          document.addEventListener(event, trackUserInteraction, {
            passive: true,
          });
        });

        // Periodic activity updates
        setInterval(updateStudyTime, 60000); // Every minute

        // Save session data before page unload
        window.addEventListener("beforeunload", saveSessionData);
      }

      function handleVisibilityChange() {
        if (document.hidden) {
          courseSession.lastActivityTime = new Date();
        } else {
          // Page became visible again - update activity
          updateLastActivity();
        }
      }

      function trackUserInteraction() {
        courseSession.interactionCount++;
        courseSession.lastActivityTime = new Date();

        // Throttle activity updates
        if (courseSession.interactionCount % 50 === 0) {
          updateLastActivity();
        }
      }

      function updateStudyTime() {
        if (!courseSession.startTime || document.hidden) return;

        const now = new Date();
        const sessionDuration = now - courseSession.startTime;
        courseSession.totalStudyTime = Math.floor(sessionDuration / 1000 / 60); // in minutes

        // Update progress with study time
        saveProgress();
      }

      function saveSessionData() {
        if (!currentUser || !courseSession.startTime) return;

        const sessionData = {
          user_id: currentUser.id,
          course_id: COURSE_DATA.id,
          session_duration: courseSession.totalStudyTime,
          lessons_viewed: courseSession.lessonsStarted,
          lessons_completed: courseSession.lessonsCompleted,
          interactions: courseSession.interactionCount,
          session_date: courseSession.startTime.toISOString().split("T")[0],
        };

        // Store in localStorage as backup
        localStorage.setItem(
          "course_session_backup",
          JSON.stringify(sessionData)
        );

        // Try to save to database
        logUserActivity("course_session_end", sessionData);
      }

      // =====================================================
      // COURSE DATA & PROGRESS MANAGEMENT
      // =====================================================
      async function loadCourseData() {
        try {
          // Update course info in UI
          document.getElementById("courseTitle").textContent =
            COURSE_DATA.title;
          document.getElementById("totalLessons").textContent =
            COURSE_DATA.lessons.length;

          // Log course access
          logUserActivity("course_access", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
          });
        } catch (error) {
          console.error("Error loading course data:", error);
        }
      }

      async function loadProgress() {
        try {
          // Get existing progress from database
          const { data, error } = await supabase
            .from("course_progress")
            .select("*")
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (data) {
            courseProgress = JSON.parse(data.lesson_progress || "{}");
            currentLessonIndex = data.current_lesson || 0;

            // Update session tracking
            courseSession.lessonsStarted = Object.keys(courseProgress).length;
            courseSession.lessonsCompleted = Object.values(
              courseProgress
            ).filter((p) => p.completed).length;
          } else {
            // Initialize new progress
            courseProgress = {};
            currentLessonIndex = 0;
            await saveProgress();

            // Award first course start achievement
            await checkAndUnlockAchievement("first_course_start");
          }

          updateProgressDisplay();
        } catch (error) {
          console.error("Error loading progress:", error);
          showToast("Failed to load progress", "error");
        }
      }

      async function saveProgress() {
        try {
          if (!currentUser) return;

          const now = new Date();
          const progressData = {
            user_id: currentUser.id,
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            current_lesson: currentLessonIndex,
            lesson_progress: JSON.stringify(courseProgress),
            progress: calculateOverallProgress(),
            lessons_completed: getCompletedLessonsCount(),
            lessons_started: Object.keys(courseProgress).length,
            study_time_minutes: courseSession.totalStudyTime,
            last_accessed: now.toISOString(),
            updated_at: now.toISOString(),
          };

          // Upsert progress
          const { error } = await supabase
            .from("course_progress")
            .upsert([progressData]);

          if (error) throw error;

          // Update user stats
          await updateUserStats();

          updateProgressDisplay();
        } catch (error) {
          console.error("Error saving progress:", error);
          showToast("Failed to save progress", "error");
        }
      }

      async function updateUserStats() {
        try {
          // Get all course progress for this user
          const { data: allProgress, error } = await supabase
            .from("course_progress")
            .select("progress, course_id, study_time_minutes")
            .eq("user_id", currentUser.id);

          if (error) throw error;

          // Calculate stats
          const completedCourses =
            allProgress?.filter((p) => p.progress >= 100).length || 0;
          const inProgressCourses =
            allProgress?.filter((p) => p.progress > 0 && p.progress < 100)
              .length || 0;
          const totalStudyTime =
            allProgress?.reduce(
              (sum, p) => sum + (p.study_time_minutes || 0),
              0
            ) || 0;

          // Calculate points (500 per completed course + achievement points)
          const coursePoints = completedCourses * 500;
          const bonusPoints = userStats.bonus_points || 0;
          const totalPoints = coursePoints + bonusPoints;

          // Update profile
          const updateData = {
            completed_courses: completedCourses,
            in_progress_courses: inProgressCourses,
            total_points: totalPoints,
            total_study_time: totalStudyTime,
            last_activity: new Date().toISOString(),
          };

          const { error: updateError } = await supabase
            .from("profiles")
            .update(updateData)
            .eq("id", currentUser.id);

          if (updateError) throw updateError;

          // Update local stats
          Object.assign(userStats, updateData);
        } catch (error) {
          console.error("Error updating user stats:", error);
        }
      }

      function calculateOverallProgress() {
        const completedLessons = getCompletedLessonsCount();
        return Math.round(
          (completedLessons / COURSE_DATA.lessons.length) * 100
        );
      }

      function getCompletedLessonsCount() {
        return Object.values(courseProgress).filter(
          (lesson) => lesson.completed
        ).length;
      }

      function updateProgressDisplay() {
        const completedCount = getCompletedLessonsCount();
        const progressPercent = calculateOverallProgress();

        // Update UI elements
        const elements = {
          completedLessons: completedCount,
          courseProgressPercent: `${progressPercent}%`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });

        // Update progress bar
        const progressBar = document.getElementById("courseProgressFill");
        if (progressBar) progressBar.style.width = `${progressPercent}%`;
      }

      // =====================================================
      // LESSON MANAGEMENT
      // =====================================================
      function loadLesson(index) {
        if (index < 0 || index >= COURSE_DATA.lessons.length) return;

        const lesson = COURSE_DATA.lessons[index];
        currentLessonIndex = index;

        // Mark lesson as started and track activity
        if (!courseProgress[lesson.id]) {
          courseProgress[lesson.id] = {
            started: true,
            completed: false,
            startedAt: new Date().toISOString(),
            timeSpent: 0,
          };

          courseSession.lessonsStarted++;
          saveProgress();

          // Log lesson start
          logUserActivity("lesson_start", {
            lesson_id: lesson.id,
            lesson_title: lesson.title,
            lesson_index: index,
          });
        }

        // Update lesson start time for time tracking
        courseProgress[lesson.id].currentSessionStart = new Date();

        // Update sidebar and navigation
        renderSidebar();
        updateNavigationButtons();

        // Update header info
        updateLessonHeader(lesson, index);

        // Render lesson content
        renderLessonContent(lesson);

        // Smooth scroll and animations
        window.scrollTo({ top: 0, behavior: "smooth" });
        document.getElementById("contentBody").scrollTop = 0;

        const contentBody = document.getElementById("contentBody");
        contentBody.classList.add("fade-in");
        setTimeout(() => contentBody.classList.remove("fade-in"), 500);

        // Check lesson-based achievements
        checkLessonAchievements(index + 1);
      }

      function updateLessonHeader(lesson, index) {
        const elements = {
          currentLessonNumber: index + 1,
          currentLessonTitle: lesson.title,
          navInfo: `Lesson ${index + 1} of ${COURSE_DATA.lessons.length}`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });
      }

      function renderSidebar() {
        const lessonNav = document.getElementById("lessonNav");
        if (!lessonNav) return;

        lessonNav.innerHTML = "";

        COURSE_DATA.lessons.forEach((lesson, index) => {
          const lessonItem = document.createElement("div");
          lessonItem.className = "lesson-item";

          // Determine lesson status
          const lessonProgress = courseProgress[lesson.id];
          const isCompleted = lessonProgress?.completed || false;
          const isInProgress = lessonProgress?.started || false;
          const isLocked = !isCompleted && !canAccessLesson(index);
          const isActive = index === currentLessonIndex;

          // Apply status classes
          if (isCompleted) lessonItem.classList.add("completed");
          if (isLocked) lessonItem.classList.add("locked");
          if (isActive) lessonItem.classList.add("active");

          // Determine status display
          let statusClass = "not-started";
          let statusIcon = index + 1;

          if (isCompleted) {
            statusClass = "completed";
            statusIcon = "";
          } else if (isInProgress) {
            statusClass = "in-progress";
            statusIcon = "";
          }

          // Create lesson item HTML
          lessonItem.innerHTML = `
            <div class="lesson-status ${statusClass}">${statusIcon}</div>
            <div class="lesson-info">
                <div class="lesson-title">${lesson.title}</div>
                <div class="lesson-meta">
                    ${
                      isCompleted
                        ? "Completed"
                        : isInProgress
                        ? "In Progress"
                        : isLocked
                        ? "Locked"
                        : "Not Started"
                    }
                </div>
            </div>
            <div class="lesson-duration">${lesson.duration}</div>
        `;

          // Add click handler if not locked
          if (!isLocked) {
            lessonItem.addEventListener("click", () => {
              if (index !== currentLessonIndex) {
                // Track lesson time before switching
                trackLessonTime();

                currentLessonIndex = index;
                loadLesson(index);
                closeSidebar();
              }
            });
          }

          lessonNav.appendChild(lessonItem);
        });
      }

      function canAccessLesson(index) {
        if (index === 0) return true; // First lesson always accessible

        // Can access if previous lesson is completed
        const previousLessonId = COURSE_DATA.lessons[index - 1].id;
        return courseProgress[previousLessonId]?.completed || false;
      }

      function trackLessonTime() {
        const currentLesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonProgress = courseProgress[currentLesson.id];

        if (lessonProgress?.currentSessionStart) {
          const sessionTime = Math.floor(
            (new Date() - new Date(lessonProgress.currentSessionStart)) /
              1000 /
              60
          );
          lessonProgress.timeSpent =
            (lessonProgress.timeSpent || 0) + sessionTime;
          delete lessonProgress.currentSessionStart;
        }
      }

      // =====================================================
      // LESSON CONTENT RENDERING
      // =====================================================
      function renderLessonContent(lesson) {
        const contentContainer = document.getElementById("lessonContent");
        if (!contentContainer) return;

        let contentHTML = `
        <div class="content-section">
            <h2>Learning Objectives</h2>
            <ul>
                ${lesson.objectives.map((obj) => `<li>${obj}</li>`).join("")}
            </ul>
        </div>
        
        <div class="content-section">
            <h2>Overview</h2>
            <p>${lesson.content.overview}</p>
        </div>
    `;

        // Render content sections
        lesson.content.sections.forEach((section) => {
          contentHTML += `
            <div class="content-section">
                <h2>${section.title}</h2>
                ${section.content}
                ${
                  section.image
                    ? `<img src="${section.image}" alt="${section.title}" class="content-image" loading="lazy">`
                    : ""
                }
            </div>
        `;
        });

        // Render code examples
        if (
          lesson.content.codeExamples &&
          lesson.content.codeExamples.length > 0
        ) {
          contentHTML += `<div class="content-section"><h2>Code Examples</h2></div>`;

          lesson.content.codeExamples.forEach((example, index) => {
            const codeId = `code-${lesson.id}-${index}`;
            contentHTML += `
                <div class="code-section">
                    <div class="code-header">
                        <span class="code-title">${example.title}</span>
                        <button class="copy-btn" onclick="copyCode('${codeId}')">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <pre class="code-block"><code id="${codeId}" class="language-${
              example.language
            }">${escapeHtml(example.code)}</code></pre>
                </div>
            `;
          });
        }

        // Render quiz
        contentHTML += renderQuiz(lesson.quiz);

        contentContainer.innerHTML = contentHTML;

        // Highlight code syntax if Prism is available
        setTimeout(() => {
          if (window.Prism) {
            Prism.highlightAll();
          }
        }, 100);
      }

      // =====================================================
      // QUIZ SYSTEM
      // =====================================================
      function renderQuiz(quiz) {
        const currentLessonProgress =
          courseProgress[COURSE_DATA.lessons[currentLessonIndex].id];
        const isCompleted = currentLessonProgress?.completed || false;

        let quizHTML = `
        <div class="quiz-section" id="quizSection">
            <div class="quiz-header">
                <h2 class="quiz-title">
                    <i class="fas fa-clipboard-check"></i>
                    Knowledge Check
                </h2>
                <p class="quiz-info">
                    Complete this quiz with ${quiz.passingScore}% or higher to unlock the next lesson.
                </p>
            </div>
    `;

        if (isCompleted) {
          const savedScore = currentLessonProgress.quizScore || 0;
          quizHTML += `
            <div class="quiz-results show">
                <div class="quiz-score pass">${savedScore}%</div>
                <div class="quiz-message">
                    <strong>Lesson Completed!</strong><br>
                    You've successfully passed this lesson's quiz.
                </div>
            </div>
        `;
        } else {
          // Render quiz questions
          quiz.questions.forEach((question, qIndex) => {
            quizHTML += `
                <div class="quiz-question ${
                  qIndex === 0 ? "active" : ""
                }" data-question="${qIndex}">
                    <div class="question-header">
                        <span class="question-number">Question ${
                          qIndex + 1
                        }</span>
                        <span class="question-progress">${qIndex + 1}/${
              quiz.questions.length
            }</span>
                    </div>
                    <div class="question-text">${question.question}</div>
                    <div class="question-options">
                        ${question.options
                          .map(
                            (option, oIndex) => `
                            <div class="option" data-option="${oIndex}" onclick="selectOption(${qIndex}, ${oIndex})">
                                <span class="option-letter">${String.fromCharCode(
                                  65 + oIndex
                                )}</span>
                                <span class="option-text">${option}</span>
                            </div>
                        `
                          )
                          .join("")}
                    </div>
                </div>
            `;
          });

          quizHTML += `
            <div class="quiz-controls">
                <button class="btn btn-secondary" id="prevQuestionBtn" onclick="previousQuestion()" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <div>
                    <button class="btn btn-secondary" id="nextQuestionBtn" onclick="nextQuestion()" disabled>
                        Next
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <button class="btn btn-primary" id="submitQuizBtn" onclick="submitQuiz()" style="display: none;">
                        <i class="fas fa-check"></i>
                        Submit Quiz
                    </button>
                </div>
            </div>

            <div class="quiz-results" id="quizResults">
                <div class="quiz-score" id="quizScore">0%</div>
                <div class="quiz-message" id="quizMessage"></div>
                <div class="quiz-actions">
                    <button class="btn btn-primary" id="continueBtn" onclick="completeLesson()" style="display: none;">
                        <i class="fas fa-arrow-right"></i>
                        Continue to Next Lesson
                    </button>
                    <button class="btn btn-secondary" onclick="retakeQuiz()">
                        <i class="fas fa-redo"></i>
                        Retake Quiz
                    </button>
                </div>
            </div>
        `;
        }

        quizHTML += "</div>";
        return quizHTML;
      }

      // Quiz interaction functions
      function selectOption(questionIndex, optionIndex) {
        // Clear previous selections
        document
          .querySelectorAll(`[data-question="${questionIndex}"] .option`)
          .forEach((opt) => {
            opt.classList.remove("selected");
          });

        // Select current option
        const selectedOption = document.querySelector(
          `[data-question="${questionIndex}"] [data-option="${optionIndex}"]`
        );
        selectedOption.classList.add("selected");

        // Store answer
        quizState.answers[questionIndex] = optionIndex;

        // Update navigation
        const isLastQuestion =
          questionIndex ===
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length - 1;
        if (isLastQuestion) {
          document.getElementById("submitQuizBtn").style.display =
            "inline-flex";
          document.getElementById("nextQuestionBtn").style.display = "none";
        } else {
          document.getElementById("nextQuestionBtn").disabled = false;
        }
      }

      function nextQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const nextQuestionEl = currentQuestionEl.nextElementSibling;

        if (
          nextQuestionEl &&
          nextQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          nextQuestionEl.classList.add("active");
          quizState.currentQuestion++;
          updateQuizNavigation();
        }
      }

      function previousQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const prevQuestionEl = currentQuestionEl.previousElementSibling;

        if (
          prevQuestionEl &&
          prevQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          prevQuestionEl.classList.add("active");
          quizState.currentQuestion--;
          updateQuizNavigation();
        }
      }

      function updateQuizNavigation() {
        const totalQuestions =
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length;
        const prevBtn = document.getElementById("prevQuestionBtn");
        const nextBtn = document.getElementById("nextQuestionBtn");
        const submitBtn = document.getElementById("submitQuizBtn");

        prevBtn.disabled = quizState.currentQuestion === 0;

        const hasAnswer =
          quizState.answers[quizState.currentQuestion] !== undefined;
        const isLastQuestion = quizState.currentQuestion === totalQuestions - 1;

        if (isLastQuestion) {
          nextBtn.style.display = "none";
          submitBtn.style.display = hasAnswer ? "inline-flex" : "none";
        } else {
          nextBtn.style.display = "inline-flex";
          nextBtn.disabled = !hasAnswer;
          submitBtn.style.display = "none";
        }
      }

      async function submitQuiz() {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const quiz = lesson.quiz;
        let correctAnswers = 0;

        // Hide questions and controls
        document
          .querySelectorAll(".quiz-question")
          .forEach((q) => (q.style.display = "none"));
        document.querySelector(".quiz-controls").style.display = "none";

        // Calculate score and highlight answers
        quiz.questions.forEach((question, index) => {
          const userAnswer = quizState.answers[index];
          const correctAnswer = question.correct;
          const isCorrect = userAnswer === correctAnswer;

          if (isCorrect) correctAnswers++;

          // Highlight answers
          const questionEl = document.querySelector(
            `[data-question="${index}"]`
          );
          const options = questionEl.querySelectorAll(".option");

          options[correctAnswer].classList.add("correct");
          if (userAnswer !== correctAnswer && userAnswer !== undefined) {
            options[userAnswer].classList.add("incorrect");
          }
        });

        const score = Math.round(
          (correctAnswers / quiz.questions.length) * 100
        );
        const passed = score >= quiz.passingScore;

        // Update quiz results UI
        const quizScore = document.getElementById("quizScore");
        const quizMessage = document.getElementById("quizMessage");
        const quizActions = document.querySelector(".quiz-actions");

        quizScore.textContent = `${score}%`;
        quizScore.className = `quiz-score ${passed ? "pass" : "fail"}`;

        if (passed) {
          quizMessage.innerHTML = `
            <strong>Congratulations!</strong><br>
            You passed with ${score}%. You can now proceed to the next lesson.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-primary" onclick="completeLesson()">
                <i class="fas fa-arrow-right"></i>
                Continue to Next Lesson
            </button>
        `;

          // Mark lesson as completed
          await markLessonComplete(score);
        } else {
          quizMessage.innerHTML = `
            <strong>Not quite there yet.</strong><br>
            You scored ${score}%. You need ${quiz.passingScore}% to pass. Review the material and try again.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-secondary" onclick="retakeQuiz()">
                <i class="fas fa-redo"></i>
                Retake Quiz
            </button>
        `;
        }

        document.getElementById("quizResults").classList.add("show");

        // Log quiz completion
        logUserActivity("quiz_completed", {
          lesson_id: lesson.id,
          lesson_title: lesson.title,
          score: score,
          passed: passed,
          attempts: (courseProgress[lesson.id]?.quizAttempts || 0) + 1,
        });

        // Scroll to results
        document
          .getElementById("quizResults")
          .scrollIntoView({ behavior: "smooth" });
      }

      function retakeQuiz() {
        // Reset quiz state
        quizState = {
          currentQuestion: 0,
          answers: [],
          score: 0,
          isComplete: false,
        };

        // Track quiz retry
        const lessonId = COURSE_DATA.lessons[currentLessonIndex].id;
        if (!courseProgress[lessonId]) courseProgress[lessonId] = {};
        courseProgress[lessonId].quizAttempts =
          (courseProgress[lessonId].quizAttempts || 0) + 1;

        // Reload lesson content
        loadLesson(currentLessonIndex);

        // Scroll to quiz
        setTimeout(() => {
          document
            .getElementById("quizSection")
            .scrollIntoView({ behavior: "smooth" });
        }, 500);
      }

      async function markLessonComplete(score) {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonId = lesson.id;

        // Track lesson completion time
        trackLessonTime();

        // Update lesson progress
        courseProgress[lessonId] = {
          ...courseProgress[lessonId],
          completed: true,
          quizScore: score,
          completedAt: new Date().toISOString(),
          finalScore: score,
        };

        // Update session tracking
        courseSession.lessonsCompleted++;

        // Save progress to database
        await saveProgress();

        // Update UI
        renderSidebar();
        updateNavigationButtons();

        // Check various achievements
        await checkLessonCompletionAchievements();
        await checkPerfectScoreAchievements(score);
        await checkStudyTimeAchievements();

        // Log lesson completion
        logUserActivity("lesson_completed", {
          lesson_id: lessonId,
          lesson_title: lesson.title,
          final_score: score,
          time_spent: courseProgress[lessonId].timeSpent || 0,
          lesson_number: currentLessonIndex + 1,
        });

        showToast("Lesson completed successfully!", "success");
      }

      async function completeLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          // Move to next lesson
          currentLessonIndex++;
          loadLesson(currentLessonIndex);
        } else {
          // Course completion
          await completeCourse();
        }
      }

      async function completeCourse() {
        try {
          const completionTime = courseSession.totalStudyTime;

          // Update course progress to 100% completed
          await supabase
            .from("course_progress")
            .update({
              progress: 100,
              completed_at: new Date().toISOString(),
              completion_time_minutes: completionTime,
            })
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Award course completion achievements
          await checkAndUnlockAchievement("course_completion_1");
          await checkSpeedCompletionAchievements(completionTime);
          await checkCourseStreakAchievements();

          // Update user stats
          await updateUserStats();

          // Show completion message
          showToast(
            "Congratulations! Course completed successfully!",
            "certificate"
          );

          // Log course completion
          logUserActivity("course_completed", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            completion_time_minutes: completionTime,
            total_lessons: COURSE_DATA.lessons.length,
            average_quiz_score: calculateAverageQuizScore(),
          });

          // Redirect to dashboard after delay
          setTimeout(() => {
            window.location.href = "/dashboard.html";
          }, 3000);
        } catch (error) {
          console.error("Error completing course:", error);
          showToast("Error marking course as complete", "error");
        }
      }

      // =====================================================
      // ACHIEVEMENT INTEGRATION SYSTEM
      // =====================================================
      async function checkAndUnlockAchievement(
        achievementId,
        skipNotification = false
      ) {
        try {
          // Prevent duplicate checks
          const cacheKey = `achievement_${achievementId}_${currentUser.id}`;
          if (sessionStorage.getItem(cacheKey)) return false;

          // Check if already unlocked
          const { data: existing, error } = await supabase
            .from("user_achievements")
            .select("id")
            .eq("user_id", currentUser.id)
            .eq("achievement_id", achievementId)
            .single();

          if (existing) {
            sessionStorage.setItem(cacheKey, "true");
            return false;
          }

          // Award achievement
          const achievementData = {
            user_id: currentUser.id,
            achievement_id: achievementId,
            unlocked_at: new Date().toISOString(),
            points_awarded: getAchievementPoints(achievementId),
            context: "course_system",
          };

          const { data, error: insertError } = await supabase
            .from("user_achievements")
            .insert([achievementData])
            .select()
            .single();

          if (insertError) {
            if (insertError.code === "23505") return false; // Already exists
            throw insertError;
          }

          // Update user points
         await supabase.rpc('increment_user_stats', {
  user_id_param: currentUser.id,
  points_to_add: achievementData.points_awarded,
  achievements_to_add: 1
});

          // Cache and queue notification
          sessionStorage.setItem(cacheKey, "true");

          if (!skipNotification) {
            queueAchievementNotification({
              id: achievementId,
              name: getAchievementName(achievementId),
              description: getAchievementDescription(achievementId),
              points: achievementData.points_awarded,
              rarity: getAchievementRarity(achievementId),
              icon: getAchievementIcon(achievementId),
            });
          }

          return true;
        } catch (error) {
          console.error("Error unlocking achievement:", error);
          return false;
        }
      }

      // Helper functions for achievement data (replace with your actual achievement definitions)
      function getAchievementPoints(id) {
        const pointsMap = {
          first_course_start: 75,
          first_lesson: 100,
          course_completion_1: 500,
          perfect_score: 250,
          speed_demon: 750,
          marathon_learner: 500,
          night_owl: 200,
          early_bird: 200,
          weekend_warrior: 150,
          // Add more as needed
        };
        return pointsMap[id] || 100;
      }

      function getAchievementName(id) {
        const nameMap = {
          first_course_start: "Learning Initiated",
          first_lesson: "First Steps",
          course_completion_1: "Course Conqueror",
          perfect_score: "Perfectionist",
          speed_demon: "Speed Demon",
          // Add more as needed
        };
        return nameMap[id] || "Achievement Unlocked";
      }

      function getAchievementDescription(id) {
        const descMap = {
          first_course_start: "Start your first cybersecurity course",
          first_lesson: "Complete your first lesson",
          course_completion_1: "Complete your first course",
          perfect_score: "Score 100% on any quiz",
          speed_demon: "Complete a course in under 2 hours",
          // Add more as needed
        };
        return descMap[id] || "Achievement description";
      }

      function getAchievementRarity(id) {
        const rarityMap = {
          first_course_start: "common",
          first_lesson: "bronze",
          course_completion_1: "silver",
          perfect_score: "gold",
          speed_demon: "legendary",
          // Add more as needed
        };
        return rarityMap[id] || "common";
      }

      function getAchievementIcon(id) {
        const iconMap = {
          first_course_start: "fas fa-play",
          first_lesson: "fas fa-baby",
          course_completion_1: "fas fa-trophy",
          perfect_score: "fas fa-star",
          speed_demon: "fas fa-rocket",
          // Add more as needed
        };
        return iconMap[id] || "fas fa-award";
      }

      async function checkLessonAchievements(lessonNumber) {
        if (lessonNumber === 1) {
          await checkAndUnlockAchievement("first_lesson");
        }

        // Check if user has completed multiple lessons in one day
        const today = new Date().toISOString().split("T")[0];
        const todayCompletions = Object.values(courseProgress).filter(
          (p) => p.completed && p.completedAt?.startsWith(today)
        ).length;

        if (todayCompletions >= 3) {
          await checkAndUnlockAchievement("lesson_marathon");
        }
      }

      async function checkLessonCompletionAchievements() {
        const completedCount = getCompletedLessonsCount();

        // Lesson-based achievements
        const lessonMilestones = [1, 5, 10, 25, 50, 100];
        for (const milestone of lessonMilestones) {
          if (completedCount >= milestone) {
            await checkAndUnlockAchievement(`lessons_${milestone}`);
          }
        }

        // Course completion achievements
        if (completedCount === COURSE_DATA.lessons.length) {
          await checkAndUnlockAchievement("course_completion_1");

          // Check for additional course completion achievements
          const { data: allCourses } = await supabase
            .from("course_progress")
            .select("course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100);

          const totalCompleted = allCourses?.length || 0;

          const courseMilestones = [1, 5, 10, 25];
          for (const milestone of courseMilestones) {
            if (totalCompleted >= milestone) {
              await checkAndUnlockAchievement(`course_completion_${milestone}`);
            }
          }
        }
      }

      async function checkPerfectScoreAchievements(score) {
        if (score === 100) {
          await checkAndUnlockAchievement("perfect_score");

          // Check for consecutive perfect scores
          const recentScores = Object.values(courseProgress)
            .filter((p) => p.completed && p.quizScore)
            .slice(-5) // Last 5 completed
            .map((p) => p.quizScore);

          if (
            recentScores.length >= 3 &&
            recentScores.every((s) => s === 100)
          ) {
            await checkAndUnlockAchievement("perfectionist_streak");
          }
        }
      }

      async function checkSpeedCompletionAchievements(completionTime) {
        // Speed demon: Complete course in under 2 hours (120 minutes)
        if (completionTime <= 120) {
          await checkAndUnlockAchievement("speed_demon");
        }

        // Quick learner: Complete course in under 4 hours (240 minutes)
        if (completionTime <= 240) {
          await checkAndUnlockAchievement("quick_learner");
        }
      }

      async function checkStudyTimeAchievements() {
        const totalTime = courseSession.totalStudyTime;

        // Marathon learner: Study for 8+ hours in a course session
        if (totalTime >= 480) {
          // 8 hours
          await checkAndUnlockAchievement("marathon_learner");
        }

        // Dedicated learner: Study for 4+ hours
        if (totalTime >= 240) {
          // 4 hours
          await checkAndUnlockAchievement("dedicated_learner");
        }
      }

      async function checkCourseStreakAchievements() {
        try {
          // Check for consecutive course completions
          const { data: recentCourses, error } = await supabase
            .from("course_progress")
            .select("completed_at, course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100)
            .order("completed_at", { ascending: false })
            .limit(10);

          if (error || !recentCourses) return;

          // Check for courses completed on consecutive days
          let consecutiveDays = 1;
          for (let i = 1; i < recentCourses.length; i++) {
            const prevDate = new Date(
              recentCourses[i - 1].completed_at
            ).toDateString();
            const currentDate = new Date(
              recentCourses[i].completed_at
            ).toDateString();
            const dayDiff =
              Math.abs(new Date(prevDate) - new Date(currentDate)) /
              (1000 * 60 * 60 * 24);

            if (dayDiff <= 1) {
              consecutiveDays++;
            } else {
              break;
            }
          }

          if (consecutiveDays >= 3) {
            await checkAndUnlockAchievement("learning_streak");
          }
        } catch (error) {
          console.error("Error checking course streak achievements:", error);
        }
      }

      // =====================================================
      // TIME-BASED ACHIEVEMENTS
      // =====================================================
      async function checkTimeBasedAchievements(timestamp) {
        const hour = timestamp.getHours();
        const dayOfWeek = timestamp.getDay();

        // Night owl (after midnight, before 6 AM)
        if (hour >= 0 && hour < 6) {
          await incrementTimeBasedCounter("midnight_sessions", "night_owl");
        }

        // Early bird (4 AM to 6 AM)
        if (hour >= 4 && hour < 6) {
          await incrementTimeBasedCounter("early_sessions", "early_bird");
        }

        // Weekend warrior (Saturday = 6, Sunday = 0)
        if (dayOfWeek === 0 || dayOfWeek === 6) {
          await incrementTimeBasedCounter(
            "weekend_sessions",
            "weekend_warrior"
          );
        }
      }

      async function incrementTimeBasedCounter(counterType, achievementId) {
        try {
          const dateStr = new Date().toISOString().split("T")[0];
          const cacheKey = `${counterType}_${currentUser.id}_${dateStr}`;

          // Prevent multiple increments per day
          if (sessionStorage.getItem(cacheKey)) return;

          // Update counter
          await supabase
            .from("profiles")
            .update({
              [counterType]: supabase.sql`${counterType} + 1`,
            })
            .eq("id", currentUser.id);

          // Cache to prevent double counting
          sessionStorage.setItem(cacheKey, "true");

          // Check related achievement
          if (achievementId) {
            await checkAndUnlockAchievement(achievementId, true);
          }
        } catch (error) {
          console.error(`Error incrementing ${counterType}:`, error);
        }
      }

      async function checkDailyStreak() {
        try {
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("last_activity, current_streak, last_streak_date")
            .eq("id", currentUser.id)
            .single();

          if (error) throw error;

          const now = new Date();
          const today = now.toDateString();
          const lastActivity = profile.last_activity
            ? new Date(profile.last_activity)
            : null;
          const lastStreakDate = profile.last_streak_date
            ? new Date(profile.last_streak_date).toDateString()
            : null;

          let newStreak = profile.current_streak || 0;
          let shouldUpdateStreak = false;

          if (!lastActivity) {
            // First time user
            newStreak = 1;
            shouldUpdateStreak = true;
          } else {
            const daysSinceLastActivity = Math.floor(
              (now - lastActivity) / (1000 * 60 * 60 * 24)
            );

            if (lastStreakDate === today) {
              // Already counted today's streak
              return newStreak;
            } else if (
              daysSinceLastActivity === 1 ||
              (daysSinceLastActivity === 0 && lastStreakDate !== today)
            ) {
              // Consecutive day or same day but not counted yet
              newStreak += 1;
              shouldUpdateStreak = true;
            } else if (daysSinceLastActivity > 1) {
              // Streak broken
              newStreak = 1;
              shouldUpdateStreak = true;
            }
          }

          if (shouldUpdateStreak) {
            await supabase
              .from("profiles")
              .update({
                current_streak: newStreak,
                last_activity: now.toISOString(),
                last_streak_date: now.toISOString(),
              })
              .eq("id", currentUser.id);

            userStats.current_streak = newStreak;

            showToast(`Daily streak: ${newStreak} days!`, "success");
            await checkStreakAchievements(newStreak);
          }

          return newStreak;
        } catch (error) {
          console.error("Error checking daily streak:", error);
          return 0;
        }
      }

      async function checkStreakAchievements(currentStreak) {
        const streakMilestones = [3, 7, 14, 30, 100, 365];

        for (const milestone of streakMilestones) {
          if (currentStreak >= milestone) {
            await checkAndUnlockAchievement(`streak_${milestone}`);
          }
        }
      }

      // =====================================================
      // USER ACTIVITY LOGGING
      // =====================================================
      async function logUserActivity(activityType, metadata = {}) {
        try {
          const now = new Date();

          const activityData = {
            user_id: currentUser.id,
            activity_type: activityType,
            timestamp: now.toISOString(),
            course_id: COURSE_DATA.id,
            lesson_index: currentLessonIndex,
            session_duration: courseSession.totalStudyTime,
            metadata: JSON.stringify(metadata),
            created_at: now.toISOString(),
          };

          // Try to log to activities table
          const { error } = await supabase
            .from("user_activities")
            .insert([activityData]);

          if (error && error.code !== "42P01") {
            console.warn("Activity logging failed:", error.message);
          }

          // Always update last activity in profile
          await supabase
            .from("profiles")
            .update({ last_activity: now.toISOString() })
            .eq("id", currentUser.id);
        } catch (error) {
          console.error("Error logging user activity:", error);
        }
      }

      // =====================================================
      // NAVIGATION SYSTEM
      // =====================================================
      function updateNavigationButtons() {
        const prevBtn = document.getElementById("prevLessonBtn");
        const nextBtn = document.getElementById("nextLessonBtn");

        if (!prevBtn || !nextBtn) return;

        // Previous button
        prevBtn.disabled = currentLessonIndex === 0;

        // Next button logic
        const isLastLesson =
          currentLessonIndex === COURSE_DATA.lessons.length - 1;
        const canGoNext =
          currentLessonIndex < COURSE_DATA.lessons.length - 1 &&
          canAccessLesson(currentLessonIndex + 1);

        if (isLastLesson) {
          const isCurrentCompleted =
            courseProgress[COURSE_DATA.lessons[currentLessonIndex].id]
              ?.completed;
          nextBtn.disabled = !isCurrentCompleted;
          nextBtn.innerHTML = '<i class="fas fa-trophy"></i> Complete Course';
        } else {
          nextBtn.disabled = !canGoNext;
          nextBtn.innerHTML = 'Next <i class="fas fa-chevron-right"></i>';
        }
      }

      // Navigation button event handlers
      function goToPreviousLesson() {
        if (currentLessonIndex > 0) {
          trackLessonTime(); // Track time spent on current lesson
          currentLessonIndex--;
          loadLesson(currentLessonIndex);
        }
      }

      function goToNextLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          const canGoNext = canAccessLesson(currentLessonIndex + 1);
          if (canGoNext) {
            trackLessonTime();
            currentLessonIndex++;
            loadLesson(currentLessonIndex);
          } else {
            showToast("Complete the current lesson quiz to proceed", "warning");
          }
        } else {
          // Complete course
          completeCourse();
        }
      }

      // =====================================================
      // SIDEBAR FUNCTIONS
      // =====================================================
      function toggleSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.toggle("open");
        if (overlay) overlay.classList.toggle("active");
      }

      function closeSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.remove("open");
        if (overlay) overlay.classList.remove("active");
      }

      // =====================================================
      // ACHIEVEMENT NOTIFICATION SYSTEM
      // =====================================================
      function queueAchievementNotification(achievement) {
        notificationQueue.push(achievement);
        processNotificationQueue();
      }

      function processNotificationQueue() {
        if (isShowingNotification || notificationQueue.length === 0) return;

        isShowingNotification = true;
        const achievement = notificationQueue.shift();
        showAchievementNotification(achievement);

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          isShowingNotification = false;
          processNotificationQueue();
        }, duration + 500);
      }

      function showAchievementNotification(achievement) {
        const notification = document.getElementById("achievementNotification");
        if (!notification) return;

        const icon = document.getElementById("notificationIcon");
        const title = document.getElementById("notificationTitle");
        const description = document.getElementById("notificationDescription");
        const points = document.getElementById("notificationPoints");

        if (icon) {
          icon.innerHTML = `<i class="${achievement.icon}"></i>`;
          icon.className = `notification-icon ${achievement.rarity}`;
        }
        if (title) title.textContent = achievement.name;
        if (description) description.textContent = achievement.description;
        if (points) points.textContent = `+${achievement.points} Points`;

        notification.className = `achievement-notification ${achievement.rarity}`;
        notification.classList.add("show");

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          notification.classList.remove("show");
        }, duration);
      }

      // =====================================================
      // UTILITY FUNCTIONS
      // =====================================================
      function calculateAverageQuizScore() {
        const scores = Object.values(courseProgress)
          .filter((p) => p.completed && p.quizScore)
          .map((p) => p.quizScore);

        if (scores.length === 0) return 0;
        return Math.round(
          scores.reduce((sum, score) => sum + score, 0) / scores.length
        );
      }

      async function resetProgress() {
        if (
          !confirm(
            "Are you sure you want to reset your progress? This action cannot be undone."
          )
        ) {
          return;
        }

        try {
          // Track lesson time before reset
          trackLessonTime();

          // Reset local state
          courseProgress = {};
          currentLessonIndex = 0;
          courseSession = {
            startTime: new Date(),
            totalStudyTime: 0,
            lessonsStarted: 0,
            lessonsCompleted: 0,
            pageLoadTime: new Date(),
            interactionCount: 0,
            lastActivityTime: new Date(),
          };

          // Delete from database
          await supabase
            .from("course_progress")
            .delete()
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Log reset activity
          logUserActivity("progress_reset", {
            course_id: COURSE_DATA.id,
            reset_reason: "manual",
          });

          // Reinitialize
          await saveProgress();
          renderSidebar();
          loadLesson(0);

          showToast("Progress reset successfully", "success");
        } catch (error) {
          console.error("Error resetting progress:", error);
          showToast("Failed to reset progress", "error");
        }
      }

      function copyCode(codeId) {
        const codeElement = document.getElementById(codeId);
        if (!codeElement) return;

        const text = codeElement.textContent;

        navigator.clipboard
          .writeText(text)
          .then(() => {
            showToast("Code copied to clipboard!", "success");

            // Track code copy for achievements
            logUserActivity("code_copied", {
              code_section: codeId,
              lesson_id: COURSE_DATA.lessons[currentLessonIndex].id,
            });
          })
          .catch((err) => {
            console.error("Failed to copy code:", err);
            showToast("Failed to copy code", "error");

            // Fallback for older browsers
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            try {
              document.execCommand("copy");
              showToast("Code copied to clipboard!", "success");
            } catch (fallbackError) {
              showToast(
                "Copy failed - please select and copy manually",
                "error"
              );
            }
            document.body.removeChild(textArea);
          });
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // =====================================================
      // UI FEEDBACK SYSTEMS
      // =====================================================
      function showToast(message, type = "success") {
        const toast = document.getElementById("toast");
        const messageEl = document.getElementById("toastMessage");

        if (!toast || !messageEl) {
          console.log(`Toast: ${message} (${type})`);
          return;
        }

        messageEl.textContent = message;
        toast.className = `toast ${type} show`;

        setTimeout(() => {
          toast.classList.remove("show");
        }, 4000);
      }

      function showLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) loadingScreen.classList.remove("hidden");
      }

      function hideLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) {
          setTimeout(() => {
            loadingScreen.classList.add("hidden");
          }, 1000);
        }
      }

      // =====================================================
      // MUSIC PLAYER INTEGRATION
      // =====================================================
      function initMusicPlayer() {
        const btnText = document.getElementById("music-button-text");
        const icon = document.getElementById("music-icon");
        const dropdown = document.getElementById("music-dropdown-content");

        if (!btnText || !icon || !dropdown) return;

        function setUI(state) {
          btnText.textContent =
            state === "Playing" ? "PAUSE MUSIC" : "STUDY MUSIC";
          icon.className =
            state === "Playing"
              ? "fa-solid fa-circle-pause"
              : "fa-solid fa-music";
        }

        // Load saved music state
        const savedSrc = localStorage.getItem("cybersec_music_src");
        const savedTime = parseFloat(
          localStorage.getItem("cybersec_music_time") || 0
        );

        if (savedSrc) {
          audioPlayer.src = savedSrc;
          audioPlayer.currentTime = savedTime;
          audioPlayer
            .play()
            .then(() => setUI("Playing"))
            .catch(() => setUI("Stopped"));
        }

        // Music button click handler
        document
          .getElementById("music-dropdown")
          .querySelector("button")
          .addEventListener("click", (e) => {
            e.stopPropagation();
            dropdown.style.display =
              dropdown.style.display === "block" ? "none" : "block";

            if (audioPlayer.src && !audioPlayer.paused) {
              audioPlayer.pause();
              setUI("Stopped");
            } else if (audioPlayer.src) {
              audioPlayer.play().then(() => setUI("Playing"));
            }
          });

        // Music selection handlers
        dropdown.querySelectorAll("a[data-src]").forEach((link) => {
          link.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.src = link.dataset.src;
            audioPlayer.play().then(() => setUI("Playing"));
            localStorage.setItem("cybersec_music_src", link.dataset.src);
            dropdown.style.display = "none";
          });
        });

        // Stop music handler
        const stopLink = document.getElementById("stop-music-link");
        if (stopLink) {
          stopLink.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            audioPlayer.removeAttribute("src");
            setUI("Stopped");
            localStorage.removeItem("cybersec_music_src");
            localStorage.removeItem("cybersec_music_time");
            dropdown.style.display = "none";
          });
        }

        // Save music state before page unload
        window.addEventListener("beforeunload", () => {
          if (!audioPlayer.paused && audioPlayer.src) {
            localStorage.setItem("cybersec_music_src", audioPlayer.src);
            localStorage.setItem(
              "cybersec_music_time",
              audioPlayer.currentTime
            );
          }
        });

        // Close dropdown when clicking outside
        window.addEventListener("click", (e) => {
          if (!e.target.closest("#music-dropdown")) {
            dropdown.style.display = "none";
          }
        });
      }

      // Show initial music indicator
      function addMusicIndicator() {
        const musicBtn = document.querySelector("#music-dropdown");
        if (musicBtn) {
          const indicator = document.createElement("div");
          indicator.className = "music-indicator";
          indicator.innerHTML = `<i class="fa-solid fa-music"></i> Try Study Music!`;

          musicBtn.style.position = "relative";
          musicBtn.appendChild(indicator);

          setTimeout(() => indicator.remove(), 3000);
        }
      }

      // Initialize Event Listeners
      function initializeEventListeners() {
        // Navigation buttons
        document
          .getElementById("prevLessonBtn")
          ?.addEventListener("click", goToPreviousLesson);
        document
          .getElementById("nextLessonBtn")
          ?.addEventListener("click", goToNextLesson);

        // Reset progress button
        document
          .getElementById("resetProgressBtn")
          ?.addEventListener("click", resetProgress);

        // Mobile menu toggle
        document
          .getElementById("menuToggle")
          ?.addEventListener("click", toggleSidebar);
        document
          .getElementById("sidebarOverlay")
          ?.addEventListener("click", closeSidebar);

        // Keyboard shortcuts
        document.addEventListener("keydown", handleKeyboardShortcuts);

        // Window resize handler
        window.addEventListener("resize", handleWindowResize);

        // Content interaction tracking
        document.getElementById("contentBody")?.addEventListener(
          "scroll",
          debounce(() => {
            trackUserInteraction();
          }, 1000)
        );
      }

      // Keyboard Shortcuts
      function handleKeyboardShortcuts(e) {
        if (document.querySelector(".quiz-question.active")) return;

        if (e.key === "ArrowLeft" && e.ctrlKey) {
          e.preventDefault();
          goToPreviousLesson();
        } else if (e.key === "ArrowRight" && e.ctrlKey) {
          e.preventDefault();
          goToNextLesson();
        }
      }

      // Window Resize Handler
      function handleWindowResize() {
        if (window.innerWidth > 768) {
          closeSidebar();
        }
      }

      // Debounce Helper
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Initialize responsive behavior
      if (window.innerWidth <= 768) {
        document.getElementById("menuToggle").style.display = "inline-flex";
      }

      // Auto-save progress periodically
      setInterval(async () => {
        if (currentUser && Object.keys(courseProgress).length > 0) {
          await saveProgress();
        }
      }, 60000); // Save every minute

      // System initialization logging
      console.log("CyberSec Academy Course System Initialized");
      console.log("Current Course:", COURSE_DATA.title);
      console.log("Total Lessons:", COURSE_DATA.lessons.length);

      // Google OAuth Integration
      const googleBtn = document.querySelector(".btn-google");
      if (googleBtn) {
        googleBtn.addEventListener("click", async () => {
          const { data, error } = await supabase.auth.signInWithOAuth({
            provider: "google",
            options: {
              redirectTo: window.location.origin + "/courses/malware-analysis-introduction-safe-expanded.html",
            },
          });

          if (error) {
            console.error("Google login error:", error.message);
            showToast("Google login failed: " + error.message, "error");
          }
        });
      }

      // Check for existing session
      supabase.auth.getSession().then(({ data }) => {
        if (data.session) {
          console.log("User already logged in:", data.session.user);
          currentUser = data.session.user;
          startCourseSession();
        }
      });

      // Add missing auth modal functions
      function openAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "flex";
        }
      }

      function closeAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Add auth tab switching functionality
      document.getElementById("tabSignIn")?.addEventListener("click", () => {
        document.getElementById("tabSignIn").classList.add("active");
        document.getElementById("tabSignUp").classList.remove("active");
        document.getElementById("signInForm").style.display = "block";
        document.getElementById("signUpForm").style.display = "none";
      });

      document.getElementById("tabSignUp")?.addEventListener("click", () => {
        document.getElementById("tabSignUp").classList.add("active");
        document.getElementById("tabSignIn").classList.remove("active");
        document.getElementById("signUpForm").style.display = "block";
        document.getElementById("signInForm").style.display = "none";
      });

      document
        .getElementById("closeAuthModal")
        ?.addEventListener("click", closeAuthModal);

      // Improved error handling for auth session
      supabase.auth.onAuthStateChange((event, session) => {
        if (event === "SIGNED_IN") {
          currentUser = session.user;
          closeAuthModal();
          startCourseSession();
        } else if (event === "SIGNED_OUT") {
          currentUser = null;
          openAuthModal();
        }
      });

      // Add form submission handlers
      document
        .getElementById("emailSignInForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signInEmail").value;
          const password = document.getElementById("signInPassword").value;

          try {
            const { data, error } = await supabase.auth.signInWithPassword({
              email,
              password,
            });

            if (error) throw error;

            closeAuthModal();
          } catch (error) {
            showToast(error.message, "error");
          }
        });

      document
        .getElementById("emailSignUpForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signUpEmail").value;
          const password = document.getElementById("signUpPassword").value;
          const name = document.getElementById("signUpName").value;

          try {
            const { data, error } = await supabase.auth.signUp({
              email,
              password,
              options: {
                data: {
                  full_name: name,
                },
              },
            });

            if (error) throw error;

            showToast(
              "Account created successfully! Please check your email.",
              "success"
            );
          } catch (error) {
            showToast(error.message, "error");
          }
        });
    </script>
  </body>
</html>

