


<!DOCTYPE html>
<html lang="en">
 <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Exo+2:wght@700;800;900&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css"
    />
    <link rel="stylesheet" href="assets/css/coursepages.css">

    <!-- ========== Start: SEO & Schema Enhancement ========== -->
    <title>Public Key Infrastructure (PKI) - Complete Course | CipherHall</title>
    <meta name="description" content="Enroll in our expert-led Public Key Infrastructure (PKI) course. Master digital certificates, CAs, trust models, and secure key management.">

    
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png" />
    <link rel="shortcut icon" href="/favicon.png" type="image/x-icon" />
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png" />
    <link rel="canonical" href="https://www.cipherhall.com/courses/public-key-infrastructure-pki.html" />

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Course",
      "name": "Public Key Infrastructure (PKI) - Complete Course",
      "description": "A comprehensive, 20-lesson course on how trust, keys, and certificates are managed at scale.",
      "provider": {
        "@type": "Organization",
        "name": "CipherHall",
        "sameAs": "https://www.cipherhall.com"
      },
      "hasCourseInstance": {
        "@type": "CourseInstance",
        "courseMode": "Online",
        "instructor": {
          "@type": "Person",
          "name": "Dr. Adrian Carter"
        }
      }
    }
    </script>
    <!-- ========== End: SEO & Schema Enhancement ========== -->
</head>
  <body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
      <div class="loader-icon">
        <i class="fas fa-graduation-cap"></i>
      </div>
      <div class="loader-text">Loading Course Content...</div>
    </div>

    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- Music Player (fixed at top right) -->
    <div class="header-controls">
      <div class="music-dropdown" id="music-dropdown">
        <button class="btn btn-secondary">
          <span id="music-button-text">STUDY MUSIC</span>
          <i id="music-icon" class="fa-solid fa-music"></i>
        </button>
        <div class="music-dropdown-content" id="music-dropdown-content">
          <a
            href="#"
            data-src="https://www.learningcontainer.com/wp-content/uploads/2020/02/Kalimba.mp3"
            >1. Coffee Shop Vibes</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3"
            >2. City Lights Lofi</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-15.mp3"
            >3. Mellow Thoughts</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-13.mp3"
            >4. Rainy Mood</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3"
            >5. Time Alone</a
          >
          <a href="#" id="stop-music-link"
            ><i class="fa-solid fa-stop-circle"></i> Stop Music</a
          >
        </div>
      </div>

      <button class="btn btn-secondary" id="resetProgressBtn">
        <i class="fas fa-redo"></i>
        Reset Progress
      </button>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal" style="display: none">
      <div class="modal-overlay"></div>
      <div class="modal-content">
        <span class="close" id="closeAuthModal">&times;</span>
        <div class="auth-tabs">
          <button id="tabSignIn" class="auth-tab active">Sign In</button>
          <button id="tabSignUp" class="auth-tab">Sign Up</button>
        </div>
        <div
          id="authLoader"
          style="display: none; text-align: center; padding: 2rem"
        >
          <i
            class="fas fa-spinner fa-spin fa-2x"
            style="color: var(--color-green)"
          ></i>
          <p style="margin-top: 0.5rem">Authenticating...</p>
        </div>
        <div id="signInForm" class="auth-form">
          <h2>Sign In to CipherHall</h2>
          <button id="googleSignIn" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignInForm">
            <input
              type="email"
              id="signInEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signInPassword"
              placeholder="Password"
              required
            />
            <button type="submit" class="btn btn-primary">Sign In</button>
          </form>
        </div>
        <div id="signUpForm" class="auth-form" style="display: none">
          <h2>Join CipherHall</h2>
          <button id="googleSignUp" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignUpForm">
            <input
              type="text"
              id="signUpName"
              placeholder="Full Name"
              required
            />
            <input
              type="email"
              id="signUpEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signUpPassword"
              placeholder="Password (min. 8 characters)"
              required
            />
            <button type="submit" class="btn btn-secondary">
              Create Account
            </button>
          </form>
        </div>
        <div id="authMessage"></div>
      </div>
    </div>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="course-info">
          <h1 class="course-title" id="courseTitle">Loading...</h1>
          <div class="course-progress">
            <div class="progress-header">
              <span class="progress-label">Course Progress</span>
              <span class="progress-percentage" id="courseProgressPercent"
                >0%</span
              >
            </div>
            <div class="progress-bar">
              <div
                class="progress-fill"
                id="courseProgressFill"
                style="width: 0%"
              ></div>
            </div>
            <div class="progress-stats">
              <span id="completedLessons">0</span>
              <span id="totalLessons">0</span>
            </div>
          </div>
          <a href="/dashboard.html" class="back-to-dashboard">
            <i class="fas fa-arrow-left"></i>
            Back to Dashboard
          </a>
        </div>
      </div>

      <nav class="lesson-nav" id="lessonNav">
        <!-- Lessons will be loaded dynamically -->
      </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <header class="content-header">
        <div class="lesson-header">
          <div class="lesson-header-left">
            <span class="lesson-number" id="currentLessonNumber">1</span>
            <h1 class="lesson-header-title" id="currentLessonTitle">
              Loading...
            </h1>
          </div>
          <div class="lesson-actions">
            <button class="mbtn btn-primary" id="menuToggle">
              <i class="fas fa-bars"></i>
            </button>
          </div>
        </div>
      </header>

      <div class="content-body" id="contentBody">
        <div class="lesson-content" id="lessonContent">
          <!-- Lesson content will be loaded dynamically -->
        </div>
      </div>

      <footer class="lesson-navigation">
        <div class="nav-info" id="navInfo">Lesson 1 of 10</div>
        <div class="nav-controls">
          <button class="btn btn-secondary" id="prevLessonBtn" disabled>
            <i class="fas fa-chevron-left"></i>
            Previous
          </button>
          <button class="btn btn-primary" id="nextLessonBtn" disabled>
            Next
            <i class="fas fa-chevron-right"></i>
          </button>
        </div>
      </footer>
    </main>

    <!-- Achievement Notification -->
    <div id="achievementNotification" class="achievement-notification">
      <div class="notification-header">
        <div class="notification-icon" id="notificationIcon">
          <i class="fas fa-trophy"></i>
        </div>
        <div class="notification-content">
          <h3 id="notificationTitle">Achievement Unlocked!</h3>
          <p id="notificationDescription">Description here...</p>
        </div>
      </div>
      <div class="notification-reward" id="notificationReward">
        <i class="fas fa-coins"></i>
        <span id="notificationPoints">+100 Points</span>
      </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast">
      <span id="toastMessage"></span>
    </div>

    <script>
      // =====================================================
      // SYNCHRONIZED COURSE SYSTEM WITH DASHBOARD INTEGRATION
      // =====================================================

      // Supabase Configuration - Replace with your config
      const supabaseUrl = "https://lzcmzulemfubjaksoqor.supabase.co";
      const supabaseKey =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx6Y216dWxlbWZ1Ympha3NvcW9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzMzM5MDgsImV4cCI6MjA3MDkwOTkwOH0.crhPH4YWtRsr1BJTpAQcmPbWSpwIWRbzoI4sRb2_fPI";
      const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

      // =====================================================
      // COURSE DATA STRUCTURE - REPLACE WITH YOUR COURSE JSON
      // =====================================================
      const COURSE_DATA = {
        id: "public-key-infrastructure-pki",
        title: "Public Key Infrastructure (PKI)",
        description:
          "A comprehensive, 20-lesson course on how trust, keys, and certificates are managed at scale.",
        category: "security-architecture",
        difficulty: "Intermediate to Advanced",
        duration: "45 hours",
        instructor: "Dr. Adrian Carter",
        lessons: [
          {
            id: "lesson-1",
            title: "Introduction to PKI",
            duration: "90 min",
            objectives: [
              "Define Public Key Infrastructure (PKI) and its purpose",
              "Understand the problem PKI is designed to solve (scalable digital trust)",
              "Explain the concept of a trust model and a trust anchor",
              "Identify trusted root certificates on a local system",
            ],
            content: {
              overview:
                "This lesson introduces the fundamental concepts of Public Key Infrastructure (PKI), the framework of hardware, software, policies, and standards used to manage digital identities and secure communications. We will explore why PKI is the foundation of trust for e-commerce, secure email, and authenticated connections on the internet.",
              sections: [
                {
                  title: "Why Does PKI Exist? The Problem of Trust at Scale",
                  content:
                    "<p>In the physical world, we use passports, driver's licenses, and notary seals to verify identity. How do we do this on the internet, where we might be communicating with a server thousands of miles away? How does your browser know it's really connected to your bank and not an imposter? Public Key Infrastructure is the answer. It solves the problem of establishing and verifying trust between parties who have no prior relationship.</p><h3>PKI provides three core security services:</h3><ul><li><strong>Authentication:</strong> Proving that a user, device, or service is who or what it claims to be.</li><li><strong>Confidentiality:</strong> Ensuring that data is kept private through encryption.</li><li><strong>Integrity:</strong> Guaranteeing that data has not been altered or tampered with in transit.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1550645612-82f5d2d0b642?w=800&h=400&fit=crop",
                },
                {
                  title: "The PKI Trust Model and Trust Anchors",
                  content:
                    "<p>PKI is built on a simple concept: trust is transitive. If you trust a specific, authoritative source, you can also trust anything that source vouches for. This authoritative source in a PKI is called a <strong>Trust Anchor</strong>, most commonly a <strong>Root Certificate Authority (CA)</strong>.</p><p>Your operating system and web browser come with a pre-installed list of trusted Root CAs (a 'trust store'). This is the foundation of all PKI security. When a website presents a certificate, your browser trusts it only if it can trace a valid signature path back to one of these pre-trusted Root CAs. This chain of verifiable signatures is known as a 'chain of trust'.</p>",
                  image:
                    "https://images.unsplash.com/photo-1544197150-b2c4c47b0a34?w=800&h=400&fit=crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab: Explore the System Trusted Root Store",
                  language: "bash",
                  code: "# On Linux (Debian/Ubuntu/CentOS), trusted root certificates are typically stored in /etc/ssl/certs/ or /etc/pki/tls/certs/.\n\n# List the first 10 trusted root certificate subjects on a Linux system:\nls /etc/ssl/certs | head -n 20 | xargs -L1 -I{} openssl x509 -in /etc/ssl/certs/{} -noout -subject\n\n# On Windows, you can use the Certificate Manager tool:\n# 1. Press Win + R, type 'certmgr.msc', and press Enter.\n# 2. In the left pane, navigate to 'Trusted Root Certification Authorities' > 'Certificates'.\n# 3. Here you can see the list of all CAs that your Windows operating system trusts by default.\n\n# On macOS:\n# 1. Open the 'Keychain Access' application.\n# 2. In the 'Keychains' list, select 'System Roots'.\n# 3. This list shows all the Root CAs trusted by macOS.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the primary problem that Public Key Infrastructure (PKI) solves?",
                  options: [
                    "Creating faster internet connections.",
                    "Establishing and managing digital trust at scale.",
                    "Storing user passwords securely.",
                    "Preventing computer viruses.",
                  ],
                  correct: 1,
                  explanation:
                    "PKI provides a scalable way to verify identities and establish secure communication channels between entities that have no prior relationship.",
                },
                {
                  id: 2,
                  question: "In a PKI trust model, what is a 'Trust Anchor'?",
                  options: [
                    "The user's password.",
                    "A security firewall.",
                    "An authoritative entity, like a Root CA, that is trusted by default.",
                    "The web server's IP address.",
                  ],
                  correct: 2,
                  explanation:
                    "A Trust Anchor is the root of a chain of trust, an entity that is inherently trusted and upon which the trust of all subsequent certificates is based.",
                },
                {
                  id: 3,
                  question:
                    "How do browsers know which Certificate Authorities to trust?",
                  options: [
                    "They ask the user every time a new site is visited.",
                    "They come with a pre-installed list of trusted Root CA certificates (a 'trust store').",
                    "They only trust certificates issued in their own country.",
                    "They trust any certificate that is not expired.",
                  ],
                  correct: 1,
                  explanation:
                    "Operating systems and browsers are shipped with a 'trust store' containing the public certificates of globally recognized Root CAs. This is the foundation of web PKI.",
                },
              ],
            },
          },
          {
            id: "lesson-2",
            title: "Components of PKI",
            duration: "60 min",
            objectives: [
              "Identify the core components of a typical PKI system",
              "Describe the function of a Certificate Authority (CA)",
              "Describe the function of a Registration Authority (RA)",
              "Understand the purpose of a Certificate Repository",
            ],
            content: {
              overview:
                "A functioning PKI is more than just a single server; it's an ecosystem of components working together. This lesson breaks down the key architectural pieces, including the Certificate Authority that issues certificates, the Registration Authority that verifies identities, and the repositories that make certificate information public.",
              sections: [
                {
                  title: "The Certificate Authority (CA)",
                  content:
                    "<p>The <strong>Certificate Authority (CA)</strong> is the heart of a PKI. It is the entity responsible for issuing and managing digital certificates. The CA signs a certificate with its own private key, which is a declaration that the CA has verified the information contained within the certificate. Anyone who trusts the CA can use the CA's public key to verify the signature and, by extension, trust the certificate. The security of the CA's private key is paramount to the integrity of the entire PKI.</p>",
                  image:
                    "https://images.unsplash.com/photo-1594980598282-53b754e8c14f?w=800&h=400&fit=crop",
                },
                {
                  title: "The Registration Authority (RA)",
                  content:
                    "<p>The <strong>Registration Authority (RA)</strong> is the component responsible for identity verification. While the CA is the signing authority, it often delegates the task of verifying certificate applicants to an RA. The RA acts as the vetting agent for the CA. When you apply for a certificate, you submit your request to an RA. The RA performs the necessary checks to confirm your identity (e.g., verifying you own a domain, checking your organization's legal status) before approving the request and passing it on to the CA for signing. This separation of duties can improve security and administrative efficiency.</p>",
                  image:
                    "https://images.unsplash.com/photo-1579226903282-c0e4821d4c38?w=800&h=400&fit=crop",
                },
                {
                  title: "The Certificate Repository and Revocation Services",
                  content:
                    "<p>A PKI needs a way to publicly distribute the certificates it issues, as well as information about which certificates are no longer valid. This is the job of the repository.</p><ul><li><strong>Certificate Repository:</strong> A publicly accessible directory where issued certificates can be retrieved. This allows third parties to find a user's certificate and public key.</li><li><strong>Revocation Repository:</strong> A service that holds certificate revocation information. This can be in the form of a Certificate Revocation List (CRL) or an Online Certificate Status Protocol (OCSP) responder. Relying parties must check this repository to ensure a certificate has not been revoked before its expiration date.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1522199670076-2852f80289c3?w=800&h=400&fit=crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab: Identify CAs in Your Browser's Trust Store",
                  language: "bash",
                  code: "# Most browsers provide a user interface to view and manage trusted CAs.\n\n# In Firefox:\n# 1. Go to 'Settings'.\n# 2. Search for 'Certificates' and click the 'View Certificates...' button.\n# 3. Under the 'Authorities' tab, you can scroll through the list of all CAs that Firefox trusts to issue certificates for websites, email, and more.\n\n# In Google Chrome:\n# 1. Go to 'Settings' > 'Privacy and security'.\n# 2. Click 'Security'.\n# 3. Scroll down and click 'Manage certificates' or 'Manage device certificates'.\n# 4. This will open the operating system's certificate manager where you can view the 'Trusted Root Certification Authorities' store.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "Which component is responsible for signing and issuing digital certificates?",
                  options: [
                    "Registration Authority (RA)",
                    "Certificate Repository",
                    "Certificate Authority (CA)",
                    "The End User",
                  ],
                  correct: 2,
                  explanation:
                    "The Certificate Authority (CA) is the core component that digitally signs certificates, thereby vouching for the identity of the subject.",
                },
                {
                  id: 2,
                  question:
                    "What is the primary function of a Registration Authority (RA)?",
                  options: [
                    "To store revoked certificates.",
                    "To verify the identity of certificate applicants before forwarding the request to a CA.",
                    "To encrypt website traffic.",
                    "To sign the final certificate with its private key.",
                  ],
                  correct: 1,
                  explanation:
                    "The RA is the vetting component of a PKI, responsible for performing the due diligence of identity verification.",
                },
                {
                  id: 3,
                  question:
                    "A Certificate Revocation List (CRL) would be found in which PKI component?",
                  options: [
                    "The user's private key",
                    "A Certificate Repository",
                    "The Certificate Authority's offline storage",
                    "A Registration Authority",
                  ],
                  correct: 1,
                  explanation:
                    "Certificate Repositories are used to publicly distribute both valid certificates and lists of revoked certificates (CRLs).",
                },
              ],
            },
          },
          {
            id: "lesson-3",
            title: "Digital Certificates (X.509)",
            duration: "75 min",
            objectives: [
              "Understand the X.509 standard for digital certificates",
              "Identify and explain key fields in a certificate",
              "Explain the importance of the Subject Alternative Name (SAN) field",
              "Recognize different certificate file formats (PEM, DER)",
            ],
            content: {
              overview:
                "The digital certificate is the central data structure in any PKI. This lesson performs a deep dive into the X.509 v3 standard, the most widely used format for digital certificates. We will dissect the certificate's structure, from the subject's identity to the issuer's signature, and highlight the fields that are critical for modern applications.",
              sections: [
                {
                  title: "Anatomy of an X.509 Certificate",
                  content:
                    "<p>An X.509 certificate is a standardized digital document that binds a public key to an identity. Think of it as a digital passport, containing verifiable information about its owner and vouched for by a trusted authority. The certificate contains numerous fields, but some of the most important are:</p><ul><li><strong>Version:</strong> Indicates the X.509 version (v3 is the current standard).</li><li><strong>Serial Number:</strong> A unique identifier for the certificate assigned by the CA.</li><li><strong>Signature Algorithm:</strong> The algorithm used by the CA to sign the certificate (e.g., SHA256withRSA).</li><li><strong>Issuer:</strong> The Distinguished Name (DN) of the CA that signed the certificate.</li><li><strong>Validity Period:</strong> The 'Not Before' and 'Not After' dates, defining the certificate's lifespan.</li><li><strong>Subject:</strong> The Distinguished Name (DN) of the entity the certificate identifies (e.g., a person, a server).</li><li><strong>Subject Public Key Info:</strong> The public key of the subject, along with the algorithm (e.g., RSA, ECC) it uses.</li><li><strong>Extensions (v3):</strong> Crucial fields that add more information, like Key Usage, Extended Key Usage, and Subject Alternative Name.</li><li><strong>CA's Digital Signature:</strong> The signature created by the CA's private key over the entire certificate contents, which guarantees its integrity and authenticity.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1585224322384-0613531b78b0?w=800&h=400&fit=crop",
                },
                {
                  title: "The All-Important Subject Alternative Name (SAN)",
                  content:
                    "<p>In early versions of PKI, a certificate's identity was tied to the <strong>Common Name (CN)</strong> field within the Subject DN. However, this was limited to a single name. The modern solution is the <strong>Subject Alternative Name (SAN)</strong> extension. This extension allows a single certificate to be valid for multiple names, which can be DNS names, IP addresses, email addresses, and more.</p><p>For example, a single certificate with SANs could secure `www.google.com`, `google.com`, `mail.google.com`, and `drive.google.com`. Modern browsers have deprecated the use of the Common Name for identity verification and now rely exclusively on the SAN field. <strong>Any modern SSL/TLS certificate must use SANs.</strong></p>",
                  image:
                    "https://images.unsplash.com/photo-1614064548237-02f4d3544d42?w=800&h=400&fit=crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab: Decode and Inspect a Certificate with OpenSSL",
                  language: "bash",
                  code: "# The openssl x509 command is a powerful tool for parsing and viewing certificate details.\n\n# Step 1: Save a remote server's certificate to a file.\n# This command connects to google.com, saves its PEM-formatted certificate to a file named 'google.pem'.\nopenssl s_client -connect google.com:443 -servername google.com < /dev/null | openssl x509 -outform PEM > google.pem\n\n# Step 2: Decode the certificate and print its contents in human-readable text.\nopenssl x509 -in google.pem -text -noout\n\n# Step 3: Analyze the output.\n# - Look for the 'Issuer:' and 'Subject:' fields.\n# - Find the 'Validity' period ('Not Before', 'Not After').\n# - Examine the 'Subject Public Key Info' to see the key type and size.\n# - Most importantly, find the 'X509v3 extensions:' section and locate the 'Subject Alternative Name' field to see all the DNS names this single certificate covers.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "Which field in an X.509 certificate defines its lifespan?",
                  options: [
                    "Serial Number",
                    "Issuer",
                    "Validity Period",
                    "Subject",
                  ],
                  correct: 2,
                  explanation:
                    "The Validity Period contains the 'Not Before' and 'Not After' timestamps that define when the certificate is considered valid.",
                },
                {
                  id: 2,
                  question:
                    "For a modern web server certificate, which field is used to identify the valid domain names?",
                  options: [
                    "Common Name (CN)",
                    "Serial Number",
                    "Subject Alternative Name (SAN)",
                    "Issuer",
                  ],
                  correct: 2,
                  explanation:
                    "Modern browsers and clients require the domain names to be listed in the Subject Alternative Name (SAN) extension. Use of the Common Name for this purpose is deprecated.",
                },
                {
                  id: 3,
                  question:
                    "What guarantees the integrity and authenticity of an entire certificate?",
                  options: [
                    "The subject's public key.",
                    "The Certificate Authority's digital signature over the certificate's contents.",
                    "The certificate's serial number.",
                    "A strong password.",
                  ],
                  correct: 1,
                  explanation:
                    "The CA's digital signature is the cryptographic seal that proves the certificate was issued by the trusted CA and has not been altered.",
                },
              ],
            },
          },
          {
            id: "lesson-4",
            title: "Certificate Authorities (Root, Intermediate)",
            duration: "75 min",
            objectives: [
              "Explain the hierarchical trust model",
              "Differentiate between a Root CA and an Intermediate CA",
              "Understand the security reasons for using a certificate hierarchy",
              "Define cross-signing and its purpose",
            ],
            content: {
              overview:
                "Not all Certificate Authorities are created equal. The security and structure of a PKI relies on a hierarchy of CAs, with an ultra-secure Root CA at the top and one or more Intermediate CAs handling daily operations. This lesson explains this tiered model, the chain of trust it creates, and how trust can be extended between different PKIs.",
              sections: [
                {
                  title: "The CA Hierarchy: A Chain of Trust",
                  content:
                    "<p>A public key infrastructure uses a hierarchical model to manage trust. This structure is often called the <strong>chain of trust</strong>. For any given certificate, its validity can be verified by checking the signature of the authority that issued it. You can then verify the certificate of that authority by checking its issuer, and so on, until you arrive at the ultimate trust anchor: the Root CA.</p><p>This chain must be presented to the client to prove the certificate's validity. A typical chain consists of:</p><ol><li><strong>End-entity Certificate:</strong> The certificate issued to a specific server or user.</li><li><strong>Intermediate CA Certificate(s):</strong> One or more certificates that link the end-entity cert to the Root CA.</li><li><strong>Root CA Certificate:</strong> The self-signed certificate of the trust anchor, which is already present in the client's trust store.</li></ol>",
                  image:
                    "https://images.unsplash.com/photo-1621640348395-502f04b2e811?w=800&h=400&fit=crop",
                },
                {
                  title: "Root CAs vs. Intermediate CAs",
                  content:
                    "<h3>Root Certificate Authority</h3><p>A Root CA is the ultimate source of trust in a PKI. Its certificate is self-signed, and its private key is the most valuable asset in the entire system. Because a compromise of the root key would destroy the trustworthiness of the entire PKI, Root CA private keys are protected with extreme measures. They are almost always kept in a Hardware Security Module (HSM) in a secure facility and, most importantly, they are kept <strong>offline</strong>. A Root CA is only brought online to perform two tasks: to sign or revoke an Intermediate CA certificate.</p><h3>Intermediate Certificate Authority</h3><p>An Intermediate CA is a CA whose certificate has been signed by the Root CA (or another intermediate). Intermediates act on behalf of the root to issue the end-entity certificates for servers, users, and devices. Because they must be online to handle signing requests, they are more exposed to attack than the root. This hierarchy creates a critical security buffer: if an Intermediate CA's key is compromised, the Root CA can revoke its certificate, instantly invalidating all certificates that were issued by that intermediate. This can be done without compromising the root key itself, preserving the integrity of the overall PKI.",
                  image:
                    "https://images.unsplash.com/photo-1542382257-80ded13c79c8?w=800&h=400&fit=crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab: Build Your Own Mini-CA with OpenSSL",
                  language: "bash",
                  code: '# This lab demonstrates the CA hierarchy by creating a simple Root CA and an Intermediate CA.\n\n# Step 1: Create the Root CA.\n# Generate a private key for the Root CA.\nopenssl genrsa -aes256 -out root-ca.key 4096\n# Generate a self-signed Root CA certificate.\nopenssl req -x509 -new -nodes -key root-ca.key -sha256 -days 3650 -out root-ca.crt -subj "/C=US/ST=CA/O=My Corp/CN=My Corp Root CA"\n\n# Step 2: Create the Intermediate CA.\n# Generate a private key for the Intermediate CA.\nopenssl genrsa -aes256 -out intermediate-ca.key 4096\n# Create a Certificate Signing Request (CSR) for the Intermediate CA.\nopenssl req -new -key intermediate-ca.key -out intermediate-ca.csr -subj "/C=US/ST=CA/O=My Corp/CN=My Corp Intermediate CA"\n\n# Step 3: Sign the Intermediate CSR with the Root CA.\n# This is the crucial step that establishes the chain of trust.\nopenssl x509 -req -in intermediate-ca.csr -CA root-ca.crt -CAkey root-ca.key -CAcreateserial -out intermediate-ca.crt -days 1825 -sha256\n\n# You now have a Root CA (root-ca.crt) and an Intermediate CA (intermediate-ca.crt) that is trusted by your root.\n# You would now use the Intermediate key and cert to sign end-entity certificates.',
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the primary security reason for keeping a Root CA's private key offline?",
                  options: [
                    "To save electricity.",
                    "To minimize its exposure to network-based attacks, as its compromise would invalidate the entire PKI.",
                    "Offline keys are faster for signing.",
                    "The Root CA only issues certificates to offline devices.",
                  ],
                  correct: 1,
                  explanation:
                    "The Root CA is the trust anchor. Its private key is the most critical asset and is kept offline to protect it from threats. It is only used for the rare occasion of signing or revoking an Intermediate CA.",
                },
                {
                  id: 2,
                  question:
                    "In a typical CA hierarchy, which entity signs the end-entity server certificate?",
                  options: [
                    "The Root CA",
                    "The user's computer",
                    "The Intermediate CA",
                    "It is self-signed",
                  ],
                  correct: 2,
                  explanation:
                    "The Intermediate CA is the online, operational entity responsible for the day-to-day task of issuing certificates to end-users and servers.",
                },
                {
                  id: 3,
                  question:
                    "A certificate is self-signed. Which type of CA does it belong to?",
                  options: [
                    "An Intermediate CA",
                    "An End-entity CA",
                    "A Root CA",
                    "A Registration Authority",
                  ],
                  correct: 2,
                  explanation:
                    "By definition, the Root CA is at the top of the hierarchy and does not have a higher authority to sign its certificate, so its certificate is self-signed.",
                },
              ],
            },
          },
          {
            id: "lesson-5",
            title: "The Certificate Signing Process",
            duration: "60 min",
            objectives: [
              "Outline the steps to obtain a digitally signed certificate",
              "Explain the purpose and contents of a Certificate Signing Request (CSR)",
              "Understand the role of the private key in generating a CSR",
              "Describe how a CA uses a CSR to issue a certificate",
            ],
            content: {
              overview:
                "Obtaining a certificate from a Certificate Authority follows a standardized process that begins with the applicant generating a key pair and a Certificate Signing Request (CSR). This lesson demystifies that process, explaining what a CSR is, how it's created, and how the CA uses it to generate and issue the final, signed certificate.",
              sections: [
                {
                  title: "Step 1: The Applicant Generates a Key Pair",
                  content:
                    "<p>Everything starts with the entity that needs a certificate (the applicant). The first and most critical step is for the applicant to generate a public/private key pair. The <strong>private key</strong> must be kept secret and securely stored by the applicant at all times. It should never be shared with anyone, including the CA. The <strong>public key</strong> is designed to be shared and will be embedded in the certificate.</p>",
                  image:
                    "https://images.unsplash.com/photo-1526374965328-5f61d25c0e40?w=800&h=400&fit=crop",
                },
                {
                  title:
                    "Step 2: The Applicant Creates a Certificate Signing Request (CSR)",
                  content:
                    "<p>A Certificate Signing Request (CSR) is a block of encoded text containing information that will be included in the certificate, along with the applicant's public key. The applicant generates the CSR using their private key.</p><h3>The CSR contains:</h3><ul><li><strong>The Applicant's Public Key:</strong> The key the CA will certify.</li><li><strong>Identity Information:</strong> The Subject Distinguished Name, which includes details like Common Name (e.g., `www.example.com`), Organization, Country, etc. Modern CSRs must also include Subject Alternative Names (SANs).</li><li><strong>A Digital Signature:</strong> The entire CSR is signed by the applicant's <strong>private key</strong>.</li></ul><p>This signature is crucial. When the CA receives the CSR, it uses the public key contained within the request to verify the signature. This proves that the applicant who sent the CSR is also in possession of the corresponding private key.</p>",
                  image:
                    "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop",
                },
                {
                  title: "Step 3: The CA Verifies, Signs, and Issues",
                  content:
                    "<p>The applicant submits the CSR to a Registration Authority (RA) or directly to a Certificate Authority (CA).</p><ol><li><strong>Verification:</strong> The RA/CA first verifies the CSR's signature to prove possession of the private key. Then, it performs its main duty: verifying the applicant's identity to the level required by the certificate type (e.g., verifying domain control for a DV cert, or legal entity status for an OV/EV cert).</li><li><strong>Signing:</strong> Once verification is complete, the CA creates a new X.509 certificate containing the information from the CSR, adds other details like a serial number and validity period, and then signs the entire certificate with its own <strong>CA private key</strong>.</li><li><strong>Issuance:</strong> The CA then provides the newly signed public certificate back to the applicant. The applicant can then install this certificate on their server, along with their original private key, to enable secure communication.</li></ol>",
                  image:
                    "https://images.unsplash.com/photo-1629834465737-f1c52b34a6c3?w=800&h=400&fit=crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab: Generate a CSR and Sign It with Your Mini-CA",
                  language: "bash",
                  code: "# Prerequisite: You have created a mini-CA from the previous lesson (intermediate-ca.key and intermediate-ca.crt).\n\n# Step 1: Generate a private key and CSR for a web server.\nopenssl genrsa -out server.key 2048\nopenssl req -new -key server.key -out server.csr -subj \"/C=US/ST=CA/O=My Website/CN=www.mywebsite.com\"\n\n# At this point, `server.csr` is what you would submit to a public CA.\n\n# Step 2: View the contents of the CSR to verify.\nopenssl req -in server.csr -text -noout -verify\n\n# Step 3: Act as the CA and sign the server's CSR using your Intermediate CA.\n# The output file, `server.crt`, is the final, signed certificate for your web server.\nopenssl x509 -req -in server.csr -CA intermediate-ca.crt -CAkey intermediate-ca.key -CAcreateserial -out server.crt -days 365 -sha256\n\n# Step 4: Verify the newly signed certificate.\n# Check the Issuer, Subject, and verify the signature against the intermediate CA's public certificate.\nopenssl x509 -in server.crt -text -noout\nopenssl verify -CAfile intermediate-ca.crt server.crt\n# The output should be: server.crt: OK",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the primary purpose of a Certificate Signing Request (CSR)?",
                  options: [
                    "To encrypt website data.",
                    "To provide a web server with its private key.",
                    "To formally request a signed certificate from a CA, containing the applicant's public key and identity.",
                    "To revoke an existing certificate.",
                  ],
                  correct: 2,
                  explanation:
                    "A CSR is a structured request containing all the information a CA needs to create a certificate for an applicant.",
                },
                {
                  id: 2,
                  question: "The applicant signs the CSR with which key?",
                  options: [
                    "The applicant's new public key.",
                    "The applicant's new private key.",
                    "The CA's public key.",
                    "The CA's private key.",
                  ],
                  correct: 1,
                  explanation:
                    "Signing the CSR with the applicant's own private key is a proof-of-possession step. It proves to the CA that the applicant controls the private key that corresponds to the public key in the CSR.",
                },
                {
                  id: 3,
                  question:
                    "Which key does the Certificate Authority use to sign the final certificate?",
                  options: [
                    "The applicant's public key.",
                    "The applicant's private key.",
                    "The CA's public key.",
                    "The CA's private key.",
                  ],
                  correct: 3,
                  explanation:
                    "The CA applies its digital signature by using its own private key. This is what makes the certificate trusted by others.",
                },
              ],
            },
          },
          {
            id: "lesson-6",
            title: "Public & Private Key Management",
            duration: "75 min",
            objectives: [
              "Understand the critical importance of private key security",
              "Compare different methods of key storage",
              "Define a Hardware Security Module (HSM) and its role in PKI",
              "Implement basic key protection using file permissions",
            ],
            content: {
              overview:
                "A certificate is public, but the corresponding private key is the most critical secret in a PKI. The security of the entire system hinges on protecting these private keys from theft or misuse. This lesson covers the principles of secure key management, from basic filesystem protections to the use of specialized hardware.",
              sections: [
                {
                  title: "The Sanctity of the Private Key",
                  content:
                    "<p>The entire trust model of PKI is based on the assumption that only the legitimate owner has access to a private key. If a private key is compromised, an attacker can:</p><ul><li><strong>Impersonate the Owner:</strong> An attacker with a web server's private key can impersonate that server, performing undetectable Man-in-the-Middle attacks.</li><li><strong>Decrypt Communications:</strong> If the key was used for key exchange (in non-forward-secret ciphers), an attacker may be able to decrypt past captured traffic.</li><li><strong>Forge Signatures:</strong> If it's a code-signing or email-signing key, an attacker can sign malicious software or fraudulent emails in the owner's name.</li></ul><p>Therefore, protecting private keys is the most important operational aspect of managing a PKI. <strong>A compromised private key requires the immediate revocation of its corresponding certificate.</strong></p>",
                  image:
                    "https://images.unsplash.com/photo-1594402633342-a08b3c31fad1?w=800&h=400&fit=crop",
                },
                {
                  title: "Key Storage Methods",
                  content:
                    "<h3>Software-based Storage</h3><p>For many applications, private keys are stored as files on a server's filesystem (e.g., a `.pem` or `.key` file). In this case, security relies on:<ul><li><strong>Strict File Permissions:</strong> The key file must be readable only by the root user and the service that needs it (e.g., the web server process). It must not be readable by other users.</li><li><strong>Encryption at Rest:</strong> The server's hard drive should be encrypted to protect the key if the physical server is stolen.</li><li><strong>Passphrase Protection:</strong> The key file itself can be encrypted with a strong passphrase, which must be entered when the service starts. This adds a layer of protection but can complicate automated restarts.</li></ul></p><h3>Hardware Security Modules (HSMs)</h3><p>For high-value keys, such as those belonging to a CA or a busy e-commerce site, software storage is not sufficient. A <strong>Hardware Security Module (HSM)</strong> is the industry standard for securing critical private keys. An HSM is a dedicated, tamper-resistant cryptographic processor.<ul><li><strong>Keys Never Leave the Device:</strong> Private keys are generated inside the HSM and can never be exported.</li><li><strong>Cryptographic Operations Happen Inside:</strong> To use a key, an application sends data to the HSM, and the HSM performs the signing or decryption operation internally and returns only the result.</li><li><strong>Physical Security:</strong> HSMs have physical protections that cause them to wipe their keys if they detect tampering.</li></ul><p>HSMs provide the highest level of assurance that a private key cannot be stolen, even if the server it's attached to is fully compromised.",
                  image:
                    "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit=crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab: Securing a Private Key with File Permissions",
                  language: "bash",
                  code: "# Assume you have a private key file named `server.key` for your Nginx web server.\n\n# Step 1: Check the default permissions. Often, the file is created with overly permissive access.\nls -l server.key\n# Example output: -rw-r--r-- 1 myuser mygroup 1704 Aug 28 15:00 server.key\n# This is BAD. It means myuser can read/write, and mygroup and others can read it.\n\n# Step 2: Set the owner to the root user. The nginx process, which runs as root initially to bind to port 443, will be able to read it.\n# In some setups, you might create a special group.\nsudo chown root:root server.key\n\n# Step 3: Set strict file permissions.\n# `chmod 400` sets the permissions to `r--------`.\n# This means ONLY the owner (root) can read the file. No one can write to it, and no one else can read it.\nsudo chmod 400 server.key\n\n# Step 4: Verify the new, secure permissions.\nls -l server.key\n# Expected output: -r-------- 1 root root 1704 Aug 28 15:00 server.key\n\n# This basic filesystem hygiene is a critical first step in protecting private keys.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the most immediate action required if a private key is compromised?",
                  options: [
                    "Generate a new key pair.",
                    "Request a longer validity period for the certificate.",
                    "Immediately revoke the corresponding certificate.",
                    "Update the web server software.",
                  ],
                  correct: 2,
                  explanation:
                    "Revocation is the only way to signal to clients that the certificate associated with the stolen key is no longer trustworthy.",
                },
                {
                  id: 2,
                  question: "What is a Hardware Security Module (HSM)?",
                  options: [
                    "A type of firewall.",
                    "A software tool for encrypting files.",
                    "A tamper-resistant hardware device for securely storing keys and performing cryptographic operations.",
                    "A USB drive for backing up certificates.",
                  ],
                  correct: 2,
                  explanation:
                    "An HSM is a physical device that provides the highest level of security for private keys, as the keys are never exposed in software or system memory.",
                },
                {
                  id: 3,
                  question:
                    "What does the 'chmod 400' command do on a key file?",
                  options: [
                    "Makes the key file readable and writable by everyone.",
                    "Deletes the key file.",
                    "Sets the permissions so that only the owner can read the file, and no one can write or execute it.",
                    "Encrypts the key file with a password.",
                  ],
                  correct: 2,
                  explanation:
                    "This permission set (read-only for the owner) is a best practice for private key files, preventing unauthorized users from reading them and protecting against accidental modification.",
                },
              ],
            },
          },
          {
            id: "lesson-7",
            title: "The Certificate Lifecycle",
            duration: "60 min",
            objectives: [
              "Outline the complete lifecycle of a digital certificate",
              "Differentiate between certificate renewal and re-keying",
              "Explain the purpose and process of certificate revocation",
              "Understand the importance of automating lifecycle events",
            ],
            content: {
              overview:
                "A digital certificate is not a 'set it and forget it' object. It has a well-defined lifecycle, from its creation to its eventual retirement. Understanding and managing this lifecycle is crucial for maintaining a secure and reliable PKI. This lesson covers the key stages: issuance, renewal, and revocation.",
              sections: [
                {
                  title: "Stages of the Certificate Lifecycle",
                  content:
                    "<p>The certificate lifecycle is the sequence of stages a certificate goes through from its creation to its invalidation.</p><ol><li><strong>Issuance:</strong> The process begins with generating a key pair, creating a CSR, submitting it to a CA, and receiving the signed certificate.</li><li><strong>Active Use:</strong> The certificate is installed on a server, device, or by a user and is actively used to establish trust and secure communications. The relying parties continually check its validity period and revocation status.</li><li><strong>Renewal:</strong> As a certificate approaches its expiration date, it must be renewed to maintain service. A new certificate is issued to replace the expiring one.</li><li><strong>Revocation:</strong> If a certificate needs to be invalidated before its expiration date (e.g., due to key compromise), it is revoked. A revoked certificate is no longer valid.</li><li><strong>Expiration:</strong> If not renewed, a certificate expires and is no longer considered valid by any client.</li></ol>",
                  image:
                    "https://images.unsplash.com/photo-1516110833953-7a916730302b?w=800&h=400&fit=crop",
                },
                {
                  title: "Renewal and Re-Keying",
                  content:
                    "<p>Certificate renewal is the process of getting a new certificate for the same identity before the current one expires. There are two ways to do this:</p><ul><li><strong>Renewal:</strong> A new certificate is issued with the same public key and a new validity period. This is simpler but less secure.</li><li><strong>Re-Keying:</strong> A new private/public key pair is generated, and a new CSR is submitted to get a new certificate. This is the recommended best practice as it adheres to the principle of crypto-period, which states that keys should be retired and replaced on a regular schedule. It limits the amount of data that could be compromised if a single key were ever stolen.</li></ul><p>Modern certificate automation tools like ACME/Certbot perform a re-key on every renewal by default.</p>",
                  image:
                    "https://images.unsplash.com/photo-1599507578794-279213135e13?w=800&h=400&fit=crop",
                },
                {
                  title: "Revocation: The Emergency Stop",
                  content:
                    "<p>Revocation is the act of prematurely invalidating a certificate. It is a critical security function for responding to incidents. Once a CA revokes a certificate, it adds its serial number to the official revocation list (CRL) and its OCSP responders will report its status as 'revoked'.</p><p>The most common and urgent reason for revocation is the known or suspected compromise of the certificate's private key. Once revoked, a certificate should never be trusted again, even if it is within its original validity period.</p>",
                  image:
                    "https://images.unsplash.com/photo-1554867375-3c1397f3957f?w=800&h=400&fit=crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab: Revoke a Certificate Using Your OpenSSL Mini-CA",
                  language: "bash",
                  code: "# Prerequisite: Your OpenSSL CA setup from a previous lesson, and a signed `server.crt`.\n# OpenSSL maintains a database file (`index.txt`) to track issued certificates.\n\n# Step 1: Initialize the CA database (do this only once for your CA).\ntouch index.txt\necho 1000 > serial\n\n# NOTE: When you sign certs, you'll need a more complex `openssl.cnf` for a real CA,\n# but we can do a manual revocation.\n\n# Step 2: Revoke the certificate. You must have the original certificate to do this.\n# (This assumes a proper openssl.cnf is configured. For simplicity, we are showing the command.)\n# In a real setup, your openssl.cnf file must point to the 'index.txt' database.\n\n# The command would be:\n# openssl ca -config openssl.cnf -revoke server.crt -keyfile intermediate-ca.key -cert intermediate-ca.crt\n\n# Step 3: Generate the Certificate Revocation List (CRL).\n# After revoking one or more certificates, you must publish a new CRL.\n\n# The command would be:\n# openssl ca -config openssl.cnf -gencrl -out crl.pem -keyfile intermediate-ca.key -cert intermediate-ca.crt\n\n# Step 4: Inspect the CRL.\n# You can view the contents of the CRL to see the serial numbers of the revoked certs.\nopenssl crl -in crl.pem -text -noout\n\n# This lab demonstrates the CA-side process of marking a certificate as invalid and publishing that fact.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the primary difference between certificate expiration and revocation?",
                  options: [
                    "There is no difference.",
                    "Expiration is the natural end of a certificate's life, while revocation is a forced, premature invalidation.",
                    "Revocation is automatic, while expiration must be done manually.",
                    "Expiration is for users, revocation is for servers.",
                  ],
                  correct: 1,
                  explanation:
                    "Expiration is a predictable, time-based event. Revocation is an immediate, unscheduled event triggered by a security incident like key compromise.",
                },
                {
                  id: 2,
                  question: "What is 're-keying' a certificate?",
                  options: [
                    "Changing the password on the key file.",
                    "Getting a new certificate with a new validity date but the same public/private key pair.",
                    "Generating a new private/public key pair and issuing a completely new certificate for the same identity.",
                    "Decrypting a key file.",
                  ],
                  correct: 2,
                  explanation:
                    "Re-keying is the best practice for renewal, as it creates a fresh set of cryptographic keys, limiting the lifetime of any single key.",
                },
                {
                  id: 3,
                  question:
                    "Why is automating the certificate lifecycle important?",
                  options: [
                    "It makes certificates more expensive.",
                    "It is the only way to generate a private key.",
                    "It reduces the risk of service outages due to human error, like forgetting to renew a certificate.",
                    "It weakens the encryption strength.",
                  ],
                  correct: 2,
                  explanation:
                    "Manual certificate management is error-prone. Automation ensures certificates are renewed on time and reduces the administrative burden, especially with short-lived certificates.",
                },
              ],
            },
          },
          {
            id: "lesson-8",
            title: "Revocation Methods (CRL, OCSP)",
            duration: "75 min",
            objectives: [
              "Explain how clients check if a certificate has been revoked",
              "Describe the mechanism and drawbacks of Certificate Revocation Lists (CRLs)",
              "Describe the mechanism and drawbacks of the Online Certificate Status Protocol (OCSP)",
              "Explain how OCSP Stapling addresses the issues of basic OCSP",
            ],
            content: {
              overview:
                "A certificate being within its validity period is not enough to trust it; you must also know that it hasn't been revoked. This lesson details the two main protocols clients use to check a certificate's revocation status: the original CRL method and the more modern OCSP, including the critical 'OCSP Stapling' enhancement.",
              sections: [
                {
                  title: "Certificate Revocation Lists (CRL)",
                  content:
                    "<p>A CRL is the original mechanism for checking revocation status. It is a digitally signed list, published by a CA, containing the serial numbers of all certificates that have been revoked. When a client application (like a browser) validates a certificate, it is supposed to download the latest CRL from a URL specified in the certificate (the 'CRL Distribution Point').</p><h3>Problems with CRLs:</h3><ul><li><strong>Latency and Size:</strong> CRLs from major CAs can grow to be many megabytes in size. Requiring a client to download this large file during a new connection adds significant latency.</li><li><strong>Stale Data:</strong> CRLs are typically updated on a fixed schedule (e.g., once every 24 hours). This creates a window of risk where a certificate might be revoked, but clients won't know about it until the next CRL is published.</li><li><strong>Failure Modes:</strong> If the CRL distribution point is unavailable, the client has to make a choice: fail the connection ('hard fail'), or proceed as if the certificate is valid ('soft fail'). Most browsers chose the 'soft fail' approach, which means a network outage could render revocation checking useless.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1550751827-463d1a88439e?w=800&h=400&fit=crop",
                },
                {
                  title: "Online Certificate Status Protocol (OCSP)",
                  content:
                    "<p>OCSP was created to solve the size and freshness problems of CRLs. With OCSP, instead of downloading a whole list, the client sends a small query to a CA's server (an 'OCSP responder') asking for the status of a single certificate by its serial number. The responder sends back a small, signed response: `good`, `revoked`, or `unknown`.</p><h3>Problems with OCSP:</h3><ul><li><strong>Performance Bottleneck:</strong> The client's connection setup is now dependent on a third-party server (the OCSP responder). If that server is slow or down, it delays the connection.</li><li><strong>Privacy Leak:</strong> The OCSP request reveals the user's browsing habits to the CA. Every time you visit an HTTPS site, a request could go to the CA's OCSP server, telling them exactly which site you're on and when.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1548092372-2d987bde898b?w=800&h=400&fit=crop",
                },
                {
                  title: "The Solution: OCSP Stapling",
                  content:
                    "<p><strong>OCSP Stapling</strong> (formally, the TLS Certificate Status Request extension) solves the problems of both performance and privacy. The responsibility for checking the revocation status is shifted from the end-user's browser to the web server itself.</p><p>The process is as follows: The web server periodically queries the OCSP responder for its own certificate's status. The server receives the signed, timestamped OCSP response and caches it. When a new client connects, the web server 'staples' this cached OCSP response onto the TLS handshake. The browser receives both the certificate and the proof of its current status directly from the server. This means:</p><ul><li><strong>It's Faster:</strong> The browser doesn't need to make a separate, blocking call to a third-party server.</li><li><strong>It's Private:</strong> The browser doesn't reveal any information to the CA.</li><li><strong>It's More Reliable:</strong> It's not dependent on the CA's OCSP responder being online at the moment of connection.</li></ul><p>For these reasons, enabling OCSP Stapling on a web server is a critical modern security best practice.</p>",
                  image:
                    "https://images.unsplash.com/photo-1594708911226-9f874ce5a535?w=800&h=400&fit=crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab: Test for OCSP Stapling on a Live Server",
                  language: "bash",
                  code: "# We can use the openssl s_client command to check if a server is sending an OCSP Stapled response.\n\n# Step 1: Connect to a server known to have good TLS practices (like google.com).\n# The `-status` flag tells the client to request a stapled OCSP response from the server.\nopenssl s_client -connect www.google.com:443 -servername www.google.com -status\n\n# Step 2: Analyze the output.\n# Scroll up through the handshake information and look for the 'OCSP response:' section.\n\n# A server that ISN'T stapling will show:\n# OCSP Response: no response sent\n\n# A server that IS stapling will show detailed output, like:\n# OCSP Response Data:\n#     OCSP Response Status: successful (0x0)\n#     ... (details of the responder, timestamps) ...\n#     Cert Status: good\n#     ... (more details) ...\n\n# This confirms that the server is correctly configured for OCSP Stapling.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is a major disadvantage of using CRLs for revocation checking?",
                  options: [
                    "They are too secure.",
                    "They provide real-time status updates.",
                    "They can become very large, and the data can be hours or days out of date.",
                    "They cannot be read by browsers.",
                  ],
                  correct: 2,
                  explanation:
                    "CRLs suffer from issues of size (performance) and latency (freshness), as clients have to download the whole list, which is only updated periodically.",
                },
                {
                  id: 2,
                  question:
                    "Which of the following is a significant privacy concern with the basic OCSP protocol?",
                  options: [
                    "It uses weak encryption.",
                    "It reveals the user's browsing history to the Certificate Authority.",
                    "It requires the user to submit their private key.",
                    "It is too slow to be useful.",
                  ],
                  correct: 1,
                  explanation:
                    "Each time a client makes an OCSP query, it effectively tells the CA which website certificate it is checking, thus leaking browsing data.",
                },
                {
                  id: 3,
                  question: "How does OCSP Stapling improve user privacy?",
                  options: [
                    "It encrypts the OCSP request.",
                    "It removes the need for revocation checking.",
                    "The browser gets the revocation status from the web server, so it doesn't need to contact the CA directly.",
                    "It uses a different, more private protocol.",
                  ],
                  correct: 2,
                  explanation:
                    "By shifting the OCSP query to the web server, OCSP Stapling eliminates the direct communication channel between the end-user's browser and the CA, thus preserving privacy.",
                },
              ],
            },
          },
          {
            id: "lesson-9",
            title: "PKI Trust Models",
            duration: "60 min",
            objectives: [
              "Identify the three primary PKI trust models",
              "Describe the Hierarchical trust model and its common use case",
              "Describe the Web of Trust (Mesh) model",
              "Understand the purpose of a Bridge CA",
            ],
            content: {
              overview:
                "While the hierarchical model with a single root is the most common PKI structure, it's not the only one. Different situations call for different ways of establishing trust. This lesson explores the dominant Hierarchical model, the decentralized 'Web of Trust' model, and the Bridge model used to connect disparate PKIs.",
              sections: [
                {
                  title: "Hierarchical Trust Model",
                  content:
                    "<p>This is the most common model and the one used by the public web PKI. It's a top-down, tree-like structure. </p><ul><li>At the top is a single <strong>Root CA</strong>, which acts as the ultimate trust anchor.</li><li>The Root CA signs certificates for one or more <strong>Intermediate CAs</strong>.</li><li>The Intermediate CAs then sign certificates for end entities.</li></ul><p>Trust flows in one direction: downward from the root. A certificate is trusted only if it has a valid path back to the root. This model is centralized, scalable, and relatively simple to manage, which is why it's so successful for the public internet and in most large enterprises.</p>",
                  image: "https://i.imgur.com/3pQkP5d.png",
                },
                {
                  title: "Web of Trust (Mesh) Model",
                  content:
                    "<p>The Web of Trust is a decentralized trust model. Instead of relying on a central authority, trust is established by individual participants directly vouching for one another. There is no concept of a root or hierarchy. Each user has their own key pair and can sign the public keys of other users they know and trust.</p><p>To trust a new, unknown key, you check to see if it has been signed by someone whose key you already trust. You can define how much trust you place in others to vouch for third parties. This model is most famously used by <strong>Pretty Good Privacy (PGP)</strong> for email encryption and signing. It's highly resilient but can be complex to manage and does not scale well for public, anonymous transactions like e-commerce.</p>",
                  image: "https://i.imgur.com/gK2J8Xl.png",
                },
                {
                  title: "Bridge CA and Cross-Certification",
                  content:
                    "<p>What happens when two separate organizations, each with their own hierarchical PKI, need to trust each other's certificates? For example, after a corporate merger. One solution is to use cross-certification.</p><p>In cross-certification, the Root CA of PKI 'A' signs the Root CA certificate of PKI 'B', and vice-versa. This creates a two-way trust relationship. However, this becomes unmanageable if you have many PKIs to connect.</p><p>A more scalable solution is a <strong>Bridge CA</strong>. A Bridge CA acts as a central hub of trust. Instead of all the PKIs cross-certifying with each other (a mesh), they each establish a single trust relationship with the Bridge CA. The Bridge CA doesn't issue certificates to end entities, it only creates trust paths between the different participating CAs. This allows a user in PKI 'A' to validate and trust a certificate issued by PKI 'B' by routing that trust through the bridge.</p>",
                  image: "https://i.imgur.com/9C3oFhO.png",
                },
              ],
              codeExamples: [
                {
                  title: "Lab: Observe Trust Chains in a Browser",
                  language: "bash",
                  code: "# The easiest way to visualize a hierarchical trust chain is in your web browser.\n\n# Step 1: Navigate to a secure website, e.g., https://www.google.com\n\n# Step 2: Click the padlock icon in the address bar.\n\n# Step 3: Click 'Connection is secure', then 'Certificate is valid' (or similar wording depending on your browser).\n\n# Step 4: A certificate viewer window will open. Find the tab labeled 'Certification Path' or 'Details' and look for the hierarchy.\n\n# You will see a tree structure that shows:\n# - [Root CA] e.g., GTS Root R1\n#   - [Intermediate CA] e.g., GTS CA 1D4\n#     - [End-entity Certificate] e.g., *.google.com\n\n# This visualizes the hierarchical trust model, where the server's certificate is trusted because it was signed by an Intermediate, which in turn was signed by a Root that is in your browser's trust store.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "Which trust model is used by the public SSL/TLS certificates for websites?",
                  options: [
                    "Web of Trust",
                    "Hierarchical",
                    "Bridge CA",
                    "Direct Trust",
                  ],
                  correct: 1,
                  explanation:
                    "The public web PKI is based on a strict hierarchical model with a limited number of trusted Root CAs at the top.",
                },
                {
                  id: 2,
                  question:
                    "PGP (Pretty Good Privacy) is a famous example of which trust model?",
                  options: [
                    "Hierarchical",
                    "Bridge CA",
                    "Web of Trust (Mesh)",
                    "Single Root",
                  ],
                  correct: 2,
                  explanation:
                    "PGP uses a decentralized model where individual users create a 'web of trust' by signing each other's keys, rather than relying on a central authority.",
                },
                {
                  id: 3,
                  question: "What is the primary purpose of a Bridge CA?",
                  options: [
                    "To issue certificates directly to end users.",
                    "To replace all Root CAs with a single entity.",
                    "To act as a central trust hub to connect multiple, independent PKI hierarchies.",
                    "To provide a less secure, but faster, form of PKI.",
                  ],
                  correct: 2,
                  explanation:
                    "A Bridge CA is a scalable solution for establishing trust between different organizations, each with its own internal PKI, without having to create a complex mesh of cross-certifications.",
                },
              ],
            },
          },
          {
            id: "lesson-10",
            title: "Email Security with PKI (S/MIME)",
            duration: "60 min",
            objectives: [
              "Define S/MIME and its two main security functions",
              "Explain how digital signatures provide authenticity and non-repudiation for email",
              "Explain how encryption provides confidentiality for email",
              "Understand the public key exchange requirements for sending an encrypted email",
            ],
            content: {
              overview:
                "PKI extends beyond servers to secure communication between individuals. The S/MIME standard leverages an X.509 PKI to bring digital signatures and encryption to email, allowing users to send messages that are both authenticated and confidential.",
              sections: [
                {
                  title: "What is S/MIME?",
                  content:
                    "<p><strong>S/MIME</strong> stands for <strong>Secure/Multipurpose Internet Mail Extensions</strong>. It is a widely accepted standard for sending and receiving secure email. S/MIME is built upon a PKI, requiring users to obtain personal digital certificates from a trusted Certificate Authority. It provides two main security services, which can be used independently or together.</p>",
                  image:
                    "https://images.unsplash.com/photo-1596526131034-9b8d239102b4?w=800&h=400&fit=crop",
                },
                {
                  title: "1. Digital Signatures: Authenticity and Integrity",
                  content:
                    "<p>When you digitally sign an email with S/MIME, your email client uses your <strong>private key</strong> to create a unique signature based on the content of the message. This signature is attached to the email. When the recipient opens the email, their client uses your public key (usually attached to the signed message) to verify the signature.</p><p>A successful verification proves three things:</p><ul><li><strong>Authentication:</strong> The email truly came from you, as only you possess the private key capable of creating that signature.</li><li><strong>Integrity:</strong> The email content has not been altered since it was signed. Any modification would cause the signature verification to fail.</li><li><strong>Non-repudiation:</strong> The sender cannot later deny sending the message, as the signature is cryptographically unique to them.</li></ul><p>A digitally signed email shows a checkmark or ribbon icon in most email clients.</p>",
                  image: "https://i.imgur.com/uR1d3X5.png",
                },
                {
                  title: "2. Encryption: Confidentiality",
                  content:
                    "<p>While a signature proves who sent a message, it doesn't hide the content. To ensure confidentiality, you must encrypt the email. To do this, your email client uses the recipient's <strong>public key</strong> to encrypt the message content. Once encrypted, the message can <em>only</em> be decrypted by the recipient using their corresponding <strong>private key</strong>.</p><p>This creates a major prerequisite: <strong>to send someone an encrypted email, you must first have their public key</strong>. This is often accomplished by first exchanging digitally signed emails. When someone sends you a signed email, their email client typically attaches their certificate, which contains their public key. Your client can then add this certificate to your address book, allowing you to encrypt future messages to them.</p><p>An encrypted email shows a padlock icon in most email clients.</p>",
                  image: "https://i.imgur.com/7gN6gT9.png",
                },
              ],
              codeExamples: [
                {
                  title: "Lab: Send a Signed Email with Thunderbird",
                  language: "bash",
                  code: "# This lab requires an S/MIME certificate and the Mozilla Thunderbird email client.\n# (You can get free trial S/MIME certificates from various CAs).\n\n# Step 1: Obtain your S/MIME certificate. It will usually be in a .p12 or .pfx file, which contains both your certificate and your encrypted private key.\n\n# Step 2: Import the certificate into Thunderbird.\n# Go to 'Account Settings' > [Your Account] > 'End-To-End Encryption'.\n# In the S/MIME section, click 'Manage S/MIME Certificates'.\n# Click 'Import...', select your .p12 file, and enter the password you used when creating it.\n\n# Step 3: Configure your account to use the certificate for signing.\n# In the End-To-End Encryption settings, select your imported certificate for 'Digital Signing'.\n\n# Step 4: Compose a new email.\n# You will now see a 'Security' dropdown in the compose window.\n# Select 'Digitally Sign This Message'. A checkmark icon should appear.\n\n# Step 5: Send the email to yourself or a colleague.\n# When you receive the email, Thunderbird will display a sealed envelope icon with a checkmark, indicating the signature is valid. Clicking on it will show the certificate details, confirming the sender's identity.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "Which key is used to create a digital signature on an email?",
                  options: [
                    "The sender's public key",
                    "The recipient's public key",
                    "The sender's private key",
                    "The recipient's private key",
                  ],
                  correct: 2,
                  explanation:
                    "Creating a signature is an operation that only the sender can do, so it requires their secret, private key.",
                },
                {
                  id: 2,
                  question:
                    "Which key is used to encrypt an email so that only the intended recipient can read it?",
                  options: [
                    "The sender's public key",
                    "The recipient's public key",
                    "The sender's private key",
                    "The recipient's private key",
                  ],
                  correct: 1,
                  explanation:
                    "Data is encrypted with the recipient's public key, ensuring that only the person holding the corresponding private key can decrypt it.",
                },
                {
                  id: 3,
                  question:
                    "What is 'non-repudiation' in the context of a digitally signed email?",
                  options: [
                    "The message content cannot be read by anyone else.",
                    "The sender cannot deny having sent the message, because the signature is unique to them.",
                    "The message is guaranteed to be delivered.",
                    "The sender's identity is kept anonymous.",
                  ],
                  correct: 1,
                  explanation:
                    "Non-repudiation is the assurance that someone cannot deny the validity of something. A digital signature provides this by being cryptographically tied to the sender's private key.",
                },
              ],
            },
          },
          {
            id: "lesson-11",
            title: "Code Signing Certificates",
            duration: "60 min",
            objectives: [
              "Explain the purpose of code signing",
              "Describe how code signing provides software authenticity and integrity",
              "Differentiate between standard and Extended Validation (EV) code signing certificates",
              "Understand the role of timestamping in code signing",
            ],
            content: {
              overview:
                "How can you be sure that the software you download and install is from the legitimate publisher and hasn't been infected with malware? Code signing is the PKI-based solution to this problem, providing a way for developers to digitally sign their applications, ensuring authenticity and integrity for end-users.",
              sections: [
                {
                  title: "Why Sign Code?",
                  content:
                    "<p>Distributing software over the internet is risky. Malicious actors can intercept downloads and inject malware, or they can create fake software that masquerades as a legitimate application. Code signing uses digital signatures to protect users from these threats.</p><p>When a developer signs their application, they are creating a digital fingerprint of the software and signing that fingerprint with their private key. This provides two key guarantees to the user's operating system:</p><ul><li><strong>Authenticity:</strong> The signature can be verified using the developer's public key (from their code signing certificate). This proves the software was created by the publisher who owns the key.</li><li><strong>Integrity:</strong> Before running the software, the operating system calculates its own fingerprint of the executable file. If this matches the fingerprint in the digital signature, it proves the code has not been altered or corrupted since it was signed.</li></ul><p>If the signature is missing, invalid, or belongs to an untrusted publisher, the OS will display a stern security warning.</p>",
                  image: "https://i.imgur.com/8QnU42j.png",
                },
                {
                  title: "Standard vs. EV Code Signing",
                  content:
                    "<p>Similar to SSL/TLS certificates, code signing certificates come in different validation levels:</p><ul><li><strong>Standard Code Signing:</strong> The CA verifies the identity of the developer or organization. Signed applications may initially face reputation filters (like Microsoft SmartScreen) until the certificate builds a positive history.</li><li><strong>Extended Validation (EV) Code Signing:</strong> This requires a much more stringent vetting process for the publisher. In return, EV-signed applications get immediate reputation with operating system security filters. A major security requirement for EV code signing is that the private key must be stored and used on a physical hardware token (HSM or a similar secure USB token). This prevents the key from being stolen by malware on the developer's machine.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1542382257-80ded13c79c8?w=800&h=400&fit=crop",
                },
                {
                  title: "Timestamping",
                  content:
                    "<p>What happens to the signature on a piece of software when the code signing certificate expires? Without timestamping, the signature would become invalid. This would be a major problem for software that has been installed for years.</p><p>To solve this, developers include a <strong>timestamp</strong> when they sign their code. During the signing process, they send a hash of their code to a trusted Time Stamping Authority (TSA). The TSA returns a signed, dated timestamp, which is embedded alongside the developer's own signature. This provides cryptographic proof that the code was signed at a time when the developer's certificate was valid. Because of this, the signature on the software will remain valid long after the original certificate has expired.</p>",
                  image:
                    "https://images.unsplash.com/photo-1508921340878-ba53e1f416c5?w=800&h=400&fit=crop",
                },
              ],
              codeExamples: [
                {
                  title:
                    "Lab: Sign and Verify a Windows Executable (Conceptual)",
                  language: "bash",
                  code: "# Signing an executable requires platform-specific tools, like Microsoft's SignTool for Windows.\n# This lab outlines the process.\n\n# Prerequisites:\n# - A code signing certificate and key (e.g., in a .pfx file).\n# - The Windows SDK, which includes signtool.exe.\n# - An executable to sign (e.g., myapp.exe).\n\n# Step 1: Sign the executable.\n# The command points to the PFX file, provides its password, specifies a timestamp server, and points to the file to sign.\n\n# signtool.exe sign /f MyCert.pfx /p MyPassword /t http://timestamp.digicert.com /v myapp.exe\n\n# The '/t' flag is crucial for adding the timestamp.\n\n# Step 2: Verify the signature.\n# Anyone can now verify the signature on the application.\n\n# Method A: Using SignTool\n# signtool.exe verify /pa /v myapp.exe\n\n# Method B: Using the Windows GUI\n# 1. Right-click on `myapp.exe`.\n# 2. Go to the 'Digital Signatures' tab.\n# 3. Select the signature from the list and click 'Details'.\n# 4. A window will pop up stating 'This digital signature is OK' and showing the signer's information and the timestamp.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What are the two primary security guarantees provided by code signing?",
                  options: [
                    "Confidentiality and Speed",
                    "Authenticity and Integrity",
                    "Availability and Encryption",
                    "Privacy and Anonymity",
                  ],
                  correct: 1,
                  explanation:
                    "Code signing proves who the software publisher is (authenticity) and that the code has not been tampered with since it was published (integrity).",
                },
                {
                  id: 2,
                  question:
                    "What is a major requirement for an Extended Validation (EV) code signing certificate?",
                  options: [
                    "The developer must be famous.",
                    "The private key must be stored in a secured hardware token.",
                    "The software must be open source.",
                    "The certificate must be renewed every 30 days.",
                  ],
                  correct: 1,
                  explanation:
                    "EV code signing mandates the use of a hardware token to protect the private key from being stolen, providing a much higher level of assurance.",
                },
                {
                  id: 3,
                  question:
                    "What is the purpose of timestamping a digital signature on software?",
                  options: [
                    "To make the software run faster.",
                    "To prove that the code was signed when the certificate was valid, allowing the signature to remain trusted after the certificate expires.",
                    "To add the current date and time to the application's user interface.",
                    "To encrypt the executable file.",
                  ],
                  correct: 1,
                  explanation:
                    "Timestamping ensures the long-term validity of a signature by providing cryptographic proof of the time of signing.",
                },
              ],
            },
          },
          {
            id: "lesson-12",
            title: "SSL/TLS Certificates in PKI",
            duration: "75 min",
            objectives: [
              "Synthesize how the core PKI components enable secure web browsing",
              "Trace the path of trust from a browser to a Root CA for a given website",
              "Explain the role of the CSR, certificate chain, and revocation checking in a TLS handshake",
              "Reinforce the importance of proper server configuration",
            ],
            content: {
              overview:
                "This crucial lesson connects all the dots, illustrating how the abstract concepts of Public Key Infrastructure directly enable the secure, everyday experience of browsing the web with HTTPS. We will walk through an entire SSL/TLS connection, highlighting every point where the PKI is involved, from certificate issuance to browser validation.",
              sections: [
                {
                  title: "From CSR to a Live Website",
                  content:
                    "<p>Let's recap the PKI process from the perspective of a website owner:</p><ol><li><strong>Key Generation:</strong> The administrator of `www.example.com` generates a private key and a public key on their web server.</li><li><strong>CSR Creation:</strong> They create a CSR that includes their public key and identifies `www.example.com` (and any other relevant domains) in the SAN field. They sign this CSR with their new private key.</li><li><strong>CA Validation:</strong> They submit the CSR to a public CA. The CA's RA validates that the administrator actually controls `www.example.com` (for a DV certificate).</li><li><strong>Issuance:</strong> The CA signs the certificate with its Intermediate CA private key and sends the signed certificate and the Intermediate CA certificate (the chain) back to the administrator.</li><li><strong>Installation:</strong> The administrator installs the private key, the signed certificate, and the certificate chain file on their web server (e.g., Apache or Nginx) and configures it to listen on port 443.</li></ol>",
                  image:
                    "https://images.unsplash.com/photo-1544197150-b2c4c47b0a34?w=800&h=400&fit=crop",
                },
                {
                  title: "The Browser's Perspective: Validating the Connection",
                  content:
                    "<p>Now, a user opens their browser and navigates to `https://www.example.com`. Here is how the browser uses PKI to validate the connection during the TLS handshake:</p><ol><li><strong>Receives the Certificate Chain:</strong> The server sends its certificate and the Intermediate CA's certificate to the browser.</li><li><strong>Checks the Signature:</strong> The browser looks at the server's certificate and sees it was signed by the Intermediate CA. It uses the public key from the Intermediate CA's certificate to verify this signature.</li><li><strong>Walks the Chain:</strong> The browser then looks at the Intermediate CA's certificate and sees it was signed by a Root CA (e.g., 'DigiCert Root CA').</li><li><strong>Checks the Trust Store:</strong> The browser checks its own internal trust store. If it finds the 'DigiCert Root CA' certificate in its list of trusted anchors, the chain is considered valid.</li><li><strong>Verifies the Name:</strong> The browser checks that the name `www.example.com` is listed in the SAN field of the server's certificate.</li><li><strong>Checks the Dates:</strong> It verifies that the current date and time are within the certificate's validity period.</li><li><strong>Checks Revocation Status:</strong> Finally, the browser checks if the certificate has been revoked. Ideally, the server 'staples' a fresh OCSP response to the handshake. If not, the browser may have to contact the CA's OCSP/CRL servers directly.</li></ol><p>Only if all these steps pass successfully will the browser display the padlock icon and proceed with the secure connection. Any failure results in a prominent security warning.</p>",
                  image:
                    "https://images.unsplash.com/photo-1555949963-aa79dcee981c?w=800&h=400&fit=crop",
                },
              ],
              codeExamples: [
                {
                  title:
                    "Lab: Issue a Web Server Certificate with Your Mini-CA",
                  language: "bash",
                  code: "# Prerequisite: Your OpenSSL mini-CA setup (Root and Intermediate CAs).\n\n# Step 1: Create a CSR for a web server, including a SAN field.\n# To do this properly, we need a small config file. Create `server.conf`:\n# [req]\n# distinguished_name = req_distinguished_name\n# req_extensions = v3_req\n# [req_distinguished_name]\n# countryName_default = US\n# ... (other fields)\n# [v3_req]\n# subjectAltName = @alt_names\n# [alt_names]\n# DNS.1 = my-secure-site.local\n# IP.1 = 192.168.1.10\n\n# Step 2: Generate the key and the CSR using the config file.\nopenssl genrsa -out my-site.key 2048\nopenssl req -new -key my-site.key -out my-site.csr -config server.conf\n\n# Step 3: Sign the CSR with your Intermediate CA.\nopenssl x509 -req -in my-site.csr -CA intermediate-ca.crt -CAkey intermediate-ca.key -CAcreateserial -out my-site.crt -days 365 -sha256 -extfile server.conf -extensions v3_req\n\n# Step 4: Create the full chain file for the web server.\ncat my-site.crt intermediate-ca.crt > my-site-chain.pem\n\n# You can now use `my-site-chain.pem` and `my-site.key` in your web server config to host an HTTPS site that is trusted by anyone who trusts your Root CA.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the 'certificate chain' that a web server sends to a browser?",
                  options: [
                    "A list of all the websites the user has visited.",
                    "The server's certificate plus all necessary Intermediate CA certificates needed to link it to a trusted Root CA.",
                    "The server's private key.",
                    "A list of revoked certificates.",
                  ],
                  correct: 1,
                  explanation:
                    "The chain provides the browser with a complete, verifiable path from the end-entity certificate back to a trust anchor.",
                },
                {
                  id: 2,
                  question:
                    "If a browser receives a certificate chain, what is the final step in validating that chain?",
                  options: [
                    "Checking the server's IP address.",
                    "Asking the user if they trust the site.",
                    "Confirming that the Root CA of the chain is present in the browser's own trusted root store.",
                    "Verifying the physical address of the company.",
                  ],
                  correct: 2,
                  explanation:
                    "The entire process of walking the chain is to establish a link to a pre-existing trust anchor. If the chain leads to an unknown root, it is considered untrusted.",
                },
                {
                  id: 3,
                  question:
                    "Which of these is NOT a check a browser performs when validating a certificate?",
                  options: [
                    "Verifying the signature chain back to a trusted root.",
                    "Checking that the requested domain name is in the certificate's SAN field.",
                    "Confirming that the private key strength is at least 4096 bits.",
                    "Checking that the certificate is not expired or revoked.",
                  ],
                  correct: 2,
                  explanation:
                    "The browser has no access to the server's private key and does not check its strength directly. It relies on the CA's policies and the information within the public certificate for algorithm details. 2048-bit RSA is still perfectly acceptable.",
                },
              ],
            },
          },
          {
            id: "lesson-13",
            title: "Device Certificates (IoT & Mobile)",
            duration: "60 min",
            objectives: [
              "Explain the challenge of uniquely identifying and securing IoT devices",
              "Describe how a PKI can provide a scalable identity solution for devices",
              "Understand the use of Mutual TLS (mTLS) for device authentication",
              "Describe the device certificate lifecycle",
            ],
            content: {
              overview:
                "In a world of billions of connected Internet of Things (IoT) devices and mobile applications, traditional authentication methods like passwords or API keys are often insecure and difficult to manage. PKI offers a robust, scalable solution by giving each device a unique cryptographic identity in the form of a digital certificate.",
              sections: [
                {
                  title: "The IoT Identity Challenge",
                  content:
                    "<p>Securing IoT deployments presents unique challenges. Devices are often physically insecure, operate on constrained networks, have limited processing power, and need to be managed remotely at a massive scale. Using a single shared secret or password for a fleet of thousands of devices is a security nightmare; a compromise of one device would compromise the entire fleet.</p><p>PKI solves this by providing a unique, non-shared credential for every single device. Each device is provisioned with its own certificate and private key, allowing it to securely authenticate itself to backend servers and other devices without relying on static passwords.</p>",
                  image:
                    "https://images.unsplash.com/photo-1584950333252-23c8a32a6881?w=800&h=400&fit=crop",
                },
                {
                  title: "PKI for Device Authentication",
                  content:
                    "<p>The most common pattern for using device certificates is <strong>Mutual TLS (mTLS)</strong>. When an IoT device connects to a cloud service or management platform, an mTLS handshake occurs:</p><ol><li>The server presents its certificate, and the device verifies it against a pre-loaded Root CA certificate. This ensures the device is talking to the legitimate server.</li><li>The device then presents its own client certificate to the server.</li><li>The server verifies the device's certificate against its own list of trusted device CAs. This proves the device is a legitimate, provisioned member of the IoT fleet.</li></ol><p>This two-way cryptographic authentication ensures that only trusted devices can connect to the server, and devices will only connect to the trusted server, effectively locking down the communication channel.</p>",
                  image:
                    "https://images.unsplash.com/photo-1629654297299-c8506221ca97?w=800&h=400&fit=crop",
                },
                {
                  title: "The Device Certificate Lifecycle",
                  content:
                    "<p>Managing certificates for millions of devices requires extensive automation.</p><ul><li><strong>Provisioning:</strong> The device's unique private key and certificate must be securely installed. This can happen in the factory during manufacturing, or during a secure 'bootstrapping' process when the device first connects to the network. The private key should ideally be stored in a secure hardware element on the device.</li><li><strong>Renewal:</strong> Devices need to be able to automatically renew their certificates before they expire. Protocols like ACME or proprietary management protocols are often used.</li><li><strong>Revocation:</strong> If a device is lost, stolen, or decommissioned, its certificate must be revoked in the backend PKI to immediately cut off its access.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit=crop",
                },
              ],
              codeExamples: [
                {
                  title:
                    "Lab: Issue a Certificate for an IoT Device (Conceptual)",
                  language: "bash",
                  code: "# Using your mini-CA from previous lessons, you can issue a certificate for a device.\n# Device identities are often encoded in the Common Name (CN), like the device's serial number.\n\n# Step 1: Generate a private key for the 'device'. In reality, this would happen on the device itself.\nopenssl genrsa -out device-A1B2C3.key 2048\n\n# Step 2: Create a CSR for the device. The CN uniquely identifies it.\n# Other fields like Organization can be used to identify the fleet.\nopenssl req -new -key device-A1B2C3.key -out device-A1B2C3.csr -subj \"/C=US/O=Smart Thermostats Inc/CN=A1-B2-C3-D4-E5-F6\"\n\n# Step 3: Sign the device CSR with your Intermediate CA.\n# Note that we are issuing a client certificate. We need to specify this with extensions.\n# Create a file 'client.ext':\n# extendedKeyUsage = clientAuth\n\nopenssl x509 -req -in device-A1B2C3.csr -CA intermediate-ca.crt -CAkey intermediate-ca.key -CAcreateserial -out device-A1B2C3.crt -days 730 -sha256 -extfile client.ext\n\n# Step 4: Provision the device.\n# You would now securely transfer `device-A1B2C3.key`, `device-A1B2C3.crt`, and `intermediate-ca.crt` to the device.\n# The device would use these to make an mTLS connection to a server that trusts your Root CA.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "Why is using a single shared password for thousands of IoT devices a bad idea?",
                  options: [
                    "It's too hard for the devices to remember.",
                    "The password might expire.",
                    "If the password is leaked, the entire fleet of devices is compromised.",
                    "PKI does not support passwords.",
                  ],
                  correct: 2,
                  explanation:
                    "Shared secrets are a single point of failure. PKI solves this by giving each device a unique credential, so the compromise of one does not affect the others.",
                },
                {
                  id: 2,
                  question:
                    "What is the most common authentication protocol used for securely connecting a certificated device to a server?",
                  options: [
                    "HTTP Basic Auth",
                    "OAuth 2.0",
                    "Mutual TLS (mTLS)",
                    "Username and Password",
                  ],
                  correct: 2,
                  explanation:
                    "Mutual TLS provides strong, two-way cryptographic authentication, where both the device and the server prove their identity to each other using certificates.",
                },
                {
                  id: 3,
                  question:
                    "What is 'device provisioning' in the context of a PKI?",
                  options: [
                    "Updating the device's firmware.",
                    "The process of securely installing the unique private key and certificate onto a device.",
                    "Assigning an IP address to the device.",
                    "Charging the device's battery.",
                  ],
                  correct: 1,
                  explanation:
                    "Provisioning is the critical setup step where a device receives its unique cryptographic identity.",
                },
              ],
            },
          },
          {
            id: "lesson-14",
            title: "Enterprise PKI with Active Directory",
            duration: "75 min",
            objectives: [
              "Define Active Directory Certificate Services (AD CS)",
              "Identify common use cases for an internal Windows PKI",
              "Understand how AD CS integrates with Group Policy for certificate auto-enrollment",
              "Explain the role of AD CS in securing internal network resources",
            ],
            content: {
              overview:
                "For organizations running on the Windows Server platform, Microsoft provides a deeply integrated PKI solution called Active Directory Certificate Services (AD CS). This lesson explores how enterprises use AD CS to issue and manage certificates for users, computers, and services to secure their internal networks.",
              sections: [
                {
                  title: "What is Active Directory Certificate Services?",
                  content:
                    "<p><strong>Active Directory Certificate Services (AD CS)</strong> is a Windows Server role that allows an organization to build its own internal Public Key Infrastructure. It provides all the core components needed to act as an enterprise Certificate Authority, including services for creating and managing public key certificates. Because it is tightly integrated with Active Directory (AD), it can leverage the existing database of users, groups, and computers for authentication and policy enforcement.</p>",
                  image: "https://i.imgur.com/k6lP09B.png",
                },
                {
                  title: "Common Use Cases for AD CS",
                  content:
                    "<p>An internal enterprise PKI is not used for public-facing websites, but it is critical for securing internal resources. Common use cases include:</p><ul><li><strong>Network Authentication (802.1X):</strong> Issuing certificates to computers and users to allow them to securely authenticate to the corporate Wi-Fi or wired network, replacing weak pre-shared keys.</li><li><strong>Smart Card Logon:</strong> Issuing certificates to users on smart cards or hardware tokens for strong, two-factor authentication to log in to their Windows desktops.</li><li><strong>Securing Internal Websites:</strong> Issuing SSL/TLS certificates for internal applications, like an intranet portal or SharePoint site, so that traffic is encrypted and employees aren't faced with browser trust errors.</li><li><strong>Encrypting File System (EFS):</strong> Issuing file recovery certificates that allow authorized administrators to decrypt files that were encrypted by an employee who has since left the company.</li><li><strong>VPN Authentication:</strong> Providing certificate-based authentication for employees connecting to the corporate network via a VPN.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1629834465737-f1c52b34a6c3?w=800&h=400&fit=crop",
                },
                {
                  title: "Auto-Enrollment and Group Policy",
                  content:
                    "<p>The 'killer feature' of AD CS is its integration with Group Policy for certificate <strong>auto-enrollment</strong>. An administrator can create a certificate template (e.g., 'Corporate Laptop Certificate') and configure a Group Policy Object (GPO) that tells all domain-joined laptops to automatically request a certificate using that template. When a laptop boots up and authenticates to the domain, it will automatically generate a key pair, contact the AD CS server, receive its signed certificate, and install it, all with zero user or administrator interaction. This makes it possible to deploy certificates to tens of thousands of machines automatically and transparently.</p>",
                  image:
                    "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit=crop",
                },
              ],
              codeExamples: [
                {
                  title:
                    "Lab: Configure AD Certificate Services (Conceptual Steps)",
                  language: "bash",
                  code: "# A full AD CS lab is very involved, but this outlines the key steps an administrator would take on a Windows Server.\n\n# Step 1: Install the AD CS Role.\n# - Open Server Manager.\n# - Click 'Add Roles and Features'.\n# - Select the 'Active Directory Certificate Services' role.\n# - In the Role Services, choose 'Certification Authority' and 'Certification Authority Web Enrollment'.\n\n# Step 2: Configure the CA.\n# - Post-installation, launch the AD CS Configuration wizard.\n# - Choose 'Enterprise CA' (this is what enables AD integration).\n# - Choose the CA type (e.g., 'Root CA' for the first CA in a forest, or 'Subordinate CA' if you have an offline root).\n# - Create a new private key and configure cryptographic options.\n\n# Step 3: Create a Certificate Template.\n# - Open the 'Certificate Templates Console' (certtmpl.msc).\n# - Duplicate an existing template, like 'Computer'.\n# - Give it a new name, e.g., 'Corporate Workstation'.\n# - Go to the 'Security' tab and grant 'Domain Computers' the 'Enroll' and 'Autoenroll' permissions.\n\n# Step 4: Publish the Template.\n# - Open the 'Certification Authority' console (certsrv.msc).\n# - Right-click 'Certificate Templates', select 'New', then 'Certificate Template to Issue'.\n# - Choose the 'Corporate Workstation' template you just created.\n\n# Step 5: Configure Group Policy.\n# - Open 'Group Policy Management' (gpmc.msc).\n# - Edit the 'Default Domain Policy' or another relevant GPO.\n# - Navigate to 'Computer Configuration > Policies > Windows Settings > Security Settings > Public Key Policies'.\n# - Open 'Certificate Services Client - Auto-Enrollment' and enable it.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the primary advantage of an 'Enterprise CA' in Active Directory Certificate Services?",
                  options: [
                    "It can issue certificates to public websites.",
                    "It is the only type of CA that can be installed on Windows.",
                    "It integrates with Active Directory to automate certificate issuance and management for domain users and computers.",
                    "It does not require a private key.",
                  ],
                  correct: 2,
                  explanation:
                    "The key feature of an Enterprise CA is its deep integration with Active Directory, which allows it to leverage user/computer accounts and Group Policy for powerful automation.",
                },
                {
                  id: 2,
                  question:
                    "Which AD CS feature allows thousands of corporate laptops to automatically receive a certificate without manual intervention?",
                  options: [
                    "The Certificate Repository.",
                    "Certificate auto-enrollment configured via Group Policy.",
                    "The Registration Authority web page.",
                    "Certificate renewal notices.",
                  ],
                  correct: 1,
                  explanation:
                    "Auto-enrollment is the mechanism that links AD CS certificate templates to Group Policy, enabling silent, automated certificate provisioning at scale.",
                },
                {
                  id: 3,
                  question:
                    "Which of the following is a common use case for an internal PKI with AD CS?",
                  options: [
                    "Issuing the main SSL certificate for amazon.com.",
                    "Issuing certificates for smart card authentication to log into Windows.",
                    "Managing PGP keys for Linux users.",
                    "Hosting a public OCSP responder.",
                  ],
                  correct: 1,
                  explanation:
                    "Using certificates stored on smart cards for user login is a classic use case for AD CS, dramatically improving authentication security over passwords alone.",
                },
              ],
            },
          },
          {
            id: "lesson-15",
            title: "Cloud PKI Services",
            duration: "75 min",
            objectives: [
              "Define PKI-as-a-Service (PKIaaS)",
              "Identify the managed PKI services from major cloud providers (AWS, Azure, GCP)",
              "Understand the benefits of using a managed cloud PKI service",
              "Describe the integration between cloud CAs and other cloud services (e.g., load balancers)",
            ],
            content: {
              overview:
                "Building and maintaining a highly available, secure PKI is complex and expensive. Cloud providers now offer managed PKI services that handle the difficult infrastructure, security, and maintenance, allowing developers and organizations to easily issue and manage certificates for their cloud resources. This lesson introduces the offerings from AWS, Azure, and Google Cloud.",
              sections: [
                {
                  title: "The Rise of PKI-as-a-Service (PKIaaS)",
                  content:
                    "<p>Traditionally, setting up a proper, secure PKI hierarchy meant procuring hardware (HSMs), setting up secure facilities for offline roots, and hiring specialized personnel to manage it. PKI-as-a-Service simplifies this dramatically. Cloud providers manage the entire underlying CA hierarchy, including the high-security requirements for the root and intermediate CAs, as a managed service. Customers can then use simple API calls or a web console to create their own private CAs and start issuing certificates without worrying about the complex infrastructure.</p><h3>Key Benefits of Cloud PKI:</h3><ul><li><strong>Reduced Complexity:</strong> No need to manage HSMs, servers, or CA software.</li><li><strong>Scalability:</strong> Managed services are designed to issue certificates at a massive scale, suitable for IoT and large applications.</li><li><strong>Pay-as-you-go:</strong> Avoids large upfront capital investment in hardware and expertise.</li><li><strong>Deep Integration:</strong> Seamlessly works with other cloud services, such as load balancers, API gateways, and IoT platforms.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1594708911226-9f874ce5a535?w=800&h=400&fit=crop",
                },
                {
                  title: "Leading Cloud PKI Offerings",
                  content:
                    "<h3>AWS - Certificate Manager (ACM) & Private CA</h3><ul><li><strong>AWS Certificate Manager (ACM):</strong> Primarily focused on issuing and managing public SSL/TLS certificates for use with AWS services like Elastic Load Balancing (ELB) and CloudFront. Public certificates from ACM are free. It also handles automatic renewal.</li><li><strong>ACM Private Certificate Authority:</strong> Allows you to create a complete private CA hierarchy within AWS. This is the service you would use to issue certificates for internal applications, devices, and users (e.g., for IoT device authentication).</li></ul><h3>Azure - Key Vault & Azure Certificate Authority</h3><ul><li><strong>Azure Key Vault:</strong> A comprehensive service for managing all kinds of secrets, including keys and certificates. Key Vault can be used to request, automatically renew, and store public SSL/TLS certificates from integrated public CAs like DigiCert. It can also store certificates from any CA.</li><li><strong>Azure Dedicated HSM:</strong> While not a full PKIaaS, it allows customers to have dedicated HSMs in the cloud to protect their keys, often used for BYOK (Bring Your Own Key) scenarios.</li></ul><h3>Google Cloud - Certificate Authority Service</h3><ul><li><strong>Google Cloud Certificate Authority Service:</strong> A highly scalable and available service that enables customers to build and manage their own private CAs in the cloud. It is designed for high-volume issuance and provides robust controls for managing the CA hierarchy and certificate templates. It can be used for securing microservices, IoT devices, and enterprise workloads.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1621640348395-502f04b2e811?w=800&h=400&fit=crop",
                },
              ],
              codeExamples: [
                {
                  title:
                    "Lab: Issue a Public Certificate from AWS Certificate Manager (ACM)",
                  language: "bash",
                  code: "# This lab outlines the process using the AWS Management Console.\n\n# Step 1: Navigate to the AWS Certificate Manager (ACM) service in the AWS Console.\n\n# Step 2: Click 'Request a certificate'.\n# - Choose 'Request a public certificate'.\n\n# Step 3: Add the domain names.\n# - Enter the fully qualified domain name (e.g., `www.my-aws-site.com`).\n# - You can add additional names (SANs) if needed (e.g., `my-aws-site.com`).\n\n# Step 4: Choose a validation method.\n# - 'DNS validation' is generally recommended as it can be automated.\n# - 'Email validation' is also an option.\n\n# Step 5: Complete the request.\n# - If you chose DNS validation, ACM will provide you with a CNAME record that you must add to your domain's DNS settings (e.g., in Amazon Route 53).\n# - ACM will periodically check for this DNS record. Once it finds it, the certificate status will change from 'Pending validation' to 'Issued'.\n\n# Step 6: Deploy the certificate.\n# - The issued certificate is now available within your AWS account.\n# - You can select it directly from a dropdown menu when configuring an HTTPS listener on an Application Load Balancer or setting up a CloudFront distribution.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is a primary benefit of using a managed Cloud PKI service like AWS ACM Private CA?",
                  options: [
                    "It is less secure than an on-premises PKI.",
                    "It requires you to purchase and manage your own HSMs.",
                    "It abstracts away the complexity of managing the underlying CA infrastructure, allowing you to focus on issuing certificates.",
                    "It can only issue certificates that are valid for 24 hours.",
                  ],
                  correct: 2,
                  explanation:
                    "Cloud PKI services handle the difficult, high-security tasks of maintaining a CA hierarchy, allowing customers to easily consume the service via APIs or a console.",
                },
                {
                  id: 2,
                  question:
                    "AWS Certificate Manager (ACM) provides free public SSL/TLS certificates for what purpose?",
                  options: [
                    "For use on any web server in any data center.",
                    "For issuing certificates to IoT devices.",
                    "For exclusive use with integrated AWS services like ELB and CloudFront.",
                    "For code signing applications.",
                  ],
                  correct: 2,
                  explanation:
                    "The free public certificates from ACM are a major benefit, but they are tied to the AWS ecosystem and can only be deployed on specific AWS resources.",
                },
                {
                  id: 3,
                  question:
                    "Which cloud service feature is critical for the integration and automation of certificate deployment?",
                  options: [
                    "The ability to select the certificate directly when configuring a load balancer or API gateway.",
                    "A command-line interface.",
                    "Email notifications for expiring certificates.",
                    "The use of multi-factor authentication for the console.",
                  ],
                  correct: 0,
                  explanation:
                    "Deep integration, where a certificate managed by a service like ACM can be directly attached to another service like a load balancer, is a key feature that simplifies deployment and management.",
                },
              ],
            },
          },
          {
            id: "lesson-16",
            title: "PKI in VPNs",
            duration: "60 min",
            objectives: [
              "Explain why certificate-based authentication is superior to pre-shared keys for VPNs",
              "Describe the role of a CA in a VPN deployment",
              "Outline how OpenVPN uses certificates for server and client authentication",
              "Understand how certificate revocation is used to manage VPN access",
            ],
            content: {
              overview:
                "Virtual Private Networks (VPNs) rely on strong authentication to ensure only authorized users and devices can access a private network. While simple VPNs might use a single password or pre-shared key (PSK), a scalable and secure VPN deployment is built on a PKI, using certificates to provide a unique identity for the server and every single client.",
              sections: [
                {
                  title: "Certificates vs. Pre-Shared Keys (PSKs)",
                  content:
                    "<p>Many simple VPNs use a <strong>Pre-Shared Key (PSK)</strong>a single secret password shared between the server and all clients. This is easy to set up, but has major security flaws:</p><ul><li><strong>It's a Single Point of Failure:</strong> If the PSK is compromised, every user is compromised.</li><li><strong>No Individual Identity:</strong> You cannot tell which specific user is connecting, as they all share the same key.</li><li><strong>Difficult Revocation:</strong> To revoke access for one person, you must change the PSK for everyone and redistribute the new key, which is a massive operational headache.</li></ul><p><strong>Certificate-based authentication</strong> solves all these problems. A PKI is used to issue a unique certificate to the VPN server and to each individual user or device. This provides:</p><ul><li><strong>Strong Identity:</strong> Each user has a unique, non-shared credential.</li><li><strong>Granular Control:</strong> You can grant or deny access on a per-user basis.</li><li><strong>Easy Revocation:</strong> To revoke access for a single user, you simply revoke their certificate. No other users are affected.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1542382257-80ded13c79c8?w=800&h=400&fit=crop",
                },
                {
                  title: "How OpenVPN Uses PKI",
                  content:
                    "<p>OpenVPN, a popular open-source VPN solution, has robust support for certificate-based authentication. A typical OpenVPN deployment with PKI involves:</p><ol><li><strong>Setting up a CA:</strong> You create your own private Certificate Authority specifically for the VPN.</li><li><strong>Issuing a Server Certificate:</strong> You use the CA to issue a certificate and private key for the OpenVPN server.</li><li><strong>Issuing Client Certificates:</strong> For each user who needs access, you use the CA to issue a unique client certificate and private key.</li><li><strong>Configuration:</strong> The server is configured with its certificate/key and the CA certificate. Each client is configured with its unique certificate/key and the CA certificate.</li></ol><p>When a client connects, a mutual TLS handshake occurs. The client verifies the server's certificate against its copy of the CA, and the server verifies the client's certificate against its copy of the CA. Both parties must present a valid, unrevoked certificate signed by that specific CA to connect. You also need to maintain a Certificate Revocation List (CRL) on the VPN server, which it checks on every connection attempt.</p>",
                  image:
                    "https://images.unsplash.com/photo-1584950333252-23c8a32a6881?w=800&h=400&fit=crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab: Configure OpenVPN Server to Use a CA (Snippet)",
                  language: "bash",
                  code: "# This lab shows the key lines in an OpenVPN `server.conf` file that enable PKI-based authentication.\n# It assumes you have already used a tool like `easy-rsa` to create a CA and issue server/client certificates.\n\n# --- Key directives in server.conf ---\n\n# The Root CA certificate for this VPN.\n# Both server and client must trust this.\nca ca.crt\n\n# The VPN server's public certificate.\ncert server.crt\n\n# The VPN server's private key. Must be secret!\nkey server.key\n\n# Parameters for the Diffie-Hellman key exchange.\ndh dh.pem\n\n# Certificate Revocation List (CRL).\n# The server will check this file on every client connection.\n# If a client's certificate is on this list, their connection will be rejected.\ncrl-verify crl.pem\n\n# --- Client Configuration (`client.ovpn`) ---\n\n# A client config file would have these corresponding lines:\n#\n# ca ca.crt\n# cert client1.crt\n# key client1.key\n\n# Notice how the client config specifies the individual certificate `client1.crt` and `client1.key`.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the main security advantage of using certificates for VPN authentication instead of a pre-shared key (PSK)?",
                  options: [
                    "Certificates are faster.",
                    "Certificates are easier to set up.",
                    "Certificates provide a unique identity for each user and allow for granular revocation of access.",
                    "PSKs use stronger encryption.",
                  ],
                  correct: 2,
                  explanation:
                    "Certificates allow you to manage access on a per-user basis. If an employee leaves, you can revoke their specific certificate without impacting any other VPN user.",
                },
                {
                  id: 2,
                  question:
                    "In a certificate-based OpenVPN setup, who needs to have a unique certificate and private key?",
                  options: [
                    "Only the server",
                    "Only the clients",
                    "Both the server and every individual client",
                    "The Certificate Authority",
                  ],
                  correct: 2,
                  explanation:
                    "This is a mutual authentication scenario. The server needs an identity, and each client needs its own unique identity to achieve granular control and strong security.",
                },
                {
                  id: 3,
                  question:
                    "How do you revoke a specific user's access to an OpenVPN server?",
                  options: [
                    "Delete the user's account in Active Directory.",
                    "Change the pre-shared key for everyone.",
                    "Add the user's certificate serial number to the Certificate Revocation List (CRL) and load it on the server.",
                    "Block the user's IP address in the firewall.",
                  ],
                  correct: 2,
                  explanation:
                    "The correct PKI method is to use the CA to revoke the user's certificate and then update the CRL on the OpenVPN server. The server will then deny any connection attempts from that user.",
                },
              ],
            },
          },
          {
            id: "lesson-17",
            title: "PKI in Authentication (Smart Cards, MFA)",
            duration: "60 min",
            objectives: [
              "Explain certificate-based user authentication",
              "Describe how a smart card or hardware token securely stores a user's private key",
              "Understand how this provides Multi-Factor Authentication (MFA)",
              "Identify use cases like PIV cards and certificate-based SSH",
            ],
            content: {
              overview:
                "PKI is not just for servers and devices; it's a powerful tool for authenticating human users. By storing a user's certificate and private key on a physical hardware device like a smart card or USB token, organizations can implement highly secure, phishing-resistant Multi-Factor Authentication (MFA).",
              sections: [
                {
                  title: "Certificate-Based User Authentication",
                  content:
                    "<p>Instead of typing a password, a user can authenticate to a service by proving they possess a private key. This is a form of public key authentication. The process generally works as follows:</p><ol><li>The server sends a challenge (a random string of data) to the client.</li><li>The client uses the user's private key to sign the challenge.</li><li>The client sends the signed challenge back to the server.</li><li>The server uses the user's public key (retrieved from their certificate) to verify the signature.</li></ol><p>If the signature is valid, it proves the user is in possession of the correct private key, and authentication succeeds. The private key itself never leaves the user's possession.</p>",
                  image:
                    "https://images.unsplash.com/photo-1542382257-80ded13c79c8?w=800&h=400&fit=crop",
                },
                {
                  title: "Hardware Tokens: The 'Something You Have' Factor",
                  content:
                    "<p>While you can store a user's certificate and private key in software (e.g., in the OS certificate store), the security is vastly improved by storing it on a dedicated piece of hardware. This turns authentication into true MFA.</p><ul><li><strong>Smart Card:</strong> A credit-card-sized plastic card with an embedded cryptographic chip. The private key is generated and stored on the chip and can never be exported. To use the key, the card must be placed in a reader, and the user must enter a PIN.</li><li><strong>USB Hardware Token:</strong> Devices like a YubiKey can function as a smart card. The user plugs the token into their computer and typically has to touch it and/or enter a PIN to approve a signing operation.</li></ul><p>This method provides MFA by combining:</p><ul><li><strong>Something you have:</strong> The physical smart card or USB token.</li><li><strong>Something you know:</strong> The PIN for the card/token.</li><li>(And is based on) <strong>Something you are:</strong> Can be combined with a fingerprint reader for a third factor.</li></ul><p>This is extremely resistant to phishing, as an attacker cannot steal the private key, even if they have compromised the user's computer with malware.</p>",
                  image: "https://i.imgur.com/eE90mUe.jpg",
                },
                {
                  title: "Common Use Cases",
                  content:
                    "<ul><li><strong>PIV/CAC Cards:</strong> The US federal government issues PIV (Personal Identity Verification) cards and the military issues CAC (Common Access Cards) to all employees and contractors. These are smart cards used for logging into computers, accessing secure websites, and digitally signing documents.</li><li><strong>SSH Authentication:</strong> Instead of password-based or simple key-based login, SSH servers can be configured to require authentication using a certificate stored on a smart card, providing MFA for server administrators.</li><li><strong>Client Certificate Authentication for Web Apps:</strong> High-security web applications can require users to present a client certificate (stored on a hardware token) in addition to or instead of a password.</li></ul>",
                  image: "https://i.imgur.com/Qk7GjBw.jpg",
                },
              ],
              codeExamples: [
                {
                  title: "Lab: Use a Certificate for SSH Login (Conceptual)",
                  language: "bash",
                  code: "# This lab outlines how to configure an SSH server and client to use certificate-based authentication.\n\n# --- CA Side ---\n# Step 1: Issue a certificate for a user, using your PKI.\n# The key part is using an extension to specify the certificate is for SSH login.\n# For example, with OpenSSH's own CA tools, you sign the user's public key, not a full X.509 cert.\n# `ssh-keygen -s ca_key -I user_cert -n username id_rsa.pub`\n\n# --- Server Side (`sshd_config`) ---\n# Step 2: Configure the SSH server to trust your CA and check certificates.\n# Edit /etc/ssh/sshd_config:\n# \n# # Point to the PUBLIC key of the CA that signs user certs.\n# TrustedUserCAKeys /etc/ssh/ca.pub\n# \n# # Optional: Turn off other authentication methods.\n# PasswordAuthentication no\n# PubkeyAuthentication yes\n\n# Step 3: Restart the SSH service.\n# `sudo systemctl restart sshd`\n\n# --- Client Side ---\n# Step 4: Configure the user's SSH client.\n# The user needs their private key (`id_rsa`) and their signed public key certificate (`id_rsa-cert.pub`).\n# The SSH client will automatically present the certificate if it's named correctly.\n\n# Step 5: Connect.\n# `ssh username@server.example.com`\n# The server will now authenticate the user based on the certificate signed by its trusted CA, not based on an entry in `~/.ssh/authorized_keys`.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "How does using a certificate on a smart card for login provide Multi-Factor Authentication (MFA)?",
                  options: [
                    "It requires only a password.",
                    "It combines 'something you have' (the card) with 'something you know' (the PIN).",
                    "It is the same as using a password.",
                    "It sends a code to your phone.",
                  ],
                  correct: 1,
                  explanation:
                    "True MFA requires factors from different categories. The physical card is the possession factor, and the secret PIN is the knowledge factor.",
                },
                {
                  id: 2,
                  question:
                    "What is the primary security benefit of storing a private key on a hardware token instead of in a software file?",
                  options: [
                    "It is faster.",
                    "The key can never be exported or stolen by malware on the host computer.",
                    "It doesn't require a Certificate Authority.",
                    "Hardware tokens do not need passwords.",
                  ],
                  correct: 1,
                  explanation:
                    "The key is generated on and confined to the hardware. All signing operations happen on the device itself, so the key is never exposed in the computer's memory.",
                },
                {
                  id: 3,
                  question:
                    "What does PIV stand for in the context of US government smart cards?",
                  options: [
                    "Private Internet Vetting",
                    "Personal Identity Verification",
                    "Public Key Infrastructure Version",
                    "Personal Information Vault",
                  ],
                  correct: 1,
                  explanation:
                    "PIV (Personal Identity Verification) is the federal standard for the identity credentials used by government employees and contractors.",
                },
              ],
            },
          },
          {
            id: "lesson-18",
            title: "PKI Security Risks",
            duration: "75 min",
            objectives: [
              "Identify the most significant threats to a PKI",
              "Understand the catastrophic impact of a Root CA private key compromise",
              "Analyze the DigiNotar CA breach as a case study",
              "Explain how Certificate Transparency (CT) helps mitigate the threat of rogue certificates",
            ],
            content: {
              overview:
                "A PKI is built on a foundation of trust. But what happens when that foundation is compromised? This lesson explores the most severe security risks in a PKI, focusing on the disastrous consequences of a CA compromise and discussing real-world breaches. We will also cover modern countermeasures designed to detect these attacks.",
              sections: [
                {
                  title: "The Ultimate Threat: CA Compromise",
                  content:
                    "<p>The single greatest threat to a PKI is the compromise of a Certificate Authority's private key, especially a Root CA key. If an attacker steals a CA's signing key, they can:</p><ul><li><strong>Issue Rogue Certificates:</strong> They can create fraudulent but technically valid certificates for any domain they want (e.g., `google.com`, `microsoft.com`, your bank).</li><li><strong>Execute Undetectable MITM Attacks:</strong> Using these rogue certificates, they can impersonate legitimate websites and intercept traffic from millions of users, who would see a valid padlock icon in their browser.</li><li><strong>Sign Malicious Code:</strong> They could sign malware with a legitimate code signing certificate, making it appear to be trusted software from a valid publisher.</li></ul><p>A CA compromise fundamentally breaks the trust model, as the CA's signature can no longer be trusted. The only solution is to have all browsers and operating systems distrust and remove the compromised CA from their root stores, which is a massive and difficult undertaking.</p>",
                  image:
                    "https://images.unsplash.com/photo-1563206410-182f5b5f8845?w=800&h=400&fit=crop",
                },
                {
                  title: "Case Study: The DigiNotar Breach (2011)",
                  content:
                    "<p>DigiNotar was a Dutch Certificate Authority that suffered a catastrophic security breach in 2011. An attacker, believed to be state-sponsored, compromised DigiNotar's systems and used their signing infrastructure to issue hundreds of rogue certificates. The most infamous was a wildcard certificate for `*.google.com`, which was used to perform Man-in-the-Middle attacks against Gmail users in Iran.</p><p>The breach went undetected for over a month. Once discovered, browser vendors (Google, Mozilla, Microsoft) had to rush to release emergency security updates to revoke trust in all of DigiNotar's certificates. The incident led to the bankruptcy of DigiNotar and served as a major wake-up call for the entire industry about the systemic risk of CA compromise.</p>",
                  image:
                    "https://images.unsplash.com/photo-1548092372-2d987bde898b?w=800&h=400&fit=crop",
                },
                {
                  title: "Mitigation: Certificate Transparency (CT)",
                  content:
                    "<p>How can we detect if a CA has been compromised or is mis-issuing certificates? <strong>Certificate Transparency (CT)</strong> is the answer. CT is an open framework that requires CAs to publish every SSL/TLS certificate they issue to a set of public, independently-operated, and append-only logs.</p><p>This creates a public audit trail. Anyone (especially domain owners and browser vendors) can monitor these logs to see every certificate issued for their domains. If a domain owner sees a certificate they did not request, they can immediately identify it as fraudulent. This makes it very difficult for a compromised CA to secretly issue a rogue certificate without being quickly discovered. Modern browsers like Chrome now require that all public SSL/TLS certificates appear in public CT logs in order to be trusted.</p>",
                  image:
                    "https://images.unsplash.com/photo-1510511459019-5dda7724fd87?w=800&h=400&fit=crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab: Explore Certificate Transparency Logs",
                  language: "bash",
                  code: "# Several websites provide an easy way to search public Certificate Transparency logs.\n# One of the most popular is crt.sh.\n\n# Step 1: Open a web browser and navigate to https://crt.sh/\n\n# Step 2: Enter a domain name you are interested in, for example, 'google.com', and click 'Search'.\n\n# Step 3: Analyze the results.\n# The website will show you a list of *every* publicly trusted SSL/TLS certificate that has been issued for that domain and logged to a CT log.\n# You can see:\n# - The certificate serial number.\n# - The domains covered by the certificate.\n# - The issuer (the CA that signed it).\n# - The dates it was logged.\n\n# This is exactly the kind of monitoring a domain owner would do. If a certificate appeared on this list from an unknown CA or that they did not request, it would be a major red flag indicating a possible mis-issuance or attack.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the most severe security risk to a public PKI?",
                  options: [
                    "A user forgetting their smart card PIN.",
                    "A web server's certificate expiring.",
                    "The compromise of a trusted Root CA's private key.",
                    "A slow OCSP responder.",
                  ],
                  correct: 2,
                  explanation:
                    "A compromised Root CA breaks the entire foundation of trust, allowing an attacker to impersonate any entity and undermine the security of every client that trusts that CA.",
                },
                {
                  id: 2,
                  question:
                    "In the DigiNotar breach, what did the attackers do after compromising the CA?",
                  options: [
                    "They shut down the company's website.",
                    "They issued fraudulent, but validly signed, certificates for domains like google.com.",
                    "They published the CA's private key online.",
                    "They encrypted all of the CA's servers with ransomware.",
                  ],
                  correct: 1,
                  explanation:
                    "The attackers abused their access to issue rogue certificates, which were then used to conduct Man-in-the-Middle attacks.",
                },
                {
                  id: 3,
                  question:
                    "What is the primary goal of Certificate Transparency (CT)?",
                  options: [
                    "To encrypt all certificate data.",
                    "To make PKI obsolete.",
                    "To provide a public, auditable log of all issued SSL/TLS certificates to detect mis-issuance or rogue certificates quickly.",
                    "To speed up the certificate validation process.",
                  ],
                  correct: 2,
                  explanation:
                    "CT acts as a public auditing system. By forcing all issued certificates to be logged publicly, it makes it nearly impossible for a CA to issue a rogue certificate in secret.",
                },
              ],
            },
          },
          {
            id: "lesson-19",
            title: "Future of PKI (Quantum-Safe PKI)",
            duration: "60 min",
            objectives: [
              "Understand the threat that large-scale quantum computers pose to current PKI",
              "Define Post-Quantum Cryptography (PQC)",
              "Identify the categories of algorithms being standardized for PQC",
              "Explain the concept of a hybrid cryptographic approach",
            ],
            content: {
              overview:
                "The cryptographic algorithms that underpin our entire PKI today (RSA and ECC) are secure against even the most powerful classical supercomputers. However, they can be broken by a sufficiently powerful quantum computer. This lesson looks to the future, explaining the threat of quantum computing and introducing the ongoing effort to develop and standardize Post-Quantum Cryptography to ensure PKI remains secure.",
              sections: [
                {
                  title: "The Quantum Threat",
                  content:
                    "<p>Public key cryptography, as we know it, relies on mathematical problems that are 'easy' to compute in one direction but 'hard' to reverse. For RSA, this is the difficulty of factoring the product of two large prime numbers. For ECC, it's the elliptic-curve discrete logarithm problem.</p><p>A theoretical large-scale quantum computer, using an algorithm called <strong>Shor's algorithm</strong>, can solve both of these 'hard' problems relatively easily. This means that such a computer would be able to take a public key (from a certificate) and calculate the corresponding private key. This would completely break the security of our current PKI, allowing an attacker to forge any signature and decrypt any communication.</p><p>While large, cryptographically-relevant quantum computers do not yet exist, the threat is serious enough that preparations must be made now. This is especially true for data that needs to remain secret for many years; an attacker could 'harvest' encrypted data today and decrypt it later once they have a quantum computer.</p>",
                  image:
                    "https://images.unsplash.com/photo-1619961602105-16fa2a5465c2?w=800&h=400&fit=crop",
                },
                {
                  title: "Post-Quantum Cryptography (PQC)",
                  content:
                    "<p><strong>Post-Quantum Cryptography (PQC)</strong>, also called quantum-resistant cryptography, refers to cryptographic algorithms that are thought to be secure against attack by both classical and quantum computers. These algorithms are based on different mathematical problems that are not susceptible to Shor's algorithm.</p><p>The U.S. National Institute of Standards and Technology (NIST) has been running a multi-year competition to solicit, evaluate, and standardize PQC algorithms. In 2022, NIST announced its first set of standardized algorithms:</p><ul><li><strong>For Public-Key Encryption and Key Exchange:</strong> CRYSTALS-KYBER.</li><li><strong>For Digital Signatures:</strong> CRYSTALS-Dilithium, FALCON, and SPHINCS+.</li></ul><p>These new algorithms will eventually replace RSA and ECC in protocols like TLS, S/MIME, and in the certificates that make up our PKI.</p>",
                  image:
                    "https://images.unsplash.com/photo-1516110833953-7a916730302b?w=800&h=400&fit=crop",
                },
                {
                  title: "The Transition: Hybrid Cryptography",
                  content:
                    "<p>The transition to a fully post-quantum PKI will take many years. The new algorithms are complex and less studied than RSA/ECC, so there is a risk they could have unforeseen weaknesses. To manage this risk, the initial transition phase will likely use a <strong>hybrid approach</strong>.</p><p>In a hybrid scheme, a system will use two different algorithms at the same time: one traditional algorithm (like ECC) and one post-quantum algorithm (like KYBER). To break the security, an attacker would need to break <em>both</em> algorithms. This provides security against current threats while also protecting against the future quantum threat. We can expect to see hybrid key exchange in TLS and hybrid signatures in certificates as the first steps in this global migration.</p>",
                  image:
                    "https://images.unsplash.com/photo-1599507578794-279213135e13?w=800&h=400&fit=crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab: Test Dilithium PQC Certificates (Conceptual)",
                  language: "bash",
                  code: '# As PQC standards are still being finalized and deployed, real-world tools are emerging.\n# The Open Quantum Safe (OQS) project provides a fork of OpenSSL that includes PQC algorithms.\n# This lab is conceptual, showing how one might use such a tool.\n\n# Website: https://openquantumsafe.org/\n\n# Step 1: Compile the OQS version of OpenSSL.\n# This involves cloning their repository and following the build instructions.\n\n# Step 2: Use the new OQS-enabled OpenSSL to generate a PQC key and certificate.\n# Instead of `rsa:2048`, you would specify a PQC signature algorithm.\n\n# Generate a Dilithium private key:\n# `openssl genpkey -algorithm dilithium2 -out pqc_ca.key`\n\n# Step 3: Create a self-signed PQC Root CA certificate.\n# `openssl req -x509 -new -key pqc_ca.key -out pqc_ca.crt -subj "/CN=PQC Root CA"`\n\n# Step 4: Run a test server and client that use PQC certificates and a hybrid key exchange.\n# The OQS-enabled tools allow you to specify hybrid key exchange mechanisms, for example `p256_kyber768`.\n\n# Server:\n# `openssl s_server -accept 4433 -cert pqc_ca.crt -key pqc_ca.key -curves p256_kyber768`\n\n# Client:\n# `openssl s_client -connect localhost:4433 -curves p256_kyber768`\n\n# This lab demonstrates that the tools and concepts for a PQC-based PKI are actively being developed.',
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "Why do large-scale quantum computers pose a threat to our current PKI?",
                  options: [
                    "They can guess private keys very quickly.",
                    "They can use Shor's algorithm to solve the mathematical problems that RSA and ECC are based on.",
                    "They are immune to firewalls.",
                    "They can overload Certificate Authorities with requests.",
                  ],
                  correct: 1,
                  explanation:
                    "Shor's algorithm, when run on a quantum computer, can efficiently break the asymmetric cryptography that is the foundation of modern PKI.",
                },
                {
                  id: 2,
                  question:
                    "What is the goal of Post-Quantum Cryptography (PQC)?",
                  options: [
                    "To develop new algorithms that are resistant to attacks from both classical and quantum computers.",
                    "To make encryption obsolete.",
                    "To build a working quantum computer.",
                    "To replace TLS with a new protocol.",
                  ],
                  correct: 0,
                  explanation:
                    "PQC aims to provide a new generation of public-key algorithms that will keep our data secure in an era where quantum computers exist.",
                },
                {
                  id: 3,
                  question: "What is a 'hybrid' cryptographic approach?",
                  options: [
                    "Using both symmetric and asymmetric cryptography.",
                    "Using one algorithm for encryption and another for signatures.",
                    "Combining a traditional algorithm (like ECC) and a PQC algorithm (like KYBER) so that an attacker must break both.",
                    "A mix of hardware and software encryption.",
                  ],
                  correct: 2,
                  explanation:
                    "The hybrid approach is a transitional strategy that provides redundancy. It protects against both current threats (by using the proven ECC) and future threats (by using the new PQC algorithm).",
                },
              ],
            },
          },
          {
            id: "lesson-20",
            title: "PKI Deployment Best Practices",
            duration: "75 min",
            objectives: [
              "Understand the industry trend towards short-lived certificates",
              "Explain the importance of automating all aspects of the certificate lifecycle",
              "Define the ACME protocol and its role in automation",
              "Summarize the key principles for managing a secure and modern PKI",
            ],
            content: {
              overview:
                "Managing a PKI effectively requires more than just understanding the technology; it requires implementing robust processes and modern best practices. This capstone lesson covers the essential strategies for deploying and maintaining a secure, reliable, and efficient PKI, with a strong focus on automation and the move towards dynamic, short-lived credentials.",
              sections: [
                {
                  title: "Automation is Everything",
                  content:
                    "<p>Manual certificate management is a recipe for disaster. It is tedious, error-prone, and does not scale. Forgetting to renew a single critical certificate can cause a major service outage. The number one rule of modern PKI is to <strong>automate everything</strong>. This includes the processes for issuance, renewal, deployment to servers, and revocation.</p><p>Automation eliminates human error, ensures certificates are always up-to-date, and enables modern security practices. It also frees up administrators to focus on higher-level security tasks instead of manual certificate wrangling.</p>",
                  image:
                    "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop",
                },
                {
                  title: "The ACME Protocol and Short-Lived Certificates",
                  content:
                    "<p>The drive for automation led to the creation of the <strong>ACME protocol (Automated Certificate Management Environment)</strong>. This is the protocol that powers free and automated Certificate Authorities like Let's Encrypt. ACME is an open standard that allows a client (like `certbot` on a web server) to automatically prove domain ownership to a CA, and then request, renew, and install certificates without any human intervention.</p><p>This powerful automation has enabled a major shift in best practices: the move to <strong>short-lived certificates</strong>. Instead of certificates with a validity of one year, the new standard is 90 days or even less. Why?<ul><li><strong>Reduces Risk Window:</strong> If a private key is compromised and the revocation somehow fails, the certificate is still only valid for a short time, limiting the damage.</li><li><strong>Enforces Automation:</strong> With a 90-day lifespan, manual renewal is not feasible. This forces organizations to build robust automation, which improves overall reliability and security.</li><li><strong>Agility:</strong> It's easier to make changes, like migrating to a new algorithm or adding a domain, when certificates are being renewed frequently.</li></ul>",
                  image: "https://i.imgur.com/uR1d3X5.png",
                },
                {
                  title: "Summary of Best Practices",
                  content:
                    "<ul><li><strong>Automate All Lifecycle Events:</strong> Use protocols like ACME for issuance and renewal. Integrate with your infrastructure-as-code and configuration management tools.</li><li><strong>Embrace Short-Lived Certificates:</strong> Aim for a 90-day (or shorter) validity period for all SSL/TLS certificates.</li><li><strong>Secure and Manage Keys:</strong> Protect all private keys with strict permissions. Use HSMs for all CA keys and other high-value keys. Implement a clear policy for key rotation.</li><li><strong>Maintain a Secure CA Hierarchy:</strong> Keep Root CA keys offline and secure. Use Intermediate CAs for all online signing operations.</li><li><strong>Implement Robust Revocation:</strong> Ensure your revocation services (CRL/OCSP) are highly available. Enable OCSP Stapling on all public-facing web servers.</li><li><strong>Monitor and Audit:</strong> Regularly monitor Certificate Transparency logs for your domains. Periodically audit your CA's policies, procedures, and issued certificates.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1542382257-80ded13c79c8?w=800&h=400&fit=crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab: Deploy a Let's Encrypt Certificate with Certbot",
                  language: "bash",
                  code: "# This lab demonstrates the power of the ACME protocol using the Certbot client on a Linux web server with Nginx.\n\n# Prerequisites:\n# - A Linux server with Nginx installed.\n# - A registered domain name pointing to your server's public IP address.\n\n# Step 1: Install Certbot.\n# (On Debian/Ubuntu)\n`sudo apt-get update`\n`sudo apt-get install certbot python3-certbot-nginx`\n\n# Step 2: Run Certbot.\n# The `--nginx` plugin tells Certbot to automatically find your domains from your Nginx configuration and reconfigure Nginx for you.\n`sudo certbot --nginx`\n\n# Step 3: Follow the prompts.\n# Certbot will ask you which domain(s) you want to activate HTTPS for.\n# It will then automatically:\n#   1. Communicate with the Let's Encrypt ACME server.\n#   2. Prove you control the domain (using the HTTP-01 challenge).\n#   3. Download the signed certificate and key.\n#   4. Modify your Nginx configuration to use the new certificate and set up a redirect.\n#   5. Reload Nginx.\n\n# Step 4: Verify automatic renewal.\n# The Certbot package automatically sets up a cron job or systemd timer to run `certbot renew` twice a day. This command will check all your certificates and automatically renew any that are approaching expiration.\n`sudo systemctl status certbot.timer`\n\n# You can perform a dry run to test the renewal process:\n`sudo certbot renew --dry-run`\n\n# This simple process demonstrates a fully automated, best-practice PKI deployment for a web server.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the primary benefit of using short-lived certificates (e.g., 90 days)?",
                  options: [
                    "They use stronger encryption.",
                    "They reduce the risk window of a key compromise and force administrators to implement robust automation.",
                    "They are free, while long-lived certificates are expensive.",
                    "They do not need to be revoked.",
                  ],
                  correct: 1,
                  explanation:
                    "Short validity periods limit the potential damage of a compromised key and make a strong, automated renewal process a necessity, improving overall PKI health.",
                },
                {
                  id: 2,
                  question: "What is ACME?",
                  options: [
                    "A type of Certificate Authority.",
                    "A brand of Hardware Security Module.",
                    "A protocol that allows for the automated issuance and renewal of certificates.",
                    "A new type of post-quantum algorithm.",
                  ],
                  correct: 2,
                  explanation:
                    "ACME (Automated Certificate Management Environment) is the open protocol that clients like Certbot use to interact with CAs like Let's Encrypt.",
                },
                {
                  id: 3,
                  question:
                    "What is considered the number one rule of managing a modern PKI deployment?",
                  options: [
                    "Use the longest possible certificate lifetimes to avoid renewals.",
                    "Manage all certificates manually to ensure oversight.",
                    "Automate all aspects of the certificate lifecycle.",
                    "Store all private keys on a shared network drive for easy access.",
                  ],
                  correct: 2,
                  explanation:
                    "Automation is critical to reducing human error, preventing outages from expired certificates, and enabling agile and secure practices.",
                },
              ],
            },
          },
        ],
      }; // =====================================================
      // GLOBAL VARIABLES
      // =====================================================
      let currentUser = null;
      let currentLessonIndex = 0;
      let courseProgress = {};
      let userStats = {};
      let quizState = {
        currentQuestion: 0,
        answers: [],
        score: 0,
        isComplete: false,
      };

      // Enhanced session tracking
      let courseSession = {
        startTime: null,
        totalStudyTime: 0,
        lessonsStarted: 0,
        lessonsCompleted: 0,
        pageLoadTime: new Date(),
        interactionCount: 0,
        lastActivityTime: new Date(),
      };

      // Music Player Variables
      let audioPlayer = new Audio();

      // Achievement notification system
      let notificationQueue = [];
      let isShowingNotification = false;

      // =====================================================
      // INITIALIZATION
      // =====================================================
      document.addEventListener("DOMContentLoaded", async () => {
        try {
          showLoadingScreen();
          await checkAuth();

          if (currentUser) {
            // Initialize session tracking
            startCourseSession();

            // Load course data and progress
            await loadCourseData();
            await loadUserProfile();
            await loadProgress();

            // Initialize UI
            initializeEventListeners();
            renderSidebar();
            loadLesson(currentLessonIndex);

            // Initialize additional features
            initMusicPlayer();
            addMusicIndicator();
            initializeActivityTracking();

            hideLoadingScreen();
          } else {
            openAuthModal();
          }
        } catch (error) {
          console.error("Error initializing course:", error);
          hideLoadingScreen();
          showToast("Failed to initialize course system", "error");
        }
      });

      // =====================================================
      // AUTHENTICATION SYSTEM
      // =====================================================
      async function checkAuth() {
        try {
          const {
            data: { session },
            error,
          } = await supabase.auth.getSession();

          if (error) {
            console.error("Auth error:", error);
            currentUser = null;
            openAuthModal();
            return;
          }

          if (!session) {
            currentUser = null;
            openAuthModal();
            return;
          }

          currentUser = session.user;
          updateUIWithUser();
        } catch (error) {
          console.error("Error checking auth:", error);
          currentUser = null;
          openAuthModal();
        }
      }

      function updateUIWithUser() {
        if (!currentUser) return;

        const name =
          currentUser.user_metadata?.full_name ||
          currentUser.email.split("@")[0];
        const userElements = document.querySelectorAll("[data-user-name]");
        userElements.forEach((el) => (el.textContent = name));
      }

      // =====================================================
      // USER PROFILE & STATS MANAGEMENT
      // =====================================================
      async function loadUserProfile() {
        try {
          //  Step 1: Try to fetch existing profile
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("*")
            .eq("id", currentUser.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (!profile) {
            //  Step 2: Create new profile if missing
            await createUserProfile();
          } else {
            //  Step 3: Use existing profile
            userStats = profile;
            await updateLastActivity();
          }
        } catch (error) {
          console.error(" Error loading user profile:", error);
          showToast("Failed to load user profile", "error");
        }
      }
      async function createUserProfile() {
        try {
          const newProfile = {
            id: currentUser.id,
            full_name: currentUser.user_metadata?.full_name || "",
            email: currentUser.email,
            level: "Script Kiddie",
            total_points: 0,
            completed_courses: 0,
            current_streak: 0,
            total_certificates: 0,
            total_achievements: 0,
            sections_visited: 0,
            bonus_points: 0,
            in_progress_courses: 0,
            settings_changed: 0,
            midnight_sessions: 0,
            early_sessions: 0,
            weekend_sessions: 0,
            last_activity: new Date().toISOString(),
            created_at: new Date().toISOString(),
          };

          const { error } = await supabase
            .from("profiles")
            .insert([newProfile]);

          if (!error) {
            userStats = newProfile;
            // Award first login achievement
            setTimeout(() => checkAndUnlockAchievement("first_login"), 1000);
          }
        } catch (error) {
          console.error("Error creating user profile:", error);
        }
      }

      async function updateLastActivity() {
        try {
          const now = new Date();

          // Update activity tracking
          courseSession.lastActivityTime = now;

          // Update database
          await supabase
            .from("profiles")
            .update({
              last_activity: now.toISOString(),
            })
            .eq("id", currentUser.id);

          // Check time-based achievements
          await checkTimeBasedAchievements(now);
        } catch (error) {
          console.error("Error updating last activity:", error);
        }
      }

      // =====================================================
      // COURSE SESSION MANAGEMENT
      // =====================================================
      function startCourseSession() {
        courseSession.startTime = new Date();
        courseSession.pageLoadTime = new Date();

        logUserActivity("course_session_start", {
          course_id: COURSE_DATA.id,
          course_title: COURSE_DATA.title,
          user_agent: navigator.userAgent,
          screen_resolution: `${screen.width}x${screen.height}`,
        });

        // Check daily streak
        checkDailyStreak();
      }

      function initializeActivityTracking() {
        // Track page focus/blur for accurate study time
        document.addEventListener("visibilitychange", handleVisibilityChange);

        // Track user interactions
        ["click", "keydown", "scroll", "mousemove"].forEach((event) => {
          document.addEventListener(event, trackUserInteraction, {
            passive: true,
          });
        });

        // Periodic activity updates
        setInterval(updateStudyTime, 60000); // Every minute

        // Save session data before page unload
        window.addEventListener("beforeunload", saveSessionData);
      }

      function handleVisibilityChange() {
        if (document.hidden) {
          courseSession.lastActivityTime = new Date();
        } else {
          // Page became visible again - update activity
          updateLastActivity();
        }
      }

      function trackUserInteraction() {
        courseSession.interactionCount++;
        courseSession.lastActivityTime = new Date();

        // Throttle activity updates
        if (courseSession.interactionCount % 50 === 0) {
          updateLastActivity();
        }
      }

      function updateStudyTime() {
        if (!courseSession.startTime || document.hidden) return;

        const now = new Date();
        const sessionDuration = now - courseSession.startTime;
        courseSession.totalStudyTime = Math.floor(sessionDuration / 1000 / 60); // in minutes

        // Update progress with study time
        saveProgress();
      }

      function saveSessionData() {
        if (!currentUser || !courseSession.startTime) return;

        const sessionData = {
          user_id: currentUser.id,
          course_id: COURSE_DATA.id,
          session_duration: courseSession.totalStudyTime,
          lessons_viewed: courseSession.lessonsStarted,
          lessons_completed: courseSession.lessonsCompleted,
          interactions: courseSession.interactionCount,
          session_date: courseSession.startTime.toISOString().split("T")[0],
        };

        // Store in localStorage as backup
        localStorage.setItem(
          "course_session_backup",
          JSON.stringify(sessionData)
        );

        // Try to save to database
        logUserActivity("course_session_end", sessionData);
      }

      // =====================================================
      // COURSE DATA & PROGRESS MANAGEMENT
      // =====================================================
      async function loadCourseData() {
        try {
          // Update course info in UI
          document.getElementById("courseTitle").textContent =
            COURSE_DATA.title;
          document.getElementById("totalLessons").textContent =
            COURSE_DATA.lessons.length;

          // Log course access
          logUserActivity("course_access", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
          });
        } catch (error) {
          console.error("Error loading course data:", error);
        }
      }

      async function loadProgress() {
        try {
          // Get existing progress from database
          const { data, error } = await supabase
            .from("course_progress")
            .select("*")
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (data) {
            courseProgress = JSON.parse(data.lesson_progress || "{}");
            currentLessonIndex = data.current_lesson || 0;

            // Update session tracking
            courseSession.lessonsStarted = Object.keys(courseProgress).length;
            courseSession.lessonsCompleted = Object.values(
              courseProgress
            ).filter((p) => p.completed).length;
          } else {
            // Initialize new progress
            courseProgress = {};
            currentLessonIndex = 0;
            await saveProgress();

            // Award first course start achievement
            await checkAndUnlockAchievement("first_course_start");
          }

          updateProgressDisplay();
        } catch (error) {
          console.error("Error loading progress:", error);
          showToast("Failed to load progress", "error");
        }
      }

      async function saveProgress() {
        try {
          if (!currentUser) return;

          const now = new Date();
          const progressData = {
            user_id: currentUser.id,
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            current_lesson: currentLessonIndex,
            lesson_progress: JSON.stringify(courseProgress),
            progress: calculateOverallProgress(),
            lessons_completed: getCompletedLessonsCount(),
            lessons_started: Object.keys(courseProgress).length,
            study_time_minutes: courseSession.totalStudyTime,
            last_accessed: now.toISOString(),
            updated_at: now.toISOString(),
          };

          // Upsert progress
          const { error } = await supabase
            .from("course_progress")
            .upsert([progressData]);

          if (error) throw error;

          // Update user stats
          await updateUserStats();

          updateProgressDisplay();
        } catch (error) {
          console.error("Error saving progress:", error);
          showToast("Failed to save progress", "error");
        }
      }

      async function updateUserStats() {
        try {
          // Get all course progress for this user
          const { data: allProgress, error } = await supabase
            .from("course_progress")
            .select("progress, course_id, study_time_minutes")
            .eq("user_id", currentUser.id);

          if (error) throw error;

          // Calculate stats
          const completedCourses =
            allProgress?.filter((p) => p.progress >= 100).length || 0;
          const inProgressCourses =
            allProgress?.filter((p) => p.progress > 0 && p.progress < 100)
              .length || 0;
          const totalStudyTime =
            allProgress?.reduce(
              (sum, p) => sum + (p.study_time_minutes || 0),
              0
            ) || 0;

          // Calculate points (500 per completed course + achievement points)
          const coursePoints = completedCourses * 500;
          const bonusPoints = userStats.bonus_points || 0;
          const totalPoints = coursePoints + bonusPoints;

          // Update profile
          const updateData = {
            completed_courses: completedCourses,
            in_progress_courses: inProgressCourses,
            total_points: totalPoints,
            total_study_time: totalStudyTime,
            last_activity: new Date().toISOString(),
          };

          const { error: updateError } = await supabase
            .from("profiles")
            .update(updateData)
            .eq("id", currentUser.id);

          if (updateError) throw updateError;

          // Update local stats
          Object.assign(userStats, updateData);
        } catch (error) {
          console.error("Error updating user stats:", error);
        }
      }

      function calculateOverallProgress() {
        const completedLessons = getCompletedLessonsCount();
        return Math.round(
          (completedLessons / COURSE_DATA.lessons.length) * 100
        );
      }

      function getCompletedLessonsCount() {
        return Object.values(courseProgress).filter(
          (lesson) => lesson.completed
        ).length;
      }

      function updateProgressDisplay() {
        const completedCount = getCompletedLessonsCount();
        const progressPercent = calculateOverallProgress();

        // Update UI elements
        const elements = {
          completedLessons: completedCount,
          courseProgressPercent: `${progressPercent}%`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });

        // Update progress bar
        const progressBar = document.getElementById("courseProgressFill");
        if (progressBar) progressBar.style.width = `${progressPercent}%`;
      }

      // =====================================================
      // LESSON MANAGEMENT
      // =====================================================
      function loadLesson(index) {
        if (index < 0 || index >= COURSE_DATA.lessons.length) return;

        const lesson = COURSE_DATA.lessons[index];
        currentLessonIndex = index;

        // Mark lesson as started and track activity
        if (!courseProgress[lesson.id]) {
          courseProgress[lesson.id] = {
            started: true,
            completed: false,
            startedAt: new Date().toISOString(),
            timeSpent: 0,
          };

          courseSession.lessonsStarted++;
          saveProgress();

          // Log lesson start
          logUserActivity("lesson_start", {
            lesson_id: lesson.id,
            lesson_title: lesson.title,
            lesson_index: index,
          });
        }

        // Update lesson start time for time tracking
        courseProgress[lesson.id].currentSessionStart = new Date();

        // Update sidebar and navigation
        renderSidebar();
        updateNavigationButtons();

        // Update header info
        updateLessonHeader(lesson, index);

        // Render lesson content
        renderLessonContent(lesson);

        // Smooth scroll and animations
        window.scrollTo({ top: 0, behavior: "smooth" });
        document.getElementById("contentBody").scrollTop = 0;

        const contentBody = document.getElementById("contentBody");
        contentBody.classList.add("fade-in");
        setTimeout(() => contentBody.classList.remove("fade-in"), 500);

        // Check lesson-based achievements
        checkLessonAchievements(index + 1);
      }

      function updateLessonHeader(lesson, index) {
        const elements = {
          currentLessonNumber: index + 1,
          currentLessonTitle: lesson.title,
          navInfo: `Lesson ${index + 1} of ${COURSE_DATA.lessons.length}`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });
      }

      function renderSidebar() {
        const lessonNav = document.getElementById("lessonNav");
        if (!lessonNav) return;

        lessonNav.innerHTML = "";

        COURSE_DATA.lessons.forEach((lesson, index) => {
          const lessonItem = document.createElement("div");
          lessonItem.className = "lesson-item";

          // Determine lesson status
          const lessonProgress = courseProgress[lesson.id];
          const isCompleted = lessonProgress?.completed || false;
          const isInProgress = lessonProgress?.started || false;
          const isLocked = !isCompleted && !canAccessLesson(index);
          const isActive = index === currentLessonIndex;

          // Apply status classes
          if (isCompleted) lessonItem.classList.add("completed");
          if (isLocked) lessonItem.classList.add("locked");
          if (isActive) lessonItem.classList.add("active");

          // Determine status display
          let statusClass = "not-started";
          let statusIcon = index + 1;

          if (isCompleted) {
            statusClass = "completed";
            statusIcon = "";
          } else if (isInProgress) {
            statusClass = "in-progress";
            statusIcon = "";
          }

          // Create lesson item HTML
          lessonItem.innerHTML = `
            <div class="lesson-status ${statusClass}">${statusIcon}</div>
            <div class="lesson-info">
                <div class="lesson-title">${lesson.title}</div>
                <div class="lesson-meta">
                    ${
                      isCompleted
                        ? "Completed"
                        : isInProgress
                        ? "In Progress"
                        : isLocked
                        ? "Locked"
                        : "Not Started"
                    }
                </div>
            </div>
            <div class="lesson-duration">${lesson.duration}</div>
        `;

          // Add click handler if not locked
          if (!isLocked) {
            lessonItem.addEventListener("click", () => {
              if (index !== currentLessonIndex) {
                // Track lesson time before switching
                trackLessonTime();

                currentLessonIndex = index;
                loadLesson(index);
                closeSidebar();
              }
            });
          }

          lessonNav.appendChild(lessonItem);
        });
      }

      function canAccessLesson(index) {
        if (index === 0) return true; // First lesson always accessible

        // Can access if previous lesson is completed
        const previousLessonId = COURSE_DATA.lessons[index - 1].id;
        return courseProgress[previousLessonId]?.completed || false;
      }

      function trackLessonTime() {
        const currentLesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonProgress = courseProgress[currentLesson.id];

        if (lessonProgress?.currentSessionStart) {
          const sessionTime = Math.floor(
            (new Date() - new Date(lessonProgress.currentSessionStart)) /
              1000 /
              60
          );
          lessonProgress.timeSpent =
            (lessonProgress.timeSpent || 0) + sessionTime;
          delete lessonProgress.currentSessionStart;
        }
      }

      // =====================================================
      // LESSON CONTENT RENDERING
      // =====================================================
      function renderLessonContent(lesson) {
        const contentContainer = document.getElementById("lessonContent");
        if (!contentContainer) return;

        let contentHTML = `
        <div class="content-section">
            <h2>Learning Objectives</h2>
            <ul>
                ${lesson.objectives.map((obj) => `<li>${obj}</li>`).join("")}
            </ul>
        </div>
        
        <div class="content-section">
            <h2>Overview</h2>
            <p>${lesson.content.overview}</p>
        </div>
    `;

        // Render content sections
        lesson.content.sections.forEach((section) => {
          contentHTML += `
            <div class="content-section">
                <h2>${section.title}</h2>
                ${section.content}
                ${
                  section.image
                    ? `<img src="${section.image}" alt="${section.title}" class="content-image" loading="lazy">`
                    : ""
                }
            </div>
        `;
        });

        // Render code examples
        if (
          lesson.content.codeExamples &&
          lesson.content.codeExamples.length > 0
        ) {
          contentHTML += `<div class="content-section"><h2>Code Examples</h2></div>`;

          lesson.content.codeExamples.forEach((example, index) => {
            const codeId = `code-${lesson.id}-${index}`;
            contentHTML += `
                <div class="code-section">
                    <div class="code-header">
                        <span class="code-title">${example.title}</span>
                        <button class="copy-btn" onclick="copyCode('${codeId}')">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <pre class="code-block"><code id="${codeId}" class="language-${
              example.language
            }">${escapeHtml(example.code)}</code></pre>
                </div>
            `;
          });
        }

        // Render quiz
        contentHTML += renderQuiz(lesson.quiz);

        contentContainer.innerHTML = contentHTML;

        // Highlight code syntax if Prism is available
        setTimeout(() => {
          if (window.Prism) {
            Prism.highlightAll();
          }
        }, 100);
      }

      // =====================================================
      // QUIZ SYSTEM
      // =====================================================
      function renderQuiz(quiz) {
        const currentLessonProgress =
          courseProgress[COURSE_DATA.lessons[currentLessonIndex].id];
        const isCompleted = currentLessonProgress?.completed || false;

        let quizHTML = `
        <div class="quiz-section" id="quizSection">
            <div class="quiz-header">
                <h2 class="quiz-title">
                    <i class="fas fa-clipboard-check"></i>
                    Knowledge Check
                </h2>
                <p class="quiz-info">
                    Complete this quiz with ${quiz.passingScore}% or higher to unlock the next lesson.
                </p>
            </div>
    `;

        if (isCompleted) {
          const savedScore = currentLessonProgress.quizScore || 0;
          quizHTML += `
            <div class="quiz-results show">
                <div class="quiz-score pass">${savedScore}%</div>
                <div class="quiz-message">
                    <strong>Lesson Completed!</strong><br>
                    You've successfully passed this lesson's quiz.
                </div>
            </div>
        `;
        } else {
          // Render quiz questions
          quiz.questions.forEach((question, qIndex) => {
            quizHTML += `
                <div class="quiz-question ${
                  qIndex === 0 ? "active" : ""
                }" data-question="${qIndex}">
                    <div class="question-header">
                        <span class="question-number">Question ${
                          qIndex + 1
                        }</span>
                        <span class="question-progress">${qIndex + 1}/${
              quiz.questions.length
            }</span>
                    </div>
                    <div class="question-text">${question.question}</div>
                    <div class="question-options">
                        ${question.options
                          .map(
                            (option, oIndex) => `
                            <div class="option" data-option="${oIndex}" onclick="selectOption(${qIndex}, ${oIndex})">
                                <span class="option-letter">${String.fromCharCode(
                                  65 + oIndex
                                )}</span>
                                <span class="option-text">${option}</span>
                            </div>
                        `
                          )
                          .join("")}
                    </div>
                </div>
            `;
          });

          quizHTML += `
            <div class="quiz-controls">
                <button class="btn btn-secondary" id="prevQuestionBtn" onclick="previousQuestion()" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <div>
                    <button class="btn btn-secondary" id="nextQuestionBtn" onclick="nextQuestion()" disabled>
                        Next
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <button class="btn btn-primary" id="submitQuizBtn" onclick="submitQuiz()" style="display: none;">
                        <i class="fas fa-check"></i>
                        Submit Quiz
                    </button>
                </div>
            </div>

            <div class="quiz-results" id="quizResults">
                <div class="quiz-score" id="quizScore">0%</div>
                <div class="quiz-message" id="quizMessage"></div>
                <div class="quiz-actions">
                    <button class="btn btn-primary" id="continueBtn" onclick="completeLesson()" style="display: none;">
                        <i class="fas fa-arrow-right"></i>
                        Continue to Next Lesson
                    </button>
                    <button class="btn btn-secondary" onclick="retakeQuiz()">
                        <i class="fas fa-redo"></i>
                        Retake Quiz
                    </button>
                </div>
            </div>
        `;
        }

        quizHTML += "</div>";
        return quizHTML;
      }

      // Quiz interaction functions
      function selectOption(questionIndex, optionIndex) {
        // Clear previous selections
        document
          .querySelectorAll(`[data-question="${questionIndex}"] .option`)
          .forEach((opt) => {
            opt.classList.remove("selected");
          });

        // Select current option
        const selectedOption = document.querySelector(
          `[data-question="${questionIndex}"] [data-option="${optionIndex}"]`
        );
        selectedOption.classList.add("selected");

        // Store answer
        quizState.answers[questionIndex] = optionIndex;

        // Update navigation
        const isLastQuestion =
          questionIndex ===
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length - 1;
        if (isLastQuestion) {
          document.getElementById("submitQuizBtn").style.display =
            "inline-flex";
          document.getElementById("nextQuestionBtn").style.display = "none";
        } else {
          document.getElementById("nextQuestionBtn").disabled = false;
        }
      }

      function nextQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const nextQuestionEl = currentQuestionEl.nextElementSibling;

        if (
          nextQuestionEl &&
          nextQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          nextQuestionEl.classList.add("active");
          quizState.currentQuestion++;
          updateQuizNavigation();
        }
      }

      function previousQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const prevQuestionEl = currentQuestionEl.previousElementSibling;

        if (
          prevQuestionEl &&
          prevQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          prevQuestionEl.classList.add("active");
          quizState.currentQuestion--;
          updateQuizNavigation();
        }
      }

      function updateQuizNavigation() {
        const totalQuestions =
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length;
        const prevBtn = document.getElementById("prevQuestionBtn");
        const nextBtn = document.getElementById("nextQuestionBtn");
        const submitBtn = document.getElementById("submitQuizBtn");

        prevBtn.disabled = quizState.currentQuestion === 0;

        const hasAnswer =
          quizState.answers[quizState.currentQuestion] !== undefined;
        const isLastQuestion = quizState.currentQuestion === totalQuestions - 1;

        if (isLastQuestion) {
          nextBtn.style.display = "none";
          submitBtn.style.display = hasAnswer ? "inline-flex" : "none";
        } else {
          nextBtn.style.display = "inline-flex";
          nextBtn.disabled = !hasAnswer;
          submitBtn.style.display = "none";
        }
      }

      async function submitQuiz() {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const quiz = lesson.quiz;
        let correctAnswers = 0;

        // Hide questions and controls
        document
          .querySelectorAll(".quiz-question")
          .forEach((q) => (q.style.display = "none"));
        document.querySelector(".quiz-controls").style.display = "none";

        // Calculate score and highlight answers
        quiz.questions.forEach((question, index) => {
          const userAnswer = quizState.answers[index];
          const correctAnswer = question.correct;
          const isCorrect = userAnswer === correctAnswer;

          if (isCorrect) correctAnswers++;

          // Highlight answers
          const questionEl = document.querySelector(
            `[data-question="${index}"]`
          );
          const options = questionEl.querySelectorAll(".option");

          options[correctAnswer].classList.add("correct");
          if (userAnswer !== correctAnswer && userAnswer !== undefined) {
            options[userAnswer].classList.add("incorrect");
          }
        });

        const score = Math.round(
          (correctAnswers / quiz.questions.length) * 100
        );
        const passed = score >= quiz.passingScore;

        // Update quiz results UI
        const quizScore = document.getElementById("quizScore");
        const quizMessage = document.getElementById("quizMessage");
        const quizActions = document.querySelector(".quiz-actions");

        quizScore.textContent = `${score}%`;
        quizScore.className = `quiz-score ${passed ? "pass" : "fail"}`;

        if (passed) {
          quizMessage.innerHTML = `
            <strong>Congratulations!</strong><br>
            You passed with ${score}%. You can now proceed to the next lesson.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-primary" onclick="completeLesson()">
                <i class="fas fa-arrow-right"></i>
                Continue to Next Lesson
            </button>
        `;

          // Mark lesson as completed
          await markLessonComplete(score);
        } else {
          quizMessage.innerHTML = `
            <strong>Not quite there yet.</strong><br>
            You scored ${score}%. You need ${quiz.passingScore}% to pass. Review the material and try again.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-secondary" onclick="retakeQuiz()">
                <i class="fas fa-redo"></i>
                Retake Quiz
            </button>
        `;
        }

        document.getElementById("quizResults").classList.add("show");

        // Log quiz completion
        logUserActivity("quiz_completed", {
          lesson_id: lesson.id,
          lesson_title: lesson.title,
          score: score,
          passed: passed,
          attempts: (courseProgress[lesson.id]?.quizAttempts || 0) + 1,
        });

        // Scroll to results
        document
          .getElementById("quizResults")
          .scrollIntoView({ behavior: "smooth" });
      }

      function retakeQuiz() {
        // Reset quiz state
        quizState = {
          currentQuestion: 0,
          answers: [],
          score: 0,
          isComplete: false,
        };

        // Track quiz retry
        const lessonId = COURSE_DATA.lessons[currentLessonIndex].id;
        if (!courseProgress[lessonId]) courseProgress[lessonId] = {};
        courseProgress[lessonId].quizAttempts =
          (courseProgress[lessonId].quizAttempts || 0) + 1;

        // Reload lesson content
        loadLesson(currentLessonIndex);

        // Scroll to quiz
        setTimeout(() => {
          document
            .getElementById("quizSection")
            .scrollIntoView({ behavior: "smooth" });
        }, 500);
      }

      async function markLessonComplete(score) {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonId = lesson.id;

        // Track lesson completion time
        trackLessonTime();

        // Update lesson progress
        courseProgress[lessonId] = {
          ...courseProgress[lessonId],
          completed: true,
          quizScore: score,
          completedAt: new Date().toISOString(),
          finalScore: score,
        };

        // Update session tracking
        courseSession.lessonsCompleted++;

        // Save progress to database
        await saveProgress();

        // Update UI
        renderSidebar();
        updateNavigationButtons();

        // Check various achievements
        await checkLessonCompletionAchievements();
        await checkPerfectScoreAchievements(score);
        await checkStudyTimeAchievements();

        // Log lesson completion
        logUserActivity("lesson_completed", {
          lesson_id: lessonId,
          lesson_title: lesson.title,
          final_score: score,
          time_spent: courseProgress[lessonId].timeSpent || 0,
          lesson_number: currentLessonIndex + 1,
        });

        showToast("Lesson completed successfully!", "success");
      }

      async function completeLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          // Move to next lesson
          currentLessonIndex++;
          loadLesson(currentLessonIndex);
        } else {
          // Course completion
          await completeCourse();
        }
      }

      async function completeCourse() {
        try {
          const completionTime = courseSession.totalStudyTime;

          // Update course progress to 100% completed
          await supabase
            .from("course_progress")
            .update({
              progress: 100,
              completed_at: new Date().toISOString(),
              completion_time_minutes: completionTime,
            })
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Award course completion achievements
          await checkAndUnlockAchievement("course_completion_1");
          await checkSpeedCompletionAchievements(completionTime);
          await checkCourseStreakAchievements();

          // Update user stats
          await updateUserStats();

          // Show completion message
          showToast(
            "Congratulations! Course completed successfully!",
            "certificate"
          );

          // Log course completion
          logUserActivity("course_completed", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            completion_time_minutes: completionTime,
            total_lessons: COURSE_DATA.lessons.length,
            average_quiz_score: calculateAverageQuizScore(),
          });

          // Redirect to dashboard after delay
          setTimeout(() => {
            window.location.href = "/dashboard.html";
          }, 3000);
        } catch (error) {
          console.error("Error completing course:", error);
          showToast("Error marking course as complete", "error");
        }
      }

      // =====================================================
      // ACHIEVEMENT INTEGRATION SYSTEM
      // =====================================================
      async function checkAndUnlockAchievement(
        achievementId,
        skipNotification = false
      ) {
        try {
          // Prevent duplicate checks
          const cacheKey = `achievement_${achievementId}_${currentUser.id}`;
          if (sessionStorage.getItem(cacheKey)) return false;

          // Check if already unlocked
          const { data: existing, error } = await supabase
            .from("user_achievements")
            .select("id")
            .eq("user_id", currentUser.id)
            .eq("achievement_id", achievementId)
            .single();

          if (existing) {
            sessionStorage.setItem(cacheKey, "true");
            return false;
          }

          // Award achievement
          const achievementData = {
            user_id: currentUser.id,
            achievement_id: achievementId,
            unlocked_at: new Date().toISOString(),
            points_awarded: getAchievementPoints(achievementId),
            context: "course_system",
          };

          const { data, error: insertError } = await supabase
            .from("user_achievements")
            .insert([achievementData])
            .select()
            .single();

          if (insertError) {
            if (insertError.code === "23505") return false; // Already exists
            throw insertError;
          }

          // Update user points
          await supabase.rpc('increment_user_stats', {
  user_id_param: currentUser.id,
  points_to_add: achievementData.points_awarded,
  achievements_to_add: 1
});

          // Cache and queue notification
          sessionStorage.setItem(cacheKey, "true");

          if (!skipNotification) {
            queueAchievementNotification({
              id: achievementId,
              name: getAchievementName(achievementId),
              description: getAchievementDescription(achievementId),
              points: achievementData.points_awarded,
              rarity: getAchievementRarity(achievementId),
              icon: getAchievementIcon(achievementId),
            });
          }

          return true;
        } catch (error) {
          console.error("Error unlocking achievement:", error);
          return false;
        }
      }

      // Helper functions for achievement data (replace with your actual achievement definitions)
      function getAchievementPoints(id) {
        const pointsMap = {
          first_course_start: 75,
          first_lesson: 100,
          course_completion_1: 500,
          perfect_score: 250,
          speed_demon: 750,
          marathon_learner: 500,
          night_owl: 200,
          early_bird: 200,
          weekend_warrior: 150,
          // Add more as needed
        };
        return pointsMap[id] || 100;
      }

      function getAchievementName(id) {
        const nameMap = {
          first_course_start: "Learning Initiated",
          first_lesson: "First Steps",
          course_completion_1: "Course Conqueror",
          perfect_score: "Perfectionist",
          speed_demon: "Speed Demon",
          // Add more as needed
        };
        return nameMap[id] || "Achievement Unlocked";
      }

      function getAchievementDescription(id) {
        const descMap = {
          first_course_start: "Start your first cybersecurity course",
          first_lesson: "Complete your first lesson",
          course_completion_1: "Complete your first course",
          perfect_score: "Score 100% on any quiz",
          speed_demon: "Complete a course in under 2 hours",
          // Add more as needed
        };
        return descMap[id] || "Achievement description";
      }

      function getAchievementRarity(id) {
        const rarityMap = {
          first_course_start: "common",
          first_lesson: "bronze",
          course_completion_1: "silver",
          perfect_score: "gold",
          speed_demon: "legendary",
          // Add more as needed
        };
        return rarityMap[id] || "common";
      }

      function getAchievementIcon(id) {
        const iconMap = {
          first_course_start: "fas fa-play",
          first_lesson: "fas fa-baby",
          course_completion_1: "fas fa-trophy",
          perfect_score: "fas fa-star",
          speed_demon: "fas fa-rocket",
          // Add more as needed
        };
        return iconMap[id] || "fas fa-award";
      }

      async function checkLessonAchievements(lessonNumber) {
        if (lessonNumber === 1) {
          await checkAndUnlockAchievement("first_lesson");
        }

        // Check if user has completed multiple lessons in one day
        const today = new Date().toISOString().split("T")[0];
        const todayCompletions = Object.values(courseProgress).filter(
          (p) => p.completed && p.completedAt?.startsWith(today)
        ).length;

        if (todayCompletions >= 3) {
          await checkAndUnlockAchievement("lesson_marathon");
        }
      }

      async function checkLessonCompletionAchievements() {
        const completedCount = getCompletedLessonsCount();

        // Lesson-based achievements
        const lessonMilestones = [1, 5, 10, 25, 50, 100];
        for (const milestone of lessonMilestones) {
          if (completedCount >= milestone) {
            await checkAndUnlockAchievement(`lessons_${milestone}`);
          }
        }

        // Course completion achievements
        if (completedCount === COURSE_DATA.lessons.length) {
          await checkAndUnlockAchievement("course_completion_1");

          // Check for additional course completion achievements
          const { data: allCourses } = await supabase
            .from("course_progress")
            .select("course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100);

          const totalCompleted = allCourses?.length || 0;

          const courseMilestones = [1, 5, 10, 25];
          for (const milestone of courseMilestones) {
            if (totalCompleted >= milestone) {
              await checkAndUnlockAchievement(`course_completion_${milestone}`);
            }
          }
        }
      }

      async function checkPerfectScoreAchievements(score) {
        if (score === 100) {
          await checkAndUnlockAchievement("perfect_score");

          // Check for consecutive perfect scores
          const recentScores = Object.values(courseProgress)
            .filter((p) => p.completed && p.quizScore)
            .slice(-5) // Last 5 completed
            .map((p) => p.quizScore);

          if (
            recentScores.length >= 3 &&
            recentScores.every((s) => s === 100)
          ) {
            await checkAndUnlockAchievement("perfectionist_streak");
          }
        }
      }

      async function checkSpeedCompletionAchievements(completionTime) {
        // Speed demon: Complete course in under 2 hours (120 minutes)
        if (completionTime <= 120) {
          await checkAndUnlockAchievement("speed_demon");
        }

        // Quick learner: Complete course in under 4 hours (240 minutes)
        if (completionTime <= 240) {
          await checkAndUnlockAchievement("quick_learner");
        }
      }

      async function checkStudyTimeAchievements() {
        const totalTime = courseSession.totalStudyTime;

        // Marathon learner: Study for 8+ hours in a course session
        if (totalTime >= 480) {
          // 8 hours
          await checkAndUnlockAchievement("marathon_learner");
        }

        // Dedicated learner: Study for 4+ hours
        if (totalTime >= 240) {
          // 4 hours
          await checkAndUnlockAchievement("dedicated_learner");
        }
      }

      async function checkCourseStreakAchievements() {
        try {
          // Check for consecutive course completions
          const { data: recentCourses, error } = await supabase
            .from("course_progress")
            .select("completed_at, course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100)
            .order("completed_at", { ascending: false })
            .limit(10);

          if (error || !recentCourses) return;

          // Check for courses completed on consecutive days
          let consecutiveDays = 1;
          for (let i = 1; i < recentCourses.length; i++) {
            const prevDate = new Date(
              recentCourses[i - 1].completed_at
            ).toDateString();
            const currentDate = new Date(
              recentCourses[i].completed_at
            ).toDateString();
            const dayDiff =
              Math.abs(new Date(prevDate) - new Date(currentDate)) /
              (1000 * 60 * 60 * 24);

            if (dayDiff <= 1) {
              consecutiveDays++;
            } else {
              break;
            }
          }

          if (consecutiveDays >= 3) {
            await checkAndUnlockAchievement("learning_streak");
          }
        } catch (error) {
          console.error("Error checking course streak achievements:", error);
        }
      }

      // =====================================================
      // TIME-BASED ACHIEVEMENTS
      // =====================================================
      async function checkTimeBasedAchievements(timestamp) {
        const hour = timestamp.getHours();
        const dayOfWeek = timestamp.getDay();

        // Night owl (after midnight, before 6 AM)
        if (hour >= 0 && hour < 6) {
          await incrementTimeBasedCounter("midnight_sessions", "night_owl");
        }

        // Early bird (4 AM to 6 AM)
        if (hour >= 4 && hour < 6) {
          await incrementTimeBasedCounter("early_sessions", "early_bird");
        }

        // Weekend warrior (Saturday = 6, Sunday = 0)
        if (dayOfWeek === 0 || dayOfWeek === 6) {
          await incrementTimeBasedCounter(
            "weekend_sessions",
            "weekend_warrior"
          );
        }
      }

      async function incrementTimeBasedCounter(counterType, achievementId) {
        try {
          const dateStr = new Date().toISOString().split("T")[0];
          const cacheKey = `${counterType}_${currentUser.id}_${dateStr}`;

          // Prevent multiple increments per day
          if (sessionStorage.getItem(cacheKey)) return;

          // Update counter
          await supabase
            .from("profiles")
            .update({
              [counterType]: supabase.sql`${counterType} + 1`,
            })
            .eq("id", currentUser.id);

          // Cache to prevent double counting
          sessionStorage.setItem(cacheKey, "true");

          // Check related achievement
          if (achievementId) {
            await checkAndUnlockAchievement(achievementId, true);
          }
        } catch (error) {
          console.error(`Error incrementing ${counterType}:`, error);
        }
      }

      async function checkDailyStreak() {
        try {
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("last_activity, current_streak, last_streak_date")
            .eq("id", currentUser.id)
            .single();

          if (error) throw error;

          const now = new Date();
          const today = now.toDateString();
          const lastActivity = profile.last_activity
            ? new Date(profile.last_activity)
            : null;
          const lastStreakDate = profile.last_streak_date
            ? new Date(profile.last_streak_date).toDateString()
            : null;

          let newStreak = profile.current_streak || 0;
          let shouldUpdateStreak = false;

          if (!lastActivity) {
            // First time user
            newStreak = 1;
            shouldUpdateStreak = true;
          } else {
            const daysSinceLastActivity = Math.floor(
              (now - lastActivity) / (1000 * 60 * 60 * 24)
            );

            if (lastStreakDate === today) {
              // Already counted today's streak
              return newStreak;
            } else if (
              daysSinceLastActivity === 1 ||
              (daysSinceLastActivity === 0 && lastStreakDate !== today)
            ) {
              // Consecutive day or same day but not counted yet
              newStreak += 1;
              shouldUpdateStreak = true;
            } else if (daysSinceLastActivity > 1) {
              // Streak broken
              newStreak = 1;
              shouldUpdateStreak = true;
            }
          }

          if (shouldUpdateStreak) {
            await supabase
              .from("profiles")
              .update({
                current_streak: newStreak,
                last_activity: now.toISOString(),
                last_streak_date: now.toISOString(),
              })
              .eq("id", currentUser.id);

            userStats.current_streak = newStreak;

            showToast(`Daily streak: ${newStreak} days!`, "success");
            await checkStreakAchievements(newStreak);
          }

          return newStreak;
        } catch (error) {
          console.error("Error checking daily streak:", error);
          return 0;
        }
      }

      async function checkStreakAchievements(currentStreak) {
        const streakMilestones = [3, 7, 14, 30, 100, 365];

        for (const milestone of streakMilestones) {
          if (currentStreak >= milestone) {
            await checkAndUnlockAchievement(`streak_${milestone}`);
          }
        }
      }

      // =====================================================
      // USER ACTIVITY LOGGING
      // =====================================================
      async function logUserActivity(activityType, metadata = {}) {
        try {
          const now = new Date();

          const activityData = {
            user_id: currentUser.id,
            activity_type: activityType,
            timestamp: now.toISOString(),
            course_id: COURSE_DATA.id,
            lesson_index: currentLessonIndex,
            session_duration: courseSession.totalStudyTime,
            metadata: JSON.stringify(metadata),
            created_at: now.toISOString(),
          };

          // Try to log to activities table
          const { error } = await supabase
            .from("user_activities")
            .insert([activityData]);

          if (error && error.code !== "42P01") {
            console.warn("Activity logging failed:", error.message);
          }

          // Always update last activity in profile
          await supabase
            .from("profiles")
            .update({ last_activity: now.toISOString() })
            .eq("id", currentUser.id);
        } catch (error) {
          console.error("Error logging user activity:", error);
        }
      }

      // =====================================================
      // NAVIGATION SYSTEM
      // =====================================================
      function updateNavigationButtons() {
        const prevBtn = document.getElementById("prevLessonBtn");
        const nextBtn = document.getElementById("nextLessonBtn");

        if (!prevBtn || !nextBtn) return;

        // Previous button
        prevBtn.disabled = currentLessonIndex === 0;

        // Next button logic
        const isLastLesson =
          currentLessonIndex === COURSE_DATA.lessons.length - 1;
        const canGoNext =
          currentLessonIndex < COURSE_DATA.lessons.length - 1 &&
          canAccessLesson(currentLessonIndex + 1);

        if (isLastLesson) {
          const isCurrentCompleted =
            courseProgress[COURSE_DATA.lessons[currentLessonIndex].id]
              ?.completed;
          nextBtn.disabled = !isCurrentCompleted;
          nextBtn.innerHTML = '<i class="fas fa-trophy"></i> Complete Course';
        } else {
          nextBtn.disabled = !canGoNext;
          nextBtn.innerHTML = 'Next <i class="fas fa-chevron-right"></i>';
        }
      }

      // Navigation button event handlers
      function goToPreviousLesson() {
        if (currentLessonIndex > 0) {
          trackLessonTime(); // Track time spent on current lesson
          currentLessonIndex--;
          loadLesson(currentLessonIndex);
        }
      }

      function goToNextLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          const canGoNext = canAccessLesson(currentLessonIndex + 1);
          if (canGoNext) {
            trackLessonTime();
            currentLessonIndex++;
            loadLesson(currentLessonIndex);
          } else {
            showToast("Complete the current lesson quiz to proceed", "warning");
          }
        } else {
          // Complete course
          completeCourse();
        }
      }

      // =====================================================
      // SIDEBAR FUNCTIONS
      // =====================================================
      function toggleSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.toggle("open");
        if (overlay) overlay.classList.toggle("active");
      }

      function closeSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.remove("open");
        if (overlay) overlay.classList.remove("active");
      }

      // =====================================================
      // ACHIEVEMENT NOTIFICATION SYSTEM
      // =====================================================
      function queueAchievementNotification(achievement) {
        notificationQueue.push(achievement);
        processNotificationQueue();
      }

      function processNotificationQueue() {
        if (isShowingNotification || notificationQueue.length === 0) return;

        isShowingNotification = true;
        const achievement = notificationQueue.shift();
        showAchievementNotification(achievement);

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          isShowingNotification = false;
          processNotificationQueue();
        }, duration + 500);
      }

      function showAchievementNotification(achievement) {
        const notification = document.getElementById("achievementNotification");
        if (!notification) return;

        const icon = document.getElementById("notificationIcon");
        const title = document.getElementById("notificationTitle");
        const description = document.getElementById("notificationDescription");
        const points = document.getElementById("notificationPoints");

        if (icon) {
          icon.innerHTML = `<i class="${achievement.icon}"></i>`;
          icon.className = `notification-icon ${achievement.rarity}`;
        }
        if (title) title.textContent = achievement.name;
        if (description) description.textContent = achievement.description;
        if (points) points.textContent = `+${achievement.points} Points`;

        notification.className = `achievement-notification ${achievement.rarity}`;
        notification.classList.add("show");

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          notification.classList.remove("show");
        }, duration);
      }

      // =====================================================
      // UTILITY FUNCTIONS
      // =====================================================
      function calculateAverageQuizScore() {
        const scores = Object.values(courseProgress)
          .filter((p) => p.completed && p.quizScore)
          .map((p) => p.quizScore);

        if (scores.length === 0) return 0;
        return Math.round(
          scores.reduce((sum, score) => sum + score, 0) / scores.length
        );
      }

      async function resetProgress() {
        if (
          !confirm(
            "Are you sure you want to reset your progress? This action cannot be undone."
          )
        ) {
          return;
        }

        try {
          // Track lesson time before reset
          trackLessonTime();

          // Reset local state
          courseProgress = {};
          currentLessonIndex = 0;
          courseSession = {
            startTime: new Date(),
            totalStudyTime: 0,
            lessonsStarted: 0,
            lessonsCompleted: 0,
            pageLoadTime: new Date(),
            interactionCount: 0,
            lastActivityTime: new Date(),
          };

          // Delete from database
          await supabase
            .from("course_progress")
            .delete()
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Log reset activity
          logUserActivity("progress_reset", {
            course_id: COURSE_DATA.id,
            reset_reason: "manual",
          });

          // Reinitialize
          await saveProgress();
          renderSidebar();
          loadLesson(0);

          showToast("Progress reset successfully", "success");
        } catch (error) {
          console.error("Error resetting progress:", error);
          showToast("Failed to reset progress", "error");
        }
      }

      function copyCode(codeId) {
        const codeElement = document.getElementById(codeId);
        if (!codeElement) return;

        const text = codeElement.textContent;

        navigator.clipboard
          .writeText(text)
          .then(() => {
            showToast("Code copied to clipboard!", "success");

            // Track code copy for achievements
            logUserActivity("code_copied", {
              code_section: codeId,
              lesson_id: COURSE_DATA.lessons[currentLessonIndex].id,
            });
          })
          .catch((err) => {
            console.error("Failed to copy code:", err);
            showToast("Failed to copy code", "error");

            // Fallback for older browsers
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            try {
              document.execCommand("copy");
              showToast("Code copied to clipboard!", "success");
            } catch (fallbackError) {
              showToast(
                "Copy failed - please select and copy manually",
                "error"
              );
            }
            document.body.removeChild(textArea);
          });
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // =====================================================
      // UI FEEDBACK SYSTEMS
      // =====================================================
      function showToast(message, type = "success") {
        const toast = document.getElementById("toast");
        const messageEl = document.getElementById("toastMessage");

        if (!toast || !messageEl) {
          console.log(`Toast: ${message} (${type})`);
          return;
        }

        messageEl.textContent = message;
        toast.className = `toast ${type} show`;

        setTimeout(() => {
          toast.classList.remove("show");
        }, 4000);
      }

      function showLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) loadingScreen.classList.remove("hidden");
      }

      function hideLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) {
          setTimeout(() => {
            loadingScreen.classList.add("hidden");
          }, 1000);
        }
      }

      // =====================================================
      // MUSIC PLAYER INTEGRATION
      // =====================================================
      function initMusicPlayer() {
        const btnText = document.getElementById("music-button-text");
        const icon = document.getElementById("music-icon");
        const dropdown = document.getElementById("music-dropdown-content");

        if (!btnText || !icon || !dropdown) return;

        function setUI(state) {
          btnText.textContent =
            state === "Playing" ? "PAUSE MUSIC" : "STUDY MUSIC";
          icon.className =
            state === "Playing"
              ? "fa-solid fa-circle-pause"
              : "fa-solid fa-music";
        }

        // Load saved music state
        const savedSrc = localStorage.getItem("cybersec_music_src");
        const savedTime = parseFloat(
          localStorage.getItem("cybersec_music_time") || 0
        );

        if (savedSrc) {
          audioPlayer.src = savedSrc;
          audioPlayer.currentTime = savedTime;
          audioPlayer
            .play()
            .then(() => setUI("Playing"))
            .catch(() => setUI("Stopped"));
        }

        // Music button click handler
        document
          .getElementById("music-dropdown")
          .querySelector("button")
          .addEventListener("click", (e) => {
            e.stopPropagation();
            dropdown.style.display =
              dropdown.style.display === "block" ? "none" : "block";

            if (audioPlayer.src && !audioPlayer.paused) {
              audioPlayer.pause();
              setUI("Stopped");
            } else if (audioPlayer.src) {
              audioPlayer.play().then(() => setUI("Playing"));
            }
          });

        // Music selection handlers
        dropdown.querySelectorAll("a[data-src]").forEach((link) => {
          link.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.src = link.dataset.src;
            audioPlayer.play().then(() => setUI("Playing"));
            localStorage.setItem("cybersec_music_src", link.dataset.src);
            dropdown.style.display = "none";
          });
        });

        // Stop music handler
        const stopLink = document.getElementById("stop-music-link");
        if (stopLink) {
          stopLink.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            audioPlayer.removeAttribute("src");
            setUI("Stopped");
            localStorage.removeItem("cybersec_music_src");
            localStorage.removeItem("cybersec_music_time");
            dropdown.style.display = "none";
          });
        }

        // Save music state before page unload
        window.addEventListener("beforeunload", () => {
          if (!audioPlayer.paused && audioPlayer.src) {
            localStorage.setItem("cybersec_music_src", audioPlayer.src);
            localStorage.setItem(
              "cybersec_music_time",
              audioPlayer.currentTime
            );
          }
        });

        // Close dropdown when clicking outside
        window.addEventListener("click", (e) => {
          if (!e.target.closest("#music-dropdown")) {
            dropdown.style.display = "none";
          }
        });
      }

      // Show initial music indicator
      function addMusicIndicator() {
        const musicBtn = document.querySelector("#music-dropdown");
        if (musicBtn) {
          const indicator = document.createElement("div");
          indicator.className = "music-indicator";
          indicator.innerHTML = `<i class="fa-solid fa-music"></i> Try Study Music!`;

          musicBtn.style.position = "relative";
          musicBtn.appendChild(indicator);

          setTimeout(() => indicator.remove(), 3000);
        }
      }

      // Initialize Event Listeners
      function initializeEventListeners() {
        // Navigation buttons
        document
          .getElementById("prevLessonBtn")
          ?.addEventListener("click", goToPreviousLesson);
        document
          .getElementById("nextLessonBtn")
          ?.addEventListener("click", goToNextLesson);

        // Reset progress button
        document
          .getElementById("resetProgressBtn")
          ?.addEventListener("click", resetProgress);

        // Mobile menu toggle
        document
          .getElementById("menuToggle")
          ?.addEventListener("click", toggleSidebar);
        document
          .getElementById("sidebarOverlay")
          ?.addEventListener("click", closeSidebar);

        // Keyboard shortcuts
        document.addEventListener("keydown", handleKeyboardShortcuts);

        // Window resize handler
        window.addEventListener("resize", handleWindowResize);

        // Content interaction tracking
        document.getElementById("contentBody")?.addEventListener(
          "scroll",
          debounce(() => {
            trackUserInteraction();
          }, 1000)
        );
      }

      // Keyboard Shortcuts
      function handleKeyboardShortcuts(e) {
        if (document.querySelector(".quiz-question.active")) return;

        if (e.key === "ArrowLeft" && e.ctrlKey) {
          e.preventDefault();
          goToPreviousLesson();
        } else if (e.key === "ArrowRight" && e.ctrlKey) {
          e.preventDefault();
          goToNextLesson();
        }
      }

      // Window Resize Handler
      function handleWindowResize() {
        if (window.innerWidth > 768) {
          closeSidebar();
        }
      }

      // Debounce Helper
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Initialize responsive behavior
      if (window.innerWidth <= 768) {
        document.getElementById("menuToggle").style.display = "inline-flex";
      }

      // Auto-save progress periodically
      setInterval(async () => {
        if (currentUser && Object.keys(courseProgress).length > 0) {
          await saveProgress();
        }
      }, 60000); // Save every minute

      // System initialization logging
      console.log("CyberSec Academy Course System Initialized");
      console.log("Current Course:", COURSE_DATA.title);
      console.log("Total Lessons:", COURSE_DATA.lessons.length);

      // Google OAuth Integration
      const googleBtn = document.querySelector(".btn-google");
      if (googleBtn) {
        googleBtn.addEventListener("click", async () => {
          const { data, error } = await supabase.auth.signInWithOAuth({
            provider: "google",
            options: {
              redirectTo:
                window.location.origin +
                "/courses/public-key-infrastructure-pki.html",
            },
          });

          if (error) {
            console.error("Google login error:", error.message);
            showToast("Google login failed: " + error.message, "error");
          }
        });
      }

      // Check for existing session
      supabase.auth.getSession().then(({ data }) => {
        if (data.session) {
          console.log("User already logged in:", data.session.user);
          currentUser = data.session.user;
          startCourseSession();
        }
      });

      // Add missing auth modal functions
      function openAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "flex";
        }
      }

      function closeAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Add auth tab switching functionality
      document.getElementById("tabSignIn")?.addEventListener("click", () => {
        document.getElementById("tabSignIn").classList.add("active");
        document.getElementById("tabSignUp").classList.remove("active");
        document.getElementById("signInForm").style.display = "block";
        document.getElementById("signUpForm").style.display = "none";
      });

      document.getElementById("tabSignUp")?.addEventListener("click", () => {
        document.getElementById("tabSignUp").classList.add("active");
        document.getElementById("tabSignIn").classList.remove("active");
        document.getElementById("signUpForm").style.display = "block";
        document.getElementById("signInForm").style.display = "none";
      });

      document
        .getElementById("closeAuthModal")
        ?.addEventListener("click", closeAuthModal);

      // Improved error handling for auth session
      supabase.auth.onAuthStateChange((event, session) => {
        if (event === "SIGNED_IN") {
          currentUser = session.user;
          closeAuthModal();
          startCourseSession();
        } else if (event === "SIGNED_OUT") {
          currentUser = null;
          openAuthModal();
        }
      });

      // Add form submission handlers
      document
        .getElementById("emailSignInForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signInEmail").value;
          const password = document.getElementById("signInPassword").value;

          try {
            const { data, error } = await supabase.auth.signInWithPassword({
              email,
              password,
            });

            if (error) throw error;

            closeAuthModal();
          } catch (error) {
            showToast(error.message, "error");
          }
        });

      document
        .getElementById("emailSignUpForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signUpEmail").value;
          const password = document.getElementById("signUpPassword").value;
          const name = document.getElementById("signUpName").value;

          try {
            const { data, error } = await supabase.auth.signUp({
              email,
              password,
              options: {
                data: {
                  full_name: name,
                },
              },
            });

            if (error) throw error;

            showToast(
              "Account created successfully! Please check your email.",
              "success"
            );
          } catch (error) {
            showToast(error.message, "error");
          }
        });
    </script>
  </body>
</html>

