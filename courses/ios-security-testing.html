




<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Exo+2:wght@700;800;900&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css"
    />
    <link rel="stylesheet" href="assets/css/coursepages.css">
    <meta name="robots" content="noindex, nofollow">
    <!-- ========== Start: SEO & Schema Enhancement ========== -->
    <title>iOS Security Testing Masterclass | CipherHall</title>
    <meta name="description" content="Enroll in our masterclass on iOS Security Testing. Learn to jailbreak devices, reverse engineer apps, and bypass security with Frida.">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png" />
    <link rel="shortcut icon" href="/favicon.png" type="image/x-icon" />
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png" />
    <link rel="canonical" href="https://www.cipherhall.com/courses/ios-security-testing.html" />

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Course",
      "name": "iOS Security Testing: A Masterclass",
      "description": "An exhaustive, 50-lesson deep dive into the art and science of iOS application security, taking you from Apple's security architecture to advanced exploitation on jailbroken devices.",
      "provider": {
        "@type": "Organization",
        "name": "CipherHall",
        "sameAs": "https://www.cipherhall.com"
      },
      "hasCourseInstance": {
        "@type": "CourseInstance",
        "courseMode": "Online",
        "instructor": {
          "@type": "Person",
          "name": "Dr. Eva 'Cycript' Rostova"
        }
      }
    }
    </script>
    <!-- ========== End: SEO & Schema Enhancement ========== -->
</head>
  <body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
      <div class="loader-icon">
        <i class="fas fa-graduation-cap"></i>
      </div>
      <div class="loader-text">Loading Course Content...</div>
    </div>

    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- Music Player (fixed at top right) -->
    <div class="header-controls">
      <div class="music-dropdown" id="music-dropdown">
        <button class="btn btn-secondary">
          <span id="music-button-text">STUDY MUSIC</span>
          <i id="music-icon" class="fa-solid fa-music"></i>
        </button>
        <div class="music-dropdown-content" id="music-dropdown-content">
          <a
            href="#"
            data-src="https://www.learningcontainer.com/wp-content/uploads/2020/02/Kalimba.mp3"
            >1. Coffee Shop Vibes</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3"
            >2. City Lights Lofi</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-15.mp3"
            >3. Mellow Thoughts</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-13.mp3"
            >4. Rainy Mood</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3"
            >5. Time Alone</a
          >
          <a href="#" id="stop-music-link"
            ><i class="fa-solid fa-stop-circle"></i> Stop Music</a
          >
        </div>
      </div>

      <button class="btn btn-secondary" id="resetProgressBtn">
        <i class="fas fa-redo"></i>
        Reset Progress
      </button>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal" style="display: none">
      <div class="modal-overlay"></div>
      <div class="modal-content">
        <span class="close" id="closeAuthModal">&times;</span>
        <div class="auth-tabs">
          <button id="tabSignIn" class="auth-tab active">Sign In</button>
          <button id="tabSignUp" class="auth-tab">Sign Up</button>
        </div>
        <div
          id="authLoader"
          style="display: none; text-align: center; padding: 2rem"
        >
          <i
            class="fas fa-spinner fa-spin fa-2x"
            style="color: var(--color-green)"
          ></i>
          <p style="margin-top: 0.5rem">Authenticating...</p>
        </div>
        <div id="signInForm" class="auth-form">
          <h2>Sign In to CipherHall</h2>
          <button id="googleSignIn" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignInForm">
            <input
              type="email"
              id="signInEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signInPassword"
              placeholder="Password"
              required
            />
            <button type="submit" class="btn btn-primary">Sign In</button>
          </form>
        </div>
        <div id="signUpForm" class="auth-form" style="display: none">
          <h2>Join CipherHall</h2>
          <button id="googleSignUp" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignUpForm">
            <input
              type="text"
              id="signUpName"
              placeholder="Full Name"
              required
            />
            <input
              type="email"
              id="signUpEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signUpPassword"
              placeholder="Password (min. 8 characters)"
              required
            />
            <button type="submit" class="btn btn-secondary">
              Create Account
            </button>
          </form>
        </div>
        <div id="authMessage"></div>
      </div>
    </div>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="course-info">
          <h1 class="course-title" id="courseTitle">Loading...</h1>
          <div class="course-progress">
            <div class="progress-header">
              <span class="progress-label">Course Progress</span>
              <span class="progress-percentage" id="courseProgressPercent"
                >0%</span
              >
            </div>
            <div class="progress-bar">
              <div
                class="progress-fill"
                id="courseProgressFill"
                style="width: 0%"
              ></div>
            </div>
            <div class="progress-stats">
              <span id="completedLessons">0</span>
              <span id="totalLessons">0</span>
            </div>
          </div>
          <a href="/dashboard.html" class="back-to-dashboard">
            <i class="fas fa-arrow-left"></i>
            Back to Dashboard
          </a>
        </div>
      </div>

      <nav class="lesson-nav" id="lessonNav">
        <!-- Lessons will be loaded dynamically -->
      </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <header class="content-header">
        <div class="lesson-header">
          <div class="lesson-header-left">
            <span class="lesson-number" id="currentLessonNumber">1</span>
            <h1 class="lesson-header-title" id="currentLessonTitle">
              Loading...
            </h1>
          </div>
          <div class="lesson-actions">
            <button class="mbtn btn-primary" id="menuToggle">
              <i class="fas fa-bars"></i>
            </button>
          </div>
        </div>
      </header>

      <div class="content-body" id="contentBody">
        <div class="lesson-content" id="lessonContent">
          <!-- Lesson content will be loaded dynamically -->
        </div>
      </div>

      <footer class="lesson-navigation">
        <div class="nav-info" id="navInfo">Lesson 1 of 10</div>
        <div class="nav-controls">
          <button class="btn btn-secondary" id="prevLessonBtn" disabled>
            <i class="fas fa-chevron-left"></i>
            Previous
          </button>
          <button class="btn btn-primary" id="nextLessonBtn" disabled>
            Next
            <i class="fas fa-chevron-right"></i>
          </button>
        </div>
      </footer>
    </main>

    <!-- Achievement Notification -->
    <div id="achievementNotification" class="achievement-notification">
      <div class="notification-header">
        <div class="notification-icon" id="notificationIcon">
          <i class="fas fa-trophy"></i>
        </div>
        <div class="notification-content">
          <h3 id="notificationTitle">Achievement Unlocked!</h3>
          <p id="notificationDescription">Description here...</p>
        </div>
      </div>
      <div class="notification-reward" id="notificationReward">
        <i class="fas fa-coins"></i>
        <span id="notificationPoints">+100 Points</span>
      </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast">
      <span id="toastMessage"></span>
    </div>

    <script>
      // =====================================================
      // SYNCHRONIZED COURSE SYSTEM WITH DASHBOARD INTEGRATION
      // =====================================================

      // Supabase Configuration - Replace with your config
      const supabaseUrl = "https://lzcmzulemfubjaksoqor.supabase.co";
      const supabaseKey =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx6Y216dWxlbWZ1Ympha3NvcW9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzMzM5MDgsImV4cCI6MjA3MDkwOTkwOH0.crhPH4YWtRsr1BJTpAQcmPbWSpwIWRbzoI4sRb2_fPI";
      const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

      // =====================================================
      // COURSE DATA STRUCTURE - REPLACE WITH YOUR COURSE JSON
      // =====================================================
      const COURSE_DATA = {
        "id": "ios-security-testing",
        "title": "iOS Security Testing: A Masterclass",
        "description": "An exhaustive, 50-lesson deep dive into the art and science of iOS application security. This course takes you from the foundational principles of Apple's security architecture to mastering advanced exploitation, reverse engineering, and runtime manipulation on jailbroken devices.",
        "category": "mobile-security",
        "difficulty": "Intermediate to Advanced",
        "duration": "100 hours",
        "instructor": "Dr. Eva 'Cycript' Rostova",
        "lessons": [
            {
                "id": "lesson-1-ios-security-architecture",
                "title": "Lesson 1: iOS Security Architecture",
                "duration": "120 min",
                "objectives": [
                    "Deconstruct the iOS Secure Boot Chain process, from Boot ROM to the kernel",
                    "Understand key hardware security features like the Secure Enclave and Face ID/Touch ID",
                    "Define the role and limitations of the iOS Application Sandbox",
                    "Explain how Mandatory Code Signing is enforced on the platform"
                ],
                "content": {
                    "overview": "This foundational lesson unpacks the formidable, multi-layered security architecture of iOS. We will explore how security is built into the hardware and firmware, from the immutable Boot ROM that starts the Secure Boot Chain to the powerful Secure Enclave that protects your most sensitive keys. Understanding this architecture is crucial for appreciating the challenges and nuances of iOS security testing.",
                    "sections": [
                        {
                            "title": "The Secure Boot Chain",
                            "content": "<p>iOS devices are designed to trust only software that has been cryptographically signed by Apple. This trust is established through a sequence of checks at boot time called the Secure Boot Chain.</p><h3>The Chain of Trust:</h3><ol><li><strong>Boot ROM:</strong> The first code that runs on the processor is the Boot ROM, which is permanently etched into the silicon chip and cannot be modified. It contains Apple's root CA public key.</li><li><strong>Low-Level Bootloader (LLB):</strong> The Boot ROM verifies the cryptographic signature of the LLB using Apple's public key. If the signature is valid, it executes the LLB.</li><li><strong>iBoot:</strong> The LLB, in turn, verifies the signature of the next-stage bootloader, iBoot.</li><li><strong>Kernel:</strong> iBoot verifies the signature of the iOS kernel before loading it.</li></ol><p>This unbroken chain of trust ensures that the device is running a legitimate, unmodified version of the iOS operating system from the moment it is powered on. Jailbreaking is the process of finding and exploiting a vulnerability in this chain to allow unsigned code to run.</p>",
                            "image": "https://images.unsplash.com/photo-1593110022831-292911b3b194?w=800&h=400&fit-crop"
                        },
                        {
                            "title": "Hardware Security: The Secure Enclave",
                            "content": "<p>The Secure Enclave is a separate, dedicated secure coprocessor that is physically isolated from the main application processor. It has its own secure boot and personalized operating system. Its primary job is to handle and protect highly sensitive data, such as:</p><ul><li><strong>Cryptographic keys:</strong> Data Protection keys used for file system encryption.</li><li><strong>Biometric data:</strong> The mathematical representation of your fingerprint or face.</li></ul><p>Even if the main iOS kernel is compromised, an attacker cannot directly access the key material stored within the Secure Enclave. All interactions happen through a strictly controlled API.</p>",
                            "image": "https://images.unsplash.com/photo-1593064390382-2c63824f5a83?w=800&h=400&fit-crop"
                        },
                        {
                            "title": "The Application Sandbox",
                            "content": "<p>Every third-party application on iOS runs in a very restrictive sandbox. The app is given its own private directory (a 'container') on the file system, and it is strictly forbidden from accessing the data of other apps or most of the operating system. All interactions with the system, like accessing the camera or contacts, must be done through tightly controlled APIs that require explicit user permission. This sandbox provides the primary layer of isolation between applications and is the reason a jailbreak is necessary for deep inspection.</p>",
                            "image": "https://images.unsplash.com/photo-1599691888286-93e433f064b8?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary goal of the iOS Secure Boot Chain?", "options": ["To make the device boot faster", "To ensure that only legitimate, Apple-signed software (from the bootloader to the kernel) is loaded", "To allow users to install any software they want", "To manage user passwords"], "correct": 1, "explanation": "The Secure Boot Chain is the foundational element of iOS platform integrity, designed to prevent persistent malware and unauthorized OS modifications." },
                        { "id": 2, "question": "Highly sensitive data, such as cryptographic keys for file encryption, are protected by which hardware component?", "options": ["The main application processor", "The Secure Enclave", "The display controller", "The Wi-Fi chip"], "correct": 1, "explanation": "The Secure Enclave is a hardware-isolated coprocessor that acts as the root of trust for all cryptographic operations and sensitive data protection on the device." }
                    ]
                }
            },
            {
                "id": "lesson-2-ios-dev-fundamentals",
                "title": "Lesson 2: iOS Development Fundamentals for Pentesters",
                "duration": "120 min",
                "objectives": [
                    "Identify the key components in an Xcode project and the roles of Swift and Objective-C",
                    "Understand the iOS App Lifecycle and its security implications (e.g., backgrounding)",
                    "Deconstruct the Info.plist file to understand an app's core configuration and permissions",
                    "Recognize the importance of secure handling of frameworks and libraries"
                ],
                "content": {
                    "overview": "To break an iOS app, you must first understand its anatomy. This lesson provides a crash course in the core components and concepts of iOS development from a security tester's perspective, focusing on the architectural pieces that form the attack surface.",
                    "sections": [
                        {
                            "title": "The Info.plist File: The App's Blueprint",
                            "content": "<p>Similar to the AndroidManifest.xml, the `Info.plist` (Information Property List) file is the app's primary metadata and configuration file. It's a structured XML file that tells the OS how to handle the app. A security review **always** starts here.</p><h3>Key Security-Relevant Entries:</h3><ul><li><strong>`NSAppTransportSecurity` (ATS):</strong> The dictionary that configures App Transport Security, which enforces secure network connections. A weak configuration here is a major red flag.</li><li><strong>Privacy Usage Descriptions:</strong> Keys like `NSLocationWhenInUseUsageDescription` or `NSCameraUsageDescription`. These are the strings shown to the user when the app requests sensitive permissions.</li><li><strong>`CFBundleURLTypes`:</strong> Declares the custom URL schemes that the app can handle. This is a primary attack surface for Inter-Process Communication (IPC).</li><li><strong>`LSApplicationQueriesSchemes`:</strong> Declares which other app URL schemes this app intends to query, which can reveal information about the apps a user has installed.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1517694712202-14261e80e3a5?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Example Insecure ATS Configuration in Info.plist (XML)",
                        "language": "xml",
                        "code": "<!-- DANGER: This configuration disables all network security protections, -->\n<!-- allowing the app to make cleartext HTTP connections anywhere. -->\n<!-- This is a high-severity finding. -->\n<key>NSAppTransportSecurity</key>\n<dict>\n    <key>NSAllowsArbitraryLoads</key>\n    <true/>\n</dict>"
                    },
                    {
                        "title": "Example Custom URL Scheme Declaration in Info.plist",
                        "language": "xml",
                        "code": "<!-- This declares that the app can be launched with a URL like 'myapp://...' -->\n<!-- This is a key entry point for security testing. -->\n<key>CFBundleURLTypes</key>\n<array>\n    <dict>\n        <key>CFBundleURLName</key>\n        <string>com.example.myapp</string>\n        <key>CFBundleURLSchemes</key>\n        <array>\n            <string>myapp</string>\n        </array>\n    </dict>\n</array>"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary configuration file in an iOS app that declares its permissions and capabilities to the operating system?", "options": ["The main Swift file", "The `Info.plist` file", "The `Podfile`", "The `Assets.xcassets` folder"], "correct": 1, "explanation": "The `Info.plist` is the blueprint of the app, analogous to the `AndroidManifest.xml`. A security review always starts with a thorough analysis of this file." },
                        { "id": 2, "question": "The settings for App Transport Security (ATS), which governs network security, are found in which file?", "options": ["The application's source code", "The App Store description", "The `Info.plist` file", "A text file on the server"], "correct": 2, "explanation": "The `NSAppTransportSecurity` dictionary within the `Info.plist` is where a developer configures network encryption policies for their app. Misconfigurations here are a common vulnerability." }
                    ]
                }
            },
            {
                "id": "lesson-3-testing-environment",
                "title": "Lesson 3: iOS Security Testing Environment Setup",
                "duration": "180 min",
                "objectives": [
                    "Differentiate between testing on an iOS Simulator vs. a physical device",
                    "Understand the process of jailbreaking an iOS device to gain privileged access",
                    "Configure a jailbroken device with essential testing tools (SSH, Frida, file managers)",
                    "Install and trust a proxy CA certificate to intercept HTTPS traffic"
                ],
                "content": {
                    "overview": "Unlike Android, you cannot simply use an emulator with root access for most iOS testing. Real dynamic analysis requires a physical, jailbroken iOS device. This lesson provides a complete, hands-on guide to preparing a device and your computer to create a professional iOS testing lab.",
                    "sections": [
                        {
                            "title": "Jailbreaking and Tool Installation",
                            "content": "<p>A jailbreak is a process that exploits a vulnerability in iOS to bypass security controls, ultimately giving the user root access. This is essential for installing the tools needed for a security assessment.</p><h3>Post-Jailbreak Setup:</h3><ol><li><strong>Install OpenSSH:</strong> This allows you to SSH into your device from your computer, giving you a full command-line shell on the device. **Crucially, you must immediately change the default root password (the default is almost always `alpine`).**</li><li><strong>Install Frida Server:</strong> Frida runs in two parts. You install the client tools on your computer and the `frida-server` package on the jailbroken device via Cydia.</li><li><strong>Install a File Manager:</strong> A tool like Filza allows you to browse the entire file system directly on the device, bypassing the sandbox.</li></ol>",
                            "image": "https://images.unsplash.com/photo-1585250184288-5175908b083c?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Connecting to Your Jailbroken Device via SSH",
                        "language": "bash",
                        "code": "# From your Mac/Linux terminal. Assumes your device is at IP 192.168.1.123\nssh root@192.168.1.123\n# It will prompt for a password. The default is 'alpine'.\n\n# --- IMMEDIATELY AFTER YOUR FIRST LOGIN ---\niPhone-Pro:~ root# passwd\nChanging password for root.\nNew password:\nRetype new password:"
                    },
                    {
                        "title": "Using `apt` on the Device to Install Frida",
                        "language": "bash",
                        "code": "# Cydia and other modern package managers use APT (the Debian package manager).\n# After SSHing into the device:\niPhone-Pro:~ root# apt-get update\niPhone-Pro:~ root# apt-get install frida"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Why is a physical, jailbroken device required for most serious iOS security testing?", "options": ["The iOS Simulator provides a more secure and realistic environment", "Because a jailbreak provides the root-level access needed to bypass the sandbox, install debugging tools like Frida, and inspect an application's internal data", "Simulators have better battery life", "Physical devices are cheaper"], "correct": 1, "explanation": "The limitations of the Simulator and the locked-down nature of a stock iOS device make a jailbroken phone the essential platform for deep dynamic analysis and reverse engineering." },
                        { "id": 2, "question": "After jailbreaking and installing OpenSSH, what is the most critical first security step?", "options": ["Install a new theme", "Change the default root password (which is 'alpine')", "Check the weather", "Browse the internet"], "correct": 1, "explanation": "Failing to change the default password leaves your device wide open to anyone on the same network who could SSH in as root. It is a critical and mandatory first step for any tester." }
                    ]
                }
            },
            {
                "id": "lesson-4-app-structure",
                "title": "Lesson 4: iOS Application Structure",
                "duration": "120 min",
                "objectives": [
                    "Deconstruct the structure of an iOS Application Archive (IPA) file",
                    "Understand the Mach-O binary format for executables",
                    "Analyze an app's `Info.plist` and resource files",
                    "Understand the roles of code signing and provisioning profiles in the app's integrity"
                ],
                "content": {
                    "overview": "An iOS app is delivered as a single file with an `.ipa` extension. This lesson covers how to unpack and deconstruct this file to understand its internal structure, laying the groundwork for static analysis. You will learn about the key files inside an IPA, from the compiled binary to the manifest.",
                    "sections": [
                        {
                            "title": "The IPA File Format",
                            "content": "<p>Similar to an Android APK, an IPA file is simply a ZIP archive. You can change the extension to `.zip` and unzip it to see its contents. Inside, you will find a `Payload/` directory, which contains the main application bundle (`.app`).</p><h3>Key Files Inside the App Bundle:</h3><ul><li><strong>The Main Binary:</strong> A compiled executable in the Mach-O format (e.g., `AppName`). This is the primary target for disassembly.</li><li><strong>`Info.plist`:</strong> The app's blueprint and configuration file, in binary plist format.</li><li><strong>Frameworks and Libraries:</strong> Any bundled third-party libraries.</li><li><strong>`_CodeSignature/`:</strong> Contains the code signature, which is used by the OS to verify that the app has not been tampered with and was signed by a trusted developer.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Unpacking an IPA file (macOS Terminal)",
                        "language": "bash",
                        "code": "# Create a directory for the app analysis\nmkdir AppAnalysis && cd AppAnalysis\n\n# Copy the IPA file here\ncp ~/Downloads/MyApp.ipa .\n\n# Rename it to a zip file and unzip it\nmv MyApp.ipa MyApp.zip\nunzip MyApp.zip"
                    },
                    {
                        "title": "Convert Binary Plist to XML for Reading",
                        "language": "bash",
                        "code": "# The Info.plist inside the app bundle is in a binary format.\n# Use the `plutil` command on macOS to convert it to a readable XML format.\nplutil -convert xml1 Payload/MyApp.app/Info.plist"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "An IPA file is actually a standard _____ file.", "options": ["TAR", "RAR", "ZIP", "GZ"], "correct": 2, "explanation": "Like an APK, understanding that an IPA is just a zip archive is the first step in reverse engineering it. You can simply rename it and unzip it to begin your analysis." }
                    ]
                }
            },
            {
                "id": "lesson-5-ipa-analysis",
                "title": "Lesson 5: IPA Analysis and Extraction",
                "duration": "150 min",
                "objectives": [
                    "Use tools to extract and decrypt a fairplay-encrypted app from a device",
                    "Use `class-dump` to extract Objective-C class and method information from the binary",
                    "Load the main binary into a disassembler like Hopper or Ghidra for analysis"
                ],
                "content": {
                    "overview": "This is the first hands-on reverse engineering lesson for iOS. You will learn how to bypass App Store encryption, and then use powerful reverse engineering tools to extract class information and begin disassembling the application's main executable.",
                    "sections": [
                        {
                            "title": "Decrypting App Store Apps",
                            "content": "<p>Apps downloaded from the official App Store are encrypted with Apple's FairPlay DRM. You cannot statically analyze an encrypted binary. The first step is to get a decrypted copy. This requires a jailbroken device. You can use a tool like `frida-ios-dump` or other decryption utilities on your jailbroken phone. These tools will load the application into memory (where it is decrypted), and then dump the decrypted binary from memory back to a file, giving you a clean `.ipa` that you can analyze.</p>",
                            "image": "https://images.unsplash.com/photo-1585250184288-5175908b083c?w=800&h=400&fit-crop"
                        },
                        {
                            "title": "`class-dump` and Disassemblers",
                            "content": "<p>`class-dump` is a command-line tool that can read the metadata stored in an Objective-C binary and generate a set of 'header' files. These files give you a complete, human-readable list of all the classes and methods in the application, which is a fantastic roadmap for further analysis. Once you have this map, you load the decrypted main binary into a disassembler like Ghidra or Hopper to analyze the actual machine code.</p>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Decrypt an App with frida-ios-dump (SSH into device)",
                        "language": "bash",
                        "code": "# 1. SSH into your jailbroken device as root.\nssh root@<your_device_ip>\n\n# 2. Find the application's bundle name.\nfrida-ps -Ua | grep 'YourAppName'\n\n# 3. Run the dump tool. It will find the process, dump the decrypted memory, and package it into an IPA file.\ndump.py 'YourAppName'"
                    },
                    {
                        "title": "Use class-dump on the Decrypted Binary (on your Mac)",
                        "language": "bash",
                        "code": "# 1. SCP the decrypted app binary from your device to your Mac.\nscp root@<your_device_ip>:/path/to/decrypted/AppName .\n\n# 2. Run class-dump against the binary.\n# The -H flag tells it to generate separate header files.\n# The -o flag specifies the output directory.\nclass-dump -H AppName -o ./headers/"
                    },
                    {
                        "title": "Example Output of class-dump (Objective-C Header)",
                        "language": "objectivec",
                        "code": "// --- Output from class-dump in headers/LoginViewController.h ---\n// This gives us a roadmap of methods to investigate.\n// The `isPasswordValid:` method looks very interesting to hook with Frida.\n\n@interface LoginViewController : UIViewController\n{\n    UITextField *_usernameField;\n    UITextField *_passwordField;\n}\n\n- (void)loginButtonTapped:(id)arg1;\n- (_Bool)isPasswordValid:(id)arg1;\n\n@end"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Why is it necessary to use a jailbroken device to get a usable binary for an app downloaded from the App Store?", "options": ["The App Store only serves apps for jailbroken phones", "App Store apps are encrypted with FairPlay DRM, and a jailbroken device is needed to run a tool that can dump the decrypted version from memory", "It's not necessary", "Because the App Store has a slower download speed"], "correct": 1, "explanation": "Static analysis requires a decrypted binary. The standard procedure is to use a tool on a jailbroken device to get this decrypted IPA." },
                        { "id": 2, "question": "The tool `class-dump` is used for what purpose?", "options": ["To decrypt the application", "To install the application", "To extract a human-readable list of all Objective-C classes and method signatures from the binary", "To analyze network traffic"], "correct": 2, "explanation": "The output of `class-dump` is an essential first step in reverse engineering an Objective-C application, as it provides a high-level map of the codebase to guide your deeper analysis in a disassembler." }
                    ]
                }
            },
            {
                "id": "lesson-6-objectivec-runtime",
                "title": "Lesson 6: Objective-C Runtime Analysis",
                "duration": "120 min",
                "objectives": [
                    "Understand the dynamic nature of the Objective-C runtime and its implications for security",
                    "Perform runtime method swizzling to modify application behavior",
                    "Analyze how categories and extensions can be used to inject code"
                ],
                "content": {
                    "overview": "The dynamic nature of the Objective-C runtime is what makes many powerful iOS hacking techniques possible. This lesson explores this dynamism, focusing on how a security researcher can manipulate an application's behavior at runtime.",
                    "sections": [
                        {
                            "title": "Method Swizzling",
                            "content": "<p>Method swizzling is a powerful technique where you can change the implementation of an existing method at runtime. You can essentially 'swap out' the original method's code with your own. This is the underlying technology used by many jailbreak tweaks and is also used by Frida. For example, you can swizzle the implementation of a method that checks for a valid license and replace it with your own implementation that simply returns `true`.</p>",
                            "image": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Method Swizzling Example using Frida",
                        "language": "javascript",
                        "code": "// Let's assume we found the -[LoginViewController isPasswordValid:] method from class-dump.\n// This Frida script will hook it and make it always return true.\n\nif (ObjC.available) {\n    var loginVC = ObjC.classes.LoginViewController[\"- isPasswordValid:\"];\n    Interceptor.attach(loginVC.implementation, {\n        onLeave: function(retval) {\n            console.log(\"[+] Original return value of isPasswordValid: \" + retval);\n            retval.replace(1); // 1 represents `true`\n            console.log(\"[+] Patched return value to: 1\");\n        }\n    });\n}"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is 'method swizzling' in Objective-C?", "options": ["A way to compile code", "The process of changing the implementation of an existing method at runtime", "A security feature of Swift", "A way to encrypt data"], "correct": 1, "explanation": "Method swizzling is a key feature of the dynamic Objective-C runtime and a fundamental technique used by dynamic instrumentation tools like Frida to hook and modify application logic." }
                    ]
                }
            },
            {
                "id": "lesson-7-swift-security-analysis",
                "title": "Lesson 7: Swift Security Analysis",
                "duration": "120 min",
                "objectives": [
                    "Understand how Swift's static typing and memory safety features prevent common vulnerabilities",
                    "Reverse engineer compiled Swift code and its unique challenges like name mangling",
                    "Identify security risks in how Swift code interacts with legacy Objective-C code via bridging"
                ],
                "content": {
                    "overview": "Swift was designed from the ground up to be more secure than Objective-C. This lesson covers the security features of the Swift language and the new challenges a reverse engineer faces when analyzing a modern Swift application.",
                    "sections": [
                        {
                            "title": "Swift Safety Features",
                            "content": "<p>Swift has a number of language-level features that eliminate entire classes of common bugs.</p><ul><li><strong>Type Safety & Optionals:</strong> Prevents type confusion bugs and the dreaded null pointer exception.</li><li><strong>Memory Safety:</strong> Automatic Reference Counting (ARC) prevents most memory leaks, and other features protect against common memory corruption issues like buffer overflows.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit-crop"
                        },
                        {
                            "title": "Reversing Challenges: Name Mangling",
                            "content": "<p>Unlike Objective-C's readable method names, Swift uses extensive 'name mangling'. The Swift compiler encodes a function's full signature into its symbol name to support features like function overloading. This results in function names that look like gibberish in a disassembler (e.g., `_$s10MyAwesomeApp10myFunctionyyF`). A reverse engineer must use tools to 'demangle' these names back into a human-readable format.</p>",
                            "image": "https://images.unsplash.com/photo-1517694712202-14261e80e3a5?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Example of Swift Name Mangling",
                        "language": "swift",
                        "code": "// A simple Swift function\n// func myFunction() { ... }\n// in class MyAwesomeApp\n\n// Might compile to a symbol name like:\n// _$s10MyAwesomeApp10myFunctionyyF"
                    },
                    {
                        "title": "Demangling a Swift Name on the Command Line",
                        "language": "bash",
                        "code": "swift demangle _$s10MyAwesomeApp10myFunctionyyF\n\n# Output: MyAwesomeApp.myFunction() -> ()"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "The process where the Swift compiler encodes a function's full signature into a complex symbol name is called:", "options": ["Name mangling", "Obfuscation", "Encryption", "Compilation"], "correct": 0, "explanation": "Name mangling is a standard compiler feature for languages that support function overloading, but it adds an extra step for reverse engineers who must 'demangle' the names to understand the code." }
                    ]
                }
            },
            {
                "id": "lesson-8-automated-static-analysis",
                "title": "Lesson 8: Automated Static Analysis (SAST) for iOS",
                "duration": "120 min",
                "objectives": [
                    "Leverage Static Application Security Testing (SAST) tools to find common vulnerabilities in iOS code",
                    "Configure and run MobSF on an IPA file to get a comprehensive security report",
                    "Analyze and triage the results from a SAST scanner, separating true positives from false positives"
                ],
                "content": {
                    "overview": "Manual code review is powerful but slow. Automated static analysis (SAST) is essential for finding common vulnerabilities at scale. This lesson covers how to use automated tools to scan an application's source code and compiled package for security flaws.",
                    "sections": [
                        {
                            "title": "Mobile Security Framework (MobSF)",
                            "content": "<p>MobSF is an incredibly powerful, all-in-one open-source mobile security assessment framework. You can upload an IPA, and it will automatically perform a full static analysis, including:</p><ul><li>Unpacking the IPA and running `class-dump`.</li><li>Analyzing the `Info.plist` for misconfigurations.</li><li>Scanning the code for hard-coded secrets, insecure API usage, weak cryptography, and other common vulnerabilities.</li><li>Checking the binary for security mitigations like stack canaries and ARC.</li><li>Generating a comprehensive HTML report with all its findings.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1518770660439-4636190af475?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Running MobSF using Docker",
                        "language": "bash",
                        "code": "# Pull the latest MobSF image\ndocker pull opensecurity/mobile-security-framework-mobsf\n\n# Run MobSF. It will be accessible on localhost:8000\ndocker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary function of a SAST tool?", "options": ["To attack a running application", "To analyze an application's source code or binary for security vulnerabilities without executing it", "To monitor network traffic", "To manage user permissions"], "correct": 1, "explanation": "Static analysis (SAST) is a 'white-box' testing methodology that looks for vulnerability patterns in the code itself, making it great for finding bugs early." }
                    ]
                }
            },
            {
                "id": "lesson-9-runtime-manipulation-fundamentals",
                "title": "Lesson 9: Runtime Manipulation Fundamentals",
                "duration": "120 min",
                "objectives": [
                    "Use the Cycript framework for interactive runtime analysis and manipulation",
                    "Use LLDB to debug, set breakpoints in, and step through a running application",
                    "Inspect runtime objects and their properties in memory to understand application state"
                ],
                "content": {
                    "overview": "This lesson introduces the core tools for interacting with a running application on a jailbroken device. You will learn how to attach a debugger to a process and how to use the interactive Cycript console to explore and manipulate the application's state in real time.",
                    "sections": [
                        {
                            "title": "Interactive Exploration with Cycript",
                            "content": "<p>Cycript is a powerful tool that has an interactive console (a REPL) which understands a hybrid of Objective-C and JavaScript syntax. You can attach Cycript to a running process. Once attached, you can instantiate objects, call methods, and explore the application's entire view hierarchy and data model from the command line. It's an incredibly powerful tool for exploratory analysis to quickly understand how an app works under the hood.</p>",
                            "image": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Using Cycript to Inspect the UI",
                        "language": "javascript",
                        "code": "# SSH into your device\niPhone-Pro:~ root# cycript -p SpringBoard\n\ncy# // Get a reference to the running application\ncy# var app = [UIApp keyWindow];\n\ncy# // Get a recursive description of the entire UI view hierarchy\ncy# [app recursiveDescription].toString()\n\ncy# // Find a specific text field and change its value\ncy# var loginField = #0x10abcdef; // Memory address found from above\ncy# [loginField setText:@\"I control your app\"];"
                    },
                    {
                        "title": "Using LLDB to Attach and Set a Breakpoint",
                        "language": "bash",
                        "code": "# On your Mac, connect to the device\n~/$ debugserver *:1234 -a \"AppName\"\n\n# In another terminal on your Mac\n~/$ lldb\n(lldb) platform select remote-ios\n(lldb) process connect connect://<device_ip>:1234\n(lldb) b -[LoginViewController loginButtonTapped:] # Set a breakpoint on a method\n(lldb) c # Continue execution"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "The `[UIApp keyWindow].recursiveDescription().toString()` command in Cycript is used to do what?", "options": ["To crash the application", "To dump a detailed, hierarchical list of all the UI elements currently on the screen", "To change a user's password", "To send a network request"], "correct": 1, "explanation": "This is a classic exploratory technique to understand the application's UI structure and find the memory addresses of interesting objects you want to manipulate." }
                    ]
                }
            },
            {
                "id": "lesson-10-frida-for-ios",
                "title": "Lesson 10: Frida for iOS Testing",
                "duration": "180 min",
                "objectives": [
                    "Master the setup and use of Frida for iOS dynamic instrumentation",
                    "Write Frida scripts to hook Objective-C and Swift methods",
                    "Trace function calls and inspect arguments and return values",
                    "Bypass client-side security controls like jailbreak detection and certificate pinning"
                ],
                "content": {
                    "overview": "Frida is the single most important and powerful tool for modern iOS dynamic analysis. This is a masterclass in Frida. You will learn how to write your own scripts to hook into a running application's logic to inspect it, manipulate it, and bypass its security controls.",
                    "sections": [
                        {
                            "title": "Hooking with Frida",
                            "content": "<p>The core technique is 'hooking'. You can write a Frida script to find a specific class and method in the application's code and 'hook' it. This means your script will run *instead of* the original method, or *before* and *after* it. You can inspect the arguments passed to the method, view its return value, or even change the arguments and return value on the fly. This is incredibly powerful for bypassing client-side security controls, analyzing encryption routines, and understanding what an application is doing at a very deep level.</p>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Frida Script to Bypass a Simple PIN Check",
                        "language": "javascript",
                        "code": "// --- bypass-pin.js ---\n// Scenario: We found a method '- (BOOL)isPinCorrect:(NSString *)pin;' using class-dump.\n// This script hooks it and makes it always return TRUE.\n\nif (ObjC.available) {\n    var pinCheckMethod = ObjC.classes.PinViewController[\"- isPinCorrect:\"];\n    \n    Interceptor.attach(pinCheckMethod.implementation, {\n        onLeave: function(retval) {\n            console.log(\"[+] Original return value from isPinCorrect: \" + retval);\n            retval.replace(1); // 1 is true in Objective-C booleans\n            console.log(\"[+] ==> Patched return value to TRUE. Bypass successful!\");\n        }\n    });\n}\n\n// Command to run it:\n// frida -U -f com.example.vulnerableapp -l bypass-pin.js"
                    },
                    {
                        "title": "Frida Script to Trace Crypto Calls",
                        "language": "javascript",
                        "code": "// This script traces calls to a common crypto function to see what is being encrypted.\n\nInterceptor.attach(Module.findExportByName(\"libcommonCrypto.dylib\", \"CCCrypt\"), {\n    onEnter: function(args) {\n        console.log(\"\\n[+] CCCrypt called!\");\n        console.log(\"  - Data to be processed (first 16 bytes):\\n\" + hexdump(args[1], { length: 16 }));\n    }\n});"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Frida's `Interceptor.attach` function with its `onEnter` and `onLeave` callbacks allows a tester to do what?", "options": ["Change the application's icon", "Inspect and modify the arguments and return values of a function as it is being called in real time", "Decompile the entire application", "Install a different application"], "correct": 1, "explanation": "This powerful interception and manipulation capability is the core of what makes Frida so essential for dynamic analysis, allowing for surgical modification of a running application's logic." }
                    ]
                }
            },
            {
                "id": "lesson-11-network-traffic-analysis",
                "title": "Lesson 11: Network Traffic Analysis for iOS",
                "duration": "120 min",
                "objectives": [
                    "Configure an iOS device to proxy all traffic through Burp Suite",
                    "Master the use of Frida to bypass certificate pinning",
                    "Intercept and analyze both HTTP/HTTPS and binary protocol traffic",
                    "Test the application's backend APIs for web vulnerabilities"
                ],
                "content": {
                    "overview": "Analyzing network traffic is a core dynamic analysis task. It reveals what data the app is sending and receiving, how it communicates with its backend APIs, and whether it is doing so securely. This lesson covers the full workflow for iOS, from configuring the device and your proxy to the critical step of bypassing certificate pinning so that you can decrypt and analyze HTTPS traffic.",
                    "sections": [
                        {
                            "title": "Certificate Pinning Bypass with Frida",
                            "content": "<p>Many security-conscious applications implement 'SSL/TLS certificate pinning'. This is a security control where the application is coded to *only* trust the server's specific, hard-coded SSL certificate. If the app detects any other certificate (like the one generated by Burp Suite during a man-in-the-middle attack), it will refuse to connect. This is a powerful defense that we must bypass.</p><h3>Bypassing with Frida:</h3><p>We can use Frida to bypass this. A Frida script can hook the low-level library functions responsible for certificate validation (e.g., within the `Security` framework) and patch them in memory to always return a successful validation status. This tricks the application into trusting our Burp Suite CA certificate, allowing the traffic to be intercepted and decrypted.</p>",
                            "image": "https://images.unsplash.com/photo-1544890225-2fde1e46f71b?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Using a Public Frida Script for SSL Pinning Bypass",
                        "language": "bash",
                        "code": "# The community has created excellent, general-purpose scripts for this.\n# One of the most popular is available via the frida-tools repository.\n# This command spawns the target app and injects the script to bypass most common pinning implementations.\n\nfrida --codeshare pc-psi/ios-ssl-pinning-bypass -U -f com.example.pinnedapp"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is SSL/TLS Certificate Pinning?", "options": ["A way to make HTTPS connections faster", "A security mechanism where an application is hard-coded to only trust a specific server certificate, which can prevent man-in-the-middle attacks from proxies like Burp Suite", "A feature of the iOS OS", "A type of firewall"], "correct": 1, "explanation": "Certificate pinning is a strong security control that is specifically designed to thwart network interception by tools like Burp and ZAP, and bypassing it is a key skill for a mobile pentester." }
                    ]
                }
            },
            {
                "id": "lesson-12-filesystem-keychain-analysis",
                "title": "Lesson 12: File System and Keychain Analysis",
                "duration": "120 min",
                "objectives": [
                    "Navigate the iOS file system on a jailbroken device to find an app's data container",
                    "Perform a thorough security assessment of an application's data stored in the Keychain",
                    "Extract and analyze data from `UserDefaults` (plist files) and Core Data (SQLite)",
                    "Identify insecurely stored sensitive data"
                ],
                "content": {
                    "overview": "This lesson focuses on the data at rest on an iOS device. You will learn how to navigate the sandboxed file system on a jailbroken device and, more importantly, how to audit an application's use of the secure Keychain for storing sensitive data. Finding sensitive data stored in plaintext is a very common and critical finding.",
                    "sections": [
                        {
                            "title": "Insecure Data Storage in `UserDefaults`",
                            "content": "<p>`UserDefaults` is a simple key-value store used for storing user preferences and application state. It is stored as an unencrypted plist file in the app's data container. Developers often make the critical mistake of storing highly sensitive data, like session tokens, API keys, or even passwords, in `UserDefaults`. On a jailbroken device, this file can be easily pulled and read. Any sensitive data must be stored in the Keychain, not in `UserDefaults`.</p>",
                            "image": "https://images.unsplash.com/photo-1542382156942-0268579cf259?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Finding and Analyzing an App's UserDefaults (on device)",
                        "language": "bash",
                        "code": "# 1. SSH into the device.\n\n# 2. Find the application's data container directory.\n# The long string of letters/numbers is the app's unique UUID.\niPhone-Pro:~ root# find /var/mobile/Containers/Data/Application -name \"MyApp.app\"\n\n# 3. Navigate to the Preferences directory inside its container.\niPhone-Pro:~ root# cd /var/mobile/Containers/Data/Application/ABC-123-DEF-456/Library/Preferences\n\n# 4. The plist file is named with the app's bundle ID. View its contents.\niPhone-Pro:~ # cat com.example.myapp.plist"
                    },
                    {
                        "title": "Using a Keychain Dumper on a Jailbroken Device",
                        "language": "bash",
                        "code": "# Tools like Keychain-Dumper can be used on a jailbroken device to decrypt and\n# view the Keychain entries that an application has stored. This allows you to verify\n# what data is stored and which accessibility attributes are used.\n\niPhone-Pro:~ root# ./keychain_dumper"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the correct place for an iOS application to store a user's long-term session token or password?", "options": ["In a plain text file in the app bundle", "In `UserDefaults`", "In the secure, hardware-backed Keychain", "Hard-coded in the source code"], "correct": 2, "explanation": "The Keychain is specifically designed for the secure storage of small secrets, leveraging the device's hardware security features like the Secure Enclave." },
                        { "id": 2, "question": "Why is storing a user's API key in `UserDefaults` a critical vulnerability?", "options": ["It is not a vulnerability", "Because `UserDefaults` is stored as an unencrypted plist file, which can be easily read on a jailbroken or physically compromised device, leaking the key", "It can only store short strings", "It is deprecated by Apple"], "correct": 1, "explanation": "This is a classic insecure data storage vulnerability. The data is not encrypted at rest and is easily accessible to an attacker with file system access." }
                    ]
                }
            },
            {
                "id": "lesson-13-jailbreaking-techniques",
                "title": "Lesson 13: Jailbreaking Techniques",
                "duration": "120 min",
                "objectives": [
                    "Understand the difference between different types of jailbreaks (tethered, untethered, semi-tethered)",
                    "Use tools like `checkra1n` (hardware-based) and `unc0ver` (software-based) to perform a jailbreak",
                    "Understand the role of Cydia and other package managers for installing tools"
                ],
                "content": {
                    "overview": "This lesson provides a dedicated, hands-on look at the process of jailbreaking an iOS device. You will learn about the different categories of jailbreaks and the tools used to achieve them. A jailbroken device is the cornerstone of an iOS security testing lab.",
                    "sections": [
                        {
                            "title": "Hardware vs. Software Jailbreaks",
                            "content": "<ul><li><strong>Software-based Jailbreaks (e.g., `unc0ver`, `Taurine`):</strong> These exploit vulnerabilities in the iOS kernel or another high-level software component. They are 'patchable' by Apple; a new iOS update will usually fix the vulnerability, and the jailbreak will no longer work.</li><li><strong>Hardware-based Jailbreaks (e.g., `checkra1n`):</strong> This is a special category. The `checkm8` exploit, which `checkra1n` uses, is a vulnerability in the Boot ROM of certain Apple chips (A5 to A11). Because the Boot ROM is burned into the silicon, it cannot be patched by a software update. This means that affected devices (from iPhone 5s to iPhone X) are jailbreakable for life, regardless of their iOS version.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1585250184288-5175908b083c?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Running the checkra1n Jailbreak (from macOS)",
                        "language": "bash",
                        "code": "# checkra1n is a computer-based application. You connect your device and follow its instructions.\n# This command launches the checkra1n application in CLI mode.\n\n./checkra1n -c"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the key advantage of a hardware-based jailbreak like `checkra1n`?", "options": ["It is easier to use", "It exploits a vulnerability in the unpatchable Boot ROM, making certain devices permanently jailbreakable", "It works on all the newest iPhones", "It does not require a computer"], "correct": 1, "explanation": "This makes older devices like an iPhone 7 or X an incredibly valuable and stable platform for security research, as you know you will always be able to jailbreak them." }
                    ]
                }
            },
            {
                "id": "lesson-14-post-jailbreak-analysis",
                "title": "Lesson 14: Post-Jailbreak Analysis",
                "duration": "120 min",
                "objectives": [
                    "Gain root file system access via SSH and inspect critical system directories",
                    "Inspect running system processes and daemons using tools like `ps`",
                    "Understand how to analyze kernel extensions and security daemon configurations"
                ],
                "content": {
                    "overview": "With a jailbroken device, you have the keys to the kingdom. This lesson covers what to do next: how to connect to your device with SSH, navigate the full iOS file system, and understand the new level of visibility you now have into the operating system's internals.",
                    "sections": [
                        {
                            "title": "Exploring as Root",
                            "content": "<p>Once you SSH into your device as root, you can explore the entire file system, which is normally hidden from view. You can now go beyond just an app's container and inspect system-wide files.</p><h3>Key System Directories:</h3><ul><li>`/System/Library`: Contains the core OS frameworks and daemons.</li><li>`/Library/LaunchDaemons`: Contains the property lists for system daemons that are launched at boot.</li><li>`/private/var/Keychains`: Contains the system Keychain database (`keychain-2.sqlitedb`).</li></ul>",
                            "image": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Inspecting Processes and Network Connections (on device)",
                        "language": "bash",
                        "code": "# SSH into the device as root.\n\n# List all running processes, including the user they are running as.\nps aux\n\n# List all active network connections and the processes that own them.\nnetstat -anp"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "SSHing into a jailbroken device allows you to do what?", "options": ["Browse the web", "Make phone calls", "Get a full, root-level command-line shell on the device", "Change the volume"], "correct": 2, "explanation": "This shell is the primary interface for most advanced testing and analysis on a jailbroken device, giving you complete visibility and control." }
                    ]
                }
            },
            {
                "id": "lesson-15-class-dump",
                "title": "Lesson 15: Class-dump and Runtime Analysis",
                "duration": "120 min",
                "objectives": [
                    "Use `class-dump` and other tools to extract Objective-C class headers from a decrypted binary",
                    "Generate a high-level map of the application's internal structure and method signatures",
                    "Discover and analyze the use of private, undocumented APIs by an application"
                ],
                "content": {
                    "overview": "This is a focused lesson on a core reverse engineering technique. You will learn how to use `class-dump` to generate header files from the application's binary. This provides an invaluable roadmap for your dynamic analysis, telling you exactly which classes and methods are available to hook with Frida or Cycript.",
                    "sections": [
                        {
                            "title": "Discovering Private APIs",
                            "content": "<p>Running `class-dump` can also reveal if the application is using private, undocumented Apple APIs. Using private APIs is against the App Store rules, but many apps do it to access features that are not available in the public SDK. For a security reviewer, the use of private APIs is interesting because these APIs are not as stable and their behavior can change, potentially introducing unexpected security flaws.</p>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary output of the `class-dump` tool?", "options": ["A decrypted IPA file", "A set of Objective-C header files (.h files) that describe the application's classes and methods", "A list of vulnerabilities", "A network traffic capture"], "correct": 1, "explanation": "These headers act as a 'table of contents' for the application's binary, making it much easier to understand the code's structure and to find interesting functions to target for runtime hooking." }
                    ]
                }
            },
            {
                "id": "lesson-16-debugging-instrumentation",
                "title": "Lesson 16: Debugging and Instrumentation",
                "duration": "120 min",
                "objectives": [
                    "Use the LLDB debugger to attach to running processes on a jailbroken device",
                    "Set breakpoints on Objective-C methods and native functions",
                    "Step through code execution and inspect and modify the contents of memory and registers"
                ],
                "content": {
                    "overview": "This advanced lesson moves into low-level debugging. You will learn how to use LLDB, the debugger from the LLVM toolchain, to attach to a running application, pause its execution at any point, and perform a deep analysis of its state in memory. This is one of the most powerful reverse engineering techniques.",
                    "sections": [
                        {
                            "title": "Debugging with LLDB",
                            "content": "<p>With a jailbroken device, you can attach LLDB to any process. This allows you to:</p><ul><li><strong>Set breakpoints:</strong> You can tell the debugger to pause the application's execution right before a specific function is called.</li><li><strong>Step through code:</strong> Once paused, you can execute the code one line at a time.</li><li><strong>Inspect memory:</strong> You can read the contents of CPU registers (`register read`) and the application's stack and heap to see what data it is working with in real time. You can even modify values in memory on the fly.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1518770660439-4636190af475?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Setting a Breakpoint and Inspecting Arguments in LLDB",
                        "language": "bash",
                        "code": "# Assume we've attached LLDB to the process.\n\n# Set a breakpoint on a specific method.\n(lldb) b -[AuthViewController validatePassword:]\n\n# Now, use the app until that method is called. LLDB will break.\n\n# Print the first argument to the function (which is the password string).\n(lldb) po $arg3"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary function of a debugger like LLDB?", "options": ["To analyze network traffic", "To allow an analyst to attach to a running process, pause its execution, and inspect its state in memory", "To decompile an application", "To sign an application"], "correct": 1, "explanation": "A debugger provides the deepest level of runtime introspection and is an essential tool for advanced reverse engineering, malware analysis, and vulnerability research." }
                    ]
                }
            },
            {
                "id": "lesson-17-authentication",
                "title": "Lesson 17: iOS Authentication Testing",
                "duration": "120 min",
                "objectives": [
                    "Bypass insecure implementations of Touch ID and Face ID",
                    "Assess the security of passcode-based authentication logic",
                    "Understand how to test the Local Authentication framework and its common implementation pitfalls"
                ],
                "content": {
                    "overview": "This lesson focuses specifically on how to test the authentication mechanisms within an iOS app. We will cover common flaws in how developers use the Local Authentication framework, leading to bypasses of the biometric or passcode prompts that are meant to protect sensitive data.",
                    "sections": [
                        {
                            "title": "Bypassing with Frida",
                            "content": "<p>The most common vulnerability is when an application's code handles the result of a biometric check with a simple boolean. The code might call the Local Authentication framework, and if the user authenticates correctly, it gets back a `true` value. A good implementation will use the result to unlock a Keychain-backed key, but a lazy one will just use the boolean to grant access.</p><p>An attacker can use Frida to find and hook the application's method that receives this boolean result. The attacker can then simply change the implementation to always return `true`, tricking the application into thinking authentication was successful, even if it wasn't. This is a critical vulnerability that a manual code review and dynamic instrumentation can easily uncover.</p>",
                            "image": "https://images.unsplash.com/photo-1614064548237-02f8f17374b2?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "The most secure way for an application to use biometric authentication is to:", "options": ["Rely on a simple true/false return value from the authentication API", "Use the authentication event to unlock a cryptographic key stored in the secure Keychain", "Store the user's fingerprint in the app's local data", "Ask the user to enter their password instead"], "correct": 1, "explanation": "This cryptographic approach is much more secure because it cannot be easily bypassed by a simple Frida hook; the attacker would also need to be able to fake the result of the cryptographic operation, which they cannot do without the hardware-protected key." }
                    ]
                }
            },
            {
                "id": "lesson-18-session-management-testing",
                "title": "Lesson 18: Session Management Testing",
                "duration": "120 min",
                "objectives": [
                    "Assess how and where session tokens are stored (Keychain vs. UserDefaults)",
                    "Test for session timeout and proper invalidation on the client and server",
                    "Understand security risks when an app is backgrounded"
                ],
                "content": {
                    "overview": "This lesson provides a deep dive into session management for native iOS apps. We will explore how to test for secure token storage, proper session termination, and protection against session hijacking.",
                    "sections": [
                        {
                            "title": "Session Timeout and Backgrounding",
                            "content": "<p>An application that deals with sensitive data must have an inactivity timeout. If the user leaves the app in the foreground without touching it for a set period (e.g., 5 minutes), the app should automatically log them out and require them to re-authenticate. Similarly, when the user backgrounds the app (by switching to another app or the home screen), it should require re-authentication when it is brought back to the foreground. Testing this workflow is a key part of an iOS assessment. You can use Frida to manipulate the system clock to test long timeout periods quickly.</p>",
                            "image": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "A banking app that allows you to leave it open for 30 minutes, switch to another app, and then come back without requiring you to log in again is likely missing what security control?", "options": ["A session timeout and/or backgrounding protection", "Certificate pinning", "Jailbreak detection", "A strong password policy"], "correct": 0, "explanation": "Proper session timeout and re-authentication upon foregrounding are critical controls to prevent an unauthorized user from simply picking up a person's unlocked phone and accessing their sensitive applications." }
                    ]
                }
            },
            {
                "id": "lesson-19-data-protection-testing",
                "title": "Lesson 19: Data Protection Testing",
                "duration": "120 min",
                "objectives": [
                    "Understand the iOS Data Protection classes and how they are tied to the device passcode",
                    "Verify that an application is using the correct, most restrictive protection class for its files",
                    "Test for protection against screenshot and keyboard caching"
                ],
                "content": {
                    "overview": "iOS provides a powerful, hardware-accelerated file encryption system called Data Protection. This lesson covers how to test that an application is correctly leveraging this system to protect the data it writes to the file system.",
                    "sections": [
                        {
                            "title": "Data Protection Classes",
                            "content": "<p>When an application creates a file, it can assign it a 'protection class'. This class dictates when the file's per-file encryption key is available for decryption. The encryption key for the file is derived from a combination of a hardware key (burned into the device) and a key derived from the user's passcode.</p><h3>Key Classes:</h3><ul><li><strong>`NSFileProtectionComplete`:</strong> The highest level. The file is only accessible when the device is unlocked.</li><li><strong>`NSFileProtectionCompleteUnlessOpen`:</strong> An open file can continue to be accessed for a short time after the device is locked.</li><li><strong>`NSFileProtectionCompleteUntilFirstUserAuthentication`:</strong> The default for third-party apps. The file is accessible after the user unlocks the device for the first time after a boot, and remains accessible until the next reboot, even if the user locks their screen.</li></ul><p>A security tester must verify that an application handling highly sensitive data is using the `NSFileProtectionComplete` protection class for its files.</p>",
                            "image": "https://images.unsplash.com/photo-1542382156942-0268579cf259?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Checking a File's Data Protection Class (on device)",
                        "language": "bash",
                        "code": "# On a jailbroken device, you can use a tool like 'filedp' to check the\n# protection class of a specific file.\niPhone-Pro:~ root# filedp /path/to/app/container/Documents/secret.dat"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "To provide the strongest protection for a file at rest, an application should use which Data Protection class?", "options": ["No protection", "`NSFileProtectionComplete`", "`NSFileProtectionCompleteUntilFirstUserAuthentication`", "None"], "correct": 1, "explanation": "The `Complete` class ensures that the file is encrypted with a key protected by the user's passcode, and is completely inaccessible as soon as the device is locked." }
                    ]
                }
            },
            {
                "id": "lesson-20-ipc-url-scheme-testing",
                "title": "Lesson 20: IPC and URL Scheme Testing",
                "duration": "120 min",
                "objectives": [
                    "Test for security vulnerabilities in custom URL scheme handlers",
                    "Exploit insecure Universal Links and App Links implementations",
                    "Assess the security of data sharing via the Pasteboard and other IPC mechanisms"
                ],
                "content": {
                    "overview": "This lesson focuses on the attack surface created by the ways applications talk to each other on iOS. We will cover the security testing of custom URL schemes, which are a primary vector for Inter-Process Communication (IPC).",
                    "sections": [
                        {
                            "title": "Custom URL Scheme Security",
                            "content": "<p>An application can register a custom URL scheme (e.g., `mybankapp://`). When a user clicks a link with this scheme (e.g., in a browser or another app), iOS will launch the registered application and pass it the URL.</p><h3>The Vulnerability:</h3><p>The vulnerability occurs when the application blindly trusts the data and parameters within the URL. If `mybankapp://transfer?to=123&amount=100` can be triggered from a malicious webpage without any user confirmation within the banking app itself, an attacker could steal money. The application's URL scheme handler must treat the incoming URL as completely untrusted input and perform all necessary validation and user confirmation before taking any action.</p>",
                            "image": "https://images.unsplash.com/photo-1585250184288-5175908b083c?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Test a URL Scheme Handler from an SSH Shell",
                        "language": "bash",
                        "code": "# You can use the `uiopen` command on a jailbroken device to simulate clicking a link.\niPhone-Pro:~ root# uiopen mybankapp://transfer?to=badguy&amount=1000"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary security risk of deep links / custom URL schemes?", "options": ["They are too long", "The receiving application might insecurely trust the data passed in the URI, leading to vulnerabilities like XSS, authorization bypasses, or open redirects", "They require a special permission", "They only work on older iOS versions"], "correct": 1, "explanation": "A custom URL scheme is just another user-controlled input vector, and all data within it must be rigorously validated before use. The app must assume the URL could come from a malicious source." }
                    ]
                }
            },
            {
                "id": "lesson-21-ssl-tls",
                "title": "Lesson 21: SSL/TLS Implementation Testing",
                "duration": "120 min",
                "objectives": [
                    "Perform a thorough assessment of an application's SSL/TLS implementation and certificate validation",
                    "Bypass weak or improperly implemented certificate pinning using Frida",
                    "Review App Transport Security (ATS) configurations in the Info.plist",
                    "Test for weak cipher suites and other TLS configuration issues"
                ],
                "content": {
                    "overview": "This lesson is a deep dive into data-in-transit security for iOS apps. We will go beyond basic traffic interception to cover the common flaws in how applications implement SSL/TLS, the correct way to implement certificate pinning, and how to assess the crucial App Transport Security (ATS) settings.",
                    "sections": [
                        {
                            "title": "App Transport Security (ATS)",
                            "content": "<p>ATS is a system-level feature that enforces a set of security best practices for all network connections. By default, ATS requires that all connections use HTTPS with TLS 1.2+ and strong cipher suites. It is a critical, default-secure control.</p><h3>ATS Misconfigurations:</h3><p>Developers can add exceptions to the `Info.plist` file to disable ATS for specific domains or to allow insecure connections. A key part of an iOS security review is to audit the `NSAppTransportSecurity` dictionary in the `Info.plist` and scrutinize every exception. The presence of `NSAllowsArbitraryLoads` set to `true` is a major red flag, as it effectively disables ATS for the entire application, allowing it to make cleartext HTTP connections.</p>",
                            "image": "https://images.unsplash.com/photo-1544890225-2fde1e46f71b?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Highly Insecure ATS Configuration in Info.plist (XML)",
                        "language": "xml",
                        "code": "<key>NSAppTransportSecurity</key>\n<dict>\n    <!-- This globally disables ATS, which is a major security risk. -->\n    <key>NSAllowsArbitraryLoads</key>\n    <true/>\n</dict>"
                    },
                    {
                        "title": "Frida Script for SSL Pinning Bypass",
                        "language": "bash",
                        "code": "# Using a community script from the Frida CodeShare is the most efficient way.\n# This will attach to the target app and inject a script that hooks several\n# common certificate validation APIs and forces them to succeed.\n\nfrida --codeshare pc-psi/ios-ssl-pinning-bypass -U -f com.example.pinnedapp"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary function of App Transport Security (ATS)?", "options": ["To manage user passwords", "To enforce a set of secure defaults for network connections, such as requiring HTTPS and strong ciphers", "To scan for viruses", "To make the application smaller"], "correct": 1, "explanation": "ATS provides a strong, default-secure baseline for network security. A developer must explicitly justify any exceptions to disable it for specific domains." },
                        { "id": 2, "question": "You are unable to intercept an app's HTTPS traffic even after installing your proxy's CA certificate. What is the most likely cause?", "options": ["The app is not connecting to the internet", "The app is using certificate pinning", "Your proxy is configured incorrectly", "The internet is down"], "correct": 1, "explanation": "Certificate pinning is a specific defense against man-in-the-middle attacks from tools like Burp Suite, and bypassing it with a tool like Frida is a necessary step in the testing process." }
                    ]
                }
            },
            {
                "id": "lesson-22-api-assessment",
                "title": "Lesson 22: API Security Assessment",
                "duration": "120 min",
                "objectives": [
                    "Apply the OWASP API Security Top 10 to mobile backend APIs",
                    "Test for common vulnerabilities like BOLA, Mass Assignment, and Injection in the context of a mobile client",
                    "Understand how mobile-specific features can lead to new API vulnerabilities"
                ],
                "content": {
                    "overview": "The security of a mobile application is only as strong as the security of its backend APIs. This lesson focuses on using your interception proxy to test for common API vulnerabilities, which are often the root cause of mobile app security failures.",
                    "sections": [
                        {
                            "title": "Testing APIs with an Interception Proxy",
                            "content": "<p>Once you are successfully intercepting the application's traffic with Burp Suite, you can systematically test its backend APIs for the full spectrum of web vulnerabilities. The methodology is the same as for a traditional web application, but your attack vector is the mobile client. Use a tool like Burp Repeater to take a legitimate API request from the app, manipulate its parameters, and send it to the server to probe for vulnerabilities like:</p><ul><li><strong>A01 - Broken Object Level Authorization (BOLA/IDOR)</strong></li><li><strong>A02 - Broken Authentication</strong></li><li><strong>A03 - Broken Object Property Level Authorization (Mass Assignment)</strong></li><li><strong>A05 - Broken Function Level Authorization</strong></li><li><strong>A08 - Injection</strong></li></ul>",
                            "image": "https://images.unsplash.com/photo-1596003906915-013661138ae2?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Example of Testing for BOLA/IDOR in Burp Repeater",
                        "language": "http",
                        "code": "# 1. You capture a legitimate request from the app to view your own profile.\nGET /api/v2/users/12345/profile HTTP/1.1\nHost: api.mobileapp.com\nAuthorization: Bearer <your_jwt_token>\n\n# 2. In Burp Repeater, you modify the user ID and send the request.\n# If the server responds with the profile data for user 54321, it is vulnerable to BOLA.\nGET /api/v2/users/54321/profile HTTP/1.1\nHost: api.mobileapp.com\nAuthorization: Bearer <your_jwt_token>"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "True or False: A mobile app's backend APIs are not susceptible to traditional web vulnerabilities like SQL Injection or Broken Access Control.", "options": ["True", "False"], "correct": 1, "explanation": "False. An API is essentially a web application without a user interface. It is susceptible to the exact same categories of vulnerabilities as any other web application and must be tested just as rigorously." }
                    ]
                }
            },
            {
                "id": "lesson-23-webview-testing",
                "title": "Lesson 23: WebView Security Testing",
                "duration": "120 min",
                "objectives": [
                    "Perform a thorough security assessment of an application's `WKWebView` implementation",
                    "Exploit insecure JavaScript bridge interfaces to call native Swift/Objective-C code from JavaScript",
                    "Test for file access vulnerabilities and lack of URL validation within WebViews"
                ],
                "content": {
                    "overview": "`WKWebView` is the modern component for displaying web content within a native app. It is also a significant attack surface. An insecurely configured WebView can completely break the security boundary between the untrusted web and the trusted native application. This lesson covers how to find and exploit these flaws.",
                    "sections": [
                        {
                            "title": "The JavaScript Bridge Risk",
                            "content": "<p>A `WKScriptMessageHandler` allows a developer to create a 'bridge' that lets JavaScript in the WebView send messages to and invoke the native Swift or Objective-C code of the application. This is extremely dangerous if the WebView is also configured to load untrusted web content from the internet.</p><p>An attacker who finds an XSS vulnerability in the loaded web content could then use their XSS payload to call the exposed bridge functions. This could allow them to access native device features (like contacts or location), read the app's private files, or steal data from the app's native memory space, effectively escalating a simple web-based XSS into a full native compromise.</p>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Why is it dangerous to load untrusted web content into a WebView that also has a JavaScript bridge enabled?", "options": ["It can make the app slow", "An XSS vulnerability in the web content could be used to pivot and execute native application code, bypassing the sandbox", "It uses too much memory", "It drains the battery"], "correct": 1, "explanation": "The bridge creates a high-risk connection between the untrusted web world and the trusted native application code. If the web content can be compromised, that compromise can often be escalated to the native layer via the bridge." }
                    ]
                }
            },
            {
                "id": "lesson-24-push-notification",
                "title": "Lesson 24: Push Notification Security",
                "duration": "120 min",
                "objectives": [
                    "Assess the security of Apple Push Notification Service (APNS) implementations",
                    "Test for sensitive data leakage in notification content",
                    "Understand the security risks of background processing and silent push notifications"
                ],
                "content": {
                    "overview": "Push notifications are a key part of the mobile experience, but they can also be a source of data leakage if not handled correctly. This lesson covers the security assessment of an application's push notification implementation.",
                    "sections": [
                        {
                            "title": "Sensitive Data Leakage",
                            "content": "<p>The most common and critical vulnerability is the inclusion of sensitive data in a notification. The notification content (title, subtitle, and body) is displayed on the device's lock screen, making it visible to anyone with physical access to the device, even without unlocking it.</p><p>An app should **never** send sensitive data (like a one-time password, a full account balance, a tracking number, or the content of a private message) directly in the visible part of the push notification payload. Instead, it should send a generic message (e.g., 'You have a new message' or 'Your transaction is complete') that requires the user to unlock the device and open the app to view the sensitive content.</p>",
                            "image": "https://images.unsplash.com/photo-1585250184288-5175908b083c?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Insecure APNS Payload (JSON)",
                        "language": "json",
                        "code": "{\n    \"aps\": {\n        \"alert\": {\n            \"title\": \"Your One-Time Code\",\n            \"body\": \"Your login code is 123456. Do not share it.\"\n        }\n    }\n}"
                    },
                    {
                        "title": "Secure APNS Payload (JSON)",
                        "language": "json",
                        "code": "{\n    \"aps\": {\n        \"alert\": {\n            \"title\": \"New Login Code\",\n            \"body\": \"You have a new one-time login code. Tap to view.\"\n        }\n    }\n}"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary security risk of push notifications?", "options": ["They use too much battery", "They can leak sensitive information on the device's lock screen", "They are too slow", "They do not work on all devices"], "correct": 1, "explanation": "The lock screen is considered a public space. A well-designed application will never display PII or other sensitive data in a push notification payload that is rendered on the lock screen." }
                    ]
                }
            },
            {
                "id": "lesson-25-keychain-security",
                "title": "Lesson 25: Keychain Services Security",
                "duration": "150 min",
                "objectives": [
                    "Perform a deep-dive security assessment of an app's Keychain usage",
                    "Understand and verify the correct use of Keychain item accessibility attributes (`kSecAttrAccessible`)",
                    "Test Keychain Access Control Lists for correct configuration",
                    "Assess the security of inter-app Keychain sharing"
                ],
                "content": {
                    "overview": "This advanced lesson is dedicated to the single most important secure storage location on iOS: the Keychain. We will go beyond the basics to perform a thorough audit of how an application creates and configures its Keychain entries, which is a common source of subtle but critical vulnerabilities.",
                    "sections": [
                        {
                            "title": "Keychain Accessibility Attributes",
                            "content": "<p>The Keychain allows a developer to specify an accessibility attribute for each item it stores. This attribute dictates *when* the data can be decrypted and accessed. This is a critical security choice that many developers get wrong.</p><h3>The Classes:</h3><ul><li><strong>`kSecAttrAccessibleWhenUnlocked`:</strong> The data can be accessed only when the device is unlocked.</li><li><strong>`kSecAttrAccessibleAfterFirstUnlock`:</strong> The data becomes accessible the first time the user unlocks the device after a reboot, and it then **remains accessible** in a decrypted state in memory even if the user locks their phone again.</li><li><strong>`kSecAttrAccessibleWhenUnlockedThisDeviceOnly`:</strong> The same as `...WhenUnlocked`, but the item cannot be included in an encrypted backup and migrated to a new device.</li></ul><p>A major vulnerability is to store highly sensitive data (like a session token or private key) with the `...AfterFirstUnlock` attribute. This means an attacker who steals the phone could perform a file system acquisition (if an exploit exists) and would be able to decrypt and extract that Keychain item, even without knowing the user's passcode.</p>",
                            "image": "https://images.unsplash.com/photo-1599373922312-5b9340d8a5a5?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "To store a long-term session token in the Keychain with the highest level of security, which accessibility attribute should be used?", "options": ["`kSecAttrAccessibleAfterFirstUnlock`", "`kSecAttrAccessibleWhenUnlocked`", "`kSecAttrAccessibleAlways`", "No attribute"], "correct": 1, "explanation": "This attribute ensures that the Keychain item is encrypted with a key that is protected by the user's passcode, and is only decrypted and made available when the device is in the unlocked state." },
                        { "id": 2, "question": "Why is it risky to use the `kSecAttrAccessibleAfterFirstUnlock` attribute for a highly sensitive item like a password?", "options": ["It's not risky, it's the most secure option", "Because the item remains in a decrypted state in memory even when the phone is locked, making it accessible to a forensic attacker who can perform a file system acquisition", "It requires the user to enter their password twice", "It is deprecated"], "correct": 1, "explanation": "This is a subtle but critical configuration choice. The accessibility attribute must match the sensitivity of the data being protected. Long-lived secrets should always require the device to be unlocked for access." }
                    ]
                }
            },
            
            {
                "id": "lesson-26-secure-enclave",
                "title": "Lesson 26: Secure Enclave Testing",
                "duration": "120 min",
                "objectives": [
                    "Understand the architecture and function of the Secure Enclave",
                    "Analyze how an application interacts with the Secure Enclave for cryptographic operations",
                    "Verify that private keys are generated and stored non-exportably within the Secure Enclave",
                    "Recognize the high bar for attacking hardware-backed security"
                ],
                "content": {
                    "overview": "This lesson provides a dedicated look at the apex of iOS hardware security: the Secure Enclave. We will explore its role in protecting the most sensitive keys and biometric data, and how to verify that an application is using it correctly to provide the strongest possible cryptographic guarantees.",
                    "sections": [
                        {
                            "title": "Secure Enclave Functionality",
                            "content": "<p>The Secure Enclave is a hardware security module; a completely isolated, secure coprocessor. The main application processor cannot directly access its memory or storage.</p><h3>The Secure Workflow:</h3><ol><li>An application requests that the Secure Enclave generate a new, non-exportable private key.</li><li>The Secure Enclave generates the key pair. The private key material **never leaves the Secure Enclave hardware**.</li><li>The application is given a 'handle' or reference to this key.</li><li>When the application needs to perform a cryptographic operation (like signing a piece of data), it passes the data and the key handle to the Secure Enclave.</li><li>The Secure Enclave performs the signing operation internally using the protected key and returns the resulting signature to the application.</li></ol><p>This is extremely secure because the private key itself is never exposed to the main operating system, which could be compromised.</p>",
                            "image": "https://images.unsplash.com/photo-1593064390382-2c63824f5a83?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the key security guarantee provided by the Secure Enclave?", "options": ["It makes the application run faster", "Private key material generated within it is non-exportable and never exposed to the main application processor or OS", "It stores all user data", "It prevents all XSS attacks"], "correct": 1, "explanation": "This hardware-level isolation is the core principle of the Secure Enclave, providing the highest level of protection for cryptographic keys against software-based attacks." }
                    ]
                }
            },
            {
                "id": "lesson-27-ats",
                "title": "Lesson 27: App Transport Security (ATS)",
                "duration": "120 min",
                "objectives": [
                    "Perform a deep-dive security review of an application's ATS configuration in the `Info.plist`",
                    "Identify and assess the risk of broad ATS exceptions",
                    "Understand how to properly configure exceptions for specific domains"
                ],
                "content": {
                    "overview": "App Transport Security (ATS) is a crucial, system-level control for enforcing secure data-in-transit practices. This lesson focuses on how to perform a thorough audit of an application's ATS configuration to find common and dangerous misconfigurations.",
                    "sections": [
                        {
                            "title": "Auditing the `Info.plist`",
                            "content": "<p>All ATS configuration is done in the `NSAppTransportSecurity` dictionary within the app's `Info.plist` file. A security tester must meticulously review this section.</p><h3>Critical Misconfigurations:</h3><ul><li><strong>`NSAllowsArbitraryLoads`:</strong> If this key is set to `<true/>`, it completely disables ATS for the entire application, allowing it to make insecure HTTP connections anywhere. This is a major red flag and is almost always a high-severity vulnerability.</li><li><strong>Broad Domain Exceptions:</strong> A developer might create an exception for a domain but make it too broad. For example, allowing insecure connections to a third-party analytics domain might not seem risky, but an attacker who can perform a man-in-the-middle on that connection could potentially inject malicious content back into the app.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1544890225-2fde1e46f71b?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "You are reviewing an app's `Info.plist` and find the key `NSAllowsArbitraryLoads` set to true. What does this mean?", "options": ["The application is very secure", "The application has completely disabled App Transport Security, which is a major security risk", "The application can only connect to one website", "The application is using strong encryption"], "correct": 1, "explanation": "This key is a global override that turns off all of Apple's recommended network security protections, and its use is highly discouraged." }
                    ]
                }
            },
            {
                "id": "lesson-28-code-signing",
                "title": "Lesson 28: Code Signing and Provisioning",
                "duration": "120 min",
                "objectives": [
                    "Verify the integrity of an application's code signature",
                    "Analyze provisioning profiles to understand an application's entitlements",
                    "Recognize the risks of enterprise certificate abuse and ad-hoc distribution"
                ],
                "content": {
                    "overview": "Code signing is the foundation of platform integrity on iOS. The OS will not run an application unless it has a valid signature from a trusted source. This lesson covers how to analyze an app's signature and provisioning to verify its integrity and understand its capabilities.",
                    "sections": [
                        {
                            "title": "Code Signature and Entitlements",
                            "content": "<p>Every app is signed with a developer's certificate, which chains up to Apple's root CA. A Provisioning Profile links this signature to a specific application ID and a list of 'entitlements'. Entitlements are special privileges granted to an app, such as the ability to use push notifications, share data with a specific app group, or access the Keychain. A security reviewer must analyze the entitlements to understand the app's full capabilities and potential attack surface.</p>",
                            "image": "https://images.unsplash.com/photo-15428313T1-d531d209121f?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Special privileges granted to an application, such as the ability to share Keychain items with another app, are formally declared as what?", "options": ["Permissions", "Entitlements", "Features", "Settings"], "correct": 1, "explanation": "Entitlements are a critical part of the code signing and provisioning process that define what high-privilege APIs an application is allowed to access." }
                    ]
                }
            },
            {
                "id": "lesson-29-privacy-frameworks",
                "title": "Lesson 29: Privacy Framework Testing",
                "duration": "120 min",
                "objectives": [
                    "Test for correct implementation of privacy controls for Location, Photos, and Contacts",
                    "Verify that an app only accesses privacy-sensitive data after receiving user consent",
                    "Assess the risk of an app requesting overly broad permissions"
                ],
                "content": {
                    "overview": "Modern iOS has a very strong, user-centric privacy model. An app cannot access sensitive data without first prompting for and receiving explicit consent from the user. This lesson covers how to test that an application is correctly and respectfully using these privacy frameworks.",
                    "sections": [
                        {
                            "title": "Testing for Information Leaks",
                            "content": "<p>A key test is to see what the application does *before* the user grants permission. A well-behaved app should not attempt to access any location data before the user has approved the location permission prompt. An analyst can use Frida to hook the location APIs to see if they are being called prematurely. The `Info.plist` must also contain a clear `UsageDescription` string that honestly explains to the user *why* the application needs this permission.</p>",
                            "image": "https://images.unsplash.com/photo-1548092372-6a7e3206a5a2?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "A privacy-respecting application should only attempt to access a user's contacts:", "options": ["Whenever it wants", "Only after the user has explicitly granted the `Contacts` permission", "Once every day", "During a full moon"], "correct": 1, "explanation": "The runtime permission model is designed to ensure user control, and violating this flow is both a privacy and a security issue." }
                    ]
                }
            },
            {
                "id": "lesson-30-idfa-tracking",
                "title": "Lesson 30: IDFA and Tracking Prevention",
                "duration": "120 min",
                "objectives": [
                    "Understand the purpose of the Identifier for Advertisers (IDFA)",
                    "Test the implementation of the App Tracking Transparency (ATT) framework",
                    "Use dynamic analysis to detect prohibited cross-app tracking techniques"
                ],
                "content": {
                    "overview": "Apple has introduced strong new privacy controls to combat cross-app tracking. This lesson covers how to test an application's compliance with these new rules, which are a major focus for privacy regulators and security researchers.",
                    "sections": [
                        {
                            "title": "App Tracking Transparency (ATT)",
                            "content": "<p>The Identifier for Advertisers (IDFA) is a unique, resettable ID for each user's device that was traditionally used for tracking and ad targeting. With the introduction of ATT, an application is now **forbidden** from accessing the IDFA (or using any other information for the purpose of tracking the user across other apps and websites) unless the user first explicitly opts-in via a system prompt. A security tester must verify that an app respects the user's choice and does not attempt to access the IDFA if permission has been denied.</p>",
                            "image": "https://images.unsplash.com/photo-1614064548237-02f8f17374b2?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary function of the App Tracking Transparency (ATT) framework?", "options": ["To make tracking easier for advertisers", "To require applications to get explicit user consent before they can track them across other apps and websites using the IDFA", "To improve battery life", "To secure the device's keychain"], "correct": 1, "explanation": "ATT is a major privacy-enhancing feature that puts users in control of cross-app tracking." }
                    ]
                }
            },
            {
                "id": "lesson-31-health-payment",
                "title": "Lesson 31: Health and Payment Security",
                "duration": "120 min",
                "objectives": [
                    "Assess the security of applications that integrate with HealthKit",
                    "Test Apple Pay implementations for security flaws",
                    "Understand how to build HIPAA-compliant iOS applications"
                ],
                "content": {
                    "overview": "For applications that handle the most sensitive data—health and financial information—the security bar is even higher. This lesson covers the security and privacy testing of applications that integrate with Apple's HealthKit and Apple Pay frameworks.",
                    "sections": [
                        {
                            "title": "HealthKit Security",
                            "content": "<p>HealthKit is the central, encrypted repository for all health and fitness data on an iOS device. An application cannot access any HealthKit data without receiving granular, explicit permission from the user for each specific data type (e.g., permission to read heart rate is separate from permission to write workouts). A security assessment involves ensuring the app asks for the minimum required permissions and that it handles the sensitive PHI it receives in a HIPAA-compliant manner.</p>",
                            "image": "https://images.unsplash.com/photo-1538692125883-909953930b5e?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Access to HealthKit data is controlled by what mechanism?", "options": ["A single on/off switch", "A system of granular, user-controlled permissions for each individual data type", "The developer's certificate", "The application's `Info.plist` file"], "correct": 1, "explanation": "HealthKit's fine-grained permission model is designed to give users maximum control and transparency over their sensitive health data." }
                    ]
                }
            },
            {
                "id": "lesson-32-child-safety",
                "title": "Lesson 32: Child Safety and Parental Controls",
                "duration": "120 min",
                "objectives": [
                    "Assess an app's integration with the Screen Time API and other parental controls",
                    "Test content filtering mechanisms for bypasses",
                    "Evaluate the security and privacy of age verification systems"
                ],
                "content": {
                    "overview": "For applications targeted at children, there is a special set of security, privacy, and safety considerations. This lesson covers how to assess an application for compliance with child safety regulations and for the robustness of its parental control features.",
                    "sections": [
                        {
                            "title": "Screen Time and Content Filtering",
                            "content": "<p>A security assessment would test if the application correctly respects the restrictions set by a parent in the iOS Screen Time settings. For example, if a parent has restricted in-app purchases, can the app find a way to bypass this and initiate a purchase? Can the app's content filtering be easily bypassed by a clever child?</p>",
                            "image": "https://images.unsplash.com/photo-1543286386-2e659306cd6c?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Testing if an application respects the rules set in iOS's built-in parental controls is an example of what?", "options": ["Network security testing", "Child safety and compliance testing", "Database security testing", "Hardware security testing"], "correct": 1, "explanation": "This ensures the application is a good citizen within the platform's ecosystem of parental controls." }
                    ]
                }
            },
            {
                "id": "lesson-33-enterprise-app-security",
                "title": "Lesson 33: Enterprise App Security",
                "duration": "120 min",
                "objectives": [
                    "Understand how apps are distributed within an enterprise using Apple Business Manager",
                    "Identify the risks of custom, in-house app distribution",
                    "Assess the security of apps deployed via Enterprise Certificate"
                ],
                "content": {
                    "overview": "This lesson focuses on how applications are deployed and managed in a large corporate environment, covering the tools and processes that enterprises use for private app distribution.",
                    "sections": [
                        {
                            "title": "Enterprise Distribution Risks",
                            "content": "<p>The Apple Developer Enterprise Program allows a large organization to get a special certificate that they can use to sign and distribute their own in-house apps to their employees, completely outside of the public App Store. This is a high-value target for attackers. If an attacker can compromise this enterprise signing certificate, they can sign their own malicious apps that will be trusted and runnable on any employee's device within that organization.</p>",
                            "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary risk of an Apple Developer Enterprise certificate being compromised?", "options": ["It costs a lot of money", "An attacker could use it to sign their own malicious application, which would then be trusted by all devices within the enterprise", "The company can no longer publish apps to the public App Store", "It is not a risk"], "correct": 1, "explanation": "This certificate is the root of trust for all in-house applications, making its security absolutely critical." }
                    ]
                }
            },
            {
                "id": "lesson-34-mdm-testing",
                "title": "Lesson 34: Mobile Device Management Testing",
                "duration": "120 min",
                "objectives": [
                    "Assess the security of MDM configuration profiles",
                    "Test for the ability to bypass or remove MDM controls",
                    "Verify the effectiveness of remote management commands like device wipe"
                ],
                "content": {
                    "overview": "In a corporate environment, MDM solutions are the primary tool for securing devices. This lesson covers how to perform a security assessment of an MDM implementation, looking for weaknesses in the deployed policies and for ways a malicious user could bypass them.",
                    "sections": [
                        {
                            "title": "MDM Security Assessment",
                            "content": "<p>An assessment would involve reviewing the security policies being pushed to devices. Does the MDM enforce a strong device passcode? Does it enforce full-disk encryption (which is on by default but can be monitored)? Can it prevent users from installing unapproved applications? A key part of the test is to try and find ways to un-enroll a device from the MDM or to bypass its restrictions as a malicious insider might.</p>",
                            "image": "https://images.unsplash.com/photo-1544228943-8588824f19b2?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is a primary security function of an MDM solution?", "options": ["To make the phone run faster", "To enforce corporate security policies on mobile devices, such as requiring a passcode and encryption", "To give users root access", "To provide a mobile app store"], "correct": 1, "explanation": "MDM is a policy enforcement engine for mobile devices." }
                    ]
                }
            },
            {
                "id": "lesson-35-apple-configurator",
                "title": "Lesson 35: Apple Configurator Security",
                "duration": "120 min",
                "objectives": [
                    "Understand how Apple Configurator is used for large-scale device supervision and setup",
                    "Test the security of configurations and blueprints applied by Configurator",
                    "Assess the security of the device enrollment process"
                ],
                "content": {
                    "overview": "Apple Configurator is a tool that allows an administrator to manage a large number of company-owned devices. This lesson covers the security assessment of this mass-provisioning process.",
                    "sections": [
                        {
                            "title": "Device Supervision",
                            "content": "<p>When a device is 'supervised' (typically done during its initial setup), the administrator gains a much higher level of control over it than a standard MDM enrollment. A supervised device can have features completely disabled (like the camera or AirDrop), can have its proxy settings force-locked, and can have apps silently installed and removed. Testing involves verifying these restrictions are properly enforced and cannot be bypassed.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is a 'supervised' iOS device?", "options": ["A device that a user is watching", "A company-owned device that has been provisioned to allow a much higher level of administrative control", "A personal device", "A jailbroken device"], "correct": 1, "explanation": "Supervision is the key mechanism for enabling the advanced restriction policies needed for corporate-owned devices." }
                    ]
                }
            },
            {
                "id": "lesson-36-byod",
                "title": "Lesson 36: BYOD Security Testing",
                "duration": "120 min",
                "objectives": [
                    "Understand the User Enrollment model for BYOD in iOS",
                    "Test for data leakage between the personal and corporate personas",
                    "Assess the security of app-level VPN and other BYOD technologies"
                ],
                "content": {
                    "overview": "BYOD (Bring Your Own Device) presents the classic conflict between corporate security and user privacy. This lesson covers how to test Apple's modern solutions for this, which are designed to create a strong separation between work and personal data.",
                    "sections": [
                        {
                            "title": "User Enrollment and Data Separation",
                            "content": "<p>Modern iOS has a specific MDM enrollment mode for BYOD called 'User Enrollment'. This creates a separate, managed Apple ID and a separate APFS volume on the device for all corporate data. This provides a strong, cryptographically enforced separation between the user's personal data and the company's data. A security assessment would focus on testing this boundary. Can a personal app access data on the work volume? Can corporate DLP policies (like preventing copy/paste from a managed to an unmanaged app) be bypassed?</p>",
                            "image": "https://images.unsplash.com/photo-1544228943-8588824f19b2?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "The primary goal of iOS's 'User Enrollment' mode for BYOD is to:", "options": ["Give the company full control over the personal device", "Provide a strong, cryptographically-enforced separation between corporate data and personal data", "Make the device less secure", "Disable all security features"], "correct": 1, "explanation": "This allows the company to secure its data while preserving the privacy of the employee's personal information." }
                    ]
                }
            },
            {
                "id": "lesson-37-exploit-dev",
                "title": "Lesson 37: iOS Exploit Development",
                "duration": "180 min",
                "objectives": [
                    "Understand the basics of memory corruption vulnerabilities (e.g., buffer overflows) in a mobile context",
                    "Learn about exploit mitigation techniques like ASLR and DEP",
                    "Explore the basics of Return-Oriented Programming (ROP) for bypassing mitigations",
                    "Recognize the complexity and high value of sandbox escape exploits"
                ],
                "content": {
                    "overview": "This is an expert-level lesson that provides a high-level introduction to the world of iOS exploit development. We will explore how researchers find and exploit memory corruption vulnerabilities in the iOS operating system or its applications to achieve code execution.",
                    "sections": [
                        {
                            "title": "Sandbox Escapes",
                            "content": "<p>The ultimate goal for many iOS exploit chains is a sandbox escape. This typically requires chaining multiple vulnerabilities together. An attacker might first exploit a vulnerability in the browser's rendering engine to get code execution inside the sandboxed browser process. They will then need to find a *second* vulnerability, this time in the iOS kernel itself, which they can exploit from within the browser process to break out of the sandbox and gain privileged access to the underlying operating system. These are incredibly complex and valuable exploits.</p>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is a 'sandbox escape'?", "options": ["A feature of iOS", "An exploit that leverages a vulnerability (often in the kernel) to break out of the restrictive application sandbox", "A type of logging", "A way to make an app run faster"], "correct": 1, "explanation": "A sandbox escape is a critical compromise of the iOS security model, and vulnerabilities that allow for them are among the most highly sought after by security researchers and attackers." }
                    ]
                }
            },
            {
                "id": "lesson-38-privilege-escalation",
                "title": "Lesson 38: Privilege Escalation Testing",
                "duration": "120 min",
                "objectives": [
                    "Identify local privilege escalation vectors on a jailbroken device",
                    "Exploit kernel vulnerabilities to escalate to root",
                    "Abuse system services and entitlements for privilege escalation"
                ],
                "content": {
                    "overview": "This advanced lesson focuses on privilege escalation. We explore how an attacker who has already gained a low-privilege foothold on a device can then exploit vulnerabilities to escalate their privileges to the all-powerful root user.",
                    "sections": [
                        {
                            "title": "Kernel Exploitation",
                            "content": "<p>As discussed previously, the most powerful way to escalate privileges is to exploit a vulnerability in the kernel. The kernel runs with the highest level of privilege, so a successful kernel exploit will give the attacker's code the same level of privilege, effectively making them root.</p>",
                            "image": "https://images.unsplash.com/photo-1629654297299-c8506221ca97?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "The ultimate goal of most privilege escalation exploits on iOS is to gain the permissions of which user?", "options": ["mobile", "root", "admin", "guest"], "correct": 1, "explanation": "The 'root' user has complete and unrestricted access to the entire operating system, making it the final goal of a privilege escalation attack chain." }
                    ]
                }
            },
            {
                "id": "lesson-39-persistence",
                "title": "Lesson 39: Persistence Mechanism Analysis",
                "duration": "120 min",
                "objectives": [
                    "Identify common persistence techniques used by iOS malware and jailbreaks",
                    "Analyze Launch Daemons and other auto-start mechanisms",
                    "Test for URL scheme hijacking as a persistence method"
                ],
                "content": {
                    "overview": "How does an attacker or a jailbreak maintain its presence on a device after a reboot? This lesson covers the techniques used to achieve persistence on iOS.",
                    "sections": [
                        {
                            "title": "Launch Daemons",
                            "content": "<p>On iOS, a common way to have a program run automatically at boot with high privileges is to create a Launch Daemon. This is a specially formatted `.plist` file placed in the `/Library/LaunchDaemons/` directory. This directory is protected by the sandbox, so an attacker must have already gained root access to be able to write to it. A forensic analyst looking for persistence on a compromised device would always inspect the contents of this directory.</p>",
                            "image": "https://images.unsplash.com/photo-1498050108023-c5249f4df085?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary mechanism for achieving persistence (auto-starting a program at boot) on a jailbroken iOS device?", "options": ["Creating a custom wallpaper", "Creating and installing a Launch Daemon plist file", "Sending a push notification", "Using the calendar"], "correct": 1, "explanation": "Launch Daemons are the standard, system-level 'autostart' mechanism in both macOS and iOS." }
                    ]
                }
            },
            {
                "id": "lesson-40-anti-analysis-evasion",
                "title": "Lesson 40: Advanced Anti-Analysis Evasion",
                "duration": "120 min",
                "objectives": [
                    "Dynamically bypass jailbreak detection and debugger checks using Frida",
                    "Understand advanced code obfuscation techniques used in iOS apps",
                    "Test and bypass runtime application self-protection (RASP) solutions"
                ],
                "content": {
                    "overview": "This is a capstone lesson for dynamic analysis. It brings together all the advanced Frida techniques to show how a determined researcher can defeat the anti-analysis controls commonly found in high-security applications.",
                    "sections": [
                        {
                            "title": "Bypassing Jailbreak Detection with Frida",
                            "content": "<p>An application might check for the existence of files like `/bin/bash` or `/Applications/Cydia.app` to detect a jailbreak. As a researcher, you would:</p><ol><li>Use a disassembler to find the exact class and method in the app's code that performs these file checks.</li><li>Write a Frida script to hook this method.</li><li>In your hook's implementation, you simply return `false`, regardless of the method's original logic.</li></ol><p>This is the surgical, dynamic way to defeat these controls at runtime.</p>",
                            "image": "https://images.unsplash.com/photo-1614064548237-02f8f17374b2?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "If an application checks for jailbreak by looking for the file `/private/var/lib/cydia`, what would a Frida bypass script do?", "options": ["Delete the file", "Hook the file system API call (e.g., `fileExistsAtPath:`) that the app is using and force it to return `false` whenever it's called with that specific path", "Jailbreak the phone again", "Reboot the phone"], "correct": 1, "explanation": "This is the essence of runtime instrumentation. You are not changing the device or the application's code on disk; you are intercepting a specific function call in memory and changing its outcome." }
                    ]
                }
            },
            {
                "id": "lesson-41-iot-homekit-security",
                "title": "Lesson 41: IoT and HomeKit Security",
                "duration": "120 min",
                "objectives": [
                    "Assess the security of applications that integrate with the HomeKit framework",
                    "Test the security of the Bluetooth and Wi-Fi communication of smart home devices",
                    "Understand the security model of the HomeKit ecosystem"
                ],
                "content": {
                    "overview": "Apple's HomeKit provides a secure framework for smart home accessories. This lesson explores the security model of this IoT ecosystem and how to assess the security of the apps that control these devices.",
                    "sections": [
                        {
                            "title": "HomeKit Security",
                            "content": "<p>HomeKit is designed with security as a primary feature. All communication between your iOS device, your home hub (like an Apple TV), and the accessories is end-to-end encrypted. Accessories must have a special Apple-approved authentication coprocessor. This creates a high security bar for devices to be a part of the official HomeKit ecosystem.</p>",
                            "image": "https://images.unsplash.com/photo-1544890225-2fde1e46f71b?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is a key security feature of Apple's HomeKit framework?", "options": ["All communication is unencrypted", "It requires all devices to be on the public internet", "All communication between devices is end-to-end encrypted by default", "It only works with Android"], "correct": 2, "explanation": "Strong, default encryption and hardware-backed identity are core tenets of the HomeKit security architecture." }
                    ]
                }
            },
            {
                "id": "lesson-42-gaming-app-security",
                "title": "Lesson 42: Gaming Application Security",
                "duration": "120 min",
                "objectives": [
                    "Test the security of in-app purchase implementations for bypasses",
                    "Assess the security of game save data to prevent tampering",
                    "Understand and test anti-cheat mechanisms"
                ],
                "content": {
                    "overview": "Mobile gaming is a massive industry, and games have their own unique set of security challenges. This lesson covers how to assess the security of mobile games, with a focus on in-app purchases and anti-cheat.",
                    "sections": [
                        {
                            "title": "In-App Purchase Security",
                            "content": "<p>A common vulnerability is when the game client tells the game server that a purchase was successful. An attacker can use Frida or other tools to hook the part of the game's code that handles the purchase result and simply change the `false` to a `true`, tricking the game into unlocking the content for free. A secure implementation requires the game server to independently validate every single purchase receipt with Apple's or Google's servers. The client can never be trusted.</p>",
                            "image": "https://images.unsplash.com/photo-1593110022831-292911b3b194?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the correct way for a game server to validate an in-app purchase?", "options": ["Blindly trust the message from the game client", "The game server must independently validate the purchase receipt with the app store's (Apple/Google) backend servers", "Ask the player if they really paid", "Check the player's bank account"], "correct": 1, "explanation": "This server-to-server validation is the only secure method. Any client-side-only validation check can be trivially bypassed." }
                    ]
                }
            },
            {
                "id": "lesson-43-financial-app-security",
                "title": "Lesson 43: Financial Application Security",
                "duration": "120 min",
                "objectives": [
                    "Perform a security assessment of a mobile banking or fintech application",
                    "Test for compliance with standards like PCI DSS where applicable",
                    "Pay special attention to the security of authentication, session management, and cryptography"
                ],
                "content": {
                    "overview": "For financial applications, the security bar is at its absolute highest. A single vulnerability can lead to direct financial loss. This lesson covers the key areas of focus when assessing a high-security fintech application.",
                    "sections": [
                        {
                            "title": "Focus on Core Security",
                            "content": "<p>For a financial app, a tester must be absolutely rigorous in testing the core security controls:</p><ul><li>Can the biometric authentication be bypassed?</li><li>Is certificate pinning implemented correctly?</li><li>Are all session tokens stored in the Keychain with the strongest protection class?</li><li>Is there a strict session timeout?</li><li>Are there any business logic flaws in the funds transfer workflow?</li></ul>",
                            "image": "https://images.unsplash.com/photo-1556741533-4020f1b29a28?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "When testing a mobile banking app, which areas demand the most rigorous scrutiny?", "options": ["The color scheme and icon design", "The app's marketing page", "Authentication, session management, and cryptographic implementations", "The speed of the animations"], "correct": 2, "explanation": "These are the core security controls that protect the user's account and money. Flaws in these areas are almost always critical severity." }
                    ]
                }
            },
            {
                "id": "lesson-44-ar-security",
                "title": "Lesson 44: Augmented Reality Security",
                "duration": "120 min",
                "objectives": [
                    "Assess the security and privacy of applications using ARKit",
                    "Test for abuse of camera and location permissions",
                    "Understand the risks of manipulation of AR content"
                ],
                "content": {
                    "overview": "Augmented Reality (AR) applications introduce new and interesting privacy and security considerations. This lesson explores the attack surface of AR apps built with Apple's ARKit.",
                    "sections": [
                        {
                            "title": "Privacy and Data Risks",
                            "content": "<p>AR applications have access to a very rich stream of data from the device's sensors, most notably the camera, but also the IMU (for motion) and potentially LiDAR (for depth). The primary risk is a privacy violation. A malicious or compromised AR app could covertly record video or audio, or could build a detailed 3D map of the user's private environment (like the inside of their house). A security and privacy assessment must focus on ensuring the app only uses this data for its intended purpose and does not exfiltrate it.</p>",
                            "image": "https://images.unsplash.com/photo-1614064548237-02f8f17374b2?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is a primary security and privacy concern for an AR application?", "options": ["It uses too much battery", "The potential for the app to misuse its access to the device's camera and other sensors to violate a user's privacy", "It might not work in the dark", "It can make users dizzy"], "correct": 1, "explanation": "AR apps, by their nature, require access to a very rich and sensitive set of sensor data, making the protection of this data the paramount security concern." }
                    ]
                }
            },
            {
                "id": "lesson-45-ios-testing-automation",
                "title": "Lesson 45: iOS Security Testing Automation",
                "duration": "120 min",
                "objectives": [
                    "Use Apple's XCUITest framework to automate security checks",
                    "Integrate automated vulnerability scanning into a CI/CD pipeline for iOS",
                    "Leverage cloud-based device farms for large-scale automated testing"
                ],
                "content": {
                    "overview": "While many deep tests require a manual approach, some security checks can and should be automated. This DevSecOps-focused lesson covers how to build automated security tests into an iOS CI/CD pipeline.",
                    "sections": [
                        {
                            "title": "Automating Security Checks",
                            "content": "<p>You can write UI tests using XCUITest that specifically check for security features. For example, you can write a test that logs in, backgrounds the app, waits 5 minutes, then foregrounds the app and asserts that the login screen is now visible. If this test fails, it means your session timeout is broken. These security-focused UI tests can be run automatically as part of your CI/CD pipeline on every single build.</p>",
                            "image": "https://images.unsplash.com/photo-1498050108023-c5249f4df085?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary benefit of automating security tests in an iOS CI/CD pipeline?", "options": ["It replaces the need for manual testing", "It allows you to continuously check for regressions in your key security controls on every build", "It makes the app build faster", "It makes the app smaller"], "correct": 1, "explanation": "This automation provides a continuous safety net, ensuring that a developer doesn't accidentally introduce a bug that breaks a critical security feature like session timeout or certificate pinning." }
                    ]
                }
            },
            {
                "id": "lesson-46-custom-testing-tools",
                "title": "Lesson 46: Custom Testing Tool Development",
                "duration": "120 min",
                "objectives": [
                    "Develop custom Frida scripts to automate the bypass of common security controls",
                    "Write LLDB scripts to automate debugging tasks",
                    "Create a framework of reusable scripts to accelerate your assessments"
                ],
                "content": {
                    "overview": "To scale your assessments and handle complex, repetitive tasks, you need to build your own tools. This lesson is a workshop on creating a personal toolkit of Frida and LLDB scripts to automate the most common and tedious parts of an iOS security test.",
                    "sections": [
                        {
                            "title": "Building Your Frida Toolkit",
                            "content": "<p>A professional iOS tester will build up a library of reusable Frida scripts over time. You might have a generic script for bypassing certificate pinning, another for bypassing jailbreak detection, and a script to dump all the data from an app's Keychain. Having these pre-built, reusable tools makes the initial phase of any assessment much faster, allowing you to quickly get to the deeper, application-specific analysis.</p>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary benefit of building your own toolkit of reusable Frida scripts?", "options": ["It is required to pass this course", "It dramatically increases the speed and efficiency of your assessments by automating common, repetitive tasks like bypassing certificate pinning", "It allows you to sell your scripts to other testers", "It is the only way to use Frida"], "correct": 1, "explanation": "Automation is a force multiplier. A well-built toolkit allows a tester to spend more of their time on the complex, unique logic of the application rather than on re-solving the same common problems for every engagement." }
                    ]
                }
            },
            {
                "id": "lesson-47-ml-security",
                "title": "Lesson 47: Machine Learning Security Testing on iOS",
                "duration": "120 min",
                "objectives": [
                    "Assess the security of applications using Apple's Core ML framework",
                    "Test for on-device AI security vulnerabilities",
                    "Understand the risks of model extraction from an IPA"
                ],
                "content": {
                    "overview": "Apple's Core ML framework makes it easy for developers to integrate trained machine learning models directly into their applications for on-device inference. This lesson covers the security assessment of these models.",
                    "sections": [
                        {
                            "title": "Model Protection",
                            "content": "<p>Your trained ML model is a valuable piece of intellectual property. The compiled model is stored as a `.mlmodelc` file within your app's bundle. A key concern is protecting this model from extraction. A reverse engineer can find this file, extract it, and potentially steal your proprietary model. Core ML provides features for encrypting the model on disk, which is a key security control to assess.</p>",
                            "image": "https://images.unsplash.com/photo-1620712943543-959bab121695?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "When assessing an app that uses Core ML, what is a primary security concern?", "options": ["The speed of the model's inference", "Protecting the proprietary ML model from being extracted from the app package by a reverse engineer", "The size of the model", "The color of the app's icon"], "correct": 1, "explanation": "For many companies, their ML model is their competitive advantage. Protecting this intellectual property is a key security goal." }
                    ]
                }
            },
            {
                "id": "lesson-48-cloud-integration-security",
                "title": "Lesson 48: Cloud Integration Security (iCloud)",
                "duration": "120 min",
                "objectives": [
                    "Test for vulnerabilities in how an application uses iCloud and CloudKit",
                    "Assess the security of data synchronization and backup to iCloud",
                    "Understand the privacy implications of cloud integration"
                ],
                "content": {
                    "overview": "Many iOS applications sync their data to Apple's iCloud. This lesson covers how to assess the security and privacy of this cloud integration.",
                    "sections": [
                        {
                            "title": "CloudKit Security",
                            "content": "<p>CloudKit is the Apple framework for syncing data to iCloud. It has a robust security model with a public database, a shared database, and a private database for each user. An assessment involves testing the access control rules for the public and shared databases to ensure that one user cannot read or write data they are not supposed to. It's conceptually similar to testing a web application's API, but the rules are specific to CloudKit.</p>",
                            "image": "https://images.unsplash.com/photo-1498050108023-c5249f4df085?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "The primary security concern when an app syncs data to a shared or public iCloud database is:", "options": ["The speed of the sync", "Broken access control, where one user might be able to access another user's data", "The cost of the storage", "The app's battery usage"], "correct": 1, "explanation": "Just like with a traditional web API, ensuring proper data segregation and authorization is the key security challenge in a multi-user cloud backend." }
                    ]
                }
            },
            {
                "id": "lesson-49-ios-assessment-methodology",
                "title": "Lesson 49: Professional iOS Assessment Methodology",
                "duration": "120 min",
                "objectives": [
                    "Develop a professional, repeatable framework for testing any iOS application based on the OWASP MASVS",
                    "Manage client engagements and define a clear scope of work",
                    "Write a professional, high-quality mobile penetration test report"
                ],
                "content": {
                    "overview": "This capstone preparation lesson brings everything together into a professional methodology. You will learn how to approach any application as a professional pentester, combining automated and manual techniques into a repeatable process that ensures thorough coverage and high-quality results for a client engagement.",
                    "sections": [
                        {
                            "title": "The Assessment Workflow",
                            "content": "<ol><li><strong>Scoping and Reconnaissance:</strong> Understand the application and define the scope with the client.</li><li><strong>Static Analysis:</strong> Get the IPA file, decrypt it, and perform a full static analysis (MobSF, `class-dump`, code review) to map the attack surface.</li><li><strong>Dynamic Analysis:</strong> Set up the application on your jailbroken device. Systematically test each piece of functionality: bypass client-side controls with Frida, analyze network traffic with Burp, test the backend APIs, and check for insecure data storage.</li><li><strong>Reporting:</strong> Document all findings in a professional report with clear, actionable remediation guidance.</li></ol>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the industry-standard guide for structuring a mobile security assessment?", "options": ["The iOS Human Interface Guidelines", "The OWASP Mobile Application Security Verification Standard (MASVS)", "The Swift programming language book", "The Apple App Store review guidelines"], "correct": 1, "explanation": "The MASVS provides a clear, comprehensive, and industry-accepted framework for what to test and how to structure an assessment." }
                    ]
                }
            },
            {
                "id": "lesson-50-final-capstone-project",
                "title": "Lesson 50: Final Capstone Project",
                "duration": "240 min",
                "objectives": [
                    "Conduct a comprehensive, end-to-end security assessment of a complex iOS application",
                    "Chain multiple vulnerabilities together to demonstrate maximum impact, such as full account takeover",
                    "Produce a professional-grade, enterprise-ready penetration test report with strategic recommendations"
                ],
                "content": {
                    "overview": "The final capstone is a comprehensive, master's level assessment that requires you to synthesize every skill learned in this program. You will be given a complex, multi-functional vulnerable iOS application. Your mission is to perform a full security assessment from start to finish, identify and chain multiple vulnerabilities to achieve a critical business impact, and produce a professional report suitable for a major enterprise client.",
                    "sections": [
                        {
                            "title": "The Master's Level Assessment",
                            "content": "<p><strong>The Task:</strong> You are the lead mobile penetration tester hired to assess a new mobile social networking application. The application has features for private messaging, photo sharing, and profile management. It uses a REST API backend and has some features implemented in native code.</p><h3>Your Mission:</h3><ol><li><strong>Static Analysis & Reversing:</strong> Get a decrypted IPA. Perform a full static analysis to map the attack surface, including dumping the class headers and reversing a key native library.</li><li><strong>Dynamic Analysis:</strong> Set up the app on your jailbroken device. Your goal is to chain at least three vulnerabilities to achieve a full account takeover. For example, bypass certificate pinning to find a BOLA/IDOR vulnerability in the API that allows you to get a user's password reset token, and then exploit a logic flaw in the reset process.</li><li><strong>Reporting:</strong> Produce a single, comprehensive penetration test report that details all your findings, provides a narrative for your attack chain, and offers a prioritized, strategic remediation plan.</li></ol>",
                            "image": "https://images.unsplash.com/photo-1498050108023-c5249f4df085?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 100,
                    "questions": [
                        { "id": 1, "question": "The capstone project assesses your ability to:", "options": ["Run a single automated scan", "Answer multiple choice questions", "Synthesize knowledge from the entire course to conduct a comprehensive, multi-faceted, professional-grade security assessment of a realistic iOS application", "Write a simple 'hello world' application"], "correct": 2, "explanation": "This project is the ultimate test of your practical skills, requiring you to apply your full knowledge base to solve a complex, multi-stage security engagement, just as you would in a real-world professional assessment." }
                    ]
                }
            }
        ]
        }
      // =====================================================
      // GLOBAL VARIABLES
      // =====================================================
      let currentUser = null;
      let currentLessonIndex = 0;
      let courseProgress = {};
      let userStats = {};
      let quizState = {
        currentQuestion: 0,
        answers: [],
        score: 0,
        isComplete: false,
      };

      // Enhanced session tracking
      let courseSession = {
        startTime: null,
        totalStudyTime: 0,
        lessonsStarted: 0,
        lessonsCompleted: 0,
        pageLoadTime: new Date(),
        interactionCount: 0,
        lastActivityTime: new Date(),
      };

      // Music Player Variables
      let audioPlayer = new Audio();

      // Achievement notification system
      let notificationQueue = [];
      let isShowingNotification = false;

      // =====================================================
      // INITIALIZATION
      // =====================================================
      document.addEventListener("DOMContentLoaded", async () => {
        try {
          showLoadingScreen();
          await checkAuth();

          if (currentUser) {
            // Initialize session tracking
            startCourseSession();

            // Load course data and progress
            await loadCourseData();
            await loadUserProfile();
            await loadProgress();

            // Initialize UI
            initializeEventListeners();
            renderSidebar();
            loadLesson(currentLessonIndex);

            // Initialize additional features
            initMusicPlayer();
            addMusicIndicator();
            initializeActivityTracking();

            hideLoadingScreen();
          } else {
            openAuthModal();
          }
        } catch (error) {
          console.error("Error initializing course:", error);
          hideLoadingScreen();
          showToast("Failed to initialize course system", "error");
        }
      });

      // =====================================================
      // AUTHENTICATION SYSTEM
      // =====================================================
      async function checkAuth() {
        try {
          const {
            data: { session },
            error,
          } = await supabase.auth.getSession();

          if (error) {
            console.error("Auth error:", error);
            currentUser = null;
            openAuthModal();
            return;
          }

          if (!session) {
            currentUser = null;
            openAuthModal();
            return;
          }

          currentUser = session.user;
          updateUIWithUser();
        } catch (error) {
          console.error("Error checking auth:", error);
          currentUser = null;
          openAuthModal();
        }
      }

      function updateUIWithUser() {
        if (!currentUser) return;

        const name =
          currentUser.user_metadata?.full_name ||
          currentUser.email.split("@")[0];
        const userElements = document.querySelectorAll("[data-user-name]");
        userElements.forEach((el) => (el.textContent = name));
      }

      // =====================================================
      // USER PROFILE & STATS MANAGEMENT
      // =====================================================
      async function loadUserProfile() {
        try {
          // 🔍 Step 1: Try to fetch existing profile
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("*")
            .eq("id", currentUser.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (!profile) {
            // 🆕 Step 2: Create new profile if missing
            await createUserProfile();
          } else {
            // ✅ Step 3: Use existing profile
            userStats = profile;
            await updateLastActivity();
          }
        } catch (error) {
          console.error("❌ Error loading user profile:", error);
          showToast("Failed to load user profile", "error");
        }
      }
      async function createUserProfile() {
        try {
          const newProfile = {
            id: currentUser.id,
            full_name: currentUser.user_metadata?.full_name || "",
            email: currentUser.email,
            level: "Script Kiddie",
            total_points: 0,
            completed_courses: 0,
            current_streak: 0,
            total_certificates: 0,
            total_achievements: 0,
            sections_visited: 0,
            bonus_points: 0,
            in_progress_courses: 0,
            settings_changed: 0,
            midnight_sessions: 0,
            early_sessions: 0,
            weekend_sessions: 0,
            last_activity: new Date().toISOString(),
            created_at: new Date().toISOString(),
          };

          const { error } = await supabase
            .from("profiles")
            .insert([newProfile]);

          if (!error) {
            userStats = newProfile;
            // Award first login achievement
            setTimeout(() => checkAndUnlockAchievement("first_login"), 1000);
          }
        } catch (error) {
          console.error("Error creating user profile:", error);
        }
      }

      async function updateLastActivity() {
        try {
          const now = new Date();

          // Update activity tracking
          courseSession.lastActivityTime = now;

          // Update database
          await supabase
            .from("profiles")
            .update({
              last_activity: now.toISOString(),
            })
            .eq("id", currentUser.id);

          // Check time-based achievements
          await checkTimeBasedAchievements(now);
        } catch (error) {
          console.error("Error updating last activity:", error);
        }
      }

      // =====================================================
      // COURSE SESSION MANAGEMENT
      // =====================================================
      function startCourseSession() {
        courseSession.startTime = new Date();
        courseSession.pageLoadTime = new Date();

        logUserActivity("course_session_start", {
          course_id: COURSE_DATA.id,
          course_title: COURSE_DATA.title,
          user_agent: navigator.userAgent,
          screen_resolution: `${screen.width}x${screen.height}`,
        });

        // Check daily streak
        checkDailyStreak();
      }

      function initializeActivityTracking() {
        // Track page focus/blur for accurate study time
        document.addEventListener("visibilitychange", handleVisibilityChange);

        // Track user interactions
        ["click", "keydown", "scroll", "mousemove"].forEach((event) => {
          document.addEventListener(event, trackUserInteraction, {
            passive: true,
          });
        });

        // Periodic activity updates
        setInterval(updateStudyTime, 60000); // Every minute

        // Save session data before page unload
        window.addEventListener("beforeunload", saveSessionData);
      }

      function handleVisibilityChange() {
        if (document.hidden) {
          courseSession.lastActivityTime = new Date();
        } else {
          // Page became visible again - update activity
          updateLastActivity();
        }
      }

      function trackUserInteraction() {
        courseSession.interactionCount++;
        courseSession.lastActivityTime = new Date();

        // Throttle activity updates
        if (courseSession.interactionCount % 50 === 0) {
          updateLastActivity();
        }
      }

      function updateStudyTime() {
        if (!courseSession.startTime || document.hidden) return;

        const now = new Date();
        const sessionDuration = now - courseSession.startTime;
        courseSession.totalStudyTime = Math.floor(sessionDuration / 1000 / 60); // in minutes

        // Update progress with study time
        saveProgress();
      }

      function saveSessionData() {
        if (!currentUser || !courseSession.startTime) return;

        const sessionData = {
          user_id: currentUser.id,
          course_id: COURSE_DATA.id,
          session_duration: courseSession.totalStudyTime,
          lessons_viewed: courseSession.lessonsStarted,
          lessons_completed: courseSession.lessonsCompleted,
          interactions: courseSession.interactionCount,
          session_date: courseSession.startTime.toISOString().split("T")[0],
        };

        // Store in localStorage as backup
        localStorage.setItem(
          "course_session_backup",
          JSON.stringify(sessionData)
        );

        // Try to save to database
        logUserActivity("course_session_end", sessionData);
      }

      // =====================================================
      // COURSE DATA & PROGRESS MANAGEMENT
      // =====================================================
      async function loadCourseData() {
        try {
          // Update course info in UI
          document.getElementById("courseTitle").textContent =
            COURSE_DATA.title;
          document.getElementById("totalLessons").textContent =
            COURSE_DATA.lessons.length;

          // Log course access
          logUserActivity("course_access", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
          });
        } catch (error) {
          console.error("Error loading course data:", error);
        }
      }

      async function loadProgress() {
        try {
          // Get existing progress from database
          const { data, error } = await supabase
            .from("course_progress")
            .select("*")
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (data) {
            courseProgress = JSON.parse(data.lesson_progress || "{}");
            currentLessonIndex = data.current_lesson || 0;

            // Update session tracking
            courseSession.lessonsStarted = Object.keys(courseProgress).length;
            courseSession.lessonsCompleted = Object.values(
              courseProgress
            ).filter((p) => p.completed).length;
          } else {
            // Initialize new progress
            courseProgress = {};
            currentLessonIndex = 0;
            await saveProgress();

            // Award first course start achievement
            await checkAndUnlockAchievement("first_course_start");
          }

          updateProgressDisplay();
        } catch (error) {
          console.error("Error loading progress:", error);
          showToast("Failed to load progress", "error");
        }
      }

      async function saveProgress() {
        try {
          if (!currentUser) return;

          const now = new Date();
          const progressData = {
            user_id: currentUser.id,
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            current_lesson: currentLessonIndex,
            lesson_progress: JSON.stringify(courseProgress),
            progress: calculateOverallProgress(),
            lessons_completed: getCompletedLessonsCount(),
            lessons_started: Object.keys(courseProgress).length,
            study_time_minutes: courseSession.totalStudyTime,
            last_accessed: now.toISOString(),
            updated_at: now.toISOString(),
          };

          // Upsert progress
          const { error } = await supabase
            .from("course_progress")
            .upsert([progressData]);

          if (error) throw error;

          // Update user stats
          await updateUserStats();

          updateProgressDisplay();
        } catch (error) {
          console.error("Error saving progress:", error);
          showToast("Failed to save progress", "error");
        }
      }

      async function updateUserStats() {
        try {
          // Get all course progress for this user
          const { data: allProgress, error } = await supabase
            .from("course_progress")
            .select("progress, course_id, study_time_minutes")
            .eq("user_id", currentUser.id);

          if (error) throw error;

          // Calculate stats
          const completedCourses =
            allProgress?.filter((p) => p.progress >= 100).length || 0;
          const inProgressCourses =
            allProgress?.filter((p) => p.progress > 0 && p.progress < 100)
              .length || 0;
          const totalStudyTime =
            allProgress?.reduce(
              (sum, p) => sum + (p.study_time_minutes || 0),
              0
            ) || 0;

          // Calculate points (500 per completed course + achievement points)
          const coursePoints = completedCourses * 500;
          const bonusPoints = userStats.bonus_points || 0;
          const totalPoints = coursePoints + bonusPoints;

          // Update profile
          const updateData = {
            completed_courses: completedCourses,
            in_progress_courses: inProgressCourses,
            total_points: totalPoints,
            total_study_time: totalStudyTime,
            last_activity: new Date().toISOString(),
          };

          const { error: updateError } = await supabase
            .from("profiles")
            .update(updateData)
            .eq("id", currentUser.id);

          if (updateError) throw updateError;

          // Update local stats
          Object.assign(userStats, updateData);
        } catch (error) {
          console.error("Error updating user stats:", error);
        }
      }

      function calculateOverallProgress() {
        const completedLessons = getCompletedLessonsCount();
        return Math.round(
          (completedLessons / COURSE_DATA.lessons.length) * 100
        );
      }

      function getCompletedLessonsCount() {
        return Object.values(courseProgress).filter(
          (lesson) => lesson.completed
        ).length;
      }

      function updateProgressDisplay() {
        const completedCount = getCompletedLessonsCount();
        const progressPercent = calculateOverallProgress();

        // Update UI elements
        const elements = {
          completedLessons: completedCount,
          courseProgressPercent: `${progressPercent}%`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });

        // Update progress bar
        const progressBar = document.getElementById("courseProgressFill");
        if (progressBar) progressBar.style.width = `${progressPercent}%`;
      }

      // =====================================================
      // LESSON MANAGEMENT
      // =====================================================
      function loadLesson(index) {
        if (index < 0 || index >= COURSE_DATA.lessons.length) return;

        const lesson = COURSE_DATA.lessons[index];
        currentLessonIndex = index;

        // Mark lesson as started and track activity
        if (!courseProgress[lesson.id]) {
          courseProgress[lesson.id] = {
            started: true,
            completed: false,
            startedAt: new Date().toISOString(),
            timeSpent: 0,
          };

          courseSession.lessonsStarted++;
          saveProgress();

          // Log lesson start
          logUserActivity("lesson_start", {
            lesson_id: lesson.id,
            lesson_title: lesson.title,
            lesson_index: index,
          });
        }

        // Update lesson start time for time tracking
        courseProgress[lesson.id].currentSessionStart = new Date();

        // Update sidebar and navigation
        renderSidebar();
        updateNavigationButtons();

        // Update header info
        updateLessonHeader(lesson, index);

        // Render lesson content
        renderLessonContent(lesson);

        // Smooth scroll and animations
        window.scrollTo({ top: 0, behavior: "smooth" });
        document.getElementById("contentBody").scrollTop = 0;

        const contentBody = document.getElementById("contentBody");
        contentBody.classList.add("fade-in");
        setTimeout(() => contentBody.classList.remove("fade-in"), 500);

        // Check lesson-based achievements
        checkLessonAchievements(index + 1);
      }

      function updateLessonHeader(lesson, index) {
        const elements = {
          currentLessonNumber: index + 1,
          currentLessonTitle: lesson.title,
          navInfo: `Lesson ${index + 1} of ${COURSE_DATA.lessons.length}`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });
      }

      function renderSidebar() {
        const lessonNav = document.getElementById("lessonNav");
        if (!lessonNav) return;

        lessonNav.innerHTML = "";

        COURSE_DATA.lessons.forEach((lesson, index) => {
          const lessonItem = document.createElement("div");
          lessonItem.className = "lesson-item";

          // Determine lesson status
          const lessonProgress = courseProgress[lesson.id];
          const isCompleted = lessonProgress?.completed || false;
          const isInProgress = lessonProgress?.started || false;
          const isLocked = !isCompleted && !canAccessLesson(index);
          const isActive = index === currentLessonIndex;

          // Apply status classes
          if (isCompleted) lessonItem.classList.add("completed");
          if (isLocked) lessonItem.classList.add("locked");
          if (isActive) lessonItem.classList.add("active");

          // Determine status display
          let statusClass = "not-started";
          let statusIcon = index + 1;

          if (isCompleted) {
            statusClass = "completed";
            statusIcon = "✓";
          } else if (isInProgress) {
            statusClass = "in-progress";
            statusIcon = "◐";
          }

          // Create lesson item HTML
          lessonItem.innerHTML = `
            <div class="lesson-status ${statusClass}">${statusIcon}</div>
            <div class="lesson-info">
                <div class="lesson-title">${lesson.title}</div>
                <div class="lesson-meta">
                    ${
                      isCompleted
                        ? "Completed"
                        : isInProgress
                        ? "In Progress"
                        : isLocked
                        ? "Locked"
                        : "Not Started"
                    }
                </div>
            </div>
            <div class="lesson-duration">${lesson.duration}</div>
        `;

          // Add click handler if not locked
          if (!isLocked) {
            lessonItem.addEventListener("click", () => {
              if (index !== currentLessonIndex) {
                // Track lesson time before switching
                trackLessonTime();

                currentLessonIndex = index;
                loadLesson(index);
                closeSidebar();
              }
            });
          }

          lessonNav.appendChild(lessonItem);
        });
      }

      function canAccessLesson(index) {
        if (index === 0) return true; // First lesson always accessible

        // Can access if previous lesson is completed
        const previousLessonId = COURSE_DATA.lessons[index - 1].id;
        return courseProgress[previousLessonId]?.completed || false;
      }

      function trackLessonTime() {
        const currentLesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonProgress = courseProgress[currentLesson.id];

        if (lessonProgress?.currentSessionStart) {
          const sessionTime = Math.floor(
            (new Date() - new Date(lessonProgress.currentSessionStart)) /
              1000 /
              60
          );
          lessonProgress.timeSpent =
            (lessonProgress.timeSpent || 0) + sessionTime;
          delete lessonProgress.currentSessionStart;
        }
      }

      // =====================================================
      // LESSON CONTENT RENDERING
      // =====================================================
      function renderLessonContent(lesson) {
        const contentContainer = document.getElementById("lessonContent");
        if (!contentContainer) return;

        let contentHTML = `
        <div class="content-section">
            <h2>Learning Objectives</h2>
            <ul>
                ${lesson.objectives.map((obj) => `<li>${obj}</li>`).join("")}
            </ul>
        </div>
        
        <div class="content-section">
            <h2>Overview</h2>
            <p>${lesson.content.overview}</p>
        </div>
    `;

        // Render content sections
        lesson.content.sections.forEach((section) => {
          contentHTML += `
            <div class="content-section">
                <h2>${section.title}</h2>
                ${section.content}
                ${
                  section.image
                    ? `<img src="${section.image}" alt="${section.title}" class="content-image" loading="lazy">`
                    : ""
                }
            </div>
        `;
        });

        // Render code examples
        if (
          lesson.content.codeExamples &&
          lesson.content.codeExamples.length > 0
        ) {
          contentHTML += `<div class="content-section"><h2>Code Examples</h2></div>`;

          lesson.content.codeExamples.forEach((example, index) => {
            const codeId = `code-${lesson.id}-${index}`;
            contentHTML += `
                <div class="code-section">
                    <div class="code-header">
                        <span class="code-title">${example.title}</span>
                        <button class="copy-btn" onclick="copyCode('${codeId}')">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <pre class="code-block"><code id="${codeId}" class="language-${
              example.language
            }">${escapeHtml(example.code)}</code></pre>
                </div>
            `;
          });
        }

        // Render quiz
        contentHTML += renderQuiz(lesson.quiz);

        contentContainer.innerHTML = contentHTML;

        // Highlight code syntax if Prism is available
        setTimeout(() => {
          if (window.Prism) {
            Prism.highlightAll();
          }
        }, 100);
      }

      // =====================================================
      // QUIZ SYSTEM
      // =====================================================
      function renderQuiz(quiz) {
        const currentLessonProgress =
          courseProgress[COURSE_DATA.lessons[currentLessonIndex].id];
        const isCompleted = currentLessonProgress?.completed || false;

        let quizHTML = `
        <div class="quiz-section" id="quizSection">
            <div class="quiz-header">
                <h2 class="quiz-title">
                    <i class="fas fa-clipboard-check"></i>
                    Knowledge Check
                </h2>
                <p class="quiz-info">
                    Complete this quiz with ${quiz.passingScore}% or higher to unlock the next lesson.
                </p>
            </div>
    `;

        if (isCompleted) {
          const savedScore = currentLessonProgress.quizScore || 0;
          quizHTML += `
            <div class="quiz-results show">
                <div class="quiz-score pass">${savedScore}%</div>
                <div class="quiz-message">
                    <strong>Lesson Completed!</strong><br>
                    You've successfully passed this lesson's quiz.
                </div>
            </div>
        `;
        } else {
          // Render quiz questions
          quiz.questions.forEach((question, qIndex) => {
            quizHTML += `
                <div class="quiz-question ${
                  qIndex === 0 ? "active" : ""
                }" data-question="${qIndex}">
                    <div class="question-header">
                        <span class="question-number">Question ${
                          qIndex + 1
                        }</span>
                        <span class="question-progress">${qIndex + 1}/${
              quiz.questions.length
            }</span>
                    </div>
                    <div class="question-text">${question.question}</div>
                    <div class="question-options">
                        ${question.options
                          .map(
                            (option, oIndex) => `
                            <div class="option" data-option="${oIndex}" onclick="selectOption(${qIndex}, ${oIndex})">
                                <span class="option-letter">${String.fromCharCode(
                                  65 + oIndex
                                )}</span>
                                <span class="option-text">${option}</span>
                            </div>
                        `
                          )
                          .join("")}
                    </div>
                </div>
            `;
          });

          quizHTML += `
            <div class="quiz-controls">
                <button class="btn btn-secondary" id="prevQuestionBtn" onclick="previousQuestion()" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <div>
                    <button class="btn btn-secondary" id="nextQuestionBtn" onclick="nextQuestion()" disabled>
                        Next
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <button class="btn btn-primary" id="submitQuizBtn" onclick="submitQuiz()" style="display: none;">
                        <i class="fas fa-check"></i>
                        Submit Quiz
                    </button>
                </div>
            </div>

            <div class="quiz-results" id="quizResults">
                <div class="quiz-score" id="quizScore">0%</div>
                <div class="quiz-message" id="quizMessage"></div>
                <div class="quiz-actions">
                    <button class="btn btn-primary" id="continueBtn" onclick="completeLesson()" style="display: none;">
                        <i class="fas fa-arrow-right"></i>
                        Continue to Next Lesson
                    </button>
                    <button class="btn btn-secondary" onclick="retakeQuiz()">
                        <i class="fas fa-redo"></i>
                        Retake Quiz
                    </button>
                </div>
            </div>
        `;
        }

        quizHTML += "</div>";
        return quizHTML;
      }

      // Quiz interaction functions
      function selectOption(questionIndex, optionIndex) {
        // Clear previous selections
        document
          .querySelectorAll(`[data-question="${questionIndex}"] .option`)
          .forEach((opt) => {
            opt.classList.remove("selected");
          });

        // Select current option
        const selectedOption = document.querySelector(
          `[data-question="${questionIndex}"] [data-option="${optionIndex}"]`
        );
        selectedOption.classList.add("selected");

        // Store answer
        quizState.answers[questionIndex] = optionIndex;

        // Update navigation
        const isLastQuestion =
          questionIndex ===
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length - 1;
        if (isLastQuestion) {
          document.getElementById("submitQuizBtn").style.display =
            "inline-flex";
          document.getElementById("nextQuestionBtn").style.display = "none";
        } else {
          document.getElementById("nextQuestionBtn").disabled = false;
        }
      }

      function nextQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const nextQuestionEl = currentQuestionEl.nextElementSibling;

        if (
          nextQuestionEl &&
          nextQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          nextQuestionEl.classList.add("active");
          quizState.currentQuestion++;
          updateQuizNavigation();
        }
      }

      function previousQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const prevQuestionEl = currentQuestionEl.previousElementSibling;

        if (
          prevQuestionEl &&
          prevQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          prevQuestionEl.classList.add("active");
          quizState.currentQuestion--;
          updateQuizNavigation();
        }
      }

      function updateQuizNavigation() {
        const totalQuestions =
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length;
        const prevBtn = document.getElementById("prevQuestionBtn");
        const nextBtn = document.getElementById("nextQuestionBtn");
        const submitBtn = document.getElementById("submitQuizBtn");

        prevBtn.disabled = quizState.currentQuestion === 0;

        const hasAnswer =
          quizState.answers[quizState.currentQuestion] !== undefined;
        const isLastQuestion = quizState.currentQuestion === totalQuestions - 1;

        if (isLastQuestion) {
          nextBtn.style.display = "none";
          submitBtn.style.display = hasAnswer ? "inline-flex" : "none";
        } else {
          nextBtn.style.display = "inline-flex";
          nextBtn.disabled = !hasAnswer;
          submitBtn.style.display = "none";
        }
      }

      async function submitQuiz() {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const quiz = lesson.quiz;
        let correctAnswers = 0;

        // Hide questions and controls
        document
          .querySelectorAll(".quiz-question")
          .forEach((q) => (q.style.display = "none"));
        document.querySelector(".quiz-controls").style.display = "none";

        // Calculate score and highlight answers
        quiz.questions.forEach((question, index) => {
          const userAnswer = quizState.answers[index];
          const correctAnswer = question.correct;
          const isCorrect = userAnswer === correctAnswer;

          if (isCorrect) correctAnswers++;

          // Highlight answers
          const questionEl = document.querySelector(
            `[data-question="${index}"]`
          );
          const options = questionEl.querySelectorAll(".option");

          options[correctAnswer].classList.add("correct");
          if (userAnswer !== correctAnswer && userAnswer !== undefined) {
            options[userAnswer].classList.add("incorrect");
          }
        });

        const score = Math.round(
          (correctAnswers / quiz.questions.length) * 100
        );
        const passed = score >= quiz.passingScore;

        // Update quiz results UI
        const quizScore = document.getElementById("quizScore");
        const quizMessage = document.getElementById("quizMessage");
        const quizActions = document.querySelector(".quiz-actions");

        quizScore.textContent = `${score}%`;
        quizScore.className = `quiz-score ${passed ? "pass" : "fail"}`;

        if (passed) {
          quizMessage.innerHTML = `
            <strong>Congratulations!</strong><br>
            You passed with ${score}%. You can now proceed to the next lesson.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-primary" onclick="completeLesson()">
                <i class="fas fa-arrow-right"></i>
                Continue to Next Lesson
            </button>
        `;

          // Mark lesson as completed
          await markLessonComplete(score);
        } else {
          quizMessage.innerHTML = `
            <strong>Not quite there yet.</strong><br>
            You scored ${score}%. You need ${quiz.passingScore}% to pass. Review the material and try again.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-secondary" onclick="retakeQuiz()">
                <i class="fas fa-redo"></i>
                Retake Quiz
            </button>
        `;
        }

        document.getElementById("quizResults").classList.add("show");

        // Log quiz completion
        logUserActivity("quiz_completed", {
          lesson_id: lesson.id,
          lesson_title: lesson.title,
          score: score,
          passed: passed,
          attempts: (courseProgress[lesson.id]?.quizAttempts || 0) + 1,
        });

        // Scroll to results
        document
          .getElementById("quizResults")
          .scrollIntoView({ behavior: "smooth" });
      }

      function retakeQuiz() {
        // Reset quiz state
        quizState = {
          currentQuestion: 0,
          answers: [],
          score: 0,
          isComplete: false,
        };

        // Track quiz retry
        const lessonId = COURSE_DATA.lessons[currentLessonIndex].id;
        if (!courseProgress[lessonId]) courseProgress[lessonId] = {};
        courseProgress[lessonId].quizAttempts =
          (courseProgress[lessonId].quizAttempts || 0) + 1;

        // Reload lesson content
        loadLesson(currentLessonIndex);

        // Scroll to quiz
        setTimeout(() => {
          document
            .getElementById("quizSection")
            .scrollIntoView({ behavior: "smooth" });
        }, 500);
      }

      async function markLessonComplete(score) {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonId = lesson.id;

        // Track lesson completion time
        trackLessonTime();

        // Update lesson progress
        courseProgress[lessonId] = {
          ...courseProgress[lessonId],
          completed: true,
          quizScore: score,
          completedAt: new Date().toISOString(),
          finalScore: score,
        };

        // Update session tracking
        courseSession.lessonsCompleted++;

        // Save progress to database
        await saveProgress();

        // Update UI
        renderSidebar();
        updateNavigationButtons();

        // Check various achievements
        await checkLessonCompletionAchievements();
        await checkPerfectScoreAchievements(score);
        await checkStudyTimeAchievements();

        // Log lesson completion
        logUserActivity("lesson_completed", {
          lesson_id: lessonId,
          lesson_title: lesson.title,
          final_score: score,
          time_spent: courseProgress[lessonId].timeSpent || 0,
          lesson_number: currentLessonIndex + 1,
        });

        showToast("Lesson completed successfully!", "success");
      }

      async function completeLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          // Move to next lesson
          currentLessonIndex++;
          loadLesson(currentLessonIndex);
        } else {
          // Course completion
          await completeCourse();
        }
      }

      async function completeCourse() {
        try {
          const completionTime = courseSession.totalStudyTime;

          // Update course progress to 100% completed
          await supabase
            .from("course_progress")
            .update({
              progress: 100,
              completed_at: new Date().toISOString(),
              completion_time_minutes: completionTime,
            })
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Award course completion achievements
          await checkAndUnlockAchievement("course_completion_1");
          await checkSpeedCompletionAchievements(completionTime);
          await checkCourseStreakAchievements();

          // Update user stats
          await updateUserStats();

          // Show completion message
          showToast(
            "Congratulations! Course completed successfully!",
            "certificate"
          );

          // Log course completion
          logUserActivity("course_completed", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            completion_time_minutes: completionTime,
            total_lessons: COURSE_DATA.lessons.length,
            average_quiz_score: calculateAverageQuizScore(),
          });

          // Redirect to dashboard after delay
          setTimeout(() => {
            window.location.href = "/dashboard.html";
          }, 3000);
        } catch (error) {
          console.error("Error completing course:", error);
          showToast("Error marking course as complete", "error");
        }
      }

      // =====================================================
      // ACHIEVEMENT INTEGRATION SYSTEM
      // =====================================================
      async function checkAndUnlockAchievement(
        achievementId,
        skipNotification = false
      ) {
        try {
          // Prevent duplicate checks
          const cacheKey = `achievement_${achievementId}_${currentUser.id}`;
          if (sessionStorage.getItem(cacheKey)) return false;

          // Check if already unlocked
          const { data: existing, error } = await supabase
            .from("user_achievements")
            .select("id")
            .eq("user_id", currentUser.id)
            .eq("achievement_id", achievementId)
            .single();

          if (existing) {
            sessionStorage.setItem(cacheKey, "true");
            return false;
          }

          // Award achievement
          const achievementData = {
            user_id: currentUser.id,
            achievement_id: achievementId,
            unlocked_at: new Date().toISOString(),
            points_awarded: getAchievementPoints(achievementId),
            context: "course_system",
          };

          const { data, error: insertError } = await supabase
            .from("user_achievements")
            .insert([achievementData])
            .select()
            .single();

          if (insertError) {
            if (insertError.code === "23505") return false; // Already exists
            throw insertError;
          }

          // Update user points
          await supabase.rpc('increment_user_stats', {
  user_id_param: currentUser.id,
  points_to_add: achievementData.points_awarded,
  achievements_to_add: 1
});

          // Cache and queue notification
          sessionStorage.setItem(cacheKey, "true");

          if (!skipNotification) {
            queueAchievementNotification({
              id: achievementId,
              name: getAchievementName(achievementId),
              description: getAchievementDescription(achievementId),
              points: achievementData.points_awarded,
              rarity: getAchievementRarity(achievementId),
              icon: getAchievementIcon(achievementId),
            });
          }

          return true;
        } catch (error) {
          console.error("Error unlocking achievement:", error);
          return false;
        }
      }

      // Helper functions for achievement data (replace with your actual achievement definitions)
      function getAchievementPoints(id) {
        const pointsMap = {
          first_course_start: 75,
          first_lesson: 100,
          course_completion_1: 500,
          perfect_score: 250,
          speed_demon: 750,
          marathon_learner: 500,
          night_owl: 200,
          early_bird: 200,
          weekend_warrior: 150,
          // Add more as needed
        };
        return pointsMap[id] || 100;
      }

      function getAchievementName(id) {
        const nameMap = {
          first_course_start: "Learning Initiated",
          first_lesson: "First Steps",
          course_completion_1: "Course Conqueror",
          perfect_score: "Perfectionist",
          speed_demon: "Speed Demon",
          // Add more as needed
        };
        return nameMap[id] || "Achievement Unlocked";
      }

      function getAchievementDescription(id) {
        const descMap = {
          first_course_start: "Start your first cybersecurity course",
          first_lesson: "Complete your first lesson",
          course_completion_1: "Complete your first course",
          perfect_score: "Score 100% on any quiz",
          speed_demon: "Complete a course in under 2 hours",
          // Add more as needed
        };
        return descMap[id] || "Achievement description";
      }

      function getAchievementRarity(id) {
        const rarityMap = {
          first_course_start: "common",
          first_lesson: "bronze",
          course_completion_1: "silver",
          perfect_score: "gold",
          speed_demon: "legendary",
          // Add more as needed
        };
        return rarityMap[id] || "common";
      }

      function getAchievementIcon(id) {
        const iconMap = {
          first_course_start: "fas fa-play",
          first_lesson: "fas fa-baby",
          course_completion_1: "fas fa-trophy",
          perfect_score: "fas fa-star",
          speed_demon: "fas fa-rocket",
          // Add more as needed
        };
        return iconMap[id] || "fas fa-award";
      }

      async function checkLessonAchievements(lessonNumber) {
        if (lessonNumber === 1) {
          await checkAndUnlockAchievement("first_lesson");
        }

        // Check if user has completed multiple lessons in one day
        const today = new Date().toISOString().split("T")[0];
        const todayCompletions = Object.values(courseProgress).filter(
          (p) => p.completed && p.completedAt?.startsWith(today)
        ).length;

        if (todayCompletions >= 3) {
          await checkAndUnlockAchievement("lesson_marathon");
        }
      }

      async function checkLessonCompletionAchievements() {
        const completedCount = getCompletedLessonsCount();

        // Lesson-based achievements
        const lessonMilestones = [1, 5, 10, 25, 50, 100];
        for (const milestone of lessonMilestones) {
          if (completedCount >= milestone) {
            await checkAndUnlockAchievement(`lessons_${milestone}`);
          }
        }

        // Course completion achievements
        if (completedCount === COURSE_DATA.lessons.length) {
          await checkAndUnlockAchievement("course_completion_1");

          // Check for additional course completion achievements
          const { data: allCourses } = await supabase
            .from("course_progress")
            .select("course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100);

          const totalCompleted = allCourses?.length || 0;

          const courseMilestones = [1, 5, 10, 25];
          for (const milestone of courseMilestones) {
            if (totalCompleted >= milestone) {
              await checkAndUnlockAchievement(`course_completion_${milestone}`);
            }
          }
        }
      }

      async function checkPerfectScoreAchievements(score) {
        if (score === 100) {
          await checkAndUnlockAchievement("perfect_score");

          // Check for consecutive perfect scores
          const recentScores = Object.values(courseProgress)
            .filter((p) => p.completed && p.quizScore)
            .slice(-5) // Last 5 completed
            .map((p) => p.quizScore);

          if (
            recentScores.length >= 3 &&
            recentScores.every((s) => s === 100)
          ) {
            await checkAndUnlockAchievement("perfectionist_streak");
          }
        }
      }

      async function checkSpeedCompletionAchievements(completionTime) {
        // Speed demon: Complete course in under 2 hours (120 minutes)
        if (completionTime <= 120) {
          await checkAndUnlockAchievement("speed_demon");
        }

        // Quick learner: Complete course in under 4 hours (240 minutes)
        if (completionTime <= 240) {
          await checkAndUnlockAchievement("quick_learner");
        }
      }

      async function checkStudyTimeAchievements() {
        const totalTime = courseSession.totalStudyTime;

        // Marathon learner: Study for 8+ hours in a course session
        if (totalTime >= 480) {
          // 8 hours
          await checkAndUnlockAchievement("marathon_learner");
        }

        // Dedicated learner: Study for 4+ hours
        if (totalTime >= 240) {
          // 4 hours
          await checkAndUnlockAchievement("dedicated_learner");
        }
      }

      async function checkCourseStreakAchievements() {
        try {
          // Check for consecutive course completions
          const { data: recentCourses, error } = await supabase
            .from("course_progress")
            .select("completed_at, course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100)
            .order("completed_at", { ascending: false })
            .limit(10);

          if (error || !recentCourses) return;

          // Check for courses completed on consecutive days
          let consecutiveDays = 1;
          for (let i = 1; i < recentCourses.length; i++) {
            const prevDate = new Date(
              recentCourses[i - 1].completed_at
            ).toDateString();
            const currentDate = new Date(
              recentCourses[i].completed_at
            ).toDateString();
            const dayDiff =
              Math.abs(new Date(prevDate) - new Date(currentDate)) /
              (1000 * 60 * 60 * 24);

            if (dayDiff <= 1) {
              consecutiveDays++;
            } else {
              break;
            }
          }

          if (consecutiveDays >= 3) {
            await checkAndUnlockAchievement("learning_streak");
          }
        } catch (error) {
          console.error("Error checking course streak achievements:", error);
        }
      }

      // =====================================================
      // TIME-BASED ACHIEVEMENTS
      // =====================================================
      async function checkTimeBasedAchievements(timestamp) {
        const hour = timestamp.getHours();
        const dayOfWeek = timestamp.getDay();

        // Night owl (after midnight, before 6 AM)
        if (hour >= 0 && hour < 6) {
          await incrementTimeBasedCounter("midnight_sessions", "night_owl");
        }

        // Early bird (4 AM to 6 AM)
        if (hour >= 4 && hour < 6) {
          await incrementTimeBasedCounter("early_sessions", "early_bird");
        }

        // Weekend warrior (Saturday = 6, Sunday = 0)
        if (dayOfWeek === 0 || dayOfWeek === 6) {
          await incrementTimeBasedCounter(
            "weekend_sessions",
            "weekend_warrior"
          );
        }
      }

      async function incrementTimeBasedCounter(counterType, achievementId) {
        try {
          const dateStr = new Date().toISOString().split("T")[0];
          const cacheKey = `${counterType}_${currentUser.id}_${dateStr}`;

          // Prevent multiple increments per day
          if (sessionStorage.getItem(cacheKey)) return;

          // Update counter
          await supabase
            .from("profiles")
            .update({
              [counterType]: supabase.sql`${counterType} + 1`,
            })
            .eq("id", currentUser.id);

          // Cache to prevent double counting
          sessionStorage.setItem(cacheKey, "true");

          // Check related achievement
          if (achievementId) {
            await checkAndUnlockAchievement(achievementId, true);
          }
        } catch (error) {
          console.error(`Error incrementing ${counterType}:`, error);
        }
      }

      async function checkDailyStreak() {
        try {
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("last_activity, current_streak, last_streak_date")
            .eq("id", currentUser.id)
            .single();

          if (error) throw error;

          const now = new Date();
          const today = now.toDateString();
          const lastActivity = profile.last_activity
            ? new Date(profile.last_activity)
            : null;
          const lastStreakDate = profile.last_streak_date
            ? new Date(profile.last_streak_date).toDateString()
            : null;

          let newStreak = profile.current_streak || 0;
          let shouldUpdateStreak = false;

          if (!lastActivity) {
            // First time user
            newStreak = 1;
            shouldUpdateStreak = true;
          } else {
            const daysSinceLastActivity = Math.floor(
              (now - lastActivity) / (1000 * 60 * 60 * 24)
            );

            if (lastStreakDate === today) {
              // Already counted today's streak
              return newStreak;
            } else if (
              daysSinceLastActivity === 1 ||
              (daysSinceLastActivity === 0 && lastStreakDate !== today)
            ) {
              // Consecutive day or same day but not counted yet
              newStreak += 1;
              shouldUpdateStreak = true;
            } else if (daysSinceLastActivity > 1) {
              // Streak broken
              newStreak = 1;
              shouldUpdateStreak = true;
            }
          }

          if (shouldUpdateStreak) {
            await supabase
              .from("profiles")
              .update({
                current_streak: newStreak,
                last_activity: now.toISOString(),
                last_streak_date: now.toISOString(),
              })
              .eq("id", currentUser.id);

            userStats.current_streak = newStreak;

            showToast(`Daily streak: ${newStreak} days!`, "success");
            await checkStreakAchievements(newStreak);
          }

          return newStreak;
        } catch (error) {
          console.error("Error checking daily streak:", error);
          return 0;
        }
      }

      async function checkStreakAchievements(currentStreak) {
        const streakMilestones = [3, 7, 14, 30, 100, 365];

        for (const milestone of streakMilestones) {
          if (currentStreak >= milestone) {
            await checkAndUnlockAchievement(`streak_${milestone}`);
          }
        }
      }

      // =====================================================
      // USER ACTIVITY LOGGING
      // =====================================================
      async function logUserActivity(activityType, metadata = {}) {
        try {
          const now = new Date();

          const activityData = {
            user_id: currentUser.id,
            activity_type: activityType,
            timestamp: now.toISOString(),
            course_id: COURSE_DATA.id,
            lesson_index: currentLessonIndex,
            session_duration: courseSession.totalStudyTime,
            metadata: JSON.stringify(metadata),
            created_at: now.toISOString(),
          };

          // Try to log to activities table
          const { error } = await supabase
            .from("user_activities")
            .insert([activityData]);

          if (error && error.code !== "42P01") {
            console.warn("Activity logging failed:", error.message);
          }

          // Always update last activity in profile
          await supabase
            .from("profiles")
            .update({ last_activity: now.toISOString() })
            .eq("id", currentUser.id);
        } catch (error) {
          console.error("Error logging user activity:", error);
        }
      }

      // =====================================================
      // NAVIGATION SYSTEM
      // =====================================================
      function updateNavigationButtons() {
        const prevBtn = document.getElementById("prevLessonBtn");
        const nextBtn = document.getElementById("nextLessonBtn");

        if (!prevBtn || !nextBtn) return;

        // Previous button
        prevBtn.disabled = currentLessonIndex === 0;

        // Next button logic
        const isLastLesson =
          currentLessonIndex === COURSE_DATA.lessons.length - 1;
        const canGoNext =
          currentLessonIndex < COURSE_DATA.lessons.length - 1 &&
          canAccessLesson(currentLessonIndex + 1);

        if (isLastLesson) {
          const isCurrentCompleted =
            courseProgress[COURSE_DATA.lessons[currentLessonIndex].id]
              ?.completed;
          nextBtn.disabled = !isCurrentCompleted;
          nextBtn.innerHTML = '<i class="fas fa-trophy"></i> Complete Course';
        } else {
          nextBtn.disabled = !canGoNext;
          nextBtn.innerHTML = 'Next <i class="fas fa-chevron-right"></i>';
        }
      }

      // Navigation button event handlers
      function goToPreviousLesson() {
        if (currentLessonIndex > 0) {
          trackLessonTime(); // Track time spent on current lesson
          currentLessonIndex--;
          loadLesson(currentLessonIndex);
        }
      }

      function goToNextLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          const canGoNext = canAccessLesson(currentLessonIndex + 1);
          if (canGoNext) {
            trackLessonTime();
            currentLessonIndex++;
            loadLesson(currentLessonIndex);
          } else {
            showToast("Complete the current lesson quiz to proceed", "warning");
          }
        } else {
          // Complete course
          completeCourse();
        }
      }

      // =====================================================
      // SIDEBAR FUNCTIONS
      // =====================================================
      function toggleSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.toggle("open");
        if (overlay) overlay.classList.toggle("active");
      }

      function closeSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.remove("open");
        if (overlay) overlay.classList.remove("active");
      }

      // =====================================================
      // ACHIEVEMENT NOTIFICATION SYSTEM
      // =====================================================
      function queueAchievementNotification(achievement) {
        notificationQueue.push(achievement);
        processNotificationQueue();
      }

      function processNotificationQueue() {
        if (isShowingNotification || notificationQueue.length === 0) return;

        isShowingNotification = true;
        const achievement = notificationQueue.shift();
        showAchievementNotification(achievement);

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          isShowingNotification = false;
          processNotificationQueue();
        }, duration + 500);
      }

      function showAchievementNotification(achievement) {
        const notification = document.getElementById("achievementNotification");
        if (!notification) return;

        const icon = document.getElementById("notificationIcon");
        const title = document.getElementById("notificationTitle");
        const description = document.getElementById("notificationDescription");
        const points = document.getElementById("notificationPoints");

        if (icon) {
          icon.innerHTML = `<i class="${achievement.icon}"></i>`;
          icon.className = `notification-icon ${achievement.rarity}`;
        }
        if (title) title.textContent = achievement.name;
        if (description) description.textContent = achievement.description;
        if (points) points.textContent = `+${achievement.points} Points`;

        notification.className = `achievement-notification ${achievement.rarity}`;
        notification.classList.add("show");

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          notification.classList.remove("show");
        }, duration);
      }

      // =====================================================
      // UTILITY FUNCTIONS
      // =====================================================
      function calculateAverageQuizScore() {
        const scores = Object.values(courseProgress)
          .filter((p) => p.completed && p.quizScore)
          .map((p) => p.quizScore);

        if (scores.length === 0) return 0;
        return Math.round(
          scores.reduce((sum, score) => sum + score, 0) / scores.length
        );
      }

      async function resetProgress() {
        if (
          !confirm(
            "Are you sure you want to reset your progress? This action cannot be undone."
          )
        ) {
          return;
        }

        try {
          // Track lesson time before reset
          trackLessonTime();

          // Reset local state
          courseProgress = {};
          currentLessonIndex = 0;
          courseSession = {
            startTime: new Date(),
            totalStudyTime: 0,
            lessonsStarted: 0,
            lessonsCompleted: 0,
            pageLoadTime: new Date(),
            interactionCount: 0,
            lastActivityTime: new Date(),
          };

          // Delete from database
          await supabase
            .from("course_progress")
            .delete()
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Log reset activity
          logUserActivity("progress_reset", {
            course_id: COURSE_DATA.id,
            reset_reason: "manual",
          });

          // Reinitialize
          await saveProgress();
          renderSidebar();
          loadLesson(0);

          showToast("Progress reset successfully", "success");
        } catch (error) {
          console.error("Error resetting progress:", error);
          showToast("Failed to reset progress", "error");
        }
      }

      function copyCode(codeId) {
        const codeElement = document.getElementById(codeId);
        if (!codeElement) return;

        const text = codeElement.textContent;

        navigator.clipboard
          .writeText(text)
          .then(() => {
            showToast("Code copied to clipboard!", "success");

            // Track code copy for achievements
            logUserActivity("code_copied", {
              code_section: codeId,
              lesson_id: COURSE_DATA.lessons[currentLessonIndex].id,
            });
          })
          .catch((err) => {
            console.error("Failed to copy code:", err);
            showToast("Failed to copy code", "error");

            // Fallback for older browsers
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            try {
              document.execCommand("copy");
              showToast("Code copied to clipboard!", "success");
            } catch (fallbackError) {
              showToast(
                "Copy failed - please select and copy manually",
                "error"
              );
            }
            document.body.removeChild(textArea);
          });
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // =====================================================
      // UI FEEDBACK SYSTEMS
      // =====================================================
      function showToast(message, type = "success") {
        const toast = document.getElementById("toast");
        const messageEl = document.getElementById("toastMessage");

        if (!toast || !messageEl) {
          console.log(`Toast: ${message} (${type})`);
          return;
        }

        messageEl.textContent = message;
        toast.className = `toast ${type} show`;

        setTimeout(() => {
          toast.classList.remove("show");
        }, 4000);
      }

      function showLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) loadingScreen.classList.remove("hidden");
      }

      function hideLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) {
          setTimeout(() => {
            loadingScreen.classList.add("hidden");
          }, 1000);
        }
      }

      // =====================================================
      // MUSIC PLAYER INTEGRATION
      // =====================================================
      function initMusicPlayer() {
        const btnText = document.getElementById("music-button-text");
        const icon = document.getElementById("music-icon");
        const dropdown = document.getElementById("music-dropdown-content");

        if (!btnText || !icon || !dropdown) return;

        function setUI(state) {
          btnText.textContent =
            state === "Playing" ? "PAUSE MUSIC" : "STUDY MUSIC";
          icon.className =
            state === "Playing"
              ? "fa-solid fa-circle-pause"
              : "fa-solid fa-music";
        }

        // Load saved music state
        const savedSrc = localStorage.getItem("cybersec_music_src");
        const savedTime = parseFloat(
          localStorage.getItem("cybersec_music_time") || 0
        );

        if (savedSrc) {
          audioPlayer.src = savedSrc;
          audioPlayer.currentTime = savedTime;
          audioPlayer
            .play()
            .then(() => setUI("Playing"))
            .catch(() => setUI("Stopped"));
        }

        // Music button click handler
        document
          .getElementById("music-dropdown")
          .querySelector("button")
          .addEventListener("click", (e) => {
            e.stopPropagation();
            dropdown.style.display =
              dropdown.style.display === "block" ? "none" : "block";

            if (audioPlayer.src && !audioPlayer.paused) {
              audioPlayer.pause();
              setUI("Stopped");
            } else if (audioPlayer.src) {
              audioPlayer.play().then(() => setUI("Playing"));
            }
          });

        // Music selection handlers
        dropdown.querySelectorAll("a[data-src]").forEach((link) => {
          link.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.src = link.dataset.src;
            audioPlayer.play().then(() => setUI("Playing"));
            localStorage.setItem("cybersec_music_src", link.dataset.src);
            dropdown.style.display = "none";
          });
        });

        // Stop music handler
        const stopLink = document.getElementById("stop-music-link");
        if (stopLink) {
          stopLink.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            audioPlayer.removeAttribute("src");
            setUI("Stopped");
            localStorage.removeItem("cybersec_music_src");
            localStorage.removeItem("cybersec_music_time");
            dropdown.style.display = "none";
          });
        }

        // Save music state before page unload
        window.addEventListener("beforeunload", () => {
          if (!audioPlayer.paused && audioPlayer.src) {
            localStorage.setItem("cybersec_music_src", audioPlayer.src);
            localStorage.setItem(
              "cybersec_music_time",
              audioPlayer.currentTime
            );
          }
        });

        // Close dropdown when clicking outside
        window.addEventListener("click", (e) => {
          if (!e.target.closest("#music-dropdown")) {
            dropdown.style.display = "none";
          }
        });
      }

      // Show initial music indicator
      function addMusicIndicator() {
        const musicBtn = document.querySelector("#music-dropdown");
        if (musicBtn) {
          const indicator = document.createElement("div");
          indicator.className = "music-indicator";
          indicator.innerHTML = `<i class="fa-solid fa-music"></i> Try Study Music!`;

          musicBtn.style.position = "relative";
          musicBtn.appendChild(indicator);

          setTimeout(() => indicator.remove(), 3000);
        }
      }

      // Initialize Event Listeners
      function initializeEventListeners() {
        // Navigation buttons
        document
          .getElementById("prevLessonBtn")
          ?.addEventListener("click", goToPreviousLesson);
        document
          .getElementById("nextLessonBtn")
          ?.addEventListener("click", goToNextLesson);

        // Reset progress button
        document
          .getElementById("resetProgressBtn")
          ?.addEventListener("click", resetProgress);

        // Mobile menu toggle
        document
          .getElementById("menuToggle")
          ?.addEventListener("click", toggleSidebar);
        document
          .getElementById("sidebarOverlay")
          ?.addEventListener("click", closeSidebar);

        // Keyboard shortcuts
        document.addEventListener("keydown", handleKeyboardShortcuts);

        // Window resize handler
        window.addEventListener("resize", handleWindowResize);

        // Content interaction tracking
        document.getElementById("contentBody")?.addEventListener(
          "scroll",
          debounce(() => {
            trackUserInteraction();
          }, 1000)
        );
      }

      // Keyboard Shortcuts
      function handleKeyboardShortcuts(e) {
        if (document.querySelector(".quiz-question.active")) return;

        if (e.key === "ArrowLeft" && e.ctrlKey) {
          e.preventDefault();
          goToPreviousLesson();
        } else if (e.key === "ArrowRight" && e.ctrlKey) {
          e.preventDefault();
          goToNextLesson();
        }
      }

      // Window Resize Handler
      function handleWindowResize() {
        if (window.innerWidth > 768) {
          closeSidebar();
        }
      }

      // Debounce Helper
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Initialize responsive behavior
      if (window.innerWidth <= 768) {
        document.getElementById("menuToggle").style.display = "inline-flex";
      }

      // Auto-save progress periodically
      setInterval(async () => {
        if (currentUser && Object.keys(courseProgress).length > 0) {
          await saveProgress();
        }
      }, 60000); // Save every minute

      // System initialization logging
      console.log("CyberSec Academy Course System Initialized");
      console.log("Current Course:", COURSE_DATA.title);
      console.log("Total Lessons:", COURSE_DATA.lessons.length);

      // Google OAuth Integration
      const googleBtn = document.querySelector(".btn-google");
      if (googleBtn) {
        googleBtn.addEventListener("click", async () => {
          const { data, error } = await supabase.auth.signInWithOAuth({
            provider: "google",
            options: {
              redirectTo:
                window.location.origin +
                "/courses/ios-security-testing.html",
            },
          });

          if (error) {
            console.error("Google login error:", error.message);
            showToast("Google login failed: " + error.message, "error");
          }
        });
      }

      // Check for existing session
      supabase.auth.getSession().then(({ data }) => {
        if (data.session) {
          console.log("User already logged in:", data.session.user);
          currentUser = data.session.user;
          startCourseSession();
        }
      });

      // Add missing auth modal functions
      function openAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "flex";
        }
      }

      function closeAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Add auth tab switching functionality
      document.getElementById("tabSignIn")?.addEventListener("click", () => {
        document.getElementById("tabSignIn").classList.add("active");
        document.getElementById("tabSignUp").classList.remove("active");
        document.getElementById("signInForm").style.display = "block";
        document.getElementById("signUpForm").style.display = "none";
      });

      document.getElementById("tabSignUp")?.addEventListener("click", () => {
        document.getElementById("tabSignUp").classList.add("active");
        document.getElementById("tabSignIn").classList.remove("active");
        document.getElementById("signUpForm").style.display = "block";
        document.getElementById("signInForm").style.display = "none";
      });

      document
        .getElementById("closeAuthModal")
        ?.addEventListener("click", closeAuthModal);

      // Improved error handling for auth session
      supabase.auth.onAuthStateChange((event, session) => {
        if (event === "SIGNED_IN") {
          currentUser = session.user;
          closeAuthModal();
          startCourseSession();
        } else if (event === "SIGNED_OUT") {
          currentUser = null;
          openAuthModal();
        }
      });

      // Add form submission handlers
      document
        .getElementById("emailSignInForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signInEmail").value;
          const password = document.getElementById("signInPassword").value;

          try {
            const { data, error } = await supabase.auth.signInWithPassword({
              email,
              password,
            });

            if (error) throw error;

            closeAuthModal();
          } catch (error) {
            showToast(error.message, "error");
          }
        });

      document
        .getElementById("emailSignUpForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signUpEmail").value;
          const password = document.getElementById("signUpPassword").value;
          const name = document.getElementById("signUpName").value;

          try {
            const { data, error } = await supabase.auth.signUp({
              email,
              password,
              options: {
                data: {
                  full_name: name,
                },
              },
            });

            if (error) throw error;

            showToast(
              "Account created successfully! Please check your email.",
              "success"
            );
          } catch (error) {
            showToast(error.message, "error");
          }
        });
    </script>
  </body>
</html>
