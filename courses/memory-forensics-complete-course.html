



<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Exo+2:wght@700;800;900&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css"
    />
    <link rel="stylesheet" href="assets/css/coursepages.css">

    <!-- ========== Start: SEO & Schema Enhancement ========== -->
    <title>Memory Forensics - Complete Course | CipherHall</title>
    <meta name="description" content="Enroll in our expert-led Memory Forensics course. Master RAM analysis, find fileless malware, extract encryption keys, and build incident timelines with the Volatility Framework.">
    <meta name="robots" content="noindex, nofollow">
    
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png" />
    <link rel="shortcut icon" href="/favicon.png" type="image/x-icon" />
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png" />
    <link rel="canonical" href="https://www.cipherhall.com/courses/memory-forensics-complete-course.html" />

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Course",
      "name": "Memory Forensics - Complete Course",
      "description": "An advanced, hands-on course focused on the art and science of analyzing volatile memory (RAM). Learn to uncover evidence of sophisticated malware, user activity, and system intrusions that leave no trace on the hard disk.",
      "provider": {
        "@type": "Organization",
        "name": "CipherHall",
        "sameAs": "https://www.cipherhall.com"
      },
      "hasCourseInstance": {
        "@type": "CourseInstance",
        "courseMode": "Online",
        "instructor": {
          "@type": "Person",
          "name": "Dr. Kenji Tanaka"
        }
      }
    }
    </script>
    <!-- ========== End: SEO & Schema Enhancement ========== -->
</head>
  <body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
      <div class="loader-icon">
        <i class="fas fa-graduation-cap"></i>
      </div>
      <div class="loader-text">Loading Course Content...</div>
    </div>

    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- Music Player (fixed at top right) -->
    <div class="header-controls">
      <div class="music-dropdown" id="music-dropdown">
        <button class="btn btn-secondary">
          <span id="music-button-text">STUDY MUSIC</span>
          <i id="music-icon" class="fa-solid fa-music"></i>
        </button>
        <div class="music-dropdown-content" id="music-dropdown-content">
          <a
            href="#"
            data-src="https://www.learningcontainer.com/wp-content/uploads/2020/02/Kalimba.mp3"
            >1. Coffee Shop Vibes</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3"
            >2. City Lights Lofi</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-15.mp3"
            >3. Mellow Thoughts</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-13.mp3"
            >4. Rainy Mood</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3"
            >5. Time Alone</a
          >
          <a href="#" id="stop-music-link"
            ><i class="fa-solid fa-stop-circle"></i> Stop Music</a
          >
        </div>
      </div>

      <button class="btn btn-secondary" id="resetProgressBtn">
        <i class="fas fa-redo"></i>
        Reset Progress
      </button>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal" style="display: none">
      <div class="modal-overlay"></div>
      <div class="modal-content">
        <span class="close" id="closeAuthModal">&times;</span>
        <div class="auth-tabs">
          <button id="tabSignIn" class="auth-tab active">Sign In</button>
          <button id="tabSignUp" class="auth-tab">Sign Up</button>
        </div>
        <div
          id="authLoader"
          style="display: none; text-align: center; padding: 2rem"
        >
          <i
            class="fas fa-spinner fa-spin fa-2x"
            style="color: var(--color-green)"
          ></i>
          <p style="margin-top: 0.5rem">Authenticating...</p>
        </div>
        <div id="signInForm" class="auth-form">
          <h2>Sign In to CipherHall</h2>
          <button id="googleSignIn" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignInForm">
            <input
              type="email"
              id="signInEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signInPassword"
              placeholder="Password"
              required
            />
            <button type="submit" class="btn btn-primary">Sign In</button>
          </form>
        </div>
        <div id="signUpForm" class="auth-form" style="display: none">
          <h2>Join CipherHall</h2>
          <button id="googleSignUp" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignUpForm">
            <input
              type="text"
              id="signUpName"
              placeholder="Full Name"
              required
            />
            <input
              type="email"
              id="signUpEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signUpPassword"
              placeholder="Password (min. 8 characters)"
              required
            />
            <button type="submit" class="btn btn-secondary">
              Create Account
            </button>
          </form>
        </div>
        <div id="authMessage"></div>
      </div>
    </div>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="course-info">
          <h1 class="course-title" id="courseTitle">Loading...</h1>
          <div class="course-progress">
            <div class="progress-header">
              <span class="progress-label">Course Progress</span>
              <span class="progress-percentage" id="courseProgressPercent"
                >0%</span
              >
            </div>
            <div class="progress-bar">
              <div
                class="progress-fill"
                id="courseProgressFill"
                style="width: 0%"
              ></div>
            </div>
            <div class="progress-stats">
              <span id="completedLessons">0</span>
              <span id="totalLessons">0</span>
            </div>
          </div>
          <a href="/dashboard.html" class="back-to-dashboard">
            <i class="fas fa-arrow-left"></i>
            Back to Dashboard
          </a>
        </div>
      </div>

      <nav class="lesson-nav" id="lessonNav">
        <!-- Lessons will be loaded dynamically -->
      </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <header class="content-header">
        <div class="lesson-header">
          <div class="lesson-header-left">
            <span class="lesson-number" id="currentLessonNumber">1</span>
            <h1 class="lesson-header-title" id="currentLessonTitle">
              Loading...
            </h1>
          </div>
          <div class="lesson-actions">
            <button class="mbtn btn-primary" id="menuToggle">
              <i class="fas fa-bars"></i>
            </button>
          </div>
        </div>
      </header>

      <div class="content-body" id="contentBody">
        <div class="lesson-content" id="lessonContent">
          <!-- Lesson content will be loaded dynamically -->
        </div>
      </div>

      <footer class="lesson-navigation">
        <div class="nav-info" id="navInfo">Lesson 1 of 10</div>
        <div class="nav-controls">
          <button class="btn btn-secondary" id="prevLessonBtn" disabled>
            <i class="fas fa-chevron-left"></i>
            Previous
          </button>
          <button class="btn btn-primary" id="nextLessonBtn" disabled>
            Next
            <i class="fas fa-chevron-right"></i>
          </button>
        </div>
      </footer>
    </main>

    <!-- Achievement Notification -->
    <div id="achievementNotification" class="achievement-notification">
      <div class="notification-header">
        <div class="notification-icon" id="notificationIcon">
          <i class="fas fa-trophy"></i>
        </div>
        <div class="notification-content">
          <h3 id="notificationTitle">Achievement Unlocked!</h3>
          <p id="notificationDescription">Description here...</p>
        </div>
      </div>
      <div class="notification-reward" id="notificationReward">
        <i class="fas fa-coins"></i>
        <span id="notificationPoints">+100 Points</span>
      </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast">
      <span id="toastMessage"></span>
    </div>

    <script>
      // =====================================================
      // SYNCHRONIZED COURSE SYSTEM WITH DASHBOARD INTEGRATION
      // =====================================================

      // Supabase Configuration - Replace with your config
      const supabaseUrl = "https://lzcmzulemfubjaksoqor.supabase.co";
      const supabaseKey =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx6Y216dWxlbWZ1Ympha3NvcW9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzMzM5MDgsImV4cCI6MjA3MDkwOTkwOH0.crhPH4YWtRsr1BJTpAQcmPbWSpwIWRbzoI4sRb2_fPI";
      const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

      // =====================================================
      // COURSE DATA STRUCTURE - REPLACE WITH YOUR COURSE JSON
      // =====================================================

      const COURSE_DATA =   {
        "id": "memory-forensics",
        "title": "Memory Forensics - Complete Course Curriculum",
        "description": "An advanced, hands-on course focused on the art and science of analyzing volatile memory (RAM). Learn to uncover evidence of sophisticated malware, user activity, and system intrusions that leave no trace on the hard disk.",
        "category": "digital-forensics",
        "difficulty": "Advanced to Expert",
        "duration": "70 hours",
        "instructor": "Dr. Kenji Tanaka",
        "lessons": [
            {
                "id": "lesson-1",
                "title": "Fundamentals of Memory Forensics",
                "duration": "120 min",
                "objectives": [
                    "Differentiate between physical and virtual memory.",
                    "Explain the role of the Memory Management Unit (MMU).",
                    "Describe the layout of a process's virtual address space.",
                    "Understand the difference between kernel and user space memory.",
                    "Explain the legal considerations and chain of custody for volatile evidence.",
                    "Justify the need for memory forensics in a modern investigation."
                ],
                "content": {
                    "overview": "This foundational lesson introduces the critical concepts of volatile memory and the role it plays in modern operating systems. We will explore why some of the most crucial digital evidence exists only in RAM and establish the legal and procedural principles required to acquire and analyze this ephemeral data.",
                    "sections": [
                        {
                            "title": "Physical vs. Virtual Memory Concepts",
                            "content": "<p>Understanding the distinction between physical and virtual memory is the absolute foundation of memory forensics.</p><ul><li><strong>Physical Memory:</strong> The actual RAM chips installed in the computer. It is a finite, physical resource.</li><li><strong>Virtual Memory:</strong> An abstraction layer created by the operating system. Each process is given its own private, contiguous virtual address space, creating the illusion that it has the computer's entire memory to itself.</li></ul><p><strong>Real-World Example:</strong> Imagine a library with a limited number of physical shelves (physical memory). Each person wanting to read a book is given their own personal catalog with page numbers from 1 to 1,000,000 (virtual memory). The person uses their catalog's page numbers, and a librarian (the MMU) translates that virtual page number to the actual shelf and book where the data resides.</p>",
                            "image": "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "The Memory Management Unit (MMU) and Address Translation",
                            "content": "<p>The MMU is a hardware component on the CPU that acts as the 'librarian'. It is responsible for the critical task of translating the virtual addresses used by a process into the actual physical addresses in RAM where the data is stored. This translation process is invisible to the application.</p><h3>Kernel vs. User Space Memory:</h3><p>To protect the operating system's stability, memory is segregated into two distinct areas:</p><ul><li><strong>User Space:</strong> Where user applications (like a web browser or word processor) run. A process in user space can only access its own memory.</li><li><strong>Kernel Space:</strong> The protected area where the core of the operating system (the kernel) runs. The kernel can access all memory (its own and that of every user process).</li></ul>",
                            "image": "https://images.unsplash.com/photo-1510915228340-29c85a43dcfe?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Legal Considerations for Volatile Evidence",
                            "content": "<p>Volatile data in RAM is just as much 'evidence' as data on a hard drive, but it requires special handling.</p><p><strong>Chain of Custody for Volatile Evidence:</strong> The chain of custody must be started the moment of acquisition. The process of acquiring the memory dump must be meticulously documented—the tool used, the time of acquisition, the hash of the resulting dump file. Because the act of acquiring memory can alter the system, this documentation is critical to defending the evidence in court.</p><p><strong>Real-time Problem: Analyzing memory from a crashed system.</strong> A server unexpectedly crashes, creating a `MEMORY.DMP` file as part of the Blue Screen of Death (BSOD) process. An analyst can take this crash dump and analyze it with memory forensics tools like Volatility. While not as pristine as a live acquisition, it can still reveal the state of the system at the moment of the crash, often showing the malicious process or driver that caused the system to fail.</p>",
                            "image": "https://images.unsplash.com/photo-1588196749597-9ff075ee6b5b?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Memory Forensics Lab Environment Setup (Conceptual)",
                            "language": "bash",
                            "code": "# This script outlines the setup of a Linux workstation for memory analysis.\n\n# 1. Update and install prerequisites\nsudo apt update && sudo apt install -y python3-dev git\n\n# 2. Clone the Volatility 3 framework from GitHub\n# Volatility is the industry-standard tool for memory analysis.\ngit clone https://github.com/volatilityfoundation/volatility3.git\ncd volatility3\n\n# 3. Install Python dependencies\npip3 install -r requirements.txt\n\n# 4. (Optional) Install other tools like Rekall or MemProcFS\n\n# 5. Create case directories\nmkdir -p ~/forensics/memory_dumps\nmkdir -p ~/forensics/case_outputs\n\n# 6. Verify the installation by running the help command\npython3 vol.py -h\n\necho \"[+] Memory forensics lab environment is ready.\""
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the primary role of the Memory Management Unit (MMU)?",
                            "options": [
                                "To cool the RAM chips.",
                                "To store data permanently.",
                                "To translate virtual memory addresses used by a process into physical memory addresses.",
                                "To run applications."
                            ],
                            "correct": 2,
                            "explanation": "The MMU is the crucial hardware component that manages the abstraction between the logical addresses a program sees and the physical locations in RAM where data is actually stored."
                        },
                        {
                            "id": 2,
                            "question": "The protected area of memory where the core operating system runs is called:",
                            "options": [
                                "User Space",
                                "The Heap",
                                "The Stack",
                                "Kernel Space"
                            ],
                            "correct": 3,
                            "explanation": "Kernel space is a privileged and protected area of memory reserved for the OS kernel to ensure that user applications cannot crash or interfere with the core functioning of the system."
                        },
                        {
                            "id": 3,
                            "question": "Why is it critical to acquire a memory dump from a live, running system?",
                            "options": [
                                "It is not critical; memory can be analyzed after a reboot.",
                                "Because memory is volatile, and all data (running processes, network connections, encryption keys) will be lost the moment the system is powered off.",
                                "It makes the computer run faster.",
                                "It is easier to do than disk imaging."
                            ],
                            "correct": 1,
                            "explanation": "The term 'volatile' means the data is temporary. Memory forensics is focused on capturing this ephemeral data, which requires acquiring it from a live system before a shutdown erases everything."
                        }
                    ]
                }
            },
            {
                "id": "lesson-2",
                "title": "Memory Architecture and Operating System Internals",
                "duration": "100 min",
                "objectives": [
                    "Understand the memory architecture of x86/x64 and ARM processors.",
                    "Explain the internal memory management mechanisms of Windows, Linux, and macOS.",
                    "Describe the layout of a typical process address space, including the heap and stack.",
                    "Analyze how memory-mapped files and shared libraries work.",
                    "Understand the operations of the virtual memory manager, including swapping and paging.",
                    "Discuss the forensic implications of memory compression."
                ],
                "content": {
                    "overview": "To analyze memory, you must understand how an operating system organizes and manages it. This lesson dives into the OS internals, exploring how Windows, Linux, and macOS structure memory, manage processes, and handle virtual memory. We will build a detailed mental model of the memory landscape that is essential for navigating it during an investigation.",
                    "sections": [
                        {
                            "title": "x86/x64 and ARM Memory Architecture",
                            "content": "<p>The underlying CPU architecture dictates how memory is addressed.</p><ul><li><strong>x86/x64:</strong> The dominant architecture for desktops and servers. x86 refers to 32-bit, which can address a maximum of 4GB of RAM. x64 refers to 64-bit, which can address a virtually limitless amount of RAM.</li><li><strong>ARM:</strong> The dominant architecture for mobile devices and increasingly, laptops (e.g., Apple Silicon). It is a different instruction set and has its own unique memory management features.</li></ul><p>A memory analyst must be able to identify the architecture of a memory dump to use the correct profile and tools for analysis.</p>",
                            "image": "https://images.unsplash.com/photo-1593435713588-a73de23947db?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Process Address Space Layout: Heap and Stack",
                            "content": "<p>When an OS creates a process, it gives it a virtual address space with a standard layout.</p><h3>Key Regions:</h3><ul><li><strong>Text Segment:</strong> The actual executable code of the program.</li><li><strong>Data Segment:</strong> Contains global variables.</li><li><strong>Heap:</strong> A large area of memory used for dynamic memory allocation. The program can request blocks of memory from the heap as needed. This is where most of a program's operational data is stored.</li><li><strong>Stack:</strong> A smaller, highly structured region of memory used for static memory allocation, primarily for storing local variables and managing function calls.</li></ul><p><strong>Real-world Example:</strong> A program reads a user's password from the keyboard. It will likely store that password in a variable on the stack temporarily, or in a dynamically allocated buffer on the heap. A memory analyst can scan these regions to find such sensitive data in plaintext.</p>",
                            "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "The Virtual Memory Manager (VMM)",
                            "content": "<p>The VMM is the component of the OS kernel responsible for managing virtual memory. One of its key jobs is paging.</p><p><strong>Paging (Swapping):</strong> Since physical RAM is limited, the VMM can take a block (a 'page') of memory that hasn't been used recently and temporarily write it out to a special file on the hard disk (the 'page file' or 'swap space'). This frees up physical RAM for other processes. When the original process needs that page again, the VMM reads it back from the disk into RAM.</p><p><strong>Real-time Problem: Reconstructing process memory layout.</strong> An investigator is analyzing a memory dump. They use a tool to examine a specific process, but a large chunk of its memory seems to be missing. The analyst realizes this part of the process's memory was likely 'paged out' to disk when the dump was taken. To get the full picture, the analyst must not only analyze the RAM dump, but also acquire and analyze the page file (`pagefile.sys` on Windows) to reconstruct the complete memory of that process.</p>",
                            "image": "https://images.unsplash.com/photo-1544197150-b99a580bb7a8?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Cross-Platform Memory Architecture Comparison",
                            "language": "markdown",
                            "code": "# Comparing Key OS Memory Structures for Forensics\n\n| Artifact/Structure          | Windows                                         | Linux                                               | macOS                                           |\n|-----------------------------|-------------------------------------------------|-----------------------------------------------------|-------------------------------------------------|\n| **Process List Structure**  | `EPROCESS` block (doubly-linked list)           | `task_struct` (doubly-linked list)                  | `proc` structure (list)                         |\n| **Kernel Memory**           | Protected, high-address space                   | Protected, high-address space                       | Protected, high-address space                   |\n| **Paging/Swap File**        | `C:\\pagefile.sys`                                | `/swap` partition or file                           | `/private/var/vm/swapfile*`                     |\n| **Key Memory Analysis Tool**| Volatility, Rekall, WinDbg                      | Volatility, Rekall, GDB                             | Volatility, Rekall                              |\n| **Forensic Challenge**      | PatchGuard (kernel protection), memory compression| Diverse kernel versions requiring precise profiles. | Memory compression, unique ARM architecture.    |"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "In a process's virtual address space, where is memory for dynamic allocation (e.g., creating objects, reading files) typically managed?",
                            "options": [
                                "The Text Segment",
                                "The Stack",
                                "The Heap",
                                "The Kernel"
                            ],
                            "correct": 2,
                            "explanation": "The heap is the large, flexible area of memory that programs use to request memory at runtime. It is a primary target for forensic analysts looking for a program's operational data."
                        },
                        {
                            "id": 2,
                            "question": "What is the primary purpose of the page file (e.g., `pagefile.sys` on Windows)?",
                            "options": [
                                "To store the operating system kernel.",
                                "To store temporary internet files.",
                                "To act as a virtual extension of physical RAM, allowing the OS to move less-used memory pages to disk.",
                                "To store user documents."
                            ],
                            "correct": 2,
                            "explanation": "The page file (or swap space) allows the OS to manage the limited physical RAM efficiently by temporarily storing inactive memory pages on the much larger, but slower, hard disk."
                        },
                        {
                            "id": 3,
                            "question": "Why is it important for a memory analyst to also acquire the page file in an investigation?",
                            "options": [
                                "It is not important.",
                                "Because parts of a process's memory may have been paged out to disk and will not be present in the RAM dump.",
                                "The page file contains a backup of the entire hard drive.",
                                "The page file contains all the user's passwords."
                            ],
                            "correct": 1,
                            "explanation": "To get a complete picture of a process's memory, an analyst needs both the data that was in RAM and the data that was paged out to disk. Correlating the RAM dump and the page file is key to a full reconstruction."
                        }
                    ]
                }
            },
            {
                "id": "lesson-3",
                "title": "Memory Acquisition Techniques and Tools",
                "duration": "120 min",
                "objectives": [
                    "Perform memory acquisition using common software-based tools.",
                    "Understand the principles of hardware-based acquisition (e.g., DMA).",
                    "Acquire memory from virtual machines and hypervisors.",
                    "Discuss the challenges of mobile device memory acquisition.",
                    "Apply techniques to validate the integrity of a memory dump.",
                    "Understand and compare different memory dump file formats (e.g., raw, crash dump)."
                ],
                "content": {
                    "overview": "Acquiring a clean and complete copy of volatile memory is the critical first step of any memory forensics investigation. An improper acquisition can corrupt the evidence or fail to capture it entirely. This lesson provides a hands-on overview of the tools and techniques used to perform a forensically sound memory dump from a variety of systems.",
                    "sections": [
                        {
                            "title": "Software-Based Acquisition",
                            "content": "<p>This is the most common method, involving running a trusted software tool on the live system to copy the contents of RAM to a file on an external drive.</p><h3>Common Tools:</h3><ul><li><strong>FTK Imager:</strong> A popular, free GUI-based tool from AccessData. It's easy to use and widely accepted in court.</li><li><strong>DumpIt:</strong> A small, simple command-line utility from Magnet Forensics. It requires no installation and is highly portable.</li><li><strong>LiME (Linux Memory Extractor):</strong> The standard for Linux. It is a loadable kernel module that can dump memory with minimal impact on the system.</li></ul><p><strong>The Process:</strong> The analyst connects a sterile external hard drive (the 'destination') to the target computer. They run the acquisition tool from the external drive. The tool copies the full contents of physical RAM to a single file on the destination drive.</p>",
                            "image": "https://images.unsplash.com/photo-1544197150-b99a580bb7a8?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Hardware-Based Acquisition",
                            "content": "<p>Hardware-based methods use a physical device to access and copy RAM, without running any software on the target system. This is considered the most forensically sound method, as it minimizes the changes made to the live system.</p><h3>Methods:</h3><ul><li><strong>DMA (Direct Memory Access):</strong> A malicious device connected via a port with DMA access (like Thunderbolt or FireWire) can be instructed to read the entire contents of physical RAM. This is the basis for several commercial hardware acquisition tools.</li><li><strong>Cold Boot Attack:</strong> A more exotic technique. The analyst powers down the machine and immediately reboots it into a special forensic OS. Because RAM contents fade over a period of seconds (especially if cooled), it's possible to recover the remnants of the previous OS's memory before it disappears completely.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1575235028124-ab6346a5a0a3?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Acquisition from Virtual Machines",
                            "content": "<p>Acquiring memory from a VM is often easier than from a physical machine, as the hypervisor has direct access to the VM's virtualized RAM.</p><p><strong>Real-time Problem: Acquiring memory from an encrypted system.</strong> An investigator encounters a laptop that is powered on and unlocked, but the hard drive is encrypted with BitLocker. If they power it down to image the disk, the encryption keys in RAM will be lost, and the disk image will be unreadable. The correct procedure is to perform a *live memory acquisition first*. By dumping the RAM while the system is running, they can capture the BitLocker keys. Later, they can use those keys to decrypt the forensic image of the hard drive, giving them access to the full file system.</p><h3>Hypervisor-Level Acquisition:</h3><p>Platforms like VMware vSphere have built-in functions to 'suspend' a VM. When a VM is suspended, the hypervisor writes the entire contents of its RAM to a `.vmem` file on the datastore. An analyst can then acquire this `.vmem` file and analyze it as a standard memory dump.</p>",
                            "image": "https://images.unsplash.com/photo-1510915228340-29c85a43dcfe?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Custom Memory Acquisition Script (Conceptual)",
                            "language": "python",
                            "code": "import subprocess\nimport hashlib\nimport datetime\n\n# This conceptual script outlines the steps for a forensically sound acquisition process.\n# It assumes a trusted acquisition tool like 'dumpit.exe' is available.\n\ndef acquire_memory(tool_path, destination_path):\n    \"\"\"Performs and documents a memory acquisition.\"\"\"\n    timestamp = datetime.datetime.utcnow().strftime('%Y%m%d_%H%M%S')\n    output_file = f\"{destination_path}/memory_dump_{timestamp}.raw\"\n    log_file = f\"{destination_path}/acquisition_log_{timestamp}.txt\"\n\n    # 1. Start the log\n    with open(log_file, 'w') as log:\n        log.write(f\"Memory Acquisition Log - Case XYZ-001\\n\")\n        log.write(f\"Start Time (UTC): {timestamp}\\n\")\n        log.write(f\"Tool Used: {tool_path}\\n\")\n\n    # 2. Run the acquisition tool\n    print(\"[*] Starting memory acquisition...\")\n    # In a real script, you'd handle stdout/stderr properly.\n    subprocess.run([tool_path, \"-o\", output_file])\n    print(\"[+] Acquisition complete.\")\n\n    # 3. Calculate the hash of the resulting dump file for integrity\n    print(\"[*] Calculating hash of memory dump...\")\n    sha256_hash = hashlib.sha256()\n    with open(output_file, 'rb') as f:\n        for block in iter(lambda: f.read(4096), b''):\n            sha256_hash.update(block)\n    hex_digest = sha256_hash.hexdigest()\n    print(f\"[+] SHA256 Hash: {hex_digest}\")\n\n    # 4. Finalize the log\n    with open(log_file, 'a') as log:\n        log.write(f\"Output File: {os.path.basename(output_file)}\\n\")\n        log.write(f\"SHA256 Hash: {hex_digest}\\n\")\n        log.write(f\"End Time (UTC): {datetime.datetime.utcnow().strftime('%Y%m%d_%H%M%S')}\\n\")\n\n# acquire_memory(\"E:\\tools\\dumpit.exe\", \"F:\\evidence\")"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "Which of the following is considered the most common method for memory acquisition?",
                            "options": [
                                "Hardware-based DMA acquisition",
                                "A cold boot attack",
                                "Running a trusted software-based tool on the live system",
                                "Analyzing the page file"
                            ],
                            "correct": 2,
                            "explanation": "While hardware methods are the most forensically sound, they require specialized equipment. Software-based acquisition using tools like FTK Imager or DumpIt is by far the most common and accessible method used by investigators."
                        },
                        {
                            "id": 2,
                            "question": "What is the primary reason to perform a memory acquisition *before* imaging the hard drive of a system encrypted with BitLocker?",
                            "options": [
                                "It is faster.",
                                "The encryption keys needed to decrypt the hard drive image exist in RAM while the system is running.",
                                "It is required by law.",
                                "Memory acquisition is not needed for encrypted systems."
                            ],
                            "correct": 1,
                            "explanation": "This is a critical procedural point. If the system is powered down, the encryption keys in RAM are lost forever, and the disk image will be unusable. Capturing the RAM first allows you to recover the keys and unlock the evidence."
                        },
                        {
                            "id": 3,
                            "question": "LiME (Linux Memory Extractor) is a tool used to acquire memory from which operating system?",
                            "options": [
                                "Windows",
                                "macOS",
                                "Linux",
                                "iOS"
                            ],
                            "correct": 2,
                            "explanation": "LiME is the industry-standard, open-source tool for performing memory acquisition from Linux systems. It operates as a loadable kernel module to minimize its footprint on the live system."
                        }
                    ]
                }
            },
            {
                "id": "lesson-4",
                "title": "Memory Analysis Frameworks and Tools",
                "duration": "120 min",
                "objectives": [
                    "Perform a comprehensive analysis of a memory dump using the Volatility Framework.",
                    "Understand the capabilities of other major platforms like Rekall and MemProcFS.",
                    "Use debuggers like WinDbg and GDB for deep memory analysis.",
                    "Scan a memory dump for indicators of compromise using YARA rules.",
                    "Understand the basics of custom plugin development.",
                    "Automate common memory analysis tasks.",
                    "Discuss the importance of tool validation and accuracy testing."
                ],
                "content": {
                    "overview": "A memory dump is just a raw, unstructured file. To turn it into evidence, you need a specialized analysis framework. This lesson provides a comprehensive introduction to the industry-standard tool, the Volatility Framework, and other key platforms. You will learn how to use these tools to parse the internal structures of a memory dump and extract critical forensic artifacts.",
                    "sections": [
                        {
                            "title": "The Volatility Framework: The Industry Standard",
                            "content": "<p>Volatility is a powerful, open-source memory analysis framework written in Python. It is the most widely used and accepted tool in the field. Volatility works by using 'profiles'—a collection of symbols and data structures specific to an operating system version—to understand and parse the raw memory dump.</p><h3>The Basic Workflow:</h3><ol><li><strong>Identify the Profile:</strong> First, you must identify the exact OS of the memory dump (e.g., Windows 10 x64 Build 19041). Volatility has plugins to help automate this.</li><li><strong>Run Plugins:</strong> You then run a series of plugins, which are small scripts designed to find and display specific artifacts (e.g., the process list, network connections).</li></ol>",
                            "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Core Volatility Plugins",
                            "content": "<p>A typical initial analysis involves running a standard set of plugins to get a high-level overview of the system's state.</p><h3>Essential Triage Plugins:</h3><ul><li><strong>`imageinfo` / `kdbgscan` (Volatility 2) or `windows.info` (Volatility 3):</strong> Determines the correct OS profile for the image.</li><li><strong>`pslist` / `pstree`:</strong> Lists all running processes and shows their parent-child relationships. This is key for spotting suspicious processes spawned by legitimate ones.</li><li><strong>`netscan`:</strong> Shows all active and closed network connections at the time of the dump. Critical for finding C2 connections.</li><li><strong>`dlllist`:</strong> Lists all the DLLs loaded by each process.</li><li><strong>`cmdline`:</strong> Shows the command-line arguments used to launch processes, which can reveal attacker commands.</li><li><strong>`malfind`:</strong> A powerful plugin that scans for hidden or injected code within process memory, a hallmark of advanced malware.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Live Analysis with MemProcFS",
                            "content": "<p>MemProcFS is an innovative tool that takes a different approach. Instead of running individual plugins against a static dump file, it mounts the memory dump as a virtual file system.</p><p><strong>Real-time Problem: Analyzing unknown malware in memory.</strong> An analyst is investigating a memory dump but doesn't know what to look for. They start by running `pstree` to visualize the process relationships. They spot a `powershell.exe` process that was spawned by a Microsoft Word document (`winword.exe`), which is highly suspicious. They then use `cmdline` to see what command was run, revealing a long, encoded PowerShell script. Using the `memdump` plugin, they dump the memory of that PowerShell process and can then decode the script to understand the attacker's actions. This workflow, moving from a high-level overview to a specific artifact, is central to memory analysis.</p>",
                            "image": "https://images.unsplash.com/photo-1504384308090-c894fdcc538d?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Custom Volatility Plugin Development (Conceptual)",
                            "language": "python",
                            "code": "from volatility3.framework import renderers\nfrom volatility3.framework.interfaces import plugins, context\nfrom volatility3.plugins.windows import pslist\n\n# This is a simplified, conceptual Volatility 3 plugin that demonstrates the basic structure.\n# It finds all processes named 'powershell.exe'.\n\nclass FindPowerShell(plugins.PluginInterface):\n    \"\"\"Lists only the processes named powershell.exe\"\"\"\n\n    # This defines the plugin's requirements (in this case, the pslist plugin)\n    _required_plugins = [('windows.pslist', pslist.PsList)]\n\n    @classmethod\n    def get_requirements(cls):\n        return [context.Requirement(name='pslist', plugin=pslist.PsList, version=(2, 0, 0))]\n\n    def _generator(self, procs):\n        for proc in procs:\n            proc_name = proc.ImageFileName.cast('string', max_length=proc.ImageFileName.vol.count, errors='replace')\n            if proc_name.lower() == 'powershell.exe':\n                # Yield the process's PID, name, and create time\n                yield (0, (proc.UniqueProcessId, proc_name, str(proc.CreateTime)))\n\n    def run(self, *args, **kwargs):\n        # Get the list of all processes from the required plugin\n        procs = self.context.plugins.pslist.list_processes(self.context, self.config['primary'], self.config['nt_symbols'])\n        \n        # Return a grid renderer with the specified columns and the filtered data\n        return renderers.TreeGrid([(\"PID\", int), (\"ImageFileName\", str), (\"CreateTime\", str)], self._generator(procs))"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the industry-standard, open-source framework for analyzing memory dumps?",
                            "options": [
                                "Wireshark",
                                "The Volatility Framework",
                                "Nmap",
                                "FTK Imager"
                            ],
                            "correct": 1,
                            "explanation": "Volatility is the most widely used and respected tool in the field of memory forensics, with a vast number of plugins to extract nearly any type of artifact from a memory dump."
                        },
                        {
                            "id": 2,
                            "question": "In Volatility, what is the primary purpose of the `netscan` plugin?",
                            "options": [
                                "To list running processes.",
                                "To find hidden malware.",
                                "To show active and closed network connections.",
                                "To dump the contents of the command prompt."
                            ],
                            "correct": 2,
                            "explanation": "The `netscan` (or `netstat` in older versions) plugin is used to reconstruct the system's network state, which is critical for identifying malicious connections like C2 beaconing."
                        },
                        {
                            "id": 3,
                            "question": "Before you can run most analysis plugins in Volatility, what critical piece of information must you first determine?",
                            "options": [
                                "The computer's hostname.",
                                "The correct profile (the specific OS version and architecture) for the memory dump.",
                                "The amount of free disk space.",
                                "The name of the user who was logged in."
                            ],
                            "correct": 1,
                            "explanation": "Volatility needs the correct profile to know how to interpret the raw data in the memory dump. The profile acts as a map to the operating system's internal data structures. Using the wrong profile will result in garbage output."
                        }
                    ]
                }
            },
            {
                "id": "lesson-5",
                "title": "Process and Thread Analysis",
                "duration": "120 min",
                "objectives": [
                    "Analyze process creation and termination events.",
                    "Reconstruct the process hierarchy (parent-child relationships).",
                    "Understand the basics of thread analysis.",
                    "Examine the memory layout of a running process.",
                    "Analyze the Dynamic Link Libraries (DLLs) loaded by a process.",
                    "Detect various forms of process injection and hollowing.",
                    "Correlate process artifacts with other evidence to build a timeline."
                ],
                "content": {
                    "overview": "Processes are the fundamental unit of execution in an operating system. Understanding what processes were running, how they were created, and what they were doing is the core of memory forensics. This lesson provides a deep dive into process analysis, including advanced techniques for detecting how malware hides by injecting itself into legitimate processes.",
                    "sections": [
                        {
                            "title": "Process Hierarchy Reconstruction",
                            "content": "<p>In Windows and Linux, every process has a parent process that created it. Mapping these parent-child relationships is a powerful way to spot anomalies.</p><p><strong>Real-World Example:</strong> An analyst runs Volatility's `pstree` plugin, which displays the process list as a tree. They see a `powershell.exe` process, but its parent is `winword.exe` (Microsoft Word). This is highly suspicious. A user does not normally launch a powerful command-line shell from a word processor. This is a classic indicator of a malicious document that used a macro to execute a malicious script.</p><h3>Legitimate vs. Illegitimate Parent-Child Relationships:</h3><ul><li>**Normal:** `services.exe` -> `svchost.exe`</li><li>**Normal:** `explorer.exe` -> `chrome.exe`</li><li>**Suspicious:** `winword.exe` -> `powershell.exe`</li><li>**Suspicious:** `lsass.exe` -> `cmd.exe`</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "DLL Analysis",
                            "content": "<p>Dynamic Link Libraries (DLLs) are shared libraries of code used by executable files. Malware often uses malicious DLLs or abuses legitimate ones.</p><h3>Analysis Techniques:</h3><ul><li><strong>`dlllist` Plugin:</strong> This Volatility plugin lists all the DLLs loaded by each process. An analyst can look for unusually named DLLs or DLLs loaded from strange locations (like `C:\\Temp`).</li><li><strong>DLL Search Order Hijacking:</strong> A common persistence technique where an attacker places a malicious DLL with the same name as a legitimate one in a location that gets searched first, causing a program to load the malicious library instead of the real one.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Process Injection and Hollowing",
                            "content": "<p>These are advanced stealth techniques used by malware to hide its code inside of a legitimate, trusted process.</p><ul><li><strong>Process Injection:</strong> The malware injects its malicious code (e.g., a malicious DLL) into the memory space of a legitimate process (like `explorer.exe`) and then causes that process to execute it.</li><li><strong>Process Hollowing:</strong> A more advanced technique. The malware starts a legitimate process in a suspended state (e.g., `svchost.exe`). It then 'hollows out' its memory, replacing the legitimate code with its own malicious code before resuming the process. From the outside, it looks like a normal `svchost.exe` is running, but it is actually the malware.</li></ul><p><strong>Real-time Problem: Detecting a process hollowing attack.</strong> An analyst is examining a memory dump. The `pslist` output shows a normal-looking `svchost.exe` process. However, when they run the `malfind` plugin, it reports that a section of memory within that `svchost.exe` process has been marked as Read-Write-Execute (RWX), which is highly unusual for legitimate code. Volatility's `vadinfo` plugin confirms the memory protection is abnormal. This is a classic signature of process hollowing, and the analyst can now dump that specific memory section to recover the hidden malware.</p>",
                            "image": "https://images.unsplash.com/photo-1504384308090-c894fdcc538d?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Process Tree Reconstruction Tool (Volatility)",
                            "language": "bash",
                            "code": "# Using the 'pstree' plugin in Volatility provides a hierarchical view of processes.\n# This makes it easy to spot anomalous parent-child relationships.\n\nMEMORY_FILE=\"suspicious_host.mem\"\n\n# Run the pstree plugin\nvol -f $MEMORY_FILE windows.pstree\n\n# --- Sample Output ---\n# ...\n# 0x8675309  explorer.exe   1234   456   ...\n# 0xdeadbeef   winword.exe    5678   1234  ...\n# 0xfeedface     powershell.exe 8910   5678  ...\n# ...\n\n# In this conceptual output, seeing powershell.exe as a child of winword.exe\n# is an immediate red flag for an analyst to investigate further."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "An analyst sees `powershell.exe` running as a child process of `winword.exe`. Why is this suspicious?",
                            "options": [
                                "It is not suspicious; this is normal behavior.",
                                "A user does not normally launch a command-line shell from a word processor; this suggests a malicious macro was executed.",
                                "PowerShell is not a real program.",
                                "Microsoft Word cannot have child processes."
                            ],
                            "correct": 1,
                            "explanation": "Analyzing the parent-child process hierarchy is fundamental. Legitimate user actions create predictable patterns. A document launching a shell is a classic indicator of compromise."
                        },
                        {
                            "id": 2,
                            "question": "The technique where malware starts a legitimate process, replaces its code in memory with malicious code, and then resumes it is called:",
                            "options": [
                                "Process Injection",
                                "Process Hollowing",
                                "DLL Hijacking",
                                "A Cold Boot Attack"
                            ],
                            "correct": 1,
                            "explanation": "Process hollowing is an advanced stealth technique. The malware uses the legitimate process as a 'hollow' container for its own code, making it appear as a normal process in the process list."
                        },
                        {
                            "id": 3,
                            "question": "Which Volatility plugin is specifically designed to find hidden or injected code in a process's memory by looking for unusual memory permissions?",
                            "options": [
                                "pslist",
                                "netscan",
                                "cmdline",
                                "malfind"
                            ],
                            "correct": 3,
                            "explanation": "The `malfind` plugin is one of the most powerful tools for malware analysis in memory. It specifically hunts for memory sections that have suspicious characteristics, like being executable and writable, which is a common sign of injected code."
                        }
                    ]
                }
            },
            {
                "id": "lesson-6",
                "title": "Malware Detection and Analysis in Memory",
                "duration": "120 min",
                "objectives": [
                    "Identify memory-resident and 'fileless' malware.",
                    "Apply techniques to detect sophisticated rootkits.",
                    "Analyze code injection and API hooking.",
                    "Understand how to analyze packed and polymorphic malware.",
                    "Investigate 'living-off-the-land' techniques that abuse legitimate tools.",
                    "Find memory-based persistence mechanisms."
                ],
                "content": {
                    "overview": "Modern malware is designed to be stealthy, and one of the best ways to be stealthy is to avoid writing files to the disk where traditional antivirus can find them. This lesson focuses on the advanced techniques used to detect and analyze malware that runs entirely in memory, from sophisticated rootkits to 'fileless' attacks that abuse the operating system's own tools.",
                    "sections": [
                        {
                            "title": "Fileless Malware Investigation",
                            "content": "<p>'Fileless' malware is a broad term for malicious activity that runs directly in memory without first writing an executable file to the disk. This allows it to evade traditional signature-based antivirus.</p><h3>Common Techniques:</h3><ul><li><strong>Malicious Scripts:</strong> A macro in a Word document downloads and executes a PowerShell script directly in memory.</li><li><strong>In-Memory Exploitation:</strong> An exploit against a browser or application gains code execution and downloads and runs the next stage of the attack without ever touching the disk.</li><li><strong>Living-off-the-Land (LotL):</strong> The attacker uses only legitimate, pre-installed Windows tools (like PowerShell, WMI, BITSAdmin) to carry out their attack. There is no 'malware' file to find, only the abuse of legitimate tools.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1548092372-2d987bde898b?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Rootkit Detection Techniques",
                            "content": "<p>A rootkit is a type of malware designed to conceal its own existence or the existence of other malicious code. Kernel-mode rootkits are the most powerful, as they can modify the core of the operating system itself.</p><h3>How Rootkits Hide:</h3><p>A rootkit might hook the function that lists running processes. When the operating system asks for the process list, the rootkit intercepts the request, removes its own process from the list, and then passes the sanitized list back to the user. The user runs `tasklist` and sees nothing, but the malware is still running.</p><p><strong>Real-world Example: Analyzing a sophisticated rootkit.</strong> An analyst runs `pslist` in Volatility and sees a list of processes. They then run another plugin, `psscan`, which doesn't trust the OS's process list. Instead, `psscan` scans all of physical memory looking for the data structures that define a process. `psscan` shows a process that was *not* in the `pslist` output. This discrepancy is definitive proof of a rootkit that is actively hiding a process. This cross-view validation is a core technique of memory forensics.</p>",
                            "image": "https://images.unsplash.com/photo-1504384308090-c894fdcc538d?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Packed and Polymorphic Malware",
                            "content": "<p>Malware authors use 'packers' to compress and encrypt their executable files. This has two effects: it makes the file smaller, and it obfuscates the code so that antivirus can't match its signatures.</p><ul><li><strong>Packed Malware:</strong> The malicious code is compressed/encrypted. When the program is run, a small 'unpacker stub' unpacks the real code into memory and then executes it.</li><li><strong>Polymorphic Malware:</strong> An advanced type that changes its own code with each infection, creating a new signature every time.</li></ul><p><strong>Forensic Implication:</strong> Analyzing the packed file on disk is difficult. However, in order for the malware to run, it *must* be unpacked in memory. Memory forensics allows an analyst to dump the unpacked, clean version of the malware's code directly from the process's memory, bypassing the on-disk obfuscation.</p>",
                            "image": "https://images.unsplash.com/photo-1629654297299-c8506221ca97?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Advanced Malware Detection Engine (YARA)",
                            "language": "c",
                            "code": "/* This is a YARA rule designed to run against a memory dump.\n   It looks for the signs of a reflective DLL injection, a common fileless technique.\n*/\nrule Reflective_DLL_Injection_InMemory {\n\n   meta:\n      description = \"Detects a pattern indicative of reflective DLL injection in memory.\"\n      author = \"Memory Forensics Course\"\n\n   strings:\n      // The MZ header of a PE file (the DLL)\n      $mz_header = \"MZ\"\n      // A string often found in the reflective loader stub\n      $loader_stub = \"This program cannot be run in DOS mode.\"\n      // A common function used by the loader to find itself in memory\n      $find_self = \"call_find_self\"\n\n   condition:\n      // The condition is that we find the MZ header and the loader stub, but\n      // this memory region is NOT mapped to a file on disk (i.e., it's fileless).\n      // The 'pe' module in a memory-aware YARA scanner can provide this context.\n      $mz_header at 0 and $loader_stub and not pe.is_mapped\n}"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "An attack where the adversary uses only legitimate, built-in Windows tools like PowerShell and WMI to conduct their operations is known as:",
                            "options": [
                                "A virus attack",
                                "A worm attack",
                                "'Living-off-the-Land' (LotL)",
                                "A brute-force attack"
                            ],
                            "correct": 2,
                            "explanation": "Living-off-the-Land is a stealthy technique because there is no traditional malware file to detect. The attacker is simply abusing the powerful administrative tools that are already present on the system."
                        },
                        {
                            "id": 2,
                            "question": "A type of malware that actively hides its own processes and files from the operating system is known as a:",
                            "options": [
                                "Trojan",
                                "Virus",
                                "Rootkit",
                                "Spyware"
                            ],
                            "correct": 2,
                            "explanation": "A rootkit's primary purpose is stealth and concealment. It achieves this by hooking or modifying core OS functions to lie to the user and to other security software."
                        },
                        {
                            "id": 3,
                            "question": "Why is memory forensics particularly effective against packed malware?",
                            "options": [
                                "It is not effective.",
                                "Because in order to run, the malware must unpack its true code into memory, which allows an analyst to dump the clean, unpacked version.",
                                "Because packed malware runs slower.",
                                "Because packed malware always writes a log file to disk."
                            ],
                            "correct": 1,
                            "explanation": "Packing only protects the malware while it is on the disk. The moment it executes, it must reveal its true form in memory. Memory analysis bypasses the on-disk protection completely."
                        }
                    ]
                }
            },
            {
                "id": "lesson-7",
                "title": "Network Artifacts in Memory",
                "duration": "90 min",
                "objectives": [
                    "Reconstruct active and recently closed network connections from a memory dump.",
                    "Analyze socket and port information to identify listening services.",
                    "Examine the in-memory DNS cache for evidence of domain resolution.",
                    "Extract the ARP and routing tables from memory.",
                    "Correlate network artifacts in memory with packet captures and firewall logs.",
                    "Trace malware command and control (C2) communications."
                ],
                "content": {
                    "overview": "A system's network activity provides a direct link to the outside world and is often the most critical evidence in an intrusion investigation. This lesson focuses on extracting the rich network-related artifacts that reside in memory, allowing an analyst to reconstruct the system's network connections at the exact moment of the memory dump.",
                    "sections": [
                        {
                            "title": "Reconstructing Network Connections",
                            "content": "<p>The operating system kernel keeps track of all network connections in its memory. By analyzing a memory dump, we can see exactly which remote hosts the system was talking to.</p><p>The `netscan` (Volatility 3) or `netstat` (Volatility 2) plugin is the primary tool for this. It can show:</p><ul><li><strong>Active Connections:</strong> A list of all TCP and UDP connections that were established at the time of the dump.</li><li><strong>Listening Ports:</strong> Which services on the system were listening for incoming connections.</li><li><strong>Recently Closed Connections:</strong> Often, the kernel retains information about connections that have recently been terminated.</li></ul><p><strong>Real-world Example: Tracking command and control communications.</strong> An analyst suspects a machine is compromised. They run `netscan` on a memory dump. They see hundreds of normal connections to Microsoft and Google, but one connection stands out: a TCP connection on port 443 to a rare, unknown domain registered in a foreign country. This is a huge red flag and a strong indicator of a C2 channel. The analyst now has a high-confidence IoC (the domain name) to pivot to their firewall logs and see what other hosts have communicated with this domain.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "DNS and ARP Cache Analysis",
                            "content": "<p>Other key network artifacts can also be extracted from memory.</p><h3>In-Memory Caches:</h3><ul><li><strong>DNS Cache:</strong> When a computer visits `www.google.com`, it performs a DNS lookup to get the IP address. The OS caches this result in memory for a short time. Analyzing this cache can reveal what domains the system has recently resolved, even if the activity doesn't show up elsewhere.</li><li><strong>ARP Cache:</strong> The Address Resolution Protocol (ARP) maps IP addresses to the physical MAC addresses on the local network. The ARP cache in memory shows which other hosts on the local network the system was communicating with. This can be used to track an attacker's lateral movement.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Correlating with Network-Based Evidence",
                            "content": "<p>Memory forensics is most powerful when it is correlated with other evidence sources.</p><p>An analyst finds a suspicious network connection in a memory dump. They now have four key pieces of information:</p><ol><li>The malicious remote IP address.</li><li>The local port and remote port.</li><li>The process on the local machine that was responsible for the connection.</li><li>The time of the memory dump.</li></ol><p>They can now take this information and pivot to their network-based evidence. They can search the firewall logs or full packet captures (PCAPs) for that specific IP address and port combination around that specific time. This allows them to see the *content* of the communication and understand what data was being sent or received over the C2 channel.</p>",
                            "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Network Artifact Extraction Tool (Volatility)",
                            "language": "bash",
                            "code": "# This script demonstrates using Volatility to extract key network artifacts from a memory dump.\n\nMEMORY_FILE=\"compromised_host.mem\"\n\n# 1. Get a list of active and recently closed network connections.\n# This is the most important first step.\nvol -f $MEMORY_FILE windows.netscan > netscan.txt\n\n# 2. Extract the in-memory DNS cache.\n# This can reveal domains the host has recently communicated with.\nvol -f $MEMORY_FILE windows.dnscache > dnscache.txt\n\n# 3. Extract the ARP cache.\n# This shows which other hosts on the local network the machine was talking to.\nvol -f $MEMORY_FILE windows.arp > arp.txt\n\n# 4. An analyst would now review these text files.\n# They would look for suspicious IP addresses or domains in the netscan and dnscache output.\n# They would then use the arp output to see if the compromised host was communicating with\n# other sensitive servers on the same subnet.\n\necho \"Network artifact extraction complete.\""
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "Which Volatility plugin is the primary tool for listing active and recently closed network connections from a memory dump?",
                            "options": [
                                "pslist",
                                "dlllist",
                                "netscan",
                                "hashdump"
                            ],
                            "correct": 2,
                            "explanation": "`netscan` is specifically designed to parse the kernel's networking data structures to reconstruct a view of the system's network activity at the time of the dump."
                        },
                        {
                            "id": 2,
                            "question": "What kind of information can be found in the in-memory DNS cache?",
                            "options": [
                                "A list of running processes.",
                                "A list of domain names that the system has recently resolved to IP addresses.",
                                "The contents of the user's command prompt.",
                                "A list of all files on the hard drive."
                            ],
                            "correct": 1,
                            "explanation": "The DNS cache is a valuable artifact that shows which domains a system has been communicating with. It can be useful for identifying C2 domains or other suspicious communications."
                        },
                        {
                            "id": 3,
                            "question": "An analyst finds a suspicious process in memory. What is the most effective way to determine if that process was communicating with a malicious server?",
                            "options": [
                                "Run the `pslist` and `netscan` plugins and correlate the process ID (PID) from `pslist` with the owner PID of a connection in `netscan`.",
                                "Look at the process's icon.",
                                "Check the file size of the process executable on disk.",
                                "Ask the user if they were doing anything suspicious."
                            ],
                            "correct": 0,
                            "explanation": "This correlation is a fundamental memory analysis technique. `pslist` tells you *what* was running, and `netscan` tells you *what* was communicating. By linking the PID between the two outputs, you can prove that a specific process was responsible for a specific network connection."
                        }
                    ]
                }
            },
            {
                "id": "lesson-8",
                "title": "Registry and System Configuration Analysis",
                "duration": "90 min",
                "objectives": [
                    "Understand how the Windows Registry is represented in memory.",
                    "Reconstruct registry hives from a memory dump.",
                    "Analyze loaded services and drivers for persistence mechanisms.",
                    "Identify startup programs and scheduled tasks from in-memory artifacts.",
                    "Extract user profile information and security policies from memory.",
                    "Track system modifications and configuration changes."
                ],
                "content": {
                    "overview": "The Windows Registry is a central database of configuration settings, and a goldmine of forensic evidence. While it exists on disk, the operating system loads large parts of it into memory at boot time. This lesson covers how to analyze the 'live' registry directly from a memory dump to find malware persistence, loaded drivers, and system configuration information.",
                    "sections": [
                        {
                            "title": "In-Memory Registry Analysis",
                            "content": "<p>When Windows is running, it loads the registry hive files (like NTUSER.DAT, SYSTEM, SOFTWARE) into kernel memory for fast access. This means we can analyze the registry without having to extract the files from the disk image.</p><h3>Why Analyze the Registry in Memory?</h3><ul><li><strong>It's Faster:</strong> It can be quicker to dump and analyze registry keys from memory than to mount a full disk image.</li><li><strong>It Can Reveal Hidden Keys:</strong> Some advanced rootkits can 'hook' the APIs used to read the registry from disk, hiding their malicious keys. These hooks may not be active against a memory analysis tool, revealing the hidden keys.</li><li><strong>It Shows Volatile Keys:</strong> Some registry keys exist only while the system is running and are not saved to disk.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1547082231-641517543cb3?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Detecting Registry-Based Persistence",
                            "content": "<p>The Registry is the most common place for malware to establish persistence—the ability to survive a reboot.</p><p><strong>Real-time Problem: Detecting registry-based persistence.</strong> An analyst is investigating a memory dump from a machine that is believed to be part of a botnet. They use Volatility's `printkey` plugin to examine the most common startup locations in the registry. When they examine the `Microsoft\\Windows\\CurrentVersion\\Run` key, they find a suspicious entry named 'WindowsUpdate' that points to an executable in a strange location (`C:\\Users\\Admin\\AppData\\Local\\Temp\\wupdate.exe`). This is a classic malware persistence technique. The analyst can now use other memory forensics techniques to find the running 'wupdate.exe' process and use disk forensics to recover the file for analysis.</p><h3>Common Persistence Keys:</h3><ul><li>`HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run`</li><li>`HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run`</li><li>`HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce`</li></ul>",
                            "image": "https://images.unsplash.com/photo-1520923642038-b42594705955?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Analyzing Services and Drivers",
                            "content": "<p>Attackers often install malicious services or drivers to gain persistent, high-level access to a system.</p><h3>Volatility Plugins:</h3><ul><li><strong>`svcscan`:</strong> This plugin scans memory for the data structures that define system services. It can show all services, whether they are running or stopped, and the command used to launch them. An analyst looks for services with suspicious names or executable paths.</li><li><strong>`modules` / `driverscan`:</strong> These plugins list the loaded kernel modules and drivers. This is a key way to find rootkits, which often operate as malicious drivers. An analyst looks for drivers that are not signed by Microsoft or that have suspicious names.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Registry Timeline Reconstruction Tool (Volatility)",
                            "language": "bash",
                            "code": "# This script uses the 'timeliner' plugin in Volatility to extract all registry-related\n# timestamps from a memory dump, helping to build a timeline of activity.\n\nMEMORY_FILE=\"compromised_host.mem\"\n\n# The timeliner plugin can take various sources. Here, we specify 'registry'.\n# This will scan memory for registry hives and extract the 'Last Write' time\n# for every single key in those hives.\n\nvol -f $MEMORY_FILE windows.registry.timeliner > registry_timeline.txt\n\n# The output is a CSV or bodyfile format list of timestamps and registry key paths.\n# An analyst can now sort this timeline to see what keys were modified recently.\n\n# Example: An analyst sorts the timeline and sees that a 'Run' key was modified\n# just a few seconds before a suspicious network connection was made. This correlates\n# the installation of a persistence mechanism with the malware's C2 activity."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is a primary advantage of analyzing the Windows Registry from a memory dump instead of from the disk?",
                            "options": [
                                "It is the only way to see the registry.",
                                "It allows an analyst to see the 'live' state of the registry and potentially uncover keys hidden by a rootkit.",
                                "The registry on disk is always encrypted.",
                                "There is no advantage."
                            ],
                            "correct": 1,
                            "explanation": "Analyzing the live hives in memory can bypass certain types of rootkits that hook disk-based APIs to hide their registry keys. It provides a different and often more truthful view of the registry's state."
                        },
                        {
                            "id": 2,
                            "question": "An attacker wants their malware to automatically run every time a user logs in. Which of the following is the most common registry key they would use for this?",
                            "options": [
                                "The SAM hive",
                                "`HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run`",
                                "The SYSTEM hive",
                                "`HKLM\\HARDWARE`"
                            ],
                            "correct": 1,
                            "explanation": "The 'Run' keys (both in HKEY_LOCAL_MACHINE for all users and HKEY_CURRENT_USER for a specific user) are the most common and well-known locations for legitimate and malicious programs to establish startup persistence."
                        },
                        {
                            "id": 3,
                            "question": "Which Volatility plugin would an analyst use to list all loaded kernel drivers to look for a potential rootkit?",
                            "options": [
                                "pslist",
                                "netscan",
                                "cmdline",
                                "driverscan"
                            ],
                            "correct": 3,
                            "explanation": "The `driverscan` and `modules` plugins are specifically designed to enumerate the drivers and kernel modules loaded in memory. This is the primary method for identifying suspicious or unsigned drivers that could be part of a rootkit."
                        }
                    ]
                }
            },
            {
                "id": "lesson-9",
                "title": "User Activity and Behavioral Analysis",
                "duration": "90 min",
                "objectives": [
                    "Reconstruct a user's interactive session from memory.",
                    "Identify which applications a user was running.",
                    "Recover fragments of documents, emails, and web pages from process memory.",
                    "Extract clipboard contents and search queries from memory.",
                    "Reconstruct a timeline of user interaction.",
                    "Use memory artifacts to perform behavioral anomaly detection."
                ],
                "content": {
                    "overview": "Memory contains a snapshot of a user's digital life at a specific moment in time. This lesson focuses on the techniques used to reconstruct a user's activity by analyzing the memory of the applications they were using. We will learn how to pull command history, clipboard contents, and even fragments of viewed documents directly from a RAM dump.",
                    "sections": [
                        {
                            "title": "Reconstructing Command-Line Activity",
                            "content": "<p>What an attacker types into a command prompt (`cmd.exe`) or PowerShell console can be a goldmine of evidence. This history is stored in the memory of the console process.</p><h3>Volatility Plugins:</h3><ul><li><strong>`cmdline`:</strong> Shows the command line arguments used to launch every process.</li><li><strong>`consoles`:</strong> This is the key plugin. It scans memory for console buffers and can dump the entire command history—both the commands the user typed and the output they received.</li></ul><p><strong>Real-World Example: Reconstructing insider threat activities.</strong> An analyst is investigating an insider who is suspected of stealing data. The insider was careful and did not use the GUI. The analyst uses the `consoles` plugin on a memory dump of the insider's machine. The output shows a command history where the user connected to a sensitive database server, ran a query to dump a customer table, compressed it into a ZIP file, and then copied it to a network share. The console history provides a perfect, step-by-step log of the entire crime.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Extracting Data from Application Memory",
                            "content": "<p>The data a user is actively working with often resides unencrypted in the memory of the application process.</p><h3>Common Artifacts:</h3><ul><li><strong>Clipboard (`clipboard` plugin):</strong> The contents of the user's clipboard at the time of the memory dump can be recovered. This might contain copied passwords, sensitive data, or messages.</li><li><strong>Web Browser Memory:</strong> An analyst can dump the memory of a browser process (`chrome.exe`) and then run the `strings` command on it to find fragments of web pages visited, search queries, and usernames.</li><li><strong>Document Fragments:</strong> Similarly, dumping the memory of `winword.exe` might reveal fragments of a document the user was viewing, even if it was never saved to disk.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "User Interaction Timeline",
                            "content": "<p>By combining various artifacts, an analyst can build a surprisingly detailed timeline of a user's recent activity.</p><h3>Example Timeline Correlation:</h3><ol><li>Volatility's `screenshot` plugin shows what was visible on the screen.</li><li>The `consoles` plugin shows what was typed into a command prompt.</li><li>A memory dump of `chrome.exe` shows the web page they were viewing.</li><li>The `clipboard` plugin shows what they last copied.</li></ol><p>By putting these pieces together, an analyst can move beyond just listing artifacts to telling the story of exactly what the user was doing at the moment the memory was captured.</p>",
                            "image": "https://images.unsplash.com/photo-1552664730-d307ca884978?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "User Activity Profiling System (Volatility)",
                            "language": "bash",
                            "code": "# This script automates the extraction of key user activity artifacts for profiling.\n\nMEMORY_FILE=\"user_activity.mem\"\n\n# 1. Get a list of running processes to identify user applications (e.g., chrome, outlook)\nvol -f $MEMORY_FILE windows.pslist > user_processes.txt\n\n# 2. Dump the command history from all console sessions\nvol -f $MEMORY_FILE windows.cmdline > user_cmdline.txt\nvol -f $MEMORY_FILE windows.consoles > user_consoles.txt\n\n# 3. Extract the contents of the clipboard\nvol -f $MEMORY_FILE windows.clipboard > user_clipboard.txt\n\n# 4. Take a virtual screenshot of the desktop\nvol -f $MEMORY_FILE windows.screenshot -o user_screenshot.png\n\n# 5. An analyst would review these files to build a profile of user activity.\n# For example, the screenshot might show an open document, while the clipboard\n# contains a paragraph of text copied from that document, and the consoles output\n# shows a command being typed to exfiltrate a file."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "Which Volatility plugin is the most effective for recovering the full command history, including both commands and their output, from a `cmd.exe` session?",
                            "options": [
                                "pslist",
                                "cmdline",
                                "consoles",
                                "netscan"
                            ],
                            "correct": 2,
                            "explanation": "While `cmdline` shows how a process was started, `consoles` is the more powerful plugin that parses the console host's memory buffer to reconstruct a full history of the user's interactive session."
                        },
                        {
                            "id": 2,
                            "question": "What kind of sensitive information can often be recovered by analyzing the memory of a web browser process?",
                            "options": [
                                "The computer's BIOS password.",
                                "Fragments of web pages, search queries, and usernames.",
                                "A list of all files on the hard drive.",
                                "The computer's product key."
                            ],
                            "correct": 1,
                            "explanation": "The memory space of a running browser is rich with artifacts of the user's recent activity. Even if the on-disk history is cleared, traces of this activity often remain in RAM."
                        },
                        {
                            "id": 3,
                            "question": "An analyst wants to see what was on the user's screen at the time of the memory acquisition. Which Volatility plugin should they use?",
                            "options": [
                                "clipboard",
                                "pslist",
                                "screenshot",
                                "memdump"
                            ],
                            "correct": 2,
                            "explanation": "The `screenshot` plugin is a powerful visualization tool that can parse the Windows graphics subsystem data in memory to reconstruct a reasonably accurate image of what the desktop looked like at the time of the dump."
                        }
                    ]
                }
            },
            {
                "id": "lesson-10",
                "title": "Cryptographic and Security Analysis",
                "duration": "100 min",
                "objectives": [
                    "Understand how and where encryption keys are stored in memory.",
                    "Apply techniques to extract full-disk encryption keys (e.g., BitLocker) from a memory dump.",
                    "Recover password hashes from memory for offline cracking.",
                    "Examine certificate and key stores for cryptographic evidence.",
                    "Analyze secure communication protocols and identify potential weaknesses.",
                    "Discuss the future challenges of post-quantum cryptography for memory forensics."
                ],
                "content": {
                    "overview": "Encryption is the cornerstone of modern security, but for a system to use encrypted data, the keys must exist somewhere in memory. This lesson focuses on the high-stakes process of extracting cryptographic artifacts—from password hashes to full-disk encryption keys—directly from a RAM dump, providing the 'keys to the kingdom' in an investigation.",
                    "sections": [
                        {
                            "title": "Extracting Full-Disk Encryption Keys",
                            "content": "<p>This is one of the most powerful applications of memory forensics. If a machine with full-disk encryption (like BitLocker or FileVault) is running and unlocked, the keys needed to decrypt the entire drive *must* be present in RAM.</p><p><strong>Real-world Problem: Extracting encryption keys from memory.</strong> An investigator seizes a running laptop that is encrypted with BitLocker. They immediately perform a live memory acquisition. They then take the memory dump and the (still encrypted) forensic image of the hard drive back to the lab. Using a Volatility plugin or a specialized tool like Elcomsoft Forensic Disk Decryptor, they scan the memory dump for the BitLocker Volume Master Key (VMK). Once the key is found, they can use it to instantly and completely decrypt the hard drive image, giving them access to the entire file system. Without the memory dump, the hard drive image would have been a useless, encrypted blob.</p>",
                            "image": "https://images.unsplash.com/photo-1548092372-2d987bde898b?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Password Hash Analysis in Memory",
                            "content": "<p>Windows does not store user passwords in plaintext. It stores them as cryptographic hashes in a database called the SAM (Security Account Manager). Attackers often try to steal these hashes to crack them offline or use them in 'pass-the-hash' attacks.</p><h3>The `hashdump` Plugin:</h3><p>The `hashdump` plugin in Volatility can parse the memory of the LSASS (Local Security Authority Subsystem Service) process to extract the user password hashes directly from RAM. This is often more effective than trying to extract the SAM file from disk, as the SAM file is locked while Windows is running. These recovered hashes can then be put into a password cracker like John the Ripper or Hashcat.</p>",
                            "image": "https://images.unsplash.com/photo-1555949963-ff9fe0c870eb?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Other Cryptographic Artifacts",
                            "content": "<p>Memory can contain a wide variety of other secret material.</p><h3>Potential Finds:</h3><ul><li><strong>Private Keys:</strong> The private keys for TLS certificates or SSH keys might be present in the memory of a web server or an administrator's SSH client.</li><li><strong>API Keys and Tokens:</strong> Application secrets, API keys, and connection strings are often stored in a process's memory.</li><li><strong>Plaintext Passwords:</strong> While less common in modern applications, some older or poorly written software might keep user passwords in memory as plaintext, which can be found with a simple `strings` search.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1629654297299-c8506221ca97?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Cryptographic Artifact Extraction (Volatility)",
                            "language": "bash",
                            "code": "# This script demonstrates the Volatility commands for extracting common cryptographic secrets.\n\nMEMORY_FILE=\"encrypted_host.mem\"\n\n# 1. Extract Windows password hashes from the LSASS process memory.\n# This is a critical step in many investigations.\nvol -f $MEMORY_FILE windows.hashdump > password_hashes.txt\n\n# An analyst would now take the hashes in password_hashes.txt and attempt to crack them.\n\n# 2. Extract BitLocker keys.\n# This plugin searches memory for the specific structures that hold FDE keys.\nvol -f $MEMORY_FILE windows.bitlocker > bitlocker_keys.txt\n\n# 3. Extract DPAPI keys.\n# The Data Protection API is used by Windows to encrypt many user secrets, like saved passwords.\nvol -f $MEMORY_FILE windows.dpapi.masterkeys > dpapi_keys.txt\n\necho \"Cryptographic artifact extraction complete.\""
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "If a system is using full-disk encryption like BitLocker, where must the encryption keys reside while the system is running and unlocked?",
                            "options": [
                                "On the hard drive in a text file.",
                                "In the system's RAM.",
                                "On a remote server.",
                                "They are not stored anywhere."
                            ],
                            "correct": 1,
                            "explanation": "For the CPU to be able to read and write data from the encrypted disk, the decryption keys must be loaded into memory (RAM). This is the fundamental reason why live memory acquisition is so critical for encrypted systems."
                        },
                        {
                            "id": 2,
                            "question": "Which Volatility plugin is used to extract Windows user password hashes from the memory of the LSASS process?",
                            "options": [
                                "pslist",
                                "netscan",
                                "hashdump",
                                "cmdline"
                            ],
                            "correct": 2,
                            "explanation": "`hashdump` is the specific plugin designed to find and parse the data structures within the LSASS process's memory where password hashes are stored."
                        },
                        {
                            "id": 3,
                            "question": "What is the primary goal of extracting password hashes from memory?",
                            "options": [
                                "To change the user's password.",
                                "To use the hashes in a password cracking tool (like Hashcat) to try and recover the original plaintext password.",
                                "To prove that the user had a strong password.",
                                "To delete the user's account."
                            ],
                            "correct": 1,
                            "explanation": "Password hashes are a one-way function, but by guessing passwords, hashing them, and comparing them to the stolen hash, an attacker or investigator can often recover weak or common passwords. The hashes are the input for an offline password cracking attack."
                        }
                    ]
                }
            },
            {
                "id": "lesson-11",
                "title": "Advanced Persistence Mechanism Detection",
                "duration": "100 min",
                "objectives": [
                    "Identify memory signatures of Advanced Persistent Threats (APTs).",
                    "Perform kernel-level analysis to detect malicious drivers and hooks.",
                    "Investigate firmware-level compromises (UEFI/BIOS).",
                    "Understand how to detect hypervisor-level persistence.",
                    "Analyze memory for indicators of advanced evasion techniques (e.g., direct system calls).",
                    "Hunt for zero-day exploit artifacts in memory."
                ],
                "content": {
                    "overview": "The most sophisticated adversaries, like nation-state APT groups, use advanced techniques to hide their presence and maintain long-term access to a system. This lesson covers the advanced memory forensics techniques required to hunt for these threats, moving beyond simple process analysis to the deep, kernel-level analysis needed to uncover rootkits, firmware implants, and other stealthy persistence mechanisms.",
                    "sections": [
                        {
                            "title": "Kernel-Level Persistence: Rootkits and Drivers",
                            "content": "<p>Kernel-mode rootkits are the holy grail for an attacker because they operate at the highest privilege level of the operating system. They can intercept and modify any system function.</p><h3>Detection in Memory:</h3><ul><li><strong>Driver Analysis (`driverscan`):</strong> A key technique is to look for unsigned drivers. While some legitimate third-party drivers are unsigned, any unsigned driver is suspicious and requires investigation.</li><li><strong>System Call Table Hooking (`ssdt`):</strong> A rootkit might modify the System Service Descriptor Table (SSDT), which is the list of core OS functions. It can replace the address of a legitimate function (like `NtCreateFile`) with the address of its own malicious function. Volatility's `ssdt` plugin can check this table for such hooks.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1504384308090-c894fdcc538d?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Firmware and Hypervisor-Level Compromise",
                            "content": "<p>The most advanced attackers can achieve persistence even below the operating system.</p><ul><li><strong>UEFI/BIOS Implants:</strong> A malicious implant in the system's firmware will execute *before* the operating system even boots. It can then inject malware into the OS as it loads. This is extremely difficult to detect.</li><li><strong>Hypervisor-Level Persistence:</strong> If an attacker can compromise the hypervisor (the software that runs virtual machines), they have complete control over all guest VMs and are invisible to any security software running inside those VMs.</li></ul><p><strong>Real-world Example: Investigating nation-state malware.</strong> An analyst is investigating a machine compromised by a suspected APT. Standard memory analysis shows no obvious malware. However, using the `idt` plugin to inspect the Interrupt Descriptor Table, they find that one of the system's interrupt handlers points to a strange, unbacked region of memory. This is an indicator of an advanced kernel-mode rootkit. Further analysis using `malfind` on kernel memory reveals the hidden implant, which was designed to be invisible to normal process and driver scans.</p>",
                            "image": "https://images.unsplash.com/photo-1593435713588-a73de23947db?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Advanced Evasion Techniques",
                            "content": "<p>Attackers are constantly developing ways to evade detection by EDR and other security tools.</p><h3>Direct System Calls:</h3><p>Many security tools work by 'hooking' common Windows API functions (like `CreateProcess`). To bypass this, some malware will avoid the API call and communicate with the kernel directly using a 'system call'. Volatility plugins can help detect this by looking for unusual code patterns in user-mode processes that are making direct system calls, a behavior that is highly indicative of malware trying to evade detection.</p>",
                            "image": "https://images.unsplash.com/photo-1548092372-2d987bde898b?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Multi-Layer Persistence Detection System (Volatility)",
                            "language": "bash",
                            "code": "# This script combines multiple Volatility plugins to hunt for advanced persistence.\n\nMEMORY_FILE=\"apt_compromised.mem\"\n\n# 1. Look for hidden processes (rootkit detection)\nvol -f $MEMORY_FILE windows.psscan > psscan.txt\n# The analyst would compare the output of psscan with pslist to find discrepancies.\n\n# 2. Check for hooks in the kernel's system call table\nvol -f $MEMORY_FILE windows.ssdt > ssdt.txt\n# The analyst looks for any entries that point to memory outside of the main kernel image (ntoskrnl.exe).\n\n# 3. Check for unsigned drivers\nvol -f $MEMORY_FILE windows.driverscan | grep \"False\" > unsigned_drivers.txt\n# This command filters the driverscan output to show only drivers that are not digitally signed.\n\n# 4. Check common registry persistence locations\nvol -f $MEMORY_FILE windows.registry.printkey -K \"Microsoft\\Windows\\CurrentVersion\\Run\" > run_keys.txt\n\necho \"Advanced persistence checks complete. Review output files.\""
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "A rootkit that modifies core operating system functions to hide its presence is operating in which memory space?",
                            "options": [
                                "User Space",
                                "The Heap",
                                "The Stack",
                                "Kernel Space"
                            ],
                            "correct": 3,
                            "explanation": "Kernel-mode rootkits are the most powerful because they run with the same privilege level as the OS kernel itself, allowing them to intercept and modify any system operation."
                        },
                        {
                            "id": 2,
                            "question": "An analyst runs `pslist` and then `psscan` in Volatility and finds that `psscan` shows a process that `pslist` did not. What is this a strong indicator of?",
                            "options": [
                                "A normally functioning system.",
                                "A rootkit that is actively hiding a process by unlinking it from the operating system's process list.",
                                "A user who is browsing the internet.",
                                "A bug in the Volatility software."
                            ],
                            "correct": 1,
                            "explanation": "This is the classic technique for detecting hidden processes. `pslist` trusts the OS, while `psscan` does not. A discrepancy between the two is proof that the OS's data structures have been tampered with."
                        },
                        {
                            "id": 3,
                            "question": "The most advanced and persistent form of malware would infect which component of a computer?",
                            "options": [
                                "A user's document.",
                                "A web browser's cache.",
                                "The system's UEFI/BIOS firmware.",
                                "The Master File Table (MFT)."
                            ],
                            "correct": 2,
                            "explanation": "A firmware-level implant is the ultimate form of persistence. It runs before the OS, is not stored on the hard drive, and can survive a complete OS reinstall, making it extremely difficult to detect and remove."
                        }
                    ]
                }
            },
            {
                "id": "lesson-12",
                "title": "Memory Timeline and Correlation Analysis",
                "duration": "90 min",
                "objectives": [
                    "Understand the concept of creating a timeline from memory artifacts.",
                    "Correlate events across different memory artifacts (processes, network, registry).",
                    "Use cross-reference analysis to link related pieces of evidence.",
                    "Apply visualization methods to understand complex timelines.",
                    "Recognize patterns of activity that indicate a larger campaign.",
                    "Correlate memory evidence with on-disk and network evidence to create a master timeline."
                ],
                "content": {
                    "overview": "Individual artifacts are useful, but the real power of memory forensics comes from correlating them to tell a story. This lesson focuses on the art of timeline analysis: how to fuse data from multiple sources in memory and on disk to reconstruct the exact sequence of an attacker's actions and build a comprehensive narrative of the entire intrusion.",
                    "sections": [
                        {
                            "title": "Creating a Memory-Based Timeline",
                            "content": "<p>Many of the data structures in memory contain timestamps. By extracting all of these, we can create a detailed, chronological view of the system's recent activity.</p><h3>Volatility's `timeliner` Plugin:</h3><p>The `timeliner` plugin in Volatility is a powerful tool for this. It can automatically extract timestamped data from various sources within the memory dump, including:</p><ul><li>Process creation times.</li><li>Driver load times.</li><li>Registry key last write times.</li><li>Network connection start times.</li></ul><p>The output is a single, massive timeline of events that can be sorted and filtered to find interesting activity.</p>",
                            "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Correlation: The Key to a Coherent Story",
                            "content": "<p>The real investigative work is in correlating different events on the timeline to build a narrative.</p><p><strong>Real-time Problem: Correlating complex attack sequences.</strong> An analyst is reviewing a timeline created from a memory dump. They filter the timeline for events that happened in the last hour and see the following sequence:</p><ol><li><strong>14:30:15:</strong> A process named `evil.exe` is created (from `pslist` timestamps).</li><li><strong>14:30:20:</strong> A new registry key is written to `HKCU\\...\\Run` with the value `C:\\Users\\...\\evil.exe` (from registry timeliner).</li><li><strong>14:30:25:</strong> A new network connection is established to IP `198.51.100.55` by the process `evil.exe` (from `netscan` timestamps).</li><li><strong>14:30:30:</strong> A new kernel driver named `rootkit.sys` is loaded (from `modules` timestamps).</li></ol><p>By themselves, each is a single piece of data. Correlated on a timeline, they tell a clear story: The malware started, immediately established a persistence mechanism, connected to its C2 server, and then loaded a rootkit to hide itself. This is how a simple list of events becomes a compelling piece of evidence.</p>",
                            "image": "https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "The Master Timeline: Fusing Memory, Disk, and Network",
                            "content": "<p>The ultimate goal is to create a master 'super timeline' that fuses evidence from all three forensic disciplines.</p><h3>The Investigative Workflow:</h3><p>An investigator can use a tool like Plaso/Log2Timeline to automatically extract timestamps from every possible artifact on a disk image (file system, registry, logs, browser history, etc.). They can then merge this massive disk timeline with the timeline generated from the memory dump, and with timestamps from firewall and proxy logs.</p><p>The result is a single, unified view of the entire incident, allowing the analyst to pivot seamlessly from a network event, to a process being created in memory, to a file being written on disk. This is the pinnacle of a modern digital forensic investigation.</p>",
                            "image": "https://images.unsplash.com/photo-1563986768609-322da13575f3?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Advanced Timeline Correlation Engine (Plaso)",
                            "language": "bash",
                            "code": "# This example demonstrates the full-scale timeline analysis process using Plaso.\n\nDISK_IMAGE=\"case007.E01\"\nMEMORY_DUMP=\"case007.mem\"\n\n# Step 1: Create a timeline from the disk image using Plaso's log2timeline.\nlog2timeline.py disk_timeline.plaso $DISK_IMAGE\n\n# Step 2: Create a timeline from the memory dump using Volatility's timeliner.\n# The output format is specified as 'body' to be compatible with Plaso.\nvol -f $MEMORY_DUMP windows.registry.timeliner --output=body --output-file=registry_timeline.body\nvol -f $MEMORY_DUMP windows.pslist.pslist --output=body --output-file=process_timeline.body\n\n# Step 3: Parse the memory timelines into the Plaso format.\npsort.py -o plaso -w memory_timeline.plaso registry_timeline.body process_timeline.body\n\n# Step 4: Use a tool like Timesketch to load and analyze both the disk_timeline.plaso\n# and memory_timeline.plaso files together.\n\n# Step 5: An analyst can now run queries that correlate across both data sources.\n# For example, find a file creation event on disk and see what process in memory was running\n# at that exact second."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "Volatility's `timeliner` plugin is used for what purpose?",
                            "options": [
                                "To find hidden malware.",
                                "To list network connections.",
                                "To automatically extract timestamped events from various artifacts in memory to help build a timeline.",
                                "To dump password hashes."
                            ],
                            "correct": 2,
                            "explanation": "The `timeliner` plugin is a powerful automation tool that pulls together timestamps from processes, registry keys, drivers, and other sources into a single, chronologically sorted output."
                        },
                        {
                            "id": 2,
                            "question": "What is the primary goal of timeline correlation?",
                            "options": [
                                "To make the evidence look more confusing.",
                                "To create a simple list of files.",
                                "To tell a clear, narrative story of the incident by linking different pieces of evidence in chronological order.",
                                "To satisfy a legal requirement."
                            ],
                            "correct": 2,
                            "explanation": "Correlation turns a list of data points into a story. By sequencing events, an investigator can show cause and effect, which is the key to explaining what happened during an intrusion."
                        },
                        {
                            "id": 3,
                            "question": "A 'super timeline' in a major investigation is created by fusing data from which sources?",
                            "options": [
                                "Only from the hard disk.",
                                "Only from memory.",
                                "Only from network logs.",
                                "From memory, disk, and network evidence sources."
                            ],
                            "correct": 3,
                            "explanation": "The most comprehensive and powerful timeline comes from correlating evidence from all available sources. This allows an analyst to track an attacker's activity as it moves between the network, the operating system's memory, and the file system."
                        }
                    ]
                }
            },
            
        {
            "id": "lesson-13",
            "title": "Virtual Environment and Cloud Memory Forensics",
            "duration": "120 min",
            "objectives": [
                "Perform memory analysis on virtual machines (VMs).",
                "Understand the forensic challenges and techniques related to hypervisors.",
                "Conduct a forensic examination of container memory (e.g., Docker).",
                "Describe the methods for acquiring memory from cloud instances (IaaS).",
                "Analyze memory from serverless functions and other cloud-native technologies.",
                "Address the challenges of multi-tenant environments and data privacy."
            ],
            "content": {
                "overview": "As infrastructure moves from physical servers to virtualized and cloud-native environments, memory forensics must adapt. This lesson covers the techniques for acquiring and analyzing memory from virtual machines, containers, and cloud instances, addressing the unique challenges posed by these abstracted environments.",
                "sections": [
                    {
                        "title": "Virtual Machine Memory Analysis",
                        "content": "<p>Analyzing a virtual machine's memory is often simpler than a physical machine's because the hypervisor has direct control over the guest's memory state.</p><h3>Acquisition Methods:</h3><ul><li><strong>Suspend/Snapshot Files:</strong> Most hypervisors (like VMware and VirtualBox) create a file containing the full contents of a VM's RAM when you suspend it or take a snapshot that includes its memory state. For VMware, this is a `.vmem` file. This file can be copied and analyzed directly with Volatility as if it were a raw memory dump.</li><li><strong>Hypervisor-Level Tools:</strong> Hypervisors often have command-line tools or APIs that allow a privileged administrator to directly dump the memory of a running guest VM.</li></ul><p><strong>Real-world Example:</strong> A security team is alerted to a suspicious process running on a VM. Instead of logging into the VM and potentially tipping off the attacker, the administrator uses the hypervisor's tools (e.g., VMware vSphere's `vmss2core`) to take a snapshot of the VM's memory from the outside. They can then analyze this `.vmem` file offline to investigate the suspicious process without ever touching the live guest operating system.</p>",
                            "image": "https://images.unsplash.com/photo-1510915228340-29c85a43dcfe?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Cloud Instance Memory Acquisition",
                            "content": "<p>Acquiring memory from a cloud Infrastructure as a Service (IaaS) instance (like an AWS EC2 or Azure VM) requires using the cloud provider's APIs and tools.</p><h3>Cloud Provider Tools:</h3><ul><li><strong>AWS:</strong> Does not have a direct 'dump memory' API. The standard procedure is to use a snapshot-based approach with a third-party tool (e.g., Magnet AXIOM Cyber, Cado Response) that can be deployed to the instance to orchestrate the memory capture and acquisition of the disk snapshot.</li><li><strong>Azure:</strong> Has similar capabilities for acquiring snapshots of VMs for analysis.</li><li><strong>GCP:</strong> Offers similar disk snapshotting.</li></ul><p>The key challenge is that you have no physical access. All acquisition and analysis must be done remotely via APIs and specialized tools designed for the cloud.</p>",
                            "image": "https://images.unsplash.com/photo-1588196749597-9ff075ee6b5b?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Container and Serverless Forensics",
                            "content": "<p>These modern, ephemeral technologies present the greatest challenge to memory forensics.</p><ul><li><strong>Containers (Docker, Kubernetes):</strong> A container shares the kernel of the host OS. Its memory is part of a larger host process. Analysis often involves using tools on the host to inspect the memory of the specific container process or analyzing a core dump if the container crashes. The ephemeral nature of containers means the evidence might only exist for a few minutes.</li><li><strong>Serverless (AWS Lambda):</strong> A serverless function is even more ephemeral, running for just a few seconds to handle a single request. Memory forensics of a serverless function is practically impossible. The investigation must rely almost entirely on the detailed execution logs provided by the cloud platform.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1544197150-b99a580bb7a8?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Cloud Memory Acquisition Automation (Conceptual)",
                            "language": "python",
                            "code": "import boto3\n\n# This conceptual Python script uses the AWS API (Boto3) to automate the\n# *preparation* for memory forensics in the cloud by snapshotting the disk.\n\ndef acquire_ec2_snapshot(instance_id, region):\n    \"\"\"Creates a snapshot of an EC2 instance's root volume for forensic analysis.\"\"\"\n    ec2 = boto3.client('ec2', region_name=region)\n    print(f\"[*] Acquiring snapshot for instance {instance_id}\")\n\n    # In a real-world scenario, you would first deploy an agent to the instance\n    # to perform the memory dump to a separate, attached EBS volume, and then\n    # snapshot that volume along with the root disk.\n\n    # Get the root volume ID\n    response = ec2.describe_instances(InstanceIds=[instance_id])\n    root_volume_id = response['Reservations'][0]['Instances'][0]['RootDeviceName']\n    \n    # Create the snapshot\n    snapshot_response = ec2.create_snapshot(\n        VolumeId=root_volume_id,\n        Description=f\"Forensic snapshot for instance {instance_id}\"\n    )\n\n    print(f\"[+] Snapshot creation started: {snapshot_response['SnapshotId']}\")\n    print(\"[*] Analyst can now attach this snapshot to a forensic workstation in the cloud.\")\n\n# acquire_ec2_snapshot(\"i-0123456789abcdef0\", \"us-east-1\")"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "In VMware, what is the file extension for a file that contains a dump of a suspended virtual machine's memory?",
                            "options": [
                                ".vmdk",
                                ".vmem",
                                ".vdi",
                                ".raw"
                            ],
                            "correct": 1,
                            "explanation": "A .vmem file is created when a VMware VM is suspended, and it contains a raw, bit-for-bit copy of the guest's RAM, which can be directly analyzed by tools like Volatility."
                        },
                        {
                            "id": 2,
                            "question": "What is the primary challenge of performing memory forensics on serverless functions (like AWS Lambda)?",
                            "options": [
                                "They run for too long.",
                                "They are extremely ephemeral, running for only a few seconds, making it nearly impossible to capture their memory state.",
                                "They don't use memory.",
                                "They are always encrypted."
                            ],
                            "correct": 1,
                            "explanation": "The short-lived, transient nature of serverless functions is their key forensic challenge. By the time an analyst can react, the function and its memory are gone. Investigation must rely on logs."
                        },
                        {
                            "id": 3,
                            "question": "How is memory acquisition typically performed on a cloud instance like an AWS EC2 virtual machine?",
                            "options": [
                                "By calling AWS support and asking them to mail you the RAM chips.",
                                "Using a cold boot attack.",
                                "It cannot be done.",
                                "Using the cloud provider's APIs and specialized tools to orchestrate the memory dump and disk snapshotting process remotely."
                            ],
                            "correct": 3,
                            "explanation": "Cloud forensics is entirely API-driven. Since you have no physical access, you must use the tools and services provided by the cloud platform, often in conjunction with third-party forensic agents, to capture evidence remotely."
                        }
                    ]
                }
            },
            {
                "id": "lesson-14",
                "title": "Mobile and Embedded Device Memory Forensics",
                "duration": "100 min",
                "objectives": [
                    "Understand the memory architecture of mobile devices (ARM).",
                    "Discuss the challenges and methods for Android memory acquisition and analysis.",
                    "Explain the security features that make iOS memory forensics extremely difficult.",
                    "Analyze memory from IoT and other embedded systems.",
                    "Detect mobile malware and suspicious application behavior in memory.",
                    "Correlate memory artifacts with evidence from mobile disk forensics."
                ],
                "content": {
                    "overview": "Mobile and embedded devices present a unique and difficult challenge for memory forensics. Their locked-down architectures, specialized hardware, and security features require advanced techniques to acquire and analyze volatile data. This lesson explores the current state of the art in this rapidly evolving field.",
                    "sections": [
                        {
                            "title": "Android Memory Forensics",
                            "content": "<p>Android's more open, Linux-based nature makes memory forensics more feasible than on iOS, but it is still challenging.</p><h3>Acquisition Methods:</h3><ul><li><strong>Rooted Devices:</strong> On a rooted device, an analyst can use tools like `dd` or specialized apps to directly access and dump the physical memory.</li><li><strong>Vulnerability Exploits:</strong> For unrooted devices, acquisition often relies on using a specific vulnerability in the Android OS to temporarily gain the root-level privileges needed to dump the RAM.</li></ul><h3>Analysis:</h3><p>An Android memory dump can be analyzed with Volatility, which has profiles for many Android kernel versions. An analyst can reconstruct the process list, network connections, and extract data from application memory just like on a Linux system.</p>",
                            "image": "https://images.unsplash.com/photo-1610465213254-2c35a8276b4a?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "iOS Memory Forensics: A Major Challenge",
                            "content": "<p>Performing a full memory acquisition and analysis on a modern, up-to-date iPhone is considered nearly impossible for almost all practitioners due to Apple's strong security posture.</p><h3>Security Obstacles:</h3><ul><li><strong>Secure Enclave & Hardware Protections:</strong> Critical cryptographic keys are protected by dedicated hardware, and numerous hardware-level security features prevent unauthorized memory access.</li><li><strong>Locked-Down OS:</strong> Without a public 'jailbreak' (an exploit that bypasses the OS's security), it is not possible to get the privileges needed to run a memory acquisition tool.</li></ul><p><strong>Real-world Example:</strong> Most modern iOS investigations have to rely on logical extractions (iTunes backups) and cloud data (iCloud backups). While these are rich sources, they do not provide the deep, volatile data that memory forensics can. The analysis of sophisticated, memory-resident malware on iOS is a capability generally reserved for nation-state intelligence agencies and a handful of specialized private companies.</p>",
                            "image": "https://images.unsplash.com/photo-1585255428357-ac758950454a?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "IoT and Embedded System Forensics",
                            "content": "<p>IoT devices (like smart cameras, routers, and DVRs) are a growing area of interest.</p><p><strong>Real-time Problem: Analyzing a compromised IoT botnet.</strong> An organization's network is being used to launch a DDoS attack. The source is traced to a fleet of compromised security cameras. The analyst needs to understand the malware. They gain access to one of the cameras via a debug port (JTAG) or a known exploit. They then use specialized tools to dump the RAM of the small, Linux-based embedded system. Analyzing the memory dump with Volatility (using a custom Linux ARM profile) reveals the running botnet malware process and its C2 server address. This IoC can then be used to find and clean all other infected cameras on the network.</p>",
                            "image": "https://images.unsplash.com/photo-1535683416248-8495c6b8159b?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Mobile Memory Analysis Toolkit (Frida)",
                            "language": "javascript",
                            "code": "// Frida is a dynamic instrumentation toolkit, not a traditional forensics tool,\n// but it can be used for live memory analysis on mobile apps (on a rooted/jailbroken device).\n// This script attaches to the Telegram app and hooks the function used for sending messages.\n\nif (Java.available) {\n    Java.perform(function() {\n        // Target the 'SendMessagesHelper' class and its 'sendMessage' method\n        var SendMessagesHelper = Java.use('org.telegram.messenger.SendMessagesHelper');\n        SendMessagesHelper.sendMessage.overload('java.lang.String', 'long').implementation = function(message, dialog_id) {\n            \n            // Log the message content before it is sent\n            console.log(\"[+] Intercepted outgoing message:\");\n            console.log(\"    To: \" + dialog_id);\n            console.log(\"    Message: \" + message);\n\n            // Call the original function to let the message send normally\n            return this.sendMessage(message, dialog_id);\n        };\n    });\n}"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "Which mobile operating system is generally more feasible for memory forensics due to its more open nature?",
                            "options": [
                                "iOS",
                                "Android",
                                "Windows Phone",
                                "BlackBerry OS"
                            ],
                            "correct": 1,
                            "explanation": "While still challenging, Android's Linux foundation and the availability of rooted devices make memory acquisition and analysis significantly more accessible than on Apple's highly locked-down iOS."
                        },
                        {
                            "id": 2,
                            "question": "What is the primary reason that full memory acquisition from a modern, fully-patched iPhone is nearly impossible for most investigators?",
                            "options": [
                                "iPhones do not have enough RAM.",
                                "A combination of strong hardware security (like the Secure Enclave) and a locked-down operating system that prevents gaining the necessary privileges.",
                                "The files are too big.",
                                "Volatility does not support iOS."
                            ],
                            "correct": 1,
                            "explanation": "Apple's deep integration of hardware and software security creates multiple layers of protection that effectively prevent the kind of low-level access required to dump the full contents of RAM."
                        },
                        {
                            "id": 3,
                            "question": "When investigating a compromised IoT device that is part of a botnet, what is the most critical piece of information to recover from its memory?",
                            "options": [
                                "The device's uptime.",
                                "The list of saved Wi-Fi networks.",
                                "The address of the attacker's Command and Control (C2) server.",
                                "The device's serial number."
                            ],
                            "correct": 2,
                            "explanation": "Identifying the C2 server is the most critical intelligence gain. This IoC can then be used to hunt for other infected devices on the network and to block the C2 traffic at the firewall, disrupting the entire botnet."
                        }
                    ]
                }
            },
            {
                "id": "lesson-15",
                "title": "Database and Application Memory Analysis",
                "duration": "90 min",
                "objectives": [
                    "Analyze database buffers in memory for cached queries and data.",
                    "Examine an application's heap to recover data structures and user content.",
                    "Reconstruct the state of an application from its memory.",
                    "Perform memory-based data recovery for unsaved work.",
                    "Analyze the memory of web applications to find session data and secrets.",
                    "Investigate enterprise applications for sensitive business data."
                ],
                "content": {
                    "overview": "Beyond the operating system, the memory space of individual applications is a rich source of evidence. This lesson explores how to dive into the memory of specific processes—from databases to web browsers to custom enterprise applications—to extract the data they were actively working with.",
                    "sections": [
                        {
                            "title": "Database Buffer Analysis",
                            "content": "<p>To improve performance, database servers like SQL Server and MySQL maintain a large 'buffer cache' or 'buffer pool' in RAM. This cache holds recently accessed data pages from the database files on disk.</p><h3>Forensic Value:</h3><ul><li><strong>Access to Live Data:</strong> An analyst can examine this buffer cache in a memory dump to see what data was being actively queried and worked with at the time of the incident.</li><li><strong>Recovery of Deleted Data:</strong> Sometimes, a data page containing a now-deleted record might still exist in the buffer cache even if it has been overwritten on disk.</li></ul><p><strong>Real-world Example: Reconstructing database transactions from memory.</strong> A database server is compromised, and the attacker tries to cover their tracks by deleting the on-disk transaction logs. However, the investigator acquires a memory dump of the running `sqlservr.exe` process. By parsing the buffer cache in memory, they can find the data pages the attacker was modifying and can reconstruct the fraudulent transactions, even without the disk-based logs.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Application Heap Examination",
                            "content": "<p>The heap is the region of a process's memory used for dynamic allocation. It's where an application stores most of its working data.</p><h3>Common Artifacts Found on the Heap:</h3><ul><li><strong>User Content:</strong> In a text editor process, the entire contents of an unsaved document may be found on the heap.</li><li><strong>Configuration Data:</strong> An application might load its configuration settings into memory on the heap.</li><li><strong>Sensitive Data:</strong> Passwords, API keys, and connection strings are often stored in variables that reside on the heap.</li></ul><p>The process is to first dump the memory of the target process using a tool like Volatility (`memdump`), and then analyze the resulting file with tools like `strings` or specialized parsers.</p>",
                            "image": "https.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Web Application Memory Forensics",
                            "content": "<p>The memory of a web server process (like Apache, Nginx, or IIS) is a particularly rich environment.</p><h3>Potential Evidence:</h3><ul><li><strong>User Session Data:</strong> Session IDs, usernames, and other user-specific data may be present in memory.</li><li><strong>Decrypted Web Traffic:</strong> If the web server is handling HTTPS traffic, the unencrypted plaintext of recent requests and responses will exist in the server's process memory. This can be a way to read encrypted traffic without needing the server's private key.</li><li><strong>Web Shell Code:</strong> If the server was compromised with a web shell, the code of that web shell may be found in the memory of the web server process.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1555949963-ff9fe0c870eb?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Application Memory Profiler (Volatility)",
                            "language": "bash",
                            "code": "# This script demonstrates a workflow for dumping and analyzing the memory of a specific application.\n\nMEMORY_FILE=\"compromised_server.mem\"\nTARGET_PROCESS=\"notepad.exe\" # The process we want to investigate\n\n# 1. Find the Process ID (PID) of the target process.\n# We use 'pslist' and grep to find our target.\nPID=$(vol -f $MEMORY_FILE windows.pslist | grep $TARGET_PROCESS | awk '{print $1}')\n\nif [ -z \"$PID\" ]; then\n    echo \"Process $TARGET_PROCESS not found in memory dump.\"\n    exit 1\nfi\n\necho \"[*] Found $TARGET_PROCESS with PID: $PID\"\n\n# 2. Dump the entire memory space of that specific process to a file.\nPROCESS_DUMP_FILE=\"notepad_memory.dmp\"\necho \"[*] Dumping process memory to $PROCESS_DUMP_FILE...\"\nvol -f $MEMORY_FILE windows.memmap.Memmap --pid $PID --dump\n# Assuming the dump is created with a predictable name, or we find it.\n\n# 3. Run 'strings' against the process dump to find readable text.\n# This is a simple but effective way to find user content, passwords, etc.\necho \"[*] Searching for readable strings in process dump...\"\nstrings $PROCESS_DUMP_FILE > notepad_strings.txt\n\necho \"[+] Analysis complete. Review notepad_strings.txt for evidence.\""
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "The area in a database server's RAM that holds recently accessed data pages from disk to improve performance is known as the:",
                            "options": [
                                "The Stack",
                                "The Buffer Cache / Buffer Pool",
                                "The Transaction Log",
                                "The Master File Table"
                            ],
                            "correct": 1,
                            "explanation": "The buffer cache is a critical performance feature of databases, but it also becomes a valuable forensic artifact, as it contains a snapshot of the most recently and frequently accessed data."
                        },
                        {
                            "id": 2,
                            "question": "An analyst is investigating a compromised web server that uses HTTPS. Where is the most likely place they could find the plaintext of recent web requests?",
                            "options": [
                                "In the on-disk log files, which are encrypted.",
                                "In a packet capture (PCAP), which would show the encrypted TLS traffic.",
                                "In the memory of the web server process (e.g., apache.exe), where the data exists after decryption.",
                                "It is impossible to find the plaintext."
                            ],
                            "correct": 2,
                            "explanation": "For an HTTPS server to process a request, it must first decrypt it. That decrypted data exists, however briefly, in the process's memory. This makes memory analysis a key technique for investigating encrypted communications."
                        },
                        {
                            "id": 3,
                            "question": "A user was writing a ransom note in a text editor but closed it without saving when they were caught. What is the most likely forensic technique to recover the content of the note?",
                            "options": [
                                "Analyze the hard drive's unallocated space.",
                                "Analyze a memory dump of the text editor process to find the unsaved text on its heap.",
                                "Analyze the system's DNS cache.",
                                "Analyze the Master Boot Record."
                            ],
                            "correct": 1,
                            "explanation": "The content of an unsaved file exists in the application's memory (specifically, on the heap). By dumping the process memory, an investigator can often recover this volatile data."
                        }
                    ]
                }
            },
            {
                "id": "lesson-16",
                "title": "Advanced Memory Analysis Techniques",
                "duration": "100 min",
                "objectives": [
                    "Analyze internal kernel data structures.",
                    "Understand how to trace system calls in a memory dump.",
                    "Examine the structure of memory pools used by the kernel.",
                    "Analyze CPU caches and their forensic implications.",
                    "Understand the challenges of memory compression and deduplication.",
                    "Perform deep analysis of kernel-level objects to find anomalies."
                ],
                "content": {
                    "overview": "This lesson pushes beyond standard plugin analysis into the deep, internal structures of the operating system kernel. We will explore how to manually walk through kernel data structures, trace system calls, and analyze the kernel's own memory management pools to find the most sophisticated and well-hidden malware.",
                    "sections": [
                        {
                            "title": "Kernel Structure Analysis",
                            "content": "<p>At its core, memory analysis is about parsing the data structures that the OS kernel uses to manage everything. While plugins automate this, a deep understanding requires knowing what those structures are.</p><h3>Key Windows Kernel Structures:</h3><ul><li><strong>`EPROCESS` and `ETHREAD`:</strong> The primary structures that define a process and a thread, respectively. They are connected in a doubly-linked list. The `pslist` plugin works by simply walking this list.</li><li><strong>`_DRIVER_OBJECT`:</strong> The structure that defines a loaded kernel driver.</li><li><strong>`_FILE_OBJECT`:</strong> Represents an open file handle.</li></ul><p>By using a tool like WinDbg, an expert analyst can manually parse these structures in a memory dump to find information that a standard plugin might miss.</p>",
                            "image": "https://images.unsplash.com/photo-1504384308090-c894fdcc538d?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "System Call Tracing",
                            "content": "<p>A system call is the mechanism by which a user-mode process requests a service from the kernel (e.g., to open a file or send network traffic). Malware, especially rootkits, will often intercept or manipulate these calls.</p><p><strong>Real-world Problem: Analyzing a kernel-level compromise.</strong> A rootkit wants to hide its files. It 'hooks' the System Service Descriptor Table (SSDT). It replaces the kernel's pointer for the function that lists directory contents with a pointer to its own malicious function. When a user tries to list a directory, the rootkit's function runs first. It gets the real list from the kernel, removes its own files from the list, and then returns the sanitized list to the user. The user sees nothing. The `ssdt` plugin in Volatility can detect this by checking the SSDT for any pointers that go to memory outside of the main kernel module (`ntoskrnl.exe`), indicating a hook.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Memory Compression and Deduplication",
                            "content": "<p>Modern operating systems use techniques to optimize memory usage, which can complicate forensic analysis.</p><ul><li><strong>Memory Compression (Windows, macOS):</strong> The OS can compress pages of memory that are not actively in use to make more room. When an analyst dumps the RAM, some of it will be in this compressed format, requiring specialized tools or techniques to decompress it before analysis.</li><li><strong>Memory Deduplication (Windows Server):</strong> If multiple processes have identical pages of memory, the OS can store just one copy to save space.</li></ul><p>These features mean that the physical layout of memory is even more abstract and complex than it used to be, requiring forensic tools to be constantly updated to understand these new OS internals.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Kernel Memory Analysis Framework (WinDbg)",
                            "language": "c",
                            "code": "// This is an example of using the Windows Debugger (WinDbg) to manually analyze\n// a kernel memory dump. This is a very advanced technique.\n\n// 1. Load the memory dump and symbol files.\n// .load wow64exts\n// .sympath srv*c:\\symbols*https://msdl.microsoft.com/download/symbols\n// .reload\n\n// 2. Find the list of running processes.\n// The '!process' command walks the EPROCESS linked list.\n!process 0 0\n\n// 3. Dump the details of a specific process (e.g., with address 0xfffffa8003a78b30)\ndt nt!_EPROCESS 0xfffffa8003a78b30\n\n// 4. List the loaded kernel modules (drivers).\n// The 'lm' command lists loaded modules.\nlm\n\n// 5. Check the System Service Descriptor Table (SSDT) for hooks.\n// The 'dps' command can be used to disassemble the code at the function pointers.\ndps nt!KiServiceTable"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "In the Windows kernel, the data structure that defines a running process is called:",
                            "options": [
                                "EPROCESS",
                                "task_struct",
                                "DRIVER_OBJECT",
                                "FILE_OBJECT"
                            ],
                            "correct": 0,
                            "explanation": "The EPROCESS block is the primary kernel data structure for a process in Windows. The `pslist` plugin works by walking the linked list of these structures."
                        },
                        {
                            "id": 2,
                            "question": "A rootkit that intercepts and modifies the results of core OS functions (like listing files or processes) is likely manipulating what kernel structure?",
                            "options": [
                                "The Master File Table (MFT)",
                                "The process heap",
                                "The System Service Descriptor Table (SSDT)",
                                "The DNS cache"
                            ],
                            "correct": 2,
                            "explanation": "The SSDT is the table of pointers that the OS uses to find its core functions. By 'hooking' this table, a rootkit can redirect calls to its own malicious code, allowing it to filter and hide information."
                        },
                        {
                            "id": 3,
                            "question": "What is a primary forensic challenge introduced by memory compression?",
                            "options": [
                                "It makes the memory dump file larger.",
                                "Some of the data in the memory dump will be in a compressed format and must be decompressed before it can be analyzed.",
                                "It deletes all user data from memory.",
                                "It prevents memory from being acquired."
                            ],
                            "correct": 1,
                            "explanation": "Memory compression means that the raw data in the dump file doesn't always directly correspond to the logical data a process was using. The forensic tool must be aware of the OS's compression algorithm to properly reconstruct the original memory pages."
                        }
                    ]
                }
            },
            
        {
            "id": "lesson-17",
            "title": "Large-Scale Disk Analysis and Big Data Forensics",
            "duration": "90 min",
            "objectives": [
                "Understand the challenges of performing forensics on distributed storage systems.",
                "Apply parallel processing and big data platforms (like Hadoop/Spark) to forensic analysis.",
                "Use automated triage techniques to quickly identify relevant evidence in massive datasets.",
                "Leverage machine learning and pattern recognition to find anomalies.",
                "Design and manage a scalable infrastructure for forensic processing.",
                "Optimize forensic workflows for performance in large-scale investigations."
            ],
            "content": {
                "overview": "In corporate and enterprise environments, an investigation may involve not one disk, but thousands, totaling petabytes of data. Traditional, single-machine forensic techniques do not scale. This lesson explores the strategies and technologies used for large-scale digital forensics, applying big data principles to find the needle in a digital haystack.",
                "sections": [
                    {
                        "title": "The Challenge of Scale",
                        "content": "<p>A single forensic analyst working on a single machine cannot effectively investigate a breach that spans an entire enterprise network. The sheer volume of data is overwhelming.</p><h3>The 'Big Data' Problems in Forensics:</h3><ul><li><strong>Volume:</strong> Terabytes or petabytes of data from servers, laptops, and logs that must be collected and processed.</li><li><strong>Velocity:</strong> New data is being generated constantly, requiring real-time analysis in incident response scenarios.</li><li><strong>Variety:</strong> Data comes from many different sources and formats (disk images, network logs, memory dumps, cloud logs).</li></ul><p>The solution is to stop bringing the data to the tool and start bringing the tool to the data, using distributed processing frameworks to analyze evidence in parallel.</p>",
                        "image": "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Distributed Processing and Automated Triage",
                        "content": "<p>Large-scale forensics relies on parallel processing to analyze many sources of evidence at once.</p><h3>The Workflow:</h3><ol><li><strong>Acquisition:</strong> Evidence is collected from many endpoints simultaneously using remote acquisition agents (e.g., F-Response, GRR).</li><li><strong>Processing:</strong> Instead of one analyst processing one image, a framework like Hadoop or Spark is used. The forensic image is broken into chunks, and hundreds of virtual machines (nodes) work in parallel, each analyzing a small piece of the data to extract key artifacts.</li><li><strong>Triage & Super-Timeline:</strong> The framework automatically extracts key artifacts (e.g., running processes, log entries, file creations, browser history) from all sources and puts them into a single, massive, indexed database or 'super-timeline'.</li><li><strong>Analysis:</strong> The analyst does not look at the raw images initially. They query the super-timeline to find anomalies and pivot between related events across multiple systems.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Machine Learning in Forensics",
                        "content": "<p>With massive datasets, machine learning can be used to find patterns that are impossible for a human to spot.</p><p><strong>Real-time Problem: Analyzing petabytes of enterprise data.</strong> In a major data breach investigation, a company has collected 5,000 disk images. It would take a single analyst years to review them. Instead, they use a distributed processing framework. It takes 24 hours to process all the images and create a super-timeline with billions of events. The lead investigator then runs a query to find a specific piece of malware seen on one machine. The framework instantly returns a list of the 15 other machines where that malware's hash was also seen, allowing the team to immediately understand the scope of the breach. They then use machine learning to find other, unknown malware by looking for statistical outliers in process behavior.</p>",
                        "image": "https://images.unsplash.com/photo-1620712943543-285f212a5a54?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Distributed Forensic Analysis Framework (Conceptual Spark)",
                        "language": "python",
                        "code": "# This is a conceptual PySpark script to find a specific malicious file hash\n# across a massive number of filesystem listings collected from many hosts.\n\nfrom pyspark.sql import SparkSession\n\n# Initialize Spark Session\nspark = SparkSession.builder.appName(\"DistributedForensics\").getOrCreate()\n\n# Assume 'filesystem_data.parquet' is a massive file in HDFS containing\n# file listings from thousands of machines.\n# Columns: hostname, filepath, sha256_hash, mtime\nall_files = spark.read.parquet(\"hdfs:///forensic_data/filesystem_data.parquet\")\n\nmalicious_hash = \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\"\n\n# The query is distributed across the entire Spark cluster\ncompromised_hosts = all_files.filter(all_files.sha256_hash == malicious_hash).select(\"hostname\").distinct()\n\nprint(f\"Found malicious hash on {compromised_hosts.count()} hosts:\")\ncompromised_hosts.show()\n\nspark.stop()"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What are the 'three V's' that define a big data problem in forensics?",
                        "options": [
                            "Volatility, Value, and VHDs",
                            "Volume, Velocity, and Variety",
                            "Validation, Verification, and Virtualization",
                            "Vector, Vulnerability, and Victim"
                        ],
                        "correct": 1,
                        "explanation": "These are the classic definitions of a big data environment: a massive volume of data, being generated with high velocity, from a wide variety of sources."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary goal of creating a 'super-timeline' in a large-scale investigation?",
                        "options": [
                            "To make the investigation report longer.",
                            "To aggregate and normalize key events from thousands of evidence sources into a single, searchable dataset.",
                            "To prove that the timestamps on the systems are correct.",
                            "To delete irrelevant data."
                        ],
                        "correct": 1,
                        "explanation": "A super-timeline is the core of modern large-scale forensics. It allows an analyst to pivot across huge datasets and see the chronological relationship between an event on one computer and an event on another."
                    },
                    {
                        "id": 3,
                        "question": "In the context of enterprise forensics, what does 'automated triage' mean?",
                        "options": [
                            "Letting an AI decide who is guilty.",
                            "Using automated, parallel processing to rapidly extract the most critical artifacts from a large number of systems to quickly identify compromised machines.",
                            "A new type of forensic imaging format.",
                            "A legal process for handling evidence."
                        ],
                        "correct": 1,
                        "explanation": "Triage is the process of rapid prioritization. In large-scale forensics, automation is used to perform a quick, high-level analysis on all systems to find the 'smoking guns', allowing human analysts to focus their deep-dive efforts on the most critical evidence."
                    }
                ]
            }
        },
        {
            "id": "lesson-18",
            "title": "Specialized System Forensics",
            "duration": "100 min",
            "objectives": [
                "Perform forensic analysis on common server systems (web, database, domain controllers).",
                "Extract and analyze web server logs to reconstruct attacker activity.",
                "Investigate backup systems for historical data and evidence of tampering.",
                "Understand the forensic challenges of network appliances like firewalls and routers.",
                "Discuss the unique aspects of embedded systems, ICS, and POS system forensics.",
                "Analyze artifacts from a compromised medical device."
            ],
            "content": {
                "overview": "Not all disks are created equal. A web server, a domain controller, and a point-of-sale system are all computers, but they have unique roles, configurations, and artifacts. This lesson covers the specialized forensic analysis of common server types and embedded systems, focusing on the unique evidence each one provides.",
                "sections": [
                    {
                        "title": "Web Server Forensics",
                        "content": "<p>When a website is hacked, the web server's logs are the primary source of evidence.</p><h3>Key Artifacts:</h3><ul><li><strong>Access Logs:</strong> A record of every single HTTP request made to the server. An analyst can search these logs for evidence of vulnerability scanning, SQL injection attempts, or access to a web shell.</li><li><strong>Error Logs:</strong> Can reveal failed attack attempts or problems caused by an attacker's activity.</li><li><strong>Web Shells:</strong> The attacker's primary tool. A web shell is a malicious script (e.g., in PHP, ASPX) uploaded to the server that gives the attacker the ability to execute commands. Finding the web shell file itself is a critical goal.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1555949963-ff9fe0c870eb?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Domain Controller Forensics",
                        "content": "<p>A Domain Controller (DC) is the heart of a Windows network. It manages authentication and is a prime target for attackers.</p><h3>Key Artifacts:</h3><ul><li><strong>Security Event Log (ID 4624/4625):</strong> The DC logs every successful (4624) and failed (4625) login attempt on the entire network. Analyzing these logs is key to tracking lateral movement and brute-force attacks.</li><li><strong>NTDS.dit file:</strong> The Active Directory database. Attackers will attempt to steal this file so they can crack all the user password hashes offline.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Point-of-Sale (POS) and Embedded Systems",
                        "content": "<p>These systems are often stripped-down, legacy computers running specialized software.</p><p><strong>Real-time Problem: Investigating a compromised payment system.</strong> A retail company suffers a breach of credit card data. The investigation focuses on the POS terminals in the stores. The forensic analyst discovers that the attackers used a weak remote administration password to gain access to one terminal. From there, they deployed specialized malware known as a 'RAM scraper'. This malware sits in memory, inspects the memory of the payment processing application, and 'scrapes' credit card numbers from RAM at the moment they are swiped, before they are encrypted for storage. The analysis of the POS terminal's memory dump is the key to identifying the malware and understanding how the data was stolen.</p>",
                        "image": "https://images.unsplash.com/photo-1556742502-ec7c0e9f34b1?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Server Artifact Correlation Tool (Log Parser)",
                        "language": "bash",
                        "code": "# This is a simple shell command to perform a common web server log analysis task:\n# finding which IP addresses are scanning for vulnerabilities.\n\nACCESS_LOG=\"/var/log/apache2/access.log\"\n\n# Search the access log for requests that generated a '404 Not Found' error.\n# Attackers and scanners frequently request common vulnerability paths that don't exist.\n\ngrep \" 404 \" $ACCESS_LOG | \\\n\n# Extract just the IP address from the beginning of each line.\nawk '{print $1}' | \\\n\n# Count the occurrences of each IP address and sort them.\nsort | uniq -c | sort -nr | \\\n\n# Display the top 10 IPs that are generating the most 404 errors.\nhead -10\n\n# An IP address with thousands of 404 errors is very likely a malicious scanner."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "In a web server breach investigation, which artifact would provide the most detailed record of every HTTP request the attacker made?",
                        "options": [
                            "The server's RAM",
                            "The server's access log",
                            "The Master File Table (MFT)",
                            "The Windows Registry"
                        ],
                        "correct": 1,
                        "explanation": "The access log is specifically designed to record every incoming request, including the source IP, the requested URL, the user agent, and the server's response code. It is the primary source for reconstructing an attacker's web-based activity."
                    },
                    {
                        "id": 2,
                        "question": "An investigator needs to track an attacker's lateral movement through a Windows network. Which server would contain the centralized logs of all successful and failed login attempts?",
                        "options": [
                            "The Web Server",
                            "The Database Server",
                            "The Domain Controller",
                            "The File Server"
                        ],
                        "correct": 2,
                        "explanation": "The Domain Controller is responsible for authentication in a Windows Active Directory environment. Its security event log is the definitive source for tracking login activity across the entire domain."
                    },
                    {
                        "id": 3,
                        "question": "Malware specifically designed to steal credit card numbers by reading them directly from the memory of a payment application on a Point-of-Sale (POS) terminal is known as a:",
                        "options": [
                            "A virus",
                            "A worm",
                            "A keylogger",
                            "A RAM scraper"
                        ],
                        "correct": 3,
                        "explanation": "RAM scrapers are a specialized class of POS malware. They target the small window of time where credit card data exists in memory in an unencrypted state, just before it's processed and encrypted for storage or transmission."
                    }
                ]
            }
        },
        {
            "id": "lesson-19",
            "title": "Forensic Tool Development and Automation",
            "duration": "100 min",
            "objectives": [
                "Understand the principles of custom tool development for forensic analysis.",
                "Use APIs to integrate and extend existing forensic tools.",
                "Develop automation scripts (e.g., in Python) to streamline common forensic tasks.",
                "Understand the critical importance of tool validation and testing.",
                "Automate the generation of forensic reports.",
                "Follow quality assurance procedures for custom-developed code."
            ],
            "content": {
                "overview": "Commercial forensic tools are powerful, but they can't do everything. The most advanced investigators are not just users of tools; they are builders. This lesson introduces the principles of forensic tool development and automation, showing how scripting and programming can be used to solve unique challenges, accelerate investigations, and ensure consistency.",
                "sections": [
                    {
                        "title": "Why Develop Custom Tools?",
                        "content": "<p>While comprehensive forensic suites exist, there are common situations where a custom script or tool is needed.</p><h3>Common Use Cases:</h3><ul><li><strong>Parsing a New Artifact:</strong> A new application becomes popular, and no commercial tool knows how to parse its unique log file format yet. A custom script is needed to extract the evidence.</li><li><strong>Automating Repetitive Tasks:</strong> An investigator finds themselves running the same 10 commands on every single disk image. A script can automate this workflow, saving time and preventing errors.</li><li><strong>Large-Scale Triage:</strong> A script can be written to quickly scan thousands of files and flag only those that meet specific criteria (e.g., contain a certain keyword, were created in a certain date range), allowing an analyst to focus on the most relevant data.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Python: The Language of Forensics",
                        "content": "<p>While many languages can be used, Python has become the de facto standard for forensic scripting and tool development.</p><h3>Why Python?</h3><ul><li><strong>Easy to Learn:</strong> It has a simple and readable syntax.</li><li><strong>Powerful Libraries:</strong> A vast ecosystem of libraries exists for everything from parsing binary data (`struct`) and analyzing registry hives (`regipy`) to interacting with APIs (`requests`).</li><li><strong>Cross-Platform:</strong> The same script can often be run on Windows, macOS, and Linux with minimal changes.</li></ul><p>By learning Python, an investigator can move from being a passive user of a tool's GUI to being able to directly interact with and manipulate any data source.</p>",
                        "image": "https://images.unsplash.com/photo-1587620962725-abab7fe55159?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Tool Validation and Testing: The Scientific Standard",
                        "content": "<p>Any tool used in a forensic investigation—whether commercial or custom-built—must be validated. Validation is the process of proving that the tool works as expected.</p><p><strong>Real-time Problem: Developing a tool for a new file format.</strong> An investigator is analyzing a new chat application. They write a Python script to parse the application's proprietary database and extract messages. Before they can use this script in a real case, they must validate it. They create a test phone, send specific messages, and then use their script to extract the data. They compare the output of their script to the known messages they sent. They must prove, for example, that their script correctly interprets timestamps and does not alter the content of the messages. This validation process is documented and is essential for the evidence to be defensible in court.</p>",
                        "image": "https://images.unsplash.com/photo-1542744173-05336fcc7ad4?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Complete Forensic Analysis Suite (Conceptual Automation Script)",
                        "language": "python",
                        "code": "import os\nimport subprocess\n\n# This is a conceptual master script that automates a common forensic triage workflow.\n\ndef triage_disk_image(image_path, case_folder):\n    \"\"\"Runs a series of forensic tools against a disk image and outputs reports.\"\"\"\n    print(f\"[*] Starting triage on {image_path}\")\n\n    # 1. Run Plaso/Log2Timeline to create a super-timeline\n    print(\"[*] Generating timeline with Plaso...\")\n    plaso_output = os.path.join(case_folder, \"timeline.plaso\")\n    # subprocess.run([\"log2timeline.py\", plaso_output, image_path])\n\n    # 2. Run a file carving tool like Foremost\n    print(\"[*] Carving files with Foremost...\")\n    carve_output = os.path.join(case_folder, \"carved_files\")\n    # subprocess.run([\"foremost\", \"-i\", image_path, \"-o\", carve_output])\n\n    # 3. Run a registry parsing tool\n    print(\"[*] Parsing registry hives...\")\n    registry_report = os.path.join(case_folder, \"registry_report.txt\")\n    # You would first need to extract the hive files from the image.\n    # then run a tool like 'rip.pl' against them, piping output to the report.\n\n    # 4. Generate a final summary report\n    print(\"[*] Generating final report...\")\n    # Code to aggregate the findings from the previous steps into a single HTML report.\n    \n    print(\"[+] Triage complete. Reports are in {case_folder}\")\n\n# Example usage\n# triage_disk_image(\"/evidence_locker/image.dd\", \"/forensic_cases/case006/\")"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary reason for a forensic analyst to develop a custom script?",
                        "options": [
                            "Because commercial tools are always wrong.",
                            "To automate a repetitive task or to parse a new type of digital artifact that existing tools don't support.",
                            "To get a job as a software developer.",
                            "To make the investigation more difficult."
                        ],
                        "correct": 1,
                        "explanation": "Custom scripting is about solving specific problems and increasing efficiency. It's used to fill the gaps that commercial, general-purpose tools might have."
                    },
                    {
                        "id": 2,
                        "question": "The process of testing and documenting that a forensic tool works as expected is known as:",
                        "options": [
                            "Debugging",
                            "Compilation",
                            "Validation",
                            "Marketing"
                        ],
                        "correct": 2,
                        "explanation": "Tool validation is a critical part of the scientific methodology of digital forensics. Before any tool's output can be trusted as evidence, the analyst must prove that the tool is accurate and reliable."
                    },
                    {
                        "id": 3,
                        "question": "Which programming language has become the de facto standard for forensic automation and tool development due to its ease of use and extensive libraries?",
                        "options": [
                            "C++",
                            "Java",
                            "Assembly",
                            "Python"
                        ],
                        "correct": 3,
                        "explanation": "Python's combination of simplicity, power, and a massive ecosystem of third-party libraries specifically for security and forensics has made it the go-to language for investigators and analysts."
                    }
                ]
            }
        },
        {
            "id": "lesson-20",
            "title": "Legal Considerations and Expert Testimony",
            "duration": "100 min",
            "objectives": [
                "Understand the rules of evidence as they apply to digital forensics.",
                "Define the qualifications and responsibilities of an expert witness.",
                "Prepare for giving testimony in court, including direct and cross-examination.",
                "Learn to present complex technical findings in a way that is understandable to a non-technical jury.",
                "Navigate international legal frameworks and privacy laws.",
                "Differentiate the procedural requirements for criminal vs. civil cases.",
                "Uphold the professional and ethical standards of the forensic community."
            ],
            "content": {
                "overview": "The final output of a forensic investigation is often not a technical report, but testimony in a court of law. This lesson covers the crucial final stage of the forensic process: preparing and presenting your findings as an expert witness. We will explore the rules of evidence, the art of translating technical concepts for a jury, and the professional ethics that govern an expert's conduct.",
                "sections": [
                    {
                        "title": "The Expert Witness",
                        "content": "<p>In a legal setting, a normal witness can only testify about facts they personally observed. An expert witness is given a special privilege: they can offer their professional opinion based on the evidence.</p><h3>Qualifying as an Expert:</h3><p>To be qualified as an expert, an individual must demonstrate to the court that they have specialized knowledge, skills, training, or experience in a particular field. This is why certifications, education, and years of experience are so important.</p><p><strong>The Expert's Duty:</strong> The primary duty of an expert witness is to the court and to the truth. An expert is an impartial educator, not an advocate for the side that hired them.</p>",
                        "image": "https://images.unsplash.com/photo-1505664194779-8beace7a2044?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Testifying in Court: Direct and Cross-Examination",
                        "content": "<p>Giving testimony is a structured process.</p><h3>The Two Phases:</h3><ul><li><strong>Direct Examination:</strong> The lawyer for the side that hired you asks you questions. This is a friendly examination designed to let you tell the story of your investigation and explain your findings to the jury.</li><li><strong>Cross-Examination:</strong> The lawyer for the opposing side asks you questions. Their goal is to challenge your findings, methodology, and credibility. This is an adversarial process.</li></ul><p><strong>Real-time Problem: Preparing for a high-profile case.</strong> An expert is preparing to testify. They must anticipate the questions from the opposing counsel. They will be asked: 'Did you follow your lab's standard operating procedures? Is your tool validated? Is there another possible explanation for your findings?' The expert must have clear, confident, and well-documented answers for every step of their process. The key to surviving cross-examination is a meticulous and methodologically sound investigation from the very beginning.</p>",
                        "image": "https://images.unsplash.com/photo-1589994235863-118b6256f693?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Communicating to a Jury",
                        "content": "<p>The single biggest challenge for an expert witness is to explain highly complex technical concepts to a non-technical audience (the judge and jury).</p><h3>Keys to Effective Communication:</h3><ul><li><strong>Use Analogies:</strong> Explain a complex idea by comparing it to something simple and relatable. 'The MFT is like the card catalog in a library, and the disk clusters are like the books on the shelves.'</li><li><strong>Be a Teacher:</strong> Your role is to educate, not to sound smart. Avoid jargon.</li><li><strong>Visual Aids:</strong> Use charts, diagrams, and timelines to make your findings clear and easy to follow.</li><li><strong>Remain Objective:</strong> Present the facts of your analysis. Do not speculate or offer opinions outside your area of expertise. Your credibility is your most important asset.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1552664730-d307ca884978?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Mock Trial Preparation Exercise (Report Snippet)",
                        "language": "markdown",
                        "code": "# Expert Report Snippet: Explaining Timestamps\n\n**Finding:** The malicious file 'evil.exe' was created on the suspect's computer at 2025-09-10 14:35:10 UTC.\n\n### Explanation for a Non-Technical Audience:\n\n*   **Analogy:** Think of a file on a computer like a library book. Every book has a check-out card that gets stamped with dates. Computer files have a similar, hidden 'check-out card' that records several different timestamps.\n\n*   **What we found:** We analyzed the file system, which is the computer's detailed record-keeping system. We found an entry for the file 'evil.exe'. This entry contained four different timestamps.\n\n*   **The 'Created' Stamp:** One of these stamps, the 'Created' time, shows the exact moment the file first appeared on this computer's hard drive. In this case, that time was 14:35:10 UTC on September 10th, 2025.\n\n*   **Conclusion:** Based on this timestamp, which is a normal and automatic function of the Windows operating system, it is my expert opinion that the file 'evil.exe' was introduced to the system at that specific time."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary duty of an expert witness in court?",
                        "options": [
                            "To ensure that the side that hired them wins the case.",
                            "To provide their impartial, expert opinion to help the court understand the evidence.",
                            "To confuse the jury with technical jargon.",
                            "To argue with the opposing lawyer."
                        ],
                        "correct": 1,
                        "explanation": "An expert's primary duty is to the court and to the truth, regardless of which side is paying them. They are there to be an objective and impartial educator."
                    },
                    {
                        "id": 2,
                        "question": "The questioning of an expert witness by the opposing side's lawyer is known as:",
                        "options": [
                            "Direct examination",
                            "Cross-examination",
                            "A deposition",
                            "An affidavit"
                        ],
                        "correct": 1,
                        "explanation": "Cross-examination is the adversarial process where the opposing counsel tests the expert's findings, methodology, and credibility."
                    },
                    {
                        "id": 3,
                        "question": "What is the most important skill for an expert witness when testifying in front of a jury?",
                        "options": [
                            "The ability to use as much technical jargon as possible.",
                            "The ability to speak very quickly.",
                            "The ability to explain complex technical concepts in a simple, clear, and understandable way.",
                            "The ability to refuse to answer questions."
                        ],
                        "correct": 2,
                        "explanation": "The jury is made up of non-technical people. If they cannot understand what you are saying, your testimony is useless. The ability to teach and explain complex topics simply is the key to being an effective expert witness."
                    }
                ]
            }
        },
        {
            "id": "lesson-21",
            "title": "Quality Assurance and Validation",
            "duration": "90 min",
            "objectives": [
                "Understand the importance of a formal Quality Management System (QMS) in a forensic lab.",
                "Develop and implement Standard Operating Procedures (SOPs).",
                "Establish a process for peer review of forensic reports.",
                "Conduct tool validation and reproducibility testing.",
                "Prepare for laboratory certification and accreditation (e.g., ISO 17025).",
                "Implement a continuous improvement process for all forensic procedures."
            ],
            "content": {
                "overview": "Digital forensics is a science, and science requires rigor, consistency, and quality control. This lesson covers the essential elements of quality assurance in a forensic laboratory. We will explore how to validate tools, write standard operating procedures, and implement a peer review process to ensure that all findings are accurate, repeatable, and defensible.",
                "sections": [
                    {
                        "title": "Standard Operating Procedures (SOPs)",
                        "content": "<p>An SOP is a detailed, written, step-by-step set of instructions for performing a routine task. In forensics, there should be an SOP for everything from receiving evidence to imaging a drive to writing a final report.</p><h3>Benefits of SOPs:</h3><ul><li><strong>Consistency:</strong> Ensures that every analyst performs a task in the exact same, approved way every single time.</li><li><strong>Defensibility:</strong> In court, you can show that you followed a documented, standard procedure, which strengthens the credibility of your findings.</li><li><strong>Training:</strong> SOPs are an invaluable tool for training new analysts.</li><li><strong>Error Reduction:</strong> A well-written SOP acts as a checklist, reducing the chance that an analyst will forget a critical step.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Tool Validation and Reproducibility",
                        "content": "<p>As discussed previously, all forensic tools must be validated. But a core part of quality assurance is ensuring that your *entire process* is reproducible.</p><p><strong>Reproducibility</strong> means that if another qualified analyst, following your documented notes and SOPs, were to perform the same analysis on the same evidence, they should arrive at the exact same conclusion. This is the scientific standard for a valid finding. It removes individual bias and proves that the conclusion is based on the evidence and the methodology, not the person.</p>",
                        "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Peer Review and Lab Accreditation",
                        "content": "<p>A Quality Management System incorporates checks and balances to ensure high standards.</p><h3>Key QA Processes:</h3><ul><li><strong>Technical Peer Review:</strong> Before any forensic report is finalized, it should be reviewed by another qualified analyst. The reviewer checks for technical errors, ensures the conclusions are supported by the evidence, and looks for grammatical mistakes.</li><li><strong>Administrative Review:</strong> A final check to ensure the report meets all formatting, branding, and legal requirements.</li></ul><p><strong>Real-time Problem: Validating controversial forensic findings.</strong> An analyst's findings in a major case are going to be heavily challenged in court. To prepare, the lab manager performs an external validation. They provide a copy of the evidence and the analyst's draft report to another trusted, independent forensic lab. This second lab performs their own analysis. If they independently reach the same conclusions, it provides extremely strong validation of the original findings and prepares the primary analyst for cross-examination.</p><p>The highest level of quality assurance is formal laboratory accreditation, such as to the **ISO/IEC 17025** standard, which is the international standard for the competence of testing and calibration laboratories.</p>",
                        "image": "https://images.unsplash.com/photo-1454165804606-c3d57bc86b40?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Automated Quality Assurance System (Conceptual)",
                        "language": "python",
                        "code": "import json\n\n# This conceptual script checks a draft forensic report for compliance with an SOP.\n\ndef check_report_compliance(report_json_path, sop_checklist_path):\n    \"\"\"Checks a report against a quality assurance checklist.\"\"\"\n    with open(report_json_path, 'r') as f:\n        report = json.load(f)\n    with open(sop_checklist_path, 'r') as f:\n        checklist = json.load(f)\n\n    print(\"--- Running QA Check on Forensic Report ---\")\n    is_compliant = True\n    for item in checklist['required_sections']:\n        if item['section_name'] not in report:\n            print(f\"[FAILURE] Missing required section: {item['section_name']}\")\n            is_compliant = False\n        else:\n            print(f\"[SUCCESS] Section '{item['section_name']}' is present.\")\n            \n    # Check if all evidence items have a hash value\n    for evidence in report.get('evidence_list', []):\n        if 'sha256_hash' not in evidence:\n            print(f\"[FAILURE] Evidence item {evidence['item_id']} is missing a hash.\")\n            is_compliant = False\n\n    return is_compliant"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "A detailed, step-by-step written document that explains how to perform a routine task like imaging a hard drive is called a:",
                        "options": [
                            "Chain of Custody",
                            "Standard Operating Procedure (SOP)",
                            "Forensic Report",
                            "Legal Hold"
                        ],
                        "correct": 1,
                        "explanation": "SOPs are the backbone of a quality management system. They ensure that all tasks are performed in a consistent, repeatable, and defensible manner."
                    },
                    {
                        "id": 2,
                        "question": "The principle that another qualified analyst should be able to follow your notes and arrive at the same conclusion is known as:",
                        "options": [
                            "Validation",
                            "Peer Review",
                            "Reproducibility",
                            "Accreditation"
                        ],
                        "correct": 2,
                        "explanation": "Reproducibility is a core tenet of the scientific method and is essential for forensic findings to be considered reliable and objective."
                    },
                    {
                        "id": 3,
                        "question": "What is the purpose of a technical peer review for a forensic report?",
                        "options": [
                            "To check for spelling and grammar errors.",
                            "To ensure the report is formatted correctly.",
                            "To have another qualified analyst check for technical errors and ensure the conclusions are supported by the evidence.",
                            "To get the report approved by the legal department."
                        ],
                        "correct": 2,
                        "explanation": "The technical peer review is a critical quality control step. It's a sanity check by a colleague to catch any mistakes or unsupported conclusions before the report is finalized and sent to a client or court."
                    }
                ]
            }
        },
        {
            "id": "lesson-22",
            "title": "Advanced Analysis Techniques",
            "duration": "90 min",
            "objectives": [
                "Understand how Artificial Intelligence (AI) and Machine Learning (ML) are being applied to forensics.",
                "Use ML for pattern recognition and anomaly detection in large datasets.",
                "Apply Natural Language Processing (NLP) to analyze text-based evidence.",
                "Leverage image recognition for sorting and comparing multimedia evidence.",
                "Use advanced visualization techniques to uncover hidden relationships in data.",
                "Apply statistical analysis to forensic data to strengthen findings."
            ],
            "content": {
                "overview": "As data volumes explode, manual analysis is becoming increasingly difficult. This lesson explores the cutting edge of forensic analysis, showing how advanced techniques like machine learning and artificial intelligence are being used to automate analysis, find hidden patterns, and help investigators make sense of massive datasets.",
                "sections": [
                    {
                        "title": "Machine Learning for Anomaly Detection",
                        "content": "<p>Machine learning excels at finding the 'needle in a haystack'. An ML model can be trained on a baseline of 'normal' activity, and it can then flag any event that deviates significantly from that baseline.</p><h3>Real-World Example:</h3><p>An investigator has a super-timeline with billions of log entries from a company's network. It's impossible for a human to read it all. They use a machine learning model to analyze the login activity. The model knows that employees normally log in from 8 AM to 6 PM from specific countries. The model automatically flags a successful login at 3 AM from an unusual country as a high-priority anomaly, even though it was a 'successful' login. This allows the investigator to immediately focus on a likely compromised account.</p>",
                        "image": "https://images.unsplash.com/photo-1620712943543-285f212a5a54?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Natural Language Processing (NLP) and Image Recognition",
                        "content": "<p>AI can also be used to analyze the content of unstructured data like documents and images.</p><h3>Applications:</h3><ul><li><strong>NLP for eDiscovery:</strong> In a corporate investigation, lawyers may need to review millions of emails. An NLP model can be trained to automatically identify and prioritize documents that are relevant to the case (e.g., ones that discuss a specific project or have a negative sentiment).</li><li><strong>Image Recognition:</strong> In a law enforcement case involving illicit images, an AI model can perform image hashing and recognition to automatically identify known illegal material, saving a human analyst from having to manually review every single image.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1554080353-a576cf803bda?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Advanced Visualization",
                        "content": "<p>A picture is worth a thousand words, especially in a complex investigation. Advanced visualization tools can turn massive spreadsheets of data into intuitive graphs that reveal hidden connections.</p><p><strong>Real-world Example:</strong> An investigator has a log of all email communications within a company. It's just a massive table of 'From' and 'To' addresses. They load this data into a graph visualization tool like Gephi or Maltego. The tool automatically creates a 'social network' graph, showing each person as a node and each email as an edge. The investigator immediately sees a small, isolated cluster of people who email each other frequently but rarely email anyone else in the company. This visual outlier is a strong indicator of a potential conspiracy or insider threat group that requires further investigation.</p>",
                        "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "AI-Powered Forensic Analysis System (Conceptual)",
                        "language": "python",
                        "code": "from sklearn.ensemble import IsolationForest\nimport pandas as pd\n\n# This conceptual script demonstrates using an anomaly detection algorithm\n# (Isolation Forest) to find suspicious login activity.\n\n# 1. Load login data (in a real case, this would be millions of events)\ndata = {\n    'hour_of_day': [9, 10, 14, 17, 10, 11, 3, 15],\n    'is_weekend': [0, 0, 0, 0, 0, 0, 1, 0], # 0=False, 1=True\n    'country_code': ['US', 'US', 'US', 'US', 'US', 'US', 'RU', 'US']\n}\ndf = pd.get_dummies(pd.DataFrame(data)) # Convert country to numeric\n\n# 2. Train the anomaly detection model\nmodel = IsolationForest(contamination=0.1) # Expect 10% anomalies\nmodel.fit(df)\n\n# 3. Predict which events are anomalous\n# -1 indicates an anomaly, 1 indicates a normal event\ndf['anomaly'] = model.predict(df)\n\nprint(\"--- Anomaly Detection Results ---\")\nprint(df[df['anomaly'] == -1])"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary application of machine learning in large-scale forensic investigations?",
                        "options": [
                            "To automatically write the final report.",
                            "To conduct interviews with suspects.",
                            "To analyze massive datasets to find patterns and anomalies that a human investigator would miss.",
                            "To validate forensic tools."
                        ],
                        "correct": 2,
                        "explanation": "Machine learning excels at finding the 'needle in a haystack'. Its main forensic use is in anomaly detection and pattern recognition within vast amounts of log and system data."
                    },
                    {
                        "id": 2,
                        "question": "An investigator using an AI model to analyze millions of emails to find relevant documents for a lawsuit is an application of what technology?",
                        "options": [
                            "Image Recognition",
                            "Natural Language Processing (NLP)",
                            "Disk Imaging",
                            "Steganography"
                        ],
                        "correct": 1,
                        "explanation": "NLP is the branch of AI that deals with understanding and processing human language. It is heavily used in eDiscovery to automate the review of text-based evidence like emails and documents."
                    },
                    {
                        "id": 3,
                        "question": "Graph visualization tools like Gephi or Maltego are most useful for what purpose in an investigation?",
                        "options": [
                            "Recovering deleted files.",
                            "Analyzing the contents of a memory dump.",
                            "Uncovering hidden relationships and connections between different pieces of evidence (like people, emails, and websites).",
                            "Cracking passwords."
                        ],
                        "correct": 2,
                        "explanation": "Graph visualization turns tabular data into a network graph, making it much easier for the human brain to spot connections, clusters, and outliers that would be invisible in a spreadsheet."
                    }
                ]
            }
        },
        {
            "id": "lesson-23",
            "title": "Real-World Case Studies and Scenarios",
            "duration": "120 min",
            "objectives": [
                "Apply all learned techniques to a complex, multi-faceted case.",
                "Analyze a corporate espionage investigation from start to finish.",
                "Deconstruct an intellectual property theft case involving an insider threat.",
                "Walk through a financial fraud examination.",
                "Understand the unique challenges of criminal investigations (e.g., child exploitation, terrorism).",
                "Synthesize findings from disk, memory, and network forensics into a single timeline."
            ],
            "content": {
                "overview": "Theory is essential, but forensics is a practical discipline. This capstone lesson synthesizes everything we have learned throughout the course by walking through a complex, real-world case study from the initial alert to the final report. We will see how different types of evidence from disk, memory, and the network are correlated to tell a complete story.",
                "sections": [
                    {
                        "title": "Case Study: The 'Titan' Corporate Espionage Investigation",
                        "content": "<p>This case involves a suspected insider threat at a technology company who is believed to be stealing secret design documents for a new product, codenamed 'Titan'.</p><h3>The Initial Lead:</h3><p>A User Behavior Analytics (UBA) system generates an alert for an engineer named John Doe. The alert was triggered by him downloading an unusually large volume of files from the 'Project_Titan' SharePoint site at 2:00 AM.</p>",
                        "image": "https://images.unsplash.com/photo-1516321497487-e288fb19713f?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The Investigation: Connecting the Dots",
                        "content": "<p>The investigation proceeds by collecting and correlating evidence from multiple sources in a specific order.</p><ol><li><strong>Live Analysis:</strong> The team performs a live memory acquisition of John's laptop. Analysis of the memory dump shows a running process for the Google Drive sync client and an active network connection to Google's servers.</li><li><strong>Disk Imaging:</strong> A forensic image of John's laptop hard drive is created.</li><li><strong>Disk Forensics:</strong><ul><li>Analysis of the Google Drive client's local SQLite database and sync logs shows that a file named `Titan_Blueprints.zip` was uploaded to a personal Gmail account.</li><li>Analysis of the browser history shows searches for 'how to securely wipe a hard drive'.</li><li>Analysis of the Windows Registry shows that a USB drive was connected shortly after the large download. Its serial number is recorded.</li></ul></li><li><strong>Network Forensics:</strong> A review of the company's web proxy logs confirms a 2.5 GB upload from John's machine to `drive.google.com` at the time of the UBA alert.</li></ol>",
                        "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The Conclusion: A Synthesized Timeline",
                        "content": "<p>By combining all these artifacts, the investigator can create a detailed, second-by-second timeline of events that tells a clear and defensible story.</p><h3>The Timeline:</h3><ul><li><strong>01:55 AM:</strong> John Doe logs into his laptop (Source: Windows Event Log).</li><li><strong>02:01 AM:</strong> John Doe downloads 2.5 GB of data from SharePoint (Source: UBA Alert, SharePoint Audit Log).</li><li><strong>02:10 AM:</strong> A file named `Titan_Blueprints.zip` is created (Source: MFT Analysis).</li><li><strong>02:15 AM:</strong> An upload of 2.5 GB to `drive.google.com` begins (Source: Network Proxy Logs).</li><li><strong>02:20 AM:</strong> The file `Titan_Blueprints.zip` is synced (Source: Google Drive Sync Log).</li><li><strong>02:30 AM:</strong> John Doe's browser history shows searches for data wiping tools (Source: Browser History Database).</li></ul><p>The combination of evidence from different, independent sources creates a powerful and highly credible case, proving the data theft beyond a reasonable doubt.</p>",
                        "image": "https://images.unsplash.com/photo-1552664730-d307ca884978?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "End-to-End Complex Case Investigation (Timeline)",
                        "language": "markdown",
                        "code": "# Snippet from the Final Forensic Report Timeline\n\n| Timestamp (UTC)     | Source of Evidence  | Hostname      | User      | Event Description                                                                   |\n|---------------------|---------------------|---------------|-----------|-------------------------------------------------------------------------------------|\n| 2025-09-11 01:55:12 | Security Event Log  | LPT-JDOE-01   | John.Doe  | Successful Logon (Event ID 4624)                                                    |\n| 2025-09-11 02:01:35 | SharePoint Logs     | SharePoint-01 | John.Doe  | Accessed file library 'Project_Titan_Designs'                                       |\n| 2025-09-11 02:10:05 | MFT ($FILE_NAME)    | LPT-JDOE-01   | N/A       | File Created: C:\\Users\\John.Doe\\Desktop\\Titan_Blueprints.zip                        |\n| 2025-09-11 02:15:22 | Web Proxy Log       | LPT-JDOE-01   | John.Doe  | HTTP POST to drive.google.com, 2,516,582,400 bytes                                  |\n| 2025-09-11 02:20:48 | GDrive Sync Log     | LPT-JDOE-01   | John.Doe  | SUCCESS: Upload of Titan_Blueprints.zip to account johndoe123@gmail.com             |\n| 2025-09-11 02:30:11 | Browser History DB  | LPT-JDOE-01   | John.Doe  | Visited URL: https://www.google.com/search?q=best+secure+file+eraser              |"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "In the case study, what was the primary value of analyzing the memory dump?",
                        "options": [
                            "It showed which files were on the desktop.",
                            "It proved that the Google Drive client was actively running and connected to the network at the time of the incident.",
                            "It recovered the user's password.",
                            "It showed the computer's hardware specifications."
                        ],
                        "correct": 1,
                        "explanation": "Memory forensics provides a snapshot of what was happening on a system at a specific moment. In this case, it proved the suspect's computer was actively running the data exfiltration tool (the sync client) and was connected to the destination."
                    },
                    {
                        "id": 2,
                        "question": "What is the purpose of creating a synthesized 'super-timeline' in a complex investigation?",
                        "options": [
                            "To make the evidence look more complicated than it is.",
                            "To combine artifacts from multiple, independent sources (disk, memory, network) into a single chronological narrative.",
                            "It is a legal requirement in all cases.",
                            "To determine the time zone of the suspect."
                        ],
                        "correct": 1,
                        "explanation": "A timeline is the story of the crime. By correlating different types of evidence, an investigator can build a powerful, detailed narrative that is much more compelling and defensible than any single piece of evidence on its own."
                    },
                    {
                        "id": 3,
                        "question": "In the case study, finding the USB connection history in the Registry and the Google Drive sync logs on the disk are both examples of what discipline?",
                        "options": [
                            "Memory Forensics",
                            "Network Forensics",
                            "Disk Forensics",
                            "Live Analysis"
                        ],
                        "correct": 2,
                        "explanation": "Both the Windows Registry and application log files are artifacts that are stored on the hard drive. Analyzing them is a core part of disk forensics."
                    }
                ]
            }
        },
        {
            "id": "lesson-24",
            "title": "Emerging Technologies and Future Challenges",
            "duration": "90 min",
            "objectives": [
                "Discuss the potential impact of quantum computing on forensic evidence and encryption.",
                "Understand the forensic challenges posed by the massive scale of the Internet of Things (IoT).",
                "Explore the difficulties of tracing transactions and identifying actors on the blockchain.",
                "Analyze the challenge of authenticating evidence in the age of AI-generated deepfakes.",
                "Consider the forensic implications of 5G, edge computing, and augmented reality.",
                "Discuss the need for continuous adaptation and learning in the field of digital forensics."
            ],
            "content": {
                "overview": "The field of digital forensics is in a constant state of evolution, driven by the rapid pace of technological change. This final lesson looks to the horizon, exploring the future challenges and opportunities that will shape the next generation of digital investigation. From AI-generated evidence to the explosion of IoT devices, we will discuss how investigators must adapt to a constantly changing world.",
                "sections": [
                    {
                        "title": "The IoT Explosion: A Tsunami of Evidence",
                        "content": "<p>The Internet of Things (IoT) will create an unprecedented volume and variety of digital evidence. Every smart device in a home or city—from a doorbell to a car—will be a potential source of data.</p><h3>Future Challenges:</h3><ul><li><strong>Scale:</strong> An investigation might involve seizing and analyzing hundreds of disparate devices, each with its own proprietary file system and data format.</li><li><strong>Proprietary Systems:</strong> Many IoT devices have no standard way to access their data, requiring new and specialized extraction techniques.</li><li><strong>Data Correlation:</strong> The main challenge will be correlating tiny bits of data from hundreds of sources to reconstruct a single event.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1535683416248-8495c6b8159b?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Blockchain and Cryptocurrency Forensics",
                        "content": "<p>Blockchain, the technology behind cryptocurrencies like Bitcoin, creates a public, immutable ledger of all transactions. This presents both opportunities and challenges.</p><h3>Forensic Aspects:</h3><ul><li><strong>Opportunity (Traceability):</strong> Every transaction is public. Specialized tools can be used to trace the flow of illicit funds across the blockchain from one wallet to another.</li><li><strong>Challenge (Anonymity):</strong> While the transactions are public, the identities behind the wallet addresses are pseudonymous. The key challenge of blockchain forensics is 'de-anonymization'—linking a specific wallet address to a real-world person, often by finding a transaction where they interacted with a regulated exchange that required them to provide identification.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1621452773352-2a74c35b2917?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "AI and the Deepfake Dilemma",
                        "content": "<p>Perhaps the greatest future challenge to digital evidence is the rise of AI-generated 'deepfakes'.</p><p><strong>Real-time Problem: Investigating AI-generated deepfake evidence.</strong> In a harassment case, the primary piece of evidence is a video showing a person making threatening statements. The defense claims the video is a deepfake. The forensic analyst can no longer simply say 'the video shows what happened'. They must now perform a highly technical analysis of the video file itself, looking for subtle artifacts of AI manipulation, such as unnatural blinking, strange lighting inconsistencies, or digital compression anomalies. The field of forensics will have to evolve new techniques to authenticate digital media in a world where seeing is no longer believing.</p>",
                        "image": "https://images.unsplash.com/photo-1611162617474-5b21e879e113?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Next-Generation Forensic Framework (Conceptual)",
                        "language": "python",
                        "code": "class ForensicCase:\n    def __init__(self, case_id):\n        self.case_id = case_id\n        self.evidence_streams = []\n\n    def add_evidence(self, evidence_type, data_source):\n        # Ingest data from diverse sources (IoT, Blockchain, Disk)\n        self.evidence_streams.append({'type': evidence_type, 'source': data_source})\n        print(f\"Ingested {evidence_type} evidence.\")\n\n    def correlate_events(self):\n        \"\"\"Uses AI/ML to find connections between disparate evidence streams.\"\"\"\n        print(\"\\nCorrelating events across all evidence streams...\")\n        # This would be a complex AI model in a real system.\n        # Conceptual Logic:\n        # IF (IoT_Door_Sensor.event == 'open' at Time X)\n        # AND (Blockchain_Transaction.value > 1000 at Time X+1min)\n        # AND (Deepfake_Detection_Tool.result == 'likely fake' on video from Time X+5min)\n        # THEN generate a high-priority alert for the analyst.\n        print(\"Potential correlation found: IoT event followed by financial transaction.\")\n\n# --- Future Scenario ---\ncase = ForensicCase(\"Case-Future-001\")\ncase.add_evidence(\"IoT\", \"door_sensor.log\")\ncase.add_evidence(\"Blockchain\", \"bitcoin_ledger.csv\")\ncase.add_evidence(\"Multimedia\", \"disputed_video.mp4\")\ncase.correlate_events()"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary challenge in blockchain forensics?",
                        "options": [
                            "The transactions are all secret and hidden.",
                            "Linking a pseudonymous wallet address to a real-world identity.",
                            "The blockchain is too slow.",
                            "There are not enough forensic tools."
                        ],
                        "correct": 1,
                        "explanation": "The challenge isn't seeing the transactions (which are public), but de-anonymizing the actors. This usually involves finding a point where the suspect moved cryptocurrency through a regulated exchange where they had to provide their real identity."
                    },
                    {
                        "id": 2,
                        "question": "The rise of AI-generated deepfakes will require forensic analysts to develop new skills in what area?",
                        "options": [
                            "Recovering deleted files.",
                            "Authenticating the integrity of digital multimedia evidence.",
                            "Analyzing network traffic.",
                            "Writing Standard Operating Procedures."
                        ],
                        "correct": 1,
                        "explanation": "In a world with deepfakes, an analyst can no longer take a video or audio file at face value. They will need new tools and techniques to detect the subtle artifacts of AI manipulation to determine if a piece of media is real or synthetic."
                    },
                    {
                        "id": 3,
                        "question": "What is the biggest forensic challenge posed by the massive growth of IoT devices?",
                        "options": [
                            "IoT devices do not store any data.",
                            "The sheer volume and variety of devices, each with its own proprietary data format and extraction method.",
                            "IoT devices are too expensive.",
                            "IoT devices are never involved in criminal cases."
                        ],
                        "correct": 1,
                        "explanation": "The scale and lack of standardization are the key problems. An investigation may require analyzing hundreds of different types of devices, making the acquisition and analysis process incredibly complex and time-consuming."
                    }
                ]
            }
        }
    ]
}

      // =====================================================
      // GLOBAL VARIABLES
      // =====================================================
      let currentUser = null;
      let currentLessonIndex = 0;
      let courseProgress = {};
      let userStats = {};
      let quizState = {
        currentQuestion: 0,
        answers: [],
        score: 0,
        isComplete: false,
        timeStarted: null,
        timeCompleted: null,
        currentQuestionIndex: 0,
      };

      // Enhanced session tracking
      let courseSession = {
        startTime: null,
        totalStudyTime: 0,
        lessonsStarted: 0,
        lessonsCompleted: 0,
        pageLoadTime: new Date(),
        lastActive: new Date(),
        interactions: 0,
        completedSections: [],
        totalTime: 0,
        interactionCount: 0,
        lastActivityTime: new Date(),
      };

      // Music Player Variables
      let audioPlayer = new Audio();

      // Achievement notification system
      let notificationQueue = [];
      let isShowingNotification = false;

      // =====================================================
      // INITIALIZATION
      // =====================================================
      document.addEventListener("DOMContentLoaded", async () => {
        try {
          showLoadingScreen();
          await checkAuth();

          if (currentUser) {
            // Initialize session tracking
            startCourseSession();

            // Load course data and progress
            await loadCourseData();
            await loadUserProfile();
            await loadProgress();

            // Initialize UI
            initializeEventListeners();
            renderSidebar();
            loadLesson(currentLessonIndex);

            // Initialize additional features
            initMusicPlayer();
            addMusicIndicator();
            initializeActivityTracking();

            hideLoadingScreen();
          } else {
            openAuthModal();
          }
        } catch (error) {
          console.error("Error initializing course:", error);
          hideLoadingScreen();
          showToast("Failed to initialize course system", "error");
        }
      });

      // =====================================================
      // AUTHENTICATION SYSTEM
      // =====================================================
      async function checkAuth() {
        try {
          const {
            data: { session },
            error,
          } = await supabase.auth.getSession();

          if (error) {
            console.error("Auth error:", error);
            currentUser = null;
            openAuthModal();
            return;
          }

          if (!session) {
            currentUser = null;
            openAuthModal();
            return;
          }

          currentUser = session.user;
          updateUIWithUser();
        } catch (error) {
          console.error("Error checking auth:", error);
          currentUser = null;
          openAuthModal();
        }
      }

      function updateUIWithUser() {
        if (!currentUser) return;

        const name =
          currentUser.user_metadata?.full_name ||
          currentUser.email.split("@")[0];
        const userElements = document.querySelectorAll("[data-user-name]");
        userElements.forEach((el) => (el.textContent = name));
      }

      // =====================================================
      // USER PROFILE & STATS MANAGEMENT
      // =====================================================
      async function loadUserProfile() {
        try {
          // 🔍 Step 1: Try to fetch existing profile
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("*")
            .eq("id", currentUser.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (!profile) {
            // 🆕 Step 2: Create new profile if missing
            await createUserProfile();
          } else {
            // ✅ Step 3: Use existing profile
            userStats = profile;
            await updateLastActivity();
          }
        } catch (error) {
          console.error("❌ Error loading user profile:", error);
          showToast("Failed to load user profile", "error");
        }
      }
      async function createUserProfile() {
        try {
          const newProfile = {
            id: currentUser.id,
            full_name: currentUser.user_metadata?.full_name || "",
            email: currentUser.email,
            level: "Script Kiddie",
            total_points: 0,
            completed_courses: 0,
            current_streak: 0,
            total_certificates: 0,
            total_achievements: 0,
            sections_visited: 0,
            bonus_points: 0,
            in_progress_courses: 0,
            settings_changed: 0,
            midnight_sessions: 0,
            early_sessions: 0,
            weekend_sessions: 0,
            last_activity: new Date().toISOString(),
            created_at: new Date().toISOString(),
          };

          const { error } = await supabase
            .from("profiles")
            .insert([newProfile]);

          if (!error) {
            userStats = newProfile;
            // Award first login achievement
            setTimeout(() => checkAndUnlockAchievement("first_login"), 1000);
          }
        } catch (error) {
          console.error("Error creating user profile:", error);
        }
      }

      async function updateLastActivity() {
        try {
          const now = new Date();

          // Update activity tracking
          courseSession.lastActivityTime = now;

          // Update database
          await supabase
            .from("profiles")
            .update({
              last_activity: now.toISOString(),
            })
            .eq("id", currentUser.id);

          // Check time-based achievements
          await checkTimeBasedAchievements(now);
        } catch (error) {
          console.error("Error updating last activity:", error);
        }
      }

      // =====================================================
      // COURSE SESSION MANAGEMENT
      // =====================================================
      function startCourseSession() {
        courseSession.startTime = new Date();
        courseSession.pageLoadTime = new Date();

        logUserActivity("course_session_start", {
          course_id: COURSE_DATA.id,
          course_title: COURSE_DATA.title,
          user_agent: navigator.userAgent,
          screen_resolution: `${screen.width}x${screen.height}`,
        });

        // Check daily streak
        checkDailyStreak();
      }

      function initializeActivityTracking() {
        // Track page focus/blur for accurate study time
        document.addEventListener("visibilitychange", handleVisibilityChange);

        // Track user interactions
        ["click", "keydown", "scroll", "mousemove"].forEach((event) => {
          document.addEventListener(event, trackUserInteraction, {
            passive: true,
          });
        });

        // Periodic activity updates
        setInterval(updateStudyTime, 60000); // Every minute

        // Save session data before page unload
        window.addEventListener("beforeunload", saveSessionData);
      }

      function handleVisibilityChange() {
        if (document.hidden) {
          courseSession.lastActivityTime = new Date();
        } else {
          // Page became visible again - update activity
          updateLastActivity();
        }
      }

      function trackUserInteraction() {
        courseSession.interactionCount++;
        courseSession.lastActivityTime = new Date();

        // Throttle activity updates
        if (courseSession.interactionCount % 50 === 0) {
          updateLastActivity();
        }
      }

      function updateStudyTime() {
        if (!courseSession.startTime || document.hidden) return;

        const now = new Date();
        const sessionDuration = now - courseSession.startTime;
        courseSession.totalStudyTime = Math.floor(sessionDuration / 1000 / 60); // in minutes

        // Update progress with study time
        saveProgress();
      }

      function saveSessionData() {
        if (!currentUser || !courseSession.startTime) return;

        const sessionData = {
          user_id: currentUser.id,
          course_id: COURSE_DATA.id,
          session_duration: courseSession.totalStudyTime,
          lessons_viewed: courseSession.lessonsStarted,
          lessons_completed: courseSession.lessonsCompleted,
          interactions: courseSession.interactionCount,
          session_date: courseSession.startTime.toISOString().split("T")[0],
        };

        // Store in localStorage as backup
        localStorage.setItem(
          "course_session_backup",
          JSON.stringify(sessionData)
        );

        // Try to save to database
        logUserActivity("course_session_end", sessionData);
      }

      // =====================================================
      // COURSE DATA & PROGRESS MANAGEMENT
      // =====================================================
      async function loadCourseData() {
        try {
          // Update course info in UI
          document.getElementById("courseTitle").textContent =
            COURSE_DATA.title;
          document.getElementById("totalLessons").textContent =
            COURSE_DATA.lessons.length;

          // Log course access
          logUserActivity("course_access", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
          });
        } catch (error) {
          console.error("Error loading course data:", error);
        }
      }

      async function loadProgress() {
        try {
          // Get existing progress from database
          const { data, error } = await supabase
            .from("course_progress")
            .select("*")
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (data) {
            courseProgress = JSON.parse(data.lesson_progress || "{}");
            currentLessonIndex = data.current_lesson || 0;

            // Update session tracking
            courseSession.lessonsStarted = Object.keys(courseProgress).length;
            courseSession.lessonsCompleted = Object.values(
              courseProgress
            ).filter((p) => p.completed).length;
          } else {
            // Initialize new progress
            courseProgress = {};
            currentLessonIndex = 0;
            await saveProgress();

            // Award first course start achievement
            await checkAndUnlockAchievement("first_course_start");
          }

          updateProgressDisplay();
        } catch (error) {
          console.error("Error loading progress:", error);
          showToast("Failed to load progress", "error");
        }
      }

      async function saveProgress() {
        try {
          if (!currentUser) return;

          const now = new Date();
          const progressData = {
            user_id: currentUser.id,
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            current_lesson: currentLessonIndex,
            lesson_progress: JSON.stringify(courseProgress),
            progress: calculateOverallProgress(),
            lessons_completed: getCompletedLessonsCount(),
            lessons_started: Object.keys(courseProgress).length,
            study_time_minutes: courseSession.totalStudyTime,
            last_accessed: now.toISOString(),
            updated_at: now.toISOString(),
          };

          // Upsert progress
          const { error } = await supabase
            .from("course_progress")
            .upsert([progressData]);

          if (error) throw error;

          // Update user stats
          await updateUserStats();

          updateProgressDisplay();
        } catch (error) {
          console.error("Error saving progress:", error);
          showToast("Failed to save progress", "error");
        }
      }

      async function updateUserStats() {
        try {
          // Get all course progress for this user
          const { data: allProgress, error } = await supabase
            .from("course_progress")
            .select("progress, course_id, study_time_minutes")
            .eq("user_id", currentUser.id);

          if (error) throw error;

          // Calculate stats
          const completedCourses =
            allProgress?.filter((p) => p.progress >= 100).length || 0;
          const inProgressCourses =
            allProgress?.filter((p) => p.progress > 0 && p.progress < 100)
              .length || 0;
          const totalStudyTime =
            allProgress?.reduce(
              (sum, p) => sum + (p.study_time_minutes || 0),
              0
            ) || 0;

          // Calculate points (500 per completed course + achievement points)
          const coursePoints = completedCourses * 500;
          const bonusPoints = userStats.bonus_points || 0;
          const totalPoints = coursePoints + bonusPoints;

          // Update profile
          const updateData = {
            completed_courses: completedCourses,
            in_progress_courses: inProgressCourses,
            total_points: totalPoints,
            total_study_time: totalStudyTime,
            last_activity: new Date().toISOString(),
          };

          const { error: updateError } = await supabase
            .from("profiles")
            .update(updateData)
            .eq("id", currentUser.id);

          if (updateError) throw updateError;

          // Update local stats
          Object.assign(userStats, updateData);
        } catch (error) {
          console.error("Error updating user stats:", error);
        }
      }

      function calculateOverallProgress() {
        const completedLessons = getCompletedLessonsCount();
        return Math.round(
          (completedLessons / COURSE_DATA.lessons.length) * 100
        );
      }

      function getCompletedLessonsCount() {
        return Object.values(courseProgress).filter(
          (lesson) => lesson.completed
        ).length;
      }

      function updateProgressDisplay() {
        const completedCount = getCompletedLessonsCount();
        const progressPercent = calculateOverallProgress();

        // Update UI elements
        const elements = {
          completedLessons: completedCount,
          courseProgressPercent: `${progressPercent}%`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });

        // Update progress bar
        const progressBar = document.getElementById("courseProgressFill");
        if (progressBar) progressBar.style.width = `${progressPercent}%`;
      }

      // =====================================================
      // LESSON MANAGEMENT
      // =====================================================
      function loadLesson(index) {
        if (index < 0 || index >= COURSE_DATA.lessons.length) return;

        const lesson = COURSE_DATA.lessons[index];
        currentLessonIndex = index;

        // Mark lesson as started and track activity
        if (!courseProgress[lesson.id]) {
          courseProgress[lesson.id] = {
            started: true,
            completed: false,
            startedAt: new Date().toISOString(),
            timeSpent: 0,
          };

          courseSession.lessonsStarted++;
          saveProgress();

          // Log lesson start
          logUserActivity("lesson_start", {
            lesson_id: lesson.id,
            lesson_title: lesson.title,
            lesson_index: index,
          });
        }

        // Update lesson start time for time tracking
        courseProgress[lesson.id].currentSessionStart = new Date();

        // Update sidebar and navigation
        renderSidebar();
        updateNavigationButtons();

        // Update header info
        updateLessonHeader(lesson, index);

        // Render lesson content
        renderLessonContent(lesson);

        // Smooth scroll and animations
        window.scrollTo({ top: 0, behavior: "smooth" });
        document.getElementById("contentBody").scrollTop = 0;

        const contentBody = document.getElementById("contentBody");
        contentBody.classList.add("fade-in");
        setTimeout(() => contentBody.classList.remove("fade-in"), 500);

        // Check lesson-based achievements
        checkLessonAchievements(index + 1);
      }

      function updateLessonHeader(lesson, index) {
        const elements = {
          currentLessonNumber: index + 1,
          currentLessonTitle: lesson.title,
          navInfo: `Lesson ${index + 1} of ${COURSE_DATA.lessons.length}`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });
      }

      function renderSidebar() {
        const lessonNav = document.getElementById("lessonNav");
        if (!lessonNav) return;

        lessonNav.innerHTML = "";

        COURSE_DATA.lessons.forEach((lesson, index) => {
          const lessonItem = document.createElement("div");
          lessonItem.className = "lesson-item";

          // Determine lesson status
          const lessonProgress = courseProgress[lesson.id];
          const isCompleted = lessonProgress?.completed || false;
          const isInProgress = lessonProgress?.started || false;
          const isLocked = !isCompleted && !canAccessLesson(index);
          const isActive = index === currentLessonIndex;

          // Apply status classes
          if (isCompleted) lessonItem.classList.add("completed");
          if (isLocked) lessonItem.classList.add("locked");
          if (isActive) lessonItem.classList.add("active");

          // Determine status display
          let statusClass = "not-started";
          let statusIcon = index + 1;

          if (isCompleted) {
            statusClass = "completed";
            statusIcon = "✓";
          } else if (isInProgress) {
            statusClass = "in-progress";
            statusIcon = "◐";
          }

          // Create lesson item HTML
          lessonItem.innerHTML = `
            <div class="lesson-status ${statusClass}">${statusIcon}</div>
            <div class="lesson-info">
                <div class="lesson-title">${lesson.title}</div>
                <div class="lesson-meta">
                    ${
                      isCompleted
                        ? "Completed"
                        : isInProgress
                        ? "In Progress"
                        : isLocked
                        ? "Locked"
                        : "Not Started"
                    }
                </div>
            </div>
            <div class="lesson-duration">${lesson.duration}</div>
        `;

          // Add click handler if not locked
          if (!isLocked) {
            lessonItem.addEventListener("click", () => {
              if (index !== currentLessonIndex) {
                // Track lesson time before switching
                trackLessonTime();

                currentLessonIndex = index;
                loadLesson(index);
                closeSidebar();
              }
            });
          }

          lessonNav.appendChild(lessonItem);
        });
      }

      function canAccessLesson(index) {
        if (index === 0) return true; // First lesson always accessible

        // Can access if previous lesson is completed
        const previousLessonId = COURSE_DATA.lessons[index - 1].id;
        return courseProgress[previousLessonId]?.completed || false;
      }

      function trackLessonTime() {
        const currentLesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonProgress = courseProgress[currentLesson.id];

        if (lessonProgress?.currentSessionStart) {
          const sessionTime = Math.floor(
            (new Date() - new Date(lessonProgress.currentSessionStart)) /
              1000 /
              60
          );
          lessonProgress.timeSpent =
            (lessonProgress.timeSpent || 0) + sessionTime;
          delete lessonProgress.currentSessionStart;
        }
      }

      // =====================================================
      // LESSON CONTENT RENDERING
      // =====================================================
      function renderLessonContent(lesson) {
        const contentContainer = document.getElementById("lessonContent");
        if (!contentContainer) return;

        let contentHTML = `
        <div class="content-section">
            <h2>Learning Objectives</h2>
            <ul>
                ${lesson.objectives.map((obj) => `<li>${obj}</li>`).join("")}
            </ul>
        </div>
        
        <div class="content-section">
            <h2>Overview</h2>
            <p>${lesson.content.overview}</p>
        </div>
    `;

        // Render content sections
        lesson.content.sections.forEach((section) => {
          contentHTML += `
            <div class="content-section">
                <h2>${section.title}</h2>
                ${section.content}
                ${
                  section.image
                    ? `<img src="${section.image}" alt="${section.title}" class="content-image" loading="lazy">`
                    : ""
                }
            </div>
        `;
        });

        // Render code examples
        if (
          lesson.content.codeExamples &&
          lesson.content.codeExamples.length > 0
        ) {
          contentHTML += `<div class="content-section"><h2>Code Examples</h2></div>`;

          lesson.content.codeExamples.forEach((example, index) => {
            const codeId = `code-${lesson.id}-${index}`;
            contentHTML += `
                <div class="code-section">
                    <div class="code-header">
                        <span class="code-title">${example.title}</span>
                        <button class="copy-btn" onclick="copyCode('${codeId}')">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <pre class="code-block"><code id="${codeId}" class="language-${
              example.language
            }">${escapeHtml(example.code)}</code></pre>
                </div>
            `;
          });
        }

        // Render quiz
        contentHTML += renderQuiz(lesson.quiz);

        contentContainer.innerHTML = contentHTML;

        // Highlight code syntax if Prism is available
        setTimeout(() => {
          if (window.Prism) {
            Prism.highlightAll();
          }
        }, 100);
      }

      // =====================================================
      // QUIZ SYSTEM
      // =====================================================
      function renderQuiz(quiz) {
        const currentLessonProgress =
          courseProgress[COURSE_DATA.lessons[currentLessonIndex].id];
        const isCompleted = currentLessonProgress?.completed || false;

        let quizHTML = `
        <div class="quiz-section" id="quizSection">
            <div class="quiz-header">
                <h2 class="quiz-title">
                    <i class="fas fa-clipboard-check"></i>
                    Knowledge Check
                </h2>
                <p class="quiz-info">
                    Complete this quiz with ${quiz.passingScore}% or higher to unlock the next lesson.
                </p>
            </div>
    `;

        if (isCompleted) {
          const savedScore = currentLessonProgress.quizScore || 0;
          quizHTML += `
            <div class="quiz-results show">
                <div class="quiz-score pass">${savedScore}%</div>
                <div class="quiz-message">
                    <strong>Lesson Completed!</strong><br>
                    You've successfully passed this lesson's quiz.
                </div>
            </div>
        `;
        } else {
          // Render quiz questions
          quiz.questions.forEach((question, qIndex) => {
            quizHTML += `
                <div class="quiz-question ${
                  qIndex === 0 ? "active" : ""
                }" data-question="${qIndex}">
                    <div class="question-header">
                        <span class="question-number">Question ${
                          qIndex + 1
                        }</span>
                        <span class="question-progress">${qIndex + 1}/${
              quiz.questions.length
            }</span>
                    </div>
                    <div class="question-text">${question.question}</div>
                    <div class="question-options">
                        ${question.options
                          .map(
                            (option, oIndex) => `
                            <div class="option" data-option="${oIndex}" onclick="selectOption(${qIndex}, ${oIndex})">
                                <span class="option-letter">${String.fromCharCode(
                                  65 + oIndex
                                )}</span>
                                <span class="option-text">${option}</span>
                            </div>
                        `
                          )
                          .join("")}
                    </div>
                </div>
            `;
          });

          quizHTML += `
            <div class="quiz-controls">
                <button class="btn btn-secondary" id="prevQuestionBtn" onclick="previousQuestion()" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <div>
                    <button class="btn btn-secondary" id="nextQuestionBtn" onclick="nextQuestion()" disabled>
                        Next
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <button class="btn btn-primary" id="submitQuizBtn" onclick="submitQuiz()" style="display: none;">
                        <i class="fas fa-check"></i>
                        Submit Quiz
                    </button>
                </div>
            </div>

            <div class="quiz-results" id="quizResults">
                <div class="quiz-score" id="quizScore">0%</div>
                <div class="quiz-message" id="quizMessage"></div>
                <div class="quiz-actions">
                    <button class="btn btn-primary" id="continueBtn" onclick="completeLesson()" style="display: none;">
                        <i class="fas fa-arrow-right"></i>
                        Continue to Next Lesson
                    </button>
                    <button class="btn btn-secondary" onclick="retakeQuiz()">
                        <i class="fas fa-redo"></i>
                        Retake Quiz
                    </button>
                </div>
            </div>
        `;
        }

        quizHTML += "</div>";
        return quizHTML;
      }

      // Quiz interaction functions
      function selectOption(questionIndex, optionIndex) {
        // Clear previous selections
        document
          .querySelectorAll(`[data-question="${questionIndex}"] .option`)
          .forEach((opt) => {
            opt.classList.remove("selected");
          });

        // Select current option
        const selectedOption = document.querySelector(
          `[data-question="${questionIndex}"] [data-option="${optionIndex}"]`
        );
        selectedOption.classList.add("selected");

        // Store answer
        quizState.answers[questionIndex] = optionIndex;

        // Update navigation
        const isLastQuestion =
          questionIndex ===
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length - 1;
        if (isLastQuestion) {
          document.getElementById("submitQuizBtn").style.display =
            "inline-flex";
          document.getElementById("nextQuestionBtn").style.display = "none";
        } else {
          document.getElementById("nextQuestionBtn").disabled = false;
        }
      }

      function nextQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const nextQuestionEl = currentQuestionEl.nextElementSibling;

        if (
          nextQuestionEl &&
          nextQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          nextQuestionEl.classList.add("active");
          quizState.currentQuestion++;
          updateQuizNavigation();
        }
      }

      function previousQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const prevQuestionEl = currentQuestionEl.previousElementSibling;

        if (
          prevQuestionEl &&
          prevQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          prevQuestionEl.classList.add("active");
          quizState.currentQuestion--;
          updateQuizNavigation();
        }
      }

      function updateQuizNavigation() {
        const totalQuestions =
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length;
        const prevBtn = document.getElementById("prevQuestionBtn");
        const nextBtn = document.getElementById("nextQuestionBtn");
        const submitBtn = document.getElementById("submitQuizBtn");

        prevBtn.disabled = quizState.currentQuestion === 0;

        const hasAnswer =
          quizState.answers[quizState.currentQuestion] !== undefined;
        const isLastQuestion = quizState.currentQuestion === totalQuestions - 1;

        if (isLastQuestion) {
          nextBtn.style.display = "none";
          submitBtn.style.display = hasAnswer ? "inline-flex" : "none";
        } else {
          nextBtn.style.display = "inline-flex";
          nextBtn.disabled = !hasAnswer;
          submitBtn.style.display = "none";
        }
      }

      async function submitQuiz() {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const quiz = lesson.quiz;
        let correctAnswers = 0;

        // Hide questions and controls
        document
          .querySelectorAll(".quiz-question")
          .forEach((q) => (q.style.display = "none"));
        document.querySelector(".quiz-controls").style.display = "none";

        // Calculate score and highlight answers
        quiz.questions.forEach((question, index) => {
          const userAnswer = quizState.answers[index];
          const correctAnswer = question.correct;
          const isCorrect = userAnswer === correctAnswer;

          if (isCorrect) correctAnswers++;

          // Highlight answers
          const questionEl = document.querySelector(
            `[data-question="${index}"]`
          );
          const options = questionEl.querySelectorAll(".option");

          options[correctAnswer].classList.add("correct");
          if (userAnswer !== correctAnswer && userAnswer !== undefined) {
            options[userAnswer].classList.add("incorrect");
          }
        });

        const score = Math.round(
          (correctAnswers / quiz.questions.length) * 100
        );
        const passed = score >= quiz.passingScore;

        // Update quiz results UI
        const quizScore = document.getElementById("quizScore");
        const quizMessage = document.getElementById("quizMessage");
        const quizActions = document.querySelector(".quiz-actions");

        quizScore.textContent = `${score}%`;
        quizScore.className = `quiz-score ${passed ? "pass" : "fail"}`;

        if (passed) {
          quizMessage.innerHTML = `
            <strong>Congratulations!</strong><br>
            You passed with ${score}%. You can now proceed to the next lesson.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-primary" onclick="completeLesson()">
                <i class="fas fa-arrow-right"></i>
                Continue to Next Lesson
            </button>
        `;

          // Mark lesson as completed
          await markLessonComplete(score);
        } else {
          quizMessage.innerHTML = `
            <strong>Not quite there yet.</strong><br>
            You scored ${score}%. You need ${quiz.passingScore}% to pass. Review the material and try again.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-secondary" onclick="retakeQuiz()">
                <i class="fas fa-redo"></i>
                Retake Quiz
            </button>
        `;
        }

        document.getElementById("quizResults").classList.add("show");

        // Log quiz completion
        logUserActivity("quiz_completed", {
          lesson_id: lesson.id,
          lesson_title: lesson.title,
          score: score,
          passed: passed,
          attempts: (courseProgress[lesson.id]?.quizAttempts || 0) + 1,
        });

        // Scroll to results
        document
          .getElementById("quizResults")
          .scrollIntoView({ behavior: "smooth" });
      }

      function retakeQuiz() {
        // Reset quiz state
        quizState = {
          currentQuestion: 0,
          answers: [],
          score: 0,
          isComplete: false,
        };

        // Track quiz retry
        const lessonId = COURSE_DATA.lessons[currentLessonIndex].id;
        if (!courseProgress[lessonId]) courseProgress[lessonId] = {};
        courseProgress[lessonId].quizAttempts =
          (courseProgress[lessonId].quizAttempts || 0) + 1;

        // Reload lesson content
        loadLesson(currentLessonIndex);

        // Scroll to quiz
        setTimeout(() => {
          document
            .getElementById("quizSection")
            .scrollIntoView({ behavior: "smooth" });
        }, 500);
      }

      async function markLessonComplete(score) {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonId = lesson.id;

        // Track lesson completion time
        trackLessonTime();

        // Update lesson progress
        courseProgress[lessonId] = {
          ...courseProgress[lessonId],
          completed: true,
          quizScore: score,
          completedAt: new Date().toISOString(),
          finalScore: score,
        };

        // Update session tracking
        courseSession.lessonsCompleted++;

        // Save progress to database
        await saveProgress();

        // Update UI
        renderSidebar();
        updateNavigationButtons();

        // Check various achievements
        await checkLessonCompletionAchievements();
        await checkPerfectScoreAchievements(score);
        await checkStudyTimeAchievements();

        // Log lesson completion
        logUserActivity("lesson_completed", {
          lesson_id: lessonId,
          lesson_title: lesson.title,
          final_score: score,
          time_spent: courseProgress[lessonId].timeSpent || 0,
          lesson_number: currentLessonIndex + 1,
        });

        showToast("Lesson completed successfully!", "success");
      }

      async function completeLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          // Move to next lesson
          currentLessonIndex++;
          loadLesson(currentLessonIndex);
        } else {
          // Course completion
          await completeCourse();
        }
      }

      async function completeCourse() {
        try {
          const completionTime = courseSession.totalStudyTime;

          // Update course progress to 100% completed
          await supabase
            .from("course_progress")
            .update({
              progress: 100,
              completed_at: new Date().toISOString(),
              completion_time_minutes: completionTime,
            })
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Award course completion achievements
          await checkAndUnlockAchievement("course_completion_1");
          await checkSpeedCompletionAchievements(completionTime);
          await checkCourseStreakAchievements();

          // Update user stats
          await updateUserStats();

          // Show completion message
          showToast(
            "Congratulations! Course completed successfully!",
            "certificate"
          );

          // Log course completion
          logUserActivity("course_completed", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            completion_time_minutes: completionTime,
            total_lessons: COURSE_DATA.lessons.length,
            average_quiz_score: calculateAverageQuizScore(),
          });

          // Redirect to dashboard after delay
          setTimeout(() => {
            window.location.href = "/dashboard.html";
          }, 3000);
        } catch (error) {
          console.error("Error completing course:", error);
          showToast("Error marking course as complete", "error");
        }
      }

      // =====================================================
      // ACHIEVEMENT INTEGRATION SYSTEM
      // =====================================================
      async function checkAndUnlockAchievement(
        achievementId,
        skipNotification = false
      ) {
        try {
          // Prevent duplicate checks
          const cacheKey = `achievement_${achievementId}_${currentUser.id}`;
          if (sessionStorage.getItem(cacheKey)) return false;

          // Check if already unlocked
          const { data: existing, error } = await supabase
            .from("user_achievements")
            .select("id")
            .eq("user_id", currentUser.id)
            .eq("achievement_id", achievementId)
            .single();

          if (existing) {
            sessionStorage.setItem(cacheKey, "true");
            return false;
          }

          // Award achievement
          const achievementData = {
            user_id: currentUser.id,
            achievement_id: achievementId,
            unlocked_at: new Date().toISOString(),
            points_awarded: getAchievementPoints(achievementId),
            context: "course_system",
          };

          const { data, error: insertError } = await supabase
            .from("user_achievements")
            .insert([achievementData])
            .select()
            .single();

          if (insertError) {
            if (insertError.code === "23505") return false; // Already exists
            throw insertError;
          }

          // Update user points
          await supabase.rpc('increment_user_stats', {
  user_id_param: currentUser.id,
  points_to_add: achievementData.points_awarded,
  achievements_to_add: 1
});

          // Cache and queue notification
          sessionStorage.setItem(cacheKey, "true");

          if (!skipNotification) {
            queueAchievementNotification({
              id: achievementId,
              name: getAchievementName(achievementId),
              description: getAchievementDescription(achievementId),
              points: achievementData.points_awarded,
              rarity: getAchievementRarity(achievementId),
              icon: getAchievementIcon(achievementId),
            });
          }

          return true;
        } catch (error) {
          console.error("Error unlocking achievement:", error);
          return false;
        }
      }

      // Helper functions for achievement data (replace with your actual achievement definitions)
      function getAchievementPoints(id) {
        const pointsMap = {
          first_course_start: 75,
          first_lesson: 100,
          course_completion_1: 500,
          perfect_score: 250,
          speed_demon: 750,
          marathon_learner: 500,
          night_owl: 200,
          early_bird: 200,
          weekend_warrior: 150,
          // Add more as needed
        };
        return pointsMap[id] || 100;
      }

      function getAchievementName(id) {
        const nameMap = {
          first_course_start: "Learning Initiated",
          first_lesson: "First Steps",
          course_completion_1: "Course Conqueror",
          perfect_score: "Perfectionist",
          speed_demon: "Speed Demon",
          // Add more as needed
        };
        return nameMap[id] || "Achievement Unlocked";
      }

      function getAchievementDescription(id) {
        const descMap = {
          first_course_start: "Start your first cybersecurity course",
          first_lesson: "Complete your first lesson",
          course_completion_1: "Complete your first course",
          perfect_score: "Score 100% on any quiz",
          speed_demon: "Complete a course in under 2 hours",
          // Add more as needed
        };
        return descMap[id] || "Achievement description";
      }

      function getAchievementRarity(id) {
        const rarityMap = {
          first_course_start: "common",
          first_lesson: "bronze",
          course_completion_1: "silver",
          perfect_score: "gold",
          speed_demon: "legendary",
          // Add more as needed
        };
        return rarityMap[id] || "common";
      }

      function getAchievementIcon(id) {
        const iconMap = {
          first_course_start: "fas fa-play",
          first_lesson: "fas fa-baby",
          course_completion_1: "fas fa-trophy",
          perfect_score: "fas fa-star",
          speed_demon: "fas fa-rocket",
          // Add more as needed
        };
        return iconMap[id] || "fas fa-award";
      }

      async function checkLessonAchievements(lessonNumber) {
        if (lessonNumber === 1) {
          await checkAndUnlockAchievement("first_lesson");
        }

        // Check if user has completed multiple lessons in one day
        const today = new Date().toISOString().split("T")[0];
        const todayCompletions = Object.values(courseProgress).filter(
          (p) => p.completed && p.completedAt?.startsWith(today)
        ).length;

        if (todayCompletions >= 3) {
          await checkAndUnlockAchievement("lesson_marathon");
        }
      }

      async function checkLessonCompletionAchievements() {
        const completedCount = getCompletedLessonsCount();

        // Lesson-based achievements
        const lessonMilestones = [1, 5, 10, 25, 50, 100];
        for (const milestone of lessonMilestones) {
          if (completedCount >= milestone) {
            await checkAndUnlockAchievement(`lessons_${milestone}`);
          }
        }

        // Course completion achievements
        if (completedCount === COURSE_DATA.lessons.length) {
          await checkAndUnlockAchievement("course_completion_1");

          // Check for additional course completion achievements
          const { data: allCourses } = await supabase
            .from("course_progress")
            .select("course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100);

          const totalCompleted = allCourses?.length || 0;

          const courseMilestones = [1, 5, 10, 25];
          for (const milestone of courseMilestones) {
            if (totalCompleted >= milestone) {
              await checkAndUnlockAchievement(`course_completion_${milestone}`);
            }
          }
        }
      }

      async function checkPerfectScoreAchievements(score) {
        if (score === 100) {
          await checkAndUnlockAchievement("perfect_score");

          // Check for consecutive perfect scores
          const recentScores = Object.values(courseProgress)
            .filter((p) => p.completed && p.quizScore)
            .slice(-5) // Last 5 completed
            .map((p) => p.quizScore);

          if (
            recentScores.length >= 3 &&
            recentScores.every((s) => s === 100)
          ) {
            await checkAndUnlockAchievement("perfectionist_streak");
          }
        }
      }

      async function checkSpeedCompletionAchievements(completionTime) {
        // Speed demon: Complete course in under 2 hours (120 minutes)
        if (completionTime <= 120) {
          await checkAndUnlockAchievement("speed_demon");
        }

        // Quick learner: Complete course in under 4 hours (240 minutes)
        if (completionTime <= 240) {
          await checkAndUnlockAchievement("quick_learner");
        }
      }

      async function checkStudyTimeAchievements() {
        const totalTime = courseSession.totalStudyTime;

        // Marathon learner: Study for 8+ hours in a course session
        if (totalTime >= 480) {
          // 8 hours
          await checkAndUnlockAchievement("marathon_learner");
        }

        // Dedicated learner: Study for 4+ hours
        if (totalTime >= 240) {
          // 4 hours
          await checkAndUnlockAchievement("dedicated_learner");
        }
      }

      async function checkCourseStreakAchievements() {
        try {
          // Check for consecutive course completions
          const { data: recentCourses, error } = await supabase
            .from("course_progress")
            .select("completed_at, course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100)
            .order("completed_at", { ascending: false })
            .limit(10);

          if (error || !recentCourses) return;

          // Check for courses completed on consecutive days
          let consecutiveDays = 1;
          for (let i = 1; i < recentCourses.length; i++) {
            const prevDate = new Date(
              recentCourses[i - 1].completed_at
            ).toDateString();
            const currentDate = new Date(
              recentCourses[i].completed_at
            ).toDateString();
            const dayDiff =
              Math.abs(new Date(prevDate) - new Date(currentDate)) /
              (1000 * 60 * 60 * 24);

            if (dayDiff <= 1) {
              consecutiveDays++;
            } else {
              break;
            }
          }

          if (consecutiveDays >= 3) {
            await checkAndUnlockAchievement("learning_streak");
          }
        } catch (error) {
          console.error("Error checking course streak achievements:", error);
        }
      }

      // =====================================================
      // TIME-BASED ACHIEVEMENTS
      // =====================================================
      async function checkTimeBasedAchievements(timestamp) {
        const hour = timestamp.getHours();
        const dayOfWeek = timestamp.getDay();

        // Night owl (after midnight, before 6 AM)
        if (hour >= 0 && hour < 6) {
          await incrementTimeBasedCounter("midnight_sessions", "night_owl");
        }

        // Early bird (4 AM to 6 AM)
        if (hour >= 4 && hour < 6) {
          await incrementTimeBasedCounter("early_sessions", "early_bird");
        }

        // Weekend warrior (Saturday = 6, Sunday = 0)
        if (dayOfWeek === 0 || dayOfWeek === 6) {
          await incrementTimeBasedCounter(
            "weekend_sessions",
            "weekend_warrior"
          );
        }
      }

      async function incrementTimeBasedCounter(counterType, achievementId) {
        try {
          const dateStr = new Date().toISOString().split("T")[0];
          const cacheKey = `${counterType}_${currentUser.id}_${dateStr}`;

          // Prevent multiple increments per day
          if (sessionStorage.getItem(cacheKey)) return;

          // Update counter
          await supabase
            .from("profiles")
            .update({
              [counterType]: supabase.sql`${counterType} + 1`,
            })
            .eq("id", currentUser.id);

          // Cache to prevent double counting
          sessionStorage.setItem(cacheKey, "true");

          // Check related achievement
          if (achievementId) {
            await checkAndUnlockAchievement(achievementId, true);
          }
        } catch (error) {
          console.error(`Error incrementing ${counterType}:`, error);
        }
      }

      async function checkDailyStreak() {
        try {
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("last_activity, current_streak, last_streak_date")
            .eq("id", currentUser.id)
            .single();

          if (error) throw error;

          const now = new Date();
          const today = now.toDateString();
          const lastActivity = profile.last_activity
            ? new Date(profile.last_activity)
            : null;
          const lastStreakDate = profile.last_streak_date
            ? new Date(profile.last_streak_date).toDateString()
            : null;

          let newStreak = profile.current_streak || 0;
          let shouldUpdateStreak = false;

          if (!lastActivity) {
            // First time user
            newStreak = 1;
            shouldUpdateStreak = true;
          } else {
            const daysSinceLastActivity = Math.floor(
              (now - lastActivity) / (1000 * 60 * 60 * 24)
            );

            if (lastStreakDate === today) {
              // Already counted today's streak
              return newStreak;
            } else if (
              daysSinceLastActivity === 1 ||
              (daysSinceLastActivity === 0 && lastStreakDate !== today)
            ) {
              // Consecutive day or same day but not counted yet
              newStreak += 1;
              shouldUpdateStreak = true;
            } else if (daysSinceLastActivity > 1) {
              // Streak broken
              newStreak = 1;
              shouldUpdateStreak = true;
            }
          }

          if (shouldUpdateStreak) {
            await supabase
              .from("profiles")
              .update({
                current_streak: newStreak,
                last_activity: now.toISOString(),
                last_streak_date: now.toISOString(),
              })
              .eq("id", currentUser.id);

            userStats.current_streak = newStreak;

            showToast(`Daily streak: ${newStreak} days!`, "success");
            await checkStreakAchievements(newStreak);
          }

          return newStreak;
        } catch (error) {
          console.error("Error checking daily streak:", error);
          return 0;
        }
      }

      async function checkStreakAchievements(currentStreak) {
        const streakMilestones = [3, 7, 14, 30, 100, 365];

        for (const milestone of streakMilestones) {
          if (currentStreak >= milestone) {
            await checkAndUnlockAchievement(`streak_${milestone}`);
          }
        }
      }

      // =====================================================
      // USER ACTIVITY LOGGING
      // =====================================================
      async function logUserActivity(activityType, metadata = {}) {
        try {
          const now = new Date();

          const activityData = {
            user_id: currentUser.id,
            activity_type: activityType,
            timestamp: now.toISOString(),
            course_id: COURSE_DATA.id,
            lesson_index: currentLessonIndex,
            session_duration: courseSession.totalStudyTime,
            metadata: JSON.stringify(metadata),
            created_at: now.toISOString(),
          };

          // Try to log to activities table
          const { error } = await supabase
            .from("user_activities")
            .insert([activityData]);

          if (error && error.code !== "42P01") {
            console.warn("Activity logging failed:", error.message);
          }

          // Always update last activity in profile
          await supabase
            .from("profiles")
            .update({ last_activity: now.toISOString() })
            .eq("id", currentUser.id);
        } catch (error) {
          console.error("Error logging user activity:", error);
        }
      }

      // =====================================================
      // NAVIGATION SYSTEM
      // =====================================================
      function updateNavigationButtons() {
        const prevBtn = document.getElementById("prevLessonBtn");
        const nextBtn = document.getElementById("nextLessonBtn");

        if (!prevBtn || !nextBtn) return;

        // Previous button
        prevBtn.disabled = currentLessonIndex === 0;

        // Next button logic
        const isLastLesson =
          currentLessonIndex === COURSE_DATA.lessons.length - 1;
        const canGoNext =
          currentLessonIndex < COURSE_DATA.lessons.length - 1 &&
          canAccessLesson(currentLessonIndex + 1);

        if (isLastLesson) {
          const isCurrentCompleted =
            courseProgress[COURSE_DATA.lessons[currentLessonIndex].id]
              ?.completed;
          nextBtn.disabled = !isCurrentCompleted;
          nextBtn.innerHTML = '<i class="fas fa-trophy"></i> Complete Course';
        } else {
          nextBtn.disabled = !canGoNext;
          nextBtn.innerHTML = 'Next <i class="fas fa-chevron-right"></i>';
        }
      }

      // Navigation button event handlers
      function goToPreviousLesson() {
        if (currentLessonIndex > 0) {
          trackLessonTime(); // Track time spent on current lesson
          currentLessonIndex--;
          loadLesson(currentLessonIndex);
        }
      }

      function goToNextLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          const canGoNext = canAccessLesson(currentLessonIndex + 1);
          if (canGoNext) {
            trackLessonTime();
            currentLessonIndex++;
            loadLesson(currentLessonIndex);
          } else {
            showToast("Complete the current lesson quiz to proceed", "warning");
          }
        } else {
          // Complete course
          completeCourse();
        }
      }

      // =====================================================
      // SIDEBAR FUNCTIONS
      // =====================================================
      function toggleSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.toggle("open");
        if (overlay) overlay.classList.toggle("active");
      }

      function closeSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.remove("open");
        if (overlay) overlay.classList.remove("active");
      }

      // =====================================================
      // ACHIEVEMENT NOTIFICATION SYSTEM
      // =====================================================
      function queueAchievementNotification(achievement) {
        notificationQueue.push(achievement);
        processNotificationQueue();
      }

      function processNotificationQueue() {
        if (isShowingNotification || notificationQueue.length === 0) return;

        isShowingNotification = true;
        const achievement = notificationQueue.shift();
        showAchievementNotification(achievement);

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          isShowingNotification = false;
          processNotificationQueue();
        }, duration + 500);
      }

      function showAchievementNotification(achievement) {
        const notification = document.getElementById("achievementNotification");
        if (!notification) return;

        const icon = document.getElementById("notificationIcon");
        const title = document.getElementById("notificationTitle");
        const description = document.getElementById("notificationDescription");
        const points = document.getElementById("notificationPoints");

        if (icon) {
          icon.innerHTML = `<i class="${achievement.icon}"></i>`;
          icon.className = `notification-icon ${achievement.rarity}`;
        }
        if (title) title.textContent = achievement.name;
        if (description) description.textContent = achievement.description;
        if (points) points.textContent = `+${achievement.points} Points`;

        notification.className = `achievement-notification ${achievement.rarity}`;
        notification.classList.add("show");

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          notification.classList.remove("show");
        }, duration);
      }

      // =====================================================
      // UTILITY FUNCTIONS
      // =====================================================
      function calculateAverageQuizScore() {
        const scores = Object.values(courseProgress)
          .filter((p) => p.completed && p.quizScore)
          .map((p) => p.quizScore);

        if (scores.length === 0) return 0;
        return Math.round(
          scores.reduce((sum, score) => sum + score, 0) / scores.length
        );
      }

      async function resetProgress() {
        if (
          !confirm(
            "Are you sure you want to reset your progress? This action cannot be undone."
          )
        ) {
          return;
        }

        try {
          // Track lesson time before reset
          trackLessonTime();

          // Reset local state
          courseProgress = {};
          currentLessonIndex = 0;
          courseSession = {
            startTime: new Date(),
            totalStudyTime: 0,
            lessonsStarted: 0,
            lessonsCompleted: 0,
            pageLoadTime: new Date(),
            interactionCount: 0,
            lastActivityTime: new Date(),
          };

          // Delete from database
          await supabase
            .from("course_progress")
            .delete()
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Log reset activity
          logUserActivity("progress_reset", {
            course_id: COURSE_DATA.id,
            reset_reason: "manual",
          });

          // Reinitialize
          await saveProgress();
          renderSidebar();
          loadLesson(0);

          showToast("Progress reset successfully", "success");
        } catch (error) {
          console.error("Error resetting progress:", error);
          showToast("Failed to reset progress", "error");
        }
      }

      function copyCode(codeId) {
        const codeElement = document.getElementById(codeId);
        if (!codeElement) return;

        const text = codeElement.textContent;

        navigator.clipboard
          .writeText(text)
          .then(() => {
            showToast("Code copied to clipboard!", "success");

            // Track code copy for achievements
            logUserActivity("code_copied", {
              code_section: codeId,
              lesson_id: COURSE_DATA.lessons[currentLessonIndex].id,
            });
          })
          .catch((err) => {
            console.error("Failed to copy code:", err);
            showToast("Failed to copy code", "error");

            // Fallback for older browsers
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            try {
              document.execCommand("copy");
              showToast("Code copied to clipboard!", "success");
            } catch (fallbackError) {
              showToast(
                "Copy failed - please select and copy manually",
                "error"
              );
            }
            document.body.removeChild(textArea);
          });
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // =====================================================
      // UI FEEDBACK SYSTEMS
      // =====================================================
      function showToast(message, type = "success") {
        const toast = document.getElementById("toast");
        const messageEl = document.getElementById("toastMessage");

        if (!toast || !messageEl) {
          console.log(`Toast: ${message} (${type})`);
          return;
        }

        messageEl.textContent = message;
        toast.className = `toast ${type} show`;

        setTimeout(() => {
          toast.classList.remove("show");
        }, 4000);
      }

      function showLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) loadingScreen.classList.remove("hidden");
      }

      function hideLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) {
          setTimeout(() => {
            loadingScreen.classList.add("hidden");
          }, 1000);
        }
      }

      // =====================================================
      // MUSIC PLAYER INTEGRATION
      // =====================================================
      function initMusicPlayer() {
        const btnText = document.getElementById("music-button-text");
        const icon = document.getElementById("music-icon");
        const dropdown = document.getElementById("music-dropdown-content");

        if (!btnText || !icon || !dropdown) return;

        function setUI(state) {
          btnText.textContent =
            state === "Playing" ? "PAUSE MUSIC" : "STUDY MUSIC";
          icon.className =
            state === "Playing"
              ? "fa-solid fa-circle-pause"
              : "fa-solid fa-music";
        }

        // Load saved music state
        const savedSrc = localStorage.getItem("cybersec_music_src");
        const savedTime = parseFloat(
          localStorage.getItem("cybersec_music_time") || 0
        );

        if (savedSrc) {
          audioPlayer.src = savedSrc;
          audioPlayer.currentTime = savedTime;
          audioPlayer
            .play()
            .then(() => setUI("Playing"))
            .catch(() => setUI("Stopped"));
        }

        // Music button click handler
        document
          .getElementById("music-dropdown")
          .querySelector("button")
          .addEventListener("click", (e) => {
            e.stopPropagation();
            dropdown.style.display =
              dropdown.style.display === "block" ? "none" : "block";

            if (audioPlayer.src && !audioPlayer.paused) {
              audioPlayer.pause();
              setUI("Stopped");
            } else if (audioPlayer.src) {
              audioPlayer.play().then(() => setUI("Playing"));
            }
          });

        // Music selection handlers
        dropdown.querySelectorAll("a[data-src]").forEach((link) => {
          link.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.src = link.dataset.src;
            audioPlayer.play().then(() => setUI("Playing"));
            localStorage.setItem("cybersec_music_src", link.dataset.src);
            dropdown.style.display = "none";
          });
        });

        // Stop music handler
        const stopLink = document.getElementById("stop-music-link");
        if (stopLink) {
          stopLink.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            audioPlayer.removeAttribute("src");
            setUI("Stopped");
            localStorage.removeItem("cybersec_music_src");
            localStorage.removeItem("cybersec_music_time");
            dropdown.style.display = "none";
          });
        }

        // Save music state before page unload
        window.addEventListener("beforeunload", () => {
          if (!audioPlayer.paused && audioPlayer.src) {
            localStorage.setItem("cybersec_music_src", audioPlayer.src);
            localStorage.setItem(
              "cybersec_music_time",
              audioPlayer.currentTime
            );
          }
        });

        // Close dropdown when clicking outside
        window.addEventListener("click", (e) => {
          if (!e.target.closest("#music-dropdown")) {
            dropdown.style.display = "none";
          }
        });
      }

      // Show initial music indicator
      function addMusicIndicator() {
        const musicBtn = document.querySelector("#music-dropdown");
        if (musicBtn) {
          const indicator = document.createElement("div");
          indicator.className = "music-indicator";
          indicator.innerHTML = `<i class="fa-solid fa-music"></i> Try Study Music!`;

          musicBtn.style.position = "relative";
          musicBtn.appendChild(indicator);

          setTimeout(() => indicator.remove(), 3000);
        }
      }

      // Initialize Event Listeners
      function initializeEventListeners() {
        // Navigation buttons
        document
          .getElementById("prevLessonBtn")
          ?.addEventListener("click", goToPreviousLesson);
        document
          .getElementById("nextLessonBtn")
          ?.addEventListener("click", goToNextLesson);

        // Reset progress button
        document
          .getElementById("resetProgressBtn")
          ?.addEventListener("click", resetProgress);

        // Mobile menu toggle
        document
          .getElementById("menuToggle")
          ?.addEventListener("click", toggleSidebar);
        document
          .getElementById("sidebarOverlay")
          ?.addEventListener("click", closeSidebar);

        // Keyboard shortcuts
        document.addEventListener("keydown", handleKeyboardShortcuts);

        // Window resize handler
        window.addEventListener("resize", handleWindowResize);

        // Content interaction tracking
        document.getElementById("contentBody")?.addEventListener(
          "scroll",
          debounce(() => {
            trackUserInteraction();
          }, 1000)
        );
      }

      // Keyboard Shortcuts
      function handleKeyboardShortcuts(e) {
        if (document.querySelector(".quiz-question.active")) return;

        if (e.key === "ArrowLeft" && e.ctrlKey) {
          e.preventDefault();
          goToPreviousLesson();
        } else if (e.key === "ArrowRight" && e.ctrlKey) {
          e.preventDefault();
          goToNextLesson();
        }
      }

      // Window Resize Handler
      function handleWindowResize() {
        if (window.innerWidth > 768) {
          closeSidebar();
        }
      }

      // Debounce Helper
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Initialize responsive behavior
      if (window.innerWidth <= 768) {
        document.getElementById("menuToggle").style.display = "inline-flex";
      }

      // Auto-save progress periodically
      setInterval(async () => {
        if (currentUser && Object.keys(courseProgress).length > 0) {
          await saveProgress();
        }
      }, 60000); // Save every minute

      // System initialization logging
      console.log("CyberSec Academy Course System Initialized");
      console.log("Current Course:", COURSE_DATA.title);
      console.log("Total Lessons:", COURSE_DATA.lessons.length);

      // Google OAuth Integration
      const googleBtn = document.querySelector(".btn-google");
      if (googleBtn) {
        googleBtn.addEventListener("click", async () => {
          const { data, error } = await supabase.auth.signInWithOAuth({
            provider: "google",
            options: {
              redirectTo:
                window.location.origin +
                "/courses/memory-forensics-complete-course.html",
            },
          });

          if (error) {
            console.error("Google login error:", error.message);
            showToast("Google login failed: " + error.message, "error");
          }
        });
      }

      // Check for existing session
      supabase.auth.getSession().then(({ data }) => {
        if (data.session) {
          console.log("User already logged in:", data.session.user);
          currentUser = data.session.user;
          startCourseSession();
        }
      });

      // Add missing auth modal functions
      function openAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "flex";
        }
      }

      function closeAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Add auth tab switching functionality
      document.getElementById("tabSignIn")?.addEventListener("click", () => {
        document.getElementById("tabSignIn").classList.add("active");
        document.getElementById("tabSignUp").classList.remove("active");
        document.getElementById("signInForm").style.display = "block";
        document.getElementById("signUpForm").style.display = "none";
      });

      document.getElementById("tabSignUp")?.addEventListener("click", () => {
        document.getElementById("tabSignUp").classList.add("active");
        document.getElementById("tabSignIn").classList.remove("active");
        document.getElementById("signUpForm").style.display = "block";
        document.getElementById("signInForm").style.display = "none";
      });

      document
        .getElementById("closeAuthModal")
        ?.addEventListener("click", closeAuthModal);

      // Improved error handling for auth session
      supabase.auth.onAuthStateChange((event, session) => {
        if (event === "SIGNED_IN") {
          currentUser = session.user;
          closeAuthModal();
          startCourseSession();
        } else if (event === "SIGNED_OUT") {
          currentUser = null;
          openAuthModal();
        }
      });

      // Add form submission handlers
      document
        .getElementById("emailSignInForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signInEmail").value;
          const password = document.getElementById("signInPassword").value;

          try {
            const { data, error } = await supabase.auth.signInWithPassword({
              email,
              password,
            });

            if (error) throw error;

            closeAuthModal();
          } catch (error) {
            showToast(error.message, "error");
          }
        });

      document
        .getElementById("emailSignUpForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signUpEmail").value;
          const password = document.getElementById("signUpPassword").value;
          const name = document.getElementById("signUpName").value;

          try {
            const { data, error } = await supabase.auth.signUp({
              email,
              password,
              options: {
                data: {
                  full_name: name,
                },
              },
            });

            if (error) throw error;

            showToast(
              "Account created successfully! Please check your email.",
              "success"
            );
          } catch (error) {
            showToast(error.message, "error");
          }
        });
    </script>
  </body>
</html>
