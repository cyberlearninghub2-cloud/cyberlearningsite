



<!DOCTYPE html>
<html lang="en">
 <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- ========== Start: SEO & Schema Enhancement ========== -->
    <title>Complete Secure Software Development Course | CipherHall</title>
    <meta name="description" content="Enroll in our expert-led Secure Software Development course. A comprehensive, hands-on course for developers on how to design, build, and maintain secure applications." />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png" />
    <link rel="shortcut icon" href="/favicon.png" type="image/x-icon" />
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png" />
    <link rel="canonical" href="https://www.cipherhall.com/courses/complete-secure-software-development-course" />

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Course",
      "name": "Complete Secure Software Development Course",
      "description": "A comprehensive, hands-on course for developers on how to design, build, and maintain secure and resilient software applications.",
      "provider": {
        "@type": "Organization",
        "name": "CipherHall",
        "sameAs": "https://www.cipherhall.com"
      },
      "hasCourseInstance": {
        "@type": "CourseInstance",
        "courseMode": "Online",
        "instructor": {
          "@type": "Person",
          "name": "Dr. Chloe Anderson"
        }
      }
    }
    </script>
    <!-- ========== End: SEO & Schema Enhancement ========== -->

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Exo+2:wght@700;800;900&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css"
    />
    <link rel="icon" type="image/x-icon" href="assets/favicon.ico" />

    <link rel="stylesheet" href="assets/css/coursepages.css" />
</head>
  <body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
      <div class="loader-icon">
        <i class="fas fa-graduation-cap"></i>
      </div>
      <div class="loader-text">Loading Course Content...</div>
    </div>

    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- Music Player (fixed at top right) -->
    <div class="header-controls">
      <div class="music-dropdown" id="music-dropdown">
        <button class="btn btn-secondary">
          <span id="music-button-text">STUDY MUSIC</span>
          <i id="music-icon" class="fa-solid fa-music"></i>
        </button>
        <div class="music-dropdown-content" id="music-dropdown-content">
          <a
            href="#"
            data-src="https://www.learningcontainer.com/wp-content/uploads/2020/02/Kalimba.mp3"
            >1. Coffee Shop Vibes</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3"
            >2. City Lights Lofi</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-15.mp3"
            >3. Mellow Thoughts</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-13.mp3"
            >4. Rainy Mood</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3"
            >5. Time Alone</a
          >
          <a href="#" id="stop-music-link"
            ><i class="fa-solid fa-stop-circle"></i> Stop Music</a
          >
        </div>
      </div>

      <button class="btn btn-secondary" id="resetProgressBtn">
        <i class="fas fa-redo"></i>
        Reset Progress
      </button>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal" style="display: none">
      <div class="modal-overlay"></div>
      <div class="modal-content">
        <span class="close" id="closeAuthModal">&times;</span>
        <div class="auth-tabs">
          <button id="tabSignIn" class="auth-tab active">Sign In</button>
          <button id="tabSignUp" class="auth-tab">Sign Up</button>
        </div>
        <div
          id="authLoader"
          style="display: none; text-align: center; padding: 2rem"
        >
          <i
            class="fas fa-spinner fa-spin fa-2x"
            style="color: var(--color-green)"
          ></i>
          <p style="margin-top: 0.5rem">Authenticating...</p>
        </div>
        <div id="signInForm" class="auth-form">
          <h2>Sign In to CipherHall</h2>
          <button id="googleSignIn" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignInForm">
            <input
              type="email"
              id="signInEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signInPassword"
              placeholder="Password"
              required
            />
            <button type="submit" class="btn btn-primary">Sign In</button>
          </form>
        </div>
        <div id="signUpForm" class="auth-form" style="display: none">
          <h2>Join CipherHall</h2>
          <button id="googleSignUp" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignUpForm">
            <input
              type="text"
              id="signUpName"
              placeholder="Full Name"
              required
            />
            <input
              type="email"
              id="signUpEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signUpPassword"
              placeholder="Password (min. 8 characters)"
              required
            />
            <button type="submit" class="btn btn-secondary">
              Create Account
            </button>
          </form>
        </div>
        <div id="authMessage"></div>
      </div>
    </div>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="course-info">
          <h1 class="course-title" id="courseTitle">Loading...</h1>
          <div class="course-progress">
            <div class="progress-header">
              <span class="progress-label">Course Progress</span>
              <span class="progress-percentage" id="courseProgressPercent"
                >0%</span
              >
            </div>
            <div class="progress-bar">
              <div
                class="progress-fill"
                id="courseProgressFill"
                style="width: 0%"
              ></div>
            </div>
            <div class="progress-stats">
              <span id="completedLessons">0</span>
              <span id="totalLessons">0</span>
            </div>
          </div>
          <a href="/dashboard" class="back-to-dashboard">
            <i class="fas fa-arrow-left"></i>
            Back to Dashboard
          </a>
        </div>
      </div>

      <nav class="lesson-nav" id="lessonNav">
        <!-- Lessons will be loaded dynamically -->
      </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <header class="content-header">
        <div class="lesson-header">
          <div class="lesson-header-left">
            <span class="lesson-number" id="currentLessonNumber">1</span>
            <h1 class="lesson-header-title" id="currentLessonTitle">
              Loading...
            </h1>
          </div>
          <div class="lesson-actions">
            <button class="mbtn btn-primary" id="menuToggle">
              <i class="fas fa-bars"></i>
            </button>
          </div>
        </div>
      </header>

      <div class="content-body" id="contentBody">
        <div class="lesson-content" id="lessonContent">
          <!-- Lesson content will be loaded dynamically -->
        </div>
      </div>

      <footer class="lesson-navigation">
        <div class="nav-info" id="navInfo">Lesson 1 of 10</div>
        <div class="nav-controls">
          <button class="btn btn-secondary" id="prevLessonBtn" disabled>
            <i class="fas fa-chevron-left"></i>
            Previous
          </button>
          <button class="btn btn-primary" id="nextLessonBtn" disabled>
            Next
            <i class="fas fa-chevron-right"></i>
          </button>
        </div>
      </footer>
    </main>

    <!-- Achievement Notification -->
    <div id="achievementNotification" class="achievement-notification">
      <div class="notification-header">
        <div class="notification-icon" id="notificationIcon">
          <i class="fas fa-trophy"></i>
        </div>
        <div class="notification-content">
          <h3 id="notificationTitle">Achievement Unlocked!</h3>
          <p id="notificationDescription">Description here...</p>
        </div>
      </div>
      <div class="notification-reward" id="notificationReward">
        <i class="fas fa-coins"></i>
        <span id="notificationPoints">+100 Points</span>
      </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast">
      <span id="toastMessage"></span>
    </div>

    <script>
      // =====================================================
      // SYNCHRONIZED COURSE SYSTEM WITH DASHBOARD INTEGRATION
      // =====================================================

      // Supabase Configuration - Replace with your config
      const supabaseUrl = "https://lzcmzulemfubjaksoqor.supabase.co";
      const supabaseKey =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx6Y216dWxlbWZ1Ympha3NvcW9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzMzM5MDgsImV4cCI6MjA3MDkwOTkwOH0.crhPH4YWtRsr1BJTpAQcmPbWSpwIWRbzoI4sRb2_fPI";
      const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

      // =====================================================
      // COURSE DATA STRUCTURE - REPLACE WITH YOUR COURSE JSON
      // =====================================================
      const COURSE_DATA =
{
    "id": "secure-software-development",
    "title": "Complete Secure Software Development Course",
    "description": "A comprehensive, hands-on course for developers on how to design, build, and maintain secure and resilient software applications.",
    "category": "application-security",
    "difficulty": "Intermediate",
    "duration": "80 hours",
    "instructor": "Dr. Chloe Anderson",
    "lessons": [
        {
            "id": "lesson-1",
            "title": "Fundamentals of Secure Software Development",
            "duration": "90 min",
            "objectives": [
                "Understand the core principles of software security.",
                "Recognize the importance of integrating security throughout the entire SDLC.",
                "Analyze the exponential cost of fixing vulnerabilities late in the lifecycle.",
                "Grasp the cultural and mindset shift required for a security-first development approach."
            ],
            "content": {
                "overview": "This foundational lesson sets the stage for the entire course. We will explore why software security is no longer an optional extra but a fundamental aspect of quality. We'll cover the core principles, the business case for security, and the cultural shift required to move from a reactive to a proactive security mindset.",
                "sections": [
                    {
                        "title": "Software Security Principles and Concepts",
                        "content": "<p>Secure software development is built on a set of core principles that guide every decision.</p><h3>The Security Triad (CIA):</h3><ul><li><strong>Confidentiality:</strong> Ensuring that data is accessible only to those with authorized access.</li><li><strong>Integrity:</strong> Protecting data from unauthorized modification or deletion.</li><li><strong>Availability:</strong> Ensuring that systems and data are available to authorized users when needed.</li></ul><p>Our goal as developers is to build software that upholds these three principles in the face of threats.</p>",
                        "image": "https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Security Throughout the Software Development Lifecycle (SDLC)",
                        "content": "<p>The traditional 'waterfall' model of security, where a penetration test is performed just before release, is broken and inefficient. A secure SDLC integrates security activities into every phase.</p><ul><li><strong>Requirements:</strong> Define security requirements alongside functional ones.</li><li><strong>Design:</strong> Perform threat modeling to find design flaws.</li><li><strong>Develop:</strong> Write secure code and use automated tools (SAST/SCA) for fast feedback.</li><li><strong>Test:</strong> Perform dynamic and interactive testing (DAST/IAST) in a running environment.</li><li><strong>Deploy:</strong> Secure the configuration of the application and its infrastructure.</li><li><strong>Maintain:</strong> Continuously monitor for threats and manage vulnerabilities.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1542626991-a2f5702b3c2b?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Cost of Security Fixes Across Phases",
                        "content": "<p>The cost of fixing a security vulnerability increases exponentially the later it is found in the SDLC. A bug that costs $1 to fix in the design phase might cost $10 to fix in development, $100 in QA, and over $1000 if found in production after a breach.</p><div class=\"info-box tip\"><div class=\"info-box-header\"><i class=\"fas fa-lightbulb\"></i><strong>Shift Left</strong></div><p>This economic reality is the primary driver for the 'Shift Left' movement: finding and fixing vulnerabilities as early as possible in the lifecycle, where it is cheapest and most efficient.</p></div>",
                        "image": "https://images.unsplash.com/photo-16008802 pesado-292210-859bb1fed5b1?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 1: Vulnerability Impact Assessment Simulator",
                        "language": "markdown",
                        "code": "# Vulnerability Cost Simulation\n\n**Scenario:** A SQL Injection vulnerability.\n\n- **Cost if found in Design Phase (Threat Model):**\n  - **Time:** 1 hour (Architect discussion)\n  - **Cost:** ~$100 (Architect's time)\n\n- **Cost if found in Development Phase (SAST Tool):**\n  - **Time:** 4 hours (Developer time to fix and test)\n  - **Cost:** ~$400 (Developer's time)\n\n- **Cost if found in Production (External Breach):**\n  - **Time:** 200+ hours (Incident response, forensics, legal, PR)\n  - **Cost:** $1,000,000+ (Fines, customer loss, reputation damage, remediation)"
                    },
                    {
                        "title": "Code Example 1: Security Requirements Documentation Generator",
                        "language": "yaml",
                        "code": "# A simple security requirement definition for a user login feature\n\nfeature: User Login\n\nrequirements:\n  - id: SEC-REQ-001\n    type: Functional\n    description: The system MUST enforce multi-factor authentication for all users with the 'admin' role.\n  - id: SEC-REQ-002\n    type: Non-Functional\n    description: The password reset mechanism MUST be protected against host header injection attacks.\n  - id: SEC-REQ-003\n    type: Non-Functional\n    description: User passwords MUST NOT be stored in clear text."
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "The three core principles of security, known as the CIA triad, are:",
                        "options": [
                            "Confidentiality, Integrity, and Availability",
                            "Code, Integrate, and Automate",
                            "Cost, Impact, and Action",
                            "Control, Investigate, and Audit"
                        ],
                        "correct": 0,
                        "explanation": "The CIA triad is the foundational model for information security. All security controls are designed to protect one or more of these three principles."
                    },
                    {
                        "id": 2,
                        "question": "At which phase of the SDLC is it cheapest to fix a security vulnerability?",
                        "options": [
                            "In Production",
                            "During QA Testing",
                            "During the Development/Coding Phase",
                            "During the Design/Requirements Phase"
                        ],
                        "correct": 3,
                        "explanation": "The cost to fix a flaw increases exponentially the later it is found. Finding a design flaw on a whiteboard is far cheaper than remediating a data breach in production."
                    },
                    {
                        "id": 3,
                        "question": "The modern approach of integrating security into every phase of the development lifecycle is known as:",
                        "options": [
                            "The Waterfall Model",
                            "A Secure SDLC (or DevSecOps)",
                            "The Ad-hoc Model",
                            "The Release-gate Model"
                        ],
                        "correct": 1,
                        "explanation": "A Secure SDLC is a proactive, holistic approach that makes security a continuous concern, rather than a single, late-stage testing activity."
                    },
                    {
                        "id": 4,
                        "question": "The 'Shift Left' movement in software security refers to:",
                        "options": [
                            "Moving security activities to the right, into production.",
                            "Moving security activities to the left, to the earliest possible point in the lifecycle.",
                            "Giving all security work to a single team.",
                            "Ignoring security until after a breach."
                        ],
                        "correct": 1,
                        "explanation": "Shifting left is the tactical implementation of a proactive security strategy, focusing on finding and fixing flaws early to reduce cost and risk."
                    }
                ]
            }
        },
        {
            "id": "lesson-2",
            "title": "Threat Modeling for Software Applications",
            "duration": "120 min",
            "objectives": [
                "Understand the purpose and process of threat modeling.",
                "Learn to apply the STRIDE methodology to identify potential threats.",
                "Practice creating data flow diagrams to map attack surfaces.",
                "Develop a risk-based approach to planning mitigations."
            ],
            "content": {
                "overview": "Threat modeling is one of the most effective security practices a developer can learn. It is a structured, proactive exercise to identify and mitigate security threats in the design phase, before any code is written. This lesson provides a hands-on introduction to the 'what, why, and how' of threat modeling.",
                "sections": [
                    {
                        "title": "Threat Modeling Methodologies",
                        "content": "<p>Threat modeling is about answering four key questions:</p><ol><li><strong>What are we building?</strong> (Diagramming the system)</li><li><strong>What can go wrong?</strong> (Identifying threats)</li><li><strong>What are we going to do about it?</strong> (Mitigating threats)</li><li><strong>Did we do a good job?</strong> (Validating the mitigations)</li></p><p><strong>STRIDE</strong> is a popular and developer-friendly methodology for identifying threats (question #2). It's a mnemonic for the six key threat categories.</p>",
                        "image": "https://images.unsplash.com/photo-1543286386-713bdd548da4?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Trust Boundaries and Data Flow Mapping",
                        "content": "<p>The first step is to diagram the system using a Data Flow Diagram (DFD). A DFD shows the key components and how data flows between them.</p><h3>DFD Components:</h3><ul><li><strong>External Entities:</strong> Users or other systems that interact with your application.</li><li><strong>Processes:</strong> The components of your application that process data (e.g., an API, a microservice).</li><li><strong>Data Stores:</strong> Where data is stored (e.g., a database, a file store).</li><li><strong>Data Flows:</strong> Arrows showing the movement of data between the other components.</li></ul><p>A <strong>Trust Boundary</strong> is a line you draw on your DFD to separate components with different levels of trust. For example, a boundary between the user's browser (untrusted) and your backend API (trusted).</p>",
                        "image": "https://images.unsplash.com/photo-1542438408-abb2021e33f6?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The STRIDE Threat Model",
                        "content": "<p>Once you have a DFD, you can analyze each component and data flow using the STRIDE categories to brainstorm threats.</p><ul><li><strong>Spoofing:</strong> Illegally assuming another's identity. (Threatens Authentication)</li><li><strong>Tampering:</strong> Unauthorized modification of data. (Threatens Integrity)</li><li><strong>Repudiation:</strong> A user denying they performed an action. (Threatens Non-Repudiation)</li><li><strong>Information Disclosure:</strong> Exposing data to unauthorized parties. (Threatens Confidentiality)</li><li><strong>Denial of Service (DoS):</strong> Making a system unavailable to legitimate users. (Threatens Availability)</li><li><strong>Elevation of Privilege:</strong> Gaining capabilities without proper authorization. (Threatens Authorization)</li></ul>",
                        "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 2: Interactive Threat Modeling Workshop Platform",
                        "language": "markdown",
                        "code": "# Threat Model for a Simple File Upload Feature\n\n**DFD:** `User -> [Web App] -> [S3 Bucket]`\n**Trust Boundary:** Between User and Web App.\n\n### STRIDE Analysis of the Data Flow `User -> [Web App]`:\n\n- **Spoofing:** Can a user upload a file on behalf of another user?\n  - **Mitigation:** Require strong authentication.\n- **Tampering:** Can a user modify the file in transit?\n  - **Mitigation:** Use TLS.\n- **Information Disclosure:** Does the upload response leak sensitive system information?\n  - **Mitigation:** Use generic error messages.\n- **Denial of Service:** Can a user upload a massive file and exhaust server resources?\n  - **Mitigation:** Enforce strict file size limits.\n- **Elevation of Privilege:** Can a user upload a web shell (`.php`) and have it executed by the server?\n  - **Mitigation:** Validate file types (allow-list) and store uploads in a non-web-accessible location (like a separate S3 bucket)."
                    },
                    {
                        "title": "Code Example 2: Automated Threat Model Generator and Validator",
                        "language": "python",
                        "code": "def analyze_dfd_element(element):\n    threats = []\n    # If the element is a data store, automatically add standard threats.\n    if element['type'] == 'DataStore':\n        threats.append({\n            'threat': 'Information Disclosure',\n            'scenario': 'Data at rest is read by an unauthorized party.',\n            'mitigation_suggestion': 'Implement encryption at rest.'\n        })\n        threats.append({\n            'threat': 'Tampering',\n            'scenario': 'Data at rest is modified by an unauthorized party.',\n            'mitigation_suggestion': 'Implement strong access controls.'\n        })\n    return threats"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary goal of threat modeling?",
                        "options": [
                            "To find and fix bugs in production.",
                            "To write a formal security policy.",
                            "To proactively identify and mitigate security threats during the design phase.",
                            "To test the application's performance."
                        ],
                        "correct": 2,
                        "explanation": "Threat modeling is a proactive 'shift-left' security practice. Its purpose is to find and fix architectural design flaws before they are turned into code."
                    },
                    {
                        "id": 2,
                        "question": "In a Data Flow Diagram (DFD), a line drawn to separate components with different levels of trust is called a:",
                        "options": [
                            "Data Flow",
                            "Process Boundary",
                            "Trust Boundary",
                            "External Entity"
                        ],
                        "correct": 2,
                        "explanation": "Trust boundaries are a key concept in threat modeling. Threats often arise at the point where data crosses a trust boundary (e.g., from an untrusted user into a trusted backend process)."
                    },
                    {
                        "id": 3,
                        "question": "A threat where an attacker modifies data in a database falls under which STRIDE category?",
                        "options": [
                            "Spoofing",
                            "Repudiation",
                            "Information Disclosure",
                            "Tampering"
                        ],
                        "correct": 3,
                        "explanation": "Tampering is the unauthorized modification of data, which violates the principle of Integrity."
                    },
                    {
                        "id": 4,
                        "question": "A threat where a regular user finds a flaw that allows them to become an administrator falls under which STRIDE category?",
                        "options": [
                            "Denial of Service",
                            "Elevation of Privilege",
                            "Spoofing",
                            "Repudiation"
                        ],
                        "correct": 1,
                        "explanation": "Elevation of Privilege is the threat of gaining unauthorized permissions, which violates the principle of Authorization."
                    }
                ]
            }
        },
        {
            "id": "lesson-3",
            "title": "Secure Design Principles",
            "duration": "90 min",
            "objectives": [
                "Understand and apply the principle of Defense in Depth.",
                "Learn to implement the Principle of Least Privilege in software design.",
                "Grasp the importance of designing systems that Fail Securely.",
                "Differentiate between Open Design and Security through Obscurity."
            ],
            "content": {
                "overview": "Secure design principles are timeless, fundamental concepts that form the bedrock of a resilient and defensible software architecture. They are the 'rules of the road' for security architects and developers. This lesson covers the most important of these principles and how to apply them in practice.",
                "sections": [
                    {
                        "title": "Defense in Depth Architecture",
                        "content": "<p>Defense in Depth is the principle of applying security controls in multiple layers. The idea is that if one layer of defense fails, there are other layers behind it to stop an attack.</p><h3>Example: Securing a Web Application</h3><ul><li><strong>Layer 1 (Edge):</strong> Web Application Firewall (WAF)</li><li><strong>Layer 2 (Host):</strong> Hardened operating system, EDR agent</li><li><strong>Layer 3 (Application):</strong> Secure coding (e.g., parameterized queries to prevent SQLi)</li><li><strong>Layer 4 (Data):</strong> Encryption of sensitive data at rest in the database</li></ul><p>A single control is a single point of failure. Layering controls provides resilience.</p>",
                        "image": "https://images.unsplash.com/photo-1569864016487-36e6933f7841?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Principle of Least Privilege Implementation",
                        "content": "<p>The Principle of Least Privilege (PoLP) states that any user, program, or process should have only the bare minimum permissions necessary to perform its intended function.</p><h3>Implementation Examples:</h3><ul><li><strong>Database Access:</strong> An application service account that only needs to read customer data should only be granted the `SELECT` permission on the `customers` table. It should not be given `UPDATE` or `DELETE` permissions, and it should not be the database owner (`dbo`).</li><li><strong>File Permissions:</strong> A web server process should have read-only access to its content files, not write access.</li><li><strong>User Roles:</strong> A standard user should not be able to access the application's administrative functions.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1585435465945-594241c39332?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Fail Securely Design Patterns",
                        "content": "<p>This principle means that if a system fails for any reason, it should fail into a secure state. The default should be to deny access.</p><h3>Examples:</h3><ul><li><strong>Exception Handling:</strong> If a block of code that checks a user's permissions throws an unexpected exception, the `catch` block should deny access rather than allowing it.</li><li><strong>Firewall Rules:</strong> The last rule in a firewall ruleset should be an explicit `deny all`. Access is only granted by specific `allow` rules.</li><li><strong>New Accounts:</strong> A newly created user account should have zero permissions by default. Permissions must be explicitly granted.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1544256718-3b62ff04b356?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Open Design vs Security Through Obscurity",
                        "content": "<p>The principle of <strong>Open Design</strong> (also known as Kerckhoffs's Principle) states that the security of a system should not depend on the secrecy of its design or implementation. You should assume that an attacker knows everything about your architecture and your code.</p><p><strong>Security Through Obscurity</strong> is the opposite, and it is a failed strategy. It relies on hoping an attacker won't find a weakness. Examples include hiding a server by giving it a weird name, or assuming an API is safe because it's not publicly documented. Attackers are very good at discovering obscure systems.</p>",
                        "image": "https://images.unsplash.com/photo-1516321497487-e288fb19713f?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 3: Secure Architecture Design Workshop",
                        "language": "java",
                        "code": "// Example of Failing Securely\n\npublic boolean isUserAdmin(User user) {\n    try {\n        // This call could fail if the directory server is down\n        return directoryService.getRoles(user.getId()).contains(\"admin\");\n    } catch (Exception e) {\n        // Log the error\n        log.error(\"Failed to check user roles for user: \" + user.getId(), e);\n        \n        // Fail securely by defaulting to the least privileged state\n        return false; \n    }\n}"
                    },
                    {
                        "title": "Code Example 3: Security Pattern Implementation Library",
                        "language": "sql",
                        "code": "-- Example of Principle of Least Privilege\n\n-- Create a specific user for the reporting application\nCREATE USER reporting_app_user WITH PASSWORD 'managed_by_vault';\n\n-- Grant the bare minimum permissions needed.\n-- This user can ONLY read data from the 'sales_summary' view.\n-- It cannot access any other tables or perform any modifications.\nGRANT SELECT ON sales_summary TO reporting_app_user;"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "Creating a web server that can only read its own content files and a database service account that only has SELECT permissions are examples of which principle?",
                        "options": [
                            "Defense in Depth",
                            "Fail Securely",
                            "Principle of Least Privilege",
                            "Security Through Obscurity"
                        ],
                        "correct": 2,
                        "explanation": "The Principle of Least Privilege is all about granting the absolute minimum permissions required for a function. This limits the potential damage if that component is compromised."
                    },
                    {
                        "id": 2,
                        "question": "A firewall that is configured with an explicit 'deny all' rule at the very end of its ruleset is an example of what principle?",
                        "options": [
                            "Defense in Depth",
                            "Fail Securely",
                            "Open Design",
                            "Economy of Mechanism"
                        ],
                        "correct": 1,
                        "explanation": "This is a classic 'default deny' posture, which is a key part of failing securely. Access is only granted if a specific 'allow' rule is matched; otherwise, the default is to block."
                    },
                    {
                        "id": 3,
                        "question": "The idea that the security of your system should not depend on the secrecy of your source code or architecture is known as:",
                        "options": [
                            "Security Through Obscurity",
                            "Complete Mediation",
                            "Open Design",
                            "Least Common Mechanism"
                        ],
                        "correct": 2,
                        "explanation": "The principle of Open Design dictates that you should design your systems assuming the attacker knows everything about how they work. The security should rest in the strength of your keys and your algorithms, not in secrecy."
                    },
                    {
                        "id": 4,
                        "question": "Using a WAF, followed by a hardened OS, followed by secure application code, is an example of what principle?",
                        "options": [
                            "Defense in Depth",
                            "Fail Securely",
                            "Least Privilege",
                            "Open Design"
                        ],
                        "correct": 0,
                        "explanation": "Defense in Depth is the strategy of layering multiple, different security controls. If an attacker bypasses the WAF, they still have to face the hardened OS and the secure code, increasing the overall resilience of the system."
                    }
                ]
            }
        },
        {
            "id": "lesson-4",
            "title": "Input Validation and Output Encoding",
            "duration": "120 min",
            "objectives": [
                "Understand that all external input is untrusted and must be validated.",
                "Implement a positive validation (allow-list) strategy.",
                "Learn to apply contextual output encoding to prevent injection attacks.",
                "Design secure mechanisms for handling file uploads."
            ],
            "content": {
                "overview": "Improper handling of input and output is the root cause of the most common and dangerous software vulnerabilities, especially injection attacks like Cross-Site Scripting (XSS) and SQL Injection. This lesson covers the two fundamental defensive techniques: validating everything that comes in, and encoding everything that goes out.",
                "sections": [
                    {
                        "title": "Input Validation Strategies",
                        "content": "<p>The core principle is: <strong>never trust external input</strong>. Input from a user, an API, or another system must be rigorously validated before it is used.</p><h3>Whitelisting vs. Blacklisting:</h3><ul><li><strong>Blacklisting (Bad):</strong> Trying to define a list of 'bad' characters or patterns and blocking them. This is doomed to fail, as attackers will always find a way to bypass an incomplete blocklist.</li><li><strong>Whitelisting / Allow-listing (Good):</strong> Defining exactly what is allowed, and rejecting everything else. This is the most effective strategy.</li></ul><h3>Validation Techniques:</h3><ul><li><strong>Type Checking:</strong> Is the input the correct data type (e.g., an integer, not a string)?</li><li><strong>Length Checking:</strong> Does the input meet the expected minimum and maximum length?</li><li><strong>Format Checking:</strong> Does the input match a strict format, such as a regular expression for a zip code or an email address?</li><li><strong>Range Checking:</strong> Is a numerical input within its expected range?</li></ul>",
                        "image": "https://images.unsplash.com/photo-1555099962-4199c345e546?w=800&h=400&fit=crop"
                    },
                   {
  "title": "Output Encoding for Different Contexts",
  "content": "<p>Output encoding is the process of taking data and converting potentially special characters into a safe, non-executable form before displaying it to the user. This is the primary defense against Cross-Site Scripting (XSS).</p><p>The key is that the encoding must be <strong>contextual</strong>â€”it depends on where in the output you are placing the untrusted data.</p><h3>Common Contexts:</h3><ul><li><strong>HTML Body:</strong> Use HTML entity encoding (e.g., `&lt;` becomes `&amp;lt;`).</li><li><strong>HTML Attributes:</strong> Use HTML attribute encoding (e.g., `&gt;` becomes `&amp;gt;`).</li><li><strong>JavaScript Variables:</strong> Use JavaScript string encoding (e.g., `\\\"` becomes `\\\\\\\"`).</li><li><strong>URL Parameters:</strong> Use URL encoding (e.g., space becomes `%20`).</li></ul><p>Modern web frameworks often provide libraries that perform contextual encoding automatically. You should always use these trusted libraries rather than trying to write your own encoding functions.</p>",
  "image": "https://images.unsplash.com/photo-1517694712202-14dd9538aa97?w=800&h=400&fit=crop"
},
                    {
                        "title": "File Upload Security",
                        "content": "<p>File uploads are a high-risk feature. An attacker could upload a web shell, a virus, or a file designed to exploit a vulnerability in the server-side processing library.</p><h3>Key Controls:</h3><ol><li><strong>Validate the File Type:</strong> Use an allow-list of permitted file extensions. Do not rely on the `Content-Type` header, as it can be easily spoofed. For higher security, check the file's 'magic numbers' to verify its true type.</li><li><strong>Scan for Malware:</strong> Pass the uploaded file to an antivirus or malware scanner before it is stored.</li><li><strong>Store Securely:</strong> Store the uploaded file outside of the web root, in a separate, isolated directory or object store (like S3). This prevents it from being executed by the web server.</li><li><strong>Use a Generic Filename:</strong> Rename the file on the server to a randomly generated name. Do not use the user-supplied filename, as it could contain path traversal characters (`../`).</li></ol>",
                        "image": "https://images.unsplash.com/photo-1588665387928-a8d2a13f8373?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 4: Comprehensive Input Validation Framework",
                        "language": "java",
                        "code": "import java.util.regex.Pattern;\n\npublic class InputValidator {\n\n    // Whitelist pattern for a valid username (alphanumeric, 3-16 chars)\n    private static final Pattern USERNAME_PATTERN = Pattern.compile(\"^[a-zA-Z0-9]{3,16}$\");\n\n    public static boolean isValidUsername(String username) {\n        if (username == null) {\n            return false;\n        }\n        // Use the strict whitelist pattern for validation\n        return USERNAME_PATTERN.matcher(username).matches();\n    }\n}"
                    },
{
  "title": "Code Example 4: Universal Input Sanitization and Validation Library",
  "language": "javascript",
  "code": "// Example of contextual output encoding in a web framework (conceptual)\n\n// Untrusted data from a user\nconst userInput = '\\u003cSCRPT\\u003ealert(\\\"XSS\\\")\\u003c/ SCRPT\\u003e';\n\n// --- Rendering in HTML Body ---\n// Framework automatically applies HTML entity encoding\n// Output: <div>&lt;SCRPT&gt;alert(&quot;XSS&quot;)&lt;/SCRPT&gt;</div>\nconst htmlBodyOutput = `<div>${framework.encodeForHtml(userInput)}</div>`;\n\n// --- Rendering in a JavaScript variable ---\n// Framework applies JavaScript string encoding\n// Output: <SCRPT>var username = \"\\u003cSCRPT\\u003ealert\\u0028\\u0027XSS\\u0027\\u0029\\u003c/ SCRPT\\u003e\";</SCRPT>\nconst scriptOutput = `\\u003cSCRPT\\u003evar username = \\\"${framework.encodeForJs(userInput)}\\\";\\u003c/ SCRPT\\u003e`;"
}



                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the most effective strategy for input validation?",
                        "options": [
                            "Blacklisting (denying known bad input)",
                            "Trusting all input from authenticated users",
                            "Whitelisting (allowing only known good input)",
                            "Disabling input validation for performance."
                        ],
                        "correct": 2,
                        "explanation": "Whitelisting, or positive validation, is the strongest approach because it forces you to define a strict format for what is acceptable. Any input that does not match this format is rejected. It is much more secure than trying to guess all the possible 'bad' inputs an attacker might try."
                    },
                    {
                        "id": 2,
                        "question": "Contextual output encoding is the primary defense against which vulnerability?",
                        "options": [
                            "Cross-Site Scripting (XSS)",
                            "Cross-Site Request Forgery (CSRF)",
                            "Denial of Service",
                            "Insecure Deserialization"
                        ],
                        "correct": 0,
                        "explanation": "XSS occurs when an application renders untrusted data to a user's browser without properly encoding it, allowing the attacker's script to execute. Contextual output encoding neutralizes these scripts by converting them into harmless text."
                    },
                    {
                        "id": 3,
                        "question": "A user uploads a file named `../../../../etc/passwd`. An attack that attempts to use this filename to access a sensitive system file is known as:",
                        "options": [
                            "SQL Injection",
                            "Path Traversal",
                            "Cross-Site Scripting",
                            "File Execution"
                        ],
                        "correct": 1,
                        "explanation": "Path traversal attacks use `../` sequences to navigate outside of the intended directory. The primary defense is to strip path information from user-supplied filenames and store files in a secure location."
                    },
                    {
                        "id": 4,
                        "question": "Why is it dangerous to rely on the `Content-Type` header to validate an uploaded file's type?",
                        "options": [
                            "It is always accurate.",
                            "The header is encrypted.",
                            "It is a client-controlled value and can be easily spoofed by an attacker.",
                            "The header is too long."
                        ],
                        "correct": 2,
                        "explanation": "An attacker can easily intercept their request and change the `Content-Type` header to bypass a weak validation check. Server-side checks on the file extension and, ideally, its actual content (magic numbers) are required."
                    }
                ]
            }
        },
        {
            "id": "lesson-5",
            "title": "Authentication and Session Management",
            "duration": "120 min",
            "objectives": [
                "Design and implement secure authentication mechanisms.",
                "Understand and enforce modern password security best practices.",
                "Architect a robust Multi-Factor Authentication (MFA) implementation.",
                "Securely manage the entire session lifecycle, from login to logout."
            ],
            "content": {
                "overview": "Authentication confirms a user's identity, and session management maintains that identity throughout their interaction with the application. Flaws in these core components can lead to a complete compromise of user accounts. This lesson covers the essential best practices for building secure authentication and session management systems.",
                "sections": [
                    {
                        "title": "Password Security Best Practices",
                        "content": "<p>Passwords are a common weak link. Developers must handle them correctly to protect user accounts even if the password database is breached.</p><h3>The Cardinal Rule: Never Store Plaintext Passwords</h3><ul><li><strong>Hashing:</strong> Passwords must be passed through a one-way cryptographic hash function before being stored.</li><li><strong>Salting:</strong> A unique, random 'salt' must be generated for each user and combined with their password before hashing. This prevents attackers from using pre-computed 'rainbow tables' to crack the entire database.</li><li><strong>Strong Algorithm:</strong> Use a slow, adaptive, and memory-hard hashing algorithm designed for passwords, such as <strong>Argon2</strong> (the modern standard), scrypt, or bcrypt. Do NOT use fast algorithms like MD5 or SHA-1.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Multi-Factor Authentication Implementation",
                        "content": "<p>Multi-Factor Authentication (MFA) is one of the most effective security controls for preventing account takeover. It requires the user to provide more than one type of credential.</p><h3>Factors of Authentication:</h3><ul><li><strong>Something you know:</strong> A password or PIN.</li><li><strong>Something you have:</strong> A physical device, like a phone generating a one-time password (OTP) or a hardware security key (e.g., YubiKey).</li><li><strong>Something you are:</strong> A biometric, like a fingerprint or face scan.</li></ul><p>The strongest and most phishing-resistant MFA methods are those based on the FIDO2/WebAuthn standard, which uses public-key cryptography.</p>",
                        "image": "https://images.unsplash.com/photo-1614064548237-02f0d1a2c39c?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Session Management Security",
                        "content": "<p>Once a user is authenticated, a session is created. Securing this session is critical.</p><h3>Best Practices:</h3><ol><li><strong>Generate a Strong Session ID:</strong> After a successful login, generate a long, unpredictable, and random string to use as the session ID.</li><li><strong>Secure the Session Cookie:</strong><ul><li>Set the `Secure` flag to ensure the cookie is only sent over HTTPS.</li><li>Set the `HttpOnly` flag to prevent the cookie from being accessed by client-side JavaScript, which is the primary defense against session hijacking via XSS.</li><li>Set the `SameSite` flag to `Strict` or `Lax` to protect against Cross-Site Request Forgery (CSRF).</li></ul></li><li><strong>Implement Timeouts:</strong> Enforce both an idle timeout (e.g., 15 minutes of inactivity) and an absolute timeout (e.g., 8 hours).</li><li><strong>Provide a Logout Button:</strong> The logout button must invalidate the session on the server-side, not just delete the cookie on the client.</li></ol>",
                        "image": "https://images.unsplash.com/photo-1555949963-aa79dcee981c?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 5: Secure Authentication System Implementation",
                        "language": "python",
                        "code": "import bcrypt\n\ndef hash_password(password):\n    # Generate a new salt for each password\n    salt = bcrypt.gensalt()\n    # Hash the password with the salt\n    hashed_password = bcrypt.hashpw(password.encode('utf-8'), salt)\n    return hashed_password\n\ndef check_password(password, hashed_password):\n    # The checkpw function automatically handles the salt extraction and comparison\n    return bcrypt.checkpw(password.encode('utf-8'), hashed_password)"
                    },
                    {
                        "title": "Code Example 5: Multi-Factor Authentication Framework",
                        "language": "http",
                        "code": "// Conceptual HTTP Response setting a secure session cookie\n\nHTTP/1.1 200 OK\n\nSet-Cookie: sessionId=abc123xyz789; Path=/; Max-Age=28800; HttpOnly; Secure; SameSite=Lax\n\n// Breakdown:\n// sessionId=...      (The session ID itself)\n// Path=/             (Cookie applies to the whole site)\n// Max-Age=28800      (Absolute timeout of 8 hours)\n// HttpOnly           (Prevents access from JavaScript - XSS protection)\n// Secure             (Only send over HTTPS)\n// SameSite=Lax       (CSRF protection)"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary reason for hashing user passwords before storing them?",
                        "options": [
                            "To make the passwords shorter and save database space.",
                            "To make them easily reversible so a user can retrieve their forgotten password.",
                            "To make them unreadable, so that if the database is breached, the attacker cannot see the users' actual passwords.",
                            "To make logins faster."
                        ],
                        "correct": 2,
                        "explanation": "Hashing is a one-way function. Its purpose is to protect the confidentiality of the passwords in the event of a database compromise. The application can verify a password by hashing the user's input and comparing it to the stored hash, without ever needing to know or store the plaintext password."
                    },
                    {
                        "id": 2,
                        "question": "Using a password and a one-time code from an authenticator app is an example of what?",
                        "options": [
                            "Single-Factor Authentication",
                            "Multi-Factor Authentication",
                            "Passwordless Authentication",
                            "Authorization"
                        ],
                        "correct": 1,
                        "explanation": "This uses two different factors: something you know (the password) and something you have (your phone with the authenticator app), which is the definition of MFA."
                    },
                    {
                        "id": 3,
                        "question": "Setting the `HttpOnly` flag on a session cookie is the primary defense against which attack?",
                        "options": [
                            "Session hijacking via Cross-Site Scripting (XSS)",
                            "SQL Injection",
                            "Cross-Site Request Forgery (CSRF)",
                            "Brute-force login"
                        ],
                        "correct": 0,
                        "explanation": "If an attacker can inject JavaScript into a page (XSS), they can try to steal the session cookie with `document.cookie`. The `HttpOnly` flag makes the cookie inaccessible to JavaScript, defeating this common attack vector."
                    },
                    {
                        "id": 4,
                        "question": "Which of the following is the most secure algorithm for hashing passwords?",
                        "options": [
                            "MD5",
                            "SHA-1",
                            "Base64 encoding",
                            "Argon2"
                        ],
                        "correct": 3,
                        "explanation": "MD5 and SHA-1 are fast hashing algorithms and are considered broken for password hashing. Base64 is an encoding format, not a hash. Argon2 is a modern, slow, memory-hard algorithm specifically designed to be resistant to password cracking attempts."
                    }
                ]
            }
        },
        {
            "id": "lesson-6",
            "title": "Authorization and Access Control",
            "duration": "120 min",
            "objectives": [
                "Compare and contrast different access control models (RBAC, ABAC).",
                "Learn to implement the Principle of Least Privilege in an authorization system.",
                "Design and test for privilege escalation vulnerabilities.",
                "Develop secure API authorization patterns."
            ],
            "content": {
                "overview": "While authentication answers 'Who are you?', authorization answers 'What are you allowed to do?'. A robust authorization system is critical for enforcing the principle of least privilege and preventing users from accessing data and functions they should not have access to. This lesson covers the key models and patterns for designing and building secure authorization systems.",
                "sections": [
                    {
                        "title": "Access Control Models",
                        "content": "<h3>Role-Based Access Control (RBAC):</h3><p>This is the most common model. Permissions are assigned to roles, and users are assigned to roles. It's easy to manage for well-defined job functions.</p><ul><li><strong>Example:</strong> The 'Editor' role has 'create-post' and 'edit-post' permissions. The 'Viewer' role only has 'view-post' permission. Alice is an Editor, Bob is a Viewer.</li></ul><h3>Attribute-Based Access Control (ABAC):</h3><p>A more dynamic and fine-grained model. Access decisions are based on policies that evaluate attributes of the user, the resource, and the environment.</p><ul><li><strong>Example Policy:</strong> A user with the attribute `role=Doctor` can `view` a resource with the attribute `type=MedicalRecord` IF the user's `department` attribute matches the resource's `department` attribute AND the `time-of-day` is during business hours.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1556155092-490a1ba16284?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Principle of Least Privilege Enforcement",
                        "content": "<p>The authorization logic is where the Principle of Least Privilege is enforced in code.</p><h3>Server-Side Enforcement is Critical:</h3><p>Access control decisions must always be made and enforced on the server-side. Do not rely on the client-side (e.g., hiding a button in the UI) for security. An attacker can always bypass client-side controls by crafting their own HTTP requests directly to the API.</p><h3>The 'Default Deny' Stance:</h3><p>Your authorization logic should follow a 'default deny' model. A user should only be granted access to a resource if a specific rule explicitly allows it. If no rule matches, access should be denied.</p>",
                        "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Privilege Escalation Prevention",
                        "content": "<p>Privilege escalation vulnerabilities occur when a user is able to gain permissions beyond what they are authorized for. One of the most common and dangerous vulnerabilities in modern applications is <strong>Insecure Direct Object Reference (IDOR)</strong>, also known as Broken Object Level Authorization (BOLA).</p><h3>IDOR / BOLA Explained:</h3><p>This occurs when the application uses a user-supplied identifier to retrieve an object from the database without checking if the authenticated user actually has permission to access *that specific object*.</p><ul><li><strong>Vulnerable Example:</strong> A user logs in and requests `GET /invoices/123`. The server checks that the user is authenticated, but not whether the user is the owner of invoice #123. The attacker can then simply change the number to `GET /invoices/124` to view someone else's invoice.</li><li><strong>Secure Solution:</strong> The server-side code must perform two checks: 1) Is the user authenticated? and 2) Does the authenticated user's ID match the owner ID of the requested invoice?</li></ul>",
                        "image": "https://images.unsplash.com/photo-1605995538181-22920bee518f?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 6: Role-Based Access Control System",
                        "language": "python",
                        "code": "# Conceptual example of an RBAC check in a web framework\n\n# A decorator that can be applied to API endpoints\ndef requires_role(role):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            current_user = get_user_from_session()\n            # Check if the user's roles include the required role\n            if role not in current_user.roles:\n                return abort(403) # Forbidden\n            return func(*args, **kwargs)\n        return wrapper\n    return decorator\n\n@app.route('/admin/dashboard')\n@requires_role('admin') # Enforce the RBAC check\ndef admin_dashboard():\n    return 'Welcome to the admin dashboard!'"
                    },
                    {
                        "title": "Code Example 6: Dynamic Authorization Engine",
                        "language": "java",
                        "code": "// Example of a BOLA / IDOR check\n\n@GetMapping(\"/invoices/{invoiceId}\")\npublic Invoice getInvoice(@PathVariable String invoiceId, Authentication authentication) {\n    // 1. Get the authenticated user's ID from the session\n    User currentUser = (User) authentication.getPrincipal();\n    String currentUserId = currentUser.getId();\n\n    // 2. Retrieve the requested invoice from the database\n    Invoice invoice = invoiceRepository.findById(invoiceId);\n\n    // 3. THE CRITICAL CHECK: Verify ownership\n    if (!invoice.getOwnerId().equals(currentUserId)) {\n        // If the IDs don't match, the user is not authorized.\n        throw new ForbiddenException(\"Access denied.\");\n    }\n\n    // 4. If the check passes, return the invoice\n    return invoice;\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "An access control model where permissions are granted based on policies that evaluate the user's role, the resource's sensitivity, and the current time of day is known as:",
                        "options": [
                            "Role-Based Access Control (RBAC)",
                            "Attribute-Based Access Control (ABAC)",
                            "Discretionary Access Control (DAC)",
                            "Mandatory Access Control (MAC)"
                        ],
                        "correct": 1,
                        "explanation": "ABAC is the most dynamic and fine-grained model, as its policies can use any attribute (of the user, resource, or environment) to make an access control decision."
                    },
                    {
                        "id": 2,
                        "question": "A user notices they can view another user's profile by changing the ID in the URL (e.g., `.../profile/1` to `.../profile/2`). This is a classic example of what vulnerability?",
                        "options": [
                            "SQL Injection",
                            "Cross-Site Scripting (XSS)",
                            "Insecure Direct Object Reference (IDOR) / Broken Object Level Authorization (BOLA)",
                            "Cross-Site Request Forgery (CSRF)"
                        ],
                        "correct": 2,
                        "explanation": "This is the most common authorization flaw. It occurs when the server fails to perform the second critical check: verifying that the authenticated user is actually the owner of the specific object they are requesting."
                    },
                    {
                        "id": 3,
                        "question": "Where must authorization decisions be enforced?",
                        "options": [
                            "Only on the client-side (e.g., by hiding buttons in the UI).",
                            "On the server-side, in the application or API code.",
                            "In the user's web browser.",
                            "Authorization is not necessary if you have authentication."
                        ],
                        "correct": 1,
                        "explanation": "Client-side controls are only for user experience; they are not a security measure. A determined attacker can always bypass them and send requests directly to the server, so the server must be the ultimate authority for enforcing all access control decisions."
                    },
                    {
                        "id": 4,
                        "question": "The primary goal of the Principle of Least Privilege is to:",
                        "options": [
                            "Make the application easier to use.",
                            "Grant every user administrator access by default.",
                            "Limit the damage that can be caused by a compromised account or component.",
                            "Improve the performance of the database."
                        ],
                        "correct": 2,
                        "explanation": "Least privilege is about limiting the 'blast radius'. If an attacker compromises a user account or an application component, the damage they can do is limited to the very small set of permissions that account or component had."
                    }
                ]
            }
        },
        {
            "id": "lesson-7",
            "title": "Cryptography in Software Development",
            "duration": "120 min",
            "objectives": [
                "Understand the fundamental concepts of cryptography for developers.",
                "Differentiate between symmetric and asymmetric encryption and their use cases.",
                "Learn the importance of secure key management.",
                "Identify and avoid common cryptographic mistakes in code."
            ],
            "content": {
                "overview": "Cryptography is a powerful tool for achieving confidentiality and integrity, but it is also notoriously difficult to implement correctly. This lesson provides a developer-focused guide to the essential concepts of cryptography, focusing on how to use it safely and avoid common pitfalls that can render it useless.",
                "sections": [
                    {
                        "title": "Cryptographic Fundamentals for Developers",
                        "content": "<p>Developers don't need to invent cryptographic algorithms, but they do need to know how to use them correctly.</p><h3>The Cardinal Rule: Don't Roll Your Own Crypto</h3><p>Never try to invent your own encryption algorithm. Never try to implement a standard algorithm yourself from scratch. Always use well-vetted, high-level, standard cryptographic libraries for your language (e.g., `libsodium`, `Tink`, or the built-in libraries in Java and .NET).</p><p>Using these libraries correctly is hard enough; inventing the underlying primitives is a task for expert cryptographers.</p>",
                        "image": "https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Symmetric vs. Asymmetric Encryption",
                        "content": "<h3>Symmetric Encryption (e.g., AES):</h3><ul><li>Uses the **same key** for both encryption and decryption.</li><li>It is very fast and is used for encrypting large amounts of data (data at rest).</li><li><strong>Challenge:</strong> Securely sharing the secret key.</li></ul><h3>Asymmetric Encryption (e.g., RSA, ECC):</h3><ul><li>Uses a **key pair**: a public key for encryption and a private key for decryption.</li><li>The public key can be shared freely. The private key must be kept secret.</li><li>It is much slower than symmetric encryption and is used for encrypting small amounts of data, for digital signatures, and for securely exchanging the key for symmetric encryption (key exchange).</li></ul>",
                        "image": "https://images.unsplash.com/photo-1584929788015-230a14589d31?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Key Management and Lifecycle",
                        "content": "<p>The security of any cryptographic system rests entirely on the security of its keys. If the keys are compromised, the encryption is worthless.</p><h3>Key Management Principles:</h3><ul><li><strong>Generation:</strong> Keys must be generated using a cryptographically secure random number generator.</li><li><strong>Storage:</strong> Keys must be stored in a secure location, like a Hardware Security Module (HSM) or a managed Key Management Service (KMS) like AWS KMS or Azure Key Vault. They should NOT be stored in a config file or source code.</li><li><strong>Rotation:</strong> Keys should be rotated periodically (e.g., annually) to limit the amount of data that would be compromised if a single key were ever exposed.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1510915228340-29c85a43dcfe?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Common Cryptographic Mistakes",
                        "content": "<ul><li><strong>Using a Broken or Weak Algorithm:</strong> Using outdated algorithms like DES or RC4, or using RSA with a key size that is too small.</li><li><strong>Incorrectly Using an Algorithm:</strong> For example, using the ECB (Electronic Codebook) mode for AES, which is not secure because it lacks randomness. You should use an authenticated encryption mode like GCM or CCM.</li><li><strong>Hard-coding Keys:</strong> Storing encryption keys directly in the source code or a configuration file is one of the most common and dangerous mistakes.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1555949963-ff9808202534?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 7: Cryptographic Implementation Workshop",
                        "language": "python",
                        "code": "# Example of using a high-level library (PyNaCl / libsodium) for symmetric encryption\n# This handles the complexity of choosing a secure algorithm (XSalsa20-Poly1305) and nonce management.\n\nfrom nacl.secret import SecretBox\nimport os\n\n# 1. The key MUST be 32 bytes and should be loaded from a secure key vault.\nkey = os.urandom(SecretBox.KEY_SIZE)\n\n# 2. Create a box using the key.\nbox = SecretBox(key)\n\n# 3. Encrypt a message. The library automatically generates a secure, random nonce.\nmessage = b\"This is a secret message.\"\nencrypted = box.encrypt(message)\n\n# 4. Decrypt the message. The nonce is bundled with the ciphertext.\nplaintext = box.decrypt(encrypted)\n\nprint(plaintext.decode('utf-8'))"
                    },
                    {
                        "title": "Code Example 7: Secure Cryptographic Library Wrapper",
                        "language": "java",
                        "code": "// BAD: Using an insecure algorithm and mode (ECB)\nCipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n\n// GOOD: Using a modern, secure authenticated encryption mode (GCM)\n// It provides both confidentiality and integrity.\nCipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\");\n\n// This simple change in the string makes a massive difference in the security of the implementation.\n// A high-level library wrapper should enforce the use of secure defaults."
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the most important rule for developers when it comes to cryptography?",
                        "options": [
                            "Always try to invent your own encryption algorithm.",
                            "Use the fastest algorithm, like MD5, for everything.",
                            "Do not try to invent or implement crypto yourself; use well-vetted, high-level standard libraries.",
                            "Store encryption keys in your source code."
                        ],
                        "correct": 2,
                        "explanation": "Cryptography is incredibly subtle and difficult to get right. The 'do not roll your own crypto' rule is the most important piece of advice for any developer. The risk of making a mistake is too high."
                    },
                    {
                        "id": 2,
                        "question": "Which type of encryption uses a single key for both encryption and decryption and is very fast?",
                        "options": [
                            "Asymmetric Encryption (e.g., RSA)",
                            "Symmetric Encryption (e.g., AES)",
                            "Hashing (e.g., SHA-256)",
                            "Encoding (e.g., Base64)"
                        ],
                        "correct": 1,
                        "explanation": "Symmetric encryption is fast and efficient, making it the right choice for encrypting large amounts of data at rest."
                    },
                    {
                        "id": 3,
                        "question": "What is the most secure place to store cryptographic keys?",
                        "options": [
                            "In a plaintext configuration file.",
                            "Hard-coded in the source code.",
                            "In a dedicated, secure system like a Hardware Security Module (HSM) or a cloud Key Management Service (KMS).",
                            "In a public text file on a web server."
                        ],
                        "correct": 2,
                        "explanation": "The security of your encryption is completely dependent on the security of your keys. They must be protected in a purpose-built, highly secure system."
                    },
                    {
                        "id": 4,
                        "question": "A hybrid encryption scheme, used in protocols like TLS, uses asymmetric encryption primarily for what purpose?",
                        "options": [
                            "To encrypt all the bulk data in the session.",
                            "To securely exchange a shared secret key, which is then used for fast, symmetric encryption.",
                            "To hash the user's password.",
                            "It is not used in TLS."
                        ],
                        "correct": 1,
                        "explanation": "Asymmetric encryption is slow. TLS uses it at the beginning of a session for the client and server to securely agree on a new, temporary symmetric key. The rest of the session's data is then encrypted with that fast, symmetric key."
                    }
                ]
            }
        },
        {
            "id": "lesson-8",
            "title": "Data Protection and Privacy",
            "duration": "90 min",
            "objectives": [
                "Understand and implement a data classification scheme.",
                "Apply the principles of data minimization and purpose limitation.",
                "Design secure data retention and deletion policies.",
                "Incorporate Privacy by Design principles into the development lifecycle."
            ],
            "content": {
                "overview": "Protecting data is not just about encryption; it's about a holistic approach to managing data throughout its lifecycle in a way that respects user privacy and meets regulatory requirements like GDPR. This lesson covers the core principles of data protection and how to build them into your applications from the start.",
                "sections": [
                    {
                        "title": "Data Classification and Labeling",
                        "content": "<p>You cannot protect your data effectively if you don't know what it is and how sensitive it is. Data classification is the process of categorizing data to determine the appropriate level of protection.</p><h3>A Common Classification Scheme:</h3><ul><li><strong>Public:</strong> Data intended for public consumption.</li><li><strong>Internal:</strong> Data for internal business use only.</li><li><strong>Confidential:</strong> Sensitive data that would cause business damage if leaked.</li><li><strong>Restricted:</strong> Highly sensitive, often regulated data (e.g., PII, PHI) that would cause severe damage.</li></ul><p>As a developer, you should understand the classification of the data your application handles and apply security controls that are appropriate for that level.</p>",
                        "image": "https://images.unsplash.com/photo-1557672172-298e090bd0f1?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Data Minimization and Purpose Limitation",
                        "content": "<p>These are two key principles of modern privacy regulations like GDPR.</p><ul><li><strong>Data Minimization:</strong> Collect and store only the absolute minimum amount of personal data necessary to provide a specific service. Don't collect data just because you *might* need it someday. The less data you hold, the lower your risk.</li><li><strong>Purpose Limitation:</strong> Be clear and specific about why you are collecting personal data, and only use it for that stated purpose. You cannot collect data for one reason (e.g., shipping a product) and then re-use it for a completely different reason (e.g., marketing) without the user's consent.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1556155092-490a1ba16284?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Data Retention and Deletion Policies",
                        "content": "<p>You should not keep data forever. A data retention policy defines how long data should be kept and when it should be securely deleted.</p><h3>Implementation:</h3><ul><li>The application's design must support this. For example, to comply with GDPR's 'Right to be Forgotten', you must be able to securely delete a specific user's data from all your systems.</li><li>This requires a well-designed data model that can trace all of a user's data. It can be very difficult to implement this in a legacy system that was not designed for it.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1579532537598-459ecdaf39cc?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Privacy by Design Implementation",
                        "content": "<p>Privacy by Design is an approach that embeds privacy considerations into the entire development lifecycle, from the very beginning. It means privacy is not an afterthought, but a core requirement.</p><p>This involves asking privacy-related questions during the threat modeling and design phase:</p><ul><li>'Do we really need to collect this piece of personal data?' (Data Minimization)</li><li>'How will we securely delete this data when the user requests it?' (Deletion Policies)</li><li>'How can we give the user control over their own data?' (User Consent)</li></ul>",
                        "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 8: Data Protection Compliance System",
                        "language": "sql",
                        "code": "-- Conceptual SQL for a user data deletion request (Right to be Forgotten)\n\n-- This demonstrates the need for a well-designed data model with foreign keys\n-- and cascading deletes to properly remove all of a user's data.\n\nBEGIN TRANSACTION;\n\n-- Deleting a user should cascade to delete their related orders, sessions, etc.\nDELETE FROM users WHERE user_id = 'user-to-be-deleted-123';\n\nCOMMIT;"
                    },
                    {
                        "title": "Code Example 8: Automated Data Classification and Protection Tool",
                        "language": "python",
                        "code": "import re\n\n# A simple pattern-based data discovery function\n\nCREDIT_CARD_REGEX = re.compile(r'\\b(?:\\d[ -]*?){13,16}\\b')\n\ndef classify_text(text):\n    if CREDIT_CARD_REGEX.search(text):\n        return 'RESTRICTED' # Contains PCI data\n    # ... add other patterns for PII, PHI, etc.\n    else:\n        return 'INTERNAL'\n\n# This kind of logic can be used in a script to scan databases or log files\n# for sensitive data that may have been stored improperly."
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "The process of categorizing data based on its sensitivity to determine the right level of protection is known as:",
                        "options": [
                            "Data Encryption",
                            "Data Classification",
                            "Data Deletion",
                            "Data Minimization"
                        ],
                        "correct": 1,
                        "explanation": "Data classification is the foundational step. Without it, you cannot apply risk-based controls because you don't know which data is the most sensitive."
                    },
                    {
                        "id": 2,
                        "question": "The privacy principle that dictates you should only collect and store the absolute minimum amount of personal data needed for a specific purpose is:",
                        "options": [
                            "Data Retention",
                            "Purpose Limitation",
                            "Data Minimization",
                            "Data Encryption"
                        ],
                        "correct": 2,
                        "explanation": "Data minimization is a core tenet of modern privacy regulations like GDPR. It reduces risk by reducing the amount of sensitive data an organization holds."
                    },
                    {
                        "id": 3,
                        "question": "Embedding privacy considerations into every phase of the software development lifecycle is known as:",
                        "options": [
                            "Privacy by Accident",
                            "Privacy by Design",
                            "Privacy as an Afterthought",
                            "Privacy by Obscurity"
                        ],
                        "correct": 1,
                        "explanation": "Privacy by Design is a proactive approach that makes privacy a fundamental requirement of the system, just like security and functionality."
                    },
                    {
                        "id": 4,
                        "question": "To comply with GDPR's 'Right to be Forgotten', what must an application's architecture be able to do?",
                        "options": [
                            "Store user data forever.",
                            "Securely and completely delete a specific user's data upon request.",
                            "Sell the user's data to third parties.",
                            "Make the user's data public."
                        ],
                        "correct": 1,
                        "explanation": "The ability to delete a specific user's data is a key technical challenge posed by privacy regulations. It requires a well-thought-out data model and cannot be easily retrofitted into many legacy systems."
                    }
                ]
            }
        },
        {
            "id": "lesson-9",
            "title": "Web Application Security",
            "duration": "120 min",
            "objectives": [
                "Understand the most common web application vulnerabilities as defined by the OWASP Top 10.",
                "Learn the root causes and mitigation strategies for Cross-Site Scripting (XSS).",
                "Learn the root causes and mitigation strategies for SQL Injection.",
                "Implement key HTTP security headers, including Content Security Policy (CSP)."
            ],
            "content": {
                "overview": "Web applications are the public face of most organizations, making them a primary target for attackers. This lesson provides a deep dive into the most critical web application vulnerabilities, drawing from the industry-standard OWASP Top 10, and covers the essential coding and configuration techniques to defend against them.",
                "sections": [
                    {
                        "title": "OWASP Top 10 Deep Dive",
                        "content": "<p>The Open Web Application Security Project (OWASP) Top 10 is a standard awareness document for developers and web application security. It represents a broad consensus about the most critical security risks to web applications.</p><h3>Key Vulnerabilities We Will Cover:</h3><ul><li>A01: Broken Access Control (e.g., IDOR/BOLA)</li><li>A02: Cryptographic Failures</li><li>A03: Injection (e.g., SQL Injection, Cross-Site Scripting)</li><li>A04: Insecure Design</li><li>A05: Security Misconfiguration</li></ul>",
                        "image": "https://images.unsplash.com/photo-1605995538181-22920bee518f?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Cross-Site Scripting (XSS) Prevention",
                        "content": "<p>XSS occurs when an application includes untrusted data in a page sent to a browser without proper validation or encoding. This allows an attacker to execute malicious scripts in the victim's browser.</p><h3>The Primary Defense: Contextual Output Encoding</h3><p>As covered in Lesson 4, the key is to encode data for the specific context in which it will be rendered. All modern web frameworks have built-in functions for this. Use them.</p><h3>Defense in Depth: Content Security Policy (CSP)</h3><p>CSP is an HTTP response header that tells the browser to only load content (like scripts and images) from an explicit allow-list of domains. This provides a powerful second layer of defense, as even if an attacker can inject a script tag, the browser will refuse to load the malicious script from an untrusted domain.</p>",
                        "image": "https://images.unsplash.com/photo-1555099962-4199c345e546?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "SQL Injection Prevention",
                        "content": "<p>SQL Injection (SQLi) occurs when an application includes untrusted data in a database query in an unsafe way. This can allow an attacker to execute arbitrary commands in the database, leading to a full data breach.</p><h3>The Primary Defense: Parameterized Queries</h3><p>Never, ever build a SQL query by concatenating strings with user input. Always use <strong>parameterized queries</strong> (also known as prepared statements). This is a feature available in all modern database libraries.</p><p>Parameterized queries separate the query logic from the data. The database always treats the user input as data, never as executable code, which makes this entire class of vulnerability impossible.</p>",
                        "image": "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Cross-Site Request Forgery (CSRF) Protection",
                        "content": "<p>CSRF is an attack that tricks a logged-in user's browser into sending a forged HTTP request to a vulnerable application, allowing the attacker to perform actions on the user's behalf (like changing their password or transferring money).</p><h3>The Primary Defense: Anti-CSRF Tokens</h3><p>The server generates a unique, unpredictable token for each user session and embeds it in a hidden field in every form. When the form is submitted, the server checks that the submitted token matches the one in the user's session. Since the attacker does not know the value of this token, they cannot forge a valid request.</p><p>Modern frameworks often have this protection built-in.</p>",
                        "image": "https://images.unsplash.com/photo-1555949963-aa79dcee981c?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 9: Web Application Security Testing Suite",
                        "language": "java",
                        "code": "// BAD: Vulnerable to SQL Injection due to string concatenation\nString query = \"SELECT * FROM users WHERE username = '\" + username + \"' AND password = '\" + password + \"';\";\nStatement statement = connection.createStatement();\nResultSet results = statement.executeQuery(query);\n\n// GOOD: Using a PreparedStatement (Parameterized Query)\n// The '?' are placeholders. The database driver ensures the user input is treated only as data.\nString query = \"SELECT * FROM users WHERE username = ? AND password = ?;\";\nPreparedStatement statement = connection.prepareStatement(query);\nstatement.setString(1, username);\nstatement.setString(2, password);\nResultSet results = statement.executeQuery();"
                    },
                    {
                        "title": "Code Example 9: Comprehensive Web Security Framework",
                        "language": "http",
                        "code": "HTTP/1.1 200 OK\n\n# Example of a strong Content Security Policy (CSP)\n# This tells the browser to only allow scripts from its own domain.\nContent-Security-Policy: default-src 'self'; script-src 'self';\n\n# Example of HSTS header to enforce HTTPS\nStrict-Transport-Security: max-age=31536000; includeSubDomains\n\n# Example of a header to prevent clickjacking\nX-Frame-Options: DENY"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the single most effective defense against SQL Injection vulnerabilities?",
                        "options": [
                            "Using a Web Application Firewall (WAF).",
                            "Encoding output before displaying it to the user.",
                            "Consistently using parameterized queries (prepared statements).",
                            "Hiding the database server from the internet."
                        ],
                        "correct": 2,
                        "explanation": "While a WAF is a good defense-in-depth control, the root cause of SQLi is mixing code and data. Parameterized queries are a programmatic control that enforces the separation of the SQL query logic from the user-supplied data, making SQLi impossible."
                    },
                    {
                        "id": 2,
                        "question": "The primary defense against Cross-Site Scripting (XSS) is:",
                        "options": [
                            "Parameterized queries",
                            "Using anti-CSRF tokens",
                            "Contextual output encoding",
                            "Enforcing strong passwords"
                        ],
                        "correct": 2,
                        "explanation": "XSS occurs when untrusted data is rendered on a page without being properly encoded. Contextual output encoding neutralizes any malicious scripts in the data, turning them into harmless text."
                    },
                    {
                        "id": 3,
                        "question": "An HTTP header that provides a strong, allow-list-based defense against XSS is called:",
                        "options": [
                            "Content-Security-Policy (CSP)",
                            "Strict-Transport-Security (HSTS)",
                            "X-Frame-Options",
                            "Access-Control-Allow-Origin"
                        ],
                        "correct": 0,
                        "explanation": "CSP is a powerful defense-in-depth control. It instructs the browser on which domains are trusted sources for content like scripts, which can block a malicious script from executing even if an XSS flaw exists."
                    },
                    {
                        "id": 4,
                        "question": "Using a unique, unpredictable token in a hidden form field to prevent an attacker from tricking a user's browser into taking an action is a defense against what attack?",
                        "options": [
                            "SQL Injection",
                            "Cross-Site Scripting (XSS)",
                            "Cross-Site Request Forgery (CSRF)",
                            "Path Traversal"
                        ],
                        "correct": 2,
                        "explanation": "This is the standard 'synchronizer token pattern' for preventing CSRF. The server requires this secret, unpredictable token to be present in any state-changing request, which an attacker cannot guess."
                    }
                ]
            }
        },
        {
            "id": "lesson-10",
            "title": "Mobile Application Security",
            "duration": "90 min",
            "objectives": [
                "Understand the unique security threat landscape for mobile applications.",
                "Learn to secure data storage on mobile devices.",
                "Implement secure network communication for mobile apps.",
                "Address platform-specific security considerations for iOS and Android."
            ],
            "content": {
                "overview": "Mobile applications have a unique attack surface. They run on untrusted devices that can be lost, stolen, or infected with malware. The security of the mobile app itself is critical for protecting user data and the backend systems it connects to. This lesson covers the key principles of mobile application security.",
                "sections": [
                    {
                        "title": "Mobile Security Threat Landscape",
                        "content": "<p>Mobile apps face both client-side and server-side threats.</p><h3>Key Threats:</h3><ul><li><strong>Insecure Data Storage:</strong> Storing sensitive data unencrypted on the device's filesystem or in insecure locations.</li><li><strong>Insecure Communication:</strong> Transmitting sensitive data over unencrypted channels or failing to validate server certificates.</li><li><strong>Reverse Engineering:</strong> An attacker can decompile the application binary to analyze its code, find vulnerabilities, and extract hard-coded secrets.</li><li><strong>Platform-Specific Issues:</strong> Flaws related to the specific security models of iOS or Android.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1593508512255-86ab42a8e620?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Data Storage Security on Mobile Devices",
                        "content": "<p>The guiding principle is to store the absolute minimum amount of sensitive data on the device.</p><h3>Secure Storage Practices:</h3><ul><li><strong>Use Platform-Provided Secure Storage:</strong> Both iOS (Keychain) and Android (Keystore) provide a hardware-backed secure storage system for small secrets like API keys, session tokens, and encryption keys. This is the most secure place to store credentials.</li><li><strong>Encrypt Local Data:</strong> For larger amounts of data (e.g., in a local SQLite database or files), the data must be encrypted before it is written to disk. The encryption key should be stored in the platform's secure Keychain/Keystore.</li><li><strong>Avoid Storing PII:</strong> If possible, avoid storing sensitive personally identifiable information (PII) on the device at all.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1512428209919-8cf3c88b480c?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Network Communication Security",
                        "content": "<p>All communication between the mobile app and its backend API must be secure.</p><h3>Key Controls:</h3><ul><li><strong>Use TLS Everywhere:</strong> All network traffic must be over TLS 1.2 or higher. Modern mobile OSes enforce this by default.</li><li><strong>Certificate Pinning:</strong> For high-security applications, certificate pinning can be used. This is the practice of embedding (or 'pinning') the backend server's public key or certificate within the mobile app. The app will then only trust that specific certificate, which can prevent man-in-the-middle attacks even if a trusted CA is compromised. However, pinning adds significant operational complexity.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1534972195531-0e108fc312f0?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Platform-Specific Security",
                        "content": "<ul><li><strong>Code Obfuscation:</strong> Use tools (like ProGuard for Android) to obfuscate the compiled code, making it much harder for an attacker to reverse-engineer.</li><li><strong>Root/Jailbreak Detection:</strong> The app can include checks to see if it is running on a rooted (Android) or jailbroken (iOS) device. On such a device, the OS security controls are weakened, so the app might choose to disable high-risk features or refuse to run.</li><li><strong>Biometric Authentication:</strong> Leverage the platform's secure biometric authentication (Face ID, Touch ID) for user authentication and to protect access to secrets in the Keychain/Keystore.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1600267185393-e158a781ea27?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 10: Mobile Security Assessment Platform",
                        "language": "java",
                        "code": "// Example of using Android's EncryptedSharedPreferences for secure data storage\n\nimport androidx.security.crypto.EncryptedSharedPreferences;\nimport androidx.security.crypto.MasterKeys;\n\n// 1. Create or get the master key. This is stored in the Android Keystore.\nString masterKeyAlias = MasterKeys.getOrCreate(MasterKeys.AES256_GCM_SPEC);\n\n// 2. Initialize the EncryptedSharedPreferences\nSharedPreferences sharedPreferences = EncryptedSharedPreferences.create(\n    \"secret_user_prefs\",\n    masterKeyAlias,\n    context,\n    EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,\n    EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM\n);\n\n// 3. Use it like regular SharedPreferences. The library handles all encryption and decryption.\nSharedPreferences.Editor editor = sharedPreferences.edit();\neditor.putString(\"session_token\", \"user-session-token-123\");\neditor.apply();"
                    },
                    {
                        "title": "Code Example 10: Mobile Application Security Framework",
                        "language": "swift",
                        "code": "// Example of storing a secret in the iOS Keychain\n\nimport Security\n\nlet service = \"com.example.myapp\"\nlet account = \"user_api_key\"\nlet secret = \"my-secret-api-key\".data(using: .utf8)!\n\n// The query to add the item to the Keychain\nlet query: [String: Any] = [\n    kSecClass as String: kSecClassGenericPassword,\n    kSecAttrService as String: service,\n    kSecAttrAccount as String: account,\n    kSecValueData as String: secret\n]\n\n// Add the item. The OS handles storing it securely in the Secure Enclave.\nlet status = SecItemAdd(query as CFDictionary, nil)\n\n// A similar query is used with SecItemCopyMatching to retrieve it."
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the most secure place to store small, sensitive secrets like API keys in a mobile application?",
                        "options": [
                            "In a plaintext file on the SD card.",
                            "Hard-coded in the source code.",
                            "In the platform's hardware-backed secure storage (iOS Keychain / Android Keystore).",
                            "In the user's contact list."
                        ],
                        "correct": 2,
                        "explanation": "The Keychain and Keystore are purpose-built, hardware-backed secure enclaves for storing cryptographic keys and small secrets. This is by far the most secure storage location on a mobile device."
                    },
                    {
                        "id": 2,
                        "question": "The process of making a mobile application's compiled code harder to read and understand by an attacker is known as:",
                        "options": [
                            "Encryption",
                            "Obfuscation",
                            "Compilation",
                            "Authentication"
                        ],
                        "correct": 1,
                        "explanation": "Obfuscation modifies the code to make it functionally identical but much harder for a human to analyze after it has been decompiled. This is a key defense against reverse engineering."
                    },
                    {
                        "id": 3,
                        "question": "A security control that makes a mobile app trust only a specific, pre-defined server certificate to prevent man-in-the-middle attacks is called:",
                        "options": [
                            "TLS",
                            "Certificate Pinning",
                            "Root Detection",
                            "Code Signing"
                        ],
                        "correct": 1,
                        "explanation": "Certificate pinning is an advanced security technique that provides an extra layer of protection for network communication, but it must be implemented carefully as it can cause the app to break if the server certificate changes unexpectedly."
                    },
                    {
                        "id": 4,
                        "question": "What is a primary security risk of running an application on a 'jailbroken' or 'rooted' device?",
                        "options": [
                            "The device runs faster.",
                            "The operating system's built-in security controls and sandboxing are disabled, making it easier for malware to steal the application's data.",
                            "The device cannot connect to the internet.",
                            "There are no security risks."
                        ],
                        "correct": 1,
                        "explanation": "Jailbreaking/rooting fundamentally undermines the security model of the mobile OS. An application running on such a device cannot rely on the OS for protection, which is why high-security apps often use root detection to refuse to run."
                    }
                ]
            }
        },
        {
            "id": "lesson-11",
            "title": "API Security Development",
            "duration": "90 min",
            "objectives": [
                "Understand the OWASP API Security Top 10 risks.",
                "Implement secure API authentication using standards like OAuth 2.0 and JWTs.",
                "Design and enforce robust authorization at the API layer.",
                "Use an API gateway to enforce security policies like rate limiting."
            ],
            "content": {
                "overview": "APIs are the new de facto standard for application communication, but they are also a primary target for attackers. Securing APIs requires developers to understand a unique set of vulnerabilities and to implement robust authentication and authorization controls. This lesson covers the essential best practices for developing secure APIs.",
                "sections": [
                    {
                        "title": "API Threat Landscape",
                        "content": "<p>The OWASP API Security Top 10 is the essential guide to API vulnerabilities.</p><h3>Key Risks for Developers to Address:</h3><ul><li><strong>API1: Broken Object Level Authorization (BOLA):</strong> Failing to check if the authenticated user is the owner of the requested object.</li><li><strong>API2: Broken Authentication:</strong> Using weak or flawed authentication mechanisms.</li><li><strong>API3: Excessive Data Exposure:</strong> The API returns full database objects, including sensitive fields that the client doesn't need.</li><li><strong>API5: Broken Function Level Authorization:</strong> Allowing a user to call an administrative function that their role should not permit.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1605995538181-22920bee518f?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "API Authentication Mechanisms",
                        "content": "<p>Modern APIs should be protected by a token-based authentication scheme.</p><h3>OAuth 2.0 and JWTs:</h3><p><strong>OAuth 2.0</strong> is the standard framework for delegated authorization. A client application receives an <strong>access token</strong> from an authorization server after a user authenticates.</p><p>This access token is often a <strong>JSON Web Token (JWT)</strong>. A JWT is a self-contained, digitally signed token that includes a set of 'claims' about the user (e.g., their user ID, their roles). The client application sends this JWT in the `Authorization: Bearer <token>` header with every API request.</p><p>The API server must validate the JWT's signature on every request to ensure it is authentic and has not been tampered with.</p>",
                        "image": "https://images.unsplash.com/photo-1562907450-446aa741b2b3?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "API Gateway Security Patterns",
                        "content": "<p>An API Gateway is a reverse proxy that acts as a single entry point for all API requests. It is the ideal place for a developer to offload and centralize common security tasks.</p><h3>Gateway Functions:</h3><ul><li><strong>Authentication:</strong> The gateway can perform the validation of the JWT token, relieving the backend services of this task.</li><li><strong>Rate Limiting:</strong> Protects backend services from denial-of-service attacks by enforcing limits on the number of requests a client can make.</li><li><strong>Input Validation:</strong> Can perform initial validation of request parameters and body formats.</li><li><strong>Logging:</strong> Provides a central place to log all API requests.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1544890225-2fde0e66f255?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 11: Secure API Development Workshop",
                        "language": "python",
                        "code": "# Example of a BOLA / IDOR check in a Python Flask API endpoint\n\nfrom flask import request, abort\nfrom flask_jwt_extended import jwt_required, get_jwt_identity\n\n@app.route('/api/documents/<int:doc_id>', methods=['GET'])\n@jwt_required() # This decorator ensures a valid JWT is present\ndef get_document(doc_id):\n    # 1. Get the authenticated user's ID from the JWT token\n    current_user_id = get_jwt_identity()\n\n    # 2. Get the document from the database\n    doc = Document.query.get(doc_id)\n\n    # 3. CRITICAL: Verify that the authenticated user is the owner of the document\n    if doc.owner_id != current_user_id:\n        abort(403) # Forbidden\n\n    return doc.to_json()"
                    },
                    {
                        "title": "Code Example 11: Comprehensive API Security Middleware",
                        "language": "javascript",
                        "code": "// Conceptual example of API Gateway middleware for rate limiting (e.g., in Express.js)\n\nconst rateLimit = require('express-rate-limit');\n\nconst apiLimiter = rateLimit({\n    windowMs: 15 * 60 * 1000, // 15 minutes\n    max: 100, // Limit each IP to 100 requests per window\n    standardHeaders: true,\n    legacyHeaders: false,\n    message: 'Too many requests from this IP, please try again after 15 minutes'\n});\n\n// Apply the rate limiting middleware to all API routes\napp.use('/api/', apiLimiter);"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "A modern, stateless, self-contained token that is digitally signed and often used for API authentication is a:",
                        "options": [
                            "Session Cookie",
                            "JSON Web Token (JWT)",
                            "Static API Key",
                            "Username and Password"
                        ],
                        "correct": 1,
                        "explanation": "JWTs are the de facto standard for API authentication in modern applications. Their self-contained and signed nature makes them ideal for distributed, microservices-based architectures."
                    },
                    {
                        "id": 2,
                        "question": "An API endpoint returns a full user object from the database, including the password hash and other sensitive data that the UI does not need. This is an example of which OWASP API vulnerability?",
                        "options": [
                            "Broken Object Level Authorization",
                            "Broken Authentication",
                            "Excessive Data Exposure",
                            "Lack of Rate Limiting"
                        ],
                        "correct": 2,
                        "explanation": "This is a common flaw where developers take a shortcut and serialize an entire database object. APIs should be designed to be 'thin', returning only the specific fields required for that use case."
                    },
                    {
                        "id": 3,
                        "question": "A central component that acts as a reverse proxy to enforce security policies like authentication and rate limiting for all APIs is called an:",
                        "options": [
                            "API Gateway",
                            "Database",
                            "Web Browser",
                            "Authentication Server"
                        ],
                        "correct": 0,
                        "explanation": "An API Gateway is a critical architectural pattern for API security. It centralizes cross-cutting concerns, which simplifies the code of the backend microservices and ensures consistent policy enforcement."
                    },
                    {
                        "id": 4,
                        "question": "The most critical server-side code change to prevent Broken Object Level Authorization (BOLA) is to:",
                        "options": [
                            "Use a strong password.",
                            "Implement rate limiting.",
                            "Validate that the authenticated user is the owner of the specific object they are requesting.",
                            "Encrypt the API traffic with TLS."
                        ],
                        "correct": 2,
                        "explanation": "This is the core of the BOLA/IDOR vulnerability. The application must perform an explicit ownership check in its business logic to ensure users can only access their own data."
                    }
                ]
            }
        },
        {
            "id": "lesson-12",
            "title": "Secure Coding Practices by Language",
            "duration": "120 min",
            "objectives": [
                "Understand common security pitfalls in languages like Java, C/C++, and Python.",
                "Learn to prevent memory safety issues like buffer overflows in C/C++.",
                "Explore the security advantages of memory-safe languages like Go and Rust.",
                "Apply language-specific best practices for secure development."
            ],
            "content": {
                "overview": "While many security principles are universal, different programming languages have their own unique security characteristics, common vulnerabilities, and best practices. This lesson provides a practical overview of secure coding patterns and pitfalls in several of the most popular programming languages.",
                "sections": [
                    {
                        "title": "Java Secure Coding Guidelines",
                        "content": "<ul><li><strong>Prevent Deserialization Vulnerabilities:</strong> Avoid using Java's built-in serialization for untrusted data. If you must, use a look-ahead deserialization library that can validate the object graph before it is deserialized.</li><li><strong>Manage Class Loaders Securely:</strong> Be careful when loading code from untrusted sources.</li><li><strong>Prevent XML External Entity (XXE) Attacks:</strong> When parsing XML, ensure that external entity processing is disabled on your XML parser.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1517694712202-14dd9538aa97?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "C/C++ Memory Safety",
                        "content": "<p>C and C++ are powerful but not 'memory-safe'. The developer is responsible for all memory management, which is a major source of vulnerabilities.</p><h3>Key Vulnerabilities:</h3><ul><li><strong>Buffer Overflows:</strong> Writing data past the end of a buffer (array). This can corrupt memory and lead to arbitrary code execution. Use 'safe' string functions like `strncpy` instead of `strcpy`.</li><li><strong>Integer Overflows:</strong> A calculation results in a number that is too large for its data type, causing it to 'wrap around'. This can lead to logic errors, such as bypassing a security check.</li><li><strong>Use-After-Free:</strong> A program continues to use a pointer after the memory it points to has been freed. This can lead to crashes or code execution.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1555099962-4199c345e546?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Python Security Best Practices",
                        "content": "<ul><li><strong>Be Careful with `pickle`:** Python's `pickle` module for serialization is not secure and can execute arbitrary code. Never unpickle data from an untrusted source. Use a safe format like JSON instead.</li><li><strong>Command Injection:</strong> Avoid using `os.system` or `subprocess.run` with `shell=True` and untrusted input. Use the array form of `subprocess.run` to pass arguments safely.</li><li><strong>Path Traversal:</strong> Sanitize any user input that is used to construct a file path.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Rust Memory Safety Advantages",
                        "content": "<p>Rust is a modern systems programming language that is designed to be memory-safe by default.</p><p>The Rust compiler enforces a strict set of 'ownership' and 'borrowing' rules at compile time. These rules make it impossible to write many of the most dangerous types of memory errors, such as buffer overflows and use-after-free vulnerabilities. For this reason, Rust is becoming an increasingly popular choice for writing security-critical software like operating system components and network services.</p>",
                        "image": "https://images.unsplash.com/photo-1587620962725-abab7fe55159?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 12: Multi-Language Secure Code Analysis",
                        "language": "c",
                        "code": "// VULNERABLE C code (Buffer Overflow)\n\nvoid copy_data(char *user_input) {\n    char buffer[100];\n    // If user_input is longer than 99 characters, this will write past the end of the buffer!\n    strcpy(buffer, user_input);\n}\n\n// SECURE C code\n\nvoid secure_copy_data(char *user_input) {\n    char buffer[100];\n    // strncpy takes a size argument, preventing the overflow.\n    strncpy(buffer, user_input, sizeof(buffer) - 1);\n    buffer[sizeof(buffer) - 1] = '\\0'; // Ensure null termination\n}"
                    },
                    {
                        "title": "Code Example 12: Language-Specific Security Code Templates",
                        "language": "python",
                        "code": "# VULNERABLE Python code (Command Injection)\nimport os\n\ndef list_directory(user_input):\n    # If user_input is '; rm -rf /', this will delete files!\n    os.system(f\"ls {user_input}\")\n\n# SECURE Python code\nimport subprocess\n\ndef secure_list_directory(user_input):\n    # Using the array form passes the user input as a single, safe argument.\n    # The shell does not interpret it.\n    subprocess.run([\"ls\", user_input])"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "Writing data past the end of an array in C/C++ is a classic vulnerability known as a:",
                        "options": [
                            "SQL Injection",
                            "Buffer Overflow",
                            "Cross-Site Scripting",
                            "Race Condition"
                        ],
                        "correct": 1,
                        "explanation": "Buffer overflows are a major class of memory safety vulnerability in languages like C/C++. They can corrupt data, crash the program, and are often exploitable for arbitrary code execution."
                    },
                    {
                        "id": 2,
                        "question": "In Python, you should never use which module to deserialize data from an untrusted source because it can execute arbitrary code?",
                        "options": [
                            "json",
                            "requests",
                            "pickle",
                            "os"
                        ],
                        "correct": 2,
                        "explanation": "The `pickle` module is notoriously insecure. It was designed for serialization between trusted processes, not for handling untrusted data. Unpickling malicious data can lead to a full remote code execution."
                    },
                    {
                        "id": 3,
                        "question": "A modern programming language that is designed to be memory-safe by default through a system of ownership and borrowing rules is:",
                        "options": [
                            "C",
                            "Assembly",
                            "C++",
                            "Rust"
                        ],
                        "correct": 3,
                        "explanation": "Rust's key innovation is its compile-time memory safety guarantees. The compiler enforces rules that make entire classes of common security vulnerabilities (like buffer overflows and use-after-free) impossible to write in safe Rust code."
                    },
                    {
                        "id": 4,
                        "question": "When parsing XML from an untrusted source in Java, it is critical to disable the processing of external entities to prevent what kind of attack?",
                        "options": [
                            "XML External Entity (XXE)",
                            "Deserialization",
                            "SQL Injection",
                            "Command Injection"
                        ],
                        "correct": 0,
                        "explanation": "XXE is a vulnerability that allows an attacker to include a reference to an external file in an XML document. A vulnerable parser will then read and return the contents of that file (e.g., `/etc/passwd`), leading to information disclosure."
                    }
                ]
            }
        },
        {
            "id": "lesson-13",
            "title": "Error Handling and Logging",
            "duration": "90 min",
            "objectives": [
                "Implement secure error handling patterns that avoid information disclosure.",
                "Design a centralized and structured logging architecture.",
                "Learn to protect log data from tampering and unauthorized access.",
                "Understand what information to include in logs to create an effective audit trail."
            ],
            "content": {
                "overview": "Error handling and logging are essential for both debugging and security. However, if implemented incorrectly, they can become a source of vulnerabilities themselves, leaking sensitive information to attackers. This lesson covers the best practices for creating secure error handlers and a robust, auditable logging framework.",
                "sections": [
                    {
                        "title": "Secure Error Handling Patterns",
                        "content": "<p>Error messages are a double-edged sword. They are helpful for developers but can provide a roadmap for attackers if they are too detailed.</p><h3>Key Principles:</h3><ul><li><strong>Don't Leak Implementation Details:</strong> Error messages shown to the end-user should be generic. They should never include sensitive information like stack traces, database query errors, or internal file paths.</li><li><strong>Use Error Codes:</strong> Show the user a generic error message along with a unique reference ID (e.g., 'An unexpected error occurred. Please contact support with reference ID: a1b2-c3d4').</li><li><strong>Log the Details:</strong> The detailed error message, including the stack trace and all relevant variables, should be logged securely on the server-side, correlated with the reference ID. This gives developers the information they need to debug without exposing it to the user.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1555099962-4199c345e546?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Centralized Logging Architectures",
                        "content": "<p>Application logs should not be stored on the local file system of the web server, where they can be lost or tampered with. They should be immediately shipped to a centralized, secure logging platform (e.g., the ELK Stack, Splunk, or a cloud-native service like CloudWatch Logs).</p><h3>The Benefits:</h3><ul><li><strong>Aggregation:</strong> Allows you to search and analyze logs from all your microservices and servers in one place.</li><li><strong>Security:</strong> The central platform can be configured to be append-only, preventing an attacker from deleting or modifying log entries to cover their tracks.</li><li><strong>Long-Term Retention:</strong> Provides a scalable solution for storing logs for the long periods required for compliance and forensics.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1581291518857-4e27b48ff24e?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Audit Trail Implementation",
                        "content": "<p>Not all log entries are equal. An audit log is a specific record of a security-relevant event. It's essential to log the right information to create a useful audit trail.</p><h3>What to Log for Security Events:</h3><ul><li><strong>Timestamp:</strong> When did the event happen? (Use a synchronized time source like NTP).</li><li><strong>Source IP Address:</strong> Where did the request come from?</li><li><strong>User Identity:</strong> Who performed the action? (The authenticated user ID, not just a username).</li><li><strong>Action:</strong> What did they do? (e.g., 'user_login', 'delete_record').</li><li><strong>Resource:</strong> What did they do it to? (e.g., the ID of the record that was deleted).</li><li><strong>Outcome:</strong> Was the action successful or did it fail?</li></ul><p><strong>What NOT to log:</strong> Never log sensitive data like passwords, session tokens, or credit card numbers in your logs.</p>",
                        "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 13: Secure Logging and Error Handling Framework",
                        "language": "java",
                        "code": "// Example of a secure global exception handler in a Spring Boot application\n\n@ControllerAdvice\npublic class GlobalExceptionHandler {\n\n    private static final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);\n\n    @ExceptionHandler(Exception.class)\n    public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {\n        // Generate a unique ID for this error instance\n        String errorId = UUID.randomUUID().toString();\n\n        // 1. Log the full, detailed error on the server side with the ID\n        log.error(\"Unhandled exception, ID: {}\", errorId, ex);\n\n        // 2. Create a generic, safe response to send to the client\n        ErrorResponse errorResponse = new ErrorResponse(\n            \"An unexpected internal error occurred.\",\n            errorId\n        );\n\n        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n}"
                    },
                    {
                        "title": "Code Example 13: Centralized Security Logging System",
                        "language": "json",
                        "code": "// Example of a well-structured, centralized security log entry (JSON format)\n\n{\n  \"timestamp\": \"2025-09-13T15:30:00Z\",\n  \"event\": {\n    \"action\": \"user_login\",\n    \"outcome\": \"failure\",\n    \"category\": \"authentication\"\n  },\n  \"source\": {\n    \"ip\": \"203.0.113.100\"\n  },\n  \"user\": {\n    \"name\": \"testuser\"\n  },\n  \"application\": {\n    \"name\": \"main-webapp\",\n    \"version\": \"1.3.2\"\n  },\n  \"details\": {\n    \"reason\": \"Incorrect password provided.\"\n  }\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary security risk of showing a detailed stack trace to an end-user?",
                        "options": [
                            "It improves the user experience.",
                            "It has no security risk.",
                            "It can leak sensitive information about your application's internal structure, libraries, and file paths, which helps an attacker.",
                            "It makes the application run faster."
                        ],
                        "correct": 2,
                        "explanation": "This is a classic 'Information Disclosure' vulnerability. The detailed error gives an attacker a free roadmap of your application's internals, which they can use to craft more targeted attacks."
                    },
                    {
                        "id": 2,
                        "question": "What is the best practice for storing application logs?",
                        "options": [
                            "Store them on the local web server's disk and delete them daily.",
                            "Do not generate any logs.",
                            "Ship them in real-time to a centralized, secure, and tamper-resistant logging platform.",
                            "Print them out and store them in a file cabinet."
                        ],
                        "correct": 2,
                        "explanation": "Centralized logging is essential for security. It ensures that logs are aggregated for analysis and, critically, protects them from being deleted or altered by an attacker who has compromised the original server."
                    },
                    {
                        "id": 3,
                        "question": "Which of the following pieces of information should NEVER be written to a log file?",
                        "options": [
                            "The timestamp of the event.",
                            "The authenticated user's ID.",
                            "A user's plaintext password or session token.",
                            "The source IP address of the request."
                        ],
                        "correct": 2,
                        "explanation": "Logs are often a target for attackers. If you log sensitive credentials like passwords or session tokens, a compromise of your logging system can lead to a widespread compromise of user accounts."
                    },
                    {
                        "id": 4,
                        "question": "A generic error message that includes a unique reference ID is a secure design pattern because:",
                        "options": [
                            "It makes debugging impossible.",
                            "It hides sensitive details from the user while providing a way to correlate the event with the detailed logs on the server-side.",
                            "It looks more professional.",
                            "It is required by law in all countries."
                        ],
                        "correct": 1,
                        "explanation": "This pattern provides the best of both worlds: a safe, user-friendly message for the client, and a detailed, actionable record for the development and security teams."
                    }
                ]
            }
        },
        {
            "id": "lesson-14",
            "title": "Database Security in Development",
            "duration": "90 min",
            "objectives": [
                "Master the use of parameterized queries to prevent SQL Injection.",
                "Implement secure database connection management.",
                "Apply the principle of least privilege to database access control.",
                "Understand the security considerations for both SQL and NoSQL databases."
            ],
            "content": {
                "overview": "The database is the crown jewel of most applications, storing the most sensitive and valuable data. Securing the interaction between the application and the database is a critical responsibility for every developer. This lesson covers the essential secure coding practices for database access, focusing on preventing injection attacks and enforcing least privilege.",
                "sections": [
                    {
                        "title": "SQL Injection Prevention Techniques",
                        "content": "<p>SQL Injection remains one of the most common and damaging web application vulnerabilities. The only robust defense is to never mix code (the SQL query) and data (user input).</p><h3>The Only Sure Defense: Parameterized Queries</h3><p>As covered in the web security lesson, you must always use <strong>parameterized queries</strong> (or prepared statements). This programming technique sends the SQL query structure to the database server first, and then sends the user-supplied data separately. The database engine is designed to treat the parameterized data *only* as data, never as executable code, which makes SQL injection impossible.</p><div class=\"info-box warning\"><div class=\"info-box-header\"><i class=\"fas fa-exclamation-triangle\"></i><strong>ORM and Linq</strong></div><p>Even when using an Object-Relational Mapper (ORM) like Hibernate or Entity Framework, you still need to be careful. While most ORMs use parameterized queries by default, they often have an 'escape hatch' to run raw SQL queries. If you use this feature, you are once again responsible for preventing SQL injection.</p></div>",
                        "image": "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Database Connection Security",
                        "content": "<ul><li><strong>Encrypt Traffic:</strong> The network connection between the application server and the database server must be encrypted using TLS. This prevents a network-based attacker from sniffing or modifying database queries.</li><li><strong>Secure Connection Strings:</strong> The database connection string itself contains credentials. It must be treated as a secret and stored securely in a vault or secrets management system. It should never be hard-coded in source code or a plaintext config file.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1593441139884-faf2c88c7c97?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Database Access Control Implementation",
                        "content": "<p>This is a direct application of the Principle of Least Privilege.</p><h3>The Application Service Account:</h3><p>The application should connect to the database using its own dedicated service account. This account's permissions should be scoped down to the absolute minimum required.</p><ul><li>If the application only needs to read data, grant it `SELECT` permissions only.</li><li>Grant permissions only on the specific tables, views, or stored procedures the application needs to access.</li><li>Never grant the application service account powerful permissions like `DB_OWNER` or `SYSADMIN`.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1556155092-490a1ba16284?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "NoSQL Security Considerations",
                        "content": "<p>NoSQL databases (like MongoDB, Cassandra, and Elasticsearch) have different query languages, but they are still susceptible to injection attacks if user input is not handled safely.</p><p>For example, a MongoDB query is constructed as a JSON-like object. If a developer builds this query object by concatenating strings with untrusted user input, an attacker can inject malicious operators to bypass authentication or modify the query's logic. The principle is the same: always use a library that safely separates the query structure from the user-supplied data.</p>",
                        "image": "https://images.unsplash.com/photo-1517694712202-14dd9538aa97?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 14: Secure Database Integration Workshop",
                        "language": "csharp",
                        "code": "// Example of a secure parameterized query in C# with Dapper\n\npublic User GetUser(string username) {\n    // The query uses a named parameter '@username'.\n    var sql = \"SELECT * FROM Users WHERE Username = @username\";\n\n    using (var connection = new SqlConnection(_connectionString)) {\n        // The user input is passed in a separate object.\n        // The library ensures it is treated safely as data.\n        return connection.QuerySingleOrDefault<User>(sql, new { username });\n    }\n}"
                    },
                    {
                        "title": "Code Example 14: Database Security Abstraction Layer",
                        "language": "sql",
                        "code": "-- Example of using Stored Procedures for least privilege\n\n-- 1. Create a stored procedure that performs a specific, well-defined action.\nCREATE PROCEDURE GetUserProfile (@userId INT)\nAS\nBEGIN\n    SELECT user_id, username, full_name FROM users WHERE user_id = @userId;\nEND\n\n-- 2. Create a specific role for the application.\nCREATE ROLE AppRole;\n\n-- 3. Grant the role permission to EXECUTE the procedure.\nGRANT EXECUTE ON GetUserProfile TO AppRole;\n\n-- 4. DENY the role direct access to the underlying table.\nDENY SELECT ON users TO AppRole;\n\n-- Result: The application, using a login in the 'AppRole', can only get user profiles\n-- via the stored procedure. It cannot run arbitrary queries like 'SELECT * FROM users'."
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "The most effective and reliable method to prevent SQL Injection is:",
                        "options": [
                            "Manually filtering out characters like ' and --.",
                            "Using a Web Application Firewall.",
                            "Using parameterized queries (prepared statements).",
                            "Hiding the error messages from the user."
                        ],
                        "correct": 2,
                        "explanation": "Parameterized queries are a programmatic control that enforces the strict separation of code (the SQL query) and data (user input) at the database driver level. This fundamentally eliminates the possibility of SQL injection."
                    },
                    {
                        "id": 2,
                        "question": "An application's database connection string should be treated as a secret and stored where?",
                        "options": [
                            "Hard-coded in the source code.",
                            "In a public text file on the web server.",
                            "In a secure secrets management system, like a vault.",
                            "In the browser's local storage."
                        ],
                        "correct": 2,
                        "explanation": "The connection string contains the credentials for accessing the database. It is a highly sensitive secret and must be protected in a secure vault and retrieved by the application at runtime."
                    },
                    {
                        "id": 3,
                        "question": "What is the best way to apply the Principle of Least Privilege to an application's database service account?",
                        "options": [
                            "Grant the account the 'sysadmin' or 'db_owner' role.",
                            "Use a shared account for all applications.",
                            "Grant the account only the specific permissions (e.g., SELECT, INSERT) it needs on only the specific tables or views it needs to access.",
                            "Allow the account to connect from anywhere on the internet."
                        ],
                        "correct": 2,
                        "explanation": "This is the definition of least privilege. By granting the absolute minimum permissions, you limit the damage an attacker can do if they manage to compromise the application and its database connection."
                    },
                    {
                        "id": 4,
                        "question": "Why must the network connection between the application server and the database server be encrypted with TLS?",
                        "options": [
                            "To make the queries run faster.",
                            "To prevent a network-based attacker from sniffing or modifying the data and queries in transit.",
                            "It does not need to be encrypted if it is an 'internal' network.",
                            "To make the database easier to manage."
                        ],
                        "correct": 1,
                        "explanation": "In a Zero Trust model, there is no trusted internal network. An attacker who has gained a foothold on the network could otherwise capture all database credentials and sensitive data if the connection is not encrypted."
                    }
                ]
            }
        },
        {
            "id": "lesson-15",
            "title": "File Handling and Upload Security",
            "duration": "90 min",
            "objectives": [
                "Understand the significant security risks associated with file upload features.",
                "Implement robust server-side validation of file type and content.",
                "Architect a secure storage solution for user-uploaded files.",
                "Learn to prevent path traversal and other file-based attacks."
            ],
            "content": {
                "overview": "Allowing users to upload files is one of the most high-risk features a developer can build. A poorly secured file upload can allow an attacker to upload a web shell for remote code execution, a virus to infect other users, or a malicious file to exploit a server-side vulnerability. This lesson covers the essential, layered defenses for building a secure file handling system.",
                "sections": [
                    {
                        "title": "File Type Validation and Verification",
                        "content": "<p>You must rigorously validate what kind of file a user is uploading on the server-side.</p><h3>The Layers of Validation:</h3><ol><li><strong>Check the File Extension (Weak):</strong> Check the extension against an allow-list (e.g., `.jpg`, `.png`, `.pdf`). This is a basic check but can be easily bypassed by renaming a file.</li><li><strong>Check the MIME Type (Weak):</strong> Check the `Content-Type` header sent by the browser. This is also easily spoofed by an attacker.</li><li><strong>Check the File's Magic Numbers (Strong):</strong> This is the most reliable method. Read the first few bytes of the file and compare them to the known 'magic numbers' (or file signature) for the allowed file types. For example, a JPEG file always starts with the bytes `FF D8 FF`.</li></ol>",
                        "image": "https://images.unsplash.com/photo-1588665387928-a8d2a13f8373?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Antivirus and Content Scanning",
                        "content": "<p>Even if the file is of a permitted type (like a PDF), it could still contain a virus or an exploit. The architecture must include a step to scan the file's content for malware.</p><h3>Implementation:</h3><p>After the file is uploaded to a temporary location on the server, the application should use an API to pass the file to an antivirus/antimalware scanner. The application should only proceed with processing and storing the file if the scanner returns a 'clean' result.</p>",
                        "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "File Storage Security",
                        "content": "<p>Where and how you store the file is a critical security decision.</p><h3>Key Rules:</h3><ul><li><strong>Store Outside the Web Root:</strong> Never store user-uploaded files in the same directory as your application's code or web content. If you do, an attacker who uploads a web shell (e.g., `shell.php`) could then execute it by browsing to `www.example.com/uploads/shell.php`.</li><li><strong>Use a Secure, Isolated Location:</strong> The best practice is to store uploaded files in a dedicated object store (like AWS S3 or Azure Blob Storage) with strict access controls.</li><li><strong>Use a Random Filename:</strong> Discard the user-supplied filename. Generate a new, random, and unique filename (like a UUID) for the file. This prevents path traversal and other filename-based attacks. Store the original filename in a database if you need to display it to the user later.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 15: Secure File Processing System",
                        "language": "python",
                        "code": "import uuid\nimport os\n\n# A secure directory outside the web root\nUPLOAD_DIRECTORY = \"/var/secure_uploads/\"\nALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'pdf'}\n\ndef is_allowed_file(filename):\n    return '.' in filename and \\\n           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\n\ndef secure_file_upload(file):\n    # 1. Validate the file extension (basic check)\n    if not is_allowed_file(file.filename):\n        raise SecurityException(\"File type not allowed.\")\n\n    # 2. Generate a new, random filename to prevent path traversal\n    # and other filename attacks.\n    file_extension = file.filename.rsplit('.', 1)[1].lower()\n    new_filename = f\"{uuid.uuid4()}.{file_extension}\"\n    \n    # 3. Save the file to a secure, non-web-accessible directory.\n    # Frameworks like Flask/Django provide a secure_filename function\n    # that should be used here as well.\n    file.save(os.path.join(UPLOAD_DIRECTORY, new_filename))\n    \n    # 4. (Conceptual) After saving, pass the file to a malware scanner.\n    # if not malware_scanner.scan(os.path.join(UPLOAD_DIRECTORY, new_filename)):\n    #     os.remove(os.path.join(UPLOAD_DIRECTORY, new_filename))\n    #     raise SecurityException(\"Malware detected.\")\n\n    return new_filename"
                    },
                    {
                        "title": "Code Example 15: Comprehensive File Security Framework",
                        "language": "java",
                        "code": "public class FileTypeValidator {\n\n    // Check the file's 'magic numbers' to verify its true type.\n    public static boolean isPdf(byte[] fileData) {\n        if (fileData == null || fileData.length < 4) {\n            return false;\n        }\n        // A PDF file must start with \"%PDF\" (hex: 25 50 44 46)\n        return fileData[0] == 0x25 &&\n               fileData[1] == 0x50 &&\n               fileData[2] == 0x44 &&\n               fileData[3] == 0x46;\n    }\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the most reliable server-side method for validating the type of an uploaded file?",
                        "options": [
                            "Trusting the file extension provided by the user.",
                            "Trusting the `Content-Type` header sent by the browser.",
                            "Reading the first few bytes of the file to check its 'magic numbers' or signature.",
                            "Checking if the filename contains the word 'image'."
                        ],
                        "correct": 2,
                        "explanation": "Both the filename and the Content-Type header are user-controlled and can be easily spoofed. Checking the file's actual byte signature is the most reliable way to determine its true type."
                    },
                    {
                        "id": 2,
                        "question": "Why should user-uploaded files never be stored in the web root directory?",
                        "options": [
                            "It is the most secure location.",
                            "To prevent an attacker who uploads an executable file (like a web shell) from being able to run it by browsing to its URL.",
                            "It makes the files load faster.",
                            "It saves disk space."
                        ],
                        "correct": 1,
                        "explanation": "Storing uploads in the web root mixes untrusted user content with trusted application code, a dangerous practice. If an attacker can get a file with an executable extension (.php, .jsp, etc.) into the web root, the server will often execute it, leading to a full compromise."
                    },
                    {
                        "id": 3,
                        "question": "An attack that uses `../` sequences in a filename to try and access or overwrite files outside of the intended directory is called:",
                        "options": [
                            "SQL Injection",
                            "Cross-Site Scripting",
                            "Path Traversal",
                            "A Buffer Overflow"
                        ],
                        "correct": 2,
                        "explanation": "Path traversal is a classic file handling vulnerability. The best defenses are to discard the user-supplied filename and generate a new, random one, and to use a library function that safely joins path components."
                    },
                    {
                        "id": 4,
                        "question": "After validating a file's type, what is a critical next step in a secure file upload architecture?",
                        "options": [
                            "Immediately making the file public.",
                            "Passing the file to an antivirus/antimalware scanner.",
                            "Renaming the file to a name provided by the user.",
                            "Assuming the file is safe because its type is correct."
                        ],
                        "correct": 1,
                        "explanation": "A file can be a valid type (like a PDF or a DOCX file) but still be malicious, containing an embedded virus or an exploit. Scanning the file's content for malware is an essential defense-in-depth step."
                    }
                ]
            }
        },
        
        {
            "id": "lesson-16",
            "title": "Memory Management and Buffer Overflows",
            "duration": "90 min",
            "objectives": [
                "Understand the concept of memory safety and its importance.",
                "Identify the root causes of buffer overflow vulnerabilities in languages like C/C++.",
                "Learn to use safe string and memory handling functions.",
                "Explore how modern languages like Rust prevent these errors by design."
            ],
            "content": {
                "overview": "Memory management errors are the root cause of some of the most critical vulnerabilities in software history. This is especially true in languages like C and C++ that give the developer direct control over memory. This lesson provides a deep dive into buffer overflows and other memory safety issues and covers the essential defensive coding practices to prevent them.",
                "sections": [
                    {
                        "title": "Memory Safety Principles",
                        "content": "<p>A language or program is 'memory-safe' if it prevents programmers from introducing certain types of bugs related to memory access, such as buffer overflows and use-after-free errors. Languages like Java, Python, and Go are largely memory-safe because the runtime environment manages memory for the developer. Languages like C and C++ are not memory-safe, placing the full responsibility on the developer.</p>",
                        "image": "https://images.unsplash.com/photo-1555099962-4199c345e546?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Buffer Overflow Attack Vectors",
                        "content": "<p>A buffer overflow occurs when a program attempts to write data beyond the allocated boundary of a buffer (like an array). This can corrupt adjacent data, crash the program, or, in the worst case, be exploited by an attacker to execute arbitrary code.</p><h3>Stack vs. Heap Overflows:</h3><ul><li><strong>Stack-based Overflow:</strong> The most common type. An overly long input to a function can overwrite other data on the program's stack, including the function's return address. An attacker can overwrite this return address to point to malicious shellcode they've injected.</li><li><strong>Heap-based Overflow:</strong> More complex to exploit, but still dangerous. Overwriting data in a dynamically allocated block of memory (on the heap) can corrupt the application's internal state.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1517694712202-14dd9538aa97?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Safe String Handling Practices",
                        "content": "<p>The most common cause of buffer overflows is the use of unsafe C-style string functions that do not perform bounds checking.</p><h3>The Rule:</h3><p>Never use functions like `strcpy`, `strcat`, `sprintf`, and `gets`. They have no way of knowing the size of the destination buffer and will happily write past the end of it.</p><h3>The Alternatives:</h3><p>Always use their 'bounded' equivalents, which take the size of the destination buffer as an argument and will not write past it. Examples include `strncpy`, `strncat`, and `snprintf`.</p>",
                        "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 16: Memory Safety Analysis Workshop",
                        "language": "c",
                        "code": "// VULNERABLE CODE\n// If the 'name' parameter is longer than 15 characters, this will cause a stack-based buffer overflow.\nvoid greet(char *name) {\n    char greeting[16];\n    sprintf(greeting, \"Hello, %s!\", name);\n    printf(\"%s\\n\", greeting);\n}\n\n// SECURE CODE\n// snprintf takes the buffer size as an argument and will not write more than that many bytes.\nvoid secure_greet(char *name) {\n    char greeting[16];\n    snprintf(greeting, sizeof(greeting), \"Hello, %s!\", name);\n    printf(\"%s\\n\", greeting);\n}"
                    },
                    {
                        "title": "Code Example 16: Memory Safety Validation Tools",
                        "language": "shell",
                        "code": "# Using a static analysis tool (like cppcheck) to find the vulnerability\n\n$ cppcheck --enable=all unsafe.c\nChecking unsafe.c ...\n[unsafe.c:6]: (error) Buffer is accessed out of bounds. `sprintf` will write out of bounds. The buffer `greeting` is 16 bytes, but the string may be larger.\n\n# Compiling with stack canaries (a compiler-level defense)\n$ gcc -fstack-protector-all -o unsafe unsafe.c\n\n# When the vulnerable code is run with a long input, the stack canary detects the overflow\n# and safely terminates the program instead of allowing code execution.\n$ ./unsafe \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n*** stack smashing detected ***: terminated"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "A language that prevents memory access bugs like buffer overflows by default through its runtime or compiler is known as:",
                        "options": [
                            "Memory-unsafe",
                            "Memory-safe",
                            "A legacy language",
                            "A scripting language"
                        ],
                        "correct": 1,
                        "explanation": "Languages like Java, Python, Go, and Rust are considered memory-safe because they have built-in protections that make entire classes of memory corruption vulnerabilities impossible to introduce."
                    },
                    {
                        "id": 2,
                        "question": "The C function `strcpy` is dangerous because:",
                        "options": [
                            "It is too slow.",
                            "It does not perform bounds checking and can write past the end of the destination buffer.",
                            "It encrypts the string.",
                            "It only works with numbers."
                        ],
                        "correct": 1,
                        "explanation": "`strcpy` is the classic example of an unsafe function. It has no way of knowing the size of the destination buffer and is a primary cause of buffer overflow vulnerabilities. Its bounded cousin, `strncpy`, should always be used instead."
                    },
                    {
                        "id": 3,
                        "question": "An attack where an overly long input to a function overwrites the function's return address on the stack to point to malicious code is a:",
                        "options": [
                            "Heap-based buffer overflow",
                            "Stack-based buffer overflow",
                            "Use-after-free",
                            "SQL Injection"
                        ],
                        "correct": 1,
                        "explanation": "This is the classic stack smashing attack. By controlling the return address, an attacker can hijack the program's execution flow and run their own code."
                    },
                    {
                        "id": 4,
                        "question": "A compiler-level defense that places a secret value on the stack before a buffer and checks it after the function returns to see if it has been overwritten is called a:",
                        "options": [
                            "Firewall",
                            "Stack canary",
                            "Regular expression",
                            "Hash"
                        ],
                        "correct": 1,
                        "explanation": "A stack canary (named after the 'canary in a coal mine') is a powerful modern compiler defense. It detects that a buffer overflow has occurred and safely terminates the program, preventing the attack from succeeding."
                    }
                ]
            }
        },
        {
            "id": "lesson-17",
            "title": "Concurrency and Race Condition Security",
            "duration": "90 min",
            "objectives": [
                "Understand how race conditions create security vulnerabilities.",
                "Identify Time-of-Check to Time-of-Use (TOCTOU) flaws.",
                "Learn to use synchronization primitives like locks to ensure thread safety.",
                "Explore the use of atomic operations for secure concurrency."
            ],
            "content": {
                "overview": "In modern, multi-threaded applications, multiple threads of execution often access the same shared resources. If this access is not properly controlled, it can lead to concurrency bugs. A race condition is a type of concurrency bug that can create subtle but serious security vulnerabilities. This lesson explores how to identify and prevent these flaws.",
                "sections": [
                    {
                        "title": "Race Condition Vulnerability Types",
                        "content": "<p>A race condition occurs when the behavior of a system depends on the unpredictable sequence or timing of events. A security vulnerability can occur when the 'race' is between a security check and the operation it is supposed to be checking.</p><h3>Example: Bank Transfer</h3><p>Imagine a function that transfers money. It first checks if the user has enough funds, and then it performs the withdrawal.</p><ol><li>Thread A checks user balance ($100). Balance >= withdrawal amount ($75). The check passes.</li><li>Thread B checks user balance ($100). Balance >= withdrawal amount ($75). The check also passes.</li><li>Thread A withdraws $75. New balance is $25.</li><li>Thread B withdraws $75. New balance is -$50.</li></ol><p>The user has withdrawn more money than they had because the check and the action were not performed as a single, atomic operation.</p>",
                        "image": "https://images.unsplash.com/photo-1534972195531-0e108fc312f0?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Time-of-Check to Time-of-Use (TOCTOU)",
                        "content": "<p>TOCTOU (pronounced 'TOCK-too') is a specific class of race condition that is a common source of security vulnerabilities. It is also known as a 'check-then-act' flaw.</p><h3>The Pattern:</h3><ol><li>**Time of Check:** The program checks a condition, for example, 'Does the user have permission to access this file?'</li><li>**Time of Use:** The program then performs an action based on that check, for example, 'Open the file and read its contents.'</li></ol><p>The vulnerability occurs because an attacker can potentially change the state of the resource *between* the check and the use. For example, an attacker could swap the file with a symbolic link to a sensitive system file (`/etc/passwd`) after the permission check has passed but before the file is opened.</p>",
                        "image": "https://images.unsplash.com/photo-1588665387928-a8d2a13f8373?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Synchronization Security Patterns",
                        "content": "<p>The primary way to prevent race conditions is to ensure that critical sections of code are executed 'atomically'â€”meaning as a single, indivisible operation.</p><h3>Using Locks:</h3><p>The most common way to achieve this is with a synchronization primitive called a lock (or a mutex). Before a thread enters a critical section, it must acquire the lock. If another thread already holds the lock, the second thread will wait. After the first thread is finished, it releases the lock, allowing the second thread to proceed. This ensures that only one thread can be in the critical section at a time.</p><p>For the bank transfer example, the entire operation (check balance AND withdraw) must be protected by a lock.</p>",
                        "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 17: Concurrency Security Testing Platform",
                        "language": "python",
                        "code": "# VULNERABLE Python code (TOCTOU flaw)\nimport os\n\ndef read_user_file(filepath):\n    # Time of Check: Does the user have access to the file they requested?\n    if not os.access(filepath, os.R_OK):\n        raise PermissionError(\"Access denied.\")\n    \n    # An attacker could swap 'filepath' with a symlink to a root-owned file\n    # in the tiny window between the check above and the open below.\n    \n    # Time of Use: Open the file.\n    with open(filepath, 'r') as f:\n        return f.read()\n\n# MITIGATION:\n# For filesystem TOCTOU, the best defense is to impersonate the user.\n# The program temporarily drops its own privileges and attempts the operation\n# as the user. The operating system kernel then performs the check and the action\n# as a single, atomic operation, which cannot be raced."
                    },
                    {
                        "title": "Code Example 17: Thread-Safe Security Framework",
                        "language": "java",
                        "code": "import java.util.concurrent.locks.ReentrantLock;\n\npublic class BankAccount {\n    private double balance;\n    private final ReentrantLock lock = new ReentrantLock();\n\n    // VULNERABLE: Not thread-safe\n    public void unsafeWithdraw(double amount) {\n        if (this.balance >= amount) {\n            // Another thread can run between the check and the update!\n            this.balance -= amount;\n        }\n    }\n\n    // SECURE: Thread-safe using a lock\n    public void safeWithdraw(double amount) {\n        // Acquire the lock before the critical section\n        lock.lock();\n        try {\n            // The check and the update are now a single, atomic operation.\n            if (this.balance >= amount) {\n                this.balance -= amount;\n            }\n        } finally {\n            // Always release the lock in a 'finally' block to prevent deadlocks.\n            lock.unlock();\n        }\n    }\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "A bug that occurs when the outcome of an operation depends on the unpredictable timing of concurrent threads is known as a:",
                        "options": [
                            "Buffer Overflow",
                            "SQL Injection",
                            "Race Condition",
                            "Cross-Site Scripting"
                        ],
                        "correct": 2,
                        "explanation": "A race condition is a classic concurrency problem. When these bugs have a security implication (e.g., allowing a security check to be bypassed), they become a serious vulnerability."
                    },
                    {
                        "id": 2,
                        "question": "A vulnerability where an attacker can change a resource between the time the program checks for permissions and the time the program uses the resource is called:",
                        "options": [
                            "Use-after-free",
                            "Time-of-Check to Time-of-Use (TOCTOU)",
                            "Deserialization vulnerability",
                            "Integer Overflow"
                        ],
                        "correct": 1,
                        "explanation": "TOCTOU is a specific and common type of race condition vulnerability. It exploits the small time gap between a security check and the action it is intended to protect."
                    },
                    {
                        "id": 3,
                        "question": "What is the most common programming construct used to prevent race conditions in a critical section of code?",
                        "options": [
                            "A comment",
                            "A loop",
                            "A lock (or mutex)",
                            "An if-statement"
                        ],
                        "correct": 2,
                        "explanation": "A lock is a synchronization primitive that ensures mutual exclusion, meaning only one thread can execute a particular section of code at a time. This makes the critical section atomic and prevents race conditions."
                    },
                    {
                        "id": 4,
                        "question": "In a thread-safe bank withdrawal function, what part of the code must be protected by the lock?",
                        "options": [
                            "Only the check for the balance.",
                            "Only the action of subtracting the money.",
                            "Both the check for the balance AND the action of subtracting the money must be in the same critical section.",
                            "None of it needs to be locked."
                        ],
                        "correct": 2,
                        "explanation": "The entire check-then-act sequence must be atomic. If you only lock the withdrawal action, another thread can still perform its own check after the first thread has checked but before it has withdrawn, leading to the same race condition."
                    }
                ]
            }
        },
        {
            "id": "lesson-18",
            "title": "Third-Party Component Security",
            "duration": "90 min",
            "objectives": [
                "Understand the security risks of using open-source and third-party dependencies.",
                "Learn to use Software Composition Analysis (SCA) tools to find vulnerable components.",
                "Implement a process for managing and updating dependencies.",
                "Grasp the importance of software supply chain security and the role of an SBOM."
            ],
            "content": {
                "overview": "Modern applications are assembled from hundreds of open-source and third-party libraries. While this dramatically speeds up development, it also means you are inheriting the security posture of every component you use. This lesson, previously introduced in the DevSecOps course, focuses on the developer's role in managing this software supply chain risk.",
                "sections": [
                    {
                        "title": "Open Source Security Risk Assessment",
                        "content": "<p>When you `import` a library, you are importing all of its codeâ€”and any potential vulnerabilitiesâ€”directly into your application. An attacker who finds a vulnerability in a popular, widely used library can effectively attack thousands of applications at once.</p><h3>The Log4Shell Example:</h3><p>The vulnerability in the popular Java logging library Log4j was a stark reminder of this risk. A single, critical vulnerability in a nearly ubiquitous component created a global cybersecurity crisis. Organizations that didn't know they were using Log4j (often as a transitive dependency) were left scrambling.</p>",
                        "image": "https://images.unsplash.com/photo-1556075798-4825dfaaf498?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Dependency Vulnerability Management",
                        "content": "<p>As a developer, you are responsible for the security of your dependencies. The only way to manage this at scale is with automation.</p><h3>The Role of SCA Tools:</h3><p><strong>Software Composition Analysis (SCA)</strong> tools (like Snyk, OWASP Dependency-Check, or GitHub's Dependabot) are essential. They:</p><ol><li>Scan your package manager files (e.g., `pom.xml`, `package.json`).</li><li>Create an inventory of all your direct and transitive dependencies.</li><li>Compare this inventory against a database of known public vulnerabilities (CVEs).</li><li>Alert you if you are using a component with a known vulnerability.</li></ol>",
                        "image": "https://images.unsplash.com/photo-1542382257-80deda0e5d99?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Component Version Management",
                        "content": "<p>Managing dependencies is a continuous process.</p><h3>Developer Best Practices:</h3><ul><li><strong>Use Lock Files:</strong> Always commit a package lock file (e.g., `package-lock.json`, `Pipfile.lock`) to your repository. This ensures that every developer and the CI/CD pipeline uses the exact same version of every dependency, creating repeatable and predictable builds.</li><li><strong>Update Regularly:</strong> Don't let your dependencies become ancient. Regularly update them to their latest stable versions to get bug fixes and security patches.</li><li><strong>Automate Updates:</strong> Use tools like GitHub's Dependabot, which can automatically detect that a dependency you use has a new security patch and will create a pull request to update it for you.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 18: Component Security Management System",
                        "language": "yaml",
                        "code": "# Example of a GitHub Dependabot configuration file (.github/dependabot.yml)\n# This automates the process of keeping dependencies up-to-date.\n\nversion: 2\nupdates:\n  # Check for npm dependency updates every day\n  - package-ecosystem: \"npm\"\n    directory: \"/\"\n    schedule:\n      interval: \"daily\"\n    # Automatically create a pull request for security updates\n    open-pull-requests-limit: 10\n\n  # Check for Dockerfile updates as well\n  - package-ecosystem: \"docker\"\n    directory: \"/\"\n    schedule:\n      interval: \"daily\""
                    },
                    {
                        "title": "Code Example 18: Automated Dependency Security Scanner",
                        "language": "json",
                        "code": "// Conceptual output from an SCA scanner\n\n{\n  \"dependencyName\": \"express\",\n  \"versionUsed\": \"4.17.1\",\n  \"severity\": \"High\",\n  \"vulnerabilityId\": \"CVE-2022-2499\",\n  \"description\": \"A cross-site scripting vulnerability exists in the `express` library.\",\n  \"remediation\": {\n    \"recommendation\": \"Upgrade to version 4.18.2 or later.\",\n    \"isFixAvailable\": true\n  },\n  \"dependencyPath\": [\n    \"my-app@1.0.0\",\n    \"template-engine@2.1.0\",\n    \"express@4.17.1\"\n  ]\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "The automated process of scanning your application's dependencies for known vulnerabilities is called:",
                        "options": [
                            "Static Application Security Testing (SAST)",
                            "Dynamic Application Security Testing (DAST)",
                            "Software Composition Analysis (SCA)",
                            "Penetration Testing"
                        ],
                        "correct": 2,
                        "explanation": "SCA tools specifically focus on the composition of your softwareâ€”the third-party and open-source components you are usingâ€”to find known security and license issues."
                    },
                    {
                        "id": 2,
                        "question": "What is the purpose of a package lock file (e.g., `package-lock.json`)?",
                        "options": [
                            "To make the build process random and unpredictable.",
                            "To ensure that every developer and the CI pipeline use the exact same version of every dependency, creating deterministic builds.",
                            "To list only the direct dependencies of a project.",
                            "To store the source code of the dependencies."
                        ],
                        "correct": 1,
                        "explanation": "Lock files are critical for supply chain security and reliability. They 'lock' the entire dependency tree, preventing unexpected or malicious updates from being pulled into your build."
                    },
                    {
                        "id": 3,
                        "question": "A formal inventory of all the software components in an application, often generated by an SCA tool, is known as a:",
                        "options": [
                            "Software Bill of Materials (SBOM)",
                            "Threat Model",
                            "Pull Request",
                            "API Specification"
                        ],
                        "correct": 0,
                        "explanation": "An SBOM is the 'list of ingredients' for your application. It provides the essential visibility needed to manage supply chain risk, especially when responding to new zero-day vulnerabilities."
                    },
                    {
                        "id": 4,
                        "question": "A tool like GitHub's Dependabot improves security by:",
                        "options": [
                            "Scanning your custom source code for bugs.",
                            "Automatically creating pull requests to update your dependencies when a new security patch is released.",
                            "Testing your running application.",
                            "Managing your cloud infrastructure."
                        ],
                        "correct": 1,
                        "explanation": "Automated dependency updating tools dramatically reduce the effort required to keep your components patched, which in turn reduces your mean time to remediate (MTTR) for this class of vulnerability."
                    }
                ]
            }
        },
        {
            "id": "lesson-19",
            "title": "DevSecOps Integration",
            "duration": "120 min",
            "objectives": [
                "Understand the developer's role in a DevSecOps CI/CD pipeline.",
                "Learn how different security tools (SAST, DAST, SCA, IAST) are integrated into the pipeline.",
                "Grasp the concept of a 'security gate' and how it enforces quality.",
                "Explore the security of the pipeline itself and the concept of 'pipeline as code'."
            ],
            "content": {
                "overview": "DevSecOps is the philosophy of integrating security into the CI/CD pipeline to provide fast, automated feedback to developers. This lesson connects all the concepts we've learned about secure coding and testing, showing how they are orchestrated in a modern, automated DevSecOps pipeline and what this means for you as a developer.",
                "sections": [
                    {
                        "title": "Security in CI/CD Pipelines",
                        "content": "<p>The CI/CD pipeline is the automated workflow that takes your code from a commit to a deployed artifact. In a DevSecOps model, this pipeline is augmented with automated security checks at every stage.</p><h3>The Developer's Experience:</h3><p>As a developer, you push your code to a feature branch. The pipeline runs automatically. If a security tool finds a critical issue, the pipeline 'breaks' (fails) and notifies you immediately. You get a direct link to the finding, fix the code in your branch, and push again. The pipeline runs again, and this time it passes. You can then create a pull request, confident that your code has met the baseline security standard.</p>",
                        "image": "https://images.unsplash.com/photo-1542382257-80deda0e5d99?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "SAST, DAST, IAST, and SCA Integration",
                        "content": "<p>These tools are integrated as automated stages in the pipeline:</p><ul><li><strong>SAST & SCA:</strong> These 'white-box' and dependency checks are run early, typically in the 'build' or 'test' stage, as they only need the source code.</li><li><strong>DAST:</strong> This 'black-box' check runs later. The pipeline must first deploy the application to a running staging or test environment, and then the DAST scanner is run against that live application.</li><li><strong>IAST:</strong> This 'gray-box' agent is enabled when the application is deployed to the staging environment. It then provides findings as the DAST scanner or other automated functional tests are running.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Deployment Security Gates",
                        "content": "<p>A security gate is a mandatory, automated quality check in the pipeline. It is a policy that is enforced by the CI/CD server.</p><h3>Example Gates:</h3><ul><li>`IF sast_scan.critical_findings > 0 THEN fail_build`</li><li>`IF sca_scan.critical_cves > 0 THEN fail_build`</li><li>`IF dast_scan.high_findings > 0 THEN fail_build`</li></ul><p>These gates are the primary mechanism for preventing vulnerable code from being promoted to production. The criteria for failing the build should be clearly defined and agreed upon by both the development and security teams.</p>",
                        "image": "https://images.unsplash.com/photo-1556155092-490a1ba16284?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 19: DevSecOps Pipeline Implementation",
                        "language": "yaml",
                        "code": "# A simplified, conceptual GitLab CI pipeline\n\nstages:\n  - build\n  - test\n  - deploy_staging\n  - security_scan\n  - deploy_production\n\nbuild_job:\n  stage: build\n  script: mvn install\n\nunit_tests:\n  stage: test\n  script: mvn test\n\n# These two jobs run in parallel\nsast_scan:\n  stage: test\n  script: run-sast-scanner.sh --fail-on-critical\n\nsca_scan:\n  stage: test\n  script: run-sca-scanner.sh --fail-on-critical\n\ndeploy_to_staging_job:\n  stage: deploy_staging\n  script: deploy-to-staging-env.sh\n\ndast_scan:\n  stage: security_scan\n  # This job runs after the app is deployed to staging\n  script: run-dast-scanner.sh --target http://staging-app\n\nproduction_deployment_job:\n  stage: deploy_production\n  script: deploy-to-prod-env.sh\n  # This job only runs on the main branch\n  rules:\n    - if: $CI_COMMIT_BRANCH == 'main'"
                    },
                    {
                        "title": "Code Example 19: Integrated Security Testing Framework",
                        "language": "json",
                        "code": "{\n  \"pullRequestId\": 42,\n  \"author\": \"jane.developer@example.com\",\n  \"status\": \"FAILED\",\n  \"summary\": \"Pipeline failed due to a critical security finding.\",\n  \"gates\": [\n    {\n      \"name\": \"Unit Tests\",\n      \"status\": \"PASSED\"\n    },\n    {\n      \"name\": \"SAST Scan\",\n      \"status\": \"PASSED\"\n    },\n    {\n      \"name\": \"SCA Scan\",\n      \"status\": \"FAILED\",\n      \"details\": \"Found critical vulnerability CVE-2025-1234 in dependency `log-utils:1.1.1`.\"\n    }\n  ]\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "In a DevSecOps pipeline, what is the developer's primary interaction with security tools?",
                        "options": [
                            "They receive immediate feedback from automated tools when a scan fails, allowing them to fix issues quickly in their own feature branch.",
                            "They receive a 300-page PDF report once a year.",
                            "They have no interaction; the security team handles everything.",
                            "They manually run all the security tools on their own laptop."
                        ],
                        "correct": 0,
                        "explanation": "The core purpose of a DevSecOps pipeline is to provide fast, automated, and actionable feedback directly to the developer, making security a seamless part of their normal workflow."
                    },
                    {
                        "id": 2,
                        "question": "Which type of security scan requires the application to be deployed to a running environment?",
                        "options": [
                            "SAST",
                            "SCA",
                            "DAST",
                            "Secret Scanning"
                        ],
                        "correct": 2,
                        "explanation": "DAST is a 'black-box' technique that probes the running application from the outside, just as an attacker would. Therefore, it requires a fully deployed and running instance of the application to test."
                    },
                    {
                        "id": 3,
                        "question": "An automated rule in a CI/CD pipeline that fails the build if the SCA scan finds a new critical vulnerability is known as a:",
                        "options": [
                            "Security Gate",
                            "Manual Approval",
                            "Code Comment",
                            "Deployment Target"
                        ],
                        "correct": 0,
                        "explanation": "A security gate is an automated policy enforcement point. It's the mechanism that allows the organization to enforce a minimum security bar and prevent vulnerable code from progressing towards production."
                    },
                    {
                        "id": 4,
                        "question": "Why is it a security best practice to define the CI/CD pipeline itself as code (e.g., in a `Jenkinsfile` or `.gitlab-ci.yml`)?",
                        "options": [
                            "It makes the pipeline harder to manage.",
                            "It allows changes to the build and deployment process to be version-controlled, peer-reviewed, and audited.",
                            "It has no security benefits.",
                            "It allows anyone to change the production deployment process without approval."
                        ],
                        "correct": 1,
                        "explanation": "The pipeline itself is a critical piece of infrastructure. Treating its configuration as code ensures that changes to this sensitive process go through the same rigorous review and approval as any other code change."
                    }
                ]
            }
        },
        {
            "id": "lesson-20",
            "title": "Cloud-Native Application Security",
            "duration": "120 min",
            "objectives": [
                "Understand the security challenges of microservices architectures.",
                "Learn the core principles of container security for developers.",
                "Grasp the developer's responsibility for securing serverless functions.",
                "Explore how a service mesh can be used to secure service-to-service communication."
            ],
            "content": {
                "overview": "Cloud-native architectures, built on containers, microservices, and serverless functions, have fundamentally changed how we build applications. They also introduce a new set of security challenges for developers. This lesson covers the key security patterns and responsibilities for developers building applications in a modern, cloud-native world.",
                "sections": [
                    {
                        "title": "Microservices Security Patterns",
                        "content": "<p>In a microservices architecture, the attack surface shifts from a single monolith to hundreds or thousands of small, networked services. The primary challenge is securing the 'east-west' traffic (communication between services).</p><h3>The Role of a Service Mesh:</h3><p>As a developer, you shouldn't have to write complex authentication and encryption code in every single service. A <strong>service mesh</strong> (like Istio or Linkerd) is an infrastructure layer that handles this for you. It can automatically:</p><ul><li>Encrypt all traffic between services with mutual TLS (mTLS).</li><li>Enforce authorization policies (e.g., 'Service A can call Service B, but Service C cannot').</li></ul><p>The developer's job is to build their service; the platform's job is to secure the communication between them.</p>",
                        "image": "https://images.unsplash.com/photo-1593441139884-faf2c88c7c97?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Container Security Best Practices",
                        "content": "<p>As the developer building the container image, you have a direct impact on its security.</p><h3>Dockerfile Best Practices:</h3><ul><li><strong>Use a Minimal Base Image:</strong> Start with the smallest possible base image (like `distroless` or `alpine`). A smaller image has fewer components, which means a smaller attack surface and fewer potential vulnerabilities.</li><li><strong>Don't Run as Root:</strong> Use the `USER` instruction in your Dockerfile to specify a non-root user for your application to run as. This is a critical defense-in-depth measure.</li><li><strong>Don't hard-code secrets:</strong> Never put passwords, API keys, or other secrets in your Dockerfile. They must be injected at runtime from a secure secrets management system.</li><li><strong>Multi-stage Builds:</strong> Use multi-stage builds to create a final production image that contains only the application binary and its direct dependencies, not the build tools, compilers, and source code.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1614064548237-02f0d1a2c39c?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Serverless Application Security",
                        "content": "<p>In a serverless model, your primary responsibility as a developer is the security of your function's code and its permissions.</p><h3>The #1 Rule: Least Privilege IAM Roles</h3><p>Every single serverless function must have its own, unique IAM role that grants it the absolute minimum permissions needed to do its job. If a function only needs to read from one S3 bucket, its role should only grant it the `s3:GetObject` permission on that specific bucket. This is defined in your Infrastructure as Code (e.g., in a `serverless.yml` or SAM template).</p>",
                        "image": "https://images.unsplash.com/photo-1555949963-ff9808202534?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 20: Cloud-Native Security Architecture",
                        "language": "dockerfile",
                        "code": "# Example of a secure, multi-stage Dockerfile\n\n# --- Build Stage ---\n# Use a full-featured image for building the application\nFROM golang:1.19 AS builder\nWORKDIR /app\nCOPY . .\n# Build the Go binary\nRUN CGO_ENABLED=0 go build -o myapp .\n\n# --- Final Stage ---\n# Use a minimal, distroless image for the final production container\n# It contains only our application and its dependencies, nothing else.\nFROM gcr.io/distroless/static-debian11\nWORKDIR /app\nCOPY --from=builder /app/myapp .\n\n# Use a non-root user\nUSER nonroot:nonroot\n\n# Set the entrypoint\nENTRYPOINT [\"/app/myapp\"]"
                    },
                    {
                        "title": "Code Example 20: Cloud Security Orchestration Platform",
                        "language": "yaml",
                        "code": "# Example of a least-privilege IAM role for a serverless function\n# defined in the Serverless Framework (serverless.yml)\n\nfunctions:\n  myFunction:\n    handler: handler.hello\n    # Define the specific, granular permissions for this function\n    iamRoleStatements:\n      - Effect: \"Allow\"\n        Action:\n          - \"dynamodb:GetItem\"\n        Resource: \"arn:aws:dynamodb:us-east-1:*:table/my-table\""
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary security challenge in a microservices architecture?",
                        "options": [
                            "The applications are too large and monolithic.",
                            "Securing the 'east-west' traffic (communication between services).",
                            "There are too few services to manage.",
                            "The databases are all in one place."
                        ],
                        "correct": 1,
                        "explanation": "In a microservices architecture, the attack surface shifts from a single application to the network connections between hundreds or thousands of services. Securing this internal communication is the key challenge."
                    },
                    {
                        "id": 2,
                        "question": "Using the `USER` instruction in a Dockerfile to run the application as a non-root user is an example of what security principle?",
                        "options": [
                            "Defense in Depth and Least Privilege",
                            "Encryption",
                            "Authentication",
                            "Availability"
                        ],
                        "correct": 0,
                        "explanation": "Even if an attacker finds a code execution vulnerability in your application, if the application is running as a non-root user, their capabilities within the container are significantly limited. This is a critical defense-in-depth measure."
                    },
                    {
                        "id": 3,
                        "question": "What is the most critical security responsibility for a developer when building a serverless function?",
                        "options": [
                            "Patching the operating system.",
                            "Configuring the network firewall.",
                            "Defining a unique, least-privilege IAM role for the function in their IaC template.",
                            "Managing the physical server hardware."
                        ],
                        "correct": 2,
                        "explanation": "In serverless, the cloud provider handles the OS, network, and hardware. The developer's primary responsibility is the code and its permissions. An overly permissive IAM role is the most common and dangerous serverless vulnerability."
                    },
                    {
                        "id": 4,
                        "question": "A technology that uses a 'sidecar' proxy to transparently encrypt and authorize all traffic between microservices is known as a:",
                        "options": [
                            "Database",
                            "API Gateway",
                            "Service Mesh",
                            "Load Balancer"
                        ],
                        "correct": 2,
                        "explanation": "A service mesh (like Istio or Linkerd) is the standard architectural pattern for securing service-to-service communication in a cloud-native environment, allowing developers to focus on business logic instead of writing complex security code in every service."
                    }
                ]
            }
        },
        {
            "id": "lesson-21",
            "title": "Security Testing Strategies",
            "duration": "120 min",
            "objectives": [
                "Understand how to write security-focused unit and integration tests.",
                "Learn the role of fuzzing and chaos engineering in finding security flaws.",
                "Design a robust security regression testing suite.",
                "Integrate penetration testing into the development lifecycle."
            ],
            "content": {
                "overview": "Automated security scanners are essential, but they don't find everything. A mature secure development program also includes a robust strategy for writing specific tests that validate security controls and uncover deeper vulnerabilities. This lesson covers advanced testing strategies that developers can use to build a comprehensive security safety net.",
                "sections": [
                    {
                        "title": "Unit and Integration Testing for Security",
                        "content": "<p>Developers can and should write their own tests for security functionality, just as they do for business logic.</p><h3>Examples:</h3><ul><li><strong>Security Unit Test:</strong> A unit test for an input validation function that asserts that it correctly rejects a known malicious payload (e.g., an XSS string).</li><li><strong>Security Integration Test:</strong> An integration test for an API endpoint that asserts that a user with the 'viewer' role receives a '403 Forbidden' error when they try to call an admin-only endpoint. This type of test is crucial for preventing Broken Access Control flaws.</li></ul><p>These tests run on every single build, providing a continuous and fast check that core security controls are working as expected.</p>",
                        "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Fuzzing and Chaos Engineering",
                        "content": "<h3>Fuzzing (Fuzz Testing):</h3><p>Fuzzing is an automated testing technique that involves providing invalid, unexpected, or random data as input to a program. It is an extremely effective way to find memory corruption bugs, unhandled exceptions, and denial-of-service vulnerabilities. The fuzzer will bombard an input field or API endpoint with millions of malformed inputs and watch for crashes.</p><h3>Chaos Engineering for Security:</h3><p>Chaos engineering is the practice of intentionally injecting failures into a system to test its resilience. From a security perspective, this can be used to test the resilience of your security controls. For example, what happens if your authentication service goes down? Does your application fail securely, or does it fail open?</p>",
                        "image": "https://images.unsplash.com/photo-1588665387928-a8d2a13f8373?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Security Regression Testing",
                        "content": "<p>A security regression is when a code change accidentally re-introduces a vulnerability that had been previously fixed. A suite of automated security tests is the best defense.</p><h3>The Process:</h3><p>Whenever a security vulnerability is found and fixed, the developer should also write a new, specific, automated test case that proves the vulnerability exists. Initially, this test will fail on the old code. After the fix is applied, the test should pass. This new test is then added to the regression suite. Now, if any future change ever breaks the fix, this automated test will fail, immediately alerting the team to the regression.</p>",
                        "image": "https://images.unsplash.com/photo-1542382257-80deda0e5d99?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Penetration Testing Integration",
                        "content": "<p>A penetration test (or pen test) is a manual, human-driven test where an ethical hacker attempts to find and exploit vulnerabilities in your application. While automated tools are good at finding common flaws, a skilled human tester is much better at finding complex business logic flaws and chaining multiple, low-severity vulnerabilities together into a critical exploit.</p><p>Penetration tests should be performed regularly (e.g., annually or after a major new release) on high-risk applications as a complement to, not a replacement for, automated pipeline scanning.</p>",
                        "image": "https://images.unsplash.com/photo-1555949963-aa79dcee981c?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 21: Comprehensive Security Testing Suite",
                        "language": "python",
                        "code": "# Example of a security integration test for an API\n# This test validates the Broken Access Control fix from Lab 6.\n\nimport pytest\n\ndef test_admin_endpoint_is_protected():\n    # 1. Get a token for a non-admin user\n    viewer_token = get_auth_token('viewer', 'password')\n    viewer_headers = {'Authorization': f'Bearer {viewer_token}'}\n\n    # 2. As the non-admin user, try to call the admin endpoint\n    response = requests.post('http://test-api/admin/delete-user', headers=viewer_headers)\n\n    # 3. Assert that the request was forbidden\n    assert response.status_code == 403\n\n\ndef test_admin_endpoint_is_accessible_by_admin():\n    # 1. Get a token for an admin user\n    admin_token = get_auth_token('admin', 'password')\n    admin_headers = {'Authorization': f'Bearer {admin_token}'}\n\n    # 2. As the admin user, call the endpoint\n    response = requests.post('http://test-api/admin/delete-user', headers=admin_headers)\n\n    # 3. Assert that the request was successful\n    assert response.status_code == 200"
                    },
                    {
                        "title": "Code Example 21: Automated Security Test Framework",
                        "language": "java",
                        "code": "// Example of a security regression test for a fixed vulnerability\n\n// A vulnerability was found where providing a negative number for a quantity\n// resulted in an inventory management issue.\n\n@Test\nvoid testUpdateQuantity_disallowsNegativeNumbers() {\n    // This test is added to the regression suite after the bug is fixed.\n    // If a future code change accidentally removes the validation check,\n    // this test will fail, preventing the regression.\n    assertThrows(IllegalArgumentException.class, () -> {\n        inventoryController.updateQuantity(\"product-123\", -5);\n    });\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "A test written by a developer to assert that an API endpoint correctly returns a '403 Forbidden' for a user with the wrong role is a:",
                        "options": [
                            "Security Unit Test",
                            "Security Integration Test",
                            "Penetration Test",
                            "Fuzz Test"
                        ],
                        "correct": 1,
                        "explanation": "This is an integration test because it is testing the integration of several components: the API endpoint, the authentication system, and the authorization logic. These types of tests are a powerful way for developers to validate their access controls."
                    },
                    {
                        "id": 2,
                        "question": "The automated testing technique that involves sending millions of random or malformed inputs to an application to look for crashes is known as:",
                        "options": [
                            "Fuzzing",
                            "Unit Testing",
                            "Regression Testing",
                            "Static Analysis"
                        ],
                        "correct": 0,
                        "explanation": "Fuzzing is a highly effective, dynamic testing technique for finding bugs like buffer overflows and unhandled exceptions that can lead to denial of service or code execution."
                    },
                    {
                        "id": 3,
                        "question": "What is a security regression?",
                        "options": [
                            "A new security feature.",
                            "When a code change accidentally breaks a previously fixed security control.",
                            "A successful penetration test.",
                            "A type of cryptography."
                        ],
                        "correct": 1,
                        "explanation": "Regressions are common in complex systems. A comprehensive suite of automated security tests is the best defense to ensure that a vulnerability, once fixed, stays fixed."
                    },
                    {
                        "id": 4,
                        "question": "What is the primary advantage of a manual penetration test over automated scanning tools?",
                        "options": [
                            "It is much faster and cheaper.",
                            "A skilled human tester can find complex business logic flaws and chain together multiple vulnerabilities in ways that automated tools cannot.",
                            "It can be run on every single code commit.",
                            "It finds fewer vulnerabilities."
                        ],
                        "correct": 1,
                        "explanation": "Automated tools are great at finding common, known vulnerability patterns. However, they lack the context and creativity of a human attacker, who can understand the business logic of an application and find much more subtle and complex flaws."
                    }
                ]
            }
        },
        {
            "id": "lesson-22",
            "title": "Vulnerability Assessment and Management",
            "duration": "90 min",
            "objectives": [
                "Understand the developer's role in the enterprise vulnerability management process.",
                "Learn to triage and prioritize vulnerabilities based on risk.",
                "Develop strategies for managing and reducing false positives.",
                "Effectively communicate the status and risk of vulnerabilities."
            ],
            "content": {
                "overview": "Finding vulnerabilities is only half the battle; they must also be tracked, prioritized, and fixed. This lesson covers the vulnerability management lifecycle from a developer's perspective, focusing on how to work effectively with security teams and automated tools to manage and remediate vulnerabilities in your code and dependencies.",
                "sections": [
                    {
                        "title": "Vulnerability Scanning Integration",
                        "content": "<p>As a developer, you will interact with vulnerabilities discovered by a variety of automated tools.</p><h3>The Flow of Findings:</h3><ol><li>An automated scanner (SAST, DAST, SCA, etc.) integrated into the CI/CD pipeline discovers a potential vulnerability.</li><li>The finding is sent to a centralized vulnerability management platform.</li><li>The platform de-duplicates the finding (if multiple tools found the same issue) and enriches it with context (e.g., asset criticality).</li><li>A ticket is automatically created in the development team's backlog (e.g., Jira), with all the relevant details about the flaw and how to fix it.</li></ol>",
                        "image": "https://images.unsplash.com/photo-1542382257-80deda0e5d99?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Risk-Based Vulnerability Prioritization",
                        "content": "<p>A scanner might produce hundreds of findings. It's impossible to fix everything at once. As a developer, you need to work with your security champion and the security team to prioritize based on risk.</p><h3>The Prioritization Matrix:</h3><ul><li><strong>Severity:</strong> How technically severe is the flaw? (e.g., CVSS score).</li><li><strong>Exploitability:</strong> Is there a known public exploit? Is the vulnerable code reachable?</li><li><strong>Impact:</strong> What is the business impact if this flaw is exploited? (e.g., is it in a critical, internet-facing payment application or a non-critical internal tool?).</li></ul><p>The goal is to fix the highest-risk vulnerabilities first.</p>",
                        "image": "https://images.unsplash.com/photo-1600880292210-859bb1fed5b1?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "False Positive Management",
                        "content": "<p>Especially with SAST tools, you will encounter findings that are not real, exploitable vulnerabilities in the context of your application. These are false positives.</p><h3>The Triage Process:</h3><p>When you receive a vulnerability ticket, your first step is to validate it.</p><ol><li>Understand the finding.</li><li>Analyze your code and the context.</li><li>If you believe it is a false positive, you must formally document why.</li><li>Work with your security champion to mark the finding as a false positive in the vulnerability management tool.</li></ol><p>This is crucial for tuning the scanner and preventing the same false positive from being reported in every subsequent scan.</p>",
                        "image": "https://images.unsplash.com/photo-1555099962-4199c345e546?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Remediation Workflow Automation",
                        "content": "<p>The goal is to make fixing vulnerabilities as easy as possible.</p><ul><li><strong>Clear Guidance:</strong> A good vulnerability finding should include clear and concise guidance on how to fix the issue, often with secure code examples.</li><li><strong>Automated Pull Requests:</strong> For dependency vulnerabilities, modern SCA tools can automatically create a pull request to update the library, which the developer just needs to test and merge.</li><li><strong>SLAs:</strong> Your organization will have Service Level Agreements (SLAs) for fixing vulnerabilities (e.g., 'Critical vulnerabilities must be fixed within 15 days'). It's your responsibility to meet these SLAs for your applications.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 22: Vulnerability Management Platform",
                        "language": "markdown",
                        "code": "# Example Vulnerability Ticket in Jira\n\n**ID:** PROJ-5678\n**Type:** Security Bug\n**Priority:** High\n**SLA:** 30 Days\n\n**Summary:** [SAST] Stored Cross-Site Scripting in User Profile Page\n\n**Description:**\nThe SAST scanner has identified a potential Stored XSS vulnerability in `ProfileController.java` on line 82.\n\n- **Source:** User input from the `bio` field.\n- **Sink:** The `bio` field is rendered directly into the user profile HTML without proper output encoding.\n\n**Link to Finding:** `https://sast-tool.example.com/findings/12345`\n\n**Recommendation:**\nEnsure that all user-supplied data is contextually encoded before being rendered in the view. Use the approved enterprise `HtmlEncoder.encode()` utility.\n\n**Assignee:** @current_developer"
                    },
                    {
                        "title": "Code Example 22: Intelligent Vulnerability Prioritization System",
                        "language": "json",
                        "code": "{\n  \"vulnerabilityId\": \"CVE-2025-2222\",\n  \"cvssScore\": 7.5,\n  \"hasPublicExploit\": false,\n  \"isReachable\": true,\n  \"asset\": {\n    \"name\": \"internal-reporting-tool\",\n    \"businessCriticality\": \"LOW\",\n    \"isInternetFacing\": false\n  },\n  \"calculatedRiskScore\": 4.5, // Lowered due to low business criticality\n  \"priority\": \"Medium\",\n  \"slaDays\": 90\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "In a mature DevSecOps program, how does a developer typically get notified of a new vulnerability in their code?",
                        "options": [
                            "Through an angry email from the security team a month after they wrote the code.",
                            "They are expected to find it themselves.",
                            "An automated ticket is created in their team's backlog (e.g., Jira) with all the details from the scanner.",
                            "They read about it in the company newsletter."
                        ],
                        "correct": 2,
                        "explanation": "Automation and integration are key. The process should be seamless, with findings being delivered directly into the developer's existing workflow (their backlog) in a timely and actionable manner."
                    },
                    {
                        "id": 2,
                        "question": "A vulnerability has a CVSS score of 9.8 (Critical), but it is in an internal, non-critical application and there is no known public exploit for it. This is an example of what process?",
                        "options": [
                            "Risk-Based Prioritization",
                            "Ignoring the vulnerability",
                            "Accepting the risk",
                            "Remediation"
                        ],
                        "correct": 0,
                        "explanation": "Risk-based prioritization looks beyond just the technical severity (the CVSS score) to consider the real-world context. In this case, the low business impact and lack of an exploit would likely lower its priority compared to a less severe vulnerability on a critical, internet-facing system."
                    },
                    {
                        "id": 3,
                        "question": "What is the developer's responsibility when they believe a finding from a SAST tool is a false positive?",
                        "options": [
                            "To simply ignore the ticket and hope it goes away.",
                            "To formally document their analysis and work with the security team to mark it as a false positive in the tool.",
                            "To disable the SAST tool for their project.",
                            "To fix the code even though it's not a real bug."
                        ],
                        "correct": 1,
                        "explanation": "Managing false positives is a shared responsibility. By formally marking a finding as a false positive, the developer helps to tune the tool, which improves the quality of the results for everyone."
                    },
                    {
                        "id": 4,
                        "question": "A defined timeline, such as 'Critical vulnerabilities must be fixed within 15 days', is known as a:",
                        "options": [
                            "Service Level Agreement (SLA)",
                            "Pull Request",
                            "Threat Model",
                            "False Positive"
                        ],
                        "correct": 0,
                        "explanation": "SLAs (or Service Level Objectives - SLOs) are a key governance mechanism for a vulnerability management program. They create a clear, measurable expectation for how quickly the organization will remediate vulnerabilities based on their risk level."
                    }
                ]
            }
        },
        {
            "id": "lesson-23",
            "title": "Incident Response for Development Teams",
            "duration": "90 min",
            "objectives": [
                "Understand the developer's critical role during a security incident.",
                "Learn the process for investigating code-related incidents.",
                "Develop a strategy for creating and deploying emergency patches.",
                "Participate effectively in a blameless post-incident analysis."
            ],
            "content": {
                "overview": "When a security incident occurs in a production application, the development team is a critical part of the response. Your deep knowledge of the code and the system is essential for understanding the root cause, developing a fix, and getting the system back online securely. This lesson covers what developers need to know to be effective partners in an incident response.",
                "sections": [
                    {
                        "title": "Developer Incident Response Procedures",
                        "content": "<p>During an incident, the Security Operations Center (SOC) or the Incident Response (IR) team will lead the response. As a developer on the affected application's team, you will be called in as a subject matter expert.</p><h3>Your Role:</h3><ul><li><strong>Be Available:</strong> Respond quickly when the IR team reaches out.</li><li><strong>Provide Context:</strong> Help the IR team understand the application's architecture, data flows, and recent changes.</li><li><strong>Analyze Code:</strong> Work with the IR team to analyze the code to find the root cause of the vulnerability being exploited.</li><li><strong>Develop a Fix:</strong> Once the root cause is found, your primary job is to develop, test, and deploy a secure patch.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Emergency Patching Processes",
                        "content": "<p>Fixing a vulnerability during an active incident requires a special, expedited process. You cannot wait for the normal two-week sprint cycle.</p><h3>The 'Break-Glass' Pipeline:</h3><p>Most organizations have an emergency 'hotfix' process. This often involves:</p><ol><li>Creating a new branch from the current production code.</li><li>Developing the fix and having it rapidly peer-reviewed by another senior developer and a security engineer.</li><li>Running the fix through an accelerated, but still automated, CI/CD pipeline.</li><li>Deploying the patch to production as quickly as possible.</li></ol><p>The key is to balance speed with safety. The process must be fast, but it must still include automated testing and a code review to ensure the fix doesn't introduce new bugs.</p>",
                        "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Post-Incident Code Analysis",
                        "content": "<p>After the incident is contained, the work is not over. The development team is responsible for a deeper analysis.</p><h3>Key Questions:</h3><ul><li>Was this vulnerability a one-off mistake, or is it a systemic pattern in our codebase?</li><li>Do we have other, similar vulnerabilities in other parts of the application?</li><li>How did this vulnerability get through our existing automated scanners and testing?</li><li>What new automated test case can we add to our regression suite to prevent this specific bug from ever happening again?</li></ul>",
                        "image": "https://images.unsplash.com/photo-1555099962-4199c345e546?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Lessons Learned Integration",
                        "content": "<p>The output of the post-incident analysis is a set of 'lessons learned'. The most important part of the entire IR process is to turn these lessons into concrete action items that are tracked to completion.</p><p>As a developer, you will be the owner of many of these action items, such as refactoring a risky part of the code, adding new security tests, or updating the team's secure coding checklist. This is the feedback loop that makes the entire system more resilient over time.</p>",
                        "image": "https://images.unsplash.com/photo-1552664730-d307ca884978?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 23: Developer Incident Response Simulator",
                        "language": "markdown",
                        "code": "# Simulated Incident Timeline (Developer's View)\n\n- **14:00:** Paged by on-call system: 'P1 Incident - Potential SQL Injection on `webapp-prod`.'\n- **14:02:** Join the incident response 'war room' (Slack channel/Zoom).\n- **14:05:** SOC provides the attacker's source IP and the suspicious URL they are requesting.\n- **14:15:** As the lead developer, you identify the vulnerable code in the `ProductSearch` controller.\n- **14:30:** You work with the SOC to implement a temporary block by creating a WAF rule for the malicious pattern.\n- **14:45:** You start developing a proper code fix using parameterized queries.\n- **15:30:** The code fix is complete and has been peer-reviewed.\n- **15:45:** The fix is deployed to production via the emergency hotfix pipeline.\n- **16:00:** The SOC confirms that the attacker's exploit is no longer working.\n- **16:15:** The incident is declared resolved. A post-mortem is scheduled for the next day."
                    },
                    {
                        "title": "Code Example 23: Automated Incident Response Framework",
                        "language": "java",
                        "code": "// Action Item from a Post-Mortem: Add a security regression test\n\n@Test\nvoid testSearchForProducts_isNotVulnerableToSqlInjection() {\n    // This is the specific malicious input that the attacker used during the incident.\n    String maliciousSearchTerm = \"' OR 1=1; --\";\n    \n    // This test will now run on every single build.\n    // If a future developer accidentally re-introduces the string concatenation bug,\n    // this test will fail, and the build will break, preventing the regression.\n    assertDoesNotThrow(() -> {\n        productController.searchForProducts(maliciousSearchTerm);\n    });\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary role of a developer during a security incident involving their application?",
                        "options": [
                            "To lead the entire incident response effort.",
                            "To act as a subject matter expert on the code, help find the root cause, and develop a secure fix.",
                            "To talk to the legal and PR teams.",
                            "To do nothing unless explicitly told."
                        ],
                        "correct": 1,
                        "explanation": "The IR team leads the overall response, but they are not experts in your application's code. Your role as a developer is to provide that critical expertise to help the investigation and to build the patch."
                    },
                    {
                        "id": 2,
                        "question": "An expedited CI/CD pipeline used to deploy a critical security fix to production is often called a:",
                        "options": [
                            "Standard development pipeline",
                            "Hotfix or emergency pipeline",
                            "QA pipeline",
                            "Manual deployment process"
                        ],
                        "correct": 1,
                        "explanation": "A hotfix pipeline is a special, faster path to production that is reserved for critical, emergency fixes. It must still contain automated checks, but may bypass longer-running tests for the sake of speed."
                    },
                    {
                        "id": 3,
                        "question": "The primary goal of a blameless post-incident analysis is to:",
                        "options": [
                            "Find the person responsible and punish them.",
                            "Understand the systemic failures in process and technology that allowed the incident to happen, and create action items to fix them.",
                            "Write a report that can be filed away and never looked at again.",
                            "Decide on a new programming language to use."
                        ],
                        "correct": 1,
                        "explanation": "A blameless culture is essential. The goal is to learn from the failure to make the system stronger, not to punish individuals, which would discourage people from reporting issues in the future."
                    },
                    {
                        "id": 4,
                        "question": "After a vulnerability is discovered and fixed in production, what is the most important follow-up action for a developer?",
                        "options": [
                            "To forget about it and move on to the next feature.",
                            "To write a new, automated security regression test to ensure that specific vulnerability can never be re-introduced.",
                            "To manually check for the vulnerability every week.",
                            "To blame the QA team for not finding it."
                        ],
                        "correct": 1,
                        "explanation": "This is the crucial feedback loop of DevSecOps. The knowledge gained from the incident is encoded into an automated test, which permanently raises the security baseline of the application."
                    }
                ]
            }
        },
        {
            "id": "lesson-24",
            "title": "Compliance and Regulatory Requirements",
            "duration": "90 min",
            "objectives": [
                "Understand how major regulations like GDPR, HIPAA, and PCI DSS impact software development.",
                "Learn to translate regulatory requirements into technical controls.",
                "Implement Privacy by Design principles to meet regulations like GDPR.",
                "Automate evidence collection to simplify compliance audits."
            ],
            "content": {
                "overview": "For many developers, compliance is a scary word associated with auditors and spreadsheets. However, modern compliance can be managed through the same 'as-code' and automation principles that drive the rest of DevSecOps. This lesson demystifies key regulations and shows how developers can build applications that are 'compliant by design'.",
                "sections": [
                    {
                        "title": "GDPR Compliance in Software Development",
                        "content": "<p>The General Data Protection Regulation (GDPR) is a European privacy law that has a global impact. It establishes strict rules for handling the personal data of EU citizens.</p><h3>Key Principles for Developers:</h3><ul><li><strong>Privacy by Design:</strong> Build privacy into the application from the start.</li><li><strong>Data Minimization:</strong> Collect only the data you absolutely need.</li><li><strong>Purpose Limitation:</strong> Only use data for the specific purpose you told the user about.</li><li><strong>Right to Erasure:</strong> You must have a technical way to securely and completely delete a specific user's data if they request it. This has significant architectural implications.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1590102426319-c72115b5a832?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "HIPAA Requirements for Healthcare Apps",
                        "content": "<p>The Health Insurance Portability and Accountability Act (HIPAA) governs the security and privacy of Protected Health Information (PHI) in the United States.</p><h3>Key Technical Safeguards for Developers:</h3><ul><li><strong>Access Control:</strong> You must implement unique user identification and role-based access control to enforce least privilege.</li><li><strong>Audit Controls:</strong> The application must generate a detailed, immutable audit trail of all actions that create, read, update, or delete PHI.</li><li><strong>Integrity:</strong> You must have controls to ensure that PHI is not improperly altered or destroyed.</li><li><strong>Transmission Security:</strong> All PHI must be encrypted in transit over any open network.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1533285809283-0a7c6177ac43?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "PCI DSS for Payment Applications",
                        "content": "<p>The Payment Card Industry Data Security Standard (PCI DSS) is a highly prescriptive set of requirements for any application that stores, processes, or transmits cardholder data.</p><h3>Key Development Requirements (from Requirement 6):</h3><ul><li>Develop applications based on secure coding guidelines.</li><li>Train developers in secure coding techniques.</li><li>Implement a code review process.</li><li>Protect applications from common vulnerabilities (like those in the OWASP Top 10).</li><li>Use a change control process for all code changes.</li></ul><p>A mature DevSecOps pipeline with integrated SAST/DAST/SCA and peer reviews directly helps to satisfy these requirements.</p>",
                        "image": "https://images.unsplash.com/photo-1567427018141-0584cfcbf1b8?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 24: Compliance Validation Platform",
                        "language": "ruby",
                        "code": "# Example of a Compliance as Code test using InSpec for HIPAA\n\n# This test automatically checks that a server's audit logging is correctly configured.\n\ncontrol 'hipaa-audit-control-1' do\n  impact 1.0\n  title 'Ensure audit logging service is running'\n  desc 'HIPAA requires audit controls to record and examine activity.'\n\n  describe service('auditd') do\n    it { should be_installed }\n    it { should be_enabled }\n    it { should be_running }\n  end\nend\n\ncontrol 'hipaa-audit-control-2' do\n  impact 1.0\n  title 'Ensure audit rules are immutable'\n  desc 'Prevents an attacker from modifying the audit rules to cover their tracks.'\n\n  describe auditd_conf do\n    its('immutable') { should eq 'yes' }\n  end\nend"
                    },
                    {
                        "title": "Code Example 24: Automated Compliance Checking Framework",
                        "language": "markdown",
                        "code": "# Translating a GDPR Requirement to a Developer Task\n\n- **GDPR Article 17 (Right to Erasure):** \"The data subject shall have the right to obtain from the controller the erasure of personal data concerning him or her without undue delay...\"\n\n- **Product Requirement:** As a user, I want a 'Delete My Account' button in my profile settings.\n\n- **Developer Implementation Tasks:**\n  1.  Create an API endpoint `DELETE /users/me`.\n  2.  The business logic for this endpoint must:\n      - Anonymize the user's record in the `users` table.\n      - Find and delete all of the user's related data in the `orders`, `sessions`, and `support_tickets` tables.\n      - Call the marketing service's API to remove the user from all mailing lists.\n  3.  Write an integration test to verify that after calling the endpoint, all of the user's data is verifiably gone."
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "The GDPR principle that requires you to be able to completely and securely delete a user's data upon request is known as:",
                        "options": [
                            "Data Minimization",
                            "Purpose Limitation",
                            "The Right to Erasure",
                            "Data Encryption"
                        ],
                        "correct": 2,
                        "explanation": "The 'Right to be Forgotten' or 'Right to Erasure' is a key part of GDPR and has significant implications for how developers must design their application's data models and business logic."
                    },
                    {
                        "id": 2,
                        "question": "Integrating automated security scanning tools (SAST/DAST/SCA) into your CI/CD pipeline is a key technical control for meeting which compliance standard?",
                        "options": [
                            "HIPAA",
                            "GDPR",
                            "PCI DSS",
                            "All of the above"
                        ],
                        "correct": 2,
                        "explanation": "PCI DSS Requirement 6 is very specific about the need for a secure software development lifecycle, including protecting applications from common vulnerabilities. A DevSecOps pipeline is a perfect way to meet these requirements."
                    },
                    {
                        "id": 3,
                        "question": "The practice of defining compliance checks as automated, version-controlled tests is known as:",
                        "options": [
                            "Manual Auditing",
                            "Compliance as Code",
                            "A Security Policy",
                            "Penetration Testing"
                        ],
                        "correct": 1,
                        "explanation": "Compliance as Code applies the principles of DevOps and automation to compliance, transforming it from a manual, periodic activity into a continuous and automated part of the development lifecycle."
                    },
                    {
                        "id": 4,
                        "question": "Which privacy principle dictates that you should only collect the absolute minimum amount of personal data required for a specific function?",
                        "options": [
                            "Data Minimization",
                            "Data Hoarding",
                            "Data Retention",
                            "Data Encryption"
                        ],
                        "correct": 0,
                        "explanation": "Data minimization is a core principle of Privacy by Design and GDPR. It's a powerful way to reduce risk; you can't leak data that you don't have."
                    }
                ]
            }
        },
        {
            "id": "lesson-25",
            "title": "Security Architecture and Design Patterns",
            "duration": "90 min",
            "objectives": [
                "Understand the role of a security architect and their interaction with developers.",
                "Learn to consume and apply pre-approved secure design patterns.",
                "Identify common insecure architectural 'anti-patterns'.",
                "Participate effectively in a security architecture review process."
            ],
            "content": {
                "overview": "While developers are responsible for the security of their code, the security architecture team is responsible for designing the secure 'paved road' that makes it easy for developers to build secure applications. This lesson covers how developers can effectively partner with security architects by understanding and using secure design patterns.",
                "sections": [
                    {
                        "title": "Secure Architecture Patterns Library",
                        "content": "<p>A design pattern is a reusable, documented solution to a commonly occurring problem. A security architecture team will often create a library of pre-approved, secure design patterns for developers to use.</p><h3>Example Pattern: 'Secure Public API'</h3><p>Instead of each developer figuring out how to secure their API, they can use the standard pattern, which might mandate:</p><ul><li>Deployment behind the central API Gateway.</li><li>Authentication using the central IdP with OAuth 2.0.</li><li>Standard rate-limiting policies.</li><li>Centralized logging configuration.</li></ul><p>Using these patterns accelerates development and ensures a consistent security posture.</p>",
                        "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Anti-Pattern Identification",
                        "content": "<p>An anti-pattern is a common response to a problem that is ineffective and may be counterproductive. Learning to recognize security anti-patterns is a key skill.</p><h3>Common Security Anti-Patterns:</h3><ul><li><strong>Hard-coding Secrets:</strong> Storing passwords or API keys in code or config files instead of using a vault.</li><li><strong>The 'Fat' Service Account:</strong> Creating a single, overly permissive service account that is used by multiple applications.</li><li><strong>Security Through Obscurity:</strong> Assuming an internal API is safe because it's not documented publicly.</li><li><strong>Rolling Your Own Crypto:</strong> Trying to invent a new encryption algorithm.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1555099962-4199c345e546?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Architecture Security Review Processes",
                        "content": "<p>For a new, high-risk application or a major change to an existing one, you will likely participate in a security architecture review. This is a collaborative process, not a judgmental one.</p><h3>Your Role as a Developer:</h3><ul><li>Come prepared with a clear diagram of your proposed design (e.g., a DFD).</li><li>Be able to explain your design choices and how you are meeting the standard security patterns.</li><li>Be open to feedback. The goal is to work together with the architect to find and fix design flaws before they become code.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1552664730-d307ca884978?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 25: Security Pattern Implementation Workshop",
                        "language": "markdown",
                        "code": "# Design Document for a New Microservice\n\n**Service Name:** `user-profile-service`\n\n**Security Patterns Applied:**\n\n1.  **Pattern:** `Secure Public API`\n    - **Implementation:** The service will be deployed behind the enterprise API Gateway. It will be configured to require a valid JWT access token from our central Okta IdP.\n\n2.  **Pattern:** `Least Privilege Service Account (Database)`\n    - **Implementation:** The service will have its own dedicated database user. The user will only be granted `SELECT`, `INSERT`, and `UPDATE` permissions on the `profiles` table. `DELETE` permissions will not be granted.\n\n3.  **Pattern:** `Centralized Logging`\n    - **Implementation:** The service will use the standard corporate logging library, which is configured to ship structured JSON logs to the central Splunk instance."
                    },
                    {
                        "title": "Code Example 25: Security Architecture Validation Tool",
                        "language": "python",
                        "code": "# Conceptual script to check for an anti-pattern (hard-coded secrets)\n\nimport re\n\n# A very basic regex to look for something that looks like an AWS key\nAWS_KEY_PATTERN = re.compile(r'(?<![A-Z0-9])[A-Z0-9]{20}(?![A-Z0-9])')\n\ndef check_for_hardcoded_keys(file_content):\n    if AWS_KEY_PATTERN.search(file_content):\n        return True\n    return False\n\n# This kind of check would be run by a pre-commit hook or a specialized secret scanner."
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "A reusable, documented, and pre-approved solution to a common security problem, such as how to secure a public API, is known as a:",
                        "options": [
                            "Security Design Pattern",
                            "Security Anti-Pattern",
                            "Vulnerability",
                            "Security Incident"
                        ],
                        "correct": 0,
                        "explanation": "Security design patterns are a key tool for scaling security. They provide developers with a secure, repeatable 'paved road' for common architectural challenges."
                    },
                    {
                        "id": 2,
                        "question": "Storing a database password directly in a source code file is an example of what?",
                        "options": [
                            "A secure design pattern.",
                            "A security anti-pattern (Hard-coding Secrets).",
                            "A best practice.",
                            "A compliance requirement."
                        ],
                        "correct": 1,
                        "explanation": "Hard-coding secrets is one of the most common and dangerous anti-patterns. It makes secrets very difficult to manage and rotate, and they can be easily exposed if the source code is ever leaked."
                    },
                    {
                        "id": 3,
                        "question": "What is the primary goal of a security architecture review?",
                        "options": [
                            "To blame developers for bad designs.",
                            "To slow down the development process.",
                            "A collaborative process to identify and fix security flaws in the design before they are implemented in code.",
                            "To manually approve every line of code."
                        ],
                        "correct": 2,
                        "explanation": "A successful architecture review is a collaborative partnership between the development team and the security team. The goal is to work together to build a more secure and resilient system."
                    },
                    {
                        "id": 4,
                        "question": "The security anti-pattern of assuming an internal system is safe just because it is not on the public internet is known as:",
                        "options": [
                            "Defense in Depth",
                            "Zero Trust",
                            "Security Through Obscurity",
                            "Least Privilege"
                        ],
                        "correct": 2,
                        "explanation": "This is a classic anti-pattern that violates the 'assume breach' principle of Zero Trust. Attackers are very skilled at finding and moving laterally to internal systems once they gain an initial foothold."
                    }
                ]
            }
        },
        {
            "id": "lesson-26",
            "title": "Performance and Security Balance",
            "duration": "90 min",
            "objectives": [
                "Understand the potential performance impact of security controls.",
                "Learn to tune encryption and hashing for optimal performance.",
                "Analyze the performance overhead of security monitoring agents.",
                "Make risk-based decisions when performance and security conflict."
            ],
            "content": {
                "overview": "As a developer, you are often judged on the performance and responsiveness of your application. It's a common concern that adding security controls will slow things down. This lesson covers how to implement strong security without sacrificing performance, and how to make intelligent, risk-based trade-offs when a conflict arises.",
                "sections": [
                    {
                        "title": "Security Performance Optimization",
                        "content": "<p>Many security controls have a negligible performance impact, but some, especially those involving cryptography or real-time inspection, need to be implemented carefully.</p><h3>Areas of Focus:</h3><ul><li><strong>Cryptography:</strong> Modern CPUs have hardware acceleration (AES-NI) for common algorithms like AES. This makes the performance impact of encryption at rest almost zero for most applications.</li><li><strong>Password Hashing:</strong> Slow, memory-hard algorithms like Argon2 are *designed* to be slow to make them resistant to cracking. This is intentional. However, this hashing should be done on an asynchronous background thread so it doesn't block the main login request thread.</li><li><strong>Input Validation:</strong> Well-written validation logic has a minimal performance impact.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1542382257-80deda0e5d99?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Load Balancing and Caching Security",
                        "content": "<p>Load balancing and caching are key performance patterns, but they have security implications.</p><h3>Considerations:</h3><ul><li><strong>TLS Termination:</strong> Terminating TLS at the load balancer is common for performance reasons. However, this means the traffic from the load balancer to the backend web server is unencrypted. In a Zero Trust architecture, it is better to re-encrypt this traffic.</li><li><strong>Caching Sensitive Data:</strong> Caching is great for performance, but you must have a clear policy to prevent sensitive, user-specific data from being stored in a shared cache where it could be served to another user.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1593441139884-faf2c88c7c97?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Security Monitoring Overhead",
                        "content": "<p>Security agents (like IAST, RASP, or EDR agents) run alongside your application and do consume some CPU and memory. This overhead is usually small (e.g., 2-5%), but it must be accounted for in your performance testing and capacity planning. The visibility and protection these agents provide is almost always worth the small performance cost.</p>",
                        "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 26: Security Performance Optimization Lab",
                        "language": "java",
                        "code": "// Example of offloading a slow security operation (password hashing)\n// to a background thread pool in a Java application.\n\n@Service\npublic class AuthenticationService {\n\n    // Use a dedicated thread pool for CPU-intensive hashing work.\n    private final ExecutorService hashingExecutor = Executors.newFixedThreadPool(4);\n    private final PasswordEncoder passwordEncoder = new BCryptPasswordEncoder();\n\n    public CompletableFuture<Boolean> checkPasswordAsync(String rawPassword, String encodedPassword) {\n        // Submit the slow, blocking check to the background thread pool.\n        return CompletableFuture.supplyAsync(() -> {\n            return passwordEncoder.matches(rawPassword, encodedPassword);\n        }, hashingExecutor);\n    }\n}"
                    },
                    {
                        "title": "Code Example 26: Performance-Aware Security Framework",
                        "language": "nginx",
                        "code": "# Example NGINX config for a secure cache\n\nproxy_cache_path /var/cache/nginx levels=1:2 keys_zone=my_cache:10m;\n\nserver {\n    # ... server config ...\n\n    location / {\n        # By default, do not cache responses\n        proxy_no_cache 1;\n        # Explicitly ignore headers that would allow caching of private data\n        proxy_ignore_headers \"Set-Cookie\";\n        proxy_hide_header \"Set-Cookie\";\n        \n        # Only cache responses that have an explicit 'public' cache control header\n        proxy_cache_valid 200 302 10m;\n        proxy_cache_bypass $http_cache_control;\n\n        proxy_pass http://backend;\n    }\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "Modern CPUs have dedicated hardware instructions (AES-NI) that do what?",
                        "options": [
                            "Make AES encryption very slow.",
                            "Make AES encryption very fast, with almost no performance overhead for most applications.",
                            "Make AES encryption insecure.",
                            "Prevent the use of AES encryption."
                        ],
                        "correct": 1,
                        "explanation": "Hardware acceleration has made the performance argument against encrypting data at rest largely obsolete. The performance impact of modern symmetric encryption is negligible for the vast majority of workloads."
                    },
                    {
                        "id": 2,
                        "question": "Password hashing algorithms like Argon2 and bcrypt are intentionally designed to be slow for what reason?",
                        "options": [
                            "To annoy users.",
                            "To make them resistant to offline brute-force cracking attempts by an attacker.",
                            "It is a bug in the algorithm.",
                            "To consume more electricity."
                        ],
                        "correct": 1,
                        "explanation": "The slowness is a critical security feature. It makes it computationally expensive and time-consuming for an attacker who has stolen the password database to run through billions of password guesses to crack the hashes."
                    },
                    {
                        "id": 3,
                        "question": "What is a primary security risk of caching?",
                        "options": [
                            "It makes the application too fast.",
                            "It can improve performance.",
                            "Sensitive, user-specific data could be stored in a shared cache and accidentally served to another user.",
                            "It makes the application too simple."
                        ],
                        "correct": 2,
                        "explanation": "This is a serious information disclosure vulnerability. The application logic and cache configuration must be carefully designed to ensure that only truly public, non-sensitive data is ever cached."
                    },
                    {
                        "id": 4,
                        "question": "What is the best way to handle the small performance overhead of a runtime security agent (like an IAST or EDR agent)?",
                        "options": [
                            "To not use any monitoring agents.",
                            "To accept the overhead as a necessary cost for the significant security visibility and protection it provides, and to account for it in capacity planning.",
                            "To only install it on non-production servers.",
                            "To disable the agent whenever performance is slow."
                        ],
                        "correct": 1,
                        "explanation": "Modern security agents are highly optimized, and their benefits far outweigh their small performance cost. The correct approach is to measure and account for this overhead in your performance tests and resource allocation, just as you would for any other part of your application stack."
                    }
                ]
            }
        },
        {
            "id": "lesson-27",
            "title": "Legacy Code Security",
            "duration": "90 min",
            "objectives": [
                "Understand the security challenges inherent in maintaining legacy codebases.",
                "Develop strategies for incrementally improving the security of a legacy application.",
                "Learn to use 'wrapper-based' security to protect legacy systems from the outside.",
                "Make a risk-based plan for managing the technical debt of legacy code."
            ],
            "content": {
                "overview": "As a developer, you will inevitably have to work with legacy code. These older systems are often critical to the business but can be a minefield of security vulnerabilities, outdated dependencies, and fragile code. This lesson covers pragmatic strategies for managing the risk of legacy code and incrementally improving its security posture.",
                "sections": [
                    {
                        "title": "Legacy Code Vulnerability Assessment",
                        "content": "<p>The first step is to understand the current state of risk. Since you may not be able to easily change the code, your focus is on finding flaws you can mitigate with external controls.</p><h3>The Assessment Process:</h3><ul><li><strong>Dependency Analysis (SCA):</strong> This is often the most important first step. Run an SCA tool to find all the ancient, vulnerable libraries the application is using.</li><li><strong>Dynamic Scanning (DAST):</strong> Run a DAST scan against the running application to find vulnerabilities like XSS and SQLi without touching the code.</li><li><strong>Configuration Review:</strong> Review the configuration of the server and application framework for security best practice violations.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1555099962-4199c345e546?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Wrapper-Based Security Approaches",
                        "content": "<p>If you can't fix the code, you can 'wrap' it in a layer of modern security controls. This is a powerful strategy for reducing the risk of a legacy application.</p><h3>The Wrapper Architecture:</h3><ul><li><strong>Reverse Proxy / WAF:</strong> Place a Web Application Firewall or a modern reverse proxy in front of the legacy app. This can provide a 'virtual patch' against many common vulnerabilities, add modern TLS, and enforce stronger authentication.</li><li><strong>Containerization:</strong> Package the legacy app into a container. This doesn't fix the code, but it provides a consistent deployment model and allows you to use container runtime security tools and network policies to isolate the application.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1517694712202-14dd9538aa97?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Incremental Improvement Strategies",
                        "content": "<p>You don't have to fix everything at once. Focus on incremental, high-impact changes.</p><h3>The 'Strangler Fig' Pattern:</h3><p>This is a popular pattern for modernizing legacy systems. Instead of a big-bang rewrite, you gradually 'strangle' the old monolith by building new features as separate microservices. The wrapper (reverse proxy) is used to route traffic, sending some requests to the old monolith and requests for new features to the new microservices. Over time, more and more functionality is moved out of the monolith until it can finally be decommissioned.</p>",
                        "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 27: Legacy Code Security Assessment",
                        "language": "markdown",
                        "code": "# Risk Mitigation Plan for `legacy-app-v1`\n\n**Key Vulnerability:** The application uses a 10-year-old version of the Struts framework with multiple known RCE vulnerabilities.\n\n**Short-Term Mitigation (Wrapping):**\n1.  **Action:** Place the application behind the corporate WAF.\n2.  **Action:** Create a specific WAF policy with virtual patching rules for the known Struts vulnerabilities.\n3.  **Action:** Place the application server in a highly isolated network segment with strict egress filtering to prevent it from connecting to the internet.\n\n**Long-Term Mitigation (Modernization):**\n1.  **Action:** Prioritize the `legacy-app-v1` for decommissioning.\n2.  **Action:** Initiate a project to replace its functionality using the 'Strangler Fig' pattern, building new microservices to replace its features over the next 18 months."
                    },
                    {
                        "title": "Code Example 27: Legacy System Security Wrapper Framework",
                        "language": "nginx",
                        "code": "# Example of the 'Strangler Fig' pattern using an NGINX reverse proxy\n\nlocation /api/v1/users {\n    # Old, legacy endpoint is still served by the monolith\n    proxy_pass http://legacy_monolith_backend;\n}\n\nlocation /api/v2/users {\n    # The new, rewritten v2 endpoint is routed to the new microservice\n    proxy_pass http://new_user_microservice_backend;\n}\n\nlocation /api/v1/orders {\n    # The new orders feature is handled by a new microservice\n    proxy_pass http://new_orders_microservice_backend;\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the most effective first step in assessing the security of a legacy application?",
                        "options": [
                            "Immediately starting to rewrite the entire application.",
                            "Running automated SCA and DAST scanners against it to get a baseline of its vulnerabilities.",
                            "Assuming it is secure because it is old.",
                            "Deleting the application."
                        ],
                        "correct": 1,
                        "explanation": "Before you can form a strategy, you must understand the current risk. Automated scanning is the fastest and most effective way to get an initial inventory of the most critical vulnerabilities in the application and its dependencies."
                    },
                    {
                        "id": 2,
                        "question": "The strategy of placing a Web Application Firewall (WAF) in front of a legacy application to block known exploits is known as:",
                        "options": [
                            "Wrapping",
                            "Refactoring",
                            "Rewriting",
                            "Decommissioning"
                        ],
                        "correct": 0,
                        "explanation": "Wrapping is a pragmatic strategy that allows you to improve the security of an application from the outside, without touching its fragile internal code. A WAF can provide a 'virtual patch' against many common vulnerability types."
                    },
                    {
                        "id": 3,
                        "question": "The 'Strangler Fig' pattern is a strategy for:",
                        "options": [
                            "Securing a new application.",
                            "Gradually modernizing a legacy monolith by replacing its functionality with new microservices over time.",
                            "Keeping a legacy application running forever without any changes.",
                            "Performing a security code review."
                        ],
                        "correct": 1,
                        "explanation": "The Strangler Fig pattern is a popular and effective approach for incremental modernization. It avoids the high risk of a 'big bang' rewrite by allowing the old and new systems to coexist and gradually migrating functionality."
                    },
                    {
                        "id": 4,
                        "question": "Which of the following is a key security benefit of containerizing a legacy application?",
                        "options": [
                            "It automatically fixes all security bugs in the code.",
                            "It allows you to apply modern security controls like runtime monitoring and network micro-segmentation to the application.",
                            "It makes the application run on older hardware.",
                            "It is not possible to containerize a legacy application."
                        ],
                        "correct": 1,
                        "explanation": "Containerization provides a modern 'wrapper' at the OS level. It allows you to treat the legacy application like any other cloud-native workload, enabling you to apply a consistent set of modern security and operational controls."
                    }
                ]
            }
        },
        {
            "id": "lesson-28",
            "title": "Security Code Review and Analysis",
            "duration": "90 min",
            "objectives": [
                "Understand the value and process of a manual security code review.",
                "Learn to use a security-focused checklist for peer reviews.",
                "Integrate and interpret the results of automated code analysis tools.",
                "Foster a culture of constructive and effective security peer reviews."
            ],
            "content": {
                "overview": "A code review is a standard software quality practice where developers review each other's code. A *security* code review is a specific type of review focused on identifying security vulnerabilities and design flaws. This lesson covers how developers can perform effective security code reviews, blending manual analysis with the results of automated tools.",
                "sections": [
                    {
                        "title": "Manual Code Review Techniques",
                        "content": "<p>While automated SAST tools are great at finding common vulnerability patterns, a human reviewer is much better at finding complex business logic flaws and architectural issues.</p><h3>The Reviewer's Mindset:</h3><ul><li><strong>Think Like an Attacker:</strong> Don't just check if the code works. Ask, 'How could I abuse this feature?'</li><li><strong>Trace Untrusted Data:</strong> Pick an input field and follow the data as it flows through the code. Is it ever used to build a SQL query? Is it ever rendered in the UI without being encoded?</li><li><strong>Check for Missing Defenses:</strong> Look for what's *not* there. Is there a critical function that is missing an authorization check? Is there a sensitive cookie that is missing the `HttpOnly` flag?</li></ul>",
                        "image": "https://images.unsplash.com/photo-1555099962-4199c345e546?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Security-Focused Code Review Checklists",
                        "content": "<p>A checklist can help to structure a code review and ensure that common security issues are not overlooked. The review should focus on the OWASP Top 10.</p><h3>Example Checklist Items for a Pull Request:</h3><ul><li>**Input Validation:** Is all input from external sources validated against a strict allow-list?</li><li>**Access Control:** Does every endpoint that accesses or modifies data have a server-side authorization check?</li><li>**Output Encoding:** Is all data being rendered in the UI contextually encoded to prevent XSS?</li><li>**Cryptography:** Is the application using approved, standard cryptographic libraries? Are there any hard-coded keys?</li><li>**Logging:** Are all security-relevant events (logins, failures, access changes) being logged?</li></ul>",
                        "image": "https://images.unsplash.com/photo-1454165804606-c3d57bc86b40?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Automated Code Analysis Tools",
                        "content": "<p>The manual review should be augmented by the results of automated tools. The CI/CD pipeline should be configured to run a SAST scan on every pull request and post the results as a comment directly on the request.</p><p>This allows the human reviewer to see both the code changes and the automated scanner's findings in a single place. The reviewer can then validate the scanner's findings, saving them time and helping to find issues they might have otherwise missed.</p>",
                        "image": "https://images.unsplash.com/photo-1517694712202-14dd9538aa97?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 28: Security Code Review Platform",
                        "language": "markdown",
                        "code": "# Example of a Security-Focused Pull Request Comment in GitHub\n\n**User @secure-dev commented:**\n\nThanks for the PR! The feature looks great. I have a few security-related comments:\n\n1.  **In `UserController.java`, line 42:**\n    It looks like this new endpoint for fetching a user's profile is missing an authorization check. As written, any authenticated user could request any other user's profile. We need to add a check here to ensure the requesting user's ID matches the ID of the profile being requested (to prevent an IDOR vulnerability).\n\n2.  **In `profile.html`, line 15:**\n    The user's `bio` is being rendered directly to the page. Since this is user-controlled input, it needs to be HTML encoded to prevent Stored XSS. Please use the `th:text` attribute instead of `th:utext` here.\n\nAlso, the automated SAST scanner found a potential medium-severity issue. Could you take a look and see if it's a true positive?"
                    },
                    {
                        "title": "Code Example 28: Intelligent Code Analysis Framework",
                        "language": "plaintext",
                        "code": "/*\n  Conceptual view of a GitHub Pull Request with integrated security feedback\n\n  ----------------------------------------------------------------------\n  Pull Request #123: Add User Profile Bio Feature\n  ----------------------------------------------------------------------\n\n  [ Code Changes Tab ]\n\n  + user_bio = database.get_user_bio(user_id)\n  + return render_template('profile.html', bio=user_bio) // Potential XSS here\n\n  ----------------------------------------------------------------------\n\n  [ Checks Tab ]\n\n  - (SUCCESS) Unit Tests\n  - (FAILURE) SonarQube SAST Scan\n\n  ----------------------------------------------------------------------\n\n  [ Conversation Tab ]\n\n  **SonarQube Bot commented:**\n  > âš ï¸ SAST Scan found 1 new High vulnerability:\n  > **Stored Cross-Site Scripting** in `app.py` on line 75.\n  > Untrusted data from `database.get_user_bio` is rendered in a template without encoding.\n  > [Click here for details]\n\n  **@secure-dev commented:**\n  > Looks like the bot caught this one! Please use the `escape()` function on the `user_bio`\n  > variable before passing it to the template.\n*/"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary advantage of a manual security code review over an automated SAST tool?",
                        "options": [
                            "It is much faster.",
                            "It requires no security knowledge.",
                            "A human reviewer can understand business logic and context to find complex flaws that automated tools miss.",
                            "It finds more low-level, common vulnerability patterns."
                        ],
                        "correct": 2,
                        "explanation": "Automated tools are excellent at finding known, syntax-based vulnerability patterns. However, they struggle with understanding the business logic and context of an application, which is where a skilled human reviewer can find more complex flaws like Broken Access Control."
                    },
                    {
                        "id": 2,
                        "question": "When reviewing a piece of code, the practice of following a piece of user-supplied data from its entry point to where it is used is known as:",
                        "options": [
                            "Unit Testing",
                            "Data Flow Tracing",
                            "Code Commenting",
                            "Refactoring"
                        ],
                        "correct": 1,
                        "explanation": "This is a fundamental technique for manual code review. By tracing untrusted data, you can check for the key vulnerabilities: is it used in a SQL query (risk of SQLi)? Is it rendered in the UI (risk of XSS)? Is it used to build a filename (risk of path traversal)?"
                    },
                    {
                        "id": 3,
                        "question": "How should the results of an automated SAST scan be integrated into the code review process?",
                        "options": [
                            "They should be ignored by the human reviewer.",
                            "They should be sent in a separate email a week later.",
                            "They should be automatically posted as a comment on the pull request, so the reviewer can see the code and the automated findings in one place.",
                            "They should only be visible to the security team."
                        ],
                        "correct": 2,
                        "explanation": "Tight integration is key. By presenting the automated findings directly within the pull request interface, the developer and the reviewer have all the context they need to assess the security of the change in one unified view."
                    },
                    {
                        "id": 4,
                        "question": "A good security code review culture is one that is:",
                        "options": [
                            "Adversarial and focused on blaming individuals.",
                            "Collaborative, constructive, and focused on improving the security of the software.",
                            "Optional and rarely performed.",
                            "Performed only by the most junior developers."
                        ],
                        "correct": 1,
                        "explanation": "Like a blameless post-mortem, a good code review is a learning process. The goal is for the team to work together to produce higher-quality, more secure code. A positive and constructive tone is essential for this."
                    }
                ]
            }
        },
        {
            "id": "lesson-29",
            "title": "Security Training and Culture",
            "duration": "90 min",
            "objectives": [
                "Understand the critical role of a security-aware culture.",
                "Explore effective strategies for developer security training.",
                "Learn how to use gamification to make security engaging.",
                "Design and implement a Security Champions program."
            ],
            "content": {
                "overview": "The most secure code is written by developers who have security at the top of their minds. Technology is only part of the solution; the human element is paramount. This lesson, previously covered in the DevSecOps course, focuses on the essential strategies for building a strong security culture through engaging training, positive reinforcement, and a network of empowered champions.",
                "sections": [
                    {
                        "title": "Developer Security Training Programs",
                        "content": "<p>Annual, generic security awareness training is not effective for developers. Training must be hands-on, relevant, and continuous.</p><h3>Effective Training Models:</h3><ul><li><strong>Contextual Micro-Learning:</strong> Provide short, targeted training modules just-in-time. If a SAST scanner finds a SQLi flaw, the developer should get a link to a 5-minute interactive lab on how to fix that specific issue.</li><li><strong>Hands-On Workshops ('Dojos'):</strong> Run regular, optional workshops where developers can learn about a new attack technique and then practice exploiting and fixing it in a safe, 'capture the flag' (CTF) style environment.</li><li><strong>Secure Coding Standards:</strong> Maintain a clear, concise, and easy-to-use secure coding standard or checklist that is specific to your organization's technology stack.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1516321497487-e288fb19713f?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Gamification of Security Learning",
                        "content": "<p>Gamification applies game mechanics to non-game activities to boost engagement and motivation.</p><h3>Examples for Developers:</h3><ul><li><strong>CTF Tournaments:</strong> Hold company-wide 'capture the flag' events where teams compete to solve security puzzles.</li><li><strong>Bug Bounties:</strong> Reward developers for finding and fixing security bugs, with the reward based on the severity of the bug.</li><li><strong>Leaderboards & Badges:</strong> Publicly recognize developers who complete training, fix the most security bugs, or perform high-quality security code reviews.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1588665387928-a8d2a13f8373?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Security Champion Programs",
                        "content": "<p>A Security Champions program is the most effective way to scale security expertise and build a strong culture. A champion is a developer with an interest in security who acts as the security advocate and primary point of contact for their team.</p><p>The central security team's role is to empower these champions by providing them with advanced training, direct access to security experts, and the tools they need to help their teams. This creates a distributed network of security expertise, embedding security into the fabric of the engineering organization.</p>",
                        "image": "https://images.unsplash.com/photo-1552664730-d307ca884978?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 29: Developer Security Training Platform",
                        "language": "markdown",
                        "code": "# Proposal for a Security Guild / Community of Practice\n\n**Mission:** To provide a forum for developers and security engineers to share knowledge, discuss challenges, and collectively improve the security of our software.\n\n**Activities:**\n- **Monthly Meetings:**\n  - 30 minutes: Presentation by a security engineer or a security champion on a relevant topic (e.g., a new attack technique, a new internal security tool).\n  - 30 minutes: Open Q&A and discussion.\n- **Dedicated Slack Channel:** A place for real-time questions and knowledge sharing.\n- **Internal Blog/Wiki:** A space to document best practices, patterns, and lessons learned."
                    },
                    {
                        "title": "Code Example 29: Gamified Security Learning System",
                        "language": "json",
                        "code": "{\n  \"event\": \"VULNERABILITY_FIXED\",\n  \"developerId\": \"alex.dev\",\n  \"vulnerability\": {\n    \"id\": \"CVE-2025-3333\",\n    \"severity\": \"HIGH\"\n  },\n  \"pointsAwarded\": 75,\n  \"newTotalPoints\": 1250,\n  \"notifications\": [\n    {\n      \"type\": \"SLACK_MESSAGE\",\n      \"channel\": \"#security-wins\",\n      \"message\": \"Props to @alex.dev for fixing a HIGH severity vulnerability! :tada: (+75 points)\"\n    }\n  ]\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary goal of a Security Champions program?",
                        "options": [
                            "To hire more security engineers.",
                            "To create a network of trained, embedded security advocates within development teams to scale security expertise.",
                            "To replace all automated security tools.",
                            "To handle all incident response."
                        ],
                        "correct": 1,
                        "explanation": "A security team cannot scale to be everywhere at once. The champions program is a force multiplier, creating a distributed network of security-minded engineers who can help their teams make better security decisions every day."
                    },
                    {
                        "id": 2,
                        "question": "Which of the following is the most effective form of security training for developers?",
                        "options": [
                            "A 4-hour, non-interactive video they are required to watch once a year.",
                            "A 500-page textbook on cryptography.",
                            "Short, interactive, hands-on labs that are provided at the moment they encounter a specific vulnerability.",
                            "A threatening email from the CISO."
                        ],
                        "correct": 2,
                        "explanation": "Just-in-time, contextual, and hands-on training is far more effective at building and retaining knowledge than traditional, generic awareness training."
                    },
                    {
                        "id": 3,
                        "question": "Using a leaderboard to track which team has fixed the most security bugs is an example of what cultural technique?",
                        "options": [
                            "Gamification",
                            "A blameless post-mortem",
                            "A compliance audit",
                            "Threat modeling"
                        ],
                        "correct": 0,
                        "explanation": "Gamification uses game mechanics like points, badges, and leaderboards to make activities more engaging and to provide positive reinforcement for desired behaviors."
                    },
                    {
                        "id": 4,
                        "question": "A healthy security culture is one where:",
                        "options": [
                            "Developers are afraid to talk to the security team.",
                            "Security is seen as a blocker and someone else's problem.",
                            "Security is a shared responsibility, and failures are treated as learning opportunities.",
                            "Security is ignored completely."
                        ],
                        "correct": 2,
                        "explanation": "The ultimate goal is to create a culture of collaboration and shared ownership, where everyone feels empowered and responsible for building secure software."
                    }
                ]
            }
        },
        {
            "id": "lesson-30",
            "title": "Emerging Security Technologies",
            "duration": "90 min",
            "objectives": [
                "Understand the potential impact of AI/ML on secure software development.",
                "Explore the security challenges of emerging paradigms like IoT and Blockchain.",
                "Grasp the long-term threat of quantum computing to modern cryptography.",
                "Identify future trends and their implications for developers."
            ],
            "content": {
                "overview": "The world of software and security is constantly changing. As a developer, it's important to keep an eye on the future to understand the new technologies you will be asked to build and the new threats you will need to defend against. This final lesson provides a high-level overview of several emerging technologies and their impact on the future of secure software development.",
                "sections": [
                    {
                        "title": "AI/ML Security Applications",
                        "content": "<p>Artificial intelligence and machine learning are not just a new type of application to secure; they are also becoming a powerful tool for security itself.</p><h3>AI in Secure Development:</h3><ul><li><strong>AI-Assisted Code Generation:</strong> Tools like GitHub Copilot can suggest code snippets, but they can also suggest insecure code. The future will involve AI models that are specifically trained on secure coding patterns to act as a real-time security coach for developers.</li><li><strong>Automated Remediation:</strong> In the near future, AI models will not just find vulnerabilities but will be able to automatically write and propose the correct, secure code to fix them, dramatically speeding up remediation.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1620712943543-285f231f7927?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "IoT and Blockchain Security",
                        "content": "<h3>Internet of Things (IoT):</h3><p>As a developer for IoT devices, you face unique challenges: physically insecure devices, limited processing power, and the need for secure over-the-air updates. The principles of least privilege and secure communication are paramount.</p><h3>Blockchain and Smart Contracts:</h3><p>The key challenge for a smart contract developer is the immutability of the blockchain. A bug deployed in a smart contract can be impossible to patch and can lead to an irreversible loss of funds. This makes pre-deployment security testing, including formal verification, absolutely critical.</p>",
                        "image": "https://images.unsplash.com/photo-1642104793574-e395f87f5471?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Quantum Computing Impact",
                        "content": "<p>Large-scale quantum computers, when they arrive, will be able to break most of the public-key cryptography (RSA, ECC) that secures the internet today. This is a long-term but fundamental threat.</p><h3>The Developer's Role:</h3><p>The industry is currently in the process of standardizing post-quantum cryptographic (PQC) algorithms. As a developer, your future role will be to migrate your applications to use these new, quantum-resistant libraries. This will be a massive, global effort, and the key will be to build applications with 'crypto-agility'â€”the ability to easily swap out one cryptographic algorithm for another.</p>",
                        "image": "https://images.unsplash.com/photo-1510915228340-29c85a43dcfe?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Zero Trust Architecture",
                        "content": "<p>Zero Trust is not a future trend; it is the present-day standard for modern security architecture. As a developer, your applications must be designed to work in a Zero Trust environment.</p><h3>What this means for your code:</h3><ul><li>You cannot assume the network is trusted. All communication must be encrypted.</li><li>You cannot trust a request just because it came from an 'internal' IP address. Every request to your service must be authenticated and authorized.</li><li>Your application must expect to be run in an environment where it has the absolute minimum permissions needed to function.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 30: Emerging Technology Security Workshop",
                        "language": "python",
                        "code": "# Conceptual code showing the principle of 'crypto-agility'\n\n# The application code doesn't know or care what the specific algorithm is.\n# It just asks the crypto service to encrypt data.\ndef save_user_data(user_data):\n    encrypted_data = crypto_service.encrypt(user_data)\n    database.save(encrypted_data)\n\n# The crypto service reads its configuration from a central file.\n# To migrate from AES to a new post-quantum algorithm, only the config changes.\nclass CryptoService:\n    def __init__(self, config):\n        self.algorithm = config.get('algorithm') # e.g., 'AES_GCM' or 'KYBER_AES_HYBRID'\n        \n    def encrypt(self, data):\n        if self.algorithm == 'AES_GCM':\n            # ... do AES encryption\n        elif self.algorithm == 'KYBER_AES_HYBRID':\n            # ... do post-quantum encryption"
                    },
                    {
                        "title": "Code Example 30: Next-Generation Security Framework",
                        "language": "json",
                        "code": "{\n  \"vulnerabilityFinding\": {\n    \"type\": \"SQL_INJECTION\",\n    \"file\": \"UserRepository.java\",\n    \"line\": 52\n  },\n  \"aiRemediationSuggestion\": {\n    \"confidence\": \"98%\",\n    \"explanation\": \"The current code uses string concatenation to build a SQL query. This should be replaced with a PreparedStatement to prevent SQL Injection.\",\n    \"suggestedCodePatch\": \"... (diff format showing the secure code) ...\"\n  },\n  \"action\": \"CREATE_PULL_REQUEST_WITH_SUGGESTED_FIX\"\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary security challenge for developers of smart contracts on a blockchain?",
                        "options": [
                            "The code runs too slowly.",
                            "The immutable nature of the blockchain makes it extremely difficult or impossible to patch a vulnerability after deployment.",
                            "There are too many programming languages to choose from.",
                            "The blockchain is not secure."
                        ],
                        "correct": 1,
                        "explanation": "Immutability is a double-edged sword. While it provides integrity, it also means that a security bug, once deployed, is permanent and can be exploited until the contract is drained of funds. This places an immense burden on pre-deployment security testing."
                    },
                    {
                        "id": 2,
                        "question": "The long-term threat of quantum computing is primarily against what type of cryptography?",
                        "options": [
                            "Hashing algorithms like SHA-256.",
                            "Symmetric encryption like AES.",
                            "Public-key (asymmetric) cryptography like RSA and ECC.",
                            "It is not a threat to cryptography."
                        ],
                        "correct": 2,
                        "explanation": "Large-scale quantum computers will be able to break the mathematical problems that underlie modern public-key cryptography, which is used for almost all secure key exchange and digital signatures on the internet."
                    },
                    {
                        "id": 3,
                        "question": "An architecture where applications assume the network is hostile and every request is authenticated and authorized is known as:",
                        "options": [
                            "A legacy architecture",
                            "A perimeter-based architecture",
                            "A Zero Trust architecture",
                            "An insecure architecture"
                        ],
                        "correct": 2,
                        "explanation": "Zero Trust is the modern standard. As a developer, you must write your applications to be Zero Trust-native, meaning they do not make any assumptions about a 'trusted' internal network."
                    },
                    {
                        "id": 4,
                        "question": "The ability to easily switch an application from one cryptographic algorithm to another, for example, to migrate to a post-quantum standard, is known as:",
                        "options": [
                            "Hard-coding",
                            "Crypto-agility",
                            "Rolling your own crypto",
                            "A cryptographic failure"
                        ],
                        "correct": 1,
                        "explanation": "Crypto-agility is a key architectural principle for future-proofing applications. By abstracting the use of cryptography, you make it much easier to respond to future threats and migrate to new standards."
                    }
                ]
            }
        },
        {
            "id": "lesson-31",
            "title": "Final Capstone Project",
            "duration": "240 min",
            "objectives": [
                "Apply the principles learned throughout the course to a real-world application.",
                "Create a threat model for a new application feature.",
                "Identify and fix a set of common security vulnerabilities in a sample codebase.",
                "Design a secure architecture for a multi-tier web application."
            ],
            "content": {
                "overview": "This final capstone project brings together all the concepts covered in the Complete Secure Software Development Course. You will be given a small but realistic web application codebase with a set of new feature requirements. Your task will be to act as a security-conscious developer, performing a threat model, finding and fixing existing vulnerabilities, and designing a secure implementation for the new features.",
                "sections": [
                    {
                        "title": "Scenario: 'NoteShare' Application",
                        "content": "<p>You are a developer on the team for 'NoteShare', a web application that allows users to register, log in, and create private notes.</p><h3>The Codebase:</h3><p>You will be provided with a Git repository containing a simple web application written in the language of your choice (starter projects will be provided for Python/Flask, Java/Spring, and Node.js/Express). The application has basic functionality but contains a number of common security vulnerabilities.</p><h3>New Feature Requirement:</h3><p>The product manager wants to add a new feature that allows users to share their notes with other specific users in a 'read-only' capacity.</p>",
                        "image": "https://images.unsplash.com/photo-1517694712202-14dd9538aa97?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Project Task 1: Threat Model the New Feature",
                        "content": "<p>Before writing any code for the new 'note sharing' feature, you must create a threat model. Your submission should include:</p><ol><li>A simple Data Flow Diagram (DFD) for the new feature.</li><li>A list of potential threats identified using the STRIDE methodology.</li><li>A list of proposed mitigations for each threat.</li></ol>",
                        "image": "https://images.unsplash.com/photo-1543286386-713bdd548da4?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Project Task 2: Find and Fix Existing Vulnerabilities",
                        "content": "<p>The existing codebase contains several intentional vulnerabilities from the OWASP Top 10. You must find and fix at least three of them. Your submission should be a pull request containing:</p><ul><li>The code changes to fix the vulnerabilities.</li><li>A description in the pull request of the vulnerabilities you found and how your code fixes them.</li><li>At least one new, automated security regression test that proves your fix works.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1555099962-4199c345e546?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Project Task 3: Securely Implement the New Feature",
                        "content": "<p>Implement the 'note sharing' feature based on your threat model and secure design principles. Your implementation must include a secure authorization model to ensure that only the intended users can view a shared note.</p>",
                        "image": "https://images.unsplash.com/photo-1486312338219-ce68d2c6f44d?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Final Lab: End-to-End Secure Development Lifecycle",
                        "language": "markdown",
                        "code": "# Capstone Project Submission Checklist\n\n1.  **Threat Model Document (PDF or Markdown):**\n    - [ ] DFD for the sharing feature.\n    - [ ] List of STRIDE threats and mitigations.\n\n2.  **Pull Request 1: Vulnerability Fixes:**\n    - [ ] Link to the pull request in your forked repository.\n    - [ ] PR description clearly explains the vulnerabilities and fixes.\n    - [ ] The PR includes at least one new automated security test.\n\n3.  **Pull Request 2: New Feature Implementation:**\n    - [ ] Link to the pull request for the new sharing feature.\n    - [ ] The PR implements the feature securely, paying special attention to authorization (preventing BOLA/IDOR).\n\n**Evaluation Criteria:**\n- **Threat Modeling:** Is the threat model complete and logical?\n- **Vulnerability Analysis:** Did you correctly identify and securely fix at least three vulnerabilities?\n- **Secure Coding:** Is the new feature implemented using the secure coding principles from the course?\n- **Testing:** Did you write effective security regression tests?"
                    },
                    {
                        "title": "Final Code Project: Enterprise Secure Application Platform",
                        "language": "plaintext",
                        "code": "/*\n  This final project is a hands-on coding exercise that requires you to act as a security-minded developer.\n  You will be evaluated on your ability to apply the practical, secure coding and design skills taught\n  throughout this course to a real-world (though simplified) application.\n*/"
                    }
                ]
            },
            "quiz": {
                "passingScore": 100,
                "questions": [
                    {
                        "id": 1,
                        "question": "This capstone project requires you to apply secure design, coding, and testing principles to a practical exercise. Are you ready to begin?",
                        "options": [
                            "Yes, I am ready to secure the 'NoteShare' application.",
                            "No, I would like to review some of the previous lessons."
                        ],
                        "correct": 0,
                        "explanation": "This question confirms your readiness to apply the comprehensive, hands-on knowledge gained throughout the course to a final, practical development project."
                    }
                ]
            }
        }
    ]
}    // =====================================================
      // GLOBAL VARIABLES
      // =====================================================
      let currentUser = null;
      let currentLessonIndex = 0;
      let courseProgress = {};
      let userStats = {};
      let quizState = {
        currentQuestion: 0,
        answers: [],
        score: 0,
        isComplete: false,
      };

      // Enhanced session tracking
      let courseSession = {
        startTime: null,
        totalStudyTime: 0,
        lessonsStarted: 0,
        lessonsCompleted: 0,
        pageLoadTime: new Date(),
        interactionCount: 0,
        lastActivityTime: new Date(),
      };

      // Music Player Variables
      let audioPlayer = new Audio();

      // Achievement notification system
      let notificationQueue = [];
      let isShowingNotification = false;

      // =====================================================
      // INITIALIZATION
      // =====================================================
      document.addEventListener("DOMContentLoaded", async () => {
        try {
          showLoadingScreen();
          await checkAuth();

          if (currentUser) {
            // Initialize session tracking
            startCourseSession();

            // Load course data and progress
            await loadCourseData();
            await loadUserProfile();
            await loadProgress();

            // Initialize UI
            initializeEventListeners();
            renderSidebar();
            loadLesson(currentLessonIndex);

            // Initialize additional features
            initMusicPlayer();
            addMusicIndicator();
            initializeActivityTracking();

            hideLoadingScreen();
          } else {
            openAuthModal();
          }
        } catch (error) {
          console.error("Error initializing course:", error);
          hideLoadingScreen();
          showToast("Failed to initialize course system", "error");
        }
      });

      // =====================================================
      // AUTHENTICATION SYSTEM
      // =====================================================
      async function checkAuth() {
        try {
          const {
            data: { session },
            error,
          } = await supabase.auth.getSession();

          if (error) {
            console.error("Auth error:", error);
            currentUser = null;
            openAuthModal();
            return;
          }

          if (!session) {
            currentUser = null;
            openAuthModal();
            return;
          }

          currentUser = session.user;
          updateUIWithUser();
        } catch (error) {
          console.error("Error checking auth:", error);
          currentUser = null;
          openAuthModal();
        }
      }

      function updateUIWithUser() {
        if (!currentUser) return;

        const name =
          currentUser.user_metadata?.full_name ||
          currentUser.email.split("@")[0];
        const userElements = document.querySelectorAll("[data-user-name]");
        userElements.forEach((el) => (el.textContent = name));
      }

      // =====================================================
      // USER PROFILE & STATS MANAGEMENT
      // =====================================================
      async function loadUserProfile() {
        try {
          // ðŸ” Step 1: Try to fetch existing profile
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("*")
            .eq("id", currentUser.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (!profile) {
            // ðŸ†• Step 2: Create new profile if missing
            await createUserProfile();
          } else {
            // âœ… Step 3: Use existing profile
            userStats = profile;
            await updateLastActivity();
          }
        } catch (error) {
          console.error("âŒ Error loading user profile:", error);
          showToast("Failed to load user profile", "error");
        }
      }
      async function createUserProfile() {
        try {
          const newProfile = {
            id: currentUser.id,
            full_name: currentUser.user_metadata?.full_name || "",
            email: currentUser.email,
            level: "Script Kiddie",
            total_points: 0,
            completed_courses: 0,
            current_streak: 0,
            total_certificates: 0,
            total_achievements: 0,
            sections_visited: 0,
            bonus_points: 0,
            in_progress_courses: 0,
            settings_changed: 0,
            midnight_sessions: 0,
            early_sessions: 0,
            weekend_sessions: 0,
            last_activity: new Date().toISOString(),
            created_at: new Date().toISOString(),
          };

          const { error } = await supabase
            .from("profiles")
            .insert([newProfile]);

          if (!error) {
            userStats = newProfile;
            // Award first login achievement
            setTimeout(() => checkAndUnlockAchievement("first_login"), 1000);
          }
        } catch (error) {
          console.error("Error creating user profile:", error);
        }
      }

      async function updateLastActivity() {
        try {
          const now = new Date();

          // Update activity tracking
          courseSession.lastActivityTime = now;

          // Update database
          await supabase
            .from("profiles")
            .update({
              last_activity: now.toISOString(),
            })
            .eq("id", currentUser.id);

          // Check time-based achievements
          await checkTimeBasedAchievements(now);
        } catch (error) {
          console.error("Error updating last activity:", error);
        }
      }

      // =====================================================
      // COURSE SESSION MANAGEMENT
      // =====================================================
      function startCourseSession() {
        courseSession.startTime = new Date();
        courseSession.pageLoadTime = new Date();

        logUserActivity("course_session_start", {
          course_id: COURSE_DATA.id,
          course_title: COURSE_DATA.title,
          user_agent: navigator.userAgent,
          screen_resolution: `${screen.width}x${screen.height}`,
        });

        // Check daily streak
        checkDailyStreak();
      }

      function initializeActivityTracking() {
        // Track page focus/blur for accurate study time
        document.addEventListener("visibilitychange", handleVisibilityChange);

        // Track user interactions
        ["click", "keydown", "scroll", "mousemove"].forEach((event) => {
          document.addEventListener(event, trackUserInteraction, {
            passive: true,
          });
        });

        // Periodic activity updates
        setInterval(updateStudyTime, 60000); // Every minute

        // Save session data before page unload
        window.addEventListener("beforeunload", saveSessionData);
      }

      function handleVisibilityChange() {
        if (document.hidden) {
          courseSession.lastActivityTime = new Date();
        } else {
          // Page became visible again - update activity
          updateLastActivity();
        }
      }

      function trackUserInteraction() {
        courseSession.interactionCount++;
        courseSession.lastActivityTime = new Date();

        // Throttle activity updates
        if (courseSession.interactionCount % 50 === 0) {
          updateLastActivity();
        }
      }

      function updateStudyTime() {
        if (!courseSession.startTime || document.hidden) return;

        const now = new Date();
        const sessionDuration = now - courseSession.startTime;
        courseSession.totalStudyTime = Math.floor(sessionDuration / 1000 / 60); // in minutes

        // Update progress with study time
        saveProgress();
      }

      function saveSessionData() {
        if (!currentUser || !courseSession.startTime) return;

        const sessionData = {
          user_id: currentUser.id,
          course_id: COURSE_DATA.id,
          session_duration: courseSession.totalStudyTime,
          lessons_viewed: courseSession.lessonsStarted,
          lessons_completed: courseSession.lessonsCompleted,
          interactions: courseSession.interactionCount,
          session_date: courseSession.startTime.toISOString().split("T")[0],
        };

        // Store in localStorage as backup
        localStorage.setItem(
          "course_session_backup",
          JSON.stringify(sessionData)
        );

        // Try to save to database
        logUserActivity("course_session_end", sessionData);
      }

      // =====================================================
      // COURSE DATA & PROGRESS MANAGEMENT
      // =====================================================
      async function loadCourseData() {
        try {
          // Update course info in UI
          document.getElementById("courseTitle").textContent =
            COURSE_DATA.title;
          document.getElementById("totalLessons").textContent =
            COURSE_DATA.lessons.length;

          // Log course access
          logUserActivity("course_access", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
          });
        } catch (error) {
          console.error("Error loading course data:", error);
        }
      }

      async function loadProgress() {
        try {
          // Get existing progress from database
          const { data, error } = await supabase
            .from("course_progress")
            .select("*")
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (data) {
            courseProgress = JSON.parse(data.lesson_progress || "{}");
            currentLessonIndex = data.current_lesson || 0;

            // Update session tracking
            courseSession.lessonsStarted = Object.keys(courseProgress).length;
            courseSession.lessonsCompleted = Object.values(
              courseProgress
            ).filter((p) => p.completed).length;
          } else {
            // Initialize new progress
            courseProgress = {};
            currentLessonIndex = 0;
            await saveProgress();

            // Award first course start achievement
            await checkAndUnlockAchievement("first_course_start");
          }

          updateProgressDisplay();
        } catch (error) {
          console.error("Error loading progress:", error);
          showToast("Failed to load progress", "error");
        }
      }

      async function saveProgress() {
        try {
          if (!currentUser) return;

          const now = new Date();
          const progressData = {
            user_id: currentUser.id,
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            current_lesson: currentLessonIndex,
            lesson_progress: JSON.stringify(courseProgress),
            progress: calculateOverallProgress(),
            lessons_completed: getCompletedLessonsCount(),
            lessons_started: Object.keys(courseProgress).length,
            study_time_minutes: courseSession.totalStudyTime,
            last_accessed: now.toISOString(),
            updated_at: now.toISOString(),
          };

          // Upsert progress
          const { error } = await supabase
            .from("course_progress")
            .upsert([progressData]);

          if (error) throw error;

          // Update user stats
          await updateUserStats();

          updateProgressDisplay();
        } catch (error) {
          console.error("Error saving progress:", error);
          showToast("Failed to save progress", "error");
        }
      }

      async function updateUserStats() {
        try {
          // Get all course progress for this user
          const { data: allProgress, error } = await supabase
            .from("course_progress")
            .select("progress, course_id, study_time_minutes")
            .eq("user_id", currentUser.id);

          if (error) throw error;

          // Calculate stats
          const completedCourses =
            allProgress?.filter((p) => p.progress >= 100).length || 0;
          const inProgressCourses =
            allProgress?.filter((p) => p.progress > 0 && p.progress < 100)
              .length || 0;
          const totalStudyTime =
            allProgress?.reduce(
              (sum, p) => sum + (p.study_time_minutes || 0),
              0
            ) || 0;

          // Calculate points (500 per completed course + achievement points)
          const coursePoints = completedCourses * 500;
          const bonusPoints = userStats.bonus_points || 0;
          const totalPoints = coursePoints + bonusPoints;

          // Update profile
          const updateData = {
            completed_courses: completedCourses,
            in_progress_courses: inProgressCourses,
            total_points: totalPoints,
            total_study_time: totalStudyTime,
            last_activity: new Date().toISOString(),
          };

          const { error: updateError } = await supabase
            .from("profiles")
            .update(updateData)
            .eq("id", currentUser.id);

          if (updateError) throw updateError;

          // Update local stats
          Object.assign(userStats, updateData);
        } catch (error) {
          console.error("Error updating user stats:", error);
        }
      }

      function calculateOverallProgress() {
        const completedLessons = getCompletedLessonsCount();
        return Math.round(
          (completedLessons / COURSE_DATA.lessons.length) * 100
        );
      }

      function getCompletedLessonsCount() {
        return Object.values(courseProgress).filter(
          (lesson) => lesson.completed
        ).length;
      }

      function updateProgressDisplay() {
        const completedCount = getCompletedLessonsCount();
        const progressPercent = calculateOverallProgress();

        // Update UI elements
        const elements = {
          completedLessons: completedCount,
          courseProgressPercent: `${progressPercent}%`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });

        // Update progress bar
        const progressBar = document.getElementById("courseProgressFill");
        if (progressBar) progressBar.style.width = `${progressPercent}%`;
      }

      // =====================================================
      // LESSON MANAGEMENT
      // =====================================================
      function loadLesson(index) {
        if (index < 0 || index >= COURSE_DATA.lessons.length) return;

        const lesson = COURSE_DATA.lessons[index];
        currentLessonIndex = index;

        // Mark lesson as started and track activity
        if (!courseProgress[lesson.id]) {
          courseProgress[lesson.id] = {
            started: true,
            completed: false,
            startedAt: new Date().toISOString(),
            timeSpent: 0,
          };

          courseSession.lessonsStarted++;
          saveProgress();

          // Log lesson start
          logUserActivity("lesson_start", {
            lesson_id: lesson.id,
            lesson_title: lesson.title,
            lesson_index: index,
          });
        }

        // Update lesson start time for time tracking
        courseProgress[lesson.id].currentSessionStart = new Date();

        // Update sidebar and navigation
        renderSidebar();
        updateNavigationButtons();

        // Update header info
        updateLessonHeader(lesson, index);

        // Render lesson content
        renderLessonContent(lesson);

        // Smooth scroll and animations
        window.scrollTo({ top: 0, behavior: "smooth" });
        document.getElementById("contentBody").scrollTop = 0;

        const contentBody = document.getElementById("contentBody");
        contentBody.classList.add("fade-in");
        setTimeout(() => contentBody.classList.remove("fade-in"), 500);

        // Check lesson-based achievements
        checkLessonAchievements(index + 1);
      }

      function updateLessonHeader(lesson, index) {
        const elements = {
          currentLessonNumber: index + 1,
          currentLessonTitle: lesson.title,
          navInfo: `Lesson ${index + 1} of ${COURSE_DATA.lessons.length}`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });
      }

      function renderSidebar() {
        const lessonNav = document.getElementById("lessonNav");
        if (!lessonNav) return;

        lessonNav.innerHTML = "";

        COURSE_DATA.lessons.forEach((lesson, index) => {
          const lessonItem = document.createElement("div");
          lessonItem.className = "lesson-item";

          // Determine lesson status
          const lessonProgress = courseProgress[lesson.id];
          const isCompleted = lessonProgress?.completed || false;
          const isInProgress = lessonProgress?.started || false;
          const isLocked = !isCompleted && !canAccessLesson(index);
          const isActive = index === currentLessonIndex;

          // Apply status classes
          if (isCompleted) lessonItem.classList.add("completed");
          if (isLocked) lessonItem.classList.add("locked");
          if (isActive) lessonItem.classList.add("active");

          // Determine status display
          let statusClass = "not-started";
          let statusIcon = index + 1;

          if (isCompleted) {
            statusClass = "completed";
            statusIcon = "âœ“";
          } else if (isInProgress) {
            statusClass = "in-progress";
            statusIcon = "â—";
          }

          // Create lesson item HTML
          lessonItem.innerHTML = `
            <div class="lesson-status ${statusClass}">${statusIcon}</div>
            <div class="lesson-info">
                <div class="lesson-title">${lesson.title}</div>
                <div class="lesson-meta">
                    ${
                      isCompleted
                        ? "Completed"
                        : isInProgress
                        ? "In Progress"
                        : isLocked
                        ? "Locked"
                        : "Not Started"
                    }
                </div>
            </div>
            <div class="lesson-duration">${lesson.duration}</div>
        `;

          // Add click handler if not locked
          if (!isLocked) {
            lessonItem.addEventListener("click", () => {
              if (index !== currentLessonIndex) {
                // Track lesson time before switching
                trackLessonTime();

                currentLessonIndex = index;
                loadLesson(index);
                closeSidebar();
              }
            });
          }

          lessonNav.appendChild(lessonItem);
        });
      }

      function canAccessLesson(index) {
        if (index === 0) return true; // First lesson always accessible

        // Can access if previous lesson is completed
        const previousLessonId = COURSE_DATA.lessons[index - 1].id;
        return courseProgress[previousLessonId]?.completed || false;
      }

      function trackLessonTime() {
        const currentLesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonProgress = courseProgress[currentLesson.id];

        if (lessonProgress?.currentSessionStart) {
          const sessionTime = Math.floor(
            (new Date() - new Date(lessonProgress.currentSessionStart)) /
              1000 /
              60
          );
          lessonProgress.timeSpent =
            (lessonProgress.timeSpent || 0) + sessionTime;
          delete lessonProgress.currentSessionStart;
        }
      }

      // =====================================================
      // LESSON CONTENT RENDERING
      // =====================================================
      function renderLessonContent(lesson) {
        const contentContainer = document.getElementById("lessonContent");
        if (!contentContainer) return;

        let contentHTML = `
        <div class="content-section">
            <h2>Learning Objectives</h2>
            <ul>
                ${lesson.objectives.map((obj) => `<li>${obj}</li>`).join("")}
            </ul>
        </div>
        
        <div class="content-section">
            <h2>Overview</h2>
            <p>${lesson.content.overview}</p>
        </div>
    `;

        // Render content sections
        lesson.content.sections.forEach((section) => {
          contentHTML += `
            <div class="content-section">
                <h2>${section.title}</h2>
                ${section.content}
                ${
                  section.image
                    ? `<img src="${section.image}" alt="${section.title}" class="content-image" loading="lazy">`
                    : ""
                }
            </div>
        `;
        });

        // Render code examples
        if (
          lesson.content.codeExamples &&
          lesson.content.codeExamples.length > 0
        ) {
          contentHTML += `<div class="content-section"><h2>Code Examples</h2></div>`;

          lesson.content.codeExamples.forEach((example, index) => {
            const codeId = `code-${lesson.id}-${index}`;
            contentHTML += `
                <div class="code-section">
                    <div class="code-header">
                        <span class="code-title">${example.title}</span>
                        <button class="copy-btn" onclick="copyCode('${codeId}')">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <pre class="code-block"><code id="${codeId}" class="language-${
              example.language
            }">${escapeHtml(example.code)}</code></pre>
                </div>
            `;
          });
        }

        // Render quiz
        contentHTML += renderQuiz(lesson.quiz);

        contentContainer.innerHTML = contentHTML;

        // Highlight code syntax if Prism is available
        setTimeout(() => {
          if (window.Prism) {
            Prism.highlightAll();
          }
        }, 100);
      }

      // =====================================================
      // QUIZ SYSTEM
      // =====================================================
      function renderQuiz(quiz) {
        const currentLessonProgress =
          courseProgress[COURSE_DATA.lessons[currentLessonIndex].id];
        const isCompleted = currentLessonProgress?.completed || false;

        let quizHTML = `
        <div class="quiz-section" id="quizSection">
            <div class="quiz-header">
                <h2 class="quiz-title">
                    <i class="fas fa-clipboard-check"></i>
                    Knowledge Check
                </h2>
                <p class="quiz-info">
                    Complete this quiz with ${quiz.passingScore}% or higher to unlock the next lesson.
                </p>
            </div>
    `;

        if (isCompleted) {
          const savedScore = currentLessonProgress.quizScore || 0;
          quizHTML += `
            <div class="quiz-results show">
                <div class="quiz-score pass">${savedScore}%</div>
                <div class="quiz-message">
                    <strong>Lesson Completed!</strong><br>
                    You've successfully passed this lesson's quiz.
                </div>
            </div>
        `;
        } else {
          // Render quiz questions
          quiz.questions.forEach((question, qIndex) => {
            quizHTML += `
                <div class="quiz-question ${
                  qIndex === 0 ? "active" : ""
                }" data-question="${qIndex}">
                    <div class="question-header">
                        <span class="question-number">Question ${
                          qIndex + 1
                        }</span>
                        <span class="question-progress">${qIndex + 1}/${
              quiz.questions.length
            }</span>
                    </div>
                    <div class="question-text">${question.question}</div>
                    <div class="question-options">
                        ${question.options
                          .map(
                            (option, oIndex) => `
                            <div class="option" data-option="${oIndex}" onclick="selectOption(${qIndex}, ${oIndex})">
                                <span class="option-letter">${String.fromCharCode(
                                  65 + oIndex
                                )}</span>
                                <span class="option-text">${option}</span>
                            </div>
                        `
                          )
                          .join("")}
                    </div>
                </div>
            `;
          });

          quizHTML += `
            <div class="quiz-controls">
                <button class="btn btn-secondary" id="prevQuestionBtn" onclick="previousQuestion()" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <div>
                    <button class="btn btn-secondary" id="nextQuestionBtn" onclick="nextQuestion()" disabled>
                        Next
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <button class="btn btn-primary" id="submitQuizBtn" onclick="submitQuiz()" style="display: none;">
                        <i class="fas fa-check"></i>
                        Submit Quiz
                    </button>
                </div>
            </div>

            <div class="quiz-results" id="quizResults">
                <div class="quiz-score" id="quizScore">0%</div>
                <div class="quiz-message" id="quizMessage"></div>
                <div class="quiz-actions">
                    <button class="btn btn-primary" id="continueBtn" onclick="completeLesson()" style="display: none;">
                        <i class="fas fa-arrow-right"></i>
                        Continue to Next Lesson
                    </button>
                    <button class="btn btn-secondary" onclick="retakeQuiz()">
                        <i class="fas fa-redo"></i>
                        Retake Quiz
                    </button>
                </div>
            </div>
        `;
        }

        quizHTML += "</div>";
        return quizHTML;
      }

      // Quiz interaction functions
      function selectOption(questionIndex, optionIndex) {
        // Clear previous selections
        document
          .querySelectorAll(`[data-question="${questionIndex}"] .option`)
          .forEach((opt) => {
            opt.classList.remove("selected");
          });

        // Select current option
        const selectedOption = document.querySelector(
          `[data-question="${questionIndex}"] [data-option="${optionIndex}"]`
        );
        selectedOption.classList.add("selected");

        // Store answer
        quizState.answers[questionIndex] = optionIndex;

        // Update navigation
        const isLastQuestion =
          questionIndex ===
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length - 1;
        if (isLastQuestion) {
          document.getElementById("submitQuizBtn").style.display =
            "inline-flex";
          document.getElementById("nextQuestionBtn").style.display = "none";
        } else {
          document.getElementById("nextQuestionBtn").disabled = false;
        }
      }

      function nextQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const nextQuestionEl = currentQuestionEl.nextElementSibling;

        if (
          nextQuestionEl &&
          nextQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          nextQuestionEl.classList.add("active");
          quizState.currentQuestion++;
          updateQuizNavigation();
        }
      }

      function previousQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const prevQuestionEl = currentQuestionEl.previousElementSibling;

        if (
          prevQuestionEl &&
          prevQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          prevQuestionEl.classList.add("active");
          quizState.currentQuestion--;
          updateQuizNavigation();
        }
      }

      function updateQuizNavigation() {
        const totalQuestions =
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length;
        const prevBtn = document.getElementById("prevQuestionBtn");
        const nextBtn = document.getElementById("nextQuestionBtn");
        const submitBtn = document.getElementById("submitQuizBtn");

        prevBtn.disabled = quizState.currentQuestion === 0;

        const hasAnswer =
          quizState.answers[quizState.currentQuestion] !== undefined;
        const isLastQuestion = quizState.currentQuestion === totalQuestions - 1;

        if (isLastQuestion) {
          nextBtn.style.display = "none";
          submitBtn.style.display = hasAnswer ? "inline-flex" : "none";
        } else {
          nextBtn.style.display = "inline-flex";
          nextBtn.disabled = !hasAnswer;
          submitBtn.style.display = "none";
        }
      }

      async function submitQuiz() {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const quiz = lesson.quiz;
        let correctAnswers = 0;

        // Hide questions and controls
        document
          .querySelectorAll(".quiz-question")
          .forEach((q) => (q.style.display = "none"));
        document.querySelector(".quiz-controls").style.display = "none";

        // Calculate score and highlight answers
        quiz.questions.forEach((question, index) => {
          const userAnswer = quizState.answers[index];
          const correctAnswer = question.correct;
          const isCorrect = userAnswer === correctAnswer;

          if (isCorrect) correctAnswers++;

          // Highlight answers
          const questionEl = document.querySelector(
            `[data-question="${index}"]`
          );
          const options = questionEl.querySelectorAll(".option");

          options[correctAnswer].classList.add("correct");
          if (userAnswer !== correctAnswer && userAnswer !== undefined) {
            options[userAnswer].classList.add("incorrect");
          }
        });

        const score = Math.round(
          (correctAnswers / quiz.questions.length) * 100
        );
        const passed = score >= quiz.passingScore;

        // Update quiz results UI
        const quizScore = document.getElementById("quizScore");
        const quizMessage = document.getElementById("quizMessage");
        const quizActions = document.querySelector(".quiz-actions");

        quizScore.textContent = `${score}%`;
        quizScore.className = `quiz-score ${passed ? "pass" : "fail"}`;

        if (passed) {
          quizMessage.innerHTML = `
            <strong>Congratulations!</strong><br>
            You passed with ${score}%. You can now proceed to the next lesson.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-primary" onclick="completeLesson()">
                <i class="fas fa-arrow-right"></i>
                Continue to Next Lesson
            </button>
        `;

          // Mark lesson as completed
          await markLessonComplete(score);
        } else {
          quizMessage.innerHTML = `
            <strong>Not quite there yet.</strong><br>
            You scored ${score}%. You need ${quiz.passingScore}% to pass. Review the material and try again.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-secondary" onclick="retakeQuiz()">
                <i class="fas fa-redo"></i>
                Retake Quiz
            </button>
        `;
        }

        document.getElementById("quizResults").classList.add("show");

        // Log quiz completion
        logUserActivity("quiz_completed", {
          lesson_id: lesson.id,
          lesson_title: lesson.title,
          score: score,
          passed: passed,
          attempts: (courseProgress[lesson.id]?.quizAttempts || 0) + 1,
        });

        // Scroll to results
        document
          .getElementById("quizResults")
          .scrollIntoView({ behavior: "smooth" });
      }

      function retakeQuiz() {
        // Reset quiz state
        quizState = {
          currentQuestion: 0,
          answers: [],
          score: 0,
          isComplete: false,
        };

        // Track quiz retry
        const lessonId = COURSE_DATA.lessons[currentLessonIndex].id;
        if (!courseProgress[lessonId]) courseProgress[lessonId] = {};
        courseProgress[lessonId].quizAttempts =
          (courseProgress[lessonId].quizAttempts || 0) + 1;

        // Reload lesson content
        loadLesson(currentLessonIndex);

        // Scroll to quiz
        setTimeout(() => {
          document
            .getElementById("quizSection")
            .scrollIntoView({ behavior: "smooth" });
        }, 500);
      }

      async function markLessonComplete(score) {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonId = lesson.id;

        // Track lesson completion time
        trackLessonTime();

        // Update lesson progress
        courseProgress[lessonId] = {
          ...courseProgress[lessonId],
          completed: true,
          quizScore: score,
          completedAt: new Date().toISOString(),
          finalScore: score,
        };

        // Update session tracking
        courseSession.lessonsCompleted++;

        // Save progress to database
        await saveProgress();

        // Update UI
        renderSidebar();
        updateNavigationButtons();

        // Check various achievements
        await checkLessonCompletionAchievements();
        await checkPerfectScoreAchievements(score);
        await checkStudyTimeAchievements();

        // Log lesson completion
        logUserActivity("lesson_completed", {
          lesson_id: lessonId,
          lesson_title: lesson.title,
          final_score: score,
          time_spent: courseProgress[lessonId].timeSpent || 0,
          lesson_number: currentLessonIndex + 1,
        });

        showToast("Lesson completed successfully!", "success");
      }

      async function completeLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          // Move to next lesson
          currentLessonIndex++;
          loadLesson(currentLessonIndex);
        } else {
          // Course completion
          await completeCourse();
        }
      }

      async function completeCourse() {
        try {
          const completionTime = courseSession.totalStudyTime;

          // Update course progress to 100% completed
          await supabase
            .from("course_progress")
            .update({
              progress: 100,
              completed_at: new Date().toISOString(),
              completion_time_minutes: completionTime,
            })
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Award course completion achievements
          await checkAndUnlockAchievement("course_completion_1");
          await checkSpeedCompletionAchievements(completionTime);
          await checkCourseStreakAchievements();

          // Update user stats
          await updateUserStats();

          // Show completion message
          showToast(
            "Congratulations! Course completed successfully!",
            "certificate"
          );

          // Log course completion
          logUserActivity("course_completed", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            completion_time_minutes: completionTime,
            total_lessons: COURSE_DATA.lessons.length,
            average_quiz_score: calculateAverageQuizScore(),
          });

          // Redirect to dashboard after delay
          setTimeout(() => {
            window.location.href = "/dashboard";
          }, 3000);
        } catch (error) {
          console.error("Error completing course:", error);
          showToast("Error marking course as complete", "error");
        }
      }

      // =====================================================
      // ACHIEVEMENT INTEGRATION SYSTEM
      // =====================================================
      async function checkAndUnlockAchievement(
        achievementId,
        skipNotification = false
      ) {
        try {
          // Prevent duplicate checks
          const cacheKey = `achievement_${achievementId}_${currentUser.id}`;
          if (sessionStorage.getItem(cacheKey)) return false;

          // Check if already unlocked
          const { data: existing, error } = await supabase
            .from("user_achievements")
            .select("id")
            .eq("user_id", currentUser.id)
            .eq("achievement_id", achievementId)
            .single();

          if (existing) {
            sessionStorage.setItem(cacheKey, "true");
            return false;
          }

          // Award achievement
          const achievementData = {
            user_id: currentUser.id,
            achievement_id: achievementId,
            unlocked_at: new Date().toISOString(),
            points_awarded: getAchievementPoints(achievementId),
            context: "course_system",
          };

          const { data, error: insertError } = await supabase
            .from("user_achievements")
            .insert([achievementData])
            .select()
            .single();

          if (insertError) {
            if (insertError.code === "23505") return false; // Already exists
            throw insertError;
          }

          // Update user points
          await supabase.rpc('increment_user_stats', {
  user_id_param: currentUser.id,
  points_to_add: achievementData.points_awarded,
  achievements_to_add: 1
});

          // Cache and queue notification
          sessionStorage.setItem(cacheKey, "true");

          if (!skipNotification) {
            queueAchievementNotification({
              id: achievementId,
              name: getAchievementName(achievementId),
              description: getAchievementDescription(achievementId),
              points: achievementData.points_awarded,
              rarity: getAchievementRarity(achievementId),
              icon: getAchievementIcon(achievementId),
            });
          }

          return true;
        } catch (error) {
          console.error("Error unlocking achievement:", error);
          return false;
        }
      }

      // Helper functions for achievement data (replace with your actual achievement definitions)
      function getAchievementPoints(id) {
        const pointsMap = {
          first_course_start: 75,
          first_lesson: 100,
          course_completion_1: 500,
          perfect_score: 250,
          speed_demon: 750,
          marathon_learner: 500,
          night_owl: 200,
          early_bird: 200,
          weekend_warrior: 150,
          // Add more as needed
        };
        return pointsMap[id] || 100;
      }

      function getAchievementName(id) {
        const nameMap = {
          first_course_start: "Learning Initiated",
          first_lesson: "First Steps",
          course_completion_1: "Course Conqueror",
          perfect_score: "Perfectionist",
          speed_demon: "Speed Demon",
          // Add more as needed
        };
        return nameMap[id] || "Achievement Unlocked";
      }

      function getAchievementDescription(id) {
        const descMap = {
          first_course_start: "Start your first cybersecurity course",
          first_lesson: "Complete your first lesson",
          course_completion_1: "Complete your first course",
          perfect_score: "Score 100% on any quiz",
          speed_demon: "Complete a course in under 2 hours",
          // Add more as needed
        };
        return descMap[id] || "Achievement description";
      }

      function getAchievementRarity(id) {
        const rarityMap = {
          first_course_start: "common",
          first_lesson: "bronze",
          course_completion_1: "silver",
          perfect_score: "gold",
          speed_demon: "legendary",
          // Add more as needed
        };
        return rarityMap[id] || "common";
      }

      function getAchievementIcon(id) {
        const iconMap = {
          first_course_start: "fas fa-play",
          first_lesson: "fas fa-baby",
          course_completion_1: "fas fa-trophy",
          perfect_score: "fas fa-star",
          speed_demon: "fas fa-rocket",
          // Add more as needed
        };
        return iconMap[id] || "fas fa-award";
      }

      async function checkLessonAchievements(lessonNumber) {
        if (lessonNumber === 1) {
          await checkAndUnlockAchievement("first_lesson");
        }

        // Check if user has completed multiple lessons in one day
        const today = new Date().toISOString().split("T")[0];
        const todayCompletions = Object.values(courseProgress).filter(
          (p) => p.completed && p.completedAt?.startsWith(today)
        ).length;

        if (todayCompletions >= 3) {
          await checkAndUnlockAchievement("lesson_marathon");
        }
      }

      async function checkLessonCompletionAchievements() {
        const completedCount = getCompletedLessonsCount();

        // Lesson-based achievements
        const lessonMilestones = [1, 5, 10, 25, 50, 100];
        for (const milestone of lessonMilestones) {
          if (completedCount >= milestone) {
            await checkAndUnlockAchievement(`lessons_${milestone}`);
          }
        }

        // Course completion achievements
        if (completedCount === COURSE_DATA.lessons.length) {
          await checkAndUnlockAchievement("course_completion_1");

          // Check for additional course completion achievements
          const { data: allCourses } = await supabase
            .from("course_progress")
            .select("course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100);

          const totalCompleted = allCourses?.length || 0;

          const courseMilestones = [1, 5, 10, 25];
          for (const milestone of courseMilestones) {
            if (totalCompleted >= milestone) {
              await checkAndUnlockAchievement(`course_completion_${milestone}`);
            }
          }
        }
      }

      async function checkPerfectScoreAchievements(score) {
        if (score === 100) {
          await checkAndUnlockAchievement("perfect_score");

          // Check for consecutive perfect scores
          const recentScores = Object.values(courseProgress)
            .filter((p) => p.completed && p.quizScore)
            .slice(-5) // Last 5 completed
            .map((p) => p.quizScore);

          if (
            recentScores.length >= 3 &&
            recentScores.every((s) => s === 100)
          ) {
            await checkAndUnlockAchievement("perfectionist_streak");
          }
        }
      }

      async function checkSpeedCompletionAchievements(completionTime) {
        // Speed demon: Complete course in under 2 hours (120 minutes)
        if (completionTime <= 120) {
          await checkAndUnlockAchievement("speed_demon");
        }

        // Quick learner: Complete course in under 4 hours (240 minutes)
        if (completionTime <= 240) {
          await checkAndUnlockAchievement("quick_learner");
        }
      }

      async function checkStudyTimeAchievements() {
        const totalTime = courseSession.totalStudyTime;

        // Marathon learner: Study for 8+ hours in a course session
        if (totalTime >= 480) {
          // 8 hours
          await checkAndUnlockAchievement("marathon_learner");
        }

        // Dedicated learner: Study for 4+ hours
        if (totalTime >= 240) {
          // 4 hours
          await checkAndUnlockAchievement("dedicated_learner");
        }
      }

      async function checkCourseStreakAchievements() {
        try {
          // Check for consecutive course completions
          const { data: recentCourses, error } = await supabase
            .from("course_progress")
            .select("completed_at, course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100)
            .order("completed_at", { ascending: false })
            .limit(10);

          if (error || !recentCourses) return;

          // Check for courses completed on consecutive days
          let consecutiveDays = 1;
          for (let i = 1; i < recentCourses.length; i++) {
            const prevDate = new Date(
              recentCourses[i - 1].completed_at
            ).toDateString();
            const currentDate = new Date(
              recentCourses[i].completed_at
            ).toDateString();
            const dayDiff =
              Math.abs(new Date(prevDate) - new Date(currentDate)) /
              (1000 * 60 * 60 * 24);

            if (dayDiff <= 1) {
              consecutiveDays++;
            } else {
              break;
            }
          }

          if (consecutiveDays >= 3) {
            await checkAndUnlockAchievement("learning_streak");
          }
        } catch (error) {
          console.error("Error checking course streak achievements:", error);
        }
      }

      // =====================================================
      // TIME-BASED ACHIEVEMENTS
      // =====================================================
      async function checkTimeBasedAchievements(timestamp) {
        const hour = timestamp.getHours();
        const dayOfWeek = timestamp.getDay();

        // Night owl (after midnight, before 6 AM)
        if (hour >= 0 && hour < 6) {
          await incrementTimeBasedCounter("midnight_sessions", "night_owl");
        }

        // Early bird (4 AM to 6 AM)
        if (hour >= 4 && hour < 6) {
          await incrementTimeBasedCounter("early_sessions", "early_bird");
        }

        // Weekend warrior (Saturday = 6, Sunday = 0)
        if (dayOfWeek === 0 || dayOfWeek === 6) {
          await incrementTimeBasedCounter(
            "weekend_sessions",
            "weekend_warrior"
          );
        }
      }

      async function incrementTimeBasedCounter(counterType, achievementId) {
        try {
          const dateStr = new Date().toISOString().split("T")[0];
          const cacheKey = `${counterType}_${currentUser.id}_${dateStr}`;

          // Prevent multiple increments per day
          if (sessionStorage.getItem(cacheKey)) return;

          // Update counter
         await supabase.rpc('increment_profile_counter', {
  user_id_param: currentUser.id,
  counter_field: counterType,
  increment_value: 1
});

          // Cache to prevent double counting
          sessionStorage.setItem(cacheKey, "true");

          // Check related achievement
          if (achievementId) {
            await checkAndUnlockAchievement(achievementId, true);
          }
        } catch (error) {
          console.error(`Error incrementing ${counterType}:`, error);
        }
      }

      async function checkDailyStreak() {
        try {
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("last_activity, current_streak, last_streak_date")
            .eq("id", currentUser.id)
            .single();

          if (error) throw error;

          const now = new Date();
          const today = now.toDateString();
          const lastActivity = profile.last_activity
            ? new Date(profile.last_activity)
            : null;
          const lastStreakDate = profile.last_streak_date
            ? new Date(profile.last_streak_date).toDateString()
            : null;

          let newStreak = profile.current_streak || 0;
          let shouldUpdateStreak = false;

          if (!lastActivity) {
            // First time user
            newStreak = 1;
            shouldUpdateStreak = true;
          } else {
            const daysSinceLastActivity = Math.floor(
              (now - lastActivity) / (1000 * 60 * 60 * 24)
            );

            if (lastStreakDate === today) {
              // Already counted today's streak
              return newStreak;
            } else if (
              daysSinceLastActivity === 1 ||
              (daysSinceLastActivity === 0 && lastStreakDate !== today)
            ) {
              // Consecutive day or same day but not counted yet
              newStreak += 1;
              shouldUpdateStreak = true;
            } else if (daysSinceLastActivity > 1) {
              // Streak broken
              newStreak = 1;
              shouldUpdateStreak = true;
            }
          }

          if (shouldUpdateStreak) {
            await supabase
              .from("profiles")
              .update({
                current_streak: newStreak,
                last_activity: now.toISOString(),
                last_streak_date: now.toISOString(),
              })
              .eq("id", currentUser.id);

            userStats.current_streak = newStreak;

            showToast(`Daily streak: ${newStreak} days!`, "success");
            await checkStreakAchievements(newStreak);
          }

          return newStreak;
        } catch (error) {
          console.error("Error checking daily streak:", error);
          return 0;
        }
      }

      async function checkStreakAchievements(currentStreak) {
        const streakMilestones = [3, 7, 14, 30, 100, 365];

        for (const milestone of streakMilestones) {
          if (currentStreak >= milestone) {
            await checkAndUnlockAchievement(`streak_${milestone}`);
          }
        }
      }

      // =====================================================
      // USER ACTIVITY LOGGING
      // =====================================================
      async function logUserActivity(activityType, metadata = {}) {
        try {
          const now = new Date();

          const activityData = {
            user_id: currentUser.id,
            activity_type: activityType,
            timestamp: now.toISOString(),
            course_id: COURSE_DATA.id,
            lesson_index: currentLessonIndex,
            session_duration: courseSession.totalStudyTime,
            metadata: JSON.stringify(metadata),
            created_at: now.toISOString(),
          };

          // Try to log to activities table
          const { error } = await supabase
            .from("user_activities")
            .insert([activityData]);

          if (error && error.code !== "42P01") {
            console.warn("Activity logging failed:", error.message);
          }

          // Always update last activity in profile
          await supabase
            .from("profiles")
            .update({ last_activity: now.toISOString() })
            .eq("id", currentUser.id);
        } catch (error) {
          console.error("Error logging user activity:", error);
        }
      }

      // =====================================================
      // NAVIGATION SYSTEM
      // =====================================================
      function updateNavigationButtons() {
        const prevBtn = document.getElementById("prevLessonBtn");
        const nextBtn = document.getElementById("nextLessonBtn");

        if (!prevBtn || !nextBtn) return;

        // Previous button
        prevBtn.disabled = currentLessonIndex === 0;

        // Next button logic
        const isLastLesson =
          currentLessonIndex === COURSE_DATA.lessons.length - 1;
        const canGoNext =
          currentLessonIndex < COURSE_DATA.lessons.length - 1 &&
          canAccessLesson(currentLessonIndex + 1);

        if (isLastLesson) {
          const isCurrentCompleted =
            courseProgress[COURSE_DATA.lessons[currentLessonIndex].id]
              ?.completed;
          nextBtn.disabled = !isCurrentCompleted;
          nextBtn.innerHTML = '<i class="fas fa-trophy"></i> Complete Course';
        } else {
          nextBtn.disabled = !canGoNext;
          nextBtn.innerHTML = 'Next <i class="fas fa-chevron-right"></i>';
        }
      }

      // Navigation button event handlers
      function goToPreviousLesson() {
        if (currentLessonIndex > 0) {
          trackLessonTime(); // Track time spent on current lesson
          currentLessonIndex--;
          loadLesson(currentLessonIndex);
        }
      }

      function goToNextLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          const canGoNext = canAccessLesson(currentLessonIndex + 1);
          if (canGoNext) {
            trackLessonTime();
            currentLessonIndex++;
            loadLesson(currentLessonIndex);
          } else {
            showToast("Complete the current lesson quiz to proceed", "warning");
          }
        } else {
          // Complete course
          completeCourse();
        }
      }

      // =====================================================
      // SIDEBAR FUNCTIONS
      // =====================================================
      function toggleSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.toggle("open");
        if (overlay) overlay.classList.toggle("active");
      }

      function closeSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.remove("open");
        if (overlay) overlay.classList.remove("active");
      }

      // =====================================================
      // ACHIEVEMENT NOTIFICATION SYSTEM
      // =====================================================
      function queueAchievementNotification(achievement) {
        notificationQueue.push(achievement);
        processNotificationQueue();
      }

      function processNotificationQueue() {
        if (isShowingNotification || notificationQueue.length === 0) return;

        isShowingNotification = true;
        const achievement = notificationQueue.shift();
        showAchievementNotification(achievement);

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          isShowingNotification = false;
          processNotificationQueue();
        }, duration + 500);
      }

      function showAchievementNotification(achievement) {
        const notification = document.getElementById("achievementNotification");
        if (!notification) return;

        const icon = document.getElementById("notificationIcon");
        const title = document.getElementById("notificationTitle");
        const description = document.getElementById("notificationDescription");
        const points = document.getElementById("notificationPoints");

        if (icon) {
          icon.innerHTML = `<i class="${achievement.icon}"></i>`;
          icon.className = `notification-icon ${achievement.rarity}`;
        }
        if (title) title.textContent = achievement.name;
        if (description) description.textContent = achievement.description;
        if (points) points.textContent = `+${achievement.points} Points`;

        notification.className = `achievement-notification ${achievement.rarity}`;
        notification.classList.add("show");

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          notification.classList.remove("show");
        }, duration);
      }

      // =====================================================
      // UTILITY FUNCTIONS
      // =====================================================
      function calculateAverageQuizScore() {
        const scores = Object.values(courseProgress)
          .filter((p) => p.completed && p.quizScore)
          .map((p) => p.quizScore);

        if (scores.length === 0) return 0;
        return Math.round(
          scores.reduce((sum, score) => sum + score, 0) / scores.length
        );
      }

      async function resetProgress() {
        if (
          !confirm(
            "Are you sure you want to reset your progress? This action cannot be undone."
          )
        ) {
          return;
        }

        try {
          // Track lesson time before reset
          trackLessonTime();

          // Reset local state
          courseProgress = {};
          currentLessonIndex = 0;
          courseSession = {
            startTime: new Date(),
            totalStudyTime: 0,
            lessonsStarted: 0,
            lessonsCompleted: 0,
            pageLoadTime: new Date(),
            interactionCount: 0,
            lastActivityTime: new Date(),
          };

          // Delete from database
          await supabase
            .from("course_progress")
            .delete()
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Log reset activity
          logUserActivity("progress_reset", {
            course_id: COURSE_DATA.id,
            reset_reason: "manual",
          });

          // Reinitialize
          await saveProgress();
          renderSidebar();
          loadLesson(0);

          showToast("Progress reset successfully", "success");
        } catch (error) {
          console.error("Error resetting progress:", error);
          showToast("Failed to reset progress", "error");
        }
      }

      function copyCode(codeId) {
        const codeElement = document.getElementById(codeId);
        if (!codeElement) return;

        const text = codeElement.textContent;

        navigator.clipboard
          .writeText(text)
          .then(() => {
            showToast("Code copied to clipboard!", "success");

            // Track code copy for achievements
            logUserActivity("code_copied", {
              code_section: codeId,
              lesson_id: COURSE_DATA.lessons[currentLessonIndex].id,
            });
          })
          .catch((err) => {
            console.error("Failed to copy code:", err);
            showToast("Failed to copy code", "error");

            // Fallback for older browsers
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            try {
              document.execCommand("copy");
              showToast("Code copied to clipboard!", "success");
            } catch (fallbackError) {
              showToast(
                "Copy failed - please select and copy manually",
                "error"
              );
            }
            document.body.removeChild(textArea);
          });
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // =====================================================
      // UI FEEDBACK SYSTEMS
      // =====================================================
      function showToast(message, type = "success") {
        const toast = document.getElementById("toast");
        const messageEl = document.getElementById("toastMessage");

        if (!toast || !messageEl) {
          console.log(`Toast: ${message} (${type})`);
          return;
        }

        messageEl.textContent = message;
        toast.className = `toast ${type} show`;

        setTimeout(() => {
          toast.classList.remove("show");
        }, 4000);
      }

      function showLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) loadingScreen.classList.remove("hidden");
      }

      function hideLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) {
          setTimeout(() => {
            loadingScreen.classList.add("hidden");
          }, 1000);
        }
      }

      // =====================================================
      // MUSIC PLAYER INTEGRATION
      // =====================================================
      function initMusicPlayer() {
        const btnText = document.getElementById("music-button-text");
        const icon = document.getElementById("music-icon");
        const dropdown = document.getElementById("music-dropdown-content");

        if (!btnText || !icon || !dropdown) return;

        function setUI(state) {
          btnText.textContent =
            state === "Playing" ? "PAUSE MUSIC" : "STUDY MUSIC";
          icon.className =
            state === "Playing"
              ? "fa-solid fa-circle-pause"
              : "fa-solid fa-music";
        }

        // Load saved music state
        const savedSrc = localStorage.getItem("cybersec_music_src");
        const savedTime = parseFloat(
          localStorage.getItem("cybersec_music_time") || 0
        );

        if (savedSrc) {
          audioPlayer.src = savedSrc;
          audioPlayer.currentTime = savedTime;
          audioPlayer
            .play()
            .then(() => setUI("Playing"))
            .catch(() => setUI("Stopped"));
        }

        // Music button click handler
        document
          .getElementById("music-dropdown")
          .querySelector("button")
          .addEventListener("click", (e) => {
            e.stopPropagation();
            dropdown.style.display =
              dropdown.style.display === "block" ? "none" : "block";

            if (audioPlayer.src && !audioPlayer.paused) {
              audioPlayer.pause();
              setUI("Stopped");
            } else if (audioPlayer.src) {
              audioPlayer.play().then(() => setUI("Playing"));
            }
          });

        // Music selection handlers
        dropdown.querySelectorAll("a[data-src]").forEach((link) => {
          link.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.src = link.dataset.src;
            audioPlayer.play().then(() => setUI("Playing"));
            localStorage.setItem("cybersec_music_src", link.dataset.src);
            dropdown.style.display = "none";
          });
        });

        // Stop music handler
        const stopLink = document.getElementById("stop-music-link");
        if (stopLink) {
          stopLink.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            audioPlayer.removeAttribute("src");
            setUI("Stopped");
            localStorage.removeItem("cybersec_music_src");
            localStorage.removeItem("cybersec_music_time");
            dropdown.style.display = "none";
          });
        }

        // Save music state before page unload
        window.addEventListener("beforeunload", () => {
          if (!audioPlayer.paused && audioPlayer.src) {
            localStorage.setItem("cybersec_music_src", audioPlayer.src);
            localStorage.setItem(
              "cybersec_music_time",
              audioPlayer.currentTime
            );
          }
        });

        // Close dropdown when clicking outside
        window.addEventListener("click", (e) => {
          if (!e.target.closest("#music-dropdown")) {
            dropdown.style.display = "none";
          }
        });
      }

      // Show initial music indicator
      function addMusicIndicator() {
        const musicBtn = document.querySelector("#music-dropdown");
        if (musicBtn) {
          const indicator = document.createElement("div");
          indicator.className = "music-indicator";
          indicator.innerHTML = `<i class="fa-solid fa-music"></i> Try Study Music!`;

          musicBtn.style.position = "relative";
          musicBtn.appendChild(indicator);

          setTimeout(() => indicator.remove(), 3000);
        }
      }

      // Initialize Event Listeners
      function initializeEventListeners() {
        // Navigation buttons
        document
          .getElementById("prevLessonBtn")
          ?.addEventListener("click", goToPreviousLesson);
        document
          .getElementById("nextLessonBtn")
          ?.addEventListener("click", goToNextLesson);

        // Reset progress button
        document
          .getElementById("resetProgressBtn")
          ?.addEventListener("click", resetProgress);

        // Mobile menu toggle
        document
          .getElementById("menuToggle")
          ?.addEventListener("click", toggleSidebar);
        document
          .getElementById("sidebarOverlay")
          ?.addEventListener("click", closeSidebar);

        // Keyboard shortcuts
        document.addEventListener("keydown", handleKeyboardShortcuts);

        // Window resize handler
        window.addEventListener("resize", handleWindowResize);

        // Content interaction tracking
        document.getElementById("contentBody")?.addEventListener(
          "scroll",
          debounce(() => {
            trackUserInteraction();
          }, 1000)
        );
      }

      // Keyboard Shortcuts
      function handleKeyboardShortcuts(e) {
        if (document.querySelector(".quiz-question.active")) return;

        if (e.key === "ArrowLeft" && e.ctrlKey) {
          e.preventDefault();
          goToPreviousLesson();
        } else if (e.key === "ArrowRight" && e.ctrlKey) {
          e.preventDefault();
          goToNextLesson();
        }
      }

      // Window Resize Handler
      function handleWindowResize() {
        if (window.innerWidth > 768) {
          closeSidebar();
        }
      }

      // Debounce Helper
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Initialize responsive behavior
      if (window.innerWidth <= 768) {
        document.getElementById("menuToggle").style.display = "inline-flex";
      }

      // Auto-save progress periodically
      setInterval(async () => {
        if (currentUser && Object.keys(courseProgress).length > 0) {
          await saveProgress();
        }
      }, 60000); // Save every minute

      // System initialization logging
      console.log("CyberSec Academy Course System Initialized");
      console.log("Current Course:", COURSE_DATA.title);
      console.log("Total Lessons:", COURSE_DATA.lessons.length);

      // Google OAuth Integration
      const googleBtn = document.querySelector(".btn-google");
      if (googleBtn) {
        googleBtn.addEventListener("click", async () => {
          const { data, error } = await supabase.auth.signInWithOAuth({
            provider: "google",
            options: {
              redirectTo:
                window.location.origin +
                "/courses/complete-secure-software-development-course",
            },
          });

          if (error) {
            console.error("Google login error:", error.message);
            showToast("Google login failed: " + error.message, "error");
          }
        });
      }

      // Check for existing session
      supabase.auth.getSession().then(({ data }) => {
        if (data.session) {
          console.log("User already logged in:", data.session.user);
          currentUser = data.session.user;
          startCourseSession();
        }
      });

      // Add missing auth modal functions
      function openAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "flex";
        }
      }

      function closeAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Add auth tab switching functionality
      document.getElementById("tabSignIn")?.addEventListener("click", () => {
        document.getElementById("tabSignIn").classList.add("active");
        document.getElementById("tabSignUp").classList.remove("active");
        document.getElementById("signInForm").style.display = "block";
        document.getElementById("signUpForm").style.display = "none";
      });

      document.getElementById("tabSignUp")?.addEventListener("click", () => {
        document.getElementById("tabSignUp").classList.add("active");
        document.getElementById("tabSignIn").classList.remove("active");
        document.getElementById("signUpForm").style.display = "block";
        document.getElementById("signInForm").style.display = "none";
      });

      document
        .getElementById("closeAuthModal")
        ?.addEventListener("click", closeAuthModal);

      // Improved error handling for auth session
      supabase.auth.onAuthStateChange((event, session) => {
        if (event === "SIGNED_IN") {
          currentUser = session.user;
          closeAuthModal();
          startCourseSession();
        } else if (event === "SIGNED_OUT") {
          currentUser = null;
          openAuthModal();
        }
      });

      // Add form submission handlers
      document
        .getElementById("emailSignInForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signInEmail").value;
          const password = document.getElementById("signInPassword").value;

          try {
            const { data, error } = await supabase.auth.signInWithPassword({
              email,
              password,
            });

            if (error) throw error;

            closeAuthModal();
          } catch (error) {
            showToast(error.message, "error");
          }
        });

      document
        .getElementById("emailSignUpForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signUpEmail").value;
          const password = document.getElementById("signUpPassword").value;
          const name = document.getElementById("signUpName").value;

          try {
            const { data, error } = await supabase.auth.signUp({
              email,
              password,
              options: {
                data: {
                  full_name: name,
                },
              },
            });

            if (error) throw error;

            showToast(
              "Account created successfully! Please check your email.",
              "success"
            );
          } catch (error) {
            showToast(error.message, "error");
          }
        });
    </script>
  </body>
</html>

