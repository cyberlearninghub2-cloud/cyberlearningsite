



<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Exo+2:wght@700;800;900&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css"
    />
    <link rel="stylesheet" href="assets/css/coursepages.css">
    <!-- ========== Start: SEO & Schema Enhancement ========== -->
    <title>Elliptic Curve Cryptography Course | CipherHall</title>
    <meta name="description" content="Enroll in our expert-led Elliptic Curve Cryptography (ECC) course. Master the math behind blockchain and TLS, from number theory to post-quantum crypto.">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png" />
    <link rel="shortcut icon" href="/favicon.png" type="image/x-icon" />
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png" />
    <link rel="canonical" href="https://www.cipherhall.com/courses/elliptic-curve-cryptography-complete-course.html" />

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Course",
      "name": "Elliptic Curve Cryptography - Complete Course",
      "description": "A comprehensive, graduate-level course on the theory and practice of Elliptic Curve Cryptography (ECC). Journey from the foundational number theory to advanced topics like pairing-based crypto and post-quantum considerations.",
      "provider": {
        "@type": "Organization",
        "name": "CipherHall",
        "sameAs": "https://www.cipherhall.com"
      },
      "hasCourseInstance": {
        "@type": "CourseInstance",
        "courseMode": "Online",
        "instructor": {
          "@type": "Person",
          "name": "Dr. Anya Sharma"
        }
      }
    }
    </script>
    <!-- ========== End: SEO & Schema Enhancement ========== -->
</head>
  <body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
      <div class="loader-icon">
        <i class="fas fa-graduation-cap"></i>
      </div>
      <div class="loader-text">Loading Course Content...</div>
    </div>

    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- Music Player (fixed at top right) -->
    <div class="header-controls">
      <div class="music-dropdown" id="music-dropdown">
        <button class="btn btn-secondary">
          <span id="music-button-text">STUDY MUSIC</span>
          <i id="music-icon" class="fa-solid fa-music"></i>
        </button>
        <div class="music-dropdown-content" id="music-dropdown-content">
          <a
            href="#"
            data-src="https://www.learningcontainer.com/wp-content/uploads/2020/02/Kalimba.mp3"
            >1. Coffee Shop Vibes</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3"
            >2. City Lights Lofi</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-15.mp3"
            >3. Mellow Thoughts</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-13.mp3"
            >4. Rainy Mood</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3"
            >5. Time Alone</a
          >
          <a href="#" id="stop-music-link"
            ><i class="fa-solid fa-stop-circle"></i> Stop Music</a
          >
        </div>
      </div>

      <button class="btn btn-secondary" id="resetProgressBtn">
        <i class="fas fa-redo"></i>
        Reset Progress
      </button>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal" style="display: none">
      <div class="modal-overlay"></div>
      <div class="modal-content">
        <span class="close" id="closeAuthModal">&times;</span>
        <div class="auth-tabs">
          <button id="tabSignIn" class="auth-tab active">Sign In</button>
          <button id="tabSignUp" class="auth-tab">Sign Up</button>
        </div>
        <div
          id="authLoader"
          style="display: none; text-align: center; padding: 2rem"
        >
          <i
            class="fas fa-spinner fa-spin fa-2x"
            style="color: var(--color-green)"
          ></i>
          <p style="margin-top: 0.5rem">Authenticating...</p>
        </div>
        <div id="signInForm" class="auth-form">
          <h2>Sign In to CipherHall</h2>
          <button id="googleSignIn" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignInForm">
            <input
              type="email"
              id="signInEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signInPassword"
              placeholder="Password"
              required
            />
            <button type="submit" class="btn btn-primary">Sign In</button>
          </form>
        </div>
        <div id="signUpForm" class="auth-form" style="display: none">
          <h2>Join CipherHall</h2>
          <button id="googleSignUp" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignUpForm">
            <input
              type="text"
              id="signUpName"
              placeholder="Full Name"
              required
            />
            <input
              type="email"
              id="signUpEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signUpPassword"
              placeholder="Password (min. 8 characters)"
              required
            />
            <button type="submit" class="btn btn-secondary">
              Create Account
            </button>
          </form>
        </div>
        <div id="authMessage"></div>
      </div>
    </div>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="course-info">
          <h1 class="course-title" id="courseTitle">Loading...</h1>
          <div class="course-progress">
            <div class="progress-header">
              <span class="progress-label">Course Progress</span>
              <span class="progress-percentage" id="courseProgressPercent"
                >0%</span
              >
            </div>
            <div class="progress-bar">
              <div
                class="progress-fill"
                id="courseProgressFill"
                style="width: 0%"
              ></div>
            </div>
            <div class="progress-stats">
              <span id="completedLessons">0</span>
              <span id="totalLessons">0</span>
            </div>
          </div>
          <a href="/dashboard.html" class="back-to-dashboard">
            <i class="fas fa-arrow-left"></i>
            Back to Dashboard
          </a>
        </div>
      </div>

      <nav class="lesson-nav" id="lessonNav">
        <!-- Lessons will be loaded dynamically -->
      </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <header class="content-header">
        <div class="lesson-header">
          <div class="lesson-header-left">
            <span class="lesson-number" id="currentLessonNumber">1</span>
            <h1 class="lesson-header-title" id="currentLessonTitle">
              Loading...
            </h1>
          </div>
          <div class="lesson-actions">
            <button class="mbtn btn-primary" id="menuToggle">
              <i class="fas fa-bars"></i>
            </button>
          </div>
        </div>
      </header>

      <div class="content-body" id="contentBody">
        <div class="lesson-content" id="lessonContent">
          <!-- Lesson content will be loaded dynamically -->
        </div>
      </div>

      <footer class="lesson-navigation">
        <div class="nav-info" id="navInfo">Lesson 1 of 10</div>
        <div class="nav-controls">
          <button class="btn btn-secondary" id="prevLessonBtn" disabled>
            <i class="fas fa-chevron-left"></i>
            Previous
          </button>
          <button class="btn btn-primary" id="nextLessonBtn" disabled>
            Next
            <i class="fas fa-chevron-right"></i>
          </button>
        </div>
      </footer>
    </main>

    <!-- Achievement Notification -->
    <div id="achievementNotification" class="achievement-notification">
      <div class="notification-header">
        <div class="notification-icon" id="notificationIcon">
          <i class="fas fa-trophy"></i>
        </div>
        <div class="notification-content">
          <h3 id="notificationTitle">Achievement Unlocked!</h3>
          <p id="notificationDescription">Description here...</p>
        </div>
      </div>
      <div class="notification-reward" id="notificationReward">
        <i class="fas fa-coins"></i>
        <span id="notificationPoints">+100 Points</span>
      </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast">
      <span id="toastMessage"></span>
    </div>

    <script>
      // =====================================================
      // SYNCHRONIZED COURSE SYSTEM WITH DASHBOARD INTEGRATION
      // =====================================================

      // Supabase Configuration - Replace with your config
      const supabaseUrl = "https://lzcmzulemfubjaksoqor.supabase.co";
      const supabaseKey =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx6Y216dWxlbWZ1Ympha3NvcW9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzMzM5MDgsImV4cCI6MjA3MDkwOTkwOH0.crhPH4YWtRsr1BJTpAQcmPbWSpwIWRbzoI4sRb2_fPI";
      const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

      // =====================================================
      // COURSE DATA STRUCTURE - REPLACE WITH YOUR COURSE JSON
      // =====================================================

      const COURSE_DATA =  {
        "id": "elliptic-curve-cryptography",
        "title": "Elliptic Curve Cryptography - Complete Learning Roadmap",
        "description": "A comprehensive, graduate-level course on the theory and practice of Elliptic Curve Cryptography (ECC). Journey from the foundational number theory to advanced topics like pairing-based crypto and post-quantum considerations.",
        "category": "cryptography",
        "difficulty": "Advanced to Expert",
        "duration": "150 hours",
        "instructor": "Dr. Anya Sharma",
        "lessons": [
            {
                "id": "lesson-1",
                "title": "Mathematical Foundations - Number Theory",
                "duration": "120 min",
                "objectives": [
                    "Understand the role of prime numbers in cryptography.",
                    "Master the principles of modular arithmetic.",
                    "Implement the Extended Euclidean Algorithm to find modular inverses.",
                    "Solve systems of congruences using the Chinese Remainder Theorem.",
                    "Define and identify quadratic residues."
                ],
                "content": {
                    "overview": "Before we can explore the elegant world of elliptic curves, we must first build a solid foundation in the classical mathematics upon which all public-key cryptography is built. This lesson covers the essential concepts of number theory, from prime numbers to the intricacies of modular arithmetic, that are the fundamental building blocks of ECC.",
                    "sections": [
                        {
                            "title": "Prime Numbers and Modular Arithmetic",
                            "content": "<p>Public-key cryptography operates not on the infinite set of real numbers, but in a finite, cyclical world defined by a large prime number. This is the world of **modular arithmetic**.</p><p>Think of a clock. If it's 10 o'clock and you add 4 hours, the time is 2 o'clock, not 14. This is arithmetic 'modulo 12'. In cryptography, we do the same thing, but with a massive prime number instead of 12. This creates a finite mathematical space where operations are predictable but also have unique properties that make cryptography possible.</p>",
                            "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "GCD and the Extended Euclidean Algorithm",
                            "content": "<p>The Greatest Common Divisor (GCD) of two integers is the largest integer that divides them both. The Extended Euclidean Algorithm is a method for finding the GCD, but more importantly, it allows us to find the **modular multiplicative inverse**.</p><p>The modular inverse of a number `a` (modulo `n`) is a number `b` such that `(a * b) mod n = 1`. This is the equivalent of 'division' in modular arithmetic and is a critical operation in almost all public-key crypto systems, including the point addition formulas we will use in ECC.</p>",
                            "image": "https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Chinese Remainder Theorem (CRT)",
                            "content": "<p>The CRT is a powerful theorem that allows us to solve a system of simultaneous congruences. It provides a way to reconstruct a large number from its remainders when divided by smaller, coprime numbers.</p><p><strong>Real-world Example:</strong> The RSA algorithm, a predecessor to ECC, uses the CRT to dramatically speed up its decryption process. By performing the decryption modulo two smaller prime factors instead of one massive number, the overall computation becomes about four times faster. While not directly used in the core ECC algorithms, understanding the CRT is essential for a complete picture of number theory in cryptography.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Modular Exponentiation (Square-and-Multiply)",
                            "language": "python",
                            "code": "# This function implements modular exponentiation, a fundamental operation in crypto.\n# It calculates (base^exponent) % modulus efficiently, even for massive numbers.\n\ndef modular_pow(base, exponent, modulus):\n    result = 1\n    base %= modulus\n    while exponent > 0:\n        # If exponent is odd, multiply base with result\n        if exponent % 2 == 1:\n            result = (result * base) % modulus\n        # Exponent must be even now\n        exponent = exponent >> 1 # equivalent to exponent //= 2\n        base = (base * base) % modulus\n    return result\n\n# Example: Calculate 3^12345 mod 789\nresult = modular_pow(3, 12345, 789)\nprint(f\"3^12345 mod 789 = {result}\")"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "The world of public-key cryptography primarily operates using what kind of arithmetic?",
                            "options": [
                                "Standard integer arithmetic",
                                "Floating-point arithmetic",
                                "Modular arithmetic",
                                "Boolean algebra"
                            ],
                            "correct": 2,
                            "explanation": "Modular arithmetic creates a finite, cyclical mathematical space (a 'finite field') which has the properties necessary for building secure cryptographic systems."
                        },
                        {
                            "id": 2,
                            "question": "The Extended Euclidean Algorithm is primarily used to find what?",
                            "options": [
                                "Prime numbers",
                                "The square root of a number",
                                "The modular multiplicative inverse of a number",
                                "The logarithm of a number"
                            ],
                            "correct": 2,
                            "explanation": "The modular inverse is the equivalent of 'division' in modular arithmetic. The Extended Euclidean Algorithm is the efficient method for calculating it, and it is a critical operation in ECC."
                        },
                        {
                            "id": 3,
                            "question": "What is the purpose of the Miller-Rabin algorithm?",
                            "options": [
                                "To encrypt data.",
                                "To solve systems of equations.",
                                "To perform a probabilistic test to determine if a very large number is prime.",
                                "To calculate a greatest common divisor."
                            ],
                            "correct": 2,
                            "explanation": "Generating very large prime numbers is the first step in creating cryptographic keys. The Miller-Rabin test is a fast and efficient way to check if a chosen large number is likely to be prime."
                        }
                    ]
                }
            },
            {
                "id": "lesson-2",
                "title": "Group Theory and Algebraic Structures",
                "duration": "120 min",
                "objectives": [
                    "Understand the fundamental axioms of a group.",
                    "Differentiate between Abelian and cyclic groups.",
                    "Perform operations in finite fields (GF(p) and GF(2^m)).",
                    "Understand the concept of a group generator.",
                    "Explain the role of irreducible polynomials in binary fields."
                ],
                "content": {
                    "overview": "This lesson introduces the abstract algebra that provides the formal structure for cryptography. We will explore the concept of a 'group'—a set of elements with a defined operation—and the specific types of groups, known as finite fields, that are used to construct elliptic curve cryptosystems. This is the language of modern cryptography.",
                    "sections": [
                        {
                            "title": "Group Theory Fundamentals",
                            "content": "<p>A group is a set of elements, together with an operation, that satisfies four fundamental properties:</p><ol><li><strong>Closure:</strong> If `a` and `b` are in the group, then `a . b` is also in the group.</li><li><strong>Associativity:</strong> `(a . b) . c = a . (b . c)`</li><li><strong>Identity Element:</strong> There is an element `e` such that `a . e = a`.</li><li><strong>Inverse Element:</strong> For every element `a`, there is an inverse `a^-1` such that `a . a^-1 = e`.</li></ul><p>An **Abelian group** is a group that has one additional property: commutativity (`a . b = b . a`).</p>",
                            "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Finite Field Arithmetic",
                            "content": "<p>A finite field is a set with a finite number of elements where you can add, subtract, multiply, and divide. The modular arithmetic we learned in the last lesson forms a finite field.</p><h3>The Two Main Types in ECC:</h3><ul><li><strong>Prime Fields (GF(p) or F_p):</strong> This is the set of integers `{0, 1, 2, ..., p-1}` where `p` is a prime number. All operations are performed modulo `p`. This is the most common type of field used in ECC.</li><li><strong>Binary Fields (GF(2^m)):</strong> The elements of this field are polynomials with coefficients of 0 or 1. Addition is XOR, and multiplication is polynomial multiplication modulo an irreducible polynomial. These were popular in the past for hardware implementations but are less common now.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Cyclic Groups and Generators",
                            "content": "<p>A **cyclic group** is a group that can be generated by a single element. This element is called the **generator** (often denoted as `g`).</p><p><strong>Real-world Example:</strong> The group of integers modulo 5 under addition, `{0, 1, 2, 3, 4}`, is a cyclic group. The element `1` is a generator. By repeatedly adding `1` to itself, you can generate every other element in the group: `1`, `1+1=2`, `1+1+1=3`, `1+1+1+1=4`, `1+1+1+1+1=0`. The security of ECC is based on the fact that the points on an elliptic curve form a cyclic group, and the difficulty of finding out how many times the generator was added to itself to produce a given point.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Finite Field Arithmetic (GF(p))",
                            "language": "python",
                            "code": "# This class demonstrates arithmetic in a prime field GF(p).\n\nclass FieldElement:\n    def __init__(self, value, prime):\n        if not (0 <= value < prime):\n            raise ValueError(\"Value must be between 0 and prime-1.\")\n        self.value = value\n        self.prime = prime\n\n    def __add__(self, other):\n        return FieldElement((self.value + other.value) % self.prime, self.prime)\n\n    def __mul__(self, other):\n        return FieldElement((self.value * other.value) % self.prime, self.prime)\n    \n    def __pow__(self, exponent):\n        # Uses the modular exponentiation function from Lesson 1\n        return FieldElement(modular_pow(self.value, exponent, self.prime), self.prime)\n\n    def __repr__(self):\n        return f\"FieldElement_{self.prime}({self.value})\"\n\n# Example: Operations in GF(19)\np = 19\na = FieldElement(7, p)\nb = FieldElement(12, p)\n\nprint(f\"{a} + {b} = {a + b}\")\nprint(f\"{a} * {b} = {a * b}\")"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "A set of elements with an operation that satisfies closure, associativity, identity, and inverse is known as a:",
                            "options": [
                                "Field",
                                "Ring",
                                "Group",
                                "Set"
                            ],
                            "correct": 2,
                            "explanation": "These four axioms are the fundamental definition of a mathematical group. ECC relies on the fact that elliptic curve points form a group."
                        },
                        {
                            "id": 2,
                            "question": "An Abelian group is a group that also has which property?",
                            "options": [
                                "It has a finite number of elements.",
                                "It is cyclic.",
                                "Commutativity (a . b = b . a).",
                                "It has a generator."
                            ],
                            "correct": 2,
                            "explanation": "Commutativity is the key property of an Abelian group. The group of points on an elliptic curve is an Abelian group."
                        },
                        {
                            "id": 3,
                            "question": "A single element `g` that can be used to generate every other element in a group by repeatedly applying the group operation is known as a:",
                            "options": [
                                "Identity element",
                                "Inverse element",
                                "Generator",
                                "Prime element"
                            ],
                            "correct": 2,
                            "explanation": "The generator is a fundamental concept in cyclic groups and is the basis for discrete logarithm-based cryptography, including ECC. In ECC, the generator is a specific point on the curve called the 'base point'."
                        }
                    ]
                }
            },
            {
                "id": "lesson-3",
                "title": "Elliptic Curves - Basic Theory",
                "duration": "120 min",
                "objectives": [
                    "Define an elliptic curve using the Weierstrass equation.",
                    "Understand the geometric interpretation of point addition and doubling.",
                    "Apply the algebraic formulas for point addition and doubling.",
                    "Define the identity element (the point at infinity).",
                    "Prove that the points on an elliptic curve form a group."
                ],
                "content": {
                    "overview": "This lesson introduces the central object of our study: the elliptic curve. We will define what an elliptic curve is, visualize its beautiful geometric properties, and then translate that geometry into a set of algebraic formulas. We will define an 'addition' operation for the points on the curve and show that this operation satisfies the group axioms, forming the mathematical foundation of ECC.",
                    "sections": [
                        {
                            "title": "Definition of Elliptic Curves",
                            "content": "<p>An elliptic curve is the set of points `(x, y)` that satisfy a specific type of equation. For cryptography, we almost always use the **short Weierstrass form**:</p><p style=\"text-align:center; font-size:1.5em; font-family: 'Times New Roman', serif;\"><i>y<sup>2</sup> = x<sup>3</sup> + ax + b</i></p><p>The constants `a` and `b` define the specific shape of the curve. To be a valid, non-singular curve suitable for cryptography, it must satisfy the condition `4a^3 + 27b^2 ≠ 0`.</p>",
                            "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "The Elliptic Curve Group Law: A Geometric View",
                            "content": "<p>The magic of elliptic curves is that we can define a group operation on its points. We call this operation 'addition'.</p><h3>Geometric Point Addition (P + Q = R):</h3><ol><li>Take two distinct points on the curve, `P` and `Q`.</li><li>Draw a straight line through them. This line will intersect the curve at exactly one other point. Call this point `-R`.</li><li>Reflect the point `-R` across the x-axis to get the point `R`. This is the result of `P + Q`.</li></ol><h3>Geometric Point Doubling (P + P = R):</h3><ol><li>Take a single point `P`.</li><li>Draw the tangent line to the curve at point `P`. This line will intersect the curve at exactly one other point, `-R`.</li><li>Reflect `-R` across the x-axis to get `R`. This is the result of `2P`.</li></ol>",
                            "image": "https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "The Identity Element and Algebraic Formulas",
                            "content": "<p>What happens if the line is vertical? It doesn't intersect the curve a third time. To solve this, we define an identity element, a conceptual point called the **point at infinity** (denoted `O`). All vertical lines pass through `O`.</p><p>While the geometry is beautiful, computers work with algebra. The geometric rules can be translated into a set of algebraic formulas that give the coordinates of the resulting point `R` based on the coordinates of `P` and `Q` and the slope of the line between them. These formulas are the core of any ECC implementation.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Basic Elliptic Curve Implementation (Point Addition)",
                            "language": "python",
                            "code": "# This is a conceptual implementation of ECC point addition over real numbers.\n# NOTE: Real ECC uses finite fields, which we'll cover next.\n\ndef point_addition(P, Q, a, b):\n    # P = (x1, y1), Q = (x2, y2)\n    x1, y1 = P\n    x2, y2 = Q\n\n    # Handle identity cases\n    if P is None: return Q\n    if Q is None: return P\n\n    # Handle inverse case (vertical line)\n    if x1 == x2 and y1 == -y2:\n        return None # Point at infinity\n\n    # Calculate the slope of the line\n    if P == Q: # Point doubling\n        slope = (3 * x1**2 + a) / (2 * y1)\n    else: # Point addition\n        slope = (y2 - y1) / (x2 - x1)\n\n    # Calculate the coordinates of the result R = (x3, y3)\n    x3 = slope**2 - x1 - x2\n    y3 = slope * (x1 - x3) - y1\n\n    return (x3, y3)\n\n# Example on the curve y^2 = x^3 - 7x + 10\na, b = -7, 10\nP = (1, 2)\nQ = (3, 4)\n\nR = point_addition(P, Q, a, b)\nprint(f\"{P} + {Q} = {R}\")"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "The standard equation for an elliptic curve used in cryptography is the:",
                            "options": [
                                "Pythagorean theorem",
                                "Quadratic formula",
                                "Short Weierstrass form (y^2 = x^3 + ax + b)",
                                "Linear equation (y = mx + b)"
                            ],
                            "correct": 2,
                            "explanation": "The short Weierstrass equation is the fundamental definition of the elliptic curves that are used for most ECC standards."
                        },
                        {
                            "id": 2,
                            "question": "In the geometric group law, how is the 'addition' of two distinct points P and Q defined?",
                            "options": [
                                "By adding their x and y coordinates.",
                                "By drawing a line through P and Q, finding the third intersection point, and reflecting it across the x-axis.",
                                "By finding the midpoint between P and Q.",
                                "By drawing a tangent line at P."
                            ],
                            "correct": 1,
                            "explanation": "This chord-and-tangent rule is the beautiful geometric basis for the group operation. The reflection across the x-axis is what ensures the group law's associativity."
                        },
                        {
                            "id": 3,
                            "question": "What is the identity element for the elliptic curve group?",
                            "options": [
                                "The point (0,0)",
                                "The point (1,1)",
                                "A conceptual point called the 'point at infinity'",
                                "There is no identity element."
                            ],
                            "correct": 2,
                            "explanation": "The point at infinity is the special identity element that makes the group law work for all cases, such as adding a point to its inverse (which results in a vertical line)."
                        }
                    ]
                }
            },
            {
                "id": "lesson-4",
                "title": "Elliptic Curves over Finite Fields",
                "duration": "120 min",
                "objectives": [
                    "Adapt the elliptic curve equations and group law for finite fields (GF(p) and GF(2^m)).",
                    "Understand the concept of the order of a curve and its importance.",
                    "Use Hasse's theorem to bound the number of points on a curve.",
                    "Define the cofactor of a curve.",
                    "Implement and use point compression techniques."
                ],
                "content": {
                    "overview": "Real-world cryptography cannot operate on the continuous plane of real numbers. This lesson takes the theory from the previous lesson and applies it to the finite, modular world of finite fields. We will learn how to define and operate on elliptic curves over GF(p), how to count the number of points on these curves, and why these properties are critical for building a secure cryptosystem.",
                    "sections": [
                        {
                            "title": "Elliptic Curves over GF(p)",
                            "content": "<p>When we move to a prime field `GF(p)`, the curve is no longer a continuous line. It becomes a discrete set of points `(x, y)` where `x` and `y` are integers between `0` and `p-1`, and the Weierstrass equation `y^2 ≡ x^3 + ax + b (mod p)` holds true.</p><p>The group law remains the same conceptually, but all the arithmetic is now performed modulo `p`. For example, division is replaced by multiplication with the modular inverse, which is found using the Extended Euclidean Algorithm.</p>",
                            "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Point Counting and Curve Order",
                            "content": "<p>The **order** of the elliptic curve group is the total number of points on the curve (including the point at infinity). A secure curve must have a very large number of points. **Hasse's theorem** provides a tight bound on this number, stating that the number of points `N` on a curve over `GF(p)` is very close to `p+1`.</p><p>The order of the group, and the order of the subgroup generated by the base point `G`, must be a large prime number to be resistant to attacks like the Pohlig-Hellman algorithm.</p>",
                            "image": "https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Point Compression",
                            "content": "<p>A point on a curve `(x, y)` is represented by two large numbers. Point compression is a technique to save bandwidth by transmitting only the x-coordinate and one extra bit.</p><p><strong>Real-world Example:</strong> The equation is `y^2 ≡ x^3 + ax + b (mod p)`. For any valid `x`, there are two possible values for `y`: one positive and one negative (modulo p). Point compression works by transmitting the `x` coordinate, plus one bit to indicate whether the `y` coordinate is the 'even' or 'odd' solution. The receiving party can then use the `x` coordinate to calculate `y^2` and then find the correct square root based on the extra bit. This effectively cuts the size of a public key in half.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "ECC over Prime Fields Implementation",
                            "language": "python",
                            "code": "# This is a conceptual implementation of ECC over a prime field GF(p).\n\ndef modular_inverse(n, prime):\n    # Uses the Extended Euclidean Algorithm to find the inverse of n mod prime\n    # ... (implementation from Lesson 1) ...\n    return inverse\n\ndef point_addition_gf_p(P, Q, a, p):\n    x1, y1 = P\n    x2, y2 = Q\n\n    # Calculate the slope, now using modular arithmetic\n    # Division (/) is replaced by multiplication with the modular inverse.\n    if P == Q: # Point doubling\n        numerator = (3 * x1**2 + a) % p\n        denominator = modular_inverse(2 * y1, p)\n    else: # Point addition\n        numerator = (y2 - y1) % p\n        denominator = modular_inverse(x2 - x1, p)\n    \n    slope = (numerator * denominator) % p\n\n    # Calculate the new coordinates using modular arithmetic\n    x3 = (slope**2 - x1 - x2) % p\n    y3 = (slope * (x1 - x3) - y1) % p\n\n    return (x3, y3)\n\n# Example on the curve y^2 = x^3 + 2x + 3 over GF(97)\np = 97\na = 2\nb = 3\nP = (3, 6)\nQ = (10, 22)\n\nR = point_addition_gf_p(P, Q, a, p)\nprint(f\"{P} + {Q} = {R} (mod {p})\")"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "When defining an elliptic curve over a prime field GF(p), all the arithmetic in the group law formulas is performed:",
                            "options": [
                                "Using real numbers",
                                "Modulo p",
                                "Using complex numbers",
                                "Modulo 12"
                            ],
                            "correct": 1,
                            "explanation": "Moving to a finite field means all standard arithmetic operations (addition, multiplication, division) are replaced by their modular equivalents. Division becomes multiplication by the modular inverse."
                        },
                        {
                            "id": 2,
                            "question": "The total number of points on an elliptic curve over a finite field is known as the:",
                            "options": [
                                "Cofactor",
                                "Discriminant",
                                "Order of the curve",
                                "Generator"
                            ],
                            "correct": 2,
                            "explanation": "The order of the curve is a critical security parameter. It must be a very large number, and the order of the subgroup we use must be a large prime, to make the ECDLP difficult."
                        },
                        {
                            "id": 3,
                            "question": "What is the primary benefit of point compression?",
                            "options": [
                                "It makes the point addition calculations faster.",
                                "It reduces the bandwidth required to transmit a public key by roughly half.",
                                "It makes the curve more secure.",
                                "It increases the order of the curve."
                            ],
                            "correct": 1,
                            "explanation": "Point compression allows you to transmit just the x-coordinate and one extra bit, instead of both the full x and y coordinates. This is a significant saving in applications where bandwidth is constrained."
                        }
                    ]
                }
            },
            {
                "id": "lesson-5",
                "title": "Scalar Multiplication Algorithms",
                "duration": "120 min",
                "objectives": [
                    "Understand that scalar multiplication is the core operation of ECC.",
                    "Implement the basic double-and-add method.",
                    "Optimize scalar multiplication using the binary method and Non-Adjacent Form (NAF).",
                    "Analyze the security and efficiency of the Montgomery ladder.",
                    "Discuss the use of precomputation to speed up calculations."
                ],
                "content": {
                    "overview": "Scalar multiplication is the fundamental one-way function of elliptic curve cryptography. It is easy to perform in one direction but incredibly difficult to reverse, and this asymmetry is the source of ECC's security. This lesson covers the key algorithms used to perform scalar multiplication efficiently and securely.",
                    "sections": [
                        {
                            "title": "Scalar Multiplication",
                            "content": "<p>Scalar multiplication is the process of adding a point `P` to itself `k` times. The result is denoted as `kP`.</p><p style=\"text-align:center; font-size:1.5em; font-family: 'Times New Roman', serif;\"><i>kP = P + P + ... + P (k times)</i></p><p>This is the core operation in ECC. For example, to generate a public key, you multiply the generator point `G` by a secret, random integer `d` (the private key). The result, `Q = dG`, is the public key. It is easy to calculate `Q` if you know `d` and `G`, but it is computationally infeasible to find `d` if you only know `Q` and `G`. This is the Elliptic Curve Discrete Logarithm Problem (ECDLP).</p>",
                            "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "The Double-and-Add Method",
                            "content": "<p>You should never calculate `kP` by naively adding `P` to itself `k` times. This would be incredibly slow. Instead, we use an efficient algorithm called 'double-and-add'.</p><h3>The Algorithm:</h3><p>It works by looking at the binary representation of the scalar `k`. You start with a result equal to the identity. You scan the bits of `k` from left to right. For every bit, you double the current result. If the current bit is `1`, you also add the original point `P`.</p><p><strong>Real-world Example: Calculate 13P.</strong></p><ol><li>The binary representation of 13 is `1101`.</li><li>Start with the leftmost bit (`1`): Result = `P`.</li><li>Next bit (`1`): Double the result (`2P`), then add `P`. Result = `3P`.</li><li>Next bit (`0`): Double the result. Result = `6P`.</li><li>Next bit (`1`): Double the result (`12P`), then add `P`. Result = `13P`.</li></ol><p>This requires only 3 doublings and 3 additions, instead of 12 additions. This is exponentially faster for the large numbers used in real cryptography.</p>",
                            "image": "https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "The Montgomery Ladder",
                            "content": "<p>The double-and-add method has a problem: its operations depend on the bits of the secret scalar `k`. It performs an 'add' for a `1` bit, but not for a `0` bit. This difference can be detected through a **side-channel attack** (like power analysis), which could leak the private key.</p><p>The **Montgomery ladder** is a special algorithm for scalar multiplication that is designed to be resistant to these attacks. The key property is that it performs the *exact same sequence of operations* regardless of whether the bit of the scalar is a `0` or a `1`. This constant-time behavior makes it much more resistant to simple side-channel analysis.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Basic Scalar Multiplication (Double-and-Add)",
                            "language": "python",
                            "code": "# This is a conceptual implementation of the double-and-add algorithm.\n# It assumes we have 'point_addition_gf_p' and 'point_doubling_gf_p' functions.\n\ndef scalar_multiply(k, P, a, p):\n    \"\"\"Calculates kP using the double-and-add method.\"\"\"\n    # Get the binary representation of the scalar k, without the '0b' prefix.\n    k_binary = bin(k)[2:]\n    \n    # Start with the first bit. The result is the point itself.\n    result = P\n    \n    # Iterate through the remaining bits from left to right.\n    for bit in k_binary[1:]:\n        # Always double\n        result = point_doubling_gf_p(result, a, p)\n        \n        # If the bit is 1, also add\n        if bit == '1':\n            result = point_addition_gf_p(result, P, a, p)\n            \n    return result\n\n# Example on the curve y^2 = x^3 + 2x + 3 over GF(97)\np = 97\na = 2\nP = (3, 6)\nk = 13\n\n# result_point = scalar_multiply(k, P, a, p)\n# print(f\"{k} * {P} = {result_point}\")"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "In ECC, the operation of adding a point P to itself k times is known as:",
                            "options": [
                                "Point addition",
                                "Scalar multiplication",
                                "Point doubling",
                                "Modular inverse"
                            ],
                            "correct": 1,
                            "explanation": "This is the core one-way function of ECC. The integer 'k' is the scalar, and 'P' is the point being multiplied."
                        },
                        {
                            "id": 2,
                            "question": "The 'double-and-add' algorithm is an efficient method for performing what operation?",
                            "options": [
                                "Finding the modular inverse.",
                                "Generating a prime number.",
                                "Scalar multiplication.",
                                "Adding two points."
                            ],
                            "correct": 2,
                            "explanation": "The double-and-add algorithm is exponentially faster than naive addition and is the standard way to perform scalar multiplication."
                        },
                        {
                            "id": 3,
                            "question": "What is the primary security advantage of using the Montgomery ladder for scalar multiplication?",
                            "options": [
                                "It is faster than double-and-add.",
                                "It is easier to implement.",
                                "It performs a constant-time sequence of operations, making it resistant to simple side-channel attacks.",
                                "It works on more types of curves."
                            ],
                            "correct": 2,
                            "explanation": "The Montgomery ladder's constant-time property is its key security feature. By performing the same operations for every bit of the secret key, it avoids leaking information through side channels like power consumption or timing."
                        }
                    ]
                }
            },
            {
                "id": "lesson-6",
                "title": "Elliptic Curve Standards and Parameters",
                "duration": "90 min",
                "objectives": [
                    "Identify the most common standard elliptic curves, including those from NIST, Brainpool, and SEC.",
                    "Understand the parameters that define a specific elliptic curve.",
                    "Learn about the special properties and design of Curve25519 and Ed25519.",
                    "Perform domain parameter validation to ensure a curve is secure.",
                    "Discuss the importance of using standardized, well-vetted curves."
                ],
                "content": {
                    "overview": "You should never, ever design your own cryptographic curve. This lesson covers the standardized, publicly-vetted curves that are used in the real world. We will explore the domain parameters that define these curves and discuss the specific properties of the popular NIST and Curve25519 families of curves.",
                    "sections": [
                        {
                            "title": "Domain Parameters",
                            "content": "<p>An elliptic curve is not just its equation. A full cryptosystem requires a set of **domain parameters**.</p><h3>The Six Parameters:</h3><ol><li><strong>`a`, `b`</strong>: The coefficients of the Weierstrass equation.</li><li><strong>`p`</strong>: The prime that defines the finite field.</li><li><strong>`G`</strong>: A specific point on the curve, the 'base point' or 'generator'.</li><li><strong>`n`</strong>: The order of the subgroup generated by `G`. This must be a large prime.</li><li><strong>`h`</strong>: The cofactor, which is the total number of points on the curve divided by `n`.</li></ol><p>These parameters must be carefully chosen to ensure the curve is secure. Using a curve with poorly chosen parameters can make it vulnerable to attack.</p>",
                            "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Standardized Curves (NIST, Brainpool, SEC)",
                            "content": "<p>To ensure security and interoperability, several standards bodies have published sets of pre-defined, well-vetted domain parameters.</p><h3>Major Standards:</h3><ul><li><strong>NIST (FIPS 186-4):</strong> The US National Institute of Standards and Technology. Their curves (P-256, P-384, P-521) are the most widely used in the world, supported by virtually all web browsers for TLS.</li><li><strong>Brainpool:</strong> A set of curves published by the German federal cybersecurity agency.</li><li><strong>SEC (Standards for Efficient Cryptography):</strong> Published the parameters for `secp256k1`, the curve that was famously chosen for use in Bitcoin.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Curve25519 and Ed25519",
                            "content": "<p>Designed by Daniel J. Bernstein, these are a more modern set of curves that have become extremely popular due to their design for both high performance and high security.</p><p><strong>Real-world Example:</strong> The popular instant messaging app Signal uses the Ed25519 signature scheme as part of its end-to-end encryption protocol. The Curve25519 key exchange protocol is also used in many modern applications.</p><h3>Key Advantages:</h3><ul><li><strong>Performance:</strong> They use a special Montgomery and Edwards curve form that allows for extremely fast computations.</li><li><strong>Security by Design:</strong> They are specifically designed to be resistant to a wide range of implementation bugs and side-channel attacks. For example, they are not vulnerable to timing attacks.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Standard Curve Implementations (Python)",
                            "language": "python",
                            "code": "# This code shows the domain parameters for the 'secp256k1' curve used by Bitcoin.\n\n# The prime that defines the field.\np = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F\n\n# The coefficients of the curve y^2 = x^3 + ax + b\na = 0\nb = 7\n\n# The x and y coordinates of the base point G\nGx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798\nGy = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8\n\n# The order of the subgroup generated by G\nn = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n\n# The cofactor\nh = 1\n\n# An ECC library would use these specific, standardized numbers to perform all its\n# cryptographic operations for the secp256k1 curve."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "The six values (a, b, p, G, n, h) that define a specific elliptic curve for cryptography are known as the:",
                            "options": [
                                "Domain parameters",
                                "Weierstrass equation",
                                "Group law",
                                "Public key"
                            ],
                            "correct": 0,
                            "explanation": "The domain parameters are the complete set of public values that define a specific, standardized curve and are required for all parties to perform cryptographic operations."
                        },
                        {
                            "id": 2,
                            "question": "The `secp256k1` curve is most famously used in which application?",
                            "options": [
                                "The TLS protocol",
                                "The Signal messaging app",
                                "Bitcoin",
                                "Windows BitLocker"
                            ],
                            "correct": 2,
                            "explanation": "Satoshi Nakamoto chose the `secp256k1` curve, defined by the SECG, for use in Bitcoin's digital signature algorithm (ECDSA)."
                        },
                        {
                            "id": 3,
                            "question": "What is the primary reason for using a standardized, well-vetted curve (like those from NIST) instead of creating your own?",
                            "options": [
                                "It is easier to program.",
                                "Standard curves are faster.",
                                "It is extremely difficult to choose a set of parameters that is secure against all known attacks. Standard curves have been subjected to years of intense public scrutiny by cryptographers.",
                                "There is no reason; you should always create your own."
                            ],
                            "correct": 2,
                            "explanation": "This is the cardinal rule of cryptography: don't roll your own crypto. The process of selecting secure curve parameters is incredibly subtle and difficult. Using a standard curve is essential for building a secure system."
                        }
                    ]
                }
            },
            {
                "id": "lesson-7",
                "title": "Elliptic Curve Discrete Logarithm Problem (ECDLP)",
                "duration": "90 min",
                "objectives": [
                    "Define the ECDLP and explain why it is a hard problem.",
                    "Analyze the complexity of generic algorithms like Baby-step Giant-step.",
                    "Understand how Pollard's rho and Pohlig-Hellman algorithms work.",
                    "Explain why the index calculus method, which is effective against prime field discrete logs, does not work for ECC.",
                    "Estimate the difficulty of the ECDLP for a given curve."
                ],
                "content": {
                    "overview": "This lesson focuses on the hard problem that underpins the security of all elliptic curve cryptography: the Elliptic Curve Discrete Logarithm Problem (ECDLP). We will formally define this problem and explore the algorithms that have been developed to try and solve it, understanding why they are all infeasible for a properly chosen curve.",
                    "sections": [
                        {
                            "title": "The ECDLP Definition",
                            "content": "<p>The ECDLP is the 'reverse' of scalar multiplication.</p><p>Given two points on a curve, a base point `G` and another point `Q`, where you know that `Q = dG` for some integer `d`, the problem is to find `d`.</p><ul><li>**Easy Problem (Scalar Multiplication):** Given `d` and `G`, find `Q`.</li><li>**Hard Problem (ECDLP):** Given `Q` and `G`, find `d`.</li></ul><p>The integer `d` is the 'discrete logarithm' of `Q` with respect to the base `G`. All of the best-known algorithms to solve this problem for a secure curve have an exponential time complexity, meaning they would take billions of years to run even with all the computing power on Earth.</p>",
                            "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Generic Algorithms (Baby-Step Giant-Step, Pollard's Rho)",
                            "content": "<p>These are 'generic' algorithms because they work on any finite group, not just elliptic curves. They do not exploit any special properties of the curve itself.</p><ul><li><strong>Baby-Step Giant-Step:</strong> A time-memory tradeoff algorithm that has a time complexity of roughly the square root of the group order `n`.</li><li><strong>Pollard's Rho:</strong> Another square-root algorithm that has the advantage of using very little memory.</li></ul><p>While they are a huge improvement over a naive brute-force search, for a 256-bit curve (where `n` is a 256-bit number), an attack with a complexity of `sqrt(n)` would still require `2^128` operations, which is computationally infeasible.</p>",
                            "image": "https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Why ECC is Efficient",
                            "content": "<p>The reason ECC is so popular is that the best-known attacks against it are these generic, exponential-time algorithms. There are no known 'sub-exponential' attacks against ECC, like there are for RSA and prime field discrete logs.</p><p><strong>Real-world Example: Key Size Comparison.</strong> The index calculus method is a sub-exponential attack that can be used to solve the discrete logarithm problem in a prime field (used by the original Diffie-Hellman). To get a 128-bit security level, the prime field Diffie-Hellman algorithm needs to use a 3072-bit key. To get the same 128-bit security level, ECC only needs to use a 256-bit key. This massive difference in key size for the same level of security is why ECC is so much more efficient and is the standard for mobile and resource-constrained devices.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Pollard's Rho for Elliptic Curves (Conceptual)",
                            "language": "python",
                            "code": "# This is a highly conceptual implementation of Pollard's Rho algorithm to solve ECDLP.\n# It demonstrates the 'random walk' principle of the algorithm.\n\ndef pollards_rho_ecdlp(G, Q, a, p, n):\n    \"\"\"Finds d such that Q = dG.\"\"\"\n    # Partition the points into three sets for the random walk step function\n    # ... (code to define the partitioning) ...\n\n    def step_function(P, a, b):\n        # A function that takes a point and deterministically returns the next point in the walk.\n        # ... (code for the step function) ...\n        return next_P, next_a, next_b\n\n    # Floyd's cycle-finding algorithm ('the tortoise and the hare')\n    # Tortoise starts at Q and takes one step at a time.\n    X_tortoise, a_tortoise, b_tortoise = Q, 0, 1\n    # Hare starts at Q and takes two steps at a time.\n    X_hare, a_hare, b_hare = Q, 0, 1\n\n    for i in range(1, n):\n        # Tortoise moves one step\n        X_tortoise, a_tortoise, b_tortoise = step_function(X_tortoise, a_tortoise, b_tortoise)\n        \n        # Hare moves two steps\n        X_hare, a_hare, b_hare = step_function(X_hare, a_hare, b_hare)\n        X_hare, a_hare, b_hare = step_function(X_hare, a_hare, b_hare)\n\n        if X_tortoise == X_hare:\n            # A collision has been found! We can now solve for d.\n            # d = (a_tortoise - a_hare) * modular_inverse(b_hare - b_tortoise, n)\n            # ... (code to solve the final equation) ...\n            return d"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "Given a base point G and a public key Q, where Q = dG, what is the Elliptic Curve Discrete Logarithm Problem (ECDLP)?",
                            "options": [
                                "To find G",
                                "To find Q",
                                "To find d",
                                "To find the curve equation"
                            ],
                            "correct": 2,
                            "explanation": "The ECDLP is the problem of finding the secret scalar `d` (the private key) given the public point `Q` and the public base point `G`. The presumed difficulty of this problem is the foundation of ECC's security."
                        },
                        {
                            "id": 2,
                            "question": "The best-known algorithms to solve the ECDLP for a secure curve have what kind of time complexity?",
                            "options": [
                                "Polynomial time",
                                "Exponential time",
                                "Logarithmic time",
                                "Constant time"
                            ],
                            "correct": 1,
                            "explanation": "Algorithms like Pollard's rho have a time complexity of roughly sqrt(n), where n is the order of the group. Since n is a 256-bit number, sqrt(n) is about 2^128, which is an exponential number of operations and thus computationally infeasible."
                        },
                        {
                            "id": 3,
                            "question": "Why does ECC provide the same level of security as RSA with a much smaller key size?",
                            "options": [
                                "ECC is a newer algorithm.",
                                "Because the best-known attacks against ECC are fully exponential, while there are more efficient, 'sub-exponential' attacks against RSA.",
                                "ECC uses a larger prime number.",
                                "ECC is not more efficient than RSA."
                            ],
                            "correct": 1,
                            "explanation": "The lack of any known sub-exponential attacks against the ECDLP is the key to ECC's efficiency. It means a smaller key can be used to provide the same level of cryptographic strength, which is a major advantage in resource-constrained environments."
                        }
                    ]
                }
            },
            {
                "id": "lesson-8",
                "title": "ECDH (Elliptic Curve Diffie-Hellman)",
                "duration": "90 min",
                "objectives": [
                    "Explain the complete ECDH key agreement protocol.",
                    "Compute a shared secret using scalar multiplication.",
                    "Understand the role and necessity of a Key Derivation Function (KDF).",
                    "Analyze the security properties of ECDH and its resistance to passive eavesdropping.",
                    "Implement a basic ECDH key exchange."
                ],
                "content": {
                    "overview": "This lesson covers the first major application of ECC: key exchange. We will explore the Elliptic Curve Diffie-Hellman (ECDH) protocol, which allows two parties who have never met to securely agree on a shared secret over an insecure channel. This protocol is the foundation of secure communication for a huge portion of the internet.",
                    "sections": [
                        {
                            "title": "The ECDH Key Agreement Protocol",
                            "content": "<p>ECDH allows two parties, Alice and Bob, to arrive at the same shared secret, even though an eavesdropper, Eve, can see all of their communication.</p><h3>The Protocol Steps:</h3><ol><li><strong>Setup:</strong> Alice and Bob first agree on a public set of domain parameters (the curve, the base point `G`, etc.).</li><li><strong>Alice's Key Generation:</strong> Alice chooses a secret, random integer `d_A` (her private key). She computes her public key `Q_A = d_A * G`.</li><li><strong>Bob's Key Generation:</strong> Bob chooses his own secret, random integer `d_B`. He computes his public key `Q_B = d_B * G`.</li><li><strong>Key Exchange:</strong> Alice sends her public key `Q_A` to Bob. Bob sends his public key `Q_B` to Alice. Eve, the eavesdropper, can see both `Q_A` and `Q_B`.</li><li><strong>Shared Secret Computation:</strong><ul><li>Alice takes Bob's public key `Q_B` and multiplies it by her *private* key `d_A`. The result is `S = d_A * Q_B = d_A * (d_B * G)`.</li><li>Bob takes Alice's public key `Q_A` and multiplies it by his *private* key `d_B`. The result is `S = d_B * Q_A = d_B * (d_A * G)`.</li></ul></li></ol><p>Due to the properties of elliptic curves, both Alice and Bob will arrive at the exact same point `S`, which is their shared secret. Eve, who only knows `Q_A` and `Q_B`, cannot compute `S` because she does not know either of the private keys, and solving for them is the ECDLP.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Key Derivation Functions (KDF)",
                            "content": "<p>The raw shared secret `S` is a point on the curve `(x, y)`. It should never be used directly as an encryption key. Instead, it is passed through a **Key Derivation Function (KDF)**.</p><p>A KDF is a cryptographic hash function (like HKDF based on SHA-256) that takes the shared secret as input and outputs a cryptographically strong, uniformly random symmetric key suitable for use in an algorithm like AES. The KDF ensures that even if the shared secret has some non-random properties, the final encryption key will be secure.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Security Properties",
                            "content": "<p>The standard ECDH protocol is secure against a **passive eavesdropper**. Eve can watch all the traffic, but she cannot determine the shared secret.</p><p>However, it is *not* secure against an active **Man-in-the-Middle (MITM)** attack. An active attacker could intercept the key exchange, substituting their own public key to each party. To defeat this, ECDH is almost always used in an authenticated context, such as the TLS protocol, where the server's public key is signed by a trusted Certificate Authority. This is known as ECDHE (Ephemeral ECDH).</p>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Basic ECDH Implementation (Conceptual)",
                            "language": "python",
                            "code": "# This is a conceptual implementation of the ECDH key exchange.\n# It uses the 'scalar_multiply' function from a previous lesson.\n\n# --- Setup ---\n# Alice and Bob agree on the public curve parameters.\np = 97\na = 2\nG = (3, 6)\n\n# --- Alice ---\n# 1. Alice generates her private key (a random integer).\nd_A = 10\n# 2. Alice computes her public key.\nQ_A = scalar_multiply(d_A, G, a, p)\n# Alice sends Q_A to Bob.\n\n# --- Bob ---\n# 1. Bob generates his private key.\nd_B = 15\n# 2. Bob computes his public key.\nQ_B = scalar_multiply(d_B, G, a, p)\n# Bob sends Q_B to Alice.\n\n# --- Shared Secret Calculation ---\n# Alice computes the secret using her private key and Bob's public key.\nshared_secret_Alice = scalar_multiply(d_A, Q_B, a, p)\n\n# Bob computes the secret using his private key and Alice's public key.\nshared_secret_Bob = scalar_multiply(d_B, Q_A, a, p)\n\nprint(f\"Alice's computed secret: {shared_secret_Alice}\")\nprint(f\"Bob's computed secret:   {shared_secret_Bob}\")\nprint(f\"Do they match? {shared_secret_Alice == shared_secret_Bob}\")"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "The ECDH protocol allows two parties to do what?",
                            "options": [
                                "Send an encrypted email.",
                                "Digitally sign a document.",
                                "Securely agree on a shared secret over an insecure channel.",
                                "Verify their identity."
                            ],
                            "correct": 2,
                            "explanation": "ECDH is a key agreement protocol. Its sole purpose is to allow two parties to compute the same secret value without an eavesdropper being able to do the same. This secret is then typically used to derive a symmetric key for encryption."
                        },
                        {
                            "id": 2,
                            "question": "In ECDH, Alice multiplies her private key `d_A` by Bob's public key `Q_B`. Bob multiplies his private key `d_B` by Alice's public key `Q_A`. Why do they arrive at the same result?",
                            "options": [
                                "It is a coincidence.",
                                "Because `d_A * (d_B * G)` is equal to `d_B * (d_A * G)` due to the properties of scalar multiplication.",
                                "Their private keys are the same.",
                                "Their public keys are the same."
                            ],
                            "correct": 1,
                            "explanation": "This is the mathematical magic of the protocol. Because scalar multiplication is associative and commutative in this context, both parties will independently compute the same final point `d_A * d_B * G`."
                        },
                        {
                            "id": 3,
                            "question": "The standard ECDH protocol is vulnerable to what kind of attack?",
                            "options": [
                                "Passive eavesdropping",
                                "A brute-force attack",
                                "An active Man-in-the-Middle (MITM) attack",
                                "It is not vulnerable to any attacks."
                            ],
                            "correct": 2,
                            "explanation": "A passive attacker cannot break ECDH. However, an active attacker who can intercept and modify the messages can place themselves in the middle of the conversation, establishing one secret with Alice and a different secret with Bob. This is why ECDH must be used with an authentication mechanism, like digital signatures in TLS."
                        }
                    ]
                }
            },
            {
                "id": "lesson-9",
                "title": "ECDSA (Elliptic Curve Digital Signature Algorithm)",
                "duration": "120 min",
                "objectives": [
                    "Understand the purpose of a digital signature.",
                    "Explain the ECDSA signature generation process.",
                    "Perform an ECDSA signature verification.",
                    "Recognize the critical importance of secure nonce generation.",
                    "Implement a deterministic version of ECDSA (RFC 6979) to avoid nonce reuse."
                ],
                "content": {
                    "overview": "This lesson covers the second major application of ECC: digital signatures. We will explore the Elliptic Curve Digital Signature Algorithm (ECDSA), which is used to provide authenticity, integrity, and non-repudiation for digital messages. We will dissect the signing and verification algorithms and focus on the single most critical and historically catastrophic implementation detail: nonce generation.",
                    "sections": [
                        {
                            "title": "The Purpose of Digital Signatures",
                            "content": "<p>A digital signature provides three key security properties for a message:</p><ul><li><strong>Authenticity:</strong> Proves that the message was sent by the person who claims to have sent it.</li><li><strong>Integrity:</strong> Proves that the message has not been altered in transit.</li><li><strong>Non-Repudiation:</strong> The sender cannot later deny that they sent the message.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "The ECDSA Signature and Verification Process",
                            "content": "<p>An ECDSA signature consists of two values, `(r, s)`.</p><h3>Signature Generation:</h3><ol><li>Hash the message `m` to get a digest `z`.</li><li>Generate a cryptographically secure, random number `k` called a **nonce**. This nonce must be unique for every single signature.</li><li>Calculate the point `P = k * G`. The x-coordinate of this point becomes `r`.</li><li>Calculate `s = k^-1 * (z + r * d_A) mod n`, where `k^-1` is the modular inverse of the nonce, `z` is the message digest, and `d_A` is the signer's private key.</li></ol><h3>Signature Verification:</h3><p>A verifier needs the message `m`, the signature `(r, s)`, and the sender's public key `Q_A`. They perform a series of calculations and check if the resulting x-coordinate matches `r`. If it does, the signature is valid.</p>",
                            "image": "https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "The Critical Importance of the Nonce (k)",
                            "content": "<p>The nonce `k` must be a secret, and it must be **perfectly unique** for every signature created with the same private key. If an attacker can ever get two different messages that were signed with the same private key and the *same nonce*, they can algebraically solve for the private key itself.</p><p><strong>Real-world Example: The PlayStation 3 Hack.</strong> In 2010, Sony's PlayStation 3 was famously hacked. The security of the console relied on ECDSA signatures to ensure that only Sony-approved software could run. The hackers discovered that Sony's implementation of ECDSA used a static, constant value for the nonce `k` for every single signature. This is a catastrophic cryptographic mistake. By obtaining two different signed software updates, the hackers were able to use this nonce reuse vulnerability to calculate Sony's master private key for the entire PS3 platform, allowing anyone to sign and run their own custom software on the console.</p><h3>Solution: Deterministic ECDSA (RFC 6979)</h3><p>Because generating true, unbiased random numbers is so difficult, the modern standard is to use **deterministic ECDSA**. This standard uses an algorithm (based on HMAC) to generate a unique, secret nonce `k` in a deterministic way from the private key and the message hash. This eliminates the risk of nonce reuse and makes the signature process much safer.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Deterministic ECDSA (RFC 6979) Implementation",
                            "language": "python",
                            "code": "import hmac\nimport hashlib\n\n# This conceptual script demonstrates the core of RFC 6979 for generating a\n# deterministic nonce 'k'.\n\ndef generate_deterministic_nonce(private_key, message_hash, n):\n    \"\"\"Generates a secure, deterministic nonce k.\"\"\"\n    # n is the order of the curve's subgroup\n\n    # 1. Convert the private key and message hash to byte strings.\n    h1 = message_hash.to_bytes(32, 'big')\n    x = private_key.to_bytes(32, 'big')\n\n    # 2. Initialize K and V for the HMAC-DRBG.\n    #    V is a block of 0x01 bytes.\n    #    K is a block of 0x00 bytes.\n    V = b'\\x01' * 32\n    K = b'\\x00' * 32\n\n    # 3. The HMAC-DRBG process. This is a loop that uses HMAC-SHA256 to generate\n    #    a cryptographically strong 'k' based on the private key and message hash.\n    K = hmac.new(K, V + b'\\x00' + x + h1, hashlib.sha256).digest()\n    V = hmac.new(K, V, hashlib.sha256).digest()\n    K = hmac.new(K, V + b'\\x01' + x + h1, hashlib.sha256).digest()\n    V = hmac.new(K, V, hashlib.sha256).digest()\n\n    while True:\n        V = hmac.new(K, V, hashlib.sha256).digest()\n        k = int.from_bytes(V, 'big')\n\n        # 4. Ensure the generated k is valid (between 1 and n-1).\n        if 1 <= k < n:\n            return k\n        \n        # If not, update K and V and try again.\n        K = hmac.new(K, V + b'\\x00', hashlib.sha256).digest()\n        V = hmac.new(K, V, hashlib.sha256).digest()"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "Which of the following is NOT a security property provided by a digital signature?",
                            "options": [
                                "Authenticity",
                                "Integrity",
                                "Confidentiality",
                                "Non-repudiation"
                            ],
                            "correct": 2,
                            "explanation": "Digital signatures do not encrypt or hide the content of a message; they only provide a guarantee of its authenticity and integrity. Confidentiality is provided by encryption."
                        },
                        {
                            "id": 2,
                            "question": "In ECDSA, reusing the same nonce `k` to sign two different messages with the same private key leads to what?",
                            "options": [
                                "A faster signature.",
                                "A catastrophic failure where the private key itself can be calculated.",
                                "A smaller signature.",
                                "Nothing; this is a secure practice."
                            ],
                            "correct": 1,
                            "explanation": "This is the single most critical implementation mistake in ECDSA. Nonce reuse completely breaks the security of the algorithm and allows for a trivial algebraic recovery of the secret private key. The Sony PS3 hack is the most famous example of this failure."
                        },
                        {
                            "id": 3,
                            "question": "What is the primary purpose of Deterministic ECDSA (RFC 6979)?",
                            "options": [
                                "To make signatures smaller.",
                                "To eliminate the risk of nonce reuse by generating the nonce in a deterministic way from the private key and the message, instead of relying on a potentially flawed random number generator.",
                                "To make the verification process faster.",
                                "To use a different elliptic curve."
                            ],
                            "correct": 1,
                            "explanation": "RFC 6979 was created specifically to solve the problem of nonce reuse. It provides a standard, deterministic method for generating a unique and secret nonce `k` for every signature, removing the dangerous dependency on a perfect random number source."
                        }
                    ]
                }
            },
            {
                "id": "lesson-10",
                "title": "Advanced Signature Schemes",
                "duration": "100 min",
                "objectives": [
                    "Understand the advantages of EdDSA over ECDSA.",
                    "Explain the structure and benefits of Schnorr signatures.",
                    "Analyze how threshold and multi-signatures distribute signing authority.",
                    "Explore the applications of blind and ring signatures for privacy.",
                    "Implement an Ed25519 signature."
                ],
                "content": {
                    "overview": "ECDSA is not the only signature scheme that can be built on elliptic curves. This lesson explores more modern and advanced signature algorithms that offer better performance, stronger security properties, and new features like privacy and distributed authority. We will focus on the widely adopted EdDSA scheme and the promising Schnorr signature.",
                    "sections": [
                        {
                            "title": "EdDSA (Edwards-curve Digital Signature Algorithm)",
                            "content": "<p>EdDSA is a modern signature scheme designed for high performance and security. The most famous variant is **Ed25519**, which uses the same curve as the Curve25519 key exchange.</p><h3>Advantages over ECDSA:</h3><ul><li><strong>Performance:</strong> It is significantly faster than ECDSA.</li><li><strong>Resistant to Side-Channels:</strong> The underlying formulas are designed to be constant-time, making it much less vulnerable to timing attacks.</li><li><strong>Deterministic by Default:</strong> The nonce is generated deterministically, like in RFC 6979, so there is no risk of nonce reuse.</li><li><strong>No Modular Inverse:</strong> The signature calculation does not require the slow and complex modular inverse operation.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Schnorr Signatures",
                            "content": "<p>Schnorr signatures are another type of signature scheme that is simpler and more efficient than ECDSA. A key feature of Schnorr signatures is **linearity**.</p><p>This linearity property allows for a very elegant and efficient way to create **multi-signatures**. A multi-signature allows a group of `n` people to create a single, combined signature on a message, and this signature is only valid if `t` (a threshold) of them participated. This is a very powerful tool for applications like cryptocurrency wallets that require multiple parties to approve a transaction.</p>",
                            "image": "https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Privacy-Enhancing Signatures",
                            "content": "<p>Some signature schemes are designed specifically for privacy.</p><ul><li><strong>Blind Signatures:</strong> A blind signature allows a person to get a message signed by an authority *without the authority ever seeing the content of the message*. This is used in applications like anonymous digital cash and e-voting.</li><li><strong>Ring Signatures:</strong> A ring signature allows a member of a group to sign a message on behalf of the group, but no one can tell *which* member of the group created the signature. It proves that the signature came from a valid member, but it preserves the anonymity of the specific signer. This is famously used in privacy-focused cryptocurrencies like Monero.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Ed25519 Signature Implementation (Conceptual)",
                            "language": "python",
                            "code": "# This is a conceptual Python script showing the high-level steps of Ed25519 signing.\n# It uses the Ed25519 curve and SHA-512.\n\ndef sign_ed25519(private_key, message):\n    # 1. The private key 'd' is a 32-byte secret.\n    \n    # 2. Derive a second 32-byte secret 'prefix' and the public key 'Q' from the private key.\n    #    This is done by hashing the private key.\n    h = hashlib.sha512(private_key).digest()\n    prefix = h[32:]\n    Q = scalar_multiply(int.from_bytes(h[:32], 'little'), G) # Public key\n\n    # 3. Generate the deterministic nonce 'r' by hashing the prefix and the message.\n    r_hash = hashlib.sha512(prefix + message).digest()\n    r = int.from_bytes(r_hash, 'little')\n\n    # 4. Calculate the point R = r * G.\n    R = scalar_multiply(r, G)\n    \n    # 5. Calculate the challenge hash 'h_chal'.\n    h_chal = hashlib.sha512(R.to_bytes() + Q.to_bytes() + message).digest()\n    h_chal_int = int.from_bytes(h_chal, 'little')\n\n    # 6. Calculate the signature value 's'.\n    s = (r + h_chal_int * int.from_bytes(h[:32], 'little')) % n\n\n    # The signature is the combination of R and s.\n    return R.to_bytes(), s.to_bytes(32, 'little')"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "Which modern signature scheme, used in applications like Signal, is known for being fast, deterministic by default, and resistant to many side-channel attacks?",
                            "options": [
                                "RSA",
                                "ECDSA",
                                "EdDSA (e.g., Ed25519)",
                                "DSA"
                            ],
                            "correct": 2,
                            "explanation": "EdDSA was specifically designed to improve upon ECDSA by being more performant and, crucially, much easier to implement securely, eliminating common pitfalls like nonce reuse."
                        },
                        {
                            "id": 2,
                            "question": "The 'linearity' property of Schnorr signatures makes them particularly well-suited for what application?",
                            "options": [
                                "Encryption",
                                "Key exchange",
                                "Efficient multi-signatures and threshold signatures",
                                "Random number generation"
                            ],
                            "correct": 2,
                            "explanation": "The linearity allows multiple signatures and public keys to be aggregated into a single, compact signature and key that is still valid. This is a very powerful feature for multi-party applications."
                        },
                        {
                            "id": 3,
                            "question": "A type of signature that allows a member of a group to sign a message anonymously on behalf of the group is known as a:",
                            "options": [
                                "Blind signature",
                                "Multi-signature",
                                "Ring signature",
                                "Schnorr signature"
                            ],
                            "correct": 2,
                            "explanation": "A ring signature provides anonymity for the signer within a defined group ('ring') of possible signers. It proves the message came from *someone* in the group, but not who."
                        }
                    ]
                }
            },
            {
                "id": "lesson-11",
                "title": "ECC Implementation Optimizations",
                "duration": "90 min",
                "objectives": [
                    "Implement ECC using optimized coordinate systems like Jacobian coordinates.",
                    "Use mixed coordinates to reduce the number of required inversions.",
                    "Apply efficient modular reduction techniques like Barrett and Montgomery reduction.",
                    "Discuss the role of hardware acceleration in ECC performance.",
                    "Benchmark the performance of different implementations."
                ],
                "content": {
                    "overview": "This lesson moves into the world of performance engineering. The straightforward algebraic formulas for ECC are too slow for high-performance applications. We will explore the advanced mathematical and algorithmic optimizations that are used in real-world cryptographic libraries to make ECC operations as fast as possible, without sacrificing security.",
                    "sections": [
                        {
                            "title": "Coordinate System Optimizations (Jacobian Coordinates)",
                            "content": "<p>The most expensive operation in ECC arithmetic is the modular inverse, which is required for the 'division' in the slope calculation. The primary goal of most ECC optimizations is to avoid this inversion.</p><p>This can be done by changing the coordinate system. Instead of representing a point as `(x, y)`, we can represent it in **Jacobian coordinates** as `(X, Y, Z)`, where the original `x = X/Z^2` and `y = Y/Z^3`. The point addition and doubling formulas can be re-written to work entirely in Jacobian coordinates. These new formulas are more complex and require more multiplications, but they require **zero** modular inversions. An entire scalar multiplication can be performed using only Jacobian coordinates, and then a single final inversion is done at the very end to convert the result back to standard affine coordinates.</p>",
                            "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Efficient Modular Reduction",
                            "content": "<p>The second most expensive operation is modular reduction (the `%` operator). For the very large prime numbers used in ECC, this is a slow operation. Specialized algorithms can make it much faster.</p><ul><li><strong>Barrett Reduction:</strong> Speeds up reduction for a fixed modulus by pre-calculating a specific value.</li><li><strong>Montgomery Reduction:</strong> A clever technique that transforms numbers into a 'Montgomery form' where modular multiplication can be performed more efficiently.</li></ul><p>These algorithms are key to high-performance software implementations of ECC.</p>",
                            "image": "https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Hardware Acceleration",
                            "content": "<p>For the highest performance, ECC operations can be implemented directly in hardware.</p><p><strong>Real-world Example:</strong> Modern CPUs from Intel and AMD include the `PCLMULQDQ` instruction, which is specifically designed to accelerate multiplication in a binary field `GF(2^m)`. Cryptographic libraries can take advantage of these special instructions to make binary curve cryptography significantly faster on supported hardware. Many specialized crypto-processors on smart cards and HSMs have dedicated hardware circuits for performing modular arithmetic and even full elliptic curve point operations.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Jacobian Coordinate Implementation (Conceptual)",
                            "language": "python",
                            "code": "# This is a conceptual implementation of point doubling in Jacobian coordinates.\n# Note the absence of any division or modular inverse.\n\ndef point_doubling_jacobian(P, a, p):\n    # P is a point (X, Y, Z)\n    X1, Y1, Z1 = P\n\n    if Y1 == 0:\n        return (1, 1, 0) # The point at infinity\n\n    # The formulas are more complex, but only use multiplication and addition.\n    A = (4 * X1 * Y1**2) % p\n    B = (3 * X1**2 + a * Z1**4) % p\n    \n    X3 = (B**2 - 2 * A) % p\n    Y3 = (B * (A - X3) - 8 * Y1**4) % p\n    Z3 = (2 * Y1 * Z1) % p\n\n    return (X3, Y3, Z3)\n\n# A full scalar multiplication would use these inversion-free formulas for all\n# intermediate steps, and only convert back to affine (x,y) at the very end."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the most computationally expensive operation in standard ECC point addition?",
                            "options": [
                                "Addition",
                                "Multiplication",
                                "The modular inverse (division)",
                                "Squaring"
                            ],
                            "correct": 2,
                            "explanation": "The modular inverse is by far the slowest operation. The primary goal of performance optimizations like Jacobian coordinates is to eliminate the need for inversions during the scalar multiplication."
                        },
                        {
                            "id": 2,
                            "question": "Using Jacobian coordinates `(X, Y, Z)` instead of affine coordinates `(x, y)` allows an implementer to do what?",
                            "options": [
                                "Use a smaller prime number.",
                                "Perform point addition and doubling without any modular inversions.",
                                "Make the curve more secure.",
                                "Make the math simpler."
                            ],
                            "correct": 1,
                            "explanation": "The point of using a different coordinate system like Jacobian is to trade the very slow inversion operation for a larger number of faster multiplication operations, resulting in a significant overall speedup."
                        },
                        {
                            "id": 3,
                            "question": "Barrett and Montgomery reduction are specialized algorithms designed to optimize what?",
                            "options": [
                                "Scalar multiplication",
                                "Point addition",
                                "Modular reduction (the '%' operator)",
                                "Key generation"
                            ],
                            "correct": 2,
                            "explanation": "These are advanced algorithms that can perform the modular reduction operation much more efficiently than the standard division-based method, which is a key part of optimizing high-performance software implementations of ECC."
                        }
                    ]
                }
            },
            {
                "id": "lesson-12",
                "title": "Side-Channel Attack Resistance",
                "duration": "100 min",
                "objectives": [
                    "Understand how timing and power analysis attacks can leak secret keys.",
                    "Analyze implementations for side-channel vulnerabilities.",
                    "Implement countermeasures to defeat these attacks.",
                    "Apply constant-time programming techniques.",
                    "Develop side-channel resistant algorithms like the Montgomery ladder."
                ],
                "content": {
                    "overview": "A cryptographic implementation can be mathematically perfect but still be completely insecure. Side-channel attacks do not attack the math; they attack the physical implementation of the device running the math. This lesson covers the common side-channel attacks that threaten ECC and the crucial countermeasures required to build a physically secure system.",
                    "sections": [
                        {
                            "title": "Timing and Power Analysis Attacks",
                            "content": "<p>These are passive attacks where the attacker observes the physical side effects of a cryptographic operation.</p><h3>The Attacks:</h3><ul><li><strong>Timing Attack:</strong> The attacker carefully measures how long it takes to perform an operation. If the execution time varies depending on the secret key, this can leak information about the key.</li><li><strong>Power Analysis:</strong> The attacker uses an oscilloscope to measure the power consumption of the device. The amount of power used can differ slightly for a multiplication vs. a squaring operation, or for processing a '0' bit vs. a '1' bit. **Simple Power Analysis (SPA)** involves observing a single power trace. **Differential Power Analysis (DPA)** is a much more powerful statistical attack on many traces.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1575235028124-ab6346a5a0a3?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Countermeasures and Constant-Time Programming",
                            "content": "<p>The primary countermeasure against these attacks is to write **constant-time** code. This means the code must take the exact same amount of time and execute the exact same sequence of instructions regardless of the value of any secret data.</p><p><strong>Real-world Example: The Montgomery Ladder.</strong> As discussed in Lesson 5, the standard 'double-and-add' algorithm for scalar multiplication is *not* constant-time. It performs an extra addition for a '1' bit but not for a '0' bit. This leaks the secret key via a timing or power analysis attack. The Montgomery ladder algorithm is a constant-time alternative. It performs the *same* operations for every bit, regardless of its value. This makes it much more resistant to simple side-channel attacks and is why it is used in many high-security implementations.</p>",
                            "image": "https://images.unsplash.com/photo-1552392187-952b1e4f4a3e?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Fault Injection Attacks",
                            "content": "<p>This is an *active* attack where the attacker intentionally introduces an error into the device's operation to cause it to fail in a useful way.</p><h3>Methods:</h3><ul><li><strong>Voltage Glitching:</strong> Inducing a brief, precisely timed glitch in the power supply.</li><li><strong>Clock Glitching:</strong> Inducing a glitch in the CPU's clock signal.</li><li><strong>Lasers:</strong> Using a laser to flip a single bit in a memory cell.</li></ul><p>A successful fault injection can cause the device to skip a security check or to produce a faulty signature that can be used to algebraically solve for the private key.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Constant-Time Implementation (Conceptual)",
                            "language": "c",
                            "code": "// This is a conceptual C snippet demonstrating a non-constant-time vs. a constant-time comparison.\n\n// --- VULNERABLE (Not Constant-Time) ---\nbool insecure_compare(char* a, char* b, int len) {\n    for (int i = 0; i < len; i++) {\n        // This returns immediately on the first mismatch.\n        // The execution time depends on where the first difference is.\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// --- SECURE (Constant-Time) ---\nbool constant_time_compare(char* a, char* b, int len) {\n    int result = 0;\n    for (int i = 0; i < len; i++) {\n        // This performs a bitwise OR for every character.\n        // The loop will ALWAYS execute 'len' times, regardless of the data.\n        // 'result' will only be 0 if all characters were identical.\n        result |= a[i] ^ b[i];\n    }\n    return result == 0;\n}"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "An attack where the adversary carefully measures a device's power consumption to determine its secret key is known as a:",
                            "options": [
                                "Timing attack",
                                "Fault injection attack",
                                "Power analysis side-channel attack",
                                "Buffer overflow"
                            ],
                            "correct": 2,
                            "explanation": "Power analysis is a classic side-channel attack. It doesn't break the cryptographic algorithm itself but exploits the physical information leaked by the hardware that is running the algorithm."
                        },
                        {
                            "id": 2,
                            "question": "What is the primary principle of 'constant-time' programming?",
                            "options": [
                                "The code should run as fast as possible.",
                                "The code's execution time and sequence of instructions should be independent of the value of any secret data.",
                                "The code should use as little memory as possible.",
                                "The code should have a lot of comments."
                            ],
                            "correct": 1,
                            "explanation": "Constant-time programming is the primary software countermeasure against timing and simple power analysis attacks. It ensures that the execution of the code does not leak any information about the secrets it is processing."
                        },
                        {
                            "id": 3,
                            "question": "The Montgomery ladder is a specialized algorithm for what operation?",
                            "options": [
                                "Finding prime numbers",
                                "Solving the ECDLP",
                                "Performing a constant-time scalar multiplication",
                                "Generating random numbers"
                            ],
                            "correct": 2,
                            "explanation": "The Montgomery ladder is a side-channel resistant alternative to the standard double-and-add algorithm. It is specifically designed to be constant-time, making it much more secure against physical attacks."
                        }
                    ]
                }
            },
            {
                "id": "lesson-13",
                "title": "ECC in Practice - TLS/SSL",
                "duration": "90 min",
                "objectives": [
                    "Identify and configure ECC cipher suites in TLS.",
                    "Generate a Certificate Signing Request (CSR) with an ECC key.",
                    "Analyze an ECDHE (Ephemeral Elliptic Curve Diffie-Hellman) key exchange in a TLS handshake.",
                    "Compare the performance of ECC vs. RSA in TLS.",
                    "Understand browser and server compatibility for different curves."
                ],
                "content": {
                    "overview": "This lesson brings our ECC theory into the real world by exploring its most common application: securing web traffic with the Transport Layer Security (TLS) protocol. We will dissect a TLS handshake, see how ECC is used for both authentication and key exchange, and understand why it has become the standard for modern web security.",
                    "sections": [
                        {
                            "title": "ECC Cipher Suites in TLS",
                            "content": "<p>A 'cipher suite' is a named combination of algorithms that the client and server agree to use for a TLS session. A modern ECC cipher suite looks something like this:</p><p>`TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384`</p><h3>Breaking it Down:</h3><ul><li><strong>`ECDHE` (Elliptic Curve Diffie-Hellman Ephemeral):</strong> The key exchange algorithm. This is used to agree on the session key.</li><li><strong>`ECDSA` (Elliptic Curve Digital Signature Algorithm):</strong> The authentication algorithm. The server uses its ECDSA certificate to prove its identity.</li><li><strong>`AES_256_GCM`:</strong> The symmetric encryption algorithm used to encrypt the actual web traffic.</li><li><strong>`SHA384`:</strong> The hash function used for message integrity.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1555949963-ff9fe0c870eb?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Certificates and ECDHE Key Exchange",
                            "content": "<p><strong>Certificates with ECC:</strong> A website's TLS certificate contains its public key. In modern systems, this is an ECC public key (a point on a curve, like NIST P-256) instead of an RSA public key.</p><p><strong>ECDHE Key Exchange:</strong> The 'E' in ECDHE stands for 'ephemeral', which is a critical security feature. It means that for *every single TLS session*, the server and client generate a brand new, temporary ECDH key pair. They use these temporary keys to compute a shared session key. This provides **Perfect Forward Secrecy (PFS)**. If an attacker were to steal the server's long-term private key, they would *still not* be able to decrypt past recorded TLS sessions, because those sessions were encrypted with a temporary key that was discarded.</p>",
                            "image": "https://images.unsplash.com/photo-1548092372-2d987bde898b?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Performance: ECC vs. RSA",
                            "content": "<p>The primary reason for the web's transition to ECC is performance.</p><p><strong>Real-world Example:</strong> To achieve a 128-bit security level, RSA requires a 3072-bit key. ECC requires only a 256-bit key. The signature calculation for a 3072-bit RSA key is significantly slower than for a 256-bit ECDSA key. For a massive web server handling thousands of new TLS handshakes per second, this performance difference is enormous. The smaller key and signature sizes of ECC result in less CPU usage for the server and a faster, snappier experience for the end user.</p>",
                            "image": "https://images.unsplash.com/photo-1504384308090-c894fdcc538d?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "ECC Certificate Generation (OpenSSL)",
                            "language": "bash",
                            "code": "# This script uses the OpenSSL command-line tool to generate an ECC private key\n# and a corresponding Certificate Signing Request (CSR).\n\n# 1. Generate an ECC private key using the NIST P-256 curve (also known as prime256v1).\nopenssl ecparam -name prime256v1 -genkey -out private_key.pem\n\n# 2. Create a Certificate Signing Request (CSR) from the private key.\n# The CSR contains the public key and the identity information (Common Name, etc.)\n# that will be sent to a Certificate Authority (CA) to be signed.\nopenssl req -new -key private_key.pem -out csr.pem -sha256 \\\n    -subj \"/C=US/ST=California/L=Mountain View/O=My Company/CN=www.mycompany.com\"\n\n# 3. An administrator would now send 'csr.pem' to a CA like Let's Encrypt.\n# The CA would verify their identity and send back a signed certificate, which\n# can then be installed on the web server."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "In the cipher suite `TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384`, what is the purpose of the `ECDHE` part?",
                            "options": [
                                "It is the authentication algorithm.",
                                "It is the symmetric encryption algorithm.",
                                "It is the key exchange algorithm used to agree on the session key.",
                                "It is the hash function."
                            ],
                            "correct": 2,
                            "explanation": "ECDHE (Elliptic Curve Diffie-Hellman Ephemeral) is the key agreement protocol. ECDSA is used for authentication, and AES is used for the bulk encryption."
                        },
                        {
                            "id": 2,
                            "question": "What is the primary benefit of using an 'ephemeral' key exchange like ECDHE?",
                            "options": [
                                "It is faster.",
                                "It provides 'Perfect Forward Secrecy' (PFS), meaning the compromise of the server's long-term private key does not compromise past session keys.",
                                "It uses a stronger curve.",
                                "It is easier to implement."
                            ],
                            "correct": 1,
                            "explanation": "PFS is a critical security property. By generating a temporary, single-use key for every session, ECDHE ensures that even a full compromise of the server's private key cannot be used to retrospectively decrypt past traffic."
                        },
                        {
                            "id": 3,
                            "question": "What is the main reason that ECC has largely replaced RSA for authentication and key exchange in TLS?",
                            "options": [
                                "RSA was found to be completely broken.",
                                "ECC provides the same level of security with much smaller key sizes, resulting in a significant performance improvement (faster handshakes).",
                                "ECC is older than RSA.",
                                "Web browsers no longer support RSA."
                            ],
                            "correct": 1,
                            "explanation": "The efficiency of ECC is its key advantage. The smaller keys and faster computations of ECC are a major benefit for both powerful web servers and low-power mobile clients."
                        }
                    ]
                }
            },
            {
                "id": "lesson-14",
                "title": "ECC in Blockchain and Cryptocurrencies",
                "duration": "90 min",
                "objectives": [
                    "Understand why Bitcoin uses the `secp256k1` curve.",
                    "Explain how a cryptocurrency address is generated from a public key.",
                    "Walk through the process of signing a transaction with ECDSA.",
                    "Learn how the public key can be recovered directly from an ECDSA signature.",
                    "Discuss the security of cryptocurrency wallets."
                ],
                "content": {
                    "overview": "Elliptic curve cryptography is the technology that secures trillions of dollars of value on public blockchains. This lesson explores the specific ways that ECC is used in cryptocurrencies like Bitcoin and Ethereum, from the generation of addresses to the signing of transactions.",
                    "sections": [
                        {
                            "title": "Bitcoin's secp256k1 Curve",
                            "content": "<p>Bitcoin uses a specific elliptic curve called **`secp256k1`**. At the time of Bitcoin's creation, this curve was well-established but was less commonly used than the NIST curves. It was chosen partly because its specific structure allows for particularly efficient computations.</p>",
                            "image": "https://images.unsplash.com/photo-1621452773352-2a74c35b2917?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Address Generation from Public Keys",
                            "content": "<p>A user's 'wallet' is simply an ECC key pair. The private key is a secret 256-bit number. The public key is the point on the `secp256k1` curve that results from multiplying the base point `G` by the private key.</p><p>A cryptocurrency 'address' is not the public key itself. It is a shorter, checksummed version of the public key that is created by hashing the public key several times (using SHA-256 and RIPEMD-160) and then encoding it with a special Base58Check encoding. This is done to create shorter, more user-friendly addresses and to prevent typos.</p>",
                            "image": "https://images.unsplash.com/photo-1642155998158-9416a041cb42?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Transaction Signing and Public Key Recovery",
                            "content": "<p>To spend Bitcoin, a user must create a 'transaction' and sign it with their private key using ECDSA. This proves to the network that they are the legitimate owner of the funds.</p><p><strong>Real-world Example: Public Key Recovery.</strong> A unique feature of how Bitcoin uses ECDSA is that it is possible to algebraically recover the *public key* directly from the message hash and the signature `(r, s)`. This provides a significant efficiency gain. It means that a transaction does not need to include the sender's full public key. It only needs to include the signature. The nodes on the network can then recover the public key from the signature, hash it to derive the address, and then check if that address matches the source of the funds. This saves a significant amount of space in every single Bitcoin transaction.</p>",
                            "image": "https://images.unsplash.com/photo-1548092372-2d987bde898b?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Bitcoin Address Generation (Conceptual)",
                            "language": "python",
                            "code": "import hashlib\nimport base58\n\n# This is a conceptual script showing the main steps of Bitcoin address generation.\n\ndef generate_address(public_key_bytes):\n    \"\"\"Generates a legacy Bitcoin address from a public key.\"\"\"\n    \n    # 1. SHA-256 hash of the public key\n    sha256_hash = hashlib.sha256(public_key_bytes).digest()\n\n    # 2. RIPEMD-160 hash of the SHA-256 hash\n    ripemd160 = hashlib.new('ripemd160')\n    ripemd160.update(sha256_hash)\n    ripemd160_hash = ripemd160.digest()\n\n    # 3. Add a version byte (0x00 for mainnet) to the beginning.\n    versioned_hash = b'\\x00' + ripemd160_hash\n\n    # 4. Calculate a checksum by hashing twice and taking the first 4 bytes.\n    checksum = hashlib.sha256(hashlib.sha256(versioned_hash).digest()).digest()[:4]\n\n    # 5. Append the checksum to the versioned hash.\n    binary_address = versioned_hash + checksum\n\n    # 6. Encode the result in Base58Check to get the final address.\n    bitcoin_address = base58.b58encode(binary_address)\n    \n    return bitcoin_address.decode('ascii')\n\n# Example with a dummy public key\n# compressed_public_key = bytes.fromhex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798')\n# print(f\"Address: {generate_address(compressed_public_key)}\")"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "Which specific elliptic curve is used by Bitcoin?",
                            "options": [
                                "NIST P-256",
                                "Curve25519",
                                "secp256k1",
                                "Ed25519"
                            ],
                            "correct": 2,
                            "explanation": "Bitcoin uses the `secp256k1` curve, which was defined by the Standards for Efficient Cryptography (SEC) group. Its properties allow for some particularly efficient calculations."
                        },
                        {
                            "id": 2,
                            "question": "In Bitcoin, how is a user's address generated?",
                            "options": [
                                "It is the user's private key.",
                                "It is the user's public key.",
                                "It is a randomly generated string.",
                                "It is generated by repeatedly hashing the user's public key and then encoding it in Base58Check."
                            ],
                            "correct": 3,
                            "explanation": "The address is a derivative of the public key, not the public key itself. This hashing process creates a shorter, more convenient, and checksummed representation of the public key."
                        },
                        {
                            "id": 3,
                            "question": "The ability to recover a public key directly from an ECDSA signature is a unique feature that provides what benefit for Bitcoin?",
                            "options": [
                                "It makes the signatures more secure.",
                                "It makes the private key easier to guess.",
                                "It saves space in each transaction because the full public key does not need to be included.",
                                "It makes transactions faster."
                            ],
                            "correct": 2,
                            "explanation": "Public key recovery is a key efficiency optimization in Bitcoin. By allowing the public key to be derived from the signature, it saves dozens of bytes in every single transaction, which is a significant saving at the scale of the Bitcoin blockchain."
                        }
                    ]
                }
            },
            {
                "id": "lesson-15",
                "title": "Pairing-Based Cryptography Introduction",
                "duration": "100 min",
                "objectives": [
                    "Define a bilinear pairing and its properties.",
                    "Understand the difference between Weil and Tate pairings.",
                    "Identify the characteristics of a pairing-friendly curve.",
                    "Explain the mechanics of the BLS (Boneh-Lynn-Shacham) signature scheme.",
                    "Understand the basic principles of Identity-Based Encryption (IBE)."
                ],
                "content": {
                    "overview": "This lesson introduces a powerful and advanced concept in elliptic curve cryptography: pairings. A pairing is a special kind of mathematical map that takes two points on an elliptic curve as input and outputs an element in a different group. This 'bilinear' property enables a whole new class of cryptographic schemes with unique and powerful features.",
                    "sections": [
                        {
                            "title": "Bilinear Pairings Definition",
                            "content": "<p>A pairing, denoted `e`, is a map that takes two points, `P` and `Q`, from an elliptic curve group `G1` and maps them to an element in a different 'target' group `G2`.</p><p style=\"text-align:center; font-size:1.5em; font-family: 'Times New Roman', serif;\"><i>e(P, Q) -> z where z is in G2</i></p><p>The key property that makes a pairing useful is **bilinearity**:</p><p style=\"text-align:center; font-size:1.5em; font-family: 'Times New Roman', serif;\"><i>e(aP, bQ) = e(P, Q)<sup>ab</sup></i></p><p>This means that scalars 'move out' of the pairing as exponents. This simple property is the foundation for many advanced protocols.</p>",
                            "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "BLS (Boneh-Lynn-Shacham) Signatures",
                            "content": "<p>The BLS signature scheme is a very simple and elegant signature that is made possible by pairings.</p><h3>How it Works:</h3><ul><li><strong>Key Generation:</strong> Private key is a scalar `d`, public key is a point `Q = dG`.</li><li><strong>Signing:</strong> To sign a message `m`, the signer first hashes the message to a point `H(m)` on the curve. The signature is then simply `S = d * H(m)`.</li><li><strong>Verification:</strong> To verify, the checker computes two pairings. They check if `e(G, S) == e(Q, H(m))`.</li></ul><p><strong>The Proof:</strong> `e(G, S) = e(G, d*H(m)) = e(G, H(m))^d`. And `e(Q, H(m)) = e(d*G, H(m)) = e(G, H(m))^d`. They match! The great advantage of BLS signatures is that they are **aggregatable**. Multiple signatures can be compressed into a single, small signature, which is very useful for blockchains.</p>",
                            "image": "https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Identity-Based Encryption (IBE)",
                            "content": "<p>IBE is a revolutionary idea that was first made practical by pairings. In a traditional public-key system, your public key is a large, random-looking string of numbers. In IBE, your public key can be your **email address**.</p><p><strong>Real-world Example:</strong> Alice wants to send an encrypted email to Bob, but Bob has never set up a public key before. In an IBE system, Alice can use Bob's email address, `bob@example.com`, as his public key and encrypt the message. When Bob wants to read the message, he contacts a central 'Private Key Generator' (PKG), authenticates himself, and the PKG gives him the private key corresponding to his email address. This eliminates the need for a complex public key infrastructure and distribution system.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "BLS Signature Scheme (Conceptual)",
                            "language": "python",
                            "code": "# This is a conceptual script showing the logic of BLS signatures.\n# It assumes we have functions for 'pairing', 'scalar_multiply', and 'hash_to_curve'.\n\n# --- Key Generation ---\nd_private = 12345\nQ_public = scalar_multiply(d_private, G)\n\n# --- Signing ---\nmessage = b\"This is a test message\"\n# 1. Hash the message to a point on the curve.\nH_m = hash_to_curve(message)\n# 2. The signature is the private key multiplied by the hashed message point.\nSignature = scalar_multiply(d_private, H_m)\n\n# --- Verification ---\n# To verify, we check if e(G, Signature) == e(Q_public, H_m)\n\n# Left side of the equation:\npairing1 = pairing(G, Signature) # e(G, d*H(m)) -> e(G,H(m))^d\n\n# Right side of the equation:\npairing2 = pairing(Q_public, H_m) # e(d*G, H(m)) -> e(G,H(m))^d\n\nif pairing1 == pairing2:\n    print(\"[+] Signature is VALID.\")\nelse:\n    print(\"[!] Signature is INVALID.\")"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "The key property of a cryptographic pairing `e` is that it is:",
                            "options": [
                                "Linear",
                                "Bilinear",
                                "Quadratic",
                                "Exponential"
                            ],
                            "correct": 1,
                            "explanation": "Bilinearity (`e(aP, bQ) = e(P, Q)^ab`) is the fundamental property of pairings that allows scalars to 'move out' as exponents, which is the basis for all pairing-based protocols."
                        },
                        {
                            "id": 2,
                            "question": "What is a major advantage of the BLS signature scheme?",
                            "options": [
                                "It does not require a private key.",
                                "The signatures are aggregatable, meaning multiple signatures can be compressed into a single, small signature.",
                                "It is faster than ECDSA.",
                                "It does not require a hash function."
                            ],
                            "correct": 1,
                            "explanation": "The ability to aggregate signatures is the key feature of BLS. This is extremely valuable for reducing the amount of data that needs to be stored on a blockchain, as it allows a single signature to validate many transactions."
                        },
                        {
                            "id": 3,
                            "question": "Identity-Based Encryption (IBE) is a system that allows what to be used as a public key?",
                            "options": [
                                "A large random number.",
                                "A point on an elliptic curve.",
                                "An arbitrary string, such as an email address or a domain name.",
                                "The user's private key."
                            ],
                            "correct": 2,
                            "explanation": "IBE's breakthrough was to eliminate the need for random-looking public keys. By allowing a human-readable identifier like an email address to function as a public key, it greatly simplifies key management."
                        }
                    ]
                }
            },
            {
                "id": "lesson-16",
                "title": "Advanced ECC Curves and Forms",
                "duration": "90 min",
                "objectives": [
                    "Understand the properties of Montgomery curves and the Montgomery ladder.",
                    "Analyze Edwards curves and their unified addition formulas.",
                    "Discuss the advantages of Twisted Edwards curves.",
                    "Explore other curve forms like Hessian and Jacobi quartic.",
                    "Understand the concept of curve isomorphisms."
                ],
                "content": {
                    "overview": "The short Weierstrass form is not the only way to represent an elliptic curve. This lesson explores alternative mathematical forms for elliptic curves that offer significant advantages in performance and security. We will focus on the Montgomery and Edwards curves that are the foundation of modern, high-performance ECC.",
                    "sections": [
                        {
                            "title": "Montgomery Curves and the Ladder",
                            "content": "<p>A Montgomery curve is defined by the equation `By^2 = x^3 + Ax^2 + x`.</p><h3>Key Advantage:</h3><p>This specific form is highly optimized for the **Montgomery ladder** scalar multiplication algorithm. The ladder algorithm, as discussed in Lesson 5, is naturally resistant to many side-channel attacks because its operations are constant-time. Curve25519 is the most famous example of a Montgomery curve, and it is designed for extremely fast and secure key exchange.</p>",
                            "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Edwards Curves and Unified Formulas",
                            "content": "<p>A (twisted) Edwards curve is defined by the equation `ax^2 + y^2 = 1 + dx^2y^2`.</p><h3>Key Advantage:</h3><p>The group law on an Edwards curve is **unified**. This means that the same formula is used for both point addition (`P + Q`) and point doubling (`P + P`). This is a huge advantage because it eliminates the need for special checks to see if the points are the same, which can be a source of side-channel leaks. The formulas are also 'complete', meaning there are no special cases (like the point at infinity) that need to be handled. Ed25519 is a specific twisted Edwards curve that is used for the highly performant EdDSA signature scheme.</p>",
                            "image": "https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Curve Isomorphisms",
                            "content": "<p>An isomorphism is a mathematical map that shows that two different things are fundamentally the same. It is possible to transform a point on a Montgomery curve to a point on a birationally equivalent twisted Edwards curve, and vice-versa.</p><p><strong>Real-world Example:</strong> The popular Curve25519 (a Montgomery curve) is birationally equivalent to the Ed25519 curve (a twisted Edwards curve). This is very useful. It means a single key pair can be used for both ECDH (where the Montgomery form is fastest) and for digital signatures (where the Edwards form is fastest). This allows for a very elegant and efficient combined cryptosystem.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Edwards Curve Operations (Conceptual)",
                            "language": "python",
                            "code": "# This conceptual code shows the unified addition formula for an Edwards curve.\n# Note that it works for both adding two different points and doubling a single point.\n\ndef point_addition_edwards(P, Q, a, d, p):\n    # P = (x1, y1), Q = (x2, y2)\n    x1, y1 = P\n    x2, y2 = Q\n\n    # The unified addition formula\n    # Note the lack of 'if P == Q' checks.\n    numerator_x = (x1*y2 + y1*x2)\n    denominator_x = (1 + d*x1*x2*y1*y2)\n    x3 = (numerator_x * modular_inverse(denominator_x, p)) % p\n\n    numerator_y = (y1*y2 - a*x1*x2)\n    denominator_y = (1 - d*x1*x2*y1*y2)\n    y3 = (numerator_y * modular_inverse(denominator_y, p)) % p\n\n    return (x3, y3)\n\n# Because the formula is the same for both cases, it is much easier to implement\n# in a constant-time, side-channel resistant way."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "The Curve25519 key exchange protocol uses which special form of elliptic curve?",
                            "options": [
                                "Weierstrass curve",
                                "Edwards curve",
                                "Montgomery curve",
                                "Hessian curve"
                            ],
                            "correct": 2,
                            "explanation": "Curve25519 is a Montgomery curve, specifically chosen for its high performance and suitability for the constant-time Montgomery ladder algorithm, making it very secure."
                        },
                        {
                            "id": 2,
                            "question": "What is the primary advantage of the group law on an Edwards curve?",
                            "options": [
                                "It is slower but more secure.",
                                "It is 'unified', meaning the same algebraic formula can be used for both point addition and point doubling.",
                                "It only works with small prime numbers.",
                                "It does not require a base point."
                            ],
                            "correct": 1,
                            "explanation": "The unified and complete nature of the Edwards curve addition law is its key benefit. It simplifies the implementation and eliminates special cases that can be a source of bugs and side-channel vulnerabilities."
                        },
                        {
                            "id": 3,
                            "question": "The fact that Curve25519 and Ed25519 are 'birationally equivalent' provides what practical benefit?",
                            "options": [
                                "It makes them less secure.",
                                "It means they are the same curve.",
                                "It allows a single key pair to be used for both ECDH (on the Montgomery form) and digital signatures (on the Edwards form).",
                                "It has no practical benefit."
                            ],
                            "correct": 2,
                            "explanation": "This equivalence is a very elegant feature. It allows a protocol to use the same private key for both key exchange and signatures, while still using the most performant curve form for each operation."
                        }
                    ]
                }
            },
            {
                "id": "lesson-17",
                "title": "ECC Key Management and PKI",
                "duration": "90 min",
                "objectives": [
                    "Establish secure procedures for generating ECC key pairs.",
                    "Implement key validation to prevent attacks.",
                    "Understand the role of a Certificate Authority (CA) in an ECC-based Public Key Infrastructure (PKI).",
                    "Discuss the principles of key escrow and recovery.",
                    "Integrate Hardware Security Modules (HSMs) for secure key storage."
                ],
                "content": {
                    "overview": "A cryptosystem is only as strong as its keys. This lesson covers the practical aspects of key management in an ECC-based system, from the secure generation and validation of keys to their protection using Hardware Security Modules (HSMs) and their management within a Public Key Infrastructure (PKI).",
                    "sections": [
                        {
                            "title": "Secure Key Generation and Validation",
                            "content": "<p>The security of ECC relies on the private key being a **secret, cryptographically random** number.</p><h3>Key Generation:</h3><p>The private key `d` must be generated using a cryptographically secure pseudo-random number generator (CSPRNG). It must be an integer between `1` and `n-1`, where `n` is the order of the subgroup.</p><h3>Key Validation:</h3><p>When you receive a public key from another party, you must validate it before using it. You must check that the point is not the point at infinity, that its coordinates are in the correct range, and that it is actually a point on the specified curve. Failure to do this can make your system vulnerable to 'invalid curve attacks'.</p>",
                            "image": "https://images.unsplash.com/photo-1548092372-2d987bde898b?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "ECC in a Public Key Infrastructure (PKI)",
                            "content": "<p>A PKI is the framework of roles, policies, and systems used to manage public keys. The central component is the **Certificate Authority (CA)**.</p><p><strong>Real-world Example: TLS Certificates.</strong> When you visit your bank's website, your browser needs to know that the public key it receives actually belongs to your bank and not to a man-in-the-middle attacker. It knows this because the bank's public key is contained in a digital certificate that has been signed by a trusted, third-party Certificate Authority (like Let's Encrypt or DigiCert). Your browser has a pre-installed list of these trusted CAs. By verifying the CA's signature on the certificate, your browser can be confident that the public key is authentic.</p>",
                            "image": "https://images.unsplash.com/photo-1504384308090-c894fdcc538d?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Hardware Security Modules (HSMs)",
                            "content": "<p>For the most critical keys in a system (like a CA's root private key), storing them in a software file on a general-purpose server is not secure enough. These keys are protected using a **Hardware Security Module (HSM)**.</p><p>An HSM is a dedicated, tamper-resistant hardware device. The private key is generated *inside* the HSM and is physically incapable of ever leaving the device. To use the key (e.g., to sign a certificate), the data to be signed is sent *to* the HSM, the HSM performs the signing operation internally, and it returns only the signature. This provides a very high level of assurance that the private key can never be stolen.</p>",
                            "image": "https://images.unsplash.com/photo-1593435713588-a73de23947db?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Secure Key Generation (Python)",
                            "language": "python",
                            "code": "import os\n\n# This script demonstrates how to generate a secure private key.\n\n# The order of the secp256k1 curve's subgroup\nn = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n\ndef generate_private_key():\n    \"\"\"Generates a cryptographically secure 32-byte private key.\"\"\"\n    while True:\n        # 1. Use the operating system's source of cryptographic randomness.\n        #    os.urandom() is the correct way to do this in Python.\n        private_key_bytes = os.urandom(32)\n        private_key_int = int.from_bytes(private_key_bytes, 'big')\n\n        # 2. Ensure the generated key is valid: it must be between 1 and n-1.\n        #    The chance of it being 0 or >= n is astronomically small, but we check anyway.\n        if 1 <= private_key_int < n:\n            return private_key_int\n\nprivate_key = generate_private_key()\nprint(f\"Generated Private Key (as hex): {hex(private_key)}\")"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the most critical property of an ECC private key?",
                            "options": [
                                "It must be a prime number.",
                                "It must be a secret, cryptographically random number.",
                                "It must be larger than the prime `p`.",
                                "It must be an even number."
                            ],
                            "correct": 1,
                            "explanation": "The entire security of the system rests on the secrecy and unpredictability of the private key. It must be generated using a true source of randomness."
                        },
                        {
                            "id": 2,
                            "question": "In a Public Key Infrastructure (PKI), what is the role of a Certificate Authority (CA)?",
                            "options": [
                                "To generate all the private keys.",
                                "To act as a trusted third party that signs public keys to certify their authenticity.",
                                "To monitor network traffic for threats.",
                                "To store all the encrypted data."
                            ],
                            "correct": 1,
                            "explanation": "The CA is the root of trust in a PKI. By signing a public key (and the identity associated with it), the CA provides a way for others to verify that the key is legitimate."
                        },
                        {
                            "id": 3,
                            "question": "A tamper-resistant hardware device that is used to securely store and use the most critical private keys is known as a:",
                            "options": [
                                "CPU",
                                "GPU",
                                "Hardware Security Module (HSM)",
                                "SSD"
                            ],
                            "correct": 2,
                            "explanation": "An HSM is a dedicated crypto-processor. Its key security feature is that the private keys are generated inside it and can never leave, providing a very high degree of protection against theft."
                        }
                    ]
                }
            },
            {
                "id": "lesson-18",
                "title": "Zero-Knowledge Proofs with ECC",
                "duration": "100 min",
                "objectives": [
                    "Understand the concept of a zero-knowledge proof.",
                    "Implement a commitment scheme using elliptic curves (Pedersen commitment).",
                    "Analyze the structure of a Sigma protocol (e.g., Schnorr's protocol for proof of knowledge).",
                    "Understand the high-level concept of zk-SNARKs and their use of ECC.",
                    "Discuss the applications of ZKPs in privacy-preserving protocols."
                ],
                "content": {
                    "overview": "A zero-knowledge proof (ZKP) is one of the most powerful and counter-intuitive concepts in modern cryptography. It allows one person (the Prover) to prove to another person (the Verifier) that they know a secret, without revealing the secret itself. This lesson introduces the fundamentals of ZKPs and how they can be constructed using elliptic curves.",
                    "sections": [
                        {
                            "title": "Commitment Schemes",
                            "content": "<p>A commitment scheme is like a digital envelope. You can commit to a value (put it in the envelope), and you cannot change it later (the envelope is sealed). You can then later 'reveal' the value, and anyone can verify that it matches the original commitment.</p><p>A **Pedersen commitment** is a common scheme that uses elliptic curves. A commitment to a value `v` is of the form `C = vG + rH`, where `G` and `H` are two different generator points, `v` is the secret value, and `r` is a random 'blinding factor'. This scheme is perfectly hiding (the commitment reveals nothing about `v`) and computationally binding (it's infeasible to open the commitment to a different value).</p>",
                            "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Sigma Protocols and Proof of Knowledge",
                            "content": "<p>A Sigma protocol is a simple, three-step interaction for a zero-knowledge proof.</p><ol><li><strong>Commitment:</strong> The Prover makes a commitment to a random value.</li><li><strong>Challenge:</strong> The Verifier sends a random challenge.</li><li><strong>Response:</strong> The Prover computes a response based on their secret, the commitment, and the challenge.</li></ol><p><strong>Real-world Example: Schnorr's Protocol for Proof of Knowledge of a Private Key.</strong> Peggy (the Prover) wants to prove to Victor (the Verifier) that she knows the private key `d` corresponding to her public key `Q = dG`, without revealing `d`.<ol><li>Peggy chooses a random number `k` (a nonce) and sends the commitment `R = kG` to Victor.</li><li>Victor sends a random challenge `c` to Peggy.</li><li>Peggy computes the response `s = k + c*d` and sends it to Victor.</li></ol>Victor can then check if `sG == R + cQ`. If it does, he is convinced that Peggy must know `d`. This is the basis for Schnorr signatures.</p>",
                            "image": "https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "zk-SNARKs",
                            "content": "<p>A zk-SNARK (Zero-Knowledge Succinct Non-Interactive Argument of Knowledge) is a highly advanced form of ZKP with three amazing properties:</p><ul><li><strong>Zero-Knowledge:</strong> The proof reveals nothing about the secret.</li><li><strong>Succinct:</strong> The proof is extremely small and very fast to verify, even if the original computation was very large.</li><li><strong>Non-Interactive:</strong> The Prover can create the proof without any back-and-forth communication with the Verifier.</li></ul><p>zk-SNARKs rely heavily on pairing-based elliptic curve cryptography. They are the technology behind privacy-focused cryptocurrencies like Zcash, allowing a transaction to be publicly verified as valid without revealing the sender, receiver, or amount.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Schnorr Proof of Knowledge (Conceptual)",
                            "language": "python",
                            "code": "# This is a conceptual script for the Schnorr identity protocol.\n\n# --- Setup ---\nd_private = 12345 # Peggy's secret\nQ_public = scalar_multiply(d_private, G) # Peggy's public key\n\n# --- Peggy (Prover) --- \n# 1. Commitment Phase\nk_nonce = generate_private_key() # A random secret nonce\nR_commitment = scalar_multiply(k_nonce, G)\n# Peggy sends R to Victor.\n\n# --- Victor (Verifier) ---\n# 2. Challenge Phase\nc_challenge = generate_private_key() # A random challenge scalar\n# Victor sends c to Peggy.\n\n# --- Peggy (Prover) ---\n# 3. Response Phase\ns_response = (k_nonce + c_challenge * d_private) % n # n is the curve order\n# Peggy sends s to Victor.\n\n# --- Victor (Verifier) ---\n# 4. Verification\n# Victor checks if sG == R + cQ\n\n# Left side: s * G\nleft_side = scalar_multiply(s_response, G)\n\n# Right side: R + c * Q\nright_side_term2 = scalar_multiply(c_challenge, Q_public)\nright_side = point_addition(R_commitment, right_side_term2)\n\nif left_side == right_side:\n    print(\"[+] Proof is VALID. Victor is convinced Peggy knows the private key.\")\nelse:\n    print(\"[!] Proof is INVALID.\")"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What does a zero-knowledge proof allow a Prover to do?",
                            "options": [
                                "Prove they know a secret by revealing the secret to the Verifier.",
                                "Prove they know a secret without revealing the secret itself.",
                                "Prove that a statement is false.",
                                "Prove that a secret does not exist."
                            ],
                            "correct": 1,
                            "explanation": "This is the core, counter-intuitive property of a ZKP. It allows for the verification of knowledge without the transmission of the knowledge itself."
                        },
                        {
                            "id": 2,
                            "question": "A cryptographic scheme that is like a 'digital envelope', allowing you to commit to a value and reveal it later, is known as a:",
                            "options": [
                                "Signature scheme",
                                "Encryption scheme",
                                "Hash function",
                                "Commitment scheme"
                            ],
                            "correct": 3,
                            "explanation": "A commitment scheme provides two properties: 'binding' (you can't change your mind) and 'hiding' (the commitment reveals nothing about the value). Pedersen commitments, which use ECC, are a very common example."
                        },
                        {
                            "id": 3,
                            "question": "The advanced, non-interactive ZKPs that are used in cryptocurrencies like Zcash are known as:",
                            "options": [
                                "Sigma Protocols",
                                "zk-SNARKs",
                                "Schnorr Signatures",
                                "Pedersen Commitments"
                            ],
                            "correct": 1,
                            "explanation": "zk-SNARKs are a major breakthrough in cryptography. Their 'succinctness' (small proof size and fast verification) is what makes them practical for use on a public blockchain."
                        }
                    ]
                }
            },
            {
                "id": "lesson-19",
                "title": "Elliptic Curve Factorization and Applications",
                "duration": "90 min",
                "objectives": [
                    "Understand the principle of the Elliptic Curve Factorization Method (ECM).",
                    "Learn how point counting algorithms like Schoof's algorithm work.",
                    "Discuss the application of ECC to primality proving.",
                    "Differentiate between the use of ECC for cryptography and for cryptanalysis.",
                    "Analyze the complexity of ECM."
                ],
                "content": {
                    "overview": "This lesson explores a fascinating and different application of elliptic curves: not for building cryptosystems, but for breaking them. We will learn about the Elliptic Curve Factorization Method (ECM), one of the most powerful algorithms for factoring large composite numbers, and how other properties of elliptic curves can be used for primality proving.",
                    "sections": [
                        {
                            "title": "Elliptic Curve Factorization Method (ECM)",
                            "content": "<p>ECM, invented by Hendrik Lenstra, is an algorithm for integer factorization that uses the group of points on an elliptic curve.</p><h3>How it Works (High Level):</h3><ol><li>We want to find a factor of a large composite number `N`.</li><li>We randomly choose an elliptic curve `y^2 = x^3 + ax + b` and a point `P` on it, but we perform all the calculations **modulo N**.</li><li>Because `N` is not prime, the points do not form a proper group. We try to calculate a large scalar multiple of `P`, like `kP`.</li><li>During the point addition and doubling calculations, we will need to compute a modular inverse of a difference in x-coordinates. If this difference happens to share a factor with `N`, the modular inverse will not exist, and the attempt to calculate it with the Extended Euclidean Algorithm will fail.</li><li>This 'failure' is actually a success! The number that we failed to invert gives us a non-trivial factor of `N`.</li></ol><p>The runtime of ECM depends on the size of the smallest prime factor of `N`, which makes it very effective for finding moderately sized factors.</p>",
                            "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Point Counting Algorithms (Schoof's Algorithm)",
                            "content": "<p>For a curve to be secure for cryptography, we need to know the exact number of points on it (its order). Schoof's algorithm was the first deterministic, polynomial-time algorithm for counting the points on an elliptic curve over a finite field. It uses advanced mathematics, including the properties of the Frobenius endomorphism and the Chinese Remainder Theorem, to achieve this.</p>",
                            "image": "https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Primality Proving",
                            "content": "<p>Elliptic curves can also be used to prove that a number is prime. The Elliptic Curve Primality Proving (ECPP) algorithm was one of the fastest known algorithms for primality proving for many years. It works by finding an elliptic curve whose number of points is a multiple of the number being tested, which has certain properties that are only true if the number is prime.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "ECM Factorization Implementation (Conceptual)",
                            "language": "python",
                            "code": "# This is a highly conceptual script for the Lenstra ECM algorithm.\n# It uses a library like 'gmpy2' for the heavy lifting.\n\nimport gmpy2\n\ndef ecm_factor(N, bound=10000):\n    \"\"\"Attempts to find a factor of N using ECM.\"\"\"\n    while True:\n        # 1. Generate a random elliptic curve and a point P on it (mod N).\n        # ... (code to generate random a, P=(x,y)) ...\n        # b = (y^2 - x^3 - ax) mod N\n\n        # 2. Try to calculate k*P for a large k with many small prime factors.\n        # ... (code for the two phases of ECM scalar multiplication) ...\n\n        # 3. During the scalar multiplication, we will need to compute modular inverses.\n        #    If a modular inverse fails, the gcd(number, N) will be a factor of N.\n        try:\n            # ... (point addition/doubling logic) ...\n            # inverse = gmpy2.invert(x2 - x1, N)\n            pass\n        except ZeroDivisionError as e:\n            # The 'invert' function raises this if an inverse doesn't exist.\n            # The value that could not be inverted is in the exception.\n            g = gmpy2.gcd(e.args[0], N)\n            if 1 < g < N:\n                print(f\"[+] Factor found: {g}\")\n                return g\n        \n        # If this curve didn't work, try another random one.\n        print(\"[*] Curve failed to find a factor, trying another...\")"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "The Elliptic Curve Factorization Method (ECM) is an algorithm used for what purpose?",
                            "options": [
                                "Encrypting data",
                                "Signing a message",
                                "Finding the prime factors of a large composite number",
                                "Generating a prime number"
                            ],
                            "correct": 2,
                            "explanation": "ECM is a factoring algorithm. It cleverly uses the group law of elliptic curves modulo a composite number, where a 'failure' in the group operation actually succeeds in finding a factor."
                        },
                        {
                            "id": 2,
                            "question": "Schoof's algorithm is a deterministic, polynomial-time algorithm for what?",
                            "options": [
                                "Factoring a number.",
                                "Counting the number of points on an elliptic curve over a finite field.",
                                "Solving the ECDLP.",
                                "Generating a key pair."
                            ],
                            "correct": 1,
                            "explanation": "Point counting is a critical step in establishing the security of an elliptic curve for cryptography. Schoof's algorithm (and its more advanced variants like SEA) are the methods used to do this efficiently."
                        },
                        {
                            "id": 3,
                            "question": "The runtime of the ECM algorithm is dependent on what?",
                            "options": [
                                "The size of the composite number N.",
                                "The size of the smallest prime factor of N.",
                                "The number of prime factors of N.",
                                "The size of the largest prime factor of N."
                            ],
                            "correct": 1,
                            "explanation": "This is the key property of ECM. It is very good at finding 'smooth' factors (i.e., small to medium-sized ones). It is less efficient for numbers that are a product of two very large, similar-sized primes (like an RSA modulus)."
                        }
                    ]
                }
            },
            {
                "id": "lesson-20",
                "title": "Post-Quantum Considerations",
                "duration": "100 min",
                "objectives": [
                    "Understand the threat that quantum computers pose to ECC.",
                    "Explain how Shor's algorithm can solve the ECDLP.",
                    "Explore the field of post-quantum cryptography (PQC).",
                    "Analyze the principles of supersingular isogeny cryptography.",
                    "Develop a high-level strategy for migrating from ECC to a PQC algorithm."
                ],
                "content": {
                    "overview": "This lesson addresses the long-term, existential threat to all modern public-key cryptography: the quantum computer. We will explore how a sufficiently powerful quantum computer will be able to break ECC, and we will introduce the field of Post-Quantum Cryptography (PQC), the research into new cryptosystems that are believed to be secure even against a quantum attacker.",
                    "sections": [
                        {
                            "title": "The Quantum Threat and Shor's Algorithm",
                            "content": "<p>A classical computer would take billions of years to solve the ECDLP for a 256-bit curve. In 1994, Peter Shor discovered a **quantum algorithm** that can solve the discrete logarithm problem (and the integer factorization problem) in polynomial time.</p><p>This means that once a sufficiently large and stable quantum computer is built, it will be able to break all currently deployed public-key cryptosystems, including RSA, Diffie-Hellman, and ECC. This will be a cryptographic apocalypse, rendering almost all of our secure communication and digital signatures insecure.</p>",
                            "image": "https://images.unsplash.com/photo-1635070049035-5a79a8385075?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Post-Quantum Cryptography (PQC)",
                            "content": "<p>PQC is the field of cryptography focused on developing new algorithms that are believed to be secure against both classical and quantum computers. These algorithms are not based on the integer factorization or discrete logarithm problems.</p><h3>The Main Families of PQC:</h3><ul><li><strong>Lattice-based cryptography:</strong> Based on the hardness of problems in mathematical lattices. This is a leading candidate.</li><li><strong>Code-based cryptography:</strong> Based on the hardness of decoding a random linear code.</li><li><strong>Multivariate cryptography:</strong> Based on the hardness of solving systems of multivariate equations.</li><li><strong>Hash-based signatures:</strong> A very well-understood approach for digital signatures.</li><li><strong>Isogeny-based cryptography:</strong> A special case that is based on elliptic curves, but a different hard problem.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Supersingular Isogeny Cryptography",
                            "content": "<p>This is the one area of PQC that is still based on elliptic curves. An **isogeny** is a special kind of map between two elliptic curves. The hard problem is to find the specific isogeny (the 'path') between two given isogenus curves.</p><p><strong>Real-world Example: SIKE.</strong> Supersingular Isogeny Key Encapsulation (SIKE) was a leading candidate in the NIST PQC standardization process. It was an isogeny-based key exchange protocol. However, in 2022, a major breakthrough allowed researchers to break SIKE in a matter of hours using a standard classical computer. This was a dramatic event in the cryptographic community and highlights how new and still-developing the field of PQC is.</p>",
                            "image": "https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Shor's Algorithm Simulation (Conceptual)",
                            "language": "python",
                            "code": "# This is a highly conceptual script showing the logical steps of Shor's algorithm\n# as it would be applied to the ECDLP to find 'd' in Q = dG.\n\n# NOTE: This requires a quantum computer to run.\n\ndef shors_algorithm_ecdlp(G, Q):\n    \"\"\"Solves for d given Q and G on a quantum computer.\"\"\"\n\n    # 1. Quantum State Preparation:\n    #    Create a quantum state that is a superposition of all possible pairs (a, b).\n    #    quantum_state = sum(|a, b>)\n\n    # 2. Quantum Computation:\n    #    Apply a quantum operation that computes aG + bQ for each pair in the superposition.\n    #    The result is a complex superposition of states.\n\n    # 3. Quantum Fourier Transform (QFT):\n    #    Apply the QFT to the first register. This is the key step of the algorithm.\n    #    The QFT will cause the different quantum states to interfere with each other.\n    #    The states that correspond to the period of the function will be amplified.\n\n    # 4. Measurement:\n    #    Measure the first register. The result will, with high probability, be a value\n    #    that is related to the period of the function, which in turn is related to 'd'.\n\n    # 5. Classical Post-Processing:\n    #    Use the measured value and classical algorithms (like the continued fractions algorithm)\n    #    to solve for the discrete logarithm 'd'.\n    return d"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "Shor's algorithm is a quantum algorithm that can efficiently solve which two problems?",
                            "options": [
                                "Sorting and searching.",
                                "Integer factorization and the discrete logarithm problem.",
                                "Playing chess and Go.",
                                "Encrypting and decrypting data."
                            ],
                            "correct": 1,
                            "explanation": "These are the two 'hard' problems that underpin almost all of our currently deployed public-key cryptography. A quantum computer running Shor's algorithm will render RSA, Diffie-Hellman, and ECC insecure."
                        },
                        {
                            "id": 2,
                            "question": "The field of cryptography dedicated to finding new algorithms that are resistant to attack by both classical and quantum computers is known as:",
                            "options": [
                                "Symmetric Cryptography",
                                "Elliptic Curve Cryptography",
                                "Post-Quantum Cryptography (PQC)",
                                "Hashing"
                            ],
                            "correct": 2,
                            "explanation": "PQC is the major, ongoing research effort to prepare for the day when a quantum computer becomes a reality. The NIST PQC standardization process is the primary driver of this effort."
                        },
                        {
                            "id": 3,
                            "question": "Supersingular isogeny cryptography is a type of post-quantum cryptography that is based on a hard problem involving what?",
                            "options": [
                                "Mathematical lattices",
                                "Error-correcting codes",
                                "Finding a specific map ('isogeny') between two elliptic curves",
                                "Solving multivariate equations"
                            ],
                            "correct": 2,
                            "explanation": "Isogeny-based cryptography is the one branch of PQC that is still related to elliptic curves. It uses the same mathematical objects but relies on a different, more complex hard problem that is not believed to be vulnerable to Shor's algorithm."
                        }
                    ]
                }
            },
            {
                "id": "lesson-21",
                "title": "ECC Protocol Design and Analysis",
                "duration": "90 min",
                "objectives": [
                    "Understand the core principles of secure protocol design.",
                    "Learn how to use formal verification methods to analyze a protocol's security.",
                    "Apply protocol composition theorems to build complex protocols from simple ones.",
                    "Model potential attacks against a protocol.",
                    "Work within provable security frameworks to create strong security proofs."
                ],
                "content": {
                    "overview": "This lesson moves from the cryptographic primitives to the protocols that use them. Designing a secure protocol is notoriously difficult. We will explore the principles of secure protocol design, the formal methods used to verify their security, and the common pitfalls that lead to catastrophic failures.",
                    "sections": [
                        {
                            "title": "Principles of Secure Protocol Design",
                            "content": "<p>Many secure-looking protocols have been broken due to subtle logical flaws.</p><h3>Key Principles (Abadi & Needham):</h3><ul><li>Every message should say who sent it.</li><li>Every message should say who it is for.</li><li>Every message should be fresh (not a replay).</li><li>Every message should be clear and unambiguous in its meaning.</li><li>When encrypting, encrypt both the message and its context (e.g., who it's from/to).</li></ul><p>Violating these simple-sounding principles has led to the failure of many real-world protocols.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Formal Verification Methods",
                            "content": "<p>Formal verification is the use of mathematical methods to prove that a protocol is secure. Instead of just testing a protocol, you prove its properties.</p><h3>Approaches:</h3><ul><li><strong>Model Checking:</strong> The protocol is represented as a finite state machine. An automated tool then explores all possible states of the protocol to see if any of them lead to an insecure state.</li><li><strong>Theorem Proving:</strong> The protocol and its security properties are expressed in a formal mathematical logic. The designer then uses a proof assistant (like Coq or Isabelle/HOL) to build a rigorous, machine-checked mathematical proof of the protocol's security.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Provable Security Frameworks",
                            "content": "<p>A provable security framework provides a way to create a formal security proof. The proof is usually a **reduction**.</p><p><strong>Real-world Example:</strong> To prove that a new signature scheme is secure, you would write a reduction. The reduction shows that if an attacker could forge a signature in your new scheme, you could use that attacker as a 'subroutine' to solve a well-known hard mathematical problem (like the ECDLP). Since we believe the ECDLP is hard, this implies that forging a signature must also be hard. This provides a formal, rigorous argument for the protocol's security.</p>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Security Protocol Verification (ProVerif)",
                            "language": "prolog",
                            "code": "(* This is a simple model of a key exchange protocol written in ProVerif,\n   a formal verification tool. *)\n\nfree c: channel.\n\nfun pk(skey): pkey.\nfun senc(bitstring, pkey): bitstring.\nfun sdec(bitstring, skey): bitstring.\n\nquery attacker(secret_m).\n\nlet processA(sk_a: skey, pk_b: pkey, secret_m: bitstring) =\n    let pk_a = pk(sk_a) in\n    out(c, pk_a);\n    let message = senc(secret_m, pk_b) in\n    out(c, message).\n\nlet processB(sk_b: skey) =\n    in(c, pk_a: pkey);\n    in(c, message: bitstring);\n    let m = sdec(message, sk_b) in\n    if pk(sk_a) = pk_a then\n        (* This protocol is flawed! An attacker can intercept and replace pk_a *)\n        (* ProVerif will automatically find that 'attacker(secret_m)' is TRUE, meaning the secret is leaked. *)\n        .\n\nprocess new sk_a: skey; new sk_b: skey; new secret_m: bitstring;\n        ( (processA(sk_a, pk(sk_b), secret_m)) | (processB(sk_b)) )"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "The use of automated tools to explore all possible states of a protocol to check for security flaws is known as:",
                            "options": [
                                "Theorem Proving",
                                "Penetration Testing",
                                "Model Checking",
                                "Fuzzing"
                            ],
                            "correct": 2,
                            "explanation": "Model checking is a formal verification technique where a model of the system is created, and an automated tool exhaustively checks it against a given specification to find any violations."
                        },
                        {
                            "id": 2,
                            "question": "A common method for proving a cryptographic protocol is secure is to show that if an attacker could break your protocol, they could also be used to solve a well-known hard mathematical problem. This is known as a:",
                            "options": [
                                "Proof by contradiction",
                                "Proof by induction",
                                "Security reduction",
                                "Side-channel attack"
                            ],
                            "correct": 2,
                            "explanation": "A security reduction is the standard way to build a provable security argument. It reduces the security of the protocol to the assumed hardness of an underlying mathematical problem like the ECDLP."
                        },
                        {
                            "id": 3,
                            "question": "What is a primary goal of formal verification?",
                            "options": [
                                "To make a protocol run faster.",
                                "To find and eliminate subtle logical flaws in a protocol's design that might be missed by standard testing.",
                                "To choose which elliptic curve to use.",
                                "To write a report for management."
                            ],
                            "correct": 1,
                            "explanation": "Formal verification is about correctness. It uses rigorous mathematical and logical methods to prove that a protocol's design is free from a certain class of logical flaws, providing a much higher level of assurance than traditional testing."
                        }
                    ]
                }
            },
            {
                "id": "lesson-22",
                "title": "Efficient ECC Implementations",
                "duration": "90 min",
                "objectives": [
                    "Write optimized assembly language routines for finite field arithmetic.",
                    "Use SIMD (Single Instruction Multiple Data) instructions to accelerate computations.",
                    "Explore the use of GPUs and FPGAs for hardware acceleration of ECC.",
                    "Optimize implementations for resource-constrained embedded systems.",
                    "Apply performance profiling to identify bottlenecks."
                ],
                "content": {
                    "overview": "This lesson is for the performance engineers. We will explore the advanced techniques used to create highly optimized, high-speed implementations of ECC. From hand-tuned assembly language and SIMD instructions to dedicated hardware acceleration on FPGAs and GPUs, we will cover the methods used to push the performance of ECC to its absolute limits.",
                "sections": [
                    {
                        "title": "Assembly Language and SIMD Optimizations",
                        "content": "<p>For the highest performance, the core finite field arithmetic routines (the modular multiplication) are often written directly in assembly language. This allows a developer to take advantage of specific CPU instructions to make the math as fast as possible.</p><h3>SIMD (Single Instruction Multiple Data):</h3><p>Modern CPUs have special SIMD instructions (like AVX2) that can perform the same operation on multiple pieces of data at once. A developer can structure their ECC implementation to use these instructions to perform several steps of the modular arithmetic in parallel, providing a significant speedup.</p>",
                            "image": "https://images.unsplash.com/photo-1587620962725-abab7fe55159?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "GPU and FPGA Acceleration",
                            "content": "<p>For massive-scale operations, like a server that needs to process tens of thousands of signatures per second, the computation can be offloaded to dedicated hardware.</p><ul><li><strong>GPU Acceleration:</strong> A GPU has thousands of simple cores. An implementation can be written (e.g., using CUDA) to have each core work on a separate cryptographic operation in parallel.</li><li><strong>FPGA Implementations:</strong> An FPGA (Field-Programmable Gate Array) is a chip that can be reconfigured at the hardware level. A developer can design a dedicated hardware circuit specifically for performing ECC point multiplication. This provides the highest possible performance.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1575235028124-ab6346a5a0a3?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Embedded System Optimizations",
                            "content": "<p>On the other end of the spectrum is a tiny, resource-constrained IoT device. For these systems, the goal is not just speed, but also small code size and low power consumption. This involves choosing lightweight curves, using memory-efficient algorithms, and sometimes using a small, dedicated crypto-co-processor that is built into the device's main chip.</p>",
                            "image": "https://images.unsplash.com/photo-1535683416248-8495c6b8159b?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "x86-64 Assembly ECC Routine (Conceptual)",
                            "language": "c",
                            "code": "/* This is a conceptual snippet showing the kind of hand-optimized x86-64 assembly\n   that might be used for modular multiplication in a high-performance library.\n*/\n\n// Function to perform a 256-bit modular multiplication: C = (A * B) mod P\n\n// Use the MULX instruction for high-speed, 64x64 -> 128-bit multiplication.\n// Use the ADC (Add with Carry) instruction to handle the multi-precision arithmetic.\n// Use carefully chosen register allocations to minimize memory access.\n// Unroll loops to avoid branching penalties.\n\n// ... dozens or hundreds of lines of complex, hand-tuned assembly code ...\n\n// By operating directly at this low level, a developer can achieve performance\n// that is impossible to get from a standard C compiler."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "SIMD instructions like AVX2 are used to do what?",
                            "options": [
                                "Make the code more secure.",
                                "Perform the same operation on multiple pieces of data in parallel with a single instruction.",
                                "Make the code easier to read.",
                                "Encrypt the data."
                            ],
                            "correct": 1,
                            "explanation": "SIMD (Single Instruction, Multiple Data) is a form of parallel processing. By structuring the math correctly, a developer can use these instructions to get a significant performance boost for their cryptographic code."
                        },
                        {
                            "id": 2,
                            "question": "For the absolute highest possible performance, an ECC implementation would be built on what?",
                            "options": [
                                "Python",
                                "Java",
                                "A dedicated hardware circuit on an FPGA or ASIC.",
                                "A web browser."
                            ],
                            "correct": 2,
                            "explanation": "Hardware will always be faster than software. A custom-designed hardware implementation on an FPGA (Field-Programmable Gate Array) or an ASIC (Application-Specific Integrated Circuit) will provide the ultimate level of performance."
                        },
                        {
                            "id": 3,
                            "question": "When optimizing ECC for a tiny IoT device, what are the primary considerations?",
                            "options": [
                                "Raw speed above all else.",
                                "Small code size, low memory usage, and low power consumption.",
                                "The ability to run on a web server.",
                                "Support for very large prime numbers."
                            ],
                            "correct": 1,
                            "explanation": "Resource-constrained environments have a different set of priorities. The implementation must be small, efficient, and not drain the device's battery, which often involves different algorithmic choices than a high-performance server."
                        }
                    ]
                }
            },
            {
                "id": "lesson-23",
                "title": "ECC Attacks and Vulnerabilities",
                "duration": "100 min",
                "objectives": [
                    "Understand and execute an invalid curve attack.",
                    "Analyze the threat of twist attacks and their countermeasures.",
                    "Perform a small subgroup attack.",
                    "Identify common implementation vulnerabilities that lead to key leakage.",
                    "Discuss the theoretical risk of lattice-based attacks on weak parameters."
                ],
                "content": {
                    "overview": "This lesson focuses on the offensive side of ECC. We will explore the various attacks that can be launched against a poorly implemented or poorly configured elliptic curve cryptosystem. Understanding these attacks is essential for any developer or security professional who is building or auditing a system that relies on ECC.",
                "sections": [
                    {
                        "title": "Invalid Curve Attacks",
                        "content": "<p>This is an attack where the adversary sends a public key (a point) that is *not actually on the correct elliptic curve* to the victim. If the victim's software does not validate that the point satisfies the curve equation, it may perform the ECDH key exchange calculation using this invalid point.</p><p>The result is that the 'shared secret' the victim calculates is not the real one, and information about the victim's private key can be leaked. This highlights the critical importance of always validating any public key you receive from an external party.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Twist Attacks and Small Subgroup Attacks",
                            "content": "<ul><li><strong>Twist Attacks:</strong> Every elliptic curve has a 'twist'. An attacker can send a point that is on the twist of the curve, not the curve itself. If the victim's software is not written carefully, this can leak information about the private key. Using a curve with a specific mathematical form (like Montgomery curves) can completely eliminate this attack.</li><li><strong>Small Subgroup Attacks:</strong> An attacker can send a point that has a very small order (e.g., a point `P` where `4P = O`). If the victim uses this point in an ECDH key exchange, there will only be a very small number of possible shared secrets. The attacker can try all of them. This is defeated by ensuring the curve's cofactor is small and by validating that the received public key is not a low-order point.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Implementation Vulnerabilities",
                            "content": "<p>As we've seen, the most common failures are not in the math, but in the code.</p><p><strong>Real-world Example: The Sony PS3 ECDSA Hack.</strong> This was a catastrophic implementation vulnerability. Sony's ECDSA signing code used a static, hardcoded value for the secret nonce `k` instead of a unique, random one for every signature. Reusing the nonce for two different signatures allows an attacker to use simple algebra to completely recover the secret private key. This single mistake broke the entire security model of the PlayStation 3. This highlights the critical importance of using deterministic nonce generation (RFC 6979) as discussed in Lesson 9.</p>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Invalid Curve Attack Implementation (Conceptual)",
                            "language": "python",
                            "code": "# This conceptual script demonstrates the first step of an invalid curve attack.\n\n# The legitimate, standard curve is y^2 = x^3 + ax + b (mod p)\n\n# The attacker finds a different curve with a small subgroup order.\n# For example, y^2 = x^3 + ax + c (mod p) for some other 'c'.\n\n# The attacker then finds a low-order point (x', y') on this *invalid* curve.\n# For example, a point P' where 5*P' = O.\n\n# The attacker then sends this point P' to the victim as their 'public key' in an\n# ECDH key exchange.\n\n# --- On the Victim's Side (If Vulnerable) ---\n# The victim's software *should* check if the received point is actually on the curve.\n# It should check if (y')^2 = (x')^3 + a(x') + b (mod p).\n# If it does not perform this check, it proceeds with the key exchange.\n\n# The victim calculates the shared secret S = d_victim * P'.\n\n# Because P' has a small order (5), there are only 5 possible values for S.\n# The attacker can try all 5 possibilities and determine information about d_victim."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the most important countermeasure against an invalid curve attack?",
                            "options": [
                                "Using a larger prime number.",
                                "The receiving party must always validate that any received public key (point) actually satisfies the equation of the agreed-upon curve.",
                                "Using a faster scalar multiplication algorithm.",
                                "Encrypting the public key."
                            ],
                            "correct": 1,
                            "explanation": "Point validation is a critical, mandatory step in any secure ECC implementation. Never trust a public key received from an untrusted source without first verifying that it is a valid point on the correct curve."
                        },
                        {
                            "id": 2,
                            "question": "An attacker sends a public key that is a point of very small order (e.g., a point P where 3P = O). This is the basis for what kind of attack?",
                            "options": [
                                "A small subgroup attack",
                                "A timing attack",
                                "A fault injection attack",
                                "A brute-force attack"
                            ],
                            "correct": 0,
                            "explanation": "In a small subgroup attack, the attacker forces the ECDH shared secret to be one of only a very small number of possibilities, which they can then easily test. This is defeated by proper public key validation."
                        },
                        {
                            "id": 3,
                            "question": "The catastrophic failure in Sony's PlayStation 3 signature scheme was caused by what implementation bug?",
                            "options": [
                                "They used a weak elliptic curve.",
                                "They used too small a prime number.",
                                "They reused the same secret nonce `k` for every single signature.",
                                "They had a buffer overflow in their code."
                            ],
                            "correct": 2,
                            "explanation": "Nonce reuse is the cardinal sin of ECDSA. It completely breaks the algorithm's security and allows for a full recovery of the private key. This is why deterministic nonce generation (RFC 6979) is now the standard."
                        }
                    ]
                }
            },
            {
                "id": "lesson-24",
                "title": "Hyperelliptic Curve Cryptography",
                "duration": "90 min",
                "objectives": [
                    "Define a hyperelliptic curve.",
                    "Understand the concept of the Jacobian of a hyperelliptic curve.",
                    "Analyze Cantor's algorithm for performing group operations on the Jacobian.",
                    "Discuss the security of the Hyperelliptic Curve Discrete Logarithm Problem (HCDLP).",
                    "Compare the performance of HECC with standard ECC."
                ],
                "content": {
                    "overview": "This lesson provides an introduction to a generalization of elliptic curves known as hyperelliptic curves. We will explore how to define a group law on these more complex objects and discuss their potential applications, advantages, and disadvantages compared to standard elliptic curve cryptography.",
                "sections": [
                    {
                        "title": "Hyperelliptic Curves Definition",
                        "content": "<p>A hyperelliptic curve of genus `g` is the set of points `(x, y)` satisfying an equation of the form:</p><p style=\"text-align:center; font-size:1.5em; font-family: 'Times New Roman', serif;\"><i>y<sup>2</sup> + h(x)y = f(x)</i></p><p>where `h(x)` is a polynomial of degree at most `g`, and `f(x)` is a monic polynomial of degree `2g+1`. An elliptic curve is just the special case where `g=1`.</p>",
                            "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "The Jacobian and Cantor's Algorithm",
                            "content": "<p>Unlike elliptic curves, the points on a hyperelliptic curve do not themselves form a group. Instead, we must work with an object called the **Jacobian** of the curve. The Jacobian is a more abstract algebraic object, and its elements can be used to form a group.</p><p>The group operation on the Jacobian is performed using **Cantor's algorithm**. This is a more complex set of formulas than the standard chord-and-tangent rules for ECC, but it allows for an 'addition' operation to be defined, which is the basis for building a cryptosystem.</p>",
                            "image": "https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Security and Performance",
                            "content": "<p>The security of Hyperelliptic Curve Cryptography (HECC) relies on the hardness of the Hyperelliptic Curve Discrete Logarithm Problem (HCDLP).</p><h3>Potential Advantage:</h3><p>For the same level of security, a genus 2 hyperelliptic curve can use a smaller underlying finite field than a standard elliptic curve. This can lead to more compact keys and potentially faster computations in some scenarios.</p><h3>Disadvantage:</h3><p>The group law (Cantor's algorithm) is significantly more complex to implement than the standard ECC group law. This complexity can make implementations slower and more susceptible to bugs and side-channel attacks. For these reasons, while HECC is an active area of research, it has not seen the same widespread adoption as standard ECC.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Cantor's Algorithm Optimization (Conceptual)",
                            "language": "c",
                            "code": "// This is a conceptual C function signature for a highly optimized implementation\n// of Cantor's algorithm for adding two elements on the Jacobian of a hyperelliptic curve.\n\n// The elements of the Jacobian are represented by a pair of polynomials (u(x), v(x)).\n\nvoid jacobian_add(\n    polynomial* u1,\n    polynomial* v1,\n    polynomial* u2,\n    polynomial* v2,\n    polynomial* u3_out,\n    polynomial* v3_out,\n    hyperelliptic_curve_params* params\n) {\n    // This function would contain the many complex steps of Cantor's algorithm:\n    // 1. Compute the resultant of the two u polynomials.\n    // 2. Compute the inverse of the resultant.\n    // 3. Perform a series of polynomial multiplications and divisions.\n    // 4. Reduce the final resulting polynomial to get the output (u3, v3).\n\n    // Each of these steps would need to be implemented using efficient, constant-time\n    // polynomial arithmetic routines.\n}"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "An elliptic curve is a special case of a hyperelliptic curve with what genus?",
                            "options": [
                                "Genus 0",
                                "Genus 1",
                                "Genus 2",
                                "Genus 3"
                            ],
                            "correct": 1,
                            "explanation": "Standard elliptic curves are hyperelliptic curves of genus `g=1`. HECC typically uses curves with a genus of 2 or 3."
                        },
                        {
                            "id": 2,
                            "question": "In hyperelliptic curve cryptography, the group operation is defined on what mathematical object?",
                            "options": [
                                "The set of points on the curve itself.",
                                "The Jacobian of the curve.",
                                "A finite field.",
                                "A set of prime numbers."
                            ],
                            "correct": 1,
                            "explanation": "Unlike ECC, the points on a hyperelliptic curve do not form a group. Instead, a more abstract object called the Jacobian is used, and the group operation is defined on the elements of the Jacobian."
                        },
                        {
                            "id": 3,
                            "question": "What is the primary algorithm used to perform the group operation in the Jacobian of a hyperelliptic curve?",
                            "options": [
                                "The double-and-add algorithm",
                                "The Montgomery ladder",
                                "Schoof's algorithm",
                                "Cantor's algorithm"
                            ],
                            "correct": 3,
                            "explanation": "Cantor's algorithm is the set of formulas that defines the 'addition' operation for elements of the Jacobian, similar to how the chord-and-tangent rules define addition for standard elliptic curves."
                        }
                    ]
                }
            },
            {
                "id": "lesson-25",
                "title": "ECC in IoT and Embedded Systems",
                "duration": "90 min",
                "objectives": [
                    "Analyze the challenges of implementing cryptography on resource-constrained devices.",
                    "Select lightweight elliptic curves suitable for IoT.",
                    "Implement energy-efficient ECC algorithms.",
                    "Design secure boot and authentication protocols for IoT using ECC.",
                    "Understand the security of IoT communication protocols that use ECC."
                ],
                "content": {
                    "overview": "The Internet of Things (IoT) consists of billions of small, low-power, resource-constrained devices. Securing these devices is a massive challenge. This lesson focuses on the application of ECC in this constrained environment, exploring the techniques and lightweight curves that make it possible to bring strong public-key cryptography to even the smallest of sensors.",
                "sections": [
                    {
                        "title": "Resource-Constrained Implementations",
                        "content": "<p>An IoT device (like a smart lightbulb or a sensor) has a very different profile from a web server.</p><h3>The Constraints:</h3><ul><li><strong>Limited CPU:</strong> It may have a small, slow microcontroller.</li><li><strong>Limited RAM:</strong> It may only have a few kilobytes of RAM.</li><li><strong>Limited Power:</strong> It may need to run for years on a single battery.</li></ul><p>These constraints mean that the cryptographic algorithms must be extremely efficient in terms of code size, memory usage, and power consumption.</p>",
                            "image": "https://images.unsplash.com/photo-1535683416248-8495c6b8159b?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Lightweight Curve Selections",
                            "content": "<p>ECC's small key sizes make it a perfect fit for IoT. A 256-bit ECC key provides the same security as a 3072-bit RSA key, but the operations are much faster and require less power.</p><p>The choice of curve is also critical. Modern curves like **Curve25519** are extremely popular in IoT because they are designed for very high performance and are resistant to side-channel attacks, which is important for a physical device that an attacker could have in their hands.</p>",
                            "image": "https://images.unsplash.com/photo-1621452773352-2a74c35b2917?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "IoT Authentication and Secure Boot",
                            "content": "<p>ECC is the foundation of security for many IoT ecosystems.</p><p><strong>Real-world Example: Secure Boot with ECC.</strong> An IoT device needs to ensure that it is only running authentic, manufacturer-signed firmware. The device has the manufacturer's public key burned into its read-only memory. When the device boots, its bootloader calculates a hash of the main firmware. It then uses ECC to verify the digital signature of that firmware. If the signature is valid and was created by the manufacturer's private key, the boot proceeds. If not, the device refuses to boot. This prevents an attacker from being able to flash a malicious firmware image onto the device.</p>",
                            "image": "https://images.unsplash.com/photo-1593435713588-a73de23947db?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Microcontroller ECC Implementation (micro-ecc)",
                            "language": "c",
                            "code": "/* This is a conceptual C code snippet using the 'micro-ecc' library, which is\n   designed specifically for resource-constrained IoT devices.\n*/\n\n#include \"uECC.h\"\n#include <stdio.h>\n\nint main() {\n    // 1. Choose the curve. secp256r1 is the NIST P-256 curve.\n    const struct uECC_Curve_t* curve = uECC_secp256r1();\n\n    uint8_t private_key[32];\n    uint8_t public_key[64];\n\n    // 2. Generate a key pair.\n    if (!uECC_make_key(public_key, private_key, curve)) {\n        printf(\"Key generation failed!\\n\");\n        return 1;\n    }\n\n    // 3. Sign a message.\n    uint8_t message_hash[32];\n    // ... (code to hash the message) ...\n    uint8_t signature[64];\n    if (!uECC_sign(private_key, message_hash, sizeof(message_hash), signature, curve)) {\n        printf(\"Signing failed!\\n\");\n        return 1;\n    }\n\n    // 4. Verify the signature.\n    if (!uECC_verify(public_key, message_hash, sizeof(message_hash), signature, curve)) {\n        printf(\"Verification failed!\\n\");\n        return 1;\n    }\n\n    printf(\"Signature is VALID.\\n\");\n    return 0;\n}"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the primary reason that ECC is preferred over RSA for securing IoT devices?",
                            "options": [
                                "ECC is older.",
                                "RSA is not secure.",
                                "ECC provides the same level of security with much smaller key sizes and more efficient computations, which is ideal for resource-constrained devices.",
                                "IoT devices do not need security."
                            ],
                            "correct": 2,
                            "explanation": "The efficiency of ECC is its key advantage for IoT. The smaller key sizes and faster, less power-intensive computations are a perfect fit for the limited resources of an embedded device."
                        },
                        {
                            "id": 2,
                            "question": "Which modern elliptic curve is particularly well-suited for IoT due to its high performance and built-in resistance to side-channel attacks?",
                            "options": [
                                "NIST P-521",
                                "secp256k1",
                                "Curve25519",
                                "BrainpoolP256r1"
                            ],
                            "correct": 2,
                            "explanation": "Curve25519 (and its signature counterpart Ed25519) was specifically designed for performance and ease of secure implementation, making it a very popular choice for modern, high-security IoT applications."
                        },
                        {
                            "id": 3,
                            "question": "The process where an IoT device cryptographically verifies the signature of its firmware before executing it is known as:",
                            "options": [
                                "Key exchange",
                                "Secure Boot",
                                "Encryption",
                                "A side-channel attack"
                            ],
                            "correct": 1,
                            "explanation": "Secure Boot is a fundamental security feature for embedded devices. It creates a chain of trust, anchored by a public key burned into hardware, to ensure that only authentic, manufacturer-signed code can be run on the device."
                        }
                    ]
                }
            },
            
        {
            "id": "lesson-26",
            "title": "Algebraic Attacks on ECC",
            "duration": "90 min",
            "objectives": [
                "Understand the concept of algebraic attacks on cryptosystems.",
                "Explore how to construct an algebraic system from ECC parameters.",
                "Learn about the use of Gröbner bases to solve systems of polynomial equations.",
                "Analyze the complexity of algebraic attacks and their feasibility.",
                "Discuss the importance of algebraic immunity in curve selection."
            ],
            "content": {
                "overview": "This lesson explores a different class of attacks against ECC that do not attempt to solve the discrete logarithm problem directly, but instead try to model the entire cryptosystem as a system of polynomial equations and then solve that system. These 'algebraic attacks' are a major area of theoretical research and drive the selection of secure curve parameters.",
                "sections": [
                    {
                        "title": "Constructing an Algebraic System",
                        "content": "<p>The core idea of an algebraic attack is to translate the elliptic curve equation and the scalar multiplication process into a large system of multivariate polynomial equations over the finite field. The variables in this system would be the bits of the secret private key.</p><p>If this system of equations could be solved efficiently, then the private key could be recovered. The security of ECC therefore relies on the presumed hardness of solving these large, complex systems.</p>",
                        "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Gröbner Basis Attacks",
                        "content": "<p>A Gröbner basis is a special set of polynomials that has useful properties for solving a larger system. An algorithm can be used to compute the Gröbner basis of the system derived from the elliptic curve. In theory, this could be used to find the solution (the private key).</p><p>However, for the large, well-chosen curves used in real-world cryptography, the complexity of computing the Gröbner basis is astronomical, making this attack purely theoretical and infeasible in practice.</p>",
                        "image": "https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Algebraic Immunity and Curve Selection",
                        "content": "<p>When cryptographers design a standard elliptic curve, they must analyze its resistance to these algebraic attacks. They must ensure that the system of equations derived from the curve does not have some special structure that would make it easy to solve. A curve that is resistant to these attacks is said to have a high **algebraic immunity**. This is a critical criterion for any standardized curve.</p>",
                        "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Gröbner Basis Computation (SageMath)",
                        "language": "python",
                        "code": "# This is a conceptual script using SageMath, a powerful open-source mathematics software.\n# It demonstrates solving a *very small* system of polynomial equations using a Gröbner basis.\n\n# Define the polynomial ring. We have two variables, x and y.\nR = PolynomialRing(QQ, 'x, y')\nx, y = R.gens()\n\n# Define the system of equations we want to solve:\n# f1: x^2 + y^2 - 4 = 0\n# f2: x*y - 1 = 0\nf1 = x**2 + y**2 - 4\nf2 = x*y - 1\n\n# Create an 'ideal' from these polynomials.\nI = R.ideal(f1, f2)\n\n# Compute the Gröbner basis of the ideal.\nB = I.groebner_basis()\n\nprint(\"--- Gröbner Basis ---\")\nprint(B)\n\n# An analyst can use the basis to find the solutions.\n# For an ECC system, the variables would be the bits of the private key, and there\n# would be hundreds of equations, making this computationally infeasible."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "An algebraic attack attempts to break a cryptosystem by doing what?",
                        "options": [
                            "By guessing the private key.",
                            "By modeling the cryptosystem as a system of polynomial equations and then solving it.",
                            "By launching a denial-of-service attack.",
                            "By analyzing the power consumption of the device."
                        ],
                        "correct": 1,
                        "explanation": "Algebraic attacks translate the entire cryptographic problem into a system of equations. The attack is then reduced to the problem of solving that system, which is a hard problem in computational algebra."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary reason that algebraic attacks are not a practical threat to standard, well-chosen elliptic curves?",
                        "options": [
                            "The math is too new.",
                            "The complexity of solving the resulting system of equations for a 256-bit curve is computationally infeasible.",
                            "The equations cannot be generated.",
                            "The attacks only work on weekends."
                        ],
                        "correct": 1,
                        "explanation": "While theoretically possible, the scale of the problem is the defense. For a standard curve, the number of variables and equations is so large that algorithms like computing a Gröbner basis would take an astronomical amount of time."
                    },
                    {
                        "id": 3,
                        "question": "A curve that is designed to be resistant to algebraic attacks is said to have high:",
                        "options": [
                            "Performance",
                            "Algebraic immunity",
                            "Compatibility",
                            "Complexity"
                        ],
                        "correct": 1,
                        "explanation": "Algebraic immunity is a key security criterion in modern curve design. It's a measure of how resistant the curve's underlying mathematical structure is to being solved by these advanced algebraic methods."
                    }
                ]
            }
        },
        {
            "id": "lesson-27",
            "title": "ECC in Digital Identity Systems",
            "duration": "90 min",
            "objectives": [
                "Understand the principles of Self-Sovereign Identity (SSI).",
                "Explain the role of Decentralized Identifiers (DIDs) and their connection to ECC.",
                "Analyze the structure and verification of Verifiable Credentials.",
                "Discuss the use of Identity-Based Encryption (IBE) with ECC.",
                "Explore protocols for privacy-preserving authentication."
            ],
            "content": {
                "overview": "This lesson explores the application of ECC in the next generation of digital identity systems. We will move beyond simple authentication to the world of decentralized and self-sovereign identity, where users have ultimate control over their own digital credentials, all secured by the power of elliptic curve cryptography.",
                "sections": [
                    {
                        "title": "Self-Sovereign Identity (SSI)",
                        "content": "<p>SSI is a model for digital identity where the individual user is in full control. Instead of relying on a centralized provider (like Google or a government) to hold and manage their identity, the user holds their own credentials in a digital wallet on their own device.</p><p>This model is built on two key cryptographic concepts: Decentralized Identifiers (DIDs) and Verifiable Credentials (VCs).</p>",
                        "image": "https://images.unsplash.com/photo-1556740714-a8395b3bf30f?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Decentralized Identifiers (DIDs) and Verifiable Credentials (VCs)",
                        "content": "<h3>DIDs:</h3><p>A DID is a globally unique identifier that a user can create for themselves, which does not depend on any central authority. A DID resolves to a 'DID Document', which contains the user's public keys (almost always ECC public keys). The user controls the corresponding private keys in their wallet.</p><h3>VCs:</h3><p>A VC is a digital version of a physical credential, like a driver's license or a university degree. It is a set of claims that is cryptographically signed by a trusted issuer (like the DMV or a university) with their DID. The user can then store this VC in their wallet.</p><p><strong>Real-world Example:</strong> A user wants to prove to an online store that they are over 18 without revealing their name or date of birth. The user has a Verifiable Credential in their wallet from the DMV. They can use a ZKP (as seen in Lesson 18) to generate a proof from this VC that shows *only* that the 'age' claim is greater than 18. They sign this proof with their DID, and the store can verify it without ever seeing the user's personal information.</p>",
                        "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Privacy-Preserving Authentication",
                        "content": "<p>ECC enables powerful privacy-preserving protocols.</p><p>For example, instead of a password, a user can authenticate to a website using a signature from their ECC key. This is the principle behind standards like FIDO2/WebAuthn. It is more secure (no password to be phished) and better for privacy (the user's identity is not tied to a single, global username/password).</p>",
                        "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Verifiable Credential System (Conceptual JSON-LD)",
                        "language": "json",
                        "code": "{\n  \"@context\": \"https://www.w3.org/2018/credentials/v1\",\n  \"id\": \"http://example.edu/credentials/3732\",\n  \"type\": [\"VerifiableCredential\", \"UniversityDegreeCredential\"],\n  \"issuer\": \"did:example:76e12ec712ebc6f1c221eb46\", // The University's DID\n  \"issuanceDate\": \"2024-01-01T19:23:24Z\",\n  \"credentialSubject\": {\n    \"id\": \"did:example:ebfeb1f712ebc6f1c276e12ec21\", // The Student's DID\n    \"degree\": {\n      \"type\": \"BachelorDegree\",\n      \"name\": \"Bachelor of Science in Cryptography\"\n    }\n  },\n  // The proof is a digital signature (e.g., Ed25519) made by the issuer's private key.\n  \"proof\": {\n    \"type\": \"Ed25519Signature2018\",\n    \"created\": \"2024-01-01T19:23:24Z\",\n    \"verificationMethod\": \"did:example:76e12ec712ebc6f1c221eb46#keys-1\",\n    \"proofPurpose\": \"assertionMethod\",\n    \"jws\": \"eyJ...\"\n  }\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "The identity model where the user has full control over their own digital credentials in their own wallet is known as:",
                        "options": [
                            "Centralized Identity",
                            "Federated Identity",
                            "Self-Sovereign Identity (SSI)",
                            "Anonymous Identity"
                        ],
                        "correct": 2,
                        "explanation": "SSI is a paradigm shift that puts the user at the center of their digital identity, giving them control over how their data is shared."
                    },
                    {
                        "id": 2,
                        "question": "In an SSI ecosystem, a user's public keys are typically published in a document associated with their:",
                        "options": [
                            "Email address",
                            "Social Security Number",
                            "Decentralized Identifier (DID)",
                            "Password"
                        ],
                        "correct": 2,
                        "explanation": "The DID is the core of SSI. It's a globally unique identifier that the user controls, and it resolves to a DID Document that contains their cryptographic keys and other metadata."
                    },
                    {
                        "id": 3,
                        "question": "A digitally signed, tamper-proof version of a real-world credential (like a driver's license) is known as a:",
                        "options": [
                            "Decentralized Identifier (DID)",
                            "Verifiable Credential (VC)",
                            "Public Key",
                            "Smart Contract"
                        ],
                        "correct": 1,
                        "explanation": "Verifiable Credentials are the 'what' of SSI. They are the signed claims or attestations (like 'is over 18' or 'has a degree') that a user can present to others to prove something about themselves."
                    }
                ]
            }
        },
        {
            "id": "lesson-28",
            "title": "Advanced Pairing Applications",
            "duration": "90 min",
            "objectives": [
                "Understand and implement aggregate signatures using pairings.",
                "Analyze the construction of efficient multi-signature schemes.",
                "Explore the use of Verifiable Random Functions (VRFs).",
                "Discuss the principles of searchable and functional encryption.",
                "Apply pairings to build advanced cryptographic protocols."
            ],
            "content": {
                "overview": "This lesson explores the powerful applications that are made possible by the unique bilinear property of cryptographic pairings. We will cover advanced signature schemes like aggregate and multi-signatures, and introduce other powerful concepts like Verifiable Random Functions and searchable encryption.",
                "sections": [
                    {
                        "title": "Aggregate Signatures",
                        "content": "<p>An aggregate signature is a single, compact signature that validates multiple different signatures from multiple different signers on multiple different messages.</p><p>The BLS signature scheme (from Lesson 15) has this property. If you have `n` signatures, you can add all the signature points together to create a single aggregate signature point. To verify, you only need to perform two pairings, regardless of how many signatures were aggregated. This provides a massive efficiency gain and is a key reason for its popularity in blockchain applications, where block space is valuable.</p>",
                        "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Verifiable Random Functions (VRFs)",
                        "content": "<p>A VRF is like a public-key version of a keyed hash function. It takes an input and produces a random-looking output, but it also produces a proof that the output was generated correctly using the secret key.</p><p>Anyone with the public key can verify the proof, but they cannot generate the random output themselves. VRFs are used in some blockchain consensus protocols to fairly and verifiably select the next block producer, and in privacy-preserving protocols.</p>",
                        "image": "https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Searchable and Functional Encryption",
                        "content": "<p>These are advanced cryptographic techniques that are often built using pairings.</p><ul><li><strong>Searchable Encryption:</strong> Allows you to store encrypted data on an untrusted server, and then give the server a 'token' that allows it to search for a specific keyword within the encrypted data, without ever being able to decrypt the data itself.</li><li><strong>Functional Encryption:</strong> An even more powerful concept. It allows a user to create a special decryption key that only reveals a specific *function* of the encrypted data. For example, you could give a key to an AI model that allows it to determine if an encrypted medical image contains a tumor, without allowing it to see the actual image.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "BLS Aggregate Signatures (Conceptual)",
                        "language": "python",
                        "code": "# This is a conceptual script showing the logic of BLS aggregate signatures.\n\n# --- Three different signers sign three different messages ---\n# Alice signs message M1 -> Signature S1 = d1*H(M1)\n# Bob signs message M2 -> Signature S2 = d2*H(M2)\n# Carol signs message M3 -> Signature S3 = d3*H(M3)\n\n# --- Aggregation ---\n# The aggregator (e.g., a blockchain node) receives all three signatures.\n# They aggregate them by simply adding the signature points together.\nS_agg = point_addition(S1, point_addition(S2, S3))\n\n# --- Verification ---\n# A verifier can check the single aggregate signature with a single equation.\n# They need the public keys (Q1, Q2, Q3) and the message hashes (H1, H2, H3).\n\n# Check if: e(G, S_agg) == e(Q1, H1) * e(Q2, H2) * e(Q3, H3)\n\n# Left Side\nleft = pairing(G, S_agg)\n\n# Right Side\nright = pairing(Q1, H1) * pairing(Q2, H2) * pairing(Q3, H3)\n\nif left == right:\n    print(\"[+] Aggregate signature is VALID.\")\nelse:\n    print(\"[!] Aggregate signature is INVALID.\")"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the key feature of the BLS signature scheme?",
                        "options": [
                            "It is not secure.",
                            "The signatures are aggregatable, allowing a single small signature to validate many different signatures.",
                            "It is based on the RSA problem.",
                            "It can only be used for encryption."
                        ],
                        "correct": 1,
                        "explanation": "The ability to aggregate signatures is the key feature of BLS. This is extremely valuable for reducing the amount of data that needs to be stored on a blockchain, as it allows a single signature to validate many transactions."
                    },
                    {
                        "id": 2,
                        "question": "A cryptographic primitive that generates a random-looking output but also a proof that the output was generated correctly is a:",
                        "options": [
                            "Hash function",
                            "Verifiable Random Function (VRF)",
                            "Digital Signature",
                            "Key Exchange"
                        ],
                        "correct": 1,
                        "explanation": "A VRF combines the properties of a public-key cryptosystem with a random function. It provides a way to get a verifiable, deterministic random output that can only be generated by the holder of the private key."
                    },
                    {
                        "id": 3,
                        "question": "A system that allows a server to search for keywords within encrypted data without being able to decrypt the data is known as:",
                        "options": [
                            "Functional Encryption",
                            "Identity-Based Encryption",
                            "Searchable Encryption",
                            "Homomorphic Encryption"
                        ],
                        "correct": 2,
                        "explanation": "Searchable encryption is a powerful privacy-preserving technique that allows a user to offload storage to an untrusted cloud provider while still retaining the ability to search their data."
                    }
                ]
            }
        },
        {
            "id": "lesson-29",
            "title": "ECC Standards and Compliance",
            "duration": "90 min",
            "objectives": [
                "Understand the requirements of the FIPS 186-4 standard for digital signatures.",
                "Explore the Common Criteria evaluation process for cryptographic modules.",
                "Navigate industry-specific certification and regulatory frameworks.",
                "Discuss the role of international standardization bodies (ISO/IEC, IETF).",
                "Perform conformance testing against standard test vectors."
            ],
            "content": {
                "overview": "For a cryptographic product to be sold to governments or used in highly regulated industries, it must undergo a rigorous process of testing, validation, and certification against established standards. This lesson provides an overview of the key standards and compliance frameworks that govern the real-world deployment of elliptic curve cryptography.",
                "sections": [
                    {
                        "title": "FIPS 186-4 and NIST Standards",
                        "content": "<p>In the United States, the primary standard for digital signatures is **FIPS 186-4 (Digital Signature Standard)**, published by the National Institute of Standards and Technology (NIST). This standard specifies the approved algorithms (including ECDSA) and the approved elliptic curves (like P-256) that can be used for US government applications.</p><p>Any cryptographic module sold to the US government must undergo a formal validation process through the **Cryptographic Module Validation Program (CMVP)** to receive a FIPS 140-2/3 certificate. This is a very expensive and time-consuming process that involves rigorous testing of the implementation.</p>",
                        "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Common Criteria",
                        "content": "<p>The Common Criteria (CC) is an international standard (ISO/IEC 15408) for computer security certification. It provides a framework for evaluating the security of an IT product.</p><p>A product vendor will define a 'Protection Profile' that specifies the security claims for their product. A licensed, independent laboratory will then perform a detailed evaluation of the product to determine if it meets those claims up to a certain Evaluation Assurance Level (EAL). Gaining a high EAL level is a common requirement for products sold in the defense and intelligence communities.</p>",
                        "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Conformance Testing",
                        "content": "<p>A key part of any validation process is conformance testing. The standards body (like NIST) will publish a huge set of **Known Answer Tests (KATs)**. These are test vectors with pre-computed inputs and their expected correct outputs.</p><p>To be validated, a cryptographic implementation must be run against this entire test suite, and its output for every single test vector must exactly match the official known answer. This proves that the implementation is mathematically correct and conforms to the standard.</p>",
                        "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "FIPS Compliance Testing (KAT)",
                        "language": "python",
                        "code": "# This is a conceptual script for running a Known Answer Test (KAT).\n\n# The test vector file (provided by NIST) would contain hundreds of these.\nkat_vector = {\n    \"curve\": \"P-256\",\n    \"private_key\": \"c9afa9d845ba75166b5c215767b1d6934e50c3db36e89b127b8a622b120f6721\",\n    \"message_hash\": \"a546251e60052061e5e0f7de181942a4b89381e018e388147702816911d33118\",\n    \"nonce_k\": \"a6e3c57dd01abe90086538398355dd4c3b17aa873382b0f24d6129493d8AAD60\",\n    \"expected_r\": \"efd48b2aacb6a8fd1140dd989d47b165f89c826751a683ed8f8fdc1766e4d07e\",\n    \"expected_s\": \"7948b6034d31d2db24b75a46a06669fb8032145321540294985fff8b6cd68a57\"\n}\n\n# 1. Your cryptographic library's ECDSA signing function.\ndef my_ecdsa_sign(private_key, message_hash, nonce_k):\n    # ... your implementation ...\n    return r, s\n\n# 2. Run the test.\ncomputed_r, computed_s = my_ecdsa_sign(\n    kat_vector[\"private_key\"],\n    kat_vector[\"message_hash\"],\n    kat_vector[\"nonce_k\"]\n)\n\n# 3. Compare your output to the known answer.\nif computed_r == kat_vector[\"expected_r\"] and computed_s == kat_vector[\"expected_s\"]:\n    print(\"[+] KAT Passed!\")\nelse:\n    print(\"[!] KAT Failed! Implementation is not compliant.\")"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "In the United States, the primary standard that specifies the approved algorithms and curves for government use is:",
                        "options": [
                            "ISO/IEC 15408",
                            "FIPS 186-4",
                            "RFC 6979",
                            "PCI DSS"
                        ],
                        "correct": 1,
                        "explanation": "FIPS 186-4 (the Digital Signature Standard) is the key NIST publication that defines the requirements for digital signatures. FIPS 140-2/3 is the standard for the cryptographic modules that implement these algorithms."
                    },
                    {
                        "id": 2,
                        "question": "The international standard for computer security certification, which provides a framework for evaluating a product against a set of security claims, is known as:",
                        "options": [
                            "FIPS 140-2",
                            "The Common Criteria (ISO/IEC 15408)",
                            "The GDPR",
                            "The HIPAA Security Rule"
                        ],
                        "correct": 1,
                        "explanation": "The Common Criteria is a widely recognized international framework. Achieving a CC certification is a major requirement for selling security products to many governments and large enterprises."
                    },
                    {
                        "id": 3,
                        "question": "The process of testing a cryptographic implementation against a set of test vectors with pre-computed, known correct outputs is called:",
                        "options": [
                            "A penetration test",
                            "A fuzzing campaign",
                            "A Known Answer Test (KAT)",
                            "A code audit"
                        ],
                        "correct": 2,
                        "explanation": "KATs are a fundamental part of cryptographic validation. They provide a simple pass/fail test to ensure that an implementation is mathematically correct and conforms to the standard."
                    }
                ]
            }
        },
        {
            "id": "lesson-30",
            "title": "Quantum-Safe Elliptic Curve Research",
            "duration": "90 min",
            "objectives": [
                "Understand the properties of supersingular elliptic curves.",
                "Explain the principles of isogeny-based cryptography.",
                "Analyze the SIDH (Supersingular Isogeny Diffie-Hellman) protocol.",
                "Discuss the challenges and current state of quantum-resistant signature schemes.",
                "Explore the research frontiers in post-quantum ECC."
            ],
            "content": {
                "overview": "This lesson focuses on the cutting-edge research at the intersection of elliptic curves and post-quantum cryptography. We will explore isogeny-based cryptography, a unique approach that uses the structure of elliptic curves to build a new hard problem that is believed to be resistant to quantum computers, and discuss the ongoing effort to standardize these next-generation algorithms.",
                "sections": [
                    {
                        "title": "Supersingular Elliptic Curves",
                        "content": "<p>A supersingular elliptic curve is a special type of elliptic curve with certain mathematical properties that make it suitable for isogeny-based cryptography. These are the curves used in protocols like SIKE.</p>",
                        "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Isogeny-Based Cryptography",
                        "content": "<p>An **isogeny** is a special kind of map between two elliptic curves. Isogeny-based cryptography builds its security on the hardness of finding a specific isogeny (the 'path') between two given curves.</p><p><strong>Supersingular Isogeny Diffie-Hellman (SIDH):</strong> This was a key exchange protocol, similar in structure to ECDH, but its security was based on the isogeny problem. It was a promising candidate for post-quantum key exchange due to its very small key sizes. However, a major breakthrough in 2022 led to a complete break of the SIKE (Supersingular Isogeny Key Encapsulation) version of the protocol, demonstrating that this is still a very new and rapidly evolving area of research.</p>",
                        "image": "https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Research Frontiers and Challenges",
                        "content": "<p>The break of SIKE has spurred a huge amount of new research into isogeny-based cryptography to see if the protocols can be fixed or if new, more secure isogeny-based systems can be developed. This is one of the most active and exciting areas of modern cryptographic research. The goal is to find a post-quantum algorithm that has the elegance and efficiency of ECC, a challenge that has so far proven to be extremely difficult.</p>",
                        "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Isogeny Computation (SageMath)",
                        "language": "python",
                        "code": "# This is a conceptual script using SageMath to demonstrate an isogeny computation.\n\n# 1. Define a prime field and an elliptic curve over it.\np = 431\nK = GF(p)\nE = EllipticCurve(K, [a, b])\n\n# 2. Find a point on the curve to be the kernel of our isogeny.\nP = E.random_point()\n\n# 3. Create an isogeny from the curve E with the kernel <P>.\n# The degree of the isogeny is the order of the point P.\nphi = E.isogeny(P)\n\n# 4. The codomain of the isogeny is a new, isogenous elliptic curve.\nE_codomain = phi.codomain()\n\nprint(f\"Original Curve: {E}\")\nprint(f\"Isogenous Curve: {E_codomain}\")\n\n# The hard problem is: given E and E_codomain, find the isogeny phi."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "Isogeny-based cryptography is a type of:",
                        "options": [
                            "Symmetric cryptography",
                            "Post-quantum cryptography",
                            "Hashing algorithm",
                            "Integer factorization"
                        ],
                        "correct": 1,
                        "explanation": "It is one of the main families of post-quantum cryptography, and it is unique in that it is still based on the mathematics of elliptic curves."
                    },
                    {
                        "id": 2,
                        "question": "What is an 'isogeny'?",
                        "options": [
                            "A type of elliptic curve.",
                            "A special kind of map between two elliptic curves.",
                            "A type of digital signature.",
                            "A cryptographic hash function."
                        ],
                        "correct": 1,
                        "explanation": "An isogeny is a specific type of algebraic map. The hard problem in isogeny-based cryptography is to find the specific isogeny that connects two related curves."
                    },
                    {
                        "id": 3,
                        "question": "What happened to the SIKE (Supersingular Isogeny Key Encapsulation) protocol?",
                        "options": [
                            "It was chosen as the primary standard by NIST.",
                            "It was found to be too slow to be practical.",
                            "A major research breakthrough in 2022 led to a complete break of the protocol using a classical computer.",
                            "It is still considered secure."
                        ],
                        "correct": 2,
                        "explanation": "The break of SIKE was a major event in the cryptographic community. It demonstrated that while isogeny-based cryptography is promising, it is still a new field and our understanding of its security is still evolving."
                    }
                ]
            }
        },
        {
            "id": "lesson-31",
            "title": "ECC Performance Engineering",
            "duration": "90 min",
            "objectives": [
                "Establish and use formal benchmarking methodologies.",
                "Apply performance profiling techniques to identify bottlenecks.",
                "Implement memory and cache-efficient algorithms.",
                "Use parallel processing and multi-threaded operations to accelerate ECC.",
                "Design a comprehensive benchmarking suite for an ECC library."
            ],
            "content": {
                "overview": "This lesson is a deep dive into the art of making ECC fast. We will cover the formal methodologies for benchmarking and profiling cryptographic implementations to find the exact bottlenecks, and explore advanced software engineering techniques, from cache-aware algorithms to parallel processing, to optimize every aspect of an ECC implementation for maximum performance.",
                "sections": [
                    {
                        "title": "Benchmarking and Profiling",
                        "content": "<p>You cannot optimize what you cannot measure. Formal benchmarking is the first step.</p><h3>The Process:</h3><ol><li><strong>Define Metrics:</strong> What are you measuring? (e.g., cycles per operation, signatures per second).</li><li><strong>Establish a Baseline:</strong> Measure the performance of a standard, un-optimized implementation.</li><li><strong>Profile the Code:</strong> Use a profiling tool (like `gprof` or Intel VTune) to determine exactly where the code is spending most of its time. Is it the modular multiplication? The inversion?</li><li><strong>Optimize:</strong> Apply an optimization technique to the identified bottleneck.</li><li><strong>Measure Again:</strong> Re-run the benchmark and compare the results to the baseline to quantify the improvement.</li></ol>",
                            "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Memory and Cache-Efficient Algorithms",
                            "content": "<p>A major bottleneck in modern CPUs is memory latency. An algorithm that has to constantly fetch data from main memory will be slow. Cache-efficient algorithms are designed to keep the data they need in the CPU's fast L1/L2 cache as much as possible.</p><p><strong>Real-world Example:</strong> In a scalar multiplication, an implementation can use pre-computation to store a table of multiples of the base point `G` (e.g., `2G`, `4G`, `8G`, etc.). When performing the multiplication, it can then look up these values from the table instead of re-computing them. A cache-aware implementation will carefully organize this table in memory to ensure that the most frequently accessed values are likely to remain in the CPU cache, minimizing slow RAM accesses.</p>",
                            "image": "https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Parallel Processing",
                            "content": "<p>On a server with multiple CPU cores, many cryptographic operations can be performed in parallel. For example, when a server is verifying a batch of 1000 BLS signatures, it can assign each signature verification to a different thread running on a different core. This allows the server's throughput (signatures verified per second) to scale linearly with the number of available CPU cores.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Comprehensive Benchmarking Suite (Google Benchmark)",
                            "language": "cpp",
                            "code": "#include <benchmark/benchmark.h>\n#include \"my_ecc_library.h\"\n\n// This is a conceptual benchmark using Google's Benchmark library.\n\n// Define a benchmark for the key generation function.\nstatic void BM_ECC_KeyGeneration(benchmark::State& state) {\n  for (auto _ : state) {\n    // This code gets timed.\n    generate_ecc_key_pair();\n  }\n}\nBENCHMARK(BM_ECC_KeyGeneration);\n\n// Define a benchmark for the ECDSA signing function.\nstatic void BM_ECDSA_Sign(benchmark::State& state) {\n  auto key = generate_ecc_key_pair();\n  unsigned char message[] = \"test\";\n  for (auto _ : state) {\n    ecdsa_sign(key, message);\n  }\n}\nBENCHMARK(BM_ECDSA_Sign);\n\nBENCHMARK_MAIN();\n\n// The benchmark framework will run these functions many times, collect statistics,\n// and produce a detailed report on their performance, allowing a developer to\n// precisely measure the impact of their optimizations."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the first and most critical step in performance engineering?",
                            "options": [
                                "To guess where the bottleneck is.",
                                "To rewrite the code in assembly.",
                                "To formally benchmark and profile the code to get data on where it is spending most of its time.",
                                "To buy a faster computer."
                            ],
                            "correct": 2,
                            "explanation": "The cardinal rule of optimization is 'measure, don't guess'. Profiling provides the data that allows a developer to focus their efforts on the parts of the code that will actually make a meaningful difference in performance."
                        },
                        {
                            "id": 2,
                            "question": "An algorithm that is designed to minimize accesses to main memory by keeping its working data in the CPU's fast L1/L2 cache is known as a:",
                            "options": [
                                "Parallel algorithm",
                                "Cache-efficient algorithm",
                                "Distributed algorithm",
                                "Memory-intensive algorithm"
                            ],
                            "correct": 1,
                            "explanation": "Cache efficiency is a key part of modern performance engineering. Minimizing cache misses and keeping the CPU fed with data is crucial for achieving high performance."
                        },
                        {
                            "id": 3,
                            "question": "A server that needs to verify thousands of signatures per second would most likely leverage what to improve its throughput?",
                            "options": [
                                "A slower CPU.",
                                "Parallel processing across multiple CPU cores.",
                                "A smaller hard drive.",
                                "A less efficient algorithm."
                            ],
                            "correct": 1,
                            "explanation": "Signature verification is a highly parallelizable task. By spreading the work across many cores, a server can significantly increase the number of verifications it can perform per second."
                        }
                    ]
                }
            },
            {
                "id": "lesson-32",
                "title": "Formal Verification of ECC",
                "duration": "90 min",
                "objectives": [
                    "Write a formal specification for an ECC protocol using a language like TLA+.",
                    "Use a model checker to test an ECC implementation for logical flaws.",
                    "Understand how to use a theorem prover to create a machine-checked proof of correctness.",
                    "Apply automated verification tools to find bugs in cryptographic code."
                ],
                "content": {
                    "overview": "Testing can find the presence of bugs, but it can never prove their absence. This lesson introduces the advanced field of formal verification, the use of rigorous, mathematical methods to *prove* that a cryptographic implementation is correct and free from a certain class of errors. This provides the highest possible level of assurance.",
                "sections": [
                    {
                        "title": "Formal Specification and Model Checking",
                        "content": "<p>A formal specification is a description of a system in a completely unambiguous mathematical language. A model checker is an automated tool that takes this specification and explores every single possible state the system can be in, checking for violations of a security property.</p><p><strong>Real-world Example:</strong> A developer writes a formal specification for a TLS key exchange protocol in a language like TLA+. They also specify a security property: 'the session key should never be known to an attacker'. The TLA+ model checker will then exhaustively explore all possible interleavings of messages between the client, server, and an active attacker. If there is *any* sequence of events that could lead to the attacker learning the key, the model checker will find it and provide a specific trace of the attack.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Theorem Proving",
                            "content": "<p>Theorem proving is an even more powerful technique. The developer uses an interactive theorem prover (like Coq or Isabelle/HOL) to write a full, mathematical proof of the code's correctness. The proof itself is checked by the computer for logical consistency.</p><p>This is an extremely difficult and time-consuming process, but it provides the highest possible level of assurance. There are now formally verified implementations of major cryptographic libraries where the entire implementation has been proven to be free of common implementation bugs like buffer overflows or side-channel leaks.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Correctness Proofs",
                            "content": "<p>The goal of formal verification is to produce a machine-checked proof that the *implementation* of the code correctly matches the *specification* of the protocol. This ensures that the secure, high-level design was not undermined by a subtle bug in the low-level code.</p>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Formal ECC Specification (TLA+)",
                            "language": "prolog",
                            "code": "---- MODULE KeyExchange ----\nEXTENDS Naturals, FiniteSets\n\nVARIABLES client_key, server_key, shared_secret\n\nInit == \n  /\\ client_key \\in 1..10\n  /\\ server_key \\in 1..10\n  /\\ shared_secret = 0\n\nClientSend == \n    shared_secret' = client_key * server_key\n\nServerSend == \n    shared_secret' = server_key * client_key\n\nNext == ClientSend \\/ ServerSend\n\n(* A security property we want to check *)\nSpec == Init /\\ [][Next]_vars\n\n(* Theorem: The shared secret is always the same *)\nTheorem Commutativity == Spec => [](shared_secret' = shared_secret)\n\n----"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the primary goal of formal verification?",
                            "options": [
                                "To make a protocol run faster.",
                                "To use rigorous, mathematical methods to prove that a protocol or implementation is correct and free from a certain class of logical flaws.",
                                "To choose which elliptic curve to use.",
                                "To write a report for management."
                            ],
                            "correct": 1,
                            "explanation": "Formal verification is about correctness. It uses mathematical logic to provide a much higher level of assurance than traditional testing, which can only find bugs, not prove their absence."
                        },
                        {
                            "id": 2,
                            "question": "The technique of using an automated tool to explore all possible states of a protocol to check for security violations is known as:",
                            "options": [
                                "Theorem Proving",
                                "Penetration Testing",
                                "Model Checking",
                                "Fuzzing"
                            ],
                            "correct": 2,
                            "explanation": "Model checking is a formal verification technique where a model of the system is created, and an automated tool exhaustively checks it against a given specification to find any violations."
                        },
                        {
                            "id": 3,
                            "question": "A machine-checked, mathematical proof of a protocol's security is typically created using what kind of tool?",
                            "options": [
                                "A fuzzer",
                                "A model checker",
                                "A theorem prover (or proof assistant)",
                                "A compiler"
                            ],
                            "correct": 2,
                            "explanation": "A theorem prover, like Coq or Isabelle/HOL, is an interactive tool that allows a researcher to build a formal, step-by-step mathematical proof that is then checked for logical consistency by the computer. It is an extremely rigorous process."
                        }
                    ]
                }
            },
            {
                "id": "lesson-33",
                "title": "ECC in Secure Multi-Party Computation",
                "duration": "90 min",
                "objectives": [
                    "Implement a secret sharing scheme using elliptic curves.",
                    "Analyze and build multi-party ECDSA protocols.",
                    "Explore the applications of threshold cryptography.",
                    "Design secure two-party computation protocols.",
                    "Use ECC to build a private set intersection protocol."
                ],
                "content": {
                    "overview": "This lesson explores the fascinating field of Secure Multi-Party Computation (MPC), where a group of mutually distrustful parties can jointly compute a function on their private inputs, without revealing those inputs to each other. We will learn how elliptic curve cryptography provides the essential building blocks for these advanced privacy-preserving protocols.",
                "sections": [
                    {
                        "title": "Secret Sharing",
                        "content": "<p>Shamir's Secret Sharing is a classic MPC protocol. It allows you to split a secret (like an ECC private key) into `n` 'shares'. Any `t` (the threshold) of those shares can be combined to reconstruct the original secret, but `t-1` shares reveal absolutely nothing about it.</p><p>This can be implemented using elliptic curves by having the secret be the y-intercept of a random polynomial, and the shares be points on that polynomial.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Threshold Cryptography",
                            "content": "<p>Threshold cryptography allows a group to perform a cryptographic operation (like signing a message) in a distributed way. The private key is split into shares among the group. To sign a message, at least `t` members of the group must each use their share to create a 'partial signature'. These partial signatures can then be combined to create a single, valid ECDSA or BLS signature. Crucially, the full private key is never reconstructed on any single machine at any point.</p><p><strong>Real-world Example:</strong> A cryptocurrency exchange needs to secure its main 'cold wallet', which holds billions of dollars. They use a 3-of-5 threshold signature scheme. The private key is split into 5 shares, held by 5 different senior executives. To move any funds, at least 3 of those executives must come together and use their shares to jointly sign the transaction. A single compromised executive cannot steal the funds.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Private Set Intersection (PSI)",
                            "content": "<p>PSI is a specific MPC protocol that allows two parties to find the intersection of their private sets, without revealing any information about the items that are not in the intersection.</p><p><strong>Real-world Example:</strong> A government intelligence agency has a list of suspected phone numbers, and a telephone company has its full list of customer phone numbers. They want to find out which of the suspect numbers are customers of the phone company. Using a PSI protocol based on ECC, the two parties can interact and discover only the numbers that are in both lists. The agency learns nothing about the phone company's other customers, and the phone company learns nothing about the agency's other suspect numbers.</p>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Shamir Secret Sharing on Curves (Conceptual)",
                            "language": "python",
                            "code": "# This is a conceptual script for Shamir's Secret Sharing using ECC.\n\n# The secret is a private key, 'd'. We want to create 5 shares where 3 are needed.\n# This means we need a polynomial of degree t-1 = 2.\n# P(x) = d + a1*x + a2*x^2\n\n# 1. The dealer generates the secret 'd' and two random coefficients 'a1' and 'a2'.\nd = generate_private_key()\na1 = generate_private_key()\na2 = generate_private_key()\n\n# 2. The dealer creates the 5 shares by evaluating the polynomial at points x=1, x=2, ...\n# A 'share' is a point (x, P(x)).\nshare1 = (1, d + a1*1 + a2*1**2)\nshare2 = (2, d + a1*2 + a2*2**2)\nshare3 = (3, d + a1*3 + a2*3**2)\nshare4 = (4, d + a1*4 + a2*4**2)\nshare5 = (5, d + a1*5 + a2*5**2)\n\n# --- Reconstruction ---\n# Any 3 participants can combine their shares (their points).\n# They now have 3 points on a degree-2 polynomial. Using a mathematical technique\n# called Lagrange Interpolation, they can find the polynomial that passes through\n# all three points.\n# The y-intercept (the value of the polynomial at x=0) of this reconstructed\n# polynomial will be the original secret 'd'."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "A protocol that allows a secret to be split into `n` shares, where any `t` of those shares can reconstruct the secret, is known as:",
                            "options": [
                                "A digital signature",
                                "A secret sharing scheme",
                                "A key exchange",
                                "An encryption algorithm"
                            ],
                            "correct": 1,
                            "explanation": "Secret sharing is a fundamental building block of MPC. Shamir's Secret Sharing is the most famous example, and it can be adapted to work with elliptic curve private keys."
                        },
                        {
                            "id": 2,
                            "question": "What is the primary security guarantee of a threshold signature scheme?",
                            "options": [
                                "It makes the signature smaller.",
                                "The full private key is never reconstructed on any single machine; a quorum of participants must cooperate to create the signature.",
                                "It makes the signature faster to verify.",
                                "It hides the content of the message."
                            ],
                            "correct": 1,
                            "explanation": "This is the key security feature. It distributes the power of the private key, so that no single person or single compromised machine can create a signature. This is a powerful defense against theft."
                        },
                        {
                            "id": 3,
                            "question": "A protocol that allows two parties to find the common items in their private lists without revealing anything else is known as:",
                            "options": [
                                "Private Set Intersection (PSI)",
                                "Secret Sharing",
                                "Threshold Cryptography",
                                "A digital signature"
                            ],
                            "correct": 0,
                            "explanation": "PSI is a specialized MPC protocol with many real-world applications, from ad networks to law enforcement, where two parties need to compare sensitive data without revealing the data itself."
                        }
                    ]
                }
            },
            {
                "id": "lesson-34",
                "title": "Advanced Curve Constructions",
                "duration": "90 min",
                "objectives": [
                    "Understand the process of constructing pairing-friendly curves.",
                    "Analyze the properties of MNT, BN, and KSS curves.",
                    "Explain the concept of the embedding degree and its importance.",
                    "Optimize the embedding degree for security and performance.",
                    "Apply these constructions to advanced pairing-based protocols."
                ],
                "content": {
                    "overview": "Not all elliptic curves support efficient pairings. This lesson delves into the advanced mathematics of constructing 'pairing-friendly' curves. We will explore the special families of curves, like BN and KSS curves, that are used in modern pairing-based cryptography, and understand the critical role of the embedding degree in balancing their security and performance.",
                "sections": [
                    {
                        "title": "Pairing-Friendly Curve Construction",
                        "content": "<p>A cryptographic pairing requires a special type of elliptic curve called a 'pairing-friendly' curve. The vast majority of elliptic curves (like the standard NIST curves) are *not* pairing-friendly. Constructing these special curves is a complex area of number theory.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "BN, MNT, and KSS Curves",
                            "content": "<p>These are the names of specific families of pairing-friendly curves that are widely used in practice.</p><ul><li><strong>BN (Barreto-Naehrig) curves:</strong> A very popular family of curves that are used in many modern pairing-based systems, including the Zcash cryptocurrency.</li><li><strong>MNT (Miyaji-Nakabayashi-Takano) curves:</strong> An earlier family of curves.</li><li><strong>KSS (Kachisa-Schaefer-Scott) curves:</strong> Another family with specific properties.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "The Embedding Degree",
                            "content": "<p>The **embedding degree** (usually denoted `k`) is the most important parameter for a pairing-friendly curve. It determines the security and performance of the pairing.</p><p>A small embedding degree makes the pairing very fast, but it also makes the discrete logarithm problem in the *target group* of the pairing easy to solve. To be secure, the target group must be large enough to resist all known attacks. This means `k` must be large enough. A typical value for `k` in modern pairing-based systems is 12. The construction of a curve with a specific, desired embedding degree is the primary goal of pairing-friendly curve generation.</p>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "BN Curve Implementation (Conceptual)",
                            "language": "python",
                            "code": "# This is a conceptual script showing the generation of a BN curve.\n# BN curves are constructed to have a specific, small embedding degree (k=12).\n\n# 1. Choose a value 'x' that is small and has a low Hamming weight for performance.\n# 2. Find a prime number 't' that is close to a power of 2.\n\n# 3. Find the curve order 'n' and the prime 'p' that defines the field using polynomial formulas based on 't'.\n#    n(t) = t^4 + t^3 + t^2 + t + 1\n#    p(t) = (t-1)^2 * (t^4 + t^3 + t^2 + t + 1) / 3 + t\n\n# 4. Find a value 'b' such that the curve y^2 = x^3 + b over GF(p) has the correct order 'n'.\n\n# 5. The result is a 'BN curve' that is suitable for pairings with an embedding degree of 12.\n#    This process of finding the right parameters is a complex number theory problem."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "Are the standard NIST curves (like P-256) suitable for pairing-based cryptography?",
                            "options": [
                                "Yes, they are the best choice.",
                                "No, they are not 'pairing-friendly' and have a very large embedding degree.",
                                "They are only suitable for pairings on weekends.",
                                "They are pairing-friendly, but too slow."
                            ],
                            "correct": 1,
                            "explanation": "Standard curves are intentionally chosen to *not* be pairing-friendly. This is because a pairing can be used to transfer the ECDLP on the curve to a DLP in a finite field, which can be easier to solve if the embedding degree is too small. Pairing-based crypto requires special, purpose-built curves."
                        },
                        {
                            "id": 2,
                            "question": "BN (Barreto-Naehrig) curves are a famous family of what kind of elliptic curve?",
                            "options": [
                                "Standard curves for ECDSA.",
                                "Pairing-friendly curves.",
                                "Curves used for factorization.",
                                "Curves that are not secure."
                            ],
                            "correct": 1,
                            "explanation": "BN curves are one of the most popular and efficient families of pairing-friendly curves, and they are the foundation for the cryptography used in many modern systems like Zcash."
                        },
                        {
                            "id": 3,
                            "question": "What is the most important parameter for a pairing-friendly curve that determines its security and performance?",
                            "options": [
                                "The coefficient `a`",
                                "The coefficient `b`",
                                "The embedding degree `k`",
                                "The base point `G`"
                            ],
                            "correct": 2,
                            "explanation": "The embedding degree is the critical parameter. It must be large enough to ensure that the DLP in the target group of the pairing is hard, but small enough to make the pairing computation efficient. This trade-off is the central challenge of pairing-friendly curve construction."
                        }
                    ]
                }
            },
            {
                "id": "lesson-35",
                "title": "ECC Cryptanalysis Tools and Techniques",
                "duration": "90 min",
                "objectives": [
                    "Develop and use automated frameworks for cryptanalysis.",
                    "Apply statistical and differential analysis to find weaknesses.",
                    "Adapt linear cryptanalysis techniques for ECC.",
                    "Use machine learning for cryptanalytic attacks.",
                    "Perform automated vulnerability discovery on ECC implementations."
                ],
                "content": {
                    "overview": "This lesson focuses on the practical tools and techniques used to analyze and attack elliptic curve cryptosystems. We will explore how to build automated frameworks for testing, how to apply advanced statistical methods to find non-randomness, and how machine learning is being used to find new and unexpected vulnerabilities.",
                "sections": [
                    {
                        "title": "Automated Cryptanalysis Frameworks",
                        "content": "<p>A modern cryptanalysis lab uses automated frameworks to test an implementation against a huge battery of known attacks. This includes tests for:</p><ul><li>Small subgroup attacks.</li><li>Invalid curve attacks.</li><li>Timing side-channel leaks.</li><li>And many other common implementation bugs.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Statistical and Differential Analysis",
                            "content": "<p>These are advanced techniques for analyzing the outputs of a cryptographic primitive.</p><ul><li><strong>Statistical Analysis:</strong> A cryptographically secure algorithm should produce output that is statistically indistinguishable from random. An analyst can use a suite of statistical tests (like the NIST STS) to test the output of a random number generator or a key stream to look for any non-random patterns that could indicate a weakness.</li><li><strong>Differential Analysis:</strong> This technique looks at how a small change in the input to a function affects the output. In a secure algorithm, a tiny change in the input should cause a massive, unpredictable avalanche of change in the output. If it doesn't, this can be exploited to recover the key.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Machine Learning in Cryptanalysis",
                            "content": "<p>Machine learning is becoming a powerful new tool for cryptanalysis.</p><p><strong>Real-world Example:</strong> A researcher can train a neural network to perform a side-channel attack. They can feed the model thousands of power consumption traces from a smart card, where the input and the key are known. The model can learn the subtle, complex relationship between the power trace and the secret key. The trained model can then be given a power trace for a new, unknown key, and it can often recover the secret key with a much higher success rate than traditional statistical methods.</p>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "ML-Based Attack Implementation (Conceptual)",
                            "language": "python",
                            "code": "# This is a conceptual Python script for a simple ML-based side-channel attack.\n# It uses a neural network to predict a bit of the key from a power trace.\n\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, Conv1D, Flatten\n\n# 1. Collect training data: thousands of (power_trace, key_bit) pairs.\n#    power_traces_train, key_bits_train = collect_training_data()\n\n# 2. Build a neural network model (e.g., a 1D Convolutional Neural Network).\nmodel = Sequential([\n    Conv1D(filters=32, kernel_size=3, activation='relu', input_shape=(trace_length, 1)),\n    Flatten(),\n    Dense(1, activation='sigmoid') # Output is a single bit (0 or 1)\n])\n\nmodel.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])\n\n# 3. Train the model on the collected data.\nmodel.fit(power_traces_train, key_bits_train, epochs=10)\n\n# 4. Use the trained model to predict the key bit from a new, unknown power trace.\n# unknown_trace = get_unknown_trace()\n# predicted_bit = model.predict(unknown_trace)"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "A suite of tests that checks the output of a random number generator for non-random patterns is known as a:",
                            "options": [
                                "Penetration test",
                                "Statistical testing suite",
                                "Model checker",
                                "Fuzzer"
                            ],
                            "correct": 1,
                            "explanation": "Statistical tests are used to find any discernible pattern or bias in data that should be random. Finding such a pattern in the output of a cryptographic algorithm is a major vulnerability."
                        },
                        {
                            "id": 2,
                            "question": "The cryptanalytic technique that examines how a small change in an algorithm's input affects its output is known as:",
                            "options": [
                                "Linear cryptanalysis",
                                "Differential cryptanalysis",
                                "Algebraic cryptanalysis",
                                "Statistical cryptanalysis"
                            ],
                            "correct": 1,
                            "explanation": "Differential cryptanalysis is a very powerful technique. A secure cryptographic primitive should have a strong 'avalanche effect', where a one-bit change in the input causes approximately half the bits of the output to change."
                        },
                        {
                            "id": 3,
                            "question": "How is machine learning being applied to side-channel analysis?",
                            "options": [
                                "It cannot be applied.",
                                "A neural network can be trained to find the complex, subtle correlations between a physical side channel (like a power trace) and a secret key, often outperforming traditional methods.",
                                "By making the side channel noisier.",
                                "By speeding up the encryption."
                            ],
                            "correct": 1,
                            "explanation": "Deep learning models are extremely good at finding patterns in noisy, high-dimensional data, which makes them a perfect tool for advanced side-channel analysis where the signal is very weak."
                        }
                    ]
                }
            },
            {
                "id": "lesson-36",
                "title": "ECC in Cloud and Distributed Systems",
                "duration": "90 min",
                "objectives": [
                    "Design and implement a cloud-based ECC service.",
                    "Understand and implement a distributed key generation (DKG) protocol.",
                    "Analyze protocols for secure multi-party key management.",
                    "Explore the potential of homomorphic encryption with ECC.",
                    "Design and analyze distributed signature schemes."
                ],
                "content": {
                    "overview": "This lesson explores the application of elliptic curve cryptography in modern, large-scale distributed and cloud environments. We will cover the challenges of managing keys when there is no single trusted machine, and explore advanced protocols like distributed key generation and homomorphic encryption that are designed for this new paradigm.",
                "sections": [
                    {
                        "title": "Cloud-Based ECC Services",
                        "content": "<p>Major cloud providers (AWS, Azure, GCP) offer **Key Management Services (KMS)**. These services provide a cloud-native way to manage cryptographic keys. The keys are often protected by a fleet of Hardware Security Modules (HSMs) managed by the cloud provider.</p><p>A user can ask the KMS to generate an ECC key pair and then use the API to perform signing or decryption operations, without ever having access to the private key itself. This is a powerful way to use strong cryptography without the burden of managing the underlying hardware.</p>",
                            "image": "https://images.unsplash.com/photo-1588196749597-9ff075ee6b5b?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Distributed Key Generation (DKG)",
                            "content": "<p>A DKG protocol is a type of secure multi-party computation that allows a group of `n` parties to jointly create a shared public key and a set of private key *shares*, without any single party ever knowing the full master private key. This is the protocol that is used to set up a threshold signature scheme (from Lesson 33).</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Homomorphic Encryption",
                            "content": "<p>Homomorphic encryption is a revolutionary type of encryption that allows you to perform computations directly on encrypted data, without ever decrypting it.</p><p><strong>Real-world Example:</strong> A user encrypts their financial data and sends it to an untrusted cloud service. The user can then ask the cloud service to compute the *average* of their encrypted financial data. The cloud service can perform this computation on the ciphertext and send back an encrypted result. The user, with their private key, can decrypt the result and get the correct average. The cloud server learned nothing about the underlying financial data. While still very computationally expensive, some schemes for homomorphic encryption are built using the mathematics of elliptic curves.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Cloud ECC Service Implementation (AWS KMS)",
                            "language": "python",
                            "code": "import boto3\n\n# This conceptual script uses the AWS SDK (Boto3) to perform a signature\n# operation using a key stored in the AWS Key Management Service (KMS).\n\n# 1. Create a client for the KMS service.\nkms_client = boto3.client('kms', region_name='us-east-1')\n\n# 2. The ID of the asymmetric ECC key stored in KMS.\n# The private key never leaves the AWS HSMs.\nkey_id = 'alias/MyECCSigningKey'\n\n# 3. The message to be signed (must be hashed first).\nmessage_hash = b'...' # The SHA-256 hash of the message\n\n# 4. Call the KMS API to sign the hash.\n# The actual signing operation happens inside the AWS HSMs.\nresponse = kms_client.sign(\n    KeyId=key_id,\n    Message=message_hash,\n    MessageType='DIGEST',\n    SigningAlgorithm='ECDSA_SHA_256'\n)\n\n# 5. The API returns the signature.\nsignature = response['Signature']\n\nprint(f\"Signature: {signature.hex()}\")\n\n# The private key was used without ever being exposed to the user or the application."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "A cloud service like AWS KMS allows a user to perform cryptographic operations without ever having direct access to what?",
                            "options": [
                                "The public key",
                                "The private key",
                                "The signature",
                                "The ciphertext"
                            ],
                            "correct": 1,
                            "explanation": "This is the key security benefit of a KMS. The private key is generated and stored inside the service's HSMs and can never be exported. This prevents key theft."
                        },
                        {
                            "id": 2,
                            "question": "A protocol that allows a group of parties to jointly create a shared private key that is split into shares, without any single party ever knowing the full key, is known as a:",
                            "options": [
                                "A digital signature",
                                "A secret sharing scheme",
                                "A Distributed Key Generation (DKG) protocol",
                                "A key exchange"
                            ],
                            "correct": 2,
                            "explanation": "DKG is the protocol used to initialize a threshold cryptography scheme. It creates the shared key in a decentralized way, so there is no single point of trust or failure."
                        },
                        {
                            "id": 3,
                            "question": "The type of encryption that allows for computations to be performed directly on encrypted data is known as:",
                            "options": [
                                "Symmetric Encryption",
                                "Asymmetric Encryption",
                                "Homomorphic Encryption",
                                "Identity-Based Encryption"
                            ],
                            "correct": 2,
                            "explanation": "Homomorphic encryption is a powerful, emerging technology that allows for secure outsourcing of computation. Many modern schemes are built using the mathematics of lattices or elliptic curves."
                        }
                    ]
                }
            },
            {
                "id": "lesson-37",
                "title": "Elliptic Curve Backdoors and Weaknesses",
                "duration": "90 min",
                "objectives": [
                    "Perform a detailed analysis of the Dual_EC_DRBG controversy.",
                    "Understand how suspicious curve parameter selection can create a backdoor.",
                    "Discuss the concept of NOBUS (Nobody But Us) backdoors.",
                    "Apply rigidity and other verification techniques to detect suspicious curves.",
                    "Analyze the potential for backdoors in cryptographic standards."
                ],
                "content": {
                    "overview": "This lesson explores the dark side of cryptography: the potential for hidden backdoors to be intentionally placed in cryptographic standards and implementations. We will perform a deep dive into the most famous example, the Dual_EC_DRBG random number generator, and learn the techniques that researchers use to detect these subtle but devastating weaknesses.",
                "sections": [
                    {
                        "title": "The Dual_EC_DRBG Controversy",
                        "content": "<p>Dual_EC_DRBG was a random number generator standardized by NIST that used elliptic curves. It was later discovered, and confirmed by the Snowden revelations, that this standard contained a probable **kleptographic backdoor** inserted by the NSA.</p><p>The standard specified two points on an elliptic curve, `P` and `Q`. It turned out that these two points were not randomly generated. There was a secret relationship between them: `P = dQ` for a secret integer `d`. An attacker who knew the secret `d` could, by observing just 32 bytes of the random number generator's output, predict all future outputs of the generator. This would allow them to recover the private key of any TLS session that relied on this random number generator.</p>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "NOBUS Backdoors and Rigidity",
                            "content": "<p>A NOBUS (Nobody But Us) backdoor is a backdoor that can only be exploited by the entity that created it. The Dual_EC_DRBG backdoor was a NOBUS backdoor: only the NSA, who knew the secret `d`, could exploit it.</p><p>The defense against this is **rigidity**. When a standard specifies a cryptographic constant (like a base point `G`), it should be generated in a completely transparent and deterministic way. For example, by taking a common string (like 'The NIST P-256 curve') and hashing it until the output is the x-coordinate of a valid point on the curve. This 'nothing up my sleeve' number generation process proves that the constant was not chosen with a hidden, malicious property.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Backdoor Detection Techniques",
                        "content": "<p>The discovery of the Dual_EC_DRBG backdoor has led to a much greater degree of skepticism and analysis of cryptographic standards. Researchers now use sophisticated mathematical techniques to test standard curves and constants for any suspicious, non-random properties that could indicate a hidden weakness or backdoor.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Curve Rigidity Verification (Conceptual)",
                            "language": "python",
                            "code": "import hashlib\n\n# This conceptual script demonstrates the 'nothing up my sleeve' number generation process.\n\n# The seed is a publicly known, arbitrary string.\nseed_string = b\"The secp256k1 base point generation seed\"\n\n# We will hash the seed repeatedly until we find a valid point.\ni = 0\nwhile True:\n    # Hash the seed with a counter to get a candidate for the x-coordinate.\n    candidate_x_bytes = hashlib.sha256(seed_string + bytes([i])).digest()\n    candidate_x = int.from_bytes(candidate_x_bytes, 'big')\n\n    # Check if this x-coordinate corresponds to a valid point on the curve.\n    # y^2 = x^3 + 7 (mod p)\n    # This requires checking if (x^3 + 7) is a quadratic residue mod p.\n    if is_point_on_curve(candidate_x):\n        print(f\"Found a valid base point G after {i+1} iterations.\")\n        G = derive_point_from_x(candidate_x)\n        break\n    \n    i += 1\n\n# Because this process is deterministic and the seed is public, anyone can repeat it\n# and verify that the base point G was generated honestly and not chosen with a\n# hidden malicious property."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "The Dual_EC_DRBG standard was found to contain what?",
                            "options": [
                                "A buffer overflow vulnerability.",
                                "A probable kleptographic backdoor that would allow an attacker who knew a secret value to predict its output.",
                                "A denial-of-service vulnerability.",
                                "A hardware trojan."
                            ],
                            "correct": 1,
                            "explanation": "The Dual_EC_DRBG controversy is the most famous example of a suspected, intentionally backdoored cryptographic standard. The suspicious relationship between the public points P and Q is what created the backdoor."
                        },
                        {
                            "id": 2,
                            "question": "A backdoor that can only be exploited by the entity that created it is known as a:",
                            "options": [
                                "A zero-day",
                                "A NOBUS (Nobody But Us) backdoor",
                                "A side channel",
                                "A hardware implant"
                            ],
                            "correct": 1,
                            "explanation": "A NOBUS backdoor is one where the exploitability depends on a secret that only the creator of the backdoor knows (like the secret `d` in the Dual_EC_DRBG case)."
                        },
                        {
                            "id": 3,
                            "question": "The primary defense against backdoored cryptographic constants (like a base point G) is:",
                            "options": [
                                "To use a very large prime number.",
                                "To use a rigid, deterministic, and publicly verifiable generation process to prove that the constant was not chosen with a hidden malicious property.",
                                "To encrypt the constant.",
                                "To store the constant in an HSM."
                            ],
                            "correct": 1,
                            "explanation": "Rigidity and transparency are the key. By using a 'nothing up my sleeve' number generation process, the designers of a standard can prove to the public that the constants were generated fairly and are not backdoored."
                        }
                    ]
                }
            },
            {
                "id": "lesson-38",
                "title": "ECC in Quantum Key Distribution",
                "duration": "90 min",
                "objectives": [
                    "Understand the basic principles of Quantum Key Distribution (QKD).",
                    "Explain the need for post-measurement authentication in a QKD protocol.",
                    "Design a quantum-classical hybrid protocol that uses ECC for authentication.",
                    "Analyze the role of ECC in securing quantum networks.",
                    "Explore the concept of quantum digital signatures."
                ],
                "content": {
                    "overview": "This lesson explores the fascinating intersection of elliptic curve cryptography and the world of quantum communication. We will learn how classical ECC is a critical and necessary component for securing Quantum Key Distribution (QKD) protocols, providing the authentication that the quantum channel itself cannot.",
                "sections": [
                    {
                        "title": "Quantum Key Distribution (QKD) Basics",
                        "content": "<p>QKD is a protocol that uses the principles of quantum mechanics to allow two parties to agree on a secret key. Its security is based on the laws of physics, not on a hard mathematical problem.</p><h3>The BB84 Protocol:</h3><p>The most famous QKD protocol. Alice sends a stream of single photons to Bob. She randomly encodes each photon's bit value in one of two different bases (e.g., rectilinear or diagonal). Bob randomly measures each photon in one of the two bases. After the transmission, they communicate over a public channel to reveal which basis they used for each photon. They keep only the bits where they used the same basis. The resulting sequence of bits is their shared secret key.</p><p>The security comes from the fact that if an eavesdropper, Eve, tries to measure a photon in transit, the act of measurement will disturb its quantum state. This will introduce errors into the final key, and Alice and Bob can detect Eve's presence by testing a small sample of their key bits.</p>",
                            "image": "https://images.unsplash.com/photo-1635070049035-5a79a8385075?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "The Need for Post-Measurement Authentication",
                            "content": "<p>QKD is secure against a passive eavesdropper. However, it is completely vulnerable to an active Man-in-the-Middle (MITM) attack.</p><p>An attacker can intercept Alice's photons, perform their own QKD exchange with Alice, and then impersonate Alice and perform a separate QKD exchange with Bob. Alice and Bob will both think they have a secure key, but they have actually established keys with the attacker in the middle.</p><p>To defeat this, the public communication channel used *after* the quantum transmission must be **authenticated**. This is where ECC comes in.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Quantum-Classical Hybrid Protocols",
                            "content": "<p>A secure, real-world QKD system is a hybrid system.</p><p><strong>Real-world Example:</strong> Alice and Bob first perform the BB84 protocol over the quantum channel. They now have a shared, secret string of bits. However, they cannot trust it yet. To authenticate their public discussion, Alice signs her messages to Bob with her long-term ECC-based digital signature (e.g., ECDSA or Ed25519), and Bob does the same. Because they can trust the authenticity of these public messages, they can be sure they are talking to each other and not to a man-in-the-middle. They can then securely confirm that their shared key is correct and has not been tampered with. The classical, authenticated channel is what provides the security against an active attacker.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "QKD Authentication Protocol (Conceptual)",
                            "language": "python",
                            "code": "# This conceptual script shows the classical authentication part of a QKD protocol.\n\n# --- Quantum Phase ---\n# Alice and Bob perform BB84 and now each have a raw, potentially tampered key.\nraw_key_alice = \"0110...\"\nraw_key_bob = \"0100...\"\n\n# --- Classical Authentication Phase ---\n\n# 1. Alice takes a small sample of her key and her basis choices, and signs them\n#    with her long-term ECDSA private key.\nmessage_to_sign = hash(raw_key_alice_sample + basis_choices_alice)\nsignature_alice = ecdsa_sign(alice_private_key, message_to_sign)\n# Alice sends (raw_key_alice_sample, basis_choices_alice, signature_alice) to Bob.\n\n# 2. Bob receives the message. He first verifies Alice's signature with her trusted public key.\n#    If the signature is valid, he knows the message is authentic.\n\n# 3. Bob can now compare his key sample and basis choices to the authentic ones from Alice.\n#    If they match, he knows there was no man-in-the-middle. If they don't match, he knows\n#    an attacker was present, and they discard the key.\n\n# 4. They repeat the process with Bob signing a message to Alice.\n\n# Only after this classical, ECC-based authentication is complete can they trust\n# that their quantum-derived key is secure."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "The security of a Quantum Key Distribution (QKD) protocol is based on what?",
                            "options": [
                                "The hardness of the discrete logarithm problem.",
                                "The laws of physics (specifically, the fact that measuring a quantum state disturbs it).",
                                "The secrecy of the algorithm.",
                                "A one-way hash function."
                            ],
                            "correct": 1,
                            "explanation": "QKD's security is derived from quantum mechanics. The 'no-cloning theorem' and the observer effect are the physical principles that allow for the detection of an eavesdropper."
                        },
                        {
                            "id": 2,
                            "question": "A standard QKD protocol like BB84 is inherently vulnerable to what kind of attack?",
                            "options": [
                                "A passive eavesdropping attack.",
                                "An active Man-in-the-Middle (MITM) attack.",
                                "A brute-force attack.",
                                "It is not vulnerable to any attacks."
                            ],
                            "correct": 1,
                            "explanation": "QKD by itself provides no authentication. An active attacker can intercept the quantum channel and impersonate each party to the other, establishing their own separate keys with each. This is why an authenticated classical channel is required."
                        },
                        {
                            "id": 3,
                            "question": "In a secure, hybrid QKD system, what is the role of classical cryptography like ECC?",
                            "options": [
                                "It is not needed.",
                                "It is used to encrypt the photons.",
                                "It is used to provide authentication for the public discussion channel, to defeat a Man-in-the-Middle attack.",
                                "It is used to make the quantum communication faster."
                            ],
                            "correct": 2,
                            "explanation": "ECC-based digital signatures are the critical component that provides the authentication that QKD lacks. The security of the final system relies on both the quantum properties of the QKD protocol and the mathematical hardness of the classical ECC signature scheme."
                        }
                    ]
                }
            },
            {
                "id": "lesson-39",
                "title": "Advanced Mathematical Attacks",
                "duration": "90 min",
                "objectives": [
                    "Understand the theoretical basis for index calculus attacks.",
                    "Analyze the GHS (Gaudry-Hess-Smart) attack.",
                    "Explore the concept of Weil descent attacks.",
                    "Discuss the application of summation polynomial methods.",
                    "Evaluate the complexity and practical relevance of these advanced attacks."
                ],
                "content": {
                    "overview": "This lesson covers the most advanced and mathematically complex attacks that have been devised against the Elliptic Curve Discrete Logarithm Problem. While these attacks are generally not a threat to the standard curves used in practice, understanding them is crucial for researchers who are designing new curves or analyzing their security at the deepest level.",
                "sections": [
                    {
                        "title": "Index Calculus and its Limitations for ECC",
                        "content": "<p>The index calculus method is the most powerful algorithm for solving the discrete logarithm problem in a prime finite field `GF(p)`. It is the reason that standard Diffie-Hellman requires such large keys. However, a straightforward adaptation of this method **does not work** for elliptic curves. The lack of a clear concept of 'smoothness' for elliptic curve points prevents the main step of the algorithm from working. This is the fundamental reason for ECC's efficiency.",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Weil Descent and GHS Attacks",
                            "content": "<p>These are advanced attacks that try to solve the ECDLP on certain types of curves by transferring the problem to a different, potentially weaker mathematical setting.</p><ul><li><strong>Weil Descent:</strong> An attack that can take the ECDLP on a curve over a binary field `GF(2^m)` and reduce it to the discrete logarithm problem in a different group, the Jacobian of a hyperelliptic curve over a smaller field.</li><li><strong>GHS Attack:</strong> A refinement of the Weil descent attack.</li></ul><p>These attacks are only effective against a very specific class of curves (curves with a composite extension degree). Standard curves are specifically chosen to be resistant to these attacks.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Summation Polynomial Method",
                        "content": "<p>This is a type of algebraic attack that is related to the Gröbner basis methods. It involves solving a very large system of equations derived from the curve. Like other algebraic attacks, it is not a practical threat to the curves used in real-world cryptography due to its massive computational complexity.</p>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "GHS Attack Demonstration (Conceptual)",
                            "language": "python",
                            "code": "# This is a highly conceptual script showing the logical flow of a GHS attack.\n\n# 1. Start with an ECDLP instance on a vulnerable curve over GF(2^m).\n#    The curve must be specifically chosen to be weak against this attack.\n#    Find d such that Q = dG on E(GF(2^m)).\n\n# 2. Use Weil descent to reduce the problem to a Hyperelliptic Curve DLP (HCDLP)\n#    on the Jacobian of a new curve J over a smaller field GF(2^k).\n#    D1, D2 = weil_descent(G, Q)\n\n# 3. Solve the HCDLP in the Jacobian: find d such that D2 = d*D1.\n#    This is still a hard problem, but because it's on a smaller field,\n#    it can be faster than attacking the original ECDLP.\n#    d = solve_hcdlp(D1, D2, J)\n\n# 4. The 'd' found in the Jacobian is the same 'd' from the original problem.\n#    The attack has succeeded.\n\n# NOTE: Standard curves from NIST, Brainpool, etc., are specifically chosen\n# to ensure that this attack is not possible or is no better than generic attacks."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "Why is the index calculus method, which is very effective against prime field discrete logs, not a practical threat to ECC?",
                            "options": [
                                "Because ECC uses larger numbers.",
                                "Because a straightforward adaptation of the method does not work due to the lack of a clear notion of 'smoothness' for elliptic curve points.",
                                "Because ECC is too new.",
                                "Because ECC uses binary fields."
                            ],
                            "correct": 1,
                            "explanation": "This is the core reason for ECC's strength and efficiency. The failure of index calculus to apply to the ECDLP means that the best known attacks are still the fully exponential generic ones, allowing for smaller, more efficient key sizes."
                        },
                        {
                            "id": 2,
                            "question": "The Weil descent and GHS attacks are primarily effective against which type of elliptic curve?",
                            "options": [
                                "All elliptic curves.",
                                "Curves over a prime field.",
                                "A specific, weak class of curves over a binary field with a composite extension degree.",
                                "Curves used in Bitcoin."
                            ],
                            "correct": 2,
                            "explanation": "These are highly specialized attacks that only work on certain types of curves. All standardized curves are specifically chosen to be resistant to these and other known advanced attacks."
                        },
                        {
                            "id": 3,
                            "question": "What is the practical relevance of these advanced mathematical attacks for most cryptographic practitioners?",
                            "options": [
                                "They are a daily threat that must be defended against.",
                                "They are primarily of theoretical interest and are the reason that it is critical to only use standardized, well-vetted elliptic curves.",
                                "They are not relevant at all.",
                                "They make ECC completely insecure."
                            ],
                            "correct": 1,
                            "explanation": "For a practitioner, the key takeaway is not the details of the math, but the conclusion: the process of designing a secure curve is extremely difficult and requires deep expertise to avoid these and other advanced attacks. This is why you must always use a standard curve."
                        }
                    ]
                }
            },
            {
                "id": "lesson-40",
                "title": "ECC Research Frontiers",
                "duration": "90 min",
                "objectives": [
                    "Explore emerging and novel curve constructions.",
                    "Discuss the latest attack methodologies and their implications.",
                    "Analyze the ongoing transition from classical to quantum-classical hybrid systems.",
                    "Follow the current post-quantum standardization efforts.",
                    "Develop a roadmap for future research directions in ECC."
                ],
                "content": {
                    "overview": "This final lesson looks to the future of elliptic curve cryptography. We will explore the active areas of research, from the development of new curve models and the discovery of new attacks to the critical, ongoing transition to a post-quantum world. We will conclude by discussing the open problems and exciting frontiers that will define the next decade of ECC research.",
                "sections": [
                    {
                        "title": "Emerging Curve Constructions",
                        "content": "<p>Research continues into new forms of elliptic curves that offer even better performance or stronger security properties. This includes work on curves that are even more resistant to side-channel attacks or that are particularly well-suited for new protocols like zero-knowledge proofs.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "The Post-Quantum Transition",
                            "content": "<p>The single biggest challenge and research area is the transition to post-quantum cryptography. The NIST PQC standardization process is ongoing, and the world is preparing for a multi-year, or even multi-decade, transition to replace all of our current public-key infrastructure.</p><h3>Hybrid Systems:</h3><p>In the near term, the recommended approach is to use a **hybrid system**. For example, a TLS key exchange would perform *both* a classical ECDH key exchange and a post-quantum key exchange. The two resulting shared secrets are then combined. This approach is secure as long as *at least one* of the two algorithms remains secure. It provides a way to transition to the new algorithms while still having the security of the well-understood classical ones.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Future Research Directions",
                            "content": "<p>Elliptic curve cryptography is a mature but still vibrant field of research. The future will involve:</p><ul><li>Finding more efficient and secure implementations.</li><li>Developing new, advanced protocols for privacy and multi-party computation.</li><li>Continuing the deep analysis of the mathematical foundations to ensure their long-term security.</li><li>Navigating the complex transition to a post-quantum world.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Future-Technology Research Framework (Hybrid Key Exchange)",
                            "language": "python",
                            "code": "# This conceptual script shows the logic of a hybrid key exchange.\n\n# --- Key Generation ---\n# The parties have both a classical and a post-quantum key pair.\necdh_private, ecdh_public = generate_ecdh_keys()\npqc_private, pqc_public = generate_pqc_kem_keys() # e.g., Kyber\n\n# --- Key Exchange ---\n# They perform both key exchanges.\n# 1. Perform ECDH to get a classical shared secret.\necdh_shared_secret = perform_ecdh(ecdh_private, other_party_ecdh_public)\n\n# 2. Perform the PQC Key Encapsulation Mechanism (KEM).\n#    Alice generates a secret and encrypts it with Bob's public PQC key.\n#    Bob decrypts it with his private PQC key.\npqc_shared_secret = perform_pqc_kem(pqc_private, other_party_pqc_public)\n\n# --- Key Derivation ---\n# 3. The final, hybrid shared secret is derived by combining the two secrets,\n#    typically by concatenating them and then hashing.\nfinal_shared_secret = hash(ecdh_shared_secret + pqc_shared_secret)\n\n# This final secret is secure as long as at least one of the two underlying\n# schemes (ECDH or the PQC KEM) is secure."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the primary motivation for the ongoing NIST Post-Quantum Cryptography (PQC) standardization process?",
                            "options": [
                                "To find a faster version of RSA.",
                                "To prepare for the eventual threat of a quantum computer by standardizing new public-key algorithms that are resistant to quantum attacks.",
                                "To get rid of ECC.",
                                "To make keys smaller."
                            ],
                            "correct": 1,
                            "explanation": "The NIST PQC project is the global, driving force behind the transition to quantum-safe cryptography. Its goal is to select and standardize a set of new algorithms that can replace our current, vulnerable public-key infrastructure."
                        },
                        {
                            "id": 2,
                            "question": "A 'hybrid' key exchange is a transitional strategy that involves what?",
                            "options": [
                                "Using both a symmetric and an asymmetric algorithm.",
                                "Using two different elliptic curves at the same time.",
                                "Performing both a classical key exchange (like ECDH) and a post-quantum key exchange, and combining their results.",
                                "Using a key that is half classical and half quantum."
                            ],
                            "correct": 2,
                            "explanation": "The hybrid approach is a 'belt and suspenders' strategy. It provides security against both classical attackers (thanks to the well-understood ECDH) and quantum attackers (thanks to the new PQC algorithm), making it a robust way to manage the transition."
                        },
                        {
                            "id": 3,
                            "question": "What happened to the Supersingular Isogeny Key Encapsulation (SIKE) protocol?",
                            "options": [
                                "It was chosen as the primary standard by NIST.",
                                "It was found to be too slow to be practical.",
                                "A major research breakthrough in 2022 led to a complete break of the protocol using a classical computer.",
                                "It is still considered secure."
                            ],
                            "correct": 2,
                            "explanation": "The break of SIKE was a major event in the cryptographic community. It demonstrated that while isogeny-based cryptography is promising, it is still a new field and our understanding of its security is still evolving."
                        }
                    ]
                }
            },
            {
                "id": "lesson-41",
                "title": "Industrial ECC Applications",
                "duration": "90 min",
                "objectives": [
                    "Analyze the use of ECC in automotive security (V2X).",
                    "Explore ECC applications in smart grid and smart meter cryptography.",
                    "Discuss the security of medical devices using ECC.",
                    "Investigate the use of ECC in aerospace and avionics.",
                    "Design secure authentication protocols for the Industrial IoT (IIoT)."
                ],
                "content": {
                    "overview": "This lesson explores the application of elliptic curve cryptography in a range of safety-critical and industrial environments. From securing the communication between cars to protecting the integrity of the power grid, we will see how ECC provides the essential security foundation for the next generation of connected industrial systems.",
                "sections": [
                    {
                        "title": "Automotive Security with ECC",
                        "content": "<p>Modern vehicles are becoming increasingly connected. Vehicle-to-Everything (V2X) communication allows cars to talk to other cars, to traffic infrastructure, and to the cloud. To prevent a malicious actor from sending fake messages (e.g., a fake 'ice on road' warning), all of these messages must be digitally signed.</p><p>ECC (specifically, ECDSA) is the standard for V2X communication. Its efficiency and small signature size are a perfect fit for the real-time, high-volume communication environment of an automotive network.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Smart Grid Cryptography",
                            "content": "<p>The 'smart grid' involves adding a digital communication layer to the electrical power grid. This allows for better monitoring and control, but also creates a new attack surface.</p><p>ECC is used to secure the communications of smart meters and other grid components. For example, a smart meter will use an ECC-based digital signature to authenticate its power usage readings to the utility company, preventing a malicious actor from spoofing the data to commit energy theft.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Medical and Industrial IoT",
                        "content": "<p>As we've seen, ECC is a natural fit for resource-constrained IoT devices.</p><ul><li><strong>Medical Devices:</strong> An implantable medical device (like a pacemaker) needs a way for a doctor to communicate with it securely. An ECC-based key exchange can be used to establish a secure, encrypted channel between the doctor's programmer and the device, preventing an unauthorized party from connecting to it and potentially causing harm.</li><li><strong>Industrial IoT (IIoT):</strong> In a factory, sensors and actuators on the assembly line can use ECC to authenticate themselves to the central control system, ensuring that a malicious device cannot be added to the network to disrupt the manufacturing process.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Vehicle-to-Everything (V2X) Security (Conceptual)",
                            "language": "python",
                            "code": "# This is a conceptual script for a V2X safety message.\n\nimport json\n\n# 1. The vehicle's onboard unit creates a safety message.\nmessage = {\n    \"message_type\": \"emergency_braking\",\n    \"vehicle_id\": \"did:v2x:12345\",\n    \"location\": {\"lat\": 34.0522, \"lon\": -118.2437},\n    \"timestamp\": \"2025-09-15T14:00:00Z\"\n}\n\n# 2. The message is serialized and hashed.\nmessage_bytes = json.dumps(message).encode('utf-8')\nmessage_hash = hash(message_bytes)\n\n# 3. The vehicle's HSM signs the hash with its ECDSA private key.\n#    The private key is provisioned at the time of manufacture.\n# signature = ecdsa_sign(vehicle_private_key, message_hash)\n\n# 4. The vehicle broadcasts the message and the signature.\n\n# --- Verification by another car ---\n\n# 1. A receiving car gets the message and the signature.\n\n# 2. It already has the trusted public key of the manufacturer (the CA).\n\n# 3. It first verifies the signature on the vehicle's certificate to ensure the\n#    vehicle is authentic.\n\n# 4. It then uses the vehicle's public key from the certificate to verify the\n#    signature on the safety message itself.\n\n# This ECC-based process ensures that cars can trust the safety-critical\n# messages they receive from other vehicles."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "In a Vehicle-to-Everything (V2X) communication system, what is the primary purpose of using ECDSA digital signatures?",
                            "options": [
                                "To encrypt the messages.",
                                "To make the cars go faster.",
                                "To ensure that safety-critical messages (like 'car ahead is braking') are authentic and have not been forged by a malicious actor.",
                                "To track the location of the car."
                            ],
                            "correct": 2,
                            "explanation": "Authentication is the key security service here. In a V2X system, you must be able to trust that a message is from a legitimate vehicle and has not been altered. ECDSA provides this guarantee."
                        },
                        {
                            "id": 2,
                            "question": "What is the main reason ECC is well-suited for securing Industrial IoT (IIoT) devices?",
                            "options": [
                                "The devices are not connected to a network.",
                                "The devices have unlimited power and CPU resources.",
                                "ECC's efficiency and small key sizes are a good match for the resource-constrained nature of industrial sensors and actuators.",
                                "The industrial environment is not a target for attackers."
                            ],
                            "correct": 2,
                            "explanation": "The efficiency of ECC makes it possible to implement strong public-key cryptography on the small, low-power devices that are common in industrial settings."
                        },
                        {
                            "id": 3,
                            "question": "What is the primary security goal of using ECC in a smart grid system?",
                            "options": [
                                "To make electricity cheaper.",
                                "To ensure the authenticity and integrity of the data and commands being sent between smart meters and the utility, to prevent fraud and manipulation.",
                                "To allow customers to read their own meter.",
                                "To make the power grid less reliable."
                            ],
                            "correct": 1,
                            "explanation": "The smart grid's communication layer must be secured to prevent a wide range of attacks, from energy theft by a single user to a large-scale attack designed to destabilize the entire grid. ECC-based authentication is a key part of this defense."
                        }
                    ]
                }
            },
            {
                "id": "lesson-42",
                "title": "ECC Testing and Validation",
                "duration": "90 min",
                "objectives": [
                    "Generate and use cryptographic test vectors.",
                    "Perform interoperability testing between different ECC libraries.",
                    "Implement Known Answer Tests (KATs) for algorithm verification.",
                    "Use Monte Carlo testing to validate statistical properties.",
                    "Validate an implementation against official standards."
                ],
                "content": {
                    "overview": "This lesson focuses on the critical engineering discipline of testing and validating a cryptographic implementation. We will explore the different types of test vectors and methodologies that are used to prove that an ECC library is not only mathematically correct but also interoperable with other standard implementations.",
                "sections": [
                    {
                        "title": "Known Answer Tests (KATs)",
                        "content": "<p>A KAT is the most fundamental type of cryptographic test. As we've seen, a standards body like NIST will publish a set of test vectors. Each vector contains a known input (private key, message) and the known, correct output (the signature `r` and `s`).</p><p>To validate an implementation, the developer must run their code against every single one of these test vectors and confirm that their output matches the known answer perfectly. This is the primary method for proving that an implementation conforms to the mathematical standard.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Interoperability Testing",
                            "content": "<p>Just because an implementation is mathematically correct does not mean it will work with other libraries. Interoperability testing is the process of testing your library against other, independent implementations of the same standard.</p><p><strong>Real-world Example:</strong> A developer has written a new TLS library in Rust. To validate it, they must test it against the standard OpenSSL library. They would set up a test where their Rust-based TLS client connects to a server running OpenSSL. They must verify that the two libraries can successfully negotiate a cipher suite, perform an ECDHE key exchange, and communicate securely. This proves that their implementation is not only correct but also interoperable with the wider ecosystem.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Monte Carlo Testing",
                        "content": "<p>A Monte Carlo test is a statistical test. For example, to test a key generation function, the test would generate a million key pairs and then, for each one, sign a message and verify the signature. If any of the verifications fail, it indicates a bug in the implementation. This type of large-scale, randomized testing is good at finding subtle bugs and edge cases that might be missed by the fixed set of KATs.</p>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Cross-Implementation Testing (Conceptual)",
                            "language": "python",
                            "code": "# This conceptual script shows the logic for an interoperability test.\n\nimport my_ecc_library # Our new library\nimport openssl_wrapper # A wrapper for the established OpenSSL library\n\n# 1. Generate a key pair using our new library.\nmy_private_key, my_public_key = my_ecc_library.generate_keys()\n\n# 2. Sign a message using our new library.\nmessage = b\"test\"\nmy_signature = my_ecc_library.sign(my_private_key, message)\n\n# 3. Now, try to verify that signature using the *other* library (OpenSSL).\n#    This is the interoperability test.\nverification_result = openssl_wrapper.verify(my_public_key, my_signature, message)\n\nif verification_result:\n    print(\"[+] Interop Test 1 Passed: OpenSSL can verify our signature.\")\nelse:\n    print(\"[!] Interop Test 1 Failed!\")\n\n# 4. Do the reverse. Generate a signature with OpenSSL and verify it with our library.\nopenssl_private, openssl_public = openssl_wrapper.generate_keys()\nopenssl_signature = openssl_wrapper.sign(openssl_private, message)\n\nverification_result_2 = my_ecc_library.verify(openssl_public, openssl_signature, message)\n\nif verification_result_2:\n    print(\"[+] Interop Test 2 Passed: We can verify an OpenSSL signature.\")\nelse:\n    print(\"[!] Interop Test 2 Failed!\")"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "The process of testing a cryptographic implementation against a set of test vectors with pre-computed, known correct outputs is called:",
                            "options": [
                                "A penetration test",
                                "A fuzzing campaign",
                                "A Known Answer Test (KAT)",
                                "A code audit"
                            ],
                            "correct": 2,
                            "explanation": "KATs are a fundamental part of cryptographic validation. They provide a simple pass/fail test to ensure that an implementation is mathematically correct and conforms to the standard."
                        },
                        {
                            "id": 2,
                            "question": "What is the primary goal of interoperability testing?",
                            "options": [
                                "To prove the implementation is mathematically correct.",
                                "To ensure that an implementation can successfully communicate with other, independent implementations of the same standard.",
                                "To find security vulnerabilities.",
                                "To measure the performance of the implementation."
                            ],
                            "correct": 1,
                            "explanation": "Interoperability is crucial for any cryptographic library that will be used in a real-world protocol like TLS. It must be able to 'talk' to the other major libraries in the ecosystem."
                        },
                        {
                            "id": 3,
                            "question": "A test that involves generating and testing thousands or millions of random inputs to look for statistical anomalies or edge case failures is known as a:",
                            "options": [
                                "Known Answer Test (KAT)",
                                "Monte Carlo test",
                                "Unit test",
                                "Integration test"
                            ],
                            "correct": 1,
                            "explanation": "Monte Carlo testing is a statistical method. It's good at finding rare, edge-case bugs that might not be covered by the static set of KATs. It tests the robustness of the implementation over a very large number of random inputs."
                        }
                    ]
                }
            },
            {
                "id": "lesson-43",
                "title": "ECC Patent Landscape and Legal Issues",
                "duration": "90 min",
                "objectives": [
                    "Perform a basic analysis of the patent landscape for ECC.",
                    "Understand the licensing considerations for using patented cryptographic algorithms.",
                    "Differentiate between patent-encumbered and patent-free alternatives.",
                    "Assess the legal risks of implementing certain cryptographic schemes.",
                    "Explore the role of open-source implementations in navigating the patent landscape."
                ],
                "content": {
                    "overview": "This lesson covers the complex legal landscape of intellectual property in cryptography. We will explore the history of patents on elliptic curve and other public-key algorithms, the risks they pose to implementers, and the modern, patent-free curves that have become the standard for open and interoperable systems.",
                "sections": [
                    {
                        "title": "Patent Analysis in ECC",
                        "content": "<p>In the early days of public-key cryptography, many of the fundamental algorithms (including RSA and some aspects of ECC) were covered by patents. This meant that an implementer would need to pay a license fee to the patent holder to use the algorithm in their product.</p><p>This created a significant barrier to adoption and was a major source of legal risk and uncertainty for developers. Most of these foundational patents have now expired.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Licensing Considerations and Risk Assessment",
                            "content": "<p>While the basic ECC patents have expired, new and more advanced techniques (especially in pairing-based and post-quantum cryptography) may be covered by new patents. A company that wants to implement a cutting-edge cryptographic algorithm must first perform a thorough patent analysis and legal risk assessment to ensure they are not infringing on someone's intellectual property.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Patent-Free Alternatives and Open Source",
                        "content": "<p>The legal complexity of patents has been a major driver for the development of modern, completely unencumbered cryptographic primitives.</p><p><strong>Real-world Example: Curve25519 and Ed25519.</strong> One of the explicit design goals of these modern curves by Daniel J. Bernstein was that they would be completely free of any patent claims. They were developed in the public domain. This, combined with their excellent performance and security, is a major reason why they have been so rapidly and widely adopted by the open-source community and are now used in a huge number of applications, from Signal to SSH.</p>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Patent Database Analysis (Conceptual)",
                            "language": "markdown",
                            "code": "# This is a conceptual example of a patent analysis for a new cryptographic algorithm.\n\n**Algorithm Name:** 'MyNewCryptoScheme'\n\n**1. Prior Art Search:**\n- Search patent databases (e.g., Google Patents, USPTO) for all patents related to the core mathematical concepts used in 'MyNewCryptoScheme'.\n- Search academic literature to establish the date of public disclosure for these concepts.\n\n**2. Freedom to Operate (FTO) Analysis:**\n- For each relevant patent found, a patent lawyer must analyze its 'claims'.\n- Does our new scheme fall within the scope of the patent's claims?\n- Is the patent still active in the jurisdictions where we want to sell our product?\n\n**3. Risk Assessment:**\n- High Risk: Our scheme appears to directly infringe on a broad, active patent from a major competitor.\n- Medium Risk: There is some overlap, but we may have a strong argument for non-infringement.\n- Low Risk: The relevant patents have expired, or our scheme is demonstrably different.\n\n**4. Decision:**\n- Based on the risk assessment, the company decides whether to proceed with the implementation, try to license the patent, or choose a different, unencumbered algorithm."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What was a major barrier to the early adoption of some public-key algorithms?",
                            "options": [
                                "They were too slow.",
                                "They were covered by patents, which required a license fee to use.",
                                "They were not secure.",
                                "They only worked on one type of computer."
                            ],
                            "correct": 1,
                            "explanation": "The patent landscape created significant legal and financial hurdles, which slowed down the widespread adoption of public-key cryptography in the 1980s and 90s. Most of these fundamental patents have since expired."
                        },
                        {
                            "id": 2,
                            "question": "A key design goal of modern curves like Curve25519 was to be:",
                            "options": [
                                "As complex as possible.",
                                "Covered by as many patents as possible.",
                                "Completely unencumbered by any patents and free for all to use.",
                                "Only usable by governments."
                            ],
                            "correct": 2,
                            "explanation": "The creators of these modern curves made a deliberate effort to ensure their work was in the public domain and not subject to any patent claims. This has been a major factor in their rapid and widespread adoption."
                        },
                        {
                            "id": 3,
                            "question": "The process of having a lawyer analyze the patent landscape to determine if a new product is likely to infringe on existing patents is known as a:",
                            "options": [
                                "Code review",
                                "Security audit",
                                "Freedom to Operate (FTO) analysis",
                                "Performance benchmark"
                            ],
                            "correct": 2,
                            "explanation": "An FTO analysis is a critical due diligence step for any company that is developing a new technology. It is designed to assess the legal risk of patent infringement before investing heavily in development and marketing."
                        }
                    ]
                }
            },
            {
                "id": "lesson-44",
                "title": "ECC Hardware Security Modules",
                "duration": "90 min",
                "objectives": [
                    "Understand the architecture and purpose of an HSM.",
                    "Integrate an application with an HSM using a standard API like PKCS#11.",
                    "Perform secure, hardware-based key generation.",
                    "Analyze the physical and logical tamper-resistant designs of HSMs.",
                    "Discuss the FIPS 140-2/3 certification requirements for HSMs."
                ],
                "content": {
                    "overview": "This lesson focuses on the gold standard for protecting the most critical private keys: the Hardware Security Module (HSM). We will explore the architecture of these tamper-resistant devices, the APIs used to interact with them, and the rigorous certification process they must undergo to be considered truly secure.",
                "sections": [
                    {
                        "title": "HSM Architecture and Purpose",
                        "content": "<p>An HSM is a dedicated cryptographic computer. Its sole purpose is to manage and protect digital keys and perform cryptographic operations.</p><h3>The Core Security Principle:</h3><p>The private keys are generated *inside* the HSM's secure, tamper-resistant boundary and are physically incapable of ever leaving the device. All cryptographic operations that use the private key (like signing or decrypting) happen *inside* the HSM.</p>",
                            "image": "https://images.unsplash.com/photo-1593435713588-a73de23947db?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "HSM Integration (PKCS#11)",
                            "content": "<p>An application communicates with an HSM through a standard cryptographic API. The most common is **PKCS#11**, also known as Cryptoki. It provides a generic, vendor-neutral API for an application to find and use cryptographic objects (like keys) on a hardware token or HSM, without needing to know the low-level details of the specific device.</p>",
                            "image": "https://images.unsplash.com/photo-1587620962725-abab7fe55159?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Tamper Resistance and Certification",
                        "content": "<p>HSMs are designed to be physically secure. They have a web of sensors to detect physical tampering (like drilling or temperature changes). If tampering is detected, the HSM's firmware is designed to immediately erase all the keys it contains (a process called 'zeroization').</p><p><strong>Real-world Example: FIPS 140-2/3 Certification.</strong> To be used in government and high-security financial applications, an HSM must undergo a rigorous validation process to achieve a FIPS 140-2 or the newer FIPS 140-3 certification. This certification has different security levels. For example, Level 3 requires physical tamper-resistance. Level 4, the highest, requires the HSM to be able to detect and respond to tampering even when it is powered off. This certification is a very high bar and is a key differentiator for a high-assurance cryptographic product.</p>",
                            "image": "https://images.unsplash.com/photo-1548092372-2d987bde898b?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "HSM API Integration (PKCS#11)",
                            "language": "c",
                            "code": "// This is a conceptual C code snippet showing the high-level logic of using the PKCS#11 API.\n\n#include <pkcs11.h>\n\n// 1. Load the vendor-specific PKCS#11 library.\n// C_GetFunctionList(...)\n\n// 2. Initialize the library.\n// C_Initialize(NULL_PTR);\n\n// 3. Open a session to a specific slot (the HSM).\n// C_OpenSession(slotID, CKF_SERIAL_SESSION | CKF_RW_SESSION, NULL_PTR, NULL_PTR, &hSession);\n\n// 4. Log in to the HSM with a user PIN.\n// C_Login(hSession, CKU_USER, pPin, ulPinLen);\n\n// 5. Find the private key object on the HSM.\n// C_FindObjectsInit(hSession, ...);\n// C_FindObjects(hSession, &hSigningKey, ...);\n// C_FindObjectsFinal(hSession);\n\n// 6. Use the key handle to sign data.\n//    The message hash is sent to the HSM, and the signature is returned.\n//    The private key itself never leaves the HSM.\n// C_SignInit(hSession, &mechanism, hSigningKey);\n// C_Sign(hSession, pData, ulDataLen, pSignature, &ulSignatureLen);\n\n// 7. Log out and close the session.\n// C_Logout(hSession);\n// C_CloseSession(hSession);"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the core security principle of a Hardware Security Module (HSM)?",
                            "options": [
                                "It makes cryptographic operations run faster.",
                                "The private keys are generated inside it and are physically incapable of ever leaving the device.",
                                "It can store an unlimited number of keys.",
                                "It is easy to program."
                            ],
                            "correct": 1,
                            "explanation": "This is the fundamental security guarantee of an HSM. By ensuring the key can never be extracted, it provides a very high level of protection against theft, even if the server the HSM is connected to is completely compromised."
                        },
                        {
                            "id": 2,
                            "question": "The most common, vendor-neutral API for communicating with an HSM or a smart card is known as:",
                            "options": [
                                "The Windows API",
                                "The POSIX API",
                                "PKCS#11",
                                "The Java API"
                            ],
                            "correct": 2,
                            "explanation": "PKCS#11 (also known as Cryptoki) is the industry standard. It provides a consistent API that allows an application to use any compliant HSM without having to write vendor-specific code."
                        },
                        {
                            "id": 3,
                            "question": "A rigorous, multi-level certification for cryptographic modules that is required for their use in US government applications is known as:",
                            "options": [
                                "Common Criteria",
                                "FIPS 140-2 / 140-3",
                                "ISO 9001",
                                "PCI DSS"
                            ],
                            "correct": 1,
                            "explanation": "The FIPS 140 standard is the benchmark for cryptographic module security. The different levels (1 through 4) specify increasingly stringent requirements for physical and logical security."
                        }
                    ]
                }
            },
            {
                "id": "lesson-45",
                "title": "ECC in Authentication Systems",
                "duration": "90 min",
                "objectives": [
                    "Design a multi-factor authentication system using ECC.",
                    "Use ECC to protect biometric templates.",
                    "Understand the cryptography behind hardware tokens like YubiKeys.",
                    "Analyze the FIDO2/WebAuthn passwordless authentication protocol.",
                    "Implement a mobile authenticator app using ECC."
                ],
                "content": {
                    "overview": "This lesson explores the application of ECC in modern authentication systems. We will move beyond simple passwords to the strong, phishing-resistant authentication provided by hardware tokens and the FIDO2/WebAuthn standards, all of which are built on the foundation of elliptic curve digital signatures.",
                "sections": [
                    {
                        "title": "Multi-Factor Authentication with ECC",
                        "content": "<p>ECC is the core of modern, strong second-factor authentication.</p><h3>Hardware Tokens (YubiKey):</h3><p>A device like a YubiKey contains a small, secure cryptographic chip. When you register it with a service, the YubiKey generates a unique ECC private key that is stored securely on the chip and can never leave. To log in, the service sends a random challenge to your browser. Your browser passes it to the YubiKey. The YubiKey signs the challenge with its private key and returns the signature. The service can then verify this signature with your registered public key. This is much stronger than a one-time password because the secret never leaves the hardware.",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "FIDO2/WebAuthn: The Passwordless Future",
                            "content": "<p>FIDO2 is a set of open standards for passwordless authentication. WebAuthn is the JavaScript API that allows web applications to use it.</p><p>When you register with a WebAuthn-enabled site, your device (e.g., your laptop with a fingerprint reader, or your phone) generates a brand new, unique ECC key pair *for that specific website*. The private key is stored in the secure hardware of your device (like a TPM or Secure Enclave). To log in, you just use your fingerprint or PIN to authorize your device to sign a challenge from the website. There is no password to be phished or stolen from a server breach. This is the gold standard for secure authentication on the web.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Biometric Template Protection",
                        "content": "<p>Storing raw biometric data (like a fingerprint image) is dangerous. Instead, the system extracts a unique set of features (a 'template') from the biometric. This template can be protected using ECC. For example, the template can be encrypted with an ECC public key, and the corresponding private key can be stored in a secure hardware element on the device. This ensures that even if the stored template is stolen, it cannot be reverse-engineered to reconstruct the original fingerprint.</p>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "FIDO2/WebAuthn Implementation (Conceptual JS)",
                            "language": "javascript",
                            "code": "// This is a conceptual JavaScript snippet for the FIDO2/WebAuthn registration process.\n\n// 1. The server sends a challenge and user information to the client.\nconst publicKeyCredentialCreationOptions = {\n    challenge: new Uint8Array([...]),\n    rp: { name: \"My Awesome Website\" },\n    user: { id: new Uint8Array([...]), name: \"user@example.com\", displayName: \"User\" },\n    pubKeyCredParams: [{ type: \"public-key\", alg: -7 }] // -7 is ECDSA with P-256 and SHA-256\n};\n\n// 2. The browser's WebAuthn API is called with these options.\n//    This will trigger the platform authenticator (e.g., Windows Hello, Touch ID).\nnnavigator.credentials.create({ publicKey: publicKeyCredentialCreationOptions })\n    .then(function (credential) {\n        // 3. The authenticator creates a new, unique ECC key pair for this website.\n        //    The private key is stored securely on the device.\n        //    The browser returns the public key and an attestation signature to the web page.\n        \n        // 4. The web page sends this credential object back to the server, which verifies\n        //    the attestation and stores the user's new public key.\n        //    The user is now registered without ever having created a password.\n    });"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "A hardware token like a YubiKey provides strong second-factor authentication by doing what?",
                            "options": [
                                "By storing the user's password.",
                                "By generating a one-time password.",
                                "By storing a private key that never leaves the device and using it to sign a challenge from the server.",
                                "By blinking a light."
                            ],
                            "correct": 2,
                            "explanation": "The core security of a FIDO2 hardware token is that the private key is generated on the device and is physically incapable of being exported. This makes it immune to phishing and remote attacks."
                        },
                        {
                            "id": 2,
                            "question": "What is the primary goal of the FIDO2/WebAuthn standards?",
                            "options": [
                                "To make passwords longer.",
                                "To enable a secure, phishing-resistant, passwordless authentication experience on the web.",
                                "To encrypt all web traffic.",
                                "To make websites load faster."
                            ],
                            "correct": 1,
                            "explanation": "FIDO2/WebAuthn is designed to replace passwords. By using public-key cryptography (specifically ECC) built into our devices, it provides a much stronger and more user-friendly way to log in."
                        },
                        {
                            "id": 3,
                            "question": "In a FIDO2/WebAuthn registration, where is the private key stored?",
                            "options": [
                                "On the web server.",
                                "In a cookie in the browser.",
                                "In the secure hardware of the user's device (e.g., a TPM or Secure Enclave).",
                                "It is not stored anywhere."
                            ],
                            "correct": 2,
                            "explanation": "This is a key part of the security model. The private key is tied to the physical device and is protected by the device's own secure hardware, preventing it from being stolen by malware or a remote attacker."
                        }
                    ]
                }
            },
            {
                "id": "lesson-46",
                "title": "Advanced ECC Protocols",
                "duration": "90 min",
                "objectives": [
                    "Understand and implement an Oblivious Transfer protocol using ECC.",
                    "Explore the basics of secure two-party computation.",
                    "Analyze and implement a Private Set Intersection (PSI) protocol.",
                    "Discuss the construction of anonymous credentials and group signatures."
                ],
                "content": {
                    "overview": "This lesson explores some of the most advanced and powerful protocols that are built on top of elliptic curve cryptography. We will delve into the world of secure multi-party computation, learning how to build systems where multiple parties can compute a result without revealing their private inputs to each other.",
                "sections": [
                    {
                        "title": "Oblivious Transfer (OT)",
                        "content": "<p>Oblivious Transfer is a fundamental building block for many MPC protocols. A 1-out-of-2 OT protocol allows a receiver to choose and receive one of two messages from a sender, without the sender knowing which of the two messages the receiver chose. This can be implemented efficiently using ECC.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Secure Two-Party Computation (2PC)",
                            "content": "<p>2PC allows two parties to jointly compute a function on their private inputs. The classic example is Yao's Millionaires' Problem: two millionaires want to know who is richer, without revealing their actual net worth to each other. This can be solved using a 2PC protocol.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Private Set Intersection (PSI)",
                        "content": "<p>PSI is a specific MPC protocol that allows two parties to find the intersection of their private sets, without revealing any information about the items that are not in the intersection.</p><p><strong>Real-world Example:</strong> A government intelligence agency has a list of suspected phone numbers, and a telephone company has its full list of customer phone numbers. They want to find out which of the suspect numbers are customers of the phone company. Using a PSI protocol based on ECC, the two parties can interact and discover only the numbers that are in both lists. The agency learns nothing about the phone company's other customers, and the phone company learns nothing about the agency's other suspect numbers.</p>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Private Set Intersection (PSI) Implementation (Conceptual)",
                            "language": "python",
                            "code": "# This is a conceptual script showing the logic of a simple PSI protocol using ECC.\n\n# --- Client (Party A) ---\n# Party A has a private set of items.\nset_A = {\"apple\", \"banana\", \"cherry\"}\n\n# 1. Party A generates a private key 'a'.\n# 2. For each item in their set, they hash it to a point on the curve H(item),\n#    and then multiply it by their private key: a*H(item).\n# 3. They send this set of 'blinded' points to the server.\nblinded_set_A = {scalar_multiply(a, hash_to_curve(item)) for item in set_A}\n\n# --- Server (Party B) ---\n# Party B has their own private set and a private key 'b'.\nset_B = {\"banana\", \"grape\", \"orange\"}\n\n# 4. For each blinded point received from A, the server multiplies it by its own\n#    private key 'b': b*(a*H(item)).\nserver_processed_set = {scalar_multiply(b, blinded_point) for blinded_point in blinded_set_A}\n\n# 5. The server also hashes its own items to the curve and multiplies by 'b': b*H(item).\nserver_self_processed_set = {scalar_multiply(b, hash_to_curve(item)) for item in set_B}\n\n# 6. The server sends both of these processed sets back to the client.\n\n# --- Client (Party A) ---\n# 7. The client computes the inverse of their private key, a_inv.\n# 8. They take the set from step 4 and multiply each point by a_inv:\n#    a_inv*(b*a*H(item)) = b*H(item).\n# 9. Now the client has two sets of points: {b*H(item) for item in set_A} and {b*H(item) for item in set_B}.\n#    They can now find the intersection of these two sets to find the common items,\n#    without the server ever learning what was in their original set."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "A protocol that allows a group of parties to jointly compute a function on their private inputs without revealing those inputs to each other is known as:",
                            "options": [
                                "A digital signature",
                                "Secure Multi-Party Computation (MPC)",
                                "A key exchange",
                                "An encryption algorithm"
                            ],
                            "correct": 1,
                            "explanation": "MPC is a powerful field of cryptography that allows for computation on private data. ECC provides many of the essential building blocks for practical MPC protocols."
                        },
                        {
                            "id": 2,
                            "question": "Yao's Millionaires' Problem is the classic example of what?",
                            "options": [
                                "Secret Sharing",
                                "Threshold Cryptography",
                                "Secure Two-Party Computation",
                                "A digital signature"
                            ],
                            "correct": 2,
                            "explanation": "This problem—determining which of two millionaires is richer without them revealing their wealth—is the canonical introductory problem for 2PC. It demonstrates the ability to compute a function (`>` comparison) on private inputs."
                        },
                        {
                            "id": 3,
                            "question": "A protocol that allows two parties to find the common items in their private lists without revealing anything else is known as:",
                            "options": [
                                "Private Set Intersection (PSI)",
                                "Secret Sharing",
                                "Threshold Cryptography",
                                "A digital signature"
                            ],
                            "correct": 0,
                            "explanation": "PSI is a specialized MPC protocol with many real-world applications, from ad networks to law enforcement, where two parties need to compare sensitive data without revealing the data itself."
                        }
                    ]
                }
            },
            {
                "id": "lesson-47",
                "title": "ECC in Consensus Mechanisms",
                "duration": "90 min",
                "objectives": [
                    "Analyze the role of ECC in blockchain consensus.",
                    "Explore the use of ECC in Proof-of-Stake (PoS) implementations.",
                    "Understand how ECC is used to build a distributed random beacon.",
                    "Analyze the construction of Verifiable Delay Functions (VDFs).",
                    "Discuss the security of Byzantine Fault Tolerant (BFT) consensus protocols."
                ],
                "content": {
                    "overview": "This lesson explores the critical role of elliptic curve cryptography in the consensus mechanisms that secure modern blockchains. We will move beyond simple transaction signing to the advanced cryptographic tools that enable a distributed network of nodes to agree on a single source of truth, from the selection of validators in Proof-of-Stake to the generation of unbiased randomness.",
                "sections": [
                    {
                        "title": "Blockchain Consensus with ECC",
                        "content": "<p>In a Proof-of-Work system like Bitcoin, consensus is achieved through mining. But in a Proof-of-Stake (PoS) system, a set of 'validators' who have staked their own cryptocurrency are chosen to propose and vote on new blocks. ECC is used extensively in this process:</p><ul><li>Each validator has an ECC key pair.</li><li>Validators use their private keys to sign their votes on new blocks.</li><li>The rest of the network can verify these signatures to ensure that a valid quorum of validators has approved the block.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1621452773352-2a74c35b2917?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Distributed Random Beacons",
                            "content": "<p>Many PoS systems require a source of unbiased, unpredictable, and publicly verifiable randomness to choose the next block producer. A distributed random beacon is a protocol for this. Many of these are built using BLS signatures (from Lesson 15).</p><p><strong>Real-world Example:</strong> A group of participants can use a threshold BLS signature scheme. Each participant creates a random number and commits to it. They then reveal their numbers. All the numbers are combined to create a new random seed. They then use their BLS key shares to jointly sign this new seed. The resulting signature is the final, unpredictable, and verifiable random value for that round.</p>",
                            "image": "https://images.unsplash.com/photo-1642155998158-9416a041cb42?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Verifiable Delay Functions (VDFs)",
                        "content": "<p>A VDF is a new cryptographic primitive. It is a function that takes a long time to compute, but the result it produces is very fast to verify. Crucially, the computation cannot be parallelized; you must perform the sequential steps.</p><p>This is useful for randomness generation. A VDF can take a value and run it through its slow computation. The output is a new value that could not have been predicted in advance. Some VDF constructions are based on the mathematics of isogenies on elliptic curves.</p>",
                            "image": "https://images.unsplash.com/photo-1548092372-2d987bde898b?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "PoS Validator Implementation (Conceptual)",
                            "language": "python",
                            "code": "# This is a conceptual script showing how a PoS validator would sign a block.\n\n# 1. The validator has a private key.\nvalidator_private_key = ...\n\n# 2. A new block has been proposed.\nproposed_block = {\n    'height': 12345,\n    'previous_hash': '0xabc...',\n    'transactions': [...]\n}\n\n# 3. The validator verifies that all the transactions in the block are valid.\n# if not validate_transactions(proposed_block['transactions']):\n#    return # Do not sign\n\n# 4. If the block is valid, the validator hashes it to create a digest.\nblock_hash = hash(serialize(proposed_block))\n\n# 5. The validator signs the block hash with their private key.\n#    This could be an ECDSA or a BLS signature.\nsignature = ecdsa_sign(validator_private_key, block_hash)\n\n# 6. The validator broadcasts the block and their signature to the network.\n#    Other nodes will collect signatures, and once a quorum (e.g., 2/3 of validators)\n#    has signed off on the same block, it is considered finalized."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "In a Proof-of-Stake (PoS) blockchain, what is the primary use of ECC digital signatures?",
                            "options": [
                                "To encrypt the blockchain.",
                                "For validators to sign their votes on new blocks, to prove that a valid quorum has approved the block.",
                                "To make the blockchain run slower.",
                                "They are not used in PoS."
                            ],
                            "correct": 1,
                            "explanation": "Signatures are the core of a PoS consensus mechanism. They provide the public verifiability that allows the distributed network to agree on the state of the ledger."
                        },
                        {
                            "id": 2,
                            "question": "A protocol where a group of participants can jointly generate a single, unpredictable, and publicly verifiable random number is known as a:",
                            "options": [
                                "A digital signature",
                                "A distributed random beacon",
                                "A consensus mechanism",
                                "A smart contract"
                            ],
                            "correct": 1,
                            "explanation": "Distributed random beacons are a key component of many modern PoS blockchains. They provide a fair and unbiased way to select which validator gets to propose the next block."
                        },
                        {
                            "id": 3,
                            "question": "A function that is slow to compute but fast to verify, and whose computation cannot be parallelized, is known as a:",
                            "options": [
                                "Hash function",
                                "Digital signature",
                                "Verifiable Delay Function (VDF)",
                                "Key exchange"
                            ],
                            "correct": 2,
                            "explanation": "VDFs are a relatively new cryptographic primitive with important applications in generating trustworthy randomness. The forced sequential delay is its key security property."
                        }
                    ]
                }
            },
            {
                "id": "lesson-48",
                "title": "ECC Side-Channel Analysis Advanced",
                "duration": "90 min",
                "objectives": [
                    "Perform template attacks on ECC implementations.",
                    "Apply Correlation Power Analysis (CPA) to extract secret keys.",
                    "Analyze electromagnetic emanations for side-channel leakage.",
                    "Conduct cache-timing attacks.",
                    "Explore microarchitectural attacks like Spectre and Meltdown in the context of ECC."
                ],
                "content": {
                    "overview": "This lesson is a deep dive into the advanced, practical techniques of side-channel analysis. We will move beyond the theory to the powerful statistical attacks, like Correlation Power Analysis and template attacks, that are used in the real world to extract secret keys from physical devices, and explore the new frontier of microarchitectural side channels.",
                "sections": [
                    {
                        "title": "Template Attacks",
                        "content": "<p>A template attack is one of the most powerful forms of side-channel attack, but it requires the attacker to have an identical 'profiling' device that they have full control over.</p><h3>The Two Phases:</h3><ol><li><strong>Profiling Phase:</strong> The attacker uses their profiling device to create a detailed 'template' of the device's power consumption. They make the device perform thousands of cryptographic operations with known keys and inputs, and use machine learning to build a precise model of what the power trace looks like for every possible intermediate value.</li><li><strong>Attack Phase:</strong> The attacker then captures a single power trace from the victim device as it performs an operation with the unknown secret key. They can then compare this single trace to their pre-built templates to recover the secret key with a very high success rate.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1575235028124-ab6346a5a0a3?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Correlation Power Analysis (CPA)",
                            "content": "<p>CPA is a powerful statistical method that can extract keys even in a noisy environment. It works by creating a 'hypothetical power model'.</p><p><strong>Real-world Example:</strong> The attacker hypothesizes a value for a few bits of the secret key. They then use their power model to predict what the power consumption *should* look like at a specific point in time if that hypothesis were correct. They then compare this hypothetical prediction to the actual, measured power trace using a statistical correlation function. They repeat this for all possible hypotheses. The hypothesis that has the highest correlation with the real power trace is the most likely to be the correct value for those key bits. By repeating this process, they can recover the entire key, piece by piece.</p>",
                            "image": "https://images.unsplash.com/photo-1552392187-952b1e4f4a3e?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Cache-Timing and Microarchitectural Attacks",
                        "content": "<p>These attacks do not require physical access to measure power. They are software-based side-channel attacks.</p><ul><li><strong>Cache-Timing Attack:</strong> One process on a CPU can infer what data another process is using by carefully measuring the time it takes to access different parts of memory. If an access is fast, it means the data was already in the shared CPU cache, which leaks information about the other process's activity.</li><li><strong>Microarchitectural Attacks (Spectre/Meltdown):</strong> These attacks exploit the speculative execution features of a modern CPU to create a transient side channel that can leak data from anywhere in memory, including from the kernel or other processes.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1593435713588-a73de23947db?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Correlation Power Analysis (CPA) - Conceptual",
                            "language": "python",
                            "code": "# This conceptual Python script demonstrates the logic of a CPA attack.\n\nimport numpy as np\n\ndef correlate(a, b):\n    return np.corrcoef(a, b)[0, 1]\n\n# 1. We have a set of 'n' real power traces from a device.\n#    real_traces = [trace1, trace2, ...]\n\n# 2. We want to find the first byte of the secret key (256 possibilities).\nmax_correlation = -1\nbest_key_guess = 0\n\nfor key_guess in range(256):\n    # 3. For each guess, we create a 'hypothetical' power trace.\n    #    This model predicts the power consumption (e.g., the Hamming weight of an intermediate value)\n    #    at a specific point in time, *if* our key guess were correct.\n    hypothetical_trace = predict_power_consumption(known_inputs, key_guess)\n\n    # 4. We calculate the statistical correlation between our hypothetical trace\n    #    and the average of all the real traces.\n    correlation = correlate(hypothetical_trace, np.mean(real_traces, axis=0))\n\n    # 5. The guess that produces the highest correlation is the most likely to be correct.\n    if correlation > max_correlation:\n        max_correlation = correlation\n        best_key_guess = key_guess\n\nprint(f\"Best guess for the key byte is: {hex(best_key_guess)} with correlation {max_correlation}\")"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "A side-channel attack that requires the attacker to have an identical 'profiling' device to build a detailed model of its power consumption is known as a:",
                            "options": [
                                "Timing attack",
                                "Template attack",
                                "Fault injection attack",
                                "Cache-timing attack"
                            ],
                            "correct": 1,
                            "explanation": "Template attacks are extremely powerful because they use machine learning on a profiling device to build a highly accurate template of the target's behavior. They are often the most effective, but also the most difficult to set up."
                        },
                        {
                            "id": 2,
                            "question": "Correlation Power Analysis (CPA) works by:",
                            "options": [
                                "Injecting a fault into the device.",
                                "Finding the statistical correlation between a hypothetical power model (based on a key guess) and the real, measured power traces.",
                                "Measuring the time it takes for an operation to complete.",
                                "Breaking the mathematical algorithm directly."
                            ],
                            "correct": 1,
                            "explanation": "CPA is a powerful statistical attack. Its strength lies in its ability to extract a very weak signal (the power difference) from a very noisy environment by correlating it across thousands of measurements."
                        },
                        {
                            "id": 3,
                            "question": "Spectre and Meltdown are examples of what kind of software-based side-channel attack?",
                            "options": [
                                "Power analysis attacks",
                                "Timing attacks",
                                "Microarchitectural attacks",
                                "Fault injection attacks"
                            ],
                            "correct": 2,
                            "explanation": "These attacks exploit flaws in the design of the CPU's microarchitecture (like speculative execution) to create a side channel (like the CPU cache) that can be used to leak data that should be inaccessible."
                        }
                    ]
                }
            },
            {
                "id": "lesson-49",
                "title": "ECC Implementation Security",
                "duration": "90 min",
                "objectives": [
                    "Apply secure coding practices for cryptographic implementations.",
                    "Identify and mitigate common implementation vulnerability patterns.",
                    "Use automated security testing and fuzzing to find bugs in cryptographic code.",
                    "Integrate formal verification into the development lifecycle.",
                    "Develop a robust security development lifecycle (SDL) for a cryptographic library."
                ],
                "content": {
                    "overview": "This lesson focuses on the defensive side of implementation. We will explore the secure coding practices, testing methodologies, and development lifecycles required to build a robust and secure ECC library that is resistant to the wide range of attacks we have studied throughout this course.",
                "sections": [
                    {
                        "title": "Secure Coding Practices",
                        "content": "<p>Writing secure cryptographic code requires extreme discipline and attention to detail.</p><h3>Key Principles:</h3><ul><li><strong>Constant-Time Programming:</strong> As discussed, all code that handles secret data must be written to be constant-time to prevent side-channel leaks.</li><li><strong>No Data on the Stack:</strong> Avoid placing sensitive data like private keys on the stack. Use secure, heap-allocated memory that can be zeroed out after use.</li><li><strong>Zeroization:</strong> Always explicitly wipe secret data from memory as soon as it is no longer needed.</li><li><strong>Simplicity:</strong> A simpler implementation is easier to analyze and has a smaller attack surface.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Automated Security Testing and Fuzzing",
                            "content": "<p>Secure development is a continuous process. Security testing should be automated and integrated into the development pipeline.</p><p><strong>Real-world Example: Cryptographic Fuzzing.</strong> A developer is writing an ECC library. They set up a continuous fuzzing campaign using a modern fuzzer like AFL or LibFuzzer. The fuzzer constantly generates malformed public keys, signatures, and ciphertexts and feeds them to the library's parsing and verification functions. This is an extremely effective way to find memory corruption bugs, denial-of-service vulnerabilities, and other implementation flaws before the code is ever released.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Formal Verification Integration",
                        "content": "<p>For the highest level of assurance, formal verification can be integrated into the development process. A developer might write their core algorithms in a verifiable language (like F*) or use tools to generate a machine-checked proof of the correctness and security of their C code. This provides a level of assurance against implementation bugs that is impossible to achieve with testing alone.</p>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Cryptographic Fuzzing Framework (libFuzzer)",
                            "language": "cpp",
                            "code": "// This is a conceptual C++ fuzzing harness using libFuzzer.\n// It's designed to find bugs in a function that parses a public key.\n\n#include <cstdint>\n#include <cstddef>\n#include \"my_ecc_library.h\"\n\n// The fuzzer will call this function millions of times with random data.\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {\n    // The random data from the fuzzer is treated as a potential public key.\n    ECC_PublicKey key;\n    \n    // Call the function we want to test.\n    // The fuzzer will automatically detect if this function crashes, hangs, or\n    // leaks memory, which would indicate a vulnerability.\n    parse_public_key(&key, Data, Size);\n    \n    return 0; // The fuzzer continues\n}\n\n// To compile, you would use a modern compiler like Clang with the -fsanitize=fuzzer flag.\n// clang -fsanitize=fuzzer,address fuzz_target.cpp my_ecc_library.a -o fuzzer"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "The practice of ensuring that a piece of code's execution time does not depend on the value of any secret data is known as:",
                            "options": [
                                "Fuzzing",
                                "Constant-time programming",
                                "Unit testing",
                                "Formal verification"
                            ],
                            "correct": 1,
                            "explanation": "Constant-time programming is the primary software countermeasure against timing and simple power analysis side-channel attacks."
                        },
                        {
                            "id": 2,
                            "question": "What is the primary goal of fuzzing a cryptographic implementation?",
                            "options": [
                                "To measure its performance.",
                                "To automatically find implementation bugs and security vulnerabilities by feeding it a huge volume of malformed and unexpected inputs.",
                                "To prove that it is mathematically correct.",
                                "To write the documentation for it."
                            ],
                            "correct": 1,
                            "explanation": "Fuzzing is an automated bug-finding technique. It is extremely effective at finding memory corruption vulnerabilities and other flaws in the code that parses complex data formats, which is a common task in cryptography."
                        },
                        {
                            "id": 3,
                            "question": "The process of using rigorous, mathematical methods to *prove* that a cryptographic implementation is correct is known as:",
                            "options": [
                                "Penetration testing",
                                "Fuzzing",
                                "Unit testing",
                                "Formal verification"
                            ],
                            "correct": 3,
                            "explanation": "Formal verification provides the highest possible level of assurance. Instead of just testing for the presence of bugs, it can be used to prove their absence for certain classes of errors."
                        }
                    ]
                }
            },
            {
                "id": "lesson-50",
                "title": "Future of Elliptic Curve Cryptography",
                "duration": "90 min",
                "objectives": [
                    "Develop a high-level strategy for a post-quantum transition.",
                    "Analyze the architecture of a hybrid cryptographic system.",
                    "Discuss the emerging mathematical foundations that may replace or augment ECC.",
                    "Explore the ongoing standardization roadmaps for new cryptography.",
                    "Engage in long-term security planning for a cryptographic ecosystem."
                ],
                "content": {
                    "overview": "This final lesson synthesizes our entire journey and looks to the future. We will discuss the strategic challenges of the upcoming migration to post-quantum cryptography, the role that ECC will continue to play in a hybrid world, and the exciting open research problems that will define the future of this elegant and powerful field.",
                "sections": [
                    {
                        "title": "Post-Quantum Transition Strategies",
                        "content": "<p>The migration to post-quantum cryptography will be one of the most significant and difficult transitions in the history of information technology. It will take many years and will require a careful, phased approach.</p><h3>Crypto-Agility:</h3><p>A key principle for any new system being designed today is **crypto-agility**. This means the system should be designed in a way that allows its cryptographic algorithms to be easily replaced or upgraded in the future without a complete redesign. Hardcoding a specific curve or algorithm is a recipe for future disaster.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Hybrid Cryptographic Systems",
                            "content": "<p>In the near to medium term, the most common transition strategy will be the use of **hybrid systems**.</p><p>A hybrid system performs both a classical and a post-quantum operation and combines the results. For example, a hybrid signature scheme would require a message to be signed with *both* an ECDSA key and a post-quantum key. A verifier would have to check both signatures. This system is secure as long as *at least one* of the two schemes is secure. This provides a robust way to introduce the new, less-tested PQC algorithms while still retaining the security of the well-understood classical ones.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "The Enduring Importance of ECC",
                        "content": "<p>Even in a post-quantum world, ECC and its underlying mathematics will remain relevant. It will be the benchmark against which new algorithms are measured, a component of hybrid schemes, and will continue to be secure against all non-quantum attackers for the foreseeable future. The elegant fusion of number theory, algebra, and geometry that creates elliptic curve cryptography will continue to be a cornerstone of our digital world and a rich and rewarding field of study for the next generation of cryptographers.</p>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Hybrid System Implementation (Conceptual)",
                            "language": "python",
                            "code": "# This conceptual script shows the logic of a hybrid signature scheme.\n\nmessage = b\"This is a critically important message.\"\nmessage_hash = hash(message)\n\n# --- Signing ---\n# The signer has both a classical and a post-quantum private key.\n\n# 1. Sign the hash with the classical algorithm (ECDSA).\necdsa_signature = ecdsa_sign(ecdsa_private_key, message_hash)\n\n# 2. Sign the hash with the post-quantum algorithm (e.g., CRYSTALS-Dilithium).\npqc_signature = dilithium_sign(pqc_private_key, message_hash)\n\n# 3. The final, hybrid signature is the concatenation of the two.\nhybrid_signature = ecdsa_signature + pqc_signature\n\n# --- Verification ---\n# The verifier has both public keys.\n\n# 1. Split the hybrid signature back into its two components.\n\n# 2. Verify the ECDSA part with the ECDSA public key.\n# is_ecdsa_valid = ecdsa_verify(ecdsa_public_key, message_hash, ecdsa_signature)\n\n# 3. Verify the PQC part with the PQC public key.\n# is_pqc_valid = dilithium_verify(pqc_public_key, message_hash, pqc_signature)\n\n# 4. The hybrid signature is only valid if BOTH parts are valid.\nif is_ecdsa_valid and is_pqc_valid:\n    print(\"[+] Hybrid signature is VALID.\")"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "The design principle of making it easy to replace the cryptographic algorithms in a system in the future is known as:",
                            "options": [
                                "A hybrid system",
                                "Crypto-agility",
                                "Post-quantum cryptography",
                                "Formal verification"
                            ],
                            "correct": 1,
                            "explanation": "Crypto-agility is a critical design principle for any new system. It acknowledges that cryptographic standards will change over time and builds in the flexibility to adapt to those changes without a complete system overhaul."
                        },
                        {
                            "id": 2,
                            "question": "What is the primary security guarantee of a 'hybrid' cryptographic system that combines a classical and a post-quantum algorithm?",
                            "options": [
                                "It is faster than either algorithm alone.",
                                "It is secure as long as *at least one* of the two underlying algorithms remains secure.",
                                "It is only secure if both algorithms are secure.",
                                "It is not secure at all."
                            ],
                            "correct": 1,
                            "explanation": "The hybrid approach is a 'best of both worlds' strategy. It is secure against classical attackers (who can't break ECC) and against quantum attackers (who can't break the PQC algorithm). It is a robust way to manage the transition."
                        },
                        {
                            "id": 3,
                            "question": "What is the primary motivation for the ongoing transition to post-quantum cryptography?",
                            "options": [
                                "The existing algorithms are too slow.",
                                "The threat that a future, large-scale quantum computer will be able to break our current public-key cryptosystems.",
                                "The existing algorithms are too complicated.",
                                "The existing algorithms are running out of prime numbers."
                            ],
                            "correct": 1,
                            "explanation": "The entire field of PQC is driven by the need to prepare for the long-term threat of a quantum computer. The goal is to migrate our global infrastructure to new, quantum-resistant algorithms before that threat becomes a reality."
                        }
                    ]
                }
            }
        ]
    }


      // =====================================================
      // GLOBAL VARIABLES
      // =====================================================
      let currentUser = null;
      let currentLessonIndex = 0;
      let courseProgress = {};
      let userStats = {};
      let quizState = {
        currentQuestion: 0,
        answers: [],
        score: 0,
        isComplete: false,
        timeStarted: null,
        timeCompleted: null,
        currentQuestionIndex: 0,
      };

      // Enhanced session tracking
      let courseSession = {
        startTime: null,
        totalStudyTime: 0,
        lessonsStarted: 0,
        lessonsCompleted: 0,
        pageLoadTime: new Date(),
        lastActive: new Date(),
        interactions: 0,
        completedSections: [],
        totalTime: 0,
        interactionCount: 0,
        lastActivityTime: new Date(),
      };

      // Music Player Variables
      let audioPlayer = new Audio();

      // Achievement notification system
      let notificationQueue = [];
      let isShowingNotification = false;

      // =====================================================
      // INITIALIZATION
      // =====================================================
      document.addEventListener("DOMContentLoaded", async () => {
        try {
          showLoadingScreen();
          await checkAuth();

          if (currentUser) {
            // Initialize session tracking
            startCourseSession();

            // Load course data and progress
            await loadCourseData();
            await loadUserProfile();
            await loadProgress();

            // Initialize UI
            initializeEventListeners();
            renderSidebar();
            loadLesson(currentLessonIndex);

            // Initialize additional features
            initMusicPlayer();
            addMusicIndicator();
            initializeActivityTracking();

            hideLoadingScreen();
          } else {
            openAuthModal();
          }
        } catch (error) {
          console.error("Error initializing course:", error);
          hideLoadingScreen();
          showToast("Failed to initialize course system", "error");
        }
      });

      // =====================================================
      // AUTHENTICATION SYSTEM
      // =====================================================
      async function checkAuth() {
        try {
          const {
            data: { session },
            error,
          } = await supabase.auth.getSession();

          if (error) {
            console.error("Auth error:", error);
            currentUser = null;
            openAuthModal();
            return;
          }

          if (!session) {
            currentUser = null;
            openAuthModal();
            return;
          }

          currentUser = session.user;
          updateUIWithUser();
        } catch (error) {
          console.error("Error checking auth:", error);
          currentUser = null;
          openAuthModal();
        }
      }

      function updateUIWithUser() {
        if (!currentUser) return;

        const name =
          currentUser.user_metadata?.full_name ||
          currentUser.email.split("@")[0];
        const userElements = document.querySelectorAll("[data-user-name]");
        userElements.forEach((el) => (el.textContent = name));
      }

      // =====================================================
      // USER PROFILE & STATS MANAGEMENT
      // =====================================================
      async function loadUserProfile() {
        try {
          // 🔍 Step 1: Try to fetch existing profile
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("*")
            .eq("id", currentUser.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (!profile) {
            // 🆕 Step 2: Create new profile if missing
            await createUserProfile();
          } else {
            // ✅ Step 3: Use existing profile
            userStats = profile;
            await updateLastActivity();
          }
        } catch (error) {
          console.error("❌ Error loading user profile:", error);
          showToast("Failed to load user profile", "error");
        }
      }
      async function createUserProfile() {
        try {
          const newProfile = {
            id: currentUser.id,
            full_name: currentUser.user_metadata?.full_name || "",
            email: currentUser.email,
            level: "Script Kiddie",
            total_points: 0,
            completed_courses: 0,
            current_streak: 0,
            total_certificates: 0,
            total_achievements: 0,
            sections_visited: 0,
            bonus_points: 0,
            in_progress_courses: 0,
            settings_changed: 0,
            midnight_sessions: 0,
            early_sessions: 0,
            weekend_sessions: 0,
            last_activity: new Date().toISOString(),
            created_at: new Date().toISOString(),
          };

          const { error } = await supabase
            .from("profiles")
            .insert([newProfile]);

          if (!error) {
            userStats = newProfile;
            // Award first login achievement
            setTimeout(() => checkAndUnlockAchievement("first_login"), 1000);
          }
        } catch (error) {
          console.error("Error creating user profile:", error);
        }
      }

      async function updateLastActivity() {
        try {
          const now = new Date();

          // Update activity tracking
          courseSession.lastActivityTime = now;

          // Update database
          await supabase
            .from("profiles")
            .update({
              last_activity: now.toISOString(),
            })
            .eq("id", currentUser.id);

          // Check time-based achievements
          await checkTimeBasedAchievements(now);
        } catch (error) {
          console.error("Error updating last activity:", error);
        }
      }

      // =====================================================
      // COURSE SESSION MANAGEMENT
      // =====================================================
      function startCourseSession() {
        courseSession.startTime = new Date();
        courseSession.pageLoadTime = new Date();

        logUserActivity("course_session_start", {
          course_id: COURSE_DATA.id,
          course_title: COURSE_DATA.title,
          user_agent: navigator.userAgent,
          screen_resolution: `${screen.width}x${screen.height}`,
        });

        // Check daily streak
        checkDailyStreak();
      }

      function initializeActivityTracking() {
        // Track page focus/blur for accurate study time
        document.addEventListener("visibilitychange", handleVisibilityChange);

        // Track user interactions
        ["click", "keydown", "scroll", "mousemove"].forEach((event) => {
          document.addEventListener(event, trackUserInteraction, {
            passive: true,
          });
        });

        // Periodic activity updates
        setInterval(updateStudyTime, 60000); // Every minute

        // Save session data before page unload
        window.addEventListener("beforeunload", saveSessionData);
      }

      function handleVisibilityChange() {
        if (document.hidden) {
          courseSession.lastActivityTime = new Date();
        } else {
          // Page became visible again - update activity
          updateLastActivity();
        }
      }

      function trackUserInteraction() {
        courseSession.interactionCount++;
        courseSession.lastActivityTime = new Date();

        // Throttle activity updates
        if (courseSession.interactionCount % 50 === 0) {
          updateLastActivity();
        }
      }

      function updateStudyTime() {
        if (!courseSession.startTime || document.hidden) return;

        const now = new Date();
        const sessionDuration = now - courseSession.startTime;
        courseSession.totalStudyTime = Math.floor(sessionDuration / 1000 / 60); // in minutes

        // Update progress with study time
        saveProgress();
      }

      function saveSessionData() {
        if (!currentUser || !courseSession.startTime) return;

        const sessionData = {
          user_id: currentUser.id,
          course_id: COURSE_DATA.id,
          session_duration: courseSession.totalStudyTime,
          lessons_viewed: courseSession.lessonsStarted,
          lessons_completed: courseSession.lessonsCompleted,
          interactions: courseSession.interactionCount,
          session_date: courseSession.startTime.toISOString().split("T")[0],
        };

        // Store in localStorage as backup
        localStorage.setItem(
          "course_session_backup",
          JSON.stringify(sessionData)
        );

        // Try to save to database
        logUserActivity("course_session_end", sessionData);
      }

      // =====================================================
      // COURSE DATA & PROGRESS MANAGEMENT
      // =====================================================
      async function loadCourseData() {
        try {
          // Update course info in UI
          document.getElementById("courseTitle").textContent =
            COURSE_DATA.title;
          document.getElementById("totalLessons").textContent =
            COURSE_DATA.lessons.length;

          // Log course access
          logUserActivity("course_access", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
          });
        } catch (error) {
          console.error("Error loading course data:", error);
        }
      }

      async function loadProgress() {
        try {
          // Get existing progress from database
          const { data, error } = await supabase
            .from("course_progress")
            .select("*")
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (data) {
            courseProgress = JSON.parse(data.lesson_progress || "{}");
            currentLessonIndex = data.current_lesson || 0;

            // Update session tracking
            courseSession.lessonsStarted = Object.keys(courseProgress).length;
            courseSession.lessonsCompleted = Object.values(
              courseProgress
            ).filter((p) => p.completed).length;
          } else {
            // Initialize new progress
            courseProgress = {};
            currentLessonIndex = 0;
            await saveProgress();

            // Award first course start achievement
            await checkAndUnlockAchievement("first_course_start");
          }

          updateProgressDisplay();
        } catch (error) {
          console.error("Error loading progress:", error);
          showToast("Failed to load progress", "error");
        }
      }

      async function saveProgress() {
        try {
          if (!currentUser) return;

          const now = new Date();
          const progressData = {
            user_id: currentUser.id,
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            current_lesson: currentLessonIndex,
            lesson_progress: JSON.stringify(courseProgress),
            progress: calculateOverallProgress(),
            lessons_completed: getCompletedLessonsCount(),
            lessons_started: Object.keys(courseProgress).length,
            study_time_minutes: courseSession.totalStudyTime,
            last_accessed: now.toISOString(),
            updated_at: now.toISOString(),
          };

          // Upsert progress
          const { error } = await supabase
            .from("course_progress")
            .upsert([progressData]);

          if (error) throw error;

          // Update user stats
          await updateUserStats();

          updateProgressDisplay();
        } catch (error) {
          console.error("Error saving progress:", error);
          showToast("Failed to save progress", "error");
        }
      }

      async function updateUserStats() {
        try {
          // Get all course progress for this user
          const { data: allProgress, error } = await supabase
            .from("course_progress")
            .select("progress, course_id, study_time_minutes")
            .eq("user_id", currentUser.id);

          if (error) throw error;

          // Calculate stats
          const completedCourses =
            allProgress?.filter((p) => p.progress >= 100).length || 0;
          const inProgressCourses =
            allProgress?.filter((p) => p.progress > 0 && p.progress < 100)
              .length || 0;
          const totalStudyTime =
            allProgress?.reduce(
              (sum, p) => sum + (p.study_time_minutes || 0),
              0
            ) || 0;

          // Calculate points (500 per completed course + achievement points)
          const coursePoints = completedCourses * 500;
          const bonusPoints = userStats.bonus_points || 0;
          const totalPoints = coursePoints + bonusPoints;

          // Update profile
          const updateData = {
            completed_courses: completedCourses,
            in_progress_courses: inProgressCourses,
            total_points: totalPoints,
            total_study_time: totalStudyTime,
            last_activity: new Date().toISOString(),
          };

          const { error: updateError } = await supabase
            .from("profiles")
            .update(updateData)
            .eq("id", currentUser.id);

          if (updateError) throw updateError;

          // Update local stats
          Object.assign(userStats, updateData);
        } catch (error) {
          console.error("Error updating user stats:", error);
        }
      }

      function calculateOverallProgress() {
        const completedLessons = getCompletedLessonsCount();
        return Math.round(
          (completedLessons / COURSE_DATA.lessons.length) * 100
        );
      }

      function getCompletedLessonsCount() {
        return Object.values(courseProgress).filter(
          (lesson) => lesson.completed
        ).length;
      }

      function updateProgressDisplay() {
        const completedCount = getCompletedLessonsCount();
        const progressPercent = calculateOverallProgress();

        // Update UI elements
        const elements = {
          completedLessons: completedCount,
          courseProgressPercent: `${progressPercent}%`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });

        // Update progress bar
        const progressBar = document.getElementById("courseProgressFill");
        if (progressBar) progressBar.style.width = `${progressPercent}%`;
      }

      // =====================================================
      // LESSON MANAGEMENT
      // =====================================================
      function loadLesson(index) {
        if (index < 0 || index >= COURSE_DATA.lessons.length) return;

        const lesson = COURSE_DATA.lessons[index];
        currentLessonIndex = index;

        // Mark lesson as started and track activity
        if (!courseProgress[lesson.id]) {
          courseProgress[lesson.id] = {
            started: true,
            completed: false,
            startedAt: new Date().toISOString(),
            timeSpent: 0,
          };

          courseSession.lessonsStarted++;
          saveProgress();

          // Log lesson start
          logUserActivity("lesson_start", {
            lesson_id: lesson.id,
            lesson_title: lesson.title,
            lesson_index: index,
          });
        }

        // Update lesson start time for time tracking
        courseProgress[lesson.id].currentSessionStart = new Date();

        // Update sidebar and navigation
        renderSidebar();
        updateNavigationButtons();

        // Update header info
        updateLessonHeader(lesson, index);

        // Render lesson content
        renderLessonContent(lesson);

        // Smooth scroll and animations
        window.scrollTo({ top: 0, behavior: "smooth" });
        document.getElementById("contentBody").scrollTop = 0;

        const contentBody = document.getElementById("contentBody");
        contentBody.classList.add("fade-in");
        setTimeout(() => contentBody.classList.remove("fade-in"), 500);

        // Check lesson-based achievements
        checkLessonAchievements(index + 1);
      }

      function updateLessonHeader(lesson, index) {
        const elements = {
          currentLessonNumber: index + 1,
          currentLessonTitle: lesson.title,
          navInfo: `Lesson ${index + 1} of ${COURSE_DATA.lessons.length}`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });
      }

      function renderSidebar() {
        const lessonNav = document.getElementById("lessonNav");
        if (!lessonNav) return;

        lessonNav.innerHTML = "";

        COURSE_DATA.lessons.forEach((lesson, index) => {
          const lessonItem = document.createElement("div");
          lessonItem.className = "lesson-item";

          // Determine lesson status
          const lessonProgress = courseProgress[lesson.id];
          const isCompleted = lessonProgress?.completed || false;
          const isInProgress = lessonProgress?.started || false;
          const isLocked = !isCompleted && !canAccessLesson(index);
          const isActive = index === currentLessonIndex;

          // Apply status classes
          if (isCompleted) lessonItem.classList.add("completed");
          if (isLocked) lessonItem.classList.add("locked");
          if (isActive) lessonItem.classList.add("active");

          // Determine status display
          let statusClass = "not-started";
          let statusIcon = index + 1;

          if (isCompleted) {
            statusClass = "completed";
            statusIcon = "✓";
          } else if (isInProgress) {
            statusClass = "in-progress";
            statusIcon = "◐";
          }

          // Create lesson item HTML
          lessonItem.innerHTML = `
            <div class="lesson-status ${statusClass}">${statusIcon}</div>
            <div class="lesson-info">
                <div class="lesson-title">${lesson.title}</div>
                <div class="lesson-meta">
                    ${
                      isCompleted
                        ? "Completed"
                        : isInProgress
                        ? "In Progress"
                        : isLocked
                        ? "Locked"
                        : "Not Started"
                    }
                </div>
            </div>
            <div class="lesson-duration">${lesson.duration}</div>
        `;

          // Add click handler if not locked
          if (!isLocked) {
            lessonItem.addEventListener("click", () => {
              if (index !== currentLessonIndex) {
                // Track lesson time before switching
                trackLessonTime();

                currentLessonIndex = index;
                loadLesson(index);
                closeSidebar();
              }
            });
          }

          lessonNav.appendChild(lessonItem);
        });
      }

      function canAccessLesson(index) {
        if (index === 0) return true; // First lesson always accessible

        // Can access if previous lesson is completed
        const previousLessonId = COURSE_DATA.lessons[index - 1].id;
        return courseProgress[previousLessonId]?.completed || false;
      }

      function trackLessonTime() {
        const currentLesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonProgress = courseProgress[currentLesson.id];

        if (lessonProgress?.currentSessionStart) {
          const sessionTime = Math.floor(
            (new Date() - new Date(lessonProgress.currentSessionStart)) /
              1000 /
              60
          );
          lessonProgress.timeSpent =
            (lessonProgress.timeSpent || 0) + sessionTime;
          delete lessonProgress.currentSessionStart;
        }
      }

      // =====================================================
      // LESSON CONTENT RENDERING
      // =====================================================
      function renderLessonContent(lesson) {
        const contentContainer = document.getElementById("lessonContent");
        if (!contentContainer) return;

        let contentHTML = `
        <div class="content-section">
            <h2>Learning Objectives</h2>
            <ul>
                ${lesson.objectives.map((obj) => `<li>${obj}</li>`).join("")}
            </ul>
        </div>
        
        <div class="content-section">
            <h2>Overview</h2>
            <p>${lesson.content.overview}</p>
        </div>
    `;

        // Render content sections
        lesson.content.sections.forEach((section) => {
          contentHTML += `
            <div class="content-section">
                <h2>${section.title}</h2>
                ${section.content}
                ${
                  section.image
                    ? `<img src="${section.image}" alt="${section.title}" class="content-image" loading="lazy">`
                    : ""
                }
            </div>
        `;
        });

        // Render code examples
        if (
          lesson.content.codeExamples &&
          lesson.content.codeExamples.length > 0
        ) {
          contentHTML += `<div class="content-section"><h2>Code Examples</h2></div>`;

          lesson.content.codeExamples.forEach((example, index) => {
            const codeId = `code-${lesson.id}-${index}`;
            contentHTML += `
                <div class="code-section">
                    <div class="code-header">
                        <span class="code-title">${example.title}</span>
                        <button class="copy-btn" onclick="copyCode('${codeId}')">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <pre class="code-block"><code id="${codeId}" class="language-${
              example.language
            }">${escapeHtml(example.code)}</code></pre>
                </div>
            `;
          });
        }

        // Render quiz
        contentHTML += renderQuiz(lesson.quiz);

        contentContainer.innerHTML = contentHTML;

        // Highlight code syntax if Prism is available
        setTimeout(() => {
          if (window.Prism) {
            Prism.highlightAll();
          }
        }, 100);
      }

      // =====================================================
      // QUIZ SYSTEM
      // =====================================================
      function renderQuiz(quiz) {
        const currentLessonProgress =
          courseProgress[COURSE_DATA.lessons[currentLessonIndex].id];
        const isCompleted = currentLessonProgress?.completed || false;

        let quizHTML = `
        <div class="quiz-section" id="quizSection">
            <div class="quiz-header">
                <h2 class="quiz-title">
                    <i class="fas fa-clipboard-check"></i>
                    Knowledge Check
                </h2>
                <p class="quiz-info">
                    Complete this quiz with ${quiz.passingScore}% or higher to unlock the next lesson.
                </p>
            </div>
    `;

        if (isCompleted) {
          const savedScore = currentLessonProgress.quizScore || 0;
          quizHTML += `
            <div class="quiz-results show">
                <div class="quiz-score pass">${savedScore}%</div>
                <div class="quiz-message">
                    <strong>Lesson Completed!</strong><br>
                    You've successfully passed this lesson's quiz.
                </div>
            </div>
        `;
        } else {
          // Render quiz questions
          quiz.questions.forEach((question, qIndex) => {
            quizHTML += `
                <div class="quiz-question ${
                  qIndex === 0 ? "active" : ""
                }" data-question="${qIndex}">
                    <div class="question-header">
                        <span class="question-number">Question ${
                          qIndex + 1
                        }</span>
                        <span class="question-progress">${qIndex + 1}/${
              quiz.questions.length
            }</span>
                    </div>
                    <div class="question-text">${question.question}</div>
                    <div class="question-options">
                        ${question.options
                          .map(
                            (option, oIndex) => `
                            <div class="option" data-option="${oIndex}" onclick="selectOption(${qIndex}, ${oIndex})">
                                <span class="option-letter">${String.fromCharCode(
                                  65 + oIndex
                                )}</span>
                                <span class="option-text">${option}</span>
                            </div>
                        `
                          )
                          .join("")}
                    </div>
                </div>
            `;
          });

          quizHTML += `
            <div class="quiz-controls">
                <button class="btn btn-secondary" id="prevQuestionBtn" onclick="previousQuestion()" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <div>
                    <button class="btn btn-secondary" id="nextQuestionBtn" onclick="nextQuestion()" disabled>
                        Next
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <button class="btn btn-primary" id="submitQuizBtn" onclick="submitQuiz()" style="display: none;">
                        <i class="fas fa-check"></i>
                        Submit Quiz
                    </button>
                </div>
            </div>

            <div class="quiz-results" id="quizResults">
                <div class="quiz-score" id="quizScore">0%</div>
                <div class="quiz-message" id="quizMessage"></div>
                <div class="quiz-actions">
                    <button class="btn btn-primary" id="continueBtn" onclick="completeLesson()" style="display: none;">
                        <i class="fas fa-arrow-right"></i>
                        Continue to Next Lesson
                    </button>
                    <button class="btn btn-secondary" onclick="retakeQuiz()">
                        <i class="fas fa-redo"></i>
                        Retake Quiz
                    </button>
                </div>
            </div>
        `;
        }

        quizHTML += "</div>";
        return quizHTML;
      }

      // Quiz interaction functions
      function selectOption(questionIndex, optionIndex) {
        // Clear previous selections
        document
          .querySelectorAll(`[data-question="${questionIndex}"] .option`)
          .forEach((opt) => {
            opt.classList.remove("selected");
          });

        // Select current option
        const selectedOption = document.querySelector(
          `[data-question="${questionIndex}"] [data-option="${optionIndex}"]`
        );
        selectedOption.classList.add("selected");

        // Store answer
        quizState.answers[questionIndex] = optionIndex;

        // Update navigation
        const isLastQuestion =
          questionIndex ===
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length - 1;
        if (isLastQuestion) {
          document.getElementById("submitQuizBtn").style.display =
            "inline-flex";
          document.getElementById("nextQuestionBtn").style.display = "none";
        } else {
          document.getElementById("nextQuestionBtn").disabled = false;
        }
      }

      function nextQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const nextQuestionEl = currentQuestionEl.nextElementSibling;

        if (
          nextQuestionEl &&
          nextQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          nextQuestionEl.classList.add("active");
          quizState.currentQuestion++;
          updateQuizNavigation();
        }
      }

      function previousQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const prevQuestionEl = currentQuestionEl.previousElementSibling;

        if (
          prevQuestionEl &&
          prevQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          prevQuestionEl.classList.add("active");
          quizState.currentQuestion--;
          updateQuizNavigation();
        }
      }

      function updateQuizNavigation() {
        const totalQuestions =
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length;
        const prevBtn = document.getElementById("prevQuestionBtn");
        const nextBtn = document.getElementById("nextQuestionBtn");
        const submitBtn = document.getElementById("submitQuizBtn");

        prevBtn.disabled = quizState.currentQuestion === 0;

        const hasAnswer =
          quizState.answers[quizState.currentQuestion] !== undefined;
        const isLastQuestion = quizState.currentQuestion === totalQuestions - 1;

        if (isLastQuestion) {
          nextBtn.style.display = "none";
          submitBtn.style.display = hasAnswer ? "inline-flex" : "none";
        } else {
          nextBtn.style.display = "inline-flex";
          nextBtn.disabled = !hasAnswer;
          submitBtn.style.display = "none";
        }
      }

      async function submitQuiz() {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const quiz = lesson.quiz;
        let correctAnswers = 0;

        // Hide questions and controls
        document
          .querySelectorAll(".quiz-question")
          .forEach((q) => (q.style.display = "none"));
        document.querySelector(".quiz-controls").style.display = "none";

        // Calculate score and highlight answers
        quiz.questions.forEach((question, index) => {
          const userAnswer = quizState.answers[index];
          const correctAnswer = question.correct;
          const isCorrect = userAnswer === correctAnswer;

          if (isCorrect) correctAnswers++;

          // Highlight answers
          const questionEl = document.querySelector(
            `[data-question="${index}"]`
          );
          const options = questionEl.querySelectorAll(".option");

          options[correctAnswer].classList.add("correct");
          if (userAnswer !== correctAnswer && userAnswer !== undefined) {
            options[userAnswer].classList.add("incorrect");
          }
        });

        const score = Math.round(
          (correctAnswers / quiz.questions.length) * 100
        );
        const passed = score >= quiz.passingScore;

        // Update quiz results UI
        const quizScore = document.getElementById("quizScore");
        const quizMessage = document.getElementById("quizMessage");
        const quizActions = document.querySelector(".quiz-actions");

        quizScore.textContent = `${score}%`;
        quizScore.className = `quiz-score ${passed ? "pass" : "fail"}`;

        if (passed) {
          quizMessage.innerHTML = `
            <strong>Congratulations!</strong><br>
            You passed with ${score}%. You can now proceed to the next lesson.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-primary" onclick="completeLesson()">
                <i class="fas fa-arrow-right"></i>
                Continue to Next Lesson
            </button>
        `;

          // Mark lesson as completed
          await markLessonComplete(score);
        } else {
          quizMessage.innerHTML = `
            <strong>Not quite there yet.</strong><br>
            You scored ${score}%. You need ${quiz.passingScore}% to pass. Review the material and try again.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-secondary" onclick="retakeQuiz()">
                <i class="fas fa-redo"></i>
                Retake Quiz
            </button>
        `;
        }

        document.getElementById("quizResults").classList.add("show");

        // Log quiz completion
        logUserActivity("quiz_completed", {
          lesson_id: lesson.id,
          lesson_title: lesson.title,
          score: score,
          passed: passed,
          attempts: (courseProgress[lesson.id]?.quizAttempts || 0) + 1,
        });

        // Scroll to results
        document
          .getElementById("quizResults")
          .scrollIntoView({ behavior: "smooth" });
      }

      function retakeQuiz() {
        // Reset quiz state
        quizState = {
          currentQuestion: 0,
          answers: [],
          score: 0,
          isComplete: false,
        };

        // Track quiz retry
        const lessonId = COURSE_DATA.lessons[currentLessonIndex].id;
        if (!courseProgress[lessonId]) courseProgress[lessonId] = {};
        courseProgress[lessonId].quizAttempts =
          (courseProgress[lessonId].quizAttempts || 0) + 1;

        // Reload lesson content
        loadLesson(currentLessonIndex);

        // Scroll to quiz
        setTimeout(() => {
          document
            .getElementById("quizSection")
            .scrollIntoView({ behavior: "smooth" });
        }, 500);
      }

      async function markLessonComplete(score) {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonId = lesson.id;

        // Track lesson completion time
        trackLessonTime();

        // Update lesson progress
        courseProgress[lessonId] = {
          ...courseProgress[lessonId],
          completed: true,
          quizScore: score,
          completedAt: new Date().toISOString(),
          finalScore: score,
        };

        // Update session tracking
        courseSession.lessonsCompleted++;

        // Save progress to database
        await saveProgress();

        // Update UI
        renderSidebar();
        updateNavigationButtons();

        // Check various achievements
        await checkLessonCompletionAchievements();
        await checkPerfectScoreAchievements(score);
        await checkStudyTimeAchievements();

        // Log lesson completion
        logUserActivity("lesson_completed", {
          lesson_id: lessonId,
          lesson_title: lesson.title,
          final_score: score,
          time_spent: courseProgress[lessonId].timeSpent || 0,
          lesson_number: currentLessonIndex + 1,
        });

        showToast("Lesson completed successfully!", "success");
      }

      async function completeLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          // Move to next lesson
          currentLessonIndex++;
          loadLesson(currentLessonIndex);
        } else {
          // Course completion
          await completeCourse();
        }
      }

      async function completeCourse() {
        try {
          const completionTime = courseSession.totalStudyTime;

          // Update course progress to 100% completed
          await supabase
            .from("course_progress")
            .update({
              progress: 100,
              completed_at: new Date().toISOString(),
              completion_time_minutes: completionTime,
            })
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Award course completion achievements
          await checkAndUnlockAchievement("course_completion_1");
          await checkSpeedCompletionAchievements(completionTime);
          await checkCourseStreakAchievements();

          // Update user stats
          await updateUserStats();

          // Show completion message
          showToast(
            "Congratulations! Course completed successfully!",
            "certificate"
          );

          // Log course completion
          logUserActivity("course_completed", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            completion_time_minutes: completionTime,
            total_lessons: COURSE_DATA.lessons.length,
            average_quiz_score: calculateAverageQuizScore(),
          });

          // Redirect to dashboard after delay
          setTimeout(() => {
            window.location.href = "/dashboard.html";
          }, 3000);
        } catch (error) {
          console.error("Error completing course:", error);
          showToast("Error marking course as complete", "error");
        }
      }

      // =====================================================
      // ACHIEVEMENT INTEGRATION SYSTEM
      // =====================================================
      async function checkAndUnlockAchievement(
        achievementId,
        skipNotification = false
      ) {
        try {
          // Prevent duplicate checks
          const cacheKey = `achievement_${achievementId}_${currentUser.id}`;
          if (sessionStorage.getItem(cacheKey)) return false;

          // Check if already unlocked
          const { data: existing, error } = await supabase
            .from("user_achievements")
            .select("id")
            .eq("user_id", currentUser.id)
            .eq("achievement_id", achievementId)
            .single();

          if (existing) {
            sessionStorage.setItem(cacheKey, "true");
            return false;
          }

          // Award achievement
          const achievementData = {
            user_id: currentUser.id,
            achievement_id: achievementId,
            unlocked_at: new Date().toISOString(),
            points_awarded: getAchievementPoints(achievementId),
            context: "course_system",
          };

          const { data, error: insertError } = await supabase
            .from("user_achievements")
            .insert([achievementData])
            .select()
            .single();

          if (insertError) {
            if (insertError.code === "23505") return false; // Already exists
            throw insertError;
          }

          // Update user points
          await supabase.rpc('increment_user_stats', {
  user_id_param: currentUser.id,
  points_to_add: achievementData.points_awarded,
  achievements_to_add: 1
});

          // Cache and queue notification
          sessionStorage.setItem(cacheKey, "true");

          if (!skipNotification) {
            queueAchievementNotification({
              id: achievementId,
              name: getAchievementName(achievementId),
              description: getAchievementDescription(achievementId),
              points: achievementData.points_awarded,
              rarity: getAchievementRarity(achievementId),
              icon: getAchievementIcon(achievementId),
            });
          }

          return true;
        } catch (error) {
          console.error("Error unlocking achievement:", error);
          return false;
        }
      }

      // Helper functions for achievement data (replace with your actual achievement definitions)
      function getAchievementPoints(id) {
        const pointsMap = {
          first_course_start: 75,
          first_lesson: 100,
          course_completion_1: 500,
          perfect_score: 250,
          speed_demon: 750,
          marathon_learner: 500,
          night_owl: 200,
          early_bird: 200,
          weekend_warrior: 150,
          // Add more as needed
        };
        return pointsMap[id] || 100;
      }

      function getAchievementName(id) {
        const nameMap = {
          first_course_start: "Learning Initiated",
          first_lesson: "First Steps",
          course_completion_1: "Course Conqueror",
          perfect_score: "Perfectionist",
          speed_demon: "Speed Demon",
          // Add more as needed
        };
        return nameMap[id] || "Achievement Unlocked";
      }

      function getAchievementDescription(id) {
        const descMap = {
          first_course_start: "Start your first cybersecurity course",
          first_lesson: "Complete your first lesson",
          course_completion_1: "Complete your first course",
          perfect_score: "Score 100% on any quiz",
          speed_demon: "Complete a course in under 2 hours",
          // Add more as needed
        };
        return descMap[id] || "Achievement description";
      }

      function getAchievementRarity(id) {
        const rarityMap = {
          first_course_start: "common",
          first_lesson: "bronze",
          course_completion_1: "silver",
          perfect_score: "gold",
          speed_demon: "legendary",
          // Add more as needed
        };
        return rarityMap[id] || "common";
      }

      function getAchievementIcon(id) {
        const iconMap = {
          first_course_start: "fas fa-play",
          first_lesson: "fas fa-baby",
          course_completion_1: "fas fa-trophy",
          perfect_score: "fas fa-star",
          speed_demon: "fas fa-rocket",
          // Add more as needed
        };
        return iconMap[id] || "fas fa-award";
      }

      async function checkLessonAchievements(lessonNumber) {
        if (lessonNumber === 1) {
          await checkAndUnlockAchievement("first_lesson");
        }

        // Check if user has completed multiple lessons in one day
        const today = new Date().toISOString().split("T")[0];
        const todayCompletions = Object.values(courseProgress).filter(
          (p) => p.completed && p.completedAt?.startsWith(today)
        ).length;

        if (todayCompletions >= 3) {
          await checkAndUnlockAchievement("lesson_marathon");
        }
      }

      async function checkLessonCompletionAchievements() {
        const completedCount = getCompletedLessonsCount();

        // Lesson-based achievements
        const lessonMilestones = [1, 5, 10, 25, 50, 100];
        for (const milestone of lessonMilestones) {
          if (completedCount >= milestone) {
            await checkAndUnlockAchievement(`lessons_${milestone}`);
          }
        }

        // Course completion achievements
        if (completedCount === COURSE_DATA.lessons.length) {
          await checkAndUnlockAchievement("course_completion_1");

          // Check for additional course completion achievements
          const { data: allCourses } = await supabase
            .from("course_progress")
            .select("course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100);

          const totalCompleted = allCourses?.length || 0;

          const courseMilestones = [1, 5, 10, 25];
          for (const milestone of courseMilestones) {
            if (totalCompleted >= milestone) {
              await checkAndUnlockAchievement(`course_completion_${milestone}`);
            }
          }
        }
      }

      async function checkPerfectScoreAchievements(score) {
        if (score === 100) {
          await checkAndUnlockAchievement("perfect_score");

          // Check for consecutive perfect scores
          const recentScores = Object.values(courseProgress)
            .filter((p) => p.completed && p.quizScore)
            .slice(-5) // Last 5 completed
            .map((p) => p.quizScore);

          if (
            recentScores.length >= 3 &&
            recentScores.every((s) => s === 100)
          ) {
            await checkAndUnlockAchievement("perfectionist_streak");
          }
        }
      }

      async function checkSpeedCompletionAchievements(completionTime) {
        // Speed demon: Complete course in under 2 hours (120 minutes)
        if (completionTime <= 120) {
          await checkAndUnlockAchievement("speed_demon");
        }

        // Quick learner: Complete course in under 4 hours (240 minutes)
        if (completionTime <= 240) {
          await checkAndUnlockAchievement("quick_learner");
        }
      }

      async function checkStudyTimeAchievements() {
        const totalTime = courseSession.totalStudyTime;

        // Marathon learner: Study for 8+ hours in a course session
        if (totalTime >= 480) {
          // 8 hours
          await checkAndUnlockAchievement("marathon_learner");
        }

        // Dedicated learner: Study for 4+ hours
        if (totalTime >= 240) {
          // 4 hours
          await checkAndUnlockAchievement("dedicated_learner");
        }
      }

      async function checkCourseStreakAchievements() {
        try {
          // Check for consecutive course completions
          const { data: recentCourses, error } = await supabase
            .from("course_progress")
            .select("completed_at, course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100)
            .order("completed_at", { ascending: false })
            .limit(10);

          if (error || !recentCourses) return;

          // Check for courses completed on consecutive days
          let consecutiveDays = 1;
          for (let i = 1; i < recentCourses.length; i++) {
            const prevDate = new Date(
              recentCourses[i - 1].completed_at
            ).toDateString();
            const currentDate = new Date(
              recentCourses[i].completed_at
            ).toDateString();
            const dayDiff =
              Math.abs(new Date(prevDate) - new Date(currentDate)) /
              (1000 * 60 * 60 * 24);

            if (dayDiff <= 1) {
              consecutiveDays++;
            } else {
              break;
            }
          }

          if (consecutiveDays >= 3) {
            await checkAndUnlockAchievement("learning_streak");
          }
        } catch (error) {
          console.error("Error checking course streak achievements:", error);
        }
      }

      // =====================================================
      // TIME-BASED ACHIEVEMENTS
      // =====================================================
      async function checkTimeBasedAchievements(timestamp) {
        const hour = timestamp.getHours();
        const dayOfWeek = timestamp.getDay();

        // Night owl (after midnight, before 6 AM)
        if (hour >= 0 && hour < 6) {
          await incrementTimeBasedCounter("midnight_sessions", "night_owl");
        }

        // Early bird (4 AM to 6 AM)
        if (hour >= 4 && hour < 6) {
          await incrementTimeBasedCounter("early_sessions", "early_bird");
        }

        // Weekend warrior (Saturday = 6, Sunday = 0)
        if (dayOfWeek === 0 || dayOfWeek === 6) {
          await incrementTimeBasedCounter(
            "weekend_sessions",
            "weekend_warrior"
          );
        }
      }

      async function incrementTimeBasedCounter(counterType, achievementId) {
        try {
          const dateStr = new Date().toISOString().split("T")[0];
          const cacheKey = `${counterType}_${currentUser.id}_${dateStr}`;

          // Prevent multiple increments per day
          if (sessionStorage.getItem(cacheKey)) return;

          // Update counter
        await supabase.rpc('increment_profile_counter', {
  user_id_param: currentUser.id,
  counter_field: counterType,
  increment_value: 1
});

          // Cache to prevent double counting
          sessionStorage.setItem(cacheKey, "true");

          // Check related achievement
          if (achievementId) {
            await checkAndUnlockAchievement(achievementId, true);
          }
        } catch (error) {
          console.error(`Error incrementing ${counterType}:`, error);
        }
      }

      async function checkDailyStreak() {
        try {
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("last_activity, current_streak, last_streak_date")
            .eq("id", currentUser.id)
            .single();

          if (error) throw error;

          const now = new Date();
          const today = now.toDateString();
          const lastActivity = profile.last_activity
            ? new Date(profile.last_activity)
            : null;
          const lastStreakDate = profile.last_streak_date
            ? new Date(profile.last_streak_date).toDateString()
            : null;

          let newStreak = profile.current_streak || 0;
          let shouldUpdateStreak = false;

          if (!lastActivity) {
            // First time user
            newStreak = 1;
            shouldUpdateStreak = true;
          } else {
            const daysSinceLastActivity = Math.floor(
              (now - lastActivity) / (1000 * 60 * 60 * 24)
            );

            if (lastStreakDate === today) {
              // Already counted today's streak
              return newStreak;
            } else if (
              daysSinceLastActivity === 1 ||
              (daysSinceLastActivity === 0 && lastStreakDate !== today)
            ) {
              // Consecutive day or same day but not counted yet
              newStreak += 1;
              shouldUpdateStreak = true;
            } else if (daysSinceLastActivity > 1) {
              // Streak broken
              newStreak = 1;
              shouldUpdateStreak = true;
            }
          }

          if (shouldUpdateStreak) {
            await supabase
              .from("profiles")
              .update({
                current_streak: newStreak,
                last_activity: now.toISOString(),
                last_streak_date: now.toISOString(),
              })
              .eq("id", currentUser.id);

            userStats.current_streak = newStreak;

            showToast(`Daily streak: ${newStreak} days!`, "success");
            await checkStreakAchievements(newStreak);
          }

          return newStreak;
        } catch (error) {
          console.error("Error checking daily streak:", error);
          return 0;
        }
      }

      async function checkStreakAchievements(currentStreak) {
        const streakMilestones = [3, 7, 14, 30, 100, 365];

        for (const milestone of streakMilestones) {
          if (currentStreak >= milestone) {
            await checkAndUnlockAchievement(`streak_${milestone}`);
          }
        }
      }

      // =====================================================
      // USER ACTIVITY LOGGING
      // =====================================================
      async function logUserActivity(activityType, metadata = {}) {
        try {
          const now = new Date();

          const activityData = {
            user_id: currentUser.id,
            activity_type: activityType,
            timestamp: now.toISOString(),
            course_id: COURSE_DATA.id,
            lesson_index: currentLessonIndex,
            session_duration: courseSession.totalStudyTime,
            metadata: JSON.stringify(metadata),
            created_at: now.toISOString(),
          };

          // Try to log to activities table
          const { error } = await supabase
            .from("user_activities")
            .insert([activityData]);

          if (error && error.code !== "42P01") {
            console.warn("Activity logging failed:", error.message);
          }

          // Always update last activity in profile
          await supabase
            .from("profiles")
            .update({ last_activity: now.toISOString() })
            .eq("id", currentUser.id);
        } catch (error) {
          console.error("Error logging user activity:", error);
        }
      }

      // =====================================================
      // NAVIGATION SYSTEM
      // =====================================================
      function updateNavigationButtons() {
        const prevBtn = document.getElementById("prevLessonBtn");
        const nextBtn = document.getElementById("nextLessonBtn");

        if (!prevBtn || !nextBtn) return;

        // Previous button
        prevBtn.disabled = currentLessonIndex === 0;

        // Next button logic
        const isLastLesson =
          currentLessonIndex === COURSE_DATA.lessons.length - 1;
        const canGoNext =
          currentLessonIndex < COURSE_DATA.lessons.length - 1 &&
          canAccessLesson(currentLessonIndex + 1);

        if (isLastLesson) {
          const isCurrentCompleted =
            courseProgress[COURSE_DATA.lessons[currentLessonIndex].id]
              ?.completed;
          nextBtn.disabled = !isCurrentCompleted;
          nextBtn.innerHTML = '<i class="fas fa-trophy"></i> Complete Course';
        } else {
          nextBtn.disabled = !canGoNext;
          nextBtn.innerHTML = 'Next <i class="fas fa-chevron-right"></i>';
        }
      }

      // Navigation button event handlers
      function goToPreviousLesson() {
        if (currentLessonIndex > 0) {
          trackLessonTime(); // Track time spent on current lesson
          currentLessonIndex--;
          loadLesson(currentLessonIndex);
        }
      }

      function goToNextLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          const canGoNext = canAccessLesson(currentLessonIndex + 1);
          if (canGoNext) {
            trackLessonTime();
            currentLessonIndex++;
            loadLesson(currentLessonIndex);
          } else {
            showToast("Complete the current lesson quiz to proceed", "warning");
          }
        } else {
          // Complete course
          completeCourse();
        }
      }

      // =====================================================
      // SIDEBAR FUNCTIONS
      // =====================================================
      function toggleSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.toggle("open");
        if (overlay) overlay.classList.toggle("active");
      }

      function closeSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.remove("open");
        if (overlay) overlay.classList.remove("active");
      }

      // =====================================================
      // ACHIEVEMENT NOTIFICATION SYSTEM
      // =====================================================
      function queueAchievementNotification(achievement) {
        notificationQueue.push(achievement);
        processNotificationQueue();
      }

      function processNotificationQueue() {
        if (isShowingNotification || notificationQueue.length === 0) return;

        isShowingNotification = true;
        const achievement = notificationQueue.shift();
        showAchievementNotification(achievement);

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          isShowingNotification = false;
          processNotificationQueue();
        }, duration + 500);
      }

      function showAchievementNotification(achievement) {
        const notification = document.getElementById("achievementNotification");
        if (!notification) return;

        const icon = document.getElementById("notificationIcon");
        const title = document.getElementById("notificationTitle");
        const description = document.getElementById("notificationDescription");
        const points = document.getElementById("notificationPoints");

        if (icon) {
          icon.innerHTML = `<i class="${achievement.icon}"></i>`;
          icon.className = `notification-icon ${achievement.rarity}`;
        }
        if (title) title.textContent = achievement.name;
        if (description) description.textContent = achievement.description;
        if (points) points.textContent = `+${achievement.points} Points`;

        notification.className = `achievement-notification ${achievement.rarity}`;
        notification.classList.add("show");

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          notification.classList.remove("show");
        }, duration);
      }

      // =====================================================
      // UTILITY FUNCTIONS
      // =====================================================
      function calculateAverageQuizScore() {
        const scores = Object.values(courseProgress)
          .filter((p) => p.completed && p.quizScore)
          .map((p) => p.quizScore);

        if (scores.length === 0) return 0;
        return Math.round(
          scores.reduce((sum, score) => sum + score, 0) / scores.length
        );
      }

      async function resetProgress() {
        if (
          !confirm(
            "Are you sure you want to reset your progress? This action cannot be undone."
          )
        ) {
          return;
        }

        try {
          // Track lesson time before reset
          trackLessonTime();

          // Reset local state
          courseProgress = {};
          currentLessonIndex = 0;
          courseSession = {
            startTime: new Date(),
            totalStudyTime: 0,
            lessonsStarted: 0,
            lessonsCompleted: 0,
            pageLoadTime: new Date(),
            interactionCount: 0,
            lastActivityTime: new Date(),
          };

          // Delete from database
          await supabase
            .from("course_progress")
            .delete()
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Log reset activity
          logUserActivity("progress_reset", {
            course_id: COURSE_DATA.id,
            reset_reason: "manual",
          });

          // Reinitialize
          await saveProgress();
          renderSidebar();
          loadLesson(0);

          showToast("Progress reset successfully", "success");
        } catch (error) {
          console.error("Error resetting progress:", error);
          showToast("Failed to reset progress", "error");
        }
      }

      function copyCode(codeId) {
        const codeElement = document.getElementById(codeId);
        if (!codeElement) return;

        const text = codeElement.textContent;

        navigator.clipboard
          .writeText(text)
          .then(() => {
            showToast("Code copied to clipboard!", "success");

            // Track code copy for achievements
            logUserActivity("code_copied", {
              code_section: codeId,
              lesson_id: COURSE_DATA.lessons[currentLessonIndex].id,
            });
          })
          .catch((err) => {
            console.error("Failed to copy code:", err);
            showToast("Failed to copy code", "error");

            // Fallback for older browsers
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            try {
              document.execCommand("copy");
              showToast("Code copied to clipboard!", "success");
            } catch (fallbackError) {
              showToast(
                "Copy failed - please select and copy manually",
                "error"
              );
            }
            document.body.removeChild(textArea);
          });
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // =====================================================
      // UI FEEDBACK SYSTEMS
      // =====================================================
      function showToast(message, type = "success") {
        const toast = document.getElementById("toast");
        const messageEl = document.getElementById("toastMessage");

        if (!toast || !messageEl) {
          console.log(`Toast: ${message} (${type})`);
          return;
        }

        messageEl.textContent = message;
        toast.className = `toast ${type} show`;

        setTimeout(() => {
          toast.classList.remove("show");
        }, 4000);
      }

      function showLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) loadingScreen.classList.remove("hidden");
      }

      function hideLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) {
          setTimeout(() => {
            loadingScreen.classList.add("hidden");
          }, 1000);
        }
      }

      // =====================================================
      // MUSIC PLAYER INTEGRATION
      // =====================================================
      function initMusicPlayer() {
        const btnText = document.getElementById("music-button-text");
        const icon = document.getElementById("music-icon");
        const dropdown = document.getElementById("music-dropdown-content");

        if (!btnText || !icon || !dropdown) return;

        function setUI(state) {
          btnText.textContent =
            state === "Playing" ? "PAUSE MUSIC" : "STUDY MUSIC";
          icon.className =
            state === "Playing"
              ? "fa-solid fa-circle-pause"
              : "fa-solid fa-music";
        }

        // Load saved music state
        const savedSrc = localStorage.getItem("cybersec_music_src");
        const savedTime = parseFloat(
          localStorage.getItem("cybersec_music_time") || 0
        );

        if (savedSrc) {
          audioPlayer.src = savedSrc;
          audioPlayer.currentTime = savedTime;
          audioPlayer
            .play()
            .then(() => setUI("Playing"))
            .catch(() => setUI("Stopped"));
        }

        // Music button click handler
        document
          .getElementById("music-dropdown")
          .querySelector("button")
          .addEventListener("click", (e) => {
            e.stopPropagation();
            dropdown.style.display =
              dropdown.style.display === "block" ? "none" : "block";

            if (audioPlayer.src && !audioPlayer.paused) {
              audioPlayer.pause();
              setUI("Stopped");
            } else if (audioPlayer.src) {
              audioPlayer.play().then(() => setUI("Playing"));
            }
          });

        // Music selection handlers
        dropdown.querySelectorAll("a[data-src]").forEach((link) => {
          link.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.src = link.dataset.src;
            audioPlayer.play().then(() => setUI("Playing"));
            localStorage.setItem("cybersec_music_src", link.dataset.src);
            dropdown.style.display = "none";
          });
        });

        // Stop music handler
        const stopLink = document.getElementById("stop-music-link");
        if (stopLink) {
          stopLink.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            audioPlayer.removeAttribute("src");
            setUI("Stopped");
            localStorage.removeItem("cybersec_music_src");
            localStorage.removeItem("cybersec_music_time");
            dropdown.style.display = "none";
          });
        }

        // Save music state before page unload
        window.addEventListener("beforeunload", () => {
          if (!audioPlayer.paused && audioPlayer.src) {
            localStorage.setItem("cybersec_music_src", audioPlayer.src);
            localStorage.setItem(
              "cybersec_music_time",
              audioPlayer.currentTime
            );
          }
        });

        // Close dropdown when clicking outside
        window.addEventListener("click", (e) => {
          if (!e.target.closest("#music-dropdown")) {
            dropdown.style.display = "none";
          }
        });
      }

      // Show initial music indicator
      function addMusicIndicator() {
        const musicBtn = document.querySelector("#music-dropdown");
        if (musicBtn) {
          const indicator = document.createElement("div");
          indicator.className = "music-indicator";
          indicator.innerHTML = `<i class="fa-solid fa-music"></i> Try Study Music!`;

          musicBtn.style.position = "relative";
          musicBtn.appendChild(indicator);

          setTimeout(() => indicator.remove(), 3000);
        }
      }

      // Initialize Event Listeners
      function initializeEventListeners() {
        // Navigation buttons
        document
          .getElementById("prevLessonBtn")
          ?.addEventListener("click", goToPreviousLesson);
        document
          .getElementById("nextLessonBtn")
          ?.addEventListener("click", goToNextLesson);

        // Reset progress button
        document
          .getElementById("resetProgressBtn")
          ?.addEventListener("click", resetProgress);

        // Mobile menu toggle
        document
          .getElementById("menuToggle")
          ?.addEventListener("click", toggleSidebar);
        document
          .getElementById("sidebarOverlay")
          ?.addEventListener("click", closeSidebar);

        // Keyboard shortcuts
        document.addEventListener("keydown", handleKeyboardShortcuts);

        // Window resize handler
        window.addEventListener("resize", handleWindowResize);

        // Content interaction tracking
        document.getElementById("contentBody")?.addEventListener(
          "scroll",
          debounce(() => {
            trackUserInteraction();
          }, 1000)
        );
      }

      // Keyboard Shortcuts
      function handleKeyboardShortcuts(e) {
        if (document.querySelector(".quiz-question.active")) return;

        if (e.key === "ArrowLeft" && e.ctrlKey) {
          e.preventDefault();
          goToPreviousLesson();
        } else if (e.key === "ArrowRight" && e.ctrlKey) {
          e.preventDefault();
          goToNextLesson();
        }
      }

      // Window Resize Handler
      function handleWindowResize() {
        if (window.innerWidth > 768) {
          closeSidebar();
        }
      }

      // Debounce Helper
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Initialize responsive behavior
      if (window.innerWidth <= 768) {
        document.getElementById("menuToggle").style.display = "inline-flex";
      }

      // Auto-save progress periodically
      setInterval(async () => {
        if (currentUser && Object.keys(courseProgress).length > 0) {
          await saveProgress();
        }
      }, 60000); // Save every minute

      // System initialization logging
      console.log("CyberSec Academy Course System Initialized");
      console.log("Current Course:", COURSE_DATA.title);
      console.log("Total Lessons:", COURSE_DATA.lessons.length);

      // Google OAuth Integration
      const googleBtn = document.querySelector(".btn-google");
      if (googleBtn) {
        googleBtn.addEventListener("click", async () => {
          const { data, error } = await supabase.auth.signInWithOAuth({
            provider: "google",
            options: {
              redirectTo:
                window.location.origin +
                "/courses/elliptic-curve-cryptography-complete-course.html",
            },
          });

          if (error) {
            console.error("Google login error:", error.message);
            showToast("Google login failed: " + error.message, "error");
          }
        });
      }

      // Check for existing session
      supabase.auth.getSession().then(({ data }) => {
        if (data.session) {
          console.log("User already logged in:", data.session.user);
          currentUser = data.session.user;
          startCourseSession();
        }
      });

      // Add missing auth modal functions
      function openAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "flex";
        }
      }

      function closeAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Add auth tab switching functionality
      document.getElementById("tabSignIn")?.addEventListener("click", () => {
        document.getElementById("tabSignIn").classList.add("active");
        document.getElementById("tabSignUp").classList.remove("active");
        document.getElementById("signInForm").style.display = "block";
        document.getElementById("signUpForm").style.display = "none";
      });

      document.getElementById("tabSignUp")?.addEventListener("click", () => {
        document.getElementById("tabSignUp").classList.add("active");
        document.getElementById("tabSignIn").classList.remove("active");
        document.getElementById("signUpForm").style.display = "block";
        document.getElementById("signInForm").style.display = "none";
      });

      document
        .getElementById("closeAuthModal")
        ?.addEventListener("click", closeAuthModal);

      // Improved error handling for auth session
      supabase.auth.onAuthStateChange((event, session) => {
        if (event === "SIGNED_IN") {
          currentUser = session.user;
          closeAuthModal();
          startCourseSession();
        } else if (event === "SIGNED_OUT") {
          currentUser = null;
          openAuthModal();
        }
      });

      // Add form submission handlers
      document
        .getElementById("emailSignInForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signInEmail").value;
          const password = document.getElementById("signInPassword").value;

          try {
            const { data, error } = await supabase.auth.signInWithPassword({
              email,
              password,
            });

            if (error) throw error;

            closeAuthModal();
          } catch (error) {
            showToast(error.message, "error");
          }
        });

      document
        .getElementById("emailSignUpForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signUpEmail").value;
          const password = document.getElementById("signUpPassword").value;
          const name = document.getElementById("signUpName").value;

          try {
            const { data, error } = await supabase.auth.signUp({
              email,
              password,
              options: {
                data: {
                  full_name: name,
                },
              },
            });

            if (error) throw error;

            showToast(
              "Account created successfully! Please check your email.",
              "success"
            );
          } catch (error) {
            showToast(error.message, "error");
          }
        });
    </script>
  </body>
</html>

