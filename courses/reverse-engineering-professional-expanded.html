



<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Exo+2:wght@700;800;900&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css"
    />
    <link rel="stylesheet" href="assets/css/coursepages.css">
    
    <!-- ========== Start: SEO & Schema Enhancement ========== -->
    <title>Reverse Engineering - Complete Course | CipherHall</title>
    <meta name="description" content="Enroll in our expert-led Reverse Engineering course. Master static and dynamic analysis, debugging with Ghidra and IDA, and advanced malware analysis techniques.">
    <meta name="robots" content="noindex, nofollow">
    
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png" />
    <link rel="shortcut icon" href="/favicon.png" type="image/x-icon" />
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png" />
    <link rel="canonical" href="https://www.cipherhall.com/courses/reverse-engineering-professional-expanded.html" />

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Course",
      "name": "Reverse Engineering: From Foundations to Advanced Analysis",
      "description": "A comprehensive, 30-lesson course designed to build a professional-level skill set in reverse engineering for defensive applications like malware analysis and vulnerability research.",
      "provider": {
        "@type": "Organization",
        "name": "CipherHall",
        "sameAs": "https://www.cipherhall.com"
      },
      "hasCourseInstance": {
        "@type": "CourseInstance",
        "courseMode": "Online",
        "instructor": {
          "@type": "Person",
          "name": "Dr. Alex Mercer"
        }
      }
    }
    </script>
    <!-- ========== End: SEO & Schema Enhancement ========== -->
</head>
<body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
        <div class="loader-icon">
            <i class="fas fa-graduation-cap"></i>
        </div>
        <div class="loader-text">Loading Course Content...</div>
    </div>
    
    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>
    
    <!-- Music Player (fixed at top right) -->
    <div class="header-controls">
        <div class="music-dropdown" id="music-dropdown">
            <button class="btn btn-secondary">
                <span id="music-button-text">STUDY MUSIC</span>
                <i id="music-icon" class="fa-solid fa-music"></i>
            </button>
            <div class="music-dropdown-content" id="music-dropdown-content">
                <a href="#" data-src="https://www.learningcontainer.com/wp-content/uploads/2020/02/Kalimba.mp3">1. Coffee Shop Vibes</a>
                <a href="#" data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3">2. City Lights Lofi</a>
                <a href="#" data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-15.mp3">3. Mellow Thoughts</a>
                <a href="#" data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-13.mp3">4. Rainy Mood</a>
                <a href="#" data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3">5. Time Alone</a>
                <a href="#" id="stop-music-link"><i class="fa-solid fa-stop-circle"></i> Stop Music</a>
            </div>
        </div>
        
        <button class="btn btn-secondary" id="resetProgressBtn">
            <i class="fas fa-redo"></i>
            Reset Progress
        </button>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal" style="display: none">
        <div class="modal-overlay"></div>
        <div class="modal-content">
            <span class="close" id="closeAuthModal">&times;</span>
            <div class="auth-tabs">
                <button id="tabSignIn" class="auth-tab active">Sign In</button>
                <button id="tabSignUp" class="auth-tab">Sign Up</button>
            </div>
            <div id="authLoader" style="display: none; text-align: center; padding: 2rem">
                <i class="fas fa-spinner fa-spin fa-2x" style="color: var(--color-green)"></i>
                <p style="margin-top: 0.5rem">Authenticating...</p>
            </div>
            <div id="signInForm" class="auth-form">
                <h2>Sign In to CipherHall</h2>
                <button id="googleSignIn" class="btn btn-google">
                    <i class="fab fa-google"></i> Continue with Google
                </button>
                <div class="divider"><span>or</span></div>
                <form id="emailSignInForm">
                    <input type="email" id="signInEmail" placeholder="Email Address" required>
                    <input type="password" id="signInPassword" placeholder="Password" required>
                    <button type="submit" class="btn btn-primary">Sign In</button>
                </form>
            </div>
            <div id="signUpForm" class="auth-form" style="display: none">
                <h2>Join CipherHall</h2>
                <button id="googleSignUp" class="btn btn-google">
                    <i class="fab fa-google"></i> Continue with Google
                </button>
                <div class="divider"><span>or</span></div>
                <form id="emailSignUpForm">
                    <input type="text" id="signUpName" placeholder="Full Name" required>
                    <input type="email" id="signUpEmail" placeholder="Email Address" required>
                    <input type="password" id="signUpPassword" placeholder="Password (min. 8 characters)" required>
                    <button type="submit" class="btn btn-secondary">Create Account</button>
                </form>
            </div>
            <div id="authMessage"></div>
        </div>
    </div>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <div class="course-info">
                <h1 class="course-title" id="courseTitle">Loading...</h1>
                <div class="course-progress">
                    <div class="progress-header">
                        <span class="progress-label">Course Progress</span>
                        <span class="progress-percentage" id="courseProgressPercent">0%</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="courseProgressFill" style="width: 0%"></div>
                    </div>
                    <div class="progress-stats">
                        <span id="completedLessons">0</span>
                        <span id="totalLessons">0</span>
                    </div>
                </div>
                <a href="/dashboard.html" class="back-to-dashboard">
                    <i class="fas fa-arrow-left"></i>
                    Back to Dashboard
                </a>
            </div>
        </div>

        <nav class="lesson-nav" id="lessonNav">
            <!-- Lessons will be loaded dynamically -->
        </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
        <header class="content-header">
            <div class="lesson-header">
                <div class="lesson-header-left">
                    <span class="lesson-number" id="currentLessonNumber">1</span>
                    <h1 class="lesson-header-title" id="currentLessonTitle">Loading...</h1>
                </div>
                <div class="lesson-actions">
                    <button class="mbtn btn-primary" id="menuToggle">
                        <i class="fas fa-bars"></i>
                       
                    </button>
                </div>
            </div>
        </header>

        <div class="content-body" id="contentBody">
            <div class="lesson-content" id="lessonContent">
                <!-- Lesson content will be loaded dynamically -->
            </div>
        </div>

        <footer class="lesson-navigation">
            <div class="nav-info" id="navInfo">
                Lesson 1 of 10
            </div>
            <div class="nav-controls">
                <button class="btn btn-secondary" id="prevLessonBtn" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <button class="btn btn-primary" id="nextLessonBtn" disabled>
                    Next
                    <i class="fas fa-chevron-right"></i>
                </button>
            </div>
        </footer>
    </main>

    <!-- Achievement Notification -->
    <div id="achievementNotification" class="achievement-notification">
        <div class="notification-header">
            <div class="notification-icon" id="notificationIcon">
                <i class="fas fa-trophy"></i>
            </div>
            <div class="notification-content">
                <h3 id="notificationTitle">Achievement Unlocked!</h3>
                <p id="notificationDescription">Description here...</p>
            </div>
        </div>
        <div class="notification-reward" id="notificationReward">
            <i class="fas fa-coins"></i>
            <span id="notificationPoints">+100 Points</span>
        </div>
    </div>
    <!-- Toast Notification -->
    <div id="toast" class="toast">
        <span id="toastMessage"></span>
    </div>

    <script>
       // =====================================================
// SYNCHRONIZED COURSE SYSTEM WITH DASHBOARD INTEGRATION
// =====================================================

// Supabase Configuration - Replace with your config
const supabaseUrl = 'https://lzcmzulemfubjaksoqor.supabase.co';
const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx6Y216dWxlbWZ1Ympha3NvcW9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzMzM5MDgsImV4cCI6MjA3MDkwOTkwOH0.crhPH4YWtRsr1BJTpAQcmPbWSpwIWRbzoI4sRb2_fPI';
const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

// =====================================================
// COURSE DATA STRUCTURE - REPLACE WITH YOUR COURSE JSON
// =====================================================
  const COURSE_DATA =
{
    "id": "reverse-engineering-basics",
    "title": "Reverse Engineering: From Foundations to Advanced Analysis",
    "description": "A comprehensive, 30-lesson course designed to build a professional-level skill set in reverse engineering for defensive applications. This syllabus takes students from the fundamentals of computer architecture to advanced techniques in static and dynamic analysis, obfuscation, and reporting, all within a strict ethical framework using benign samples.",
    "category": "cybersecurity_engineering",
    "difficulty": "Intermediate to Advanced",
    "duration": "60 hours",
    "instructor": "Dr. Alex Mercer",
    "lessons": [
        {
            "id": "lesson-1",
            "title": "Module 1: Foundations - Introduction to Reverse Engineering",
            "duration": "90 min",
            "objectives": [
                "Define reverse engineering (RE) and its core methodologies.",
                "Understand the critical ethical and legal boundaries that govern RE activities.",
                "Identify real-world defensive applications, including malware analysis, vulnerability research, and software interoperability.",
                "Differentiate between reverse engineering for defense (understanding) and for exploitation (attacking)."
            ],
            "content": {
                "overview": "This foundational lesson introduces the field of reverse engineering. We will explore why it is a critical skill for cybersecurity defenders, discuss the strict ethical guidelines that must be followed, and look at real-world case studies where reverse engineering was used to stop attacks and protect users.",
                "sections": [
                    {
                        "title": "Why Reverse Engineer?",
                        "content": "<p>Reverse engineering is the process of deconstructing a man-made object to understand how it works. In software, this means taking a compiled program (machine code) and figuring out its logic, algorithms, and data. For defenders, this is essential for:</p><ul><li><strong>Malware Analysis:</strong> Understanding what a malicious program does, how it communicates, and how to create signatures to detect it. This is the primary focus of this course.</li><li><strong>Vulnerability Research:</strong> Finding flaws in software so they can be fixed before attackers exploit them. Ethical hackers and security researchers do this to improve security for everyone.</li><li><strong>Interoperability:</strong> Figuring out how a closed-source program or protocol works in order to create compatible software (e.g., the Samba project reverse engineering the SMB protocol).</li><li><strong>Legacy Code Maintenance:</strong> Understanding and fixing bugs in old software for which the source code has been lost.</li></ul>"
                    },
                    {
                        "title": "Ethical and Legal Considerations",
                        "content": "<p>Reverse engineering is a powerful skill that must be used responsibly. We will cover the importance of only analyzing software you are legally permitted to (e.g., your own code, open-source software, or authorized malware samples). We will also discuss End-User License Agreements (EULAs), which often explicitly forbid reverse engineering, and the legal frameworks like the Digital Millennium Copyright Act (DMCA) that govern this field. The guiding principle is authorization and intent: are you authorized to analyze this, and is your intent to build defenses?</p>"
                    }
                ],
                "activities": [
                    {
                        "title": "Case Study Discussion",
                        "description": "Discuss two major cybersecurity events where reverse engineering was critical to the defensive response (e.g., the analysis of the Stuxnet or WannaCry malware). For each case, identify what the defenders learned through RE and how that information was used to mitigate the threat."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "In a cybersecurity context, what is a primary defensive application of reverse engineering?",
                        "options": ["Creating new software from scratch.", "Analyzing malware to understand its functionality and create detection signatures.", "Marketing a competitor's product.", "Optimizing a program's performance."],
                        "correct": 1,
                        "explanation": "Malware analysis is one of the largest and most critical fields that relies on reverse engineering to protect users and networks."
                    },
                    {
                        "id": 2,
                        "question": "What is the most important prerequisite before starting to reverse engineer a piece of commercial software?",
                        "options": ["Having a fast computer.", "Ensuring you have the legal right and authorization to do so.", "Knowing the C++ programming language.", "Having a copy of the software's source code."],
                        "correct": 1,
                        "explanation": "Legal and ethical authorization is the absolute first step. Without it, your actions could be illegal or in violation of a license agreement."
                    }
                ]
            }
        },
        {
            "id": "lesson-2",
            "title": "Module 1: Foundations - Lab Environment Setup",
            "duration": "120 min",
            "objectives": [
                "Understand the importance of an isolated lab environment.",
                "Install and configure virtualization software (VirtualBox/VMware).",
                "Install the essential reverse engineering tools: Ghidra, IDA Free, and x64dbg.",
                "Create a workflow for safely transferring and analyzing samples within the lab."
            ],
            "content": {
                "overview": "A safe, isolated, and well-equipped lab is the reverse engineer's most important asset. This hands-on lesson guides you through the process of setting up a virtualized analysis environment and installing the industry-standard tools we will use throughout this course.",
                "sections": [
                    {
                        "title": "Lab Isolation",
                        "content": "<p>Just like in malware analysis, all reverse engineering should be done in an isolated environment, typically a virtual machine. This prevents any accidental execution or instability from affecting your primary computer. The VM's network should be set to 'Host-only' or disconnected entirely unless network analysis is specifically required. We will also disable shared folders and clipboard to prevent accidental crossover from the guest VM to the host machine.</p>"
                    },
                    {
                        "title": "The RE Toolkit",
                        "content": "<p>We will install a suite of essential, free tools:</p><ul><li><strong>Ghidra:</strong> A full-featured, open-source software reverse engineering (SRE) framework developed by the NSA. It includes a powerful disassembler and decompiler.</li><li><strong>IDA Free:</strong> A freeware version of the industry-leading Interactive Disassembler. While limited, it's a valuable tool to be familiar with.</li><li><strong>x64dbg:</strong> A modern, open-source debugger for Windows, used for dynamic analysis.</li><li><strong>PE-bear / CFF Explorer:</strong> Tools for inspecting the headers and structure of PE files.</li><li><strong>Wireshark:</strong> For capturing and analyzing network traffic.</li></ul>"
                    }
                ],
                "activities": [
                    {
                        "title": "Build Your RE Lab",
                        "description": "Following a guided tutorial, install a Windows VM. Inside the VM, download and install Ghidra, IDA Free, x64dbg, and PE-bear. Create a 'clean' snapshot of the VM once all tools are installed. This snapshot will be your baseline for all future labs."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary function of a tool like Ghidra or IDA?",
                        "options": ["To run programs in a sandbox.", "To capture network traffic.", "To disassemble and decompile a binary, allowing an analyst to study its code.", "To write new programs."],
                        "correct": 2,
                        "explanation": "These are static analysis tools that form the core of any reverse engineering toolkit, used for analyzing a program's code without running it."
                    },
                    {
                        "id": 2,
                        "question": "A debugger like x64dbg is used for what type of analysis?",
                        "options": ["Static analysis", "Dynamic analysis", "Network analysis", "File analysis"],
                        "correct": 1,
                        "explanation": "A debugger allows you to run a program in a controlled manner, pausing it to inspect its state (memory, registers), which is the definition of dynamic analysis."
                    }
                ]
            }
        },
        {
            "id": "lesson-3",
            "title": "Module 1: Foundations - Computer Architecture & Binary Formats",
            "duration": "120 min",
            "objectives": [
                "Review CPU basics, registers, and memory hierarchy (x86, ARM).",
                "Identify the key components of PE (Windows) and ELF (Linux) binary formats.",
                "Use tools like `pefile` and `readelf` to inspect binary headers.",
                "Locate critical information like the entry point and import table."
            ],
            "content": {
                "overview": "To understand compiled code, we must understand its structure and the architecture it runs on. This lesson combines a refresher on computer architecture with a practical dive into the PE and ELF file formats, teaching you how to extract critical metadata before looking at a single instruction.",
                "sections": [
                    {
                        "title": "Architecture Essentials (x86-64)",
                        "content": "<p>The CPU executes instructions using small, high-speed memory locations called registers. Key registers include <strong>RAX</strong> (return values), <strong>RDI/RSI</strong> (arguments), <strong>RSP/RBP</strong> (stack pointers), and <strong>RIP</strong> (the instruction pointer).</p>"
                    },
                    {
                        "title": "The PE (Portable Executable) Format",
                        "content": "<p>Used by Windows, the PE format contains headers and sections that describe the binary to the OS. The most important parts for an analyst are:</p><ul><li><strong>Optional Header:</strong> Contains the <strong>AddressOfEntryPoint</strong> (where code execution begins) and the <strong>DataDirectory</strong>, which points to other critical tables.</li><li><strong>Import Address Table (IAT):</strong> A table of all external functions (e.g., from `kernel32.dll`) that the program needs to run. This is a goldmine for understanding a program's capabilities.</li><li><strong>Sections:</strong> `.text` (executable code), `.data` (initialized global variables), `.rdata` (read-only data like strings).</li></ul>"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Parse PE Headers with pefile",
                        "language": "python",
                        "code": "# A defender uses this script for initial, safe reconnaissance of a Windows binary.\n# It extracts fundamental properties like the compile time and architecture.\nimport pefile\nimport datetime\n\ndef analyze_pe_headers(file_path):\n    try:\n        pe = pefile.PE(file_path)\n        print(f'--- PE Header Analysis for: {file_path} ---')\n        print(f\"Entry Point: {hex(pe.OPTIONAL_HEADER.AddressOfEntryPoint)}\")\n        compile_time = datetime.datetime.fromtimestamp(pe.FILE_HEADER.TimeDateStamp)\n        print(f\"Compile Time: {compile_time.strftime('%Y-%m-%d %H:%M:%S')}\")\n        print(f\"Architecture: {'x64' if pe.FILE_HEADER.Machine == 0x8664 else 'x86'}\")\n    except Exception as e:\n        print(f'Could not analyze file: {e}')\n\n# Usage on a benign system file\nanalyze_pe_headers('C:\\\\Windows\\\\System32\\\\kernel32.dll')"
                    },
                    {
                        "title": "List PE Imports with pefile",
                        "language": "python",
                        "code": "# This is one of the most useful static analysis scripts for a defender.\n# By listing the imported functions, you get a strong indication of the program's capabilities\n# (e.g., networking, file I/O, registry access) without ever running it.\nimport pefile\n\ndef list_pe_imports(file_path):\n    try:\n        pe = pefile.PE(file_path)\n        print(f'--- Imports for {file_path} ---')\n        for entry in pe.DIRECTORY_ENTRY_IMPORT:\n            print(f'[+] {entry.dll.decode()}')\n            for imp in entry.imports:\n                print(f'  - {imp.name.decode(errors=\"ignore\")}')\n    except Exception as e:\n        print(f'Error analyzing imports: {e}')\n\n# Usage:\nlist_pe_imports('C:\\\\Windows\\\\System32\\\\notepad.exe')"
                    },
                    {
                        "title": "Inspect ELF Headers with readelf (Linux)",
                        "language": "bash",
                        "code": "# On Linux, `readelf` is the standard tool for inspecting ELF files.\n# The `-h` flag shows the main header. A defender uses this to quickly verify\n# the file type, architecture, and entry point address.\nreadelf -h /bin/ls"
                    },
                    {
                        "title": "List ELF Dynamic Symbols with readelf (Linux)",
                        "language": "bash",
                        "code": "# This command shows the dynamically linked functions an ELF binary needs.\n# It's the Linux equivalent of looking at the PE import table.\n# A defender can see if the program uses suspicious functions like `socket` or `execve`.\nreadelf --dyn-syms /bin/ls | grep FUNC"
                    }
                ],
                "activities": [
                    {
                        "title": "Inspect Binary Headers",
                        "description": "Using the provided scripts and tools, inspect the headers of a benign Windows executable (`notepad.exe`) and a benign Linux executable (`/bin/ls`). For each, find and document the entry point address, the architecture (x86/x64), and the names of at least three sections."
                    }
                ]
            },
            "quiz": {
              "passingScore": 80,
              "questions": [
                {
                  "id": 1,
                  "question": "In a Windows PE file, which header contains the AddressOfEntryPoint?",
                  "options": ["DOS Header", "NT Headers", "Optional Header", "Section Header"],
                  "correct": 2,
                  "explanation": "The Optional Header contains the most critical information for the OS loader, including the entry point address and the location of the data directories."
                },
                {
                  "id": 2,
                  "question": "What is the purpose of the `.text` section in a PE or ELF file?",
                  "options": ["It contains the program's resources, like icons.", "It contains the program's executable code.", "It contains initialized global variables.", "It contains the file's metadata headers."],
                  "correct": 1,
                  "explanation": "By convention, the `.text` section (or sometimes `.code`) is where the actual machine code instructions of the program are stored."
                }
              ]
            }
        },
        {
            "id": "lesson-4",
            "title": "Module 1: Foundations - Assembly Language & Disassembly",
            "duration": "120 min",
            "objectives": [
                "Understand the purpose of key instructions: MOV, PUSH, POP, CALL, RET, JMP.",
                "Differentiate between linear vs. recursive disassembly.",
                "Use `objdump` and Ghidra to disassemble a simple program.",
                "Correlate disassembled code with the original source code."
            ],
            "content": {
                "overview": "Assembly language is the human-readable representation of machine code. To understand what a compiled program is doing, you must be able to read its assembly. This lesson covers the fundamental instructions and the process of disassembly.",
                "sections": [
                    {
                        "title": "Core Instructions",
                        "content": "<ul><li><strong>Data Movement:</strong> `MOV dest, src` (Move data), `PUSH value` (Push to stack), `POP dest` (Pop from stack).</li><li><strong>Control Flow:</strong> `JMP target` (Unconditional jump), `CMP reg1, reg2` (Compare), `JE target` (Jump if equal), `CALL function` (Call function), `RET` (Return from function).</li></ul>"
                    },
                    {
                        "title": "Disassembly Techniques",
                        "content": "<p>A disassembler is a tool that reads the bytes of a binary's code section and translates them into assembly instructions.</p><ul><li><strong>Linear Disassembly:</strong> A simple method that starts at the beginning and decodes each byte sequentially. It can be fooled by data mixed in with code.</li><li><strong>Recursive Disassembly:</strong> A more intelligent method that starts at the entry point and follows the control flow (jumps and calls) to determine what is code and what is data. This is what modern tools like Ghidra and IDA use.</li></ul>"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Simple C Program for Disassembly",
                        "language": "c",
                        "code": "// A defender compiles this simple program (e.g., with `gcc -o hello hello.c` on Linux)\n// to create a known-good binary for studying the disassembly process.\n#include <stdio.h>\nint main() {\n    printf(\"Hello, World!\\n\");\n    return 0;\n}"
                    },
                    {
                        "title": "Disassemble with `objdump` (Linux)",
                        "language": "bash",
                        "code": "# `objdump` with the `-d` flag is a standard way for a defender on Linux to quickly view\n# the assembly code of an executable without a heavy GUI tool.\nobjdump -d ./hello"
                    },
                    {
                        "title": "Ghidra Disassembly View (Conceptual)",
                        "language": "asm",
                        "code": "; This is what a defender would see in the central disassembly pane in Ghidra for the C program.\n; It shows the address, the raw instruction bytes, and the assembly code.\n; 00401500  55               PUSH   EBP\n; 00401501  89 E5            MOV    EBP,ESP\n; 00401503  68 00 30 40 00   PUSH   s_Hello_World!_00403000\n; 00401508  E8 03 00 00 00   CALL   _printf"
                    },
                    {
                        "title": "Python Script to Disassemble Bytes (capstone)",
                        "language": "python",
                        "code": "# The Capstone engine is a library that allows defenders to build their own analysis tools.\n# This script demonstrates programmatically disassembling a raw byte string, a technique\n# useful for analyzing shellcode or code extracted from memory.\nfrom capstone import Cs, CS_ARCH_X86, CS_MODE_64\n\nCODE = b\"\\x55\\x48\\x89\\xe5\\x48\\x83\\xec\\x20\\xc7\\x45\\xfc\\x00\\x00\\x00\\x00\"\nmd = Cs(CS_ARCH_X86, CS_MODE_64)\n\nfor i in md.disasm(CODE, 0x1000):\n    print(f\"0x{i.address:x}:\\t{i.mnemonic}\\t{i.op_str}\")"
                    }
              ],
                "activities": [
                    {
                        "title": "Disassemble 'Hello World'",
                        "description": "Compile the simple 'Hello World' C program on your native system (using GCC on Linux or Visual Studio on Windows). Load the resulting binary into Ghidra and let it auto-analyze. Find the `main` function and compare the disassembly view to the original C source code. Identify the `CALL` instruction to `printf`."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "In x86 assembly, what does the `CALL` instruction do?",
                        "options": ["It adds two numbers.", "It pushes the return address onto the stack and then jumps to the address of a function.", "It ends the program.", "It compares two values."],
                        "correct": 1,
                        "explanation": "A `CALL` is how a program transfers execution to a subroutine or function, while also saving the location to return to afterwards."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary advantage of recursive disassembly over linear disassembly?",
                        "options": ["It is faster.", "It is better at distinguishing code from data by following the program's control flow.", "It can only be done on Linux.", "It does not require a CPU."],
                        "correct": 1,
                        "explanation": "Recursive disassembly is a more intelligent approach that is more resilient to attempts to confuse the disassembler by mixing data bytes within the code."
                    }
                ]
            }
        },
        {
            "id": "lesson-5",
            "title": "Module 2: Static Analysis - Decompilation & Control Flow",
            "duration": "120 min",
            "objectives": [
                "Understand the role and limitations of a decompiler.",
                "Practice using Ghidra's decompiler to reconstruct program logic.",
                "Learn to read a Control Flow Graph (CFG) to visualize a function's logic.",
                "Identify high-level constructs (if/else, loops) in decompiled code."
            ],
            "content": {
                "overview": "While assembly is the ground truth, it's hard to read. A decompiler, which turns assembly back into high-level C-like pseudocode, is a reverse engineer's greatest productivity tool. This lesson focuses on using Ghidra's decompiler and its graph view to rapidly understand program logic.",
                "sections": [
                    {
                        "title": "The Power of Decompilation",
                        "content": "<p>A decompiler handles much of the tedious work of interpreting assembly. It automatically tracks variable usage, reconstructs `if/else` blocks and `for` loops, and resolves function arguments. For a reverse engineer, reading the decompiler's C-like output is often much faster and more intuitive than reading raw assembly. It allows you to focus on the 'what' (the program's logic) rather than the 'how' (the low-level assembly implementation).</p>"
                    },
                    {
                        "title": "Control Flow Graphs (CFGs)",
                        "content": "<p>Modern disassemblers can display a function as a CFG. Instead of a linear list of instructions, the code is shown as blocks connected by arrows. This visual representation makes it much easier to understand loops, if/else statements, and the overall logic of a function, even before looking at the decompiler.</p>"
                    }
                ],
                "codeExamples":[
                    {
                        "title": "Benign C Code with a Conditional",
                        "language": "c",
                        "code": "// A defender compiles this simple C program to study how an if-else statement\n// is translated into assembly and then reconstructed by a decompiler.\n\nint check_value(int x) {\n    if (x == 10) {\n        return 1;\n    } else {\n        return 0;\n    }\n}"
                    },
                    {
                        "title": "Corresponding Assembly with Jumps",
                        "language": "asm",
                        "code": "; This is the assembly generated from the C code. A defender learns to read this to trace logic.\ncheck_value:\n    push    ebp\n    mov     ebp, esp\n    cmp     DWORD PTR [ebp+8], 10 ; Compare the first argument (x) with the value 10\n    jne     is_not_equal        ; JUMP if NOT EQUAL to the 'else' block\n    mov     eax, 1\n    jmp     end_of_function\nis_not_equal:\n    mov     eax, 0\nend_of_function:\n    pop     ebp\n    ret"
                    },
                    {
                        "title": "Ghidra Decompiled Pseudocode",
                        "language": "c",
                        "code": "/*\nThis is what Ghidra's decompiler produces. A defender can immediately understand this.\nIt correctly reconstructs the if/else logic from the `cmp` and `jne` instructions.\n*/\nint check_value(int param_1)\n{\n  int local_c;\n  \n  if (param_1 == 10) {\n    local_c = 1;\n  } else {\n    local_c = 0;\n  }\n  return local_c;\n}"
                    },
                    {
                        "title": "Ghidra Script to Highlight Complex Functions",
                        "language": "python",
                        "code": "# A defender can use scripting to triage a large binary. This Ghidra script iterates\n# through all functions and flags those that are very complex (have a high number of\n# basic blocks in their CFG), as these might be interesting functions to analyze first.\n\n# def find_complex_functions(threshold=20):\n#     fm = currentProgram.getFunctionManager()\n#     for func in fm.getFunctions(True):\n#         num_blocks = func.getBody().getNumAddresses()\n#         if num_blocks > threshold:\n#             print(f'[INFO] Complex function found: {func.getName()} with {num_blocks} blocks.')\n#             createBookmark(func.getEntryPoint(), 'Complex Function', f'Blocks: {num_blocks}')\n\n# find_complex_functions()"
                    }
              ],
                "activities": [
                    {
                        "title": "Reconstruct Logic with the Decompiler",
                        "description": "Load a benign binary into Ghidra. Find a moderately complex function. First, try to understand its logic by only looking at the assembly graph view. Then, switch to the decompiler window. Rename the variables and add comments to the decompiled code until you can write a one-paragraph summary of what the function does."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "In a disassembler's graph view, what do the connecting arrows between blocks of code represent?",
                        "options": ["Data dependencies", "Control flow (jumps, calls, and returns)", "The order the functions were written", "The speed of execution"],
                        "correct": 1,
                        "explanation": "The graph view is a Control Flow Graph (CFG), which visually represents how the program's execution can jump between different parts of the code."
                    },
                    {
                        "id": 2,
                        "question": "If a decompiler shows a variable named `param_1`, what does this typically represent?",
                        "options": ["A global variable.", "The first argument passed to the current function.", "A local variable.", "The return value of the function."],
                        "correct": 1,
                        "explanation": "Decompilers follow the calling convention to identify which stack or register values correspond to function parameters, often giving them default names like `param_1`, `param_2`, etc."
                    }
                ]
            }
        },
        {
            "id": "lesson-6",
            "title": "Module 2: Static Analysis - Functions, Strings & Data",
            "duration": "120 min",
            "objectives": [
                "Understand calling conventions (cdecl, stdcall, fastcall).",
                "Trace function parameters and return values in disassembly.",
                "Use tools to extract ASCII and Unicode strings.",
                "Trace cross-references to data to understand its context."
            ],
            "content": {
                "overview": "This lesson deepens our static analysis skills by focusing on two key areas: understanding the mechanics of function calls and analyzing the non-code data within a binary. Strings and other data often provide the quickest and clearest clues about a program's true purpose.",
                "sections": [
                    {
                        "title": "Calling Conventions & Stack Frames",
                        "content": "<p>A 'calling convention' is a standard for how functions are called. It defines where arguments are placed (stack or registers) and who cleans up the stack. A key part of this is the 'stack frame', a temporary workspace on the stack for each function call that holds arguments and local variables. Understanding this is critical to correctly interpreting function logic.</p><ul><li><strong>cdecl:</strong> Caller cleans the stack.</li><li><strong>stdcall:</strong> Callee cleans the stack (common in WinAPI).</li></ul>"
                    },
                    {
                        "title": "Data Analysis",
                        "content": "<p>Strings, global variables, and other hardcoded data can reveal a program's secrets.</p><ul><li><strong>String Extraction:</strong> Use tools like `strings` or Ghidra's string viewer to find revealing text like error messages, filenames, or C2 domains.</li><li><strong>Cross-References:</strong> The most powerful technique. Once you find an interesting string, use your disassembler's 'xref' feature to find the exact part of the code that uses that string. This provides immediate context for the string's purpose.</li></ul>"
                    }
                ],
                "codeExamples":[
                {
                    "title": "Assembly for `stdcall` (Callee Cleanup)",
                    "language": "asm",
                    "code": "; `stdcall` is used by WinAPI. Note the `ret 10h` instruction.\n; `10h` is 16 in decimal. This `ret` instruction not only returns to the caller\n; but also cleans up the 4 arguments (4 bytes each) from the stack.\n\npush    arg4\npush    arg3\npush    arg2\npush    arg1\ncall    MyStdcallFunction\n; No stack cleanup needed by caller\n\nMyStdcallFunction:\n    ; ... function body ...\n    ret     10h ; Return and pop 16 bytes from stack"
                },
                {
                    "title": "Assembly for `cdecl` (Caller Cleanup)",
                    "language": "asm",
                    "code": "; `cdecl` is common for C programs. The function has a simple `ret`.\n; The caller is responsible for cleaning up the stack.\n\npush    arg2\npush    arg1\ncall    MyCdeclFunction\nadd     esp, 8 ; Caller cleans up 2 arguments (4 bytes each)\n\nMyCdeclFunction:\n    ; ... function body ...\n    ret ; Simple return"
                },
                {
                    "title": "Find Program Database (PDB) Path with pefile",
                    "language": "python",
                    "code": "# The PDB path is a string embedded by the compiler that points to a debugging file.\n# Malware authors often forget to remove this, leaking their username and project folder structure.\n# A defender can use this as a high-confidence indicator.\nimport pefile\n\ndef find_pdb_path(file_path):\n    try:\n        pe = pefile.PE(file_path)\n        for entry in pe.DIRECTORY_ENTRY_DEBUG:\n            if hasattr(entry.entry, 'PdbFileName'):\n                pdb_path = entry.entry.PdbFileName.decode().strip('\\x00')\n                print(f'[INFO] Found PDB Path: {pdb_path}')\n    except Exception as e:\n        print(f'Could not analyze file: {e}')\n\n# Usage:\nfind_pdb_path('C:\\\\Windows\\\\System32\\\\kernel32.dll')"
                },
                {
                    "title": "Ghidra Script to Find All String References",
                    "language": "python",
                    "code": "# This Ghidra script iterates through all defined strings in a program\n# and prints the location of the code that references each one.\n# A defender uses this to quickly find the context for interesting strings.\n\n# dt = currentProgram.getDataManager()\n# for s in dt.getDefinedStrings(currentProgram.getMemory()):\n#     s_addr = s.getAddress()\n#     s_val = s.getValue()\n#     refs = getReferencesTo(s_addr)\n#     if refs:\n#         print(f'String \"{s_val}\" at {s_addr} is referenced by:')\n#         for ref in refs:\n#             print(f' -> {ref.getFromAddress()}')"
                }
              ],
                "activities": [
                    {
                        "title": "Reverse-engineer function parameters",
                        "description": "Load a benign program into Ghidra. Find a function that you know (from its name or context) takes specific arguments. Examine the assembly and decompiled code to identify which registers or stack offsets hold the arguments. Use Ghidra to redefine the function's signature to match what you discovered, which will clean up the decompiled code."
                    }
                ]
            },
            "quiz": {
              "passingScore": 80,
              "questions": [
                {
                  "id": 1,
                  "question": "In the `cdecl` calling convention, who is responsible for cleaning up the arguments from the stack after a function call?",
                  "options": ["The callee (the function that was called)", "The operating system", "The caller (the function that made the call)", "Nobody"],
                  "correct": 2,
                  "explanation": "In `cdecl`, the caller must adjust the stack pointer (`add esp, ...`) after the call returns. This is different from `stdcall`, where the callee does it."
                },
                {
                  "id": 2,
                  "question": "After finding an interesting hardcoded string in a binary, what is the most logical next step for an analyst?",
                  "options": ["Delete the string.", "Search for cross-references to the string's memory address to find the code that uses it.", "Assume the program is malicious.", "Run the program to see what happens."],
                  "correct": 1,
                  "explanation": "Finding a string is only the first step. The critical part of the analysis is understanding the context in which that string is used by tracing cross-references."
                }
              ]
            }
        },
        {
            "id": "lesson-7",
            "title": "Module 3: Dynamic Analysis - Debugging Basics",
            "duration": "120 min",
            "objectives": [
                "Understand the purpose of a debugger for dynamic analysis.",
                "Set and use breakpoints to pause program execution at specific locations.",
                "Practice stepping through code (step over, step into, step out).",
                "Inspect the state of registers and memory while the program is paused."
            ],
            "content": {
                "overview": "While static analysis shows us what a program *can* do, dynamic analysis with a debugger shows us what it *actually* does in a given moment. This lesson is a hands-on introduction to using a debugger like x64dbg to control and inspect a running process.",
                "sections": [
                    {
                        "title": "The Debugging Process",
                        "content": "<p>A debugger attaches to a running process and takes control of its execution. This allows the analyst to:</p><ul><li><strong>Set Breakpoints:</strong> A breakpoint is a pause signal. You can set a breakpoint on a specific instruction (e.g., right before a call to a suspicious function). When the program reaches that instruction, it will pause.</li><li><strong>Step Through Code:</strong> While paused, you can execute the program one instruction at a time. `Step Into` will enter a function call, while `Step Over` will execute the function and pause at the next line in the current function.</li><li><strong>Inspect State:</strong> While paused, you can view the contents of all CPU registers, the stack, and any region of the program's memory. This is crucial for seeing what data the program is working with.</li></ul>"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "GDB Command Sequence (Linux)",
                        "language": "gdb",
                        "code": "# GDB (GNU Debugger) is the standard debugger on Linux. A defender would use this\n# sequence of commands to analyze a benign ELF binary.\n\n# Start GDB with the benign program\ngdb ./benign_program\n\n# Set a breakpoint at the main function\nbreak main\n\n# Run the program. It will stop at the breakpoint.\nrun\n\n# Step through the code one instruction at a time\nstepi\nstepi\n\n# Inspect the contents of the EAX and EBX registers\ninfo registers eax ebx\n\n# View 16 bytes of memory from the top of the stack\nx/16xb $esp"
                    },
                    {
                        "title": "x64dbg Conceptual Workflow (Windows)",
                        "language": "text",
                        "code": "// This represents the actions a defender takes in the x64dbg GUI.\n// 1. File -> Open -> Select benign_sample.exe. The program loads and is paused at its entry point.\n// 2. In the CPU window, scroll down to a CALL instruction.\n// 3. Press F2 to set a breakpoint on that line. The line turns red.\n// 4. Press F9 to run the program. It executes until it hits the breakpoint.\n// 5. Look at the Registers window on the right to see the current values of EAX, ECX, etc.\n// 6. Look at the Stack window in the bottom left to see the data on the stack.\n// 7. Press F8 (Step Over) to execute the CALL and pause on the next instruction.\n// 8. Observe how the register and stack values have changed."
                    },
                    {
                        "title": "WinDbg Command to Set Breakpoint",
                        "language": "text",
                        "code": "; WinDbg is another powerful debugger for Windows, often used for kernel debugging.\n; This command sets a breakpoint on the CreateFileW function in kernel32.dll.\n; A defender uses this to see every time any process on the system tries to create a file.\nbp kernel32!CreateFileW"
                    },
                    {
                        "title": "Python Script to Attach a Debugger (pywin32)",
                        "language": "python",
                        "code": "# This script is a proof-of-concept showing how a defender could programmatically\n# attach a debugger to a process. This is an advanced technique.\nimport win32process\nimport win32api\n\n# pid = 1234 # Get the Process ID of the target\n# h_process = win32api.OpenProcess(win32process.DEBUG_PROCESS, False, pid)\n# result = win32process.DebugActiveProcess(pid)\n# if result:\n#     print(f'Successfully attached debugger to PID {pid}')\n# else:\n#     print('Failed to attach debugger.')\n\nprint('Conceptual code for attaching a debugger.')"
                }
              ],
                "activities": [
                    {
                        "title": "Debug a Benign Program",
                        "description": "Load a simple, benign program (like the Windows calculator, `calc.exe`) into x64dbg. Find the entry point. Set a breakpoint on a function call a few lines down. Run the program to hit the breakpoint. Step through a few instructions and watch how the register values change."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is a 'breakpoint' in the context of debugging?",
                        "options": ["A bug in the program that causes it to crash.", "A signal that pauses the program's execution at a specific instruction chosen by the analyst.", "A command to end the debugging session.", "A record of the program's execution."],
                        "correct": 1,
                        "explanation": "Breakpoints are the primary mechanism for controlling a program's execution, allowing the analyst to pause it at interesting points for inspection."
                    },
                    {
                        "id": 2,
                        "question": "What is the difference between 'Step Into' and 'Step Over' in a debugger?",
                        "options": ["There is no difference.", "'Step Into' executes one instruction, while 'Step Over' executes the entire program.", "'Step Into' will enter a function being called, while 'Step Over' will execute the entire function and stop at the next instruction in the current function.", "'Step Over' is faster."],
                        "correct": 2,
                        "explanation": "This is a fundamental concept for controlling the level of detail in your analysis. You 'Step Over' functions you don't care about and 'Step Into' functions you want to analyze."
                    }
                ]
            }
        },
        {
            "id": "lesson-8",
            "title": "Module 3: Dynamic Analysis - Advanced Debugging & Memory Analysis",
            "duration": "120 min",
            "objectives": [
                "Set conditional and memory breakpoints to trace data.",
                "Modify register values and memory to alter program behavior.",
                "Use a debugger to analyze command-line arguments and environment variables.",
                "Dump and analyze process memory to extract strings or unpacked code."
            ],
            "content": {
                "overview": "This lesson goes deeper into dynamic analysis, moving beyond simple code stepping to actively manipulating a program's state and observing how it reacts. We will cover advanced breakpoints and the crucial skill of dumping memory from a live process for offline analysis.",
                "sections": [
                    {
                        "title": "Advanced Breakpoints",
                        "content": "<p>Modern debuggers can do more than just break on an instruction.</p><ul><li><strong>Conditional Breakpoints:</strong> You can set a breakpoint to only trigger if a certain condition is met (e.g., 'pause here only if the EAX register is zero').</li><li><strong>Memory Breakpoints (or Hardware Breakpoints/Watchpoints):</strong> You can tell the debugger to pause whenever a specific memory address is read from, written to, or executed. This is extremely powerful for finding out which part of the code is responsible for changing a particular variable or executing shellcode.</li></ul>"
                    },
                    {
                        "title": "Memory Dumping",
                        "content": "<p>A debugger can dump any part of a process's memory to a file. This is the core technique for unpacking. Once malware has unpacked its real code into a new memory region, the debugger can be used to save that entire region to disk. This dumped file, containing the raw, unpacked code, can then be loaded into a static analysis tool like Ghidra for a much easier analysis.</p>"
                    }
                ],
                "codeExamples":[
                {
                    "title": "x64dbg Command for a Conditional Breakpoint",
                    "language": "text",
                    "code": "// In x64dbg, a defender can set a conditional breakpoint to investigate a loop.\n// This command tells the debugger to pause at the address 0x401000, but only\n// when the loop counter register (ECX) is equal to 5.\n\nbp 0x401000, ecx == 5"
                },
                {
                    "title": "GDB Command for a Memory Watchpoint",
                    "language": "gdb",
                    "code": "# In GDB, a defender can set a watchpoint on a variable (or memory address).\n# The debugger will then pause the program any time the value at that address is changed.\n# This is invaluable for finding out what part of the code is modifying important data.\n\n# Assume 'my_variable' is at address 0x8049a20\nwatch *0x8049a20"
                },
                {
                    "title": "Dumping Process Memory with PowerShell",
                    "language": "powershell",
                    "code": "# A defender can use this built-in Windows tool to create a memory dump of a process.\n# This `.dmp` file can then be analyzed offline with WinDbg or other forensics tools.\n# Replace 'notepad' with the target process name.\n$process = Get-Process -Name notepad\nC:\\Windows\\System32\\rundll32.exe comsvcs.dll, MiniDump $process.Id .\\notepad.dmp full"
                },
                {
                    "title": "Patching a Jump Instruction in x64dbg",
                    "language": "text",
                    "code": "// This represents the actions a defender takes to modify a program's logic.\n// 1. In x64dbg, pause the program at a conditional jump, e.g., 'JE 0x405000'.\n// 2. This jump is taken if a check fails, leading to program exit.\n// 3. To bypass this, right-click the instruction and select 'Assemble'.\n// 4. Change 'JE 0x405000' to 'NOP' (No-Operation) or `JMP` to the desired location.\n// 5. This effectively removes the check, and the program will continue as if the check passed."
                }
              ],
                "activities": [
                    {
                        "title": "Debug a Benign Calculator App",
                        "description": "Write a very simple console application that asks for two numbers, adds them, and prints the result. Load this program into x64dbg. Set a breakpoint just before the `ADD` instruction. Run the program and enter two numbers. When the breakpoint is hit, inspect the registers to see your numbers. Manually change the value in one of the registers. Resume the program and see how the final output is different."
                    }
                ]
            },
            "quiz": {
              "passingScore": 80,
              "questions": [
                {
                  "id": 1,
                  "question": "What is a conditional breakpoint?",
                  "options": ["A breakpoint that sometimes works and sometimes doesn't.", "A breakpoint that only pauses execution if a specific condition (e.g., a register having a certain value) is true.", "A breakpoint that is set on a conditional jump instruction.", "A breakpoint that corrupts the program."],
                  "correct": 1,
                  "explanation": "Conditional breakpoints are a powerful feature that allows an analyst to ignore irrelevant executions of a piece of code and only stop when the conditions are interesting."
                },
                {
                  "id": 2,
                  "question": "Setting a memory breakpoint (or watchpoint) allows an analyst to:",
                  "options": ["See the entire contents of RAM.", "Pause the program whenever a specific memory address is read or written.", "Delete a section of memory.", "Prevent a program from accessing memory."],
                  "correct": 1,
                  "explanation": "Memory breakpoints are the best way to answer the question 'Who is modifying this important piece of data?'."
                }
              ]
            }
        },
        {
            "id": "lesson-9",
            "title": "Module 3: Dynamic Analysis - OS Internals for RE (Windows)",
            "duration": "90 min",
            "objectives": [
              "Understand the relationship between processes, DLLs, and the import/export tables.",
              "Learn the purpose of the Windows API (WinAPI) and its most important DLLs.",
              "Trace a WinAPI call from user code into a system DLL.",
              "Identify common WinAPI functions used by malware for persistence, injection, and C2."
            ],
            "content": {
              "overview": "To reverse engineer Windows programs, you must speak their language. Their language is the Windows API. This lesson focuses on the key concepts of the WinAPI and how programs use it to interact with the operating system, which is critical for understanding the behavior of any Windows binary.",
              "sections": [
                {
                  "title": "The Windows API (WinAPI)",
                  "content": "<p>The WinAPI is a massive collection of functions, exported by system DLLs, that allow programs to perform actions like creating files, opening network connections, modifying the registry, and creating windows. Nearly every action a program takes is ultimately done by calling a WinAPI function.</p><ul><li><strong>`kernel32.dll`</strong>: Core functions for memory management, processes, and threads.</li><li><strong>`user32.dll`</strong>: Functions for user interface elements like windows and messages.</li><li><strong>`advapi32.dll`</strong>: Advanced API functions for services, registry, and security.</li><li><strong>`ws2_32.dll`</strong>: Networking functions (Windows Sockets).</li></ul>"
                },
                {
                  "title": "Imports and Exports",
                  "content": "<p>A program's <strong>Import Address Table (IAT)</strong> lists all the external WinAPI functions it needs to call. A DLL's <strong>Export Address Table (EAT)</strong> lists all the functions it makes available for other programs to use. Analyzing these tables provides a high-level summary of the binary's capabilities.</p>"
                }
              ],
              "codeExamples":[
                {
                    "title": "C Code Using WinAPI",
                    "language": "c",
                    "code": "// A defender writes this simple program to see how a high-level action (creating a file)\n// maps to a specific WinAPI call (`CreateFileA`).\n#include <windows.h>\n\nvoid create_a_file() {\n    HANDLE hFile = CreateFileA(\n        \"C:\\\\temp\\\\test.txt\",\n        GENERIC_WRITE,\n        0,\n        NULL,\n        CREATE_NEW,\n        FILE_ATTRIBUTE_NORMAL,\n        NULL);\n    if (hFile != INVALID_HANDLE_VALUE) {\n        CloseHandle(hFile);\n    }\n}"
                },
                {
                    "title": "Use PowerShell to Find a Function's Exporting DLL",
                    "language": "powershell",
                    "code": "# This is a proof-of-concept showing how a defender could programmatically find\n# which system DLL contains a specific function. This helps in understanding dependencies.\n$module = Get-Process -Name notepad | Select-Object -ExpandProperty Modules | Where-Object { ($_.ExportedFunctions.Keys -contains 'CreateFileA') }\nif ($module) {\n    Write-Host \"'CreateFileA' is exported by: $($module.ModuleName)\"\n} else {\n    Write-Host \"Function not found in this process's modules.\"\n}"
                },
                {
                    "title": "Debug a WinAPI Call in x64dbg",
                    "language": "text",
                    "code": "// This represents the actions a defender takes to trace an API call.\n// 1. In x64dbg, find a `CALL ds:[<&CreateFileA>]` instruction.\n// 2. This is a call through the Import Address Table (IAT).\n// 3. Right-click the operand `<&CreateFileA>` and select 'Follow in Disassembler'.\n// 4. This will take you to the IAT entry, which will contain a JMP instruction.\n// 5. Following that JMP will land you at the actual start of the CreateFileA function inside kernel32.dll."
                },
                {
                    "title": "Ghidra Script to Bookmark Common Malware APIs",
                    "language": "python",
                    "code": "# A defender uses a script like this to automatically highlight dangerous API calls in a binary.\n\nMALWARE_APIS = [\"CreateRemoteThread\", \"WriteProcessMemory\", \"WinExec\", \"URLDownloadToFileA\"]\n\n# fm = currentProgram.getFunctionManager()\n# for f in fm.getFunctions(True):\n#     if f.getName() in MALWARE_APIS:\n#         createBookmark(f.getEntryPoint(), \"Malware API\", f\"Found common malware API: {f.getName()}\")\n#         print(f'Bookmarked {f.getName()}')"
                }
              ],
              "activities": [
                {
                  "title": "Map Function Calls to Imports",
                  "description": "Load a benign networked program (like `putty.exe`) into Ghidra. Find the code that performs a network connection. Identify the key WinAPI call used (e.g., `connect`). Now, go to the program's import table in the 'Symbol Tree' window and find the entry for `connect`. Verify that it is being imported from `ws2_32.dll` (the Windows Sockets library)."
                }
              ]
            },
            "quiz": {
              "passingScore": 80,
              "questions": [
                {
                  "id": 1,
                  "question": "What is the primary purpose of the Windows API (WinAPI)?",
                  "options": ["It is a programming language.", "It is a set of core functions provided by the OS that applications can call to perform tasks like file I/O and networking.", "It is a type of malware.", "It is a hardware component."],
                  "correct": 1,
                  "explanation": "The WinAPI is the fundamental interface between user applications and the Windows operating system's capabilities."
                },
                {
                  "id": 2,
                  "question": "In a PE file, the Import Address Table (IAT) contains what?",
                  "options": ["A list of functions that the file exports for other programs to use.", "The program's executable code.", "Pointers to the functions in other DLLs that the program needs to call.", "The program's string data."],
                  "correct": 2,
                  "explanation": "The IAT is a lookup table that the OS loader fills in at runtime with the actual memory addresses of the functions the program imports from system libraries."
                }
              ]
            }
        },
        {
            "id": "lesson-10",
            "title": "Module 3: Dynamic Analysis - OS Internals for RE (Linux)",
            "duration": "90 min",
            "objectives": [
              "Understand the role of syscalls as the interface to the Linux kernel.",
              "Identify the key sections of an ELF file.",
              "Use `strace` to trace the system calls made by a running program.",
              "Differentiate between static and dynamic linking in ELF binaries."
            ],
            "content": {
              "overview": "While this course focuses on Windows, understanding the basics of reverse engineering on Linux is also a valuable skill. This lesson covers the fundamentals of Linux executables (ELF files), the concept of system calls, and the powerful tools available for dynamic analysis on Linux.",
              "sections": [
                {
                  "title": "System Calls (Syscalls)",
                  "content": "<p>In Linux, a user-mode program cannot directly access hardware or perform privileged operations. Instead, it must ask the kernel to do it on its behalf. This request is called a 'system call'. For example, to open a file, a program uses the `open` syscall. The user program sets up the arguments in specific registers and then executes a special instruction (`syscall` or `int 0x80`) to trap into the kernel. The kernel performs the requested action and then returns the result to the user program.</p>"
                },
                {
                  "title": "Dynamic Analysis with `strace`",
                  "content": "<p>`strace` is a powerful command-line utility that intercepts and records all the system calls made by a process and the return values. It's the Linux equivalent of using Process Monitor to see file, network, and process operations. Running `strace` on a binary is often the very first step in dynamic analysis on Linux to get a quick overview of its behavior.</p>"
                }
              ],
              "codeExamples":[
                {
                    "title": "Trace Syscalls with `strace` (Linux)",
                    "language": "bash",
                    "code": "# `strace` is a powerful tool for defenders on Linux. It shows every interaction\n# a program has with the kernel. This command runs the `/bin/ls` program and prints\n# every single system call it makes, such as `openat`, `read`, `write`, and `close`.\nstrace /bin/ls"
                },
                {
                    "title": "Filter `strace` for Network Syscalls",
                    "language": "bash",
                    "code": "# A defender can use the `-e` flag to filter the `strace` output for specific syscalls.\n# This command will only show network-related calls like `socket`, `connect`, and `sendto`,\n# which is useful for analyzing a program's network behavior.\nstrace -e trace=network /usr/bin/curl https://google.com"
                },
                {
                    "title": "View ELF Sections with `objdump` (Linux)",
                    "language": "bash",
                    "code": "# `objdump` is another standard Linux binary analysis tool.\n# The `-h` flag shows the section headers, similar to the pefile Python script for Windows.\n# A defender uses this to see the layout of the file (e.g., .text, .data, .rodata sections).\nobjdump -h /bin/ls"
                },
                {
                    "title": "Disassemble with `objdump` (Linux)",
                    "language": "bash",
                    "code": "# The `-d` flag tells `objdump` to disassemble the executable code in the .text section.\n# This is a quick way for a defender to view the assembly of a Linux binary without\n# loading it into a heavy tool like Ghidra.\nobjdump -d /bin/ls | less"
                }
              ],
              "activities": [
                {
                  "title": "Trace Syscalls with `strace`",
                  "description": "In a Linux VM, run `strace` on several common, benign command-line programs (e.g., `ls -l /etc`, `cat /etc/hosts`, `ping -c 1 google.com`). For each program, examine the `strace` output and identify the key syscalls responsible for the program's main function (e.g., `openat` and `read` for `cat`, `connect` and `sendto` for `ping`)."
                }
              ]
            },
            "quiz": {
              "passingScore": 80,
              "questions": [
                {
                  "id": 1,
                  "question": "What is the primary way a user-mode program on Linux interacts with the kernel?",
                  "options": ["By writing to a special file.", "By making system calls (syscalls).", "By using the Windows API.", "By directly modifying kernel memory."],
                  "correct": 1,
                  "explanation": "Syscalls are the fundamental, well-defined interface between user applications and the Linux kernel's privileged services."
                },
                {
                  "id": 2,
                  "question": "The `strace` utility on Linux is used to:",
                  "options": ["Disassemble an ELF file.", "Trace the system calls made by a running process.", "Edit the source code of a program.", "Scan for viruses."],
                  "correct": 1,
                  "explanation": "`strace` is an essential dynamic analysis tool for observing a program's interaction with the operating system at the syscall level."
                }
              ]
            }
        },
        {
            "id": "lesson-11",
            "title": "Module 4: Advanced Topics - Analyzing Object-Oriented Code (C++)",
            "duration": "90 min",
            "objectives": [
                "Understand the challenges of reversing C++ code (classes, inheritance, virtual functions).",
                "Learn to recognize and demangle C++ symbol names.",
                "Identify virtual tables (vtables) and their role in dynamic dispatch.",
                "Trace a virtual function call in a disassembler."
            ],
            "content": {
                "overview": "Reversing code from object-oriented languages like C++ presents unique challenges. Concepts like classes, inheritance, and virtual functions are high-level abstractions that don't have a direct, one-to-one mapping in assembly. This lesson covers how these features are typically implemented by compilers and how to identify them in the disassembly.",
                "sections": [
                    {
                        "title": "Name Mangling",
                        "content": "<p>C++ allows multiple functions to have the same name (function overloading). To create unique symbols for the linker, the compiler 'mangles' the names, encoding information about the function's arguments and class into the symbol. For example, a function `MyClass::myFunc(int)` might become `?myFunc@MyClass@@QAEXH@Z`. Modern disassemblers can automatically 'demangle' these back to a human-readable form.</p>"
                    },
                    {
                        "title": "Virtual Functions and Vtables",
                        "content": "<p>Virtual functions allow for polymorphism. When you call a virtual function, the program doesn't know the exact function address at compile time. Instead, the object contains a hidden pointer called the 'vpointer' which points to a 'vtable' (virtual table). The vtable is essentially an array of function pointers for that class. A virtual function call involves first reading the vpointer, then reading the correct function address from the vtable, and finally calling that address. Recognizing this double-dereference pattern is key to identifying virtual calls.</p>"
                    }
                ],
                "codeExamples": [
                {
                    "title": "Benign C++ Code with a Virtual Function",
                    "language": "cpp",
                    "code": "// A defender compiles this to study how C++ classes and virtual functions are represented in assembly.\nclass Shape {\npublic:\n    virtual void draw() { /* ... */ }\n};\n\nclass Circle : public Shape {\npublic:\n    void draw() override { /* ... */ }\n};\n\nvoid draw_any_shape(Shape* s) {\n    s->draw(); // This is a virtual call\n}"
                },
                {
                    "title": "Assembly for a Virtual Function Call",
                    "language": "asm",
                    "code": "; This assembly shows the signature of a virtual call.\n; A defender learns to spot this pattern to understand object-oriented code.\ndraw_any_shape:\n    mov     eax, [esp+4] ; 1. Get the 'this' pointer ('s') into EAX\n    mov     edx, [eax]   ; 2. De-reference 's' to get the vpointer into EDX\n    mov     eax, [edx]   ; 3. De-reference the vpointer to get the address of the first function (draw)\n    call    eax          ; 4. Call the address of the draw function\n    ret"
                },
                {
                    "title": "Demangle a C++ Symbol Name (Linux)",
                    "language": "bash",
                    "code": "# A defender can use the `c++filt` utility to manually demangle C++ symbols\n# found in a binary.\n\n# Mangled symbol for `std::string::size() const`\nMANGLLED_SYMBOL=\"_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE4sizeEv\"\n\nc++filt $MANGLLED_SYMBOL"
                },
                {
                    "title": "Ghidra: Viewing Class Information",
                    "language": "text",
                    "code": "// Ghidra has built-in analyzers for C++.\n// A defender can use the 'Symbol Tree' window to see a reconstructed view of the\n// program's classes, including their methods and virtual functions.\n// This is often automatically populated during the initial analysis.\n\n// Action: Window -> Symbol Tree\n// Action: Navigate down to 'Classes' -> 'Shape' -> 'vftable'"
                }
              ],
                "activities": [
                    {
                        "title": "Identify Virtual Functions",
                        "description": "Compile the benign C++ example with a Shape and Circle class. Load the resulting binary into Ghidra. Locate the `draw_any_shape` function and observe the vtable lookup pattern in the disassembly. Use the decompiler and symbol tree to identify the reconstructed `Shape::draw` and `Circle::draw` methods."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is 'name mangling' in C++?",
                        "options": ["A type of security vulnerability.", "A process where the compiler encodes a function's parameters and class into its symbol name to ensure uniqueness.", "A code obfuscation technique.", "A way to make C++ code run faster."],
                        "correct": 1,
                        "explanation": "Name mangling is a standard part of the C++ compilation process needed to support features like function overloading."
                    },
                    {
                        "id": 2,
                        "question": "A 'vtable' in a C++ binary is essentially:",
                        "options": ["A list of all global variables.", "The program's import table.", "An array of function pointers used to implement virtual functions.", "A type of security control."],
                        "correct": 2,
                        "explanation": "The virtual table is the mechanism that enables polymorphism at a low level, allowing the correct derived class method to be called at runtime."
                    }
                ]
            }
        },
        {
            "id": "lesson-12",
            "title": "Module 4: Advanced Techniques - Reverse Engineering Scripts & Bytecode",
            "duration": "90 min",
            "objectives": [
                "Understand that interpreted languages also have a compiled form (bytecode).",
                "Use `dis` to view Python bytecode.",
                "Use `uncompyle6` to decompile `.pyc` files back to Python source.",
                "Introduce the structure of Java class files and bytecode."
            ],
            "content": {
                "overview": "Not all programs are compiled to native machine code. Many are written in interpreted languages like Python or Java. These languages first compile their source code into an intermediate format called 'bytecode', which is then run by a virtual machine. This lesson introduces the basics of reversing these bytecode formats.",
                "sections": [
                    {
                        "title": "Python Bytecode",
                        "content": "<p>When you run a Python script, the interpreter first compiles it into bytecode and saves it as a `.pyc` file. This bytecode is a set of instructions for the Python Virtual Machine (PVM). Python's built-in `dis` (disassembler) module can be used to view these bytecode instructions. Because Python bytecode is high-level and retains much of the original program's structure, it can often be 'decompiled' back into very readable Python source code using tools like `uncompyle6`.</p>"
                    },
                    {
                        "title": "Java Bytecode",
                        "content": "<p>Similarly, Java source code is compiled into bytecode and stored in `.class` files. This bytecode is executed by the Java Virtual Machine (JVM). As seen in the mobile malware lesson, tools like JADX are excellent decompilers for Java bytecode, making the analysis of Java applications (including Android apps) relatively straightforward compared to native code.</p>"
                    }
                ],
                "codeExamples": [
                {
                    "title": "Disassemble Python Bytecode with `dis`",
                    "language": "python",
                    "code": "# Python's `dis` module is a built-in tool for defenders to inspect `.pyc` files\n# or the bytecode of live functions. It shows the low-level operations the Python VM will perform.\nimport dis\n\ndef my_function(a, b):\n    if a > b:\n        return a + 1\n    return b + 1\n\n# Disassemble the function\ndis.dis(my_function)"
                },
                {
                    "title": "Decompile a .pyc File with `uncompyle6`",
                    "language": "bash",
                    "code": "# First, a defender creates a .pyc file from a .py file.\npython -m compileall benign_script.py\n\n# Then, they use a tool like `uncompyle6` to decompile it back to source.\n# This is often highly effective for understanding malicious Python scripts.\nuncompyle6 __pycache__/benign_script.cpython-38.pyc"
                },
                {
                    "title": "View Java Bytecode with `javap`",
                    "language": "bash",
                    "code": "# `javap` is a command-line tool included with the Java Development Kit (JDK).\n# A defender uses it to disassemble `.class` files to see the Java bytecode instructions.\n# First, compile a simple .java file\njavac HelloWorld.java\n\n# Then, disassemble the resulting .class file\njavap -c HelloWorld"
                },
                {
                    "title": "Python Script to Read a `.pyc` Header",
                    "language": "python",
                    "code": "# This script shows how a defender can programmatically parse the header of a .pyc file\n# to check the magic number and determine the Python version it was compiled with.\nimport struct\n\ndef check_pyc_header(file_path):\n    try:\n        with open(file_path, 'rb') as f:\n            magic = f.read(4)\n            # The first 2 bytes are the magic number, next 2 are newline/return chars\n            pyc_version_code = struct.unpack('<H', f.read(2))[0]\n            print(f'File: {file_path}')\n            print(f'Magic Number: {magic.hex()}')\n            print(f'Python Version Code: {pyc_version_code}')\n            # A defender would have a lookup table for version codes.\n    except Exception as e:\n        print(f'Error: {e}')\n\n# Usage:\n# check_pyc_header('__pycache__/benign_script.cpython-38.pyc')"
                }
              ],
                "activities": [
                    {
                        "title": "Decompile a `.pyc` File",
                        "description": "Write a simple Python script that performs a basic calculation and saves the result to a file. Use the `compileall` module to create the `.pyc` file. Then, use the `uncompyle6` tool to decompile the `.pyc` file and verify that the output closely matches your original source code."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is 'bytecode' in the context of languages like Python and Java?",
                        "options": ["Native machine code for the CPU.", "An intermediate, platform-independent code format that is executed by a virtual machine.", "The source code of the program.", "A type of encryption."],
                        "correct": 1,
                        "explanation": "Bytecode is a lower-level representation of the source code, but it is still higher-level and more abstract than native machine code."
                    },
                    {
                        "id": 2,
                        "question": "Python's built-in `dis` module is used to:",
                        "options": ["Run a Python script.", "Decompile a `.pyc` file to source code.", "Disassemble a Python function or `.pyc` file into its bytecode instructions.", "Encrypt a Python script."],
                        "correct": 2,
                        "explanation": "The `dis` module is a disassembler for Python bytecode, allowing you to see the instructions that the Python Virtual Machine (PVM) executes."
                    }
                ]
            }
        },
        {
            "id": "lesson-13",
            "title": "Module 4: Advanced Techniques - Reverse Engineering .NET & Java",
            "duration": "90 min",
            "objectives": [
                "Differentiate between managed and native code.",
                "Understand the role of the Common Intermediate Language (CIL) in .NET.",
                "Use `dnSpy` and `ILSpy` to decompile benign .NET applications.",
                "Use `JADX` to decompile benign Java (and Android) applications."
            ],
            "content": {
                "overview": "Like Python and Java, .NET applications are compiled to an intermediate language (IL). Because IL is high-level and metadata-rich, it is often possible to decompile a .NET executable back to almost perfect C# or VB.NET source code. This lesson introduces the tools and techniques for reversing managed code.",
                "sections": [
                    {
                        "title": ".NET and Common Intermediate Language (CIL)",
                        "content": "<p>When you compile a C# or VB.NET application, it is converted into CIL and stored in a .NET assembly (an EXE or DLL). This assembly also contains rich metadata about all the types, methods, and properties in the code. When the program is run, the .NET runtime's Just-In-Time (JIT) compiler converts the CIL into native machine code on the fly.</p>"
                    },
                    {
                        "title": "Decompilation Tools",
                        "content": "<p>Because the CIL contains so much high-level information, decompilers for .NET are extremely effective. An analyst can often recover a very accurate representation of the original source code.</p><ul><li><strong>dnSpy / ILSpy:</strong> These are powerful open-source tools that can decompile, debug, and even edit .NET assemblies.</li><li><strong>JADX:</strong> While focused on Android, it is also an excellent decompiler for standard Java `.class` and `.jar` files.</li></ul>"
                    }
                ],
                "codeExamples": [
                {
                    "title": "Decompile a .NET Executable with ILSpy",
                    "language": "bash",
                    "code": "# ILSpy has a command-line version that defenders can use for automation.\n# This command takes a benign .NET executable and decompiles it to a C# project file.\n# The result is often nearly identical to the original source code.\nilspycmd benign_dotnet_app.exe -p -o ./decompiled_source"
                },
                {
                    "title": "Using dnSpy for Interactive Debugging",
                    "language": "text",
                    "code": "// dnSpy is a GUI tool. This describes the workflow a defender would use.\n// 1. Open dnSpy.\n// 2. File -> Open -> Select benign_dotnet_app.exe.\n// 3. The Assembly Explorer shows the decompiled source code.\n// 4. A defender can read the C# code directly. They can also set breakpoints, edit\n//    instructions, and modify variables, all at the decompiled source code level."
                },
                {
                    "title": "Simple C# Program for Analysis",
                    "language": "csharp",
                    "code": "// A defender compiles this simple C# program to create a benign sample for practice.\nusing System;\n\npublic class HelloWorld\n{\n    public static void Main(string[] args)\n    {\n        Console.WriteLine(\"Hello, .NET RE!\");\n    }\n}"
                },
                {
                    "title": "Decompile a Java JAR file with JADX-GUI",
                    "language": "text",
                    "code": "// This describes the simple process for analyzing a Java application.\n// 1. Open JADX-GUI.\n// 2. File -> Open -> Select benign_java_app.jar.\n// 3. JADX will decompile the entire application, allowing the defender to browse\n//    the Java source code, search for strings, and find cross-references."
                }
              ],
                "activities": [
                    {
                        "title": "Decompile a Benign .NET Application",
                        "description": "Write a simple 'Hello World' console application in C#. Compile it using the .NET SDK. Now, open the resulting `.exe` file in dnSpy or ILSpy. Observe how the tool can perfectly decompile it back to your original C# source code."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is 'managed code'?",
                        "options": ["Code that has been reviewed by a manager.", "Code that runs under the management of a runtime environment (like the .NET CLR or Java JVM), which handles tasks like memory management.", "Native machine code.", "Assembly language."],
                        "correct": 1,
                        "explanation": "Managed code is an abstraction layer above the native OS and hardware, which is why it's compiled to an intermediate language instead of directly to machine code."
                    },
                    {
                        "id": 2,
                        "question": "Why is it often possible to decompile .NET and Java applications back to a very high-quality source code representation?",
                        "options": ["Because they are simple languages.", "Because the intermediate language (CIL/Java Bytecode) they are compiled to retains a large amount of high-level metadata.", "It is not possible.", "Because the source code is included in the executable."],
                        "correct": 1,
                        "explanation": "Unlike native C/C++ compilation, which loses a lot of information, .NET/Java compilation preserves a rich set of metadata, making the decompilation process much more accurate."
                    }
                ]
            }
        },
        {
            "id": "lesson-14",
            "title": "Module 4: Obfuscation and Anti-Analysis - Code Obfuscation",
            "duration": "90 min",
            "objectives": [
                "Understand the different categories of obfuscation (layout, data, control).",
                "Recognize common obfuscation techniques like string encryption and control flow flattening.",
                "Practice deobfuscating simple XOR-encrypted strings.",
                "Use a debugger to defeat simple obfuscation and reveal the underlying logic."
            ],
            "content": {
                "overview": "Obfuscation is the process of making code intentionally difficult for humans to understand, without changing its actual functionality. Malware authors and software protection systems use this extensively to slow down and frustrate reverse engineers. This lesson provides a deeper dive into common obfuscation techniques and the strategies used to defeat them.",
                "sections": [
                    {
                        "title": "Categories of Obfuscation",
                        "content": "<ul><li><strong>Layout Obfuscation:</strong> Removes or confuses metadata. Renaming variables and functions to meaningless names (`a`, `b`, `c`) is a simple example.</li><li><strong>Data Obfuscation:</strong> Hides the data the program uses. The most common form is string encryption, where strings are only decrypted in memory right before they are used.</li><li><strong>Control Obfuscation:</strong> Hides the program's logic. This includes techniques like inserting junk code, using opaque predicates, and the powerful control flow flattening, which destroys the program's structure.</li></ul>"
                    },
                    {
                        "title": "Defeating Obfuscation",
                        "content": "<p>Dynamic analysis is the primary weapon against obfuscation. No matter how scrambled the code is on disk, it must eventually be resolved into clear, logical instructions in memory for the CPU to execute them. By using a debugger, an analyst can step through the deobfuscation routines (like a string decryption loop) and inspect the result in memory, revealing the original, unobfuscated data and logic.</p>"
                    }
                ],
                "codeExamples":[
                {
                    "title": "Python Script for Simple String Obfuscation (XOR)",
                    "language": "python",
                    "code": "# Malware often uses XOR to hide strings. A defender uses a script like this\n# to both create and reverse simple string obfuscation to practice deobfuscation techniques.\n\ndef xor_string(s_bytes, key_bytes):\n    return bytes([b ^ key_bytes[i % len(key_bytes)] for i, b in enumerate(s_bytes)])\n\nsecret_string = b\"C:\\\\windows\\\\system32\\\\calc.exe\"\nkey = b\"mysecretkey\"\n\nobfuscated = xor_string(secret_string, key)\nprint(f'Obfuscated: {obfuscated.hex()}')\n\ndeobfuscated = xor_string(obfuscated, key)\nprint(f'Deobfuscated: {deobfuscated.decode()}')"
                },
                {
                    "title": "Deobfuscating Strings in a Debugger (x64dbg)",
                    "language": "text",
                    "code": "// This describes a defender's workflow for deobfuscating a string.\n// 1. In Ghidra, identify the string decryption function (e.g., it contains a loop with an XOR instruction).\n// 2. In x64dbg, set a breakpoint at the end of this function (on the RET instruction).\n// 3. Run the program until the breakpoint is hit.\n// 4. The decrypted string will now be in memory, typically pointed to by a register like EAX or on the stack.\n// 5. Inspect that memory region to read the plaintext string."
                },
                {
                    "title": "YARA Rule to Detect XOR Loops",
                    "language": "yara",
                    "code": "/*\nThis YARA rule helps a defender find code that is likely performing string deobfuscation.\nIt looks for a common pattern: a loop that iterates through data and performs an XOR operation.\n*/\nrule Detect_XOR_Loop\n{\n    strings:\n        // Looks for a pattern like: `xor reg, [mem]; inc reg; ... loop`\n        $xor_loop = { 8A .. 32 .. 43 .. 75 F? }\n\n    condition:\n        $xor_loop\n}"
                },
                {
                    "title": "Conceptual Control Flow Flattening",
                    "language": "c",
                    "code": "// This C code illustrates the logic of control flow flattening.\n// The original, linear logic is broken into blocks managed by a switch statement.\n// This makes the CFG very difficult for a human to follow.\n\nint state = 1;\nwhile (state != 0) {\n    switch (state) {\n        case 1:\n            // Original block 1\n            printf(\"Enter value: \");\n            state = 2;\n            break;\n        case 2:\n            // Original block 2\n            scanf(\"%d\", &value);\n            state = 3;\n            break;\n        case 3:\n            // Original block 3\n            if (value > 10) state = 4; else state = 5;\n            break;\n        // ... etc.\n    }\n}"
                }
              ],
                "activities": [
                    {
                        "title": "Analyze an Obfuscated Crackme",
                        "description": "Download a simple, benign 'crackme' challenge designed for beginners. These are programs that have been intentionally obfuscated. Load it into Ghidra and observe the confusing control flow graph. Then, load it into x64dbg and step through the code to bypass the obfuscation and understand its true logic."
                    }
                ]
            },
            "quiz": {
              "passingScore": 80,
              "questions": [
                {
                  "id": 1,
                  "question": "What is the primary goal of code obfuscation from a malware author's perspective?",
                  "options": ["To make the program run faster.", "To make the program smaller.", "To make the program more difficult and time-consuming for a security researcher to analyze.", "To add new features to the program."],
                  "correct": 2,
                  "explanation": "Obfuscation is an anti-analysis technique designed to increase the cost and effort required for reverse engineering."
                },
                {
                  "id": 2,
                  "question": "What is the most effective general strategy for defeating string encryption?",
                  "options": ["Guessing the key.", "Using static analysis to read the encrypted string.", "Using dynamic analysis (a debugger) to let the program decrypt the string itself, and then inspecting the result in memory.", "Ignoring the string."],
                  "correct": 2,
                  "explanation": "Dynamic analysis is the key to defeating many forms of obfuscation. By observing the program as it runs, you can see the final, deobfuscated data and logic."
                }
              ]
            }
        },
        {
            "id": "lesson-15",
            "title": "Module 4: Obfuscation and Anti-Analysis - Anti-Reversing Techniques",
            "duration": "90 min",
            "objectives": [
                "Understand the goals of anti-reversing techniques.",
                "Recognize common anti-debug and anti-VM tricks.",
                "Learn how checksums and self-modifying code can be used to detect tampering.",
                "Develop and practice strategies for bypassing these techniques."
            ],
            "content": {
                "overview": "Anti-reversing techniques are specifically designed to detect or subvert the tools and environments used by analysts. This lesson covers the common tricks that programs use to detect debuggers, resist modification, and generally make the analyst's job harder, as well as the common methods for bypassing them.",
                "sections": [
                    {
                        "title": "Anti-Debugging",
                        "content": "<p>These techniques are designed to detect if the program is being run under the control of a debugger.</p><ul><li><strong>API Checks:</strong> The simplest method is to call `IsDebuggerPresent()`. The bypass is to set a breakpoint after this call and change the return value (in EAX) to zero.</li><li><strong>Timing Checks:</strong> A program can measure the time it takes to execute a small piece of code. A common bypass is to identify the timing check code and patch it out entirely.</li></ul>"
                    },
                    {
                        "title": "Anti-VM",
                        "content": "<p>These techniques check for artifacts of virtualization.</p><ul><li><strong>File/Registry Checks:</strong> Malware looks for files like `VBoxGuestAdditions.exe`. The bypass is to use a hardened VM where these artifacts have been renamed or removed.</li><li><strong>Hardware Checks:</strong> Malware checks for MAC addresses belonging to VMware or VirtualBox. The bypass is to change the VM's MAC address to one from a real hardware vendor.</li></ul>"
                    }
                ],
                "codeExamples":[
                {
                    "title": "C Code for a Simple Anti-Debug Check",
                    "language": "c",
                    "code": "// A defender studies this code to understand how to spot anti-debug tricks.\n// This function from `kernel32.dll` is the most common and easiest to spot.\n#include <windows.h>\n\nvoid check_debugger() {\n    if (IsDebuggerPresent()) {\n        printf(\"Debugger detected! Exiting.\\n\");\n        ExitProcess(1);\n    }\n}"
                },
                {
                    "title": "Bypassing `IsDebuggerPresent` in x64dbg",
                    "language": "text",
                    "code": "// This represents a common defensive bypass technique.\n// 1. In x64dbg, set a breakpoint on the `IsDebuggerPresent` function.\n// 2. Run the program until the breakpoint is hit.\n// 3. The function will return TRUE (1) in the EAX register.\n// 4. Before returning from the function (before the RET instruction), manually change the value of EAX to 0.\n// 5. Resume execution. The program now thinks no debugger is attached."
                },
                {
                    "title": "Python Script to Calculate a File Checksum (CRC32)",
                    "language": "python",
                    "code": "# A program can use a checksum to see if its code has been patched.\n# A defender can use the same technique to create a checksum for a known-good file,\n# which can then be used to detect if that file is tampered with on a system.\nimport zlib\n\ndef calculate_crc32(file_path):\n    try:\n        with open(file_path, 'rb') as f:\n            checksum = zlib.crc32(f.read())\n            print(f'CRC32 Checksum for {file_path}: {hex(checksum)}')\n    except FileNotFoundError:\n        print(f'File not found: {file_path}')\n\n# Usage:\ncalculate_crc32('C:\\\\Windows\\\\System32\\\\kernel32.dll')"
                },
                {
                    "title": "Ghidra Script to Find Anti-Debug APIs",
                    "language": "python",
                    "code": "# A defender can automate the search for anti-reversing techniques.\n# This Ghidra script hunts for calls to common anti-debug WinAPI functions.\n\nANTI_DEBUG_FUNCS = [\"IsDebuggerPresent\", \"CheckRemoteDebuggerPresent\", \"OutputDebugStringA\"]\n\n# fm = currentProgram.getFunctionManager()\n# for func in fm.getFunctions(True):\n#     if func.getName() in ANTI_DEBUG_FUNCS:\n#         refs = getReferencesTo(func.getEntryPoint())\n#         for ref in refs:\n#             print(f'[ALERT] Anti-debug function {func.getName()} called at {ref.getFromAddress()}')"
                }
              ],
                "activities": [
                    {
                        "title": "Bypass a Benign Anti-Debug Check",
                        "description": "Compile a simple benign C program that calls `IsDebuggerPresent()` and exits if it returns true. First, run the program normally to see it execute. Then, load it into x64dbg. Observe how it exits immediately. Now, find the call to `IsDebuggerPresent`, set a breakpoint after it, and modify the return value in EAX to 0. Resume the program and see that it now continues its execution."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "The WinAPI function `IsDebuggerPresent()` is a common example of what?",
                        "options": ["A file operation", "A network function", "An anti-debugging technique", "A persistence mechanism"],
                        "correct": 2,
                        "explanation": "It is a simple and widely used method for a program to check if it is being actively debugged."
                    },
                    {
                        "id": 2,
                        "question": "Why would a program calculate a checksum of its own code in memory?",
                        "options": ["To improve performance.", "To detect if a reverse engineer has modified (patched) its code with a debugger.", "To prepare for an update.", "To communicate with a C2 server."],
                        "correct": 1,
                        "explanation": "This is a form of integrity checking. If the calculated checksum does not match a hardcoded expected value, the program knows it has been tampered with and can shut down."
                    }
                ]
            }
        },
        {
            "id": "lesson-16",
            "title": "Module 4: Advanced Techniques - Binary Instrumentation",
            "duration": "90 min",
            "objectives": [
                "Define Dynamic Binary Instrumentation (DBI) and its use cases.",
                "Differentiate DBI from traditional debugging.",
                "Introduce popular DBI frameworks like Intel Pin and Frida.",
                "Write a simple instrumentation script to trace function calls in a running program."
            ],
            "content": {
                "overview": "Dynamic Binary Instrumentation is a powerful technique for analyzing a program's behavior by inserting custom analysis code *into* the program as it runs. This allows for fine-grained, programmatic monitoring that can be more efficient and targeted than traditional debugging. This lesson provides an introduction to the concepts and tools of DBI.",
                "sections": [
                    {
                        "title": "What is DBI?",
                        "content": "<p>A DBI framework (like Pin or Frida) acts as a Just-In-Time (JIT) compiler. It attaches to a target process, reads the next block of machine code, adds its own custom analysis code (the 'instrumentation'), and then executes the modified code. This allows a defender to create custom tools that can, for example, log every time a specific function is called, trace all memory allocations, or create a complete profile of the program's behavior without the stop-and-go nature of a debugger.</p>"
                    },
                    {
                        "title": "Frida",
                        "content": "<p>Frida is a very popular and user-friendly DBI framework that allows you to write your instrumentation scripts in JavaScript. It is widely used for analyzing mobile and desktop applications. A defender can write a Frida script to intercept function calls on-the-fly, view their arguments, and even modify their return values, all programmatically.</p>"
                    }
                ],
                "codeExamples": [
                {
                    "title": "Frida Script to Trace a Function Call",
                    "language": "javascript",
                    "code": "// This Frida script is used by defenders to dynamically trace function calls.\n// It attaches to a process and hooks the `CreateFileW` API. Every time the application\n// calls this function, this script will print the filename that was passed as an argument.\n\nInterceptor.attach(Module.getExportByName(\"kernel32.dll\", \"CreateFileW\"), {\n    onEnter: function(args) {\n        console.log(\"[CALL] CreateFileW called with filename: \" + args[0].readUtf16String());\n    }\n});"
                },
                {
                    "title": "Run a Frida Script from Python",
                    "language": "python",
                    "code": "# A defender uses the Frida Python bindings to control the instrumentation.\n# This script loads a JavaScript file (containing the code from the previous example)\n# and injects it into a target process (e.g., notepad.exe).\nimport frida\nimport sys\n\ntry:\n    # Attach to the running process\n    session = frida.attach(\"notepad.exe\")\n    # Read the JavaScript instrumentation code\n    with open(\"trace_createfile.js\", \"r\") as f:\n        script_code = f.read()\n    # Create and load the script into the process\n    script = session.create_script(script_code)\n    script.load()\n    # Keep the script running\n    sys.stdin.read()\nexcept frida.ProcessNotFoundError:\n    print(\"Process not found. Is notepad.exe running?\")"
                },
                {
                    "title": "Intel Pin Tool (Conceptual C++)",
                    "language": "cpp",
                    "code": "// Pin is a more powerful, lower-level DBI framework that uses C++ 'Pintools'.\n// This is a simplified example of a Pintool that counts how many times\n// each instruction is executed, a technique known as instruction profiling.\n// VOID docount(UINT64 icount) { *icount_ptr += icount; }\n// \n// VOID Instruction(INS ins, VOID *v)\n// {\n//     INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)docount, IARG_UINT64, 1, IARG_END);\n// }"
                },
                {
                    "title": "Frida Script to Modify a Function's Return Value",
                    "language": "javascript",
                    "code": "// This Frida script demonstrates how to bypass an anti-debug check.\n// It hooks the `IsDebuggerPresent` function and, on exit (when the function is about to return),\n// it replaces the original return value with 0 (FALSE), tricking the application.\n\nInterceptor.attach(Module.getExportByName(null, \"IsDebuggerPresent\"), {\n    onLeave: function(retval) {\n        console.log(\"IsDebuggerPresent was called. Bypassing...\");\n        retval.replace(0);\n    }\n});"
                }
              ],
                "activities": [
                    {
                        "title": "Instrument a Benign Binary with Frida",
                        "description": "Install Frida on your host machine. Write a simple JavaScript script that hooks the `MessageBoxA` function from `user32.dll`. Launch a benign program that calls this function (e.g., you can write a simple C program that does this). Use Frida to inject your script into the running process. When the message box appears, verify that your script successfully logged the call and its arguments to the console."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is Dynamic Binary Instrumentation (DBI)?",
                        "options": ["A type of static analysis.", "A technique for inserting analysis code into a program as it is running to monitor its behavior.", "A method for encrypting a binary.", "A way to decompile code."],
                        "correct": 1,
                        "explanation": "DBI is a form of dynamic analysis that programmatically instruments the target binary to observe its execution in a fine-grained manner."
                    },
                    {
                        "id": 2,
                        "question": "Compared to a traditional debugger, a major advantage of a DBI framework like Frida is:",
                        "options": ["It is harder to use.", "It allows for complex, programmatic analysis and modification through scripting, which is more scalable and flexible than manual clicking in a debugger.", "It can only be used on Linux.", "It does not require running the program."],
                        "correct": 1,
                        "explanation": "DBI excels at automated, large-scale analysis where you need to programmatically define your instrumentation logic, whereas a debugger is better for manual, exploratory analysis."
                    }
                ]
            }
        },
        {
            "id": "lesson-17",
            "title": "Module 5: Application & Reporting - Binary Patching",
            "duration": "90 min",
            "objectives": [
                "Understand the goals and risks of binary patching.",
                "Use a hex editor to perform simple modifications to a binary.",
                "Practice patching instructions in a debugger by overwriting with NOPs.",
                "Save a patched version of a file and verify its new behavior."
            ],
            "content": {
                "overview": "Binary patching is the act of directly modifying the bytes of an executable file to change its behavior. For a reverse engineer, this is a powerful technique for bypassing security checks, enabling hidden features, or fixing bugs when the source code is not available. This lesson covers the basic workflow for patching binaries.",
                "sections": [
                    {
                        "title": "The Patching Workflow",
                        "content": "<p>A disciplined patching workflow is essential to avoid corrupting the file:</p><ol><li><strong>Create a Backup:</strong> Always work on a copy of the executable, never the original.</li><li><strong>Identify the Target:</strong> Use a disassembler (Ghidra) to find the exact file offset of the instruction(s) you want to change.</li><li><strong>Perform the Patch:</strong> Use a tool to change the bytes. This can be done with a hex editor for simple changes or directly in a debugger like x64dbg for more complex patches.</li><li><strong>Save and Test:</strong> Save the modified file and run it to confirm that your patch had the desired effect and did not introduce any unintended side effects.</li></ol>"
                    },
                    {
                        "title": "NOPing Instructions",
                        "content": "<p>One of the most common patching techniques is to 'NOP out' a conditional jump. The `NOP` (No-Operation) instruction (hex code `0x90`) does nothing. By overwriting a conditional jump like `JNE` with `NOP` instructions, you can effectively remove the check and force the program to always take the desired execution path. This is a common way to bypass license checks or nag screens in 'crackme' challenges.</p>"
                    }
                ],
                "codeExamples": [
                {
                    "title": "Patching with a Hex Editor (Conceptual)",
                    "language": "text",
                    "code": "// This represents a defender's workflow for a simple patch.\n// 1. In Ghidra, find the offset of a `JNZ` instruction. Let's say it's at file offset 0x1234.\n// 2. The instruction is 2 bytes long: `75 08` (JNZ +8 bytes).\n// 3. Open a copy of the binary in a hex editor (like HxD).\n// 4. Go to offset 0x1234.\n// 5. Overwrite the bytes `75 08` with `90 90` (two NOPs).\n// 6. Save the file. The conditional jump has now been removed."
                },
                {
                    "title": "Patching in x64dbg",
                    "language": "text",
                    "code": "// This is the easier, more common way for a defender to patch.\n// 1. Load the binary in x64dbg and go to the `JNZ` instruction.\n// 2. Right-click the instruction -> 'Assemble'.\n// 3. Change the text `JNZ ...` to `NOP` and click OK. x64dbg will automatically overwrite the correct number of bytes.\n// 4. To save the changes, go to File -> Patch file."
                },
                {
                    "title": "Radare2 Patching Command",
                    "language": "bash",
                    "code": "# Radare2's command line is very powerful for scripting patches.\n# A defender would use this sequence to open a file in write mode, seek to the target address,\n# and overwrite the instructions with NOPs.\nr2 -w benign_crackme.exe\n[0x...]> s 0x401000\n[0x...]> wa nop"
                },
                {
                    "title": "Python Script to Patch a File",
                    "language": "python",
                    "code": "# Defenders can write Python scripts for more complex or repetitive patching tasks.\n# This script opens a binary in read/write mode, seeks to a specific offset, and overwrites bytes.\n# THIS IS A DANGEROUS OPERATION. Always have a backup.\n\ndef patch_file(file_path, offset, new_bytes):\n    try:\n        with open(file_path, 'r+b') as f:\n            f.seek(offset)\n            f.write(new_bytes)\n            print(f'Successfully wrote {len(new_bytes)} bytes to offset {hex(offset)}')\n    except Exception as e:\n        print(f'Error patching file: {e}')\n\n# Usage:\n# patch_file('benign_crackme.copy.exe', 0x1234, b'\\x90\\x90')"
                }
              ],
                "activities": [
                    {
                        "title": "Patch a Benign Crackme",
                        "description": "Using a simple, benign 'crackme' challenge (a program that asks for a password and says 'Success' or 'Failure'), load it into a debugger. Find the conditional jump that branches to the 'Failure' message. Patch this instruction by overwriting it with `NOP`s. Save the patched executable. Run the new executable and observe that it now always shows the 'Success' message, regardless of the input."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the most important first step before attempting to patch any binary file?",
                        "options": ["Open it in a disassembler.", "Create a backup copy of the original file.", "Run the file to see what it does.", "Rename the file."],
                        "correct": 1,
                        "explanation": "Patching is a destructive operation. If you make a mistake, you can easily corrupt the file, so you must always work on a copy."
                    },
                    {
                        "id": 2,
                        "question": "Overwriting a conditional jump instruction (like `JE` or `JNZ`) with `NOP` instructions is a technique used to:",
                        "options": ["Make the program run faster.", "Force the program to take a specific execution path, effectively bypassing a check.", "Fix a bug in the program.", "Encrypt the program."],
                        "correct": 1,
                        "explanation": "This is a fundamental patching technique. By 'NOPing out' the branch, you force the CPU to simply fall through to the next instruction, as if the condition that would have caused the jump never happened."
                    }
                ]
            }
        },
        {
            "id": "lesson-18",
            "title": "Module 5: Application & Reporting - Automation in Reverse Engineering",
            "duration": "90 min",
            "objectives": [
                "Understand the benefits of scripting and automation for RE tasks.",
                "Learn the basics of scripting in Ghidra (Jython), IDA (IDAPython), and Radare2 (r2pipe).",
                "Write a simple script to automate a repetitive analysis task.",
                "Explore how automation can be used to scale analysis."
            ],
            "content": {
                "overview": "Manually analyzing large, complex binaries can be incredibly time-consuming. Modern reverse engineering platforms all include powerful scripting APIs that allow an analyst to automate repetitive tasks, extract data programmatically, and scale their analysis. This lesson is an introduction to scripting in our core toolset.",
                "sections": [
                    {
                        "title": "Why Automate?",
                        "content": "<p>Scripting allows a defender to:</p><ul><li><strong>Automate Tedious Tasks:</strong> Automatically rename functions, find all XOR loops, or comment every call to a specific API.</li><li><strong>Bulk Analysis:</strong> Write a script that runs on a repository of hundreds of malware samples to automatically extract and compare their configuration data.</li><li><strong>Create Custom Tools:</strong> Build custom logic on top of the disassembler's engine to find unique or complex code patterns that the tool's built-in analysis might miss.</li><li><strong>Integrate with Other Tools:</strong> Send data from the disassembler to other tools or databases programmatically.</li></ul>"
                    },
                    {
                        "title": "Scripting Engines",
                        "content": "<ul><li><strong>Ghidra:</strong> Primarily uses Jython (Python 2.7 running on the JVM) and Java.</li><li><strong>IDA Pro:</strong> Primarily uses IDAPython (can support Python 2 or 3).</li><li><strong>Radare2:</strong> Can be scripted from almost any language via `r2pipe`, which communicates with the Radare2 core over a pipe or HTTP.</li><li><strong>x64dbg:</strong> Has its own scripting language and supports plugins written in C++.</li></ul>"
                    }
                ],
                "codeExamples":[
                {
                    "title": "IDAPython Script to List All Functions",
                    "language": "python",
                    "code": "# A defender uses a script like this as a starting point for more complex automation.\n# This IDAPython script iterates through all the functions identified by IDA and prints their start address and name.\nimport idautils\n\nfor func_ea in idautils.Functions():\n    print(f\"Function {idc.get_func_name(func_ea)} at 0x{func_ea:x}\")"
                },
                {
                    "title": "Ghidra Jython Script to List All Functions",
                    "language": "python",
                    "code": "# This is the Ghidra equivalent of the previous script.\n# A defender would run this in the Ghidra Script Manager to get a quick list of all functions.\n\nfm = currentProgram.getFunctionManager()\nfor func in fm.getFunctions(True): # True means iterate forward\n    print(\"Function {} at {}\".format(func.getName(), func.getEntryPoint()))"
                },
                {
                    "title": "r2pipe Python Script to Analyze and Get Functions",
                    "language": "python",
                    "code": "# A defender uses r2pipe to script Radare2 from a familiar language like Python.\n# This is powerful for building automated analysis pipelines.\nimport r2pipe\n\n# Open the binary and run auto-analysis ('aaa')\nr2 = r2pipe.open(\"./benign_binary\")\nr2.cmd(\"aaa\")\n\n# Get the list of all functions as JSON and print it\nfunctions_json = r2.cmdj(\"aflj\")\nfor func in functions_json:\n    print(f\"Function {func['name']} at offset {hex(func['offset'])}\")\nr2.quit()"
                },
                {
                    "title": "Ghidra Script to find a specific instruction sequence",
                    "language": "python",
                    "code": "# This shows a more advanced use of scripting: pattern matching.\n# A defender uses this to find a specific sequence of assembly instructions that might be\n# characteristic of a particular encryption algorithm or malware family.\n\n# from ghidra.program.model.address import Address\n\n# memory = currentProgram.getMemory()\n# pattern = b\"\\x55\\x8B\\xEC\"\n\n# found_addr = findBytes(Address.toAddr(0), pattern)\n# while found_addr:\n#     print(f\"Found pattern at: {found_addr}\")\n#     found_addr = findBytes(found_addr.add(1), pattern)"
                }
              ],
                "activities": [
                    {
                        "title": "Write a Script to List All Function Calls",
                        "description": "Choose your preferred tool (Ghidra, IDA, or Radare2). Write a script that iterates through all the instructions in the `main` function of a benign binary. If an instruction is a `CALL` instruction, print the address of the instruction and the name of the function being called. This is a foundational task in automated code analysis."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is a major benefit of using the scripting APIs in tools like Ghidra and IDA?",
                        "options": ["It allows for the automation of repetitive analysis tasks, saving time and enabling analysis at scale.", "It makes the disassembler run faster.", "It's the only way to view the disassembly.", "It helps you write new programs."],
                        "correct": 0,
                        "explanation": "Automation is the key benefit. Scripting allows you to codify your analysis logic and apply it consistently to many files or complex tasks."
                    },
                    {
                        "id": 2,
                        "question": "`r2pipe` is a library used to:",
                        "options": ["Analyze network pipes.", "Script the Radare2 reverse engineering framework from other languages, like Python.", "Patch binaries.", "Decompile C++ code."],
                        "correct": 1,
                        "explanation": "`r2pipe` is the primary mechanism for scripting and automating Radare2 from outside the main r2 console."
                    }
                ]
            }
        },
        {
            "id": "lesson-19",
            "title": "Module 5: Application & Reporting - Documenting Findings",
            "duration": "90 min",
            "objectives": [
                "Understand the importance of clear, professional documentation.",
                "Learn the key sections of a reverse engineering report.",
                "Practice writing concise descriptions of a program's functionality.",
                "Discuss the principles of responsible disclosure when sharing findings."
            ],
            "content": {
                "overview": "Reverse engineering isn't complete until the findings are documented. A good report communicates the program's functionality, highlights key discoveries, and provides evidence to support the conclusions. This lesson covers the art of creating a high-quality report.",
                "sections": [
                    {
                        "title": "The RE Report Structure",
                        "content": "<p>While the format can vary, a good report generally includes:</p><ul><li><strong>Executive Summary:</strong> A high-level, non-technical overview. What is this program and what does it do?</li><li><strong>File Information:</strong> Hashes, file size, architecture, and other static properties.</li><li><strong>Functional Description:</strong> A detailed, step-by-step description of the program's core logic, algorithms, and behavior. This is the main body of the report.</li><li><strong>Key Findings:</strong> A bulleted list of the most important discoveries (e.g., 'The program uses a custom XOR-based encryption for its network traffic,' 'Persistence is achieved via a scheduled task').</li><li><strong>Appendices:</strong> Can include things like the full list of strings, a map of the custom data structures you reverse engineered, or key snippets of decompiled code.</li></ul>"
                    },
                    {
                        "title": "Responsible Disclosure",
                        "content": "<p>If you discover a security vulnerability in a piece of software, it's crucial to disclose it responsibly. This typically involves privately contacting the software vendor and giving them a reasonable amount of time to fix the issue before you publish any details publicly. This ensures that users can be protected before the vulnerability is widely known to attackers.</p>"
                    }
                ],
                "codeExamples":[
                {
                    "title": "Generate a Skeleton Report with Python",
                    "language": "python",
                    "code": "# A defender can use a script to automate the creation of a report skeleton.\n# This script takes basic file info and populates a markdown template.\n\ndef create_report_skeleton(file_path, author_name):\n    # Assumes a function `get_file_info(path)` exists that returns hashes, etc.\n    # file_info = get_file_info(file_path)\n    report = f\"\"\"# Reverse Engineering Report: {file_path}\n\n**Author:** {author_name}\n\n## 1. File Information\n- **MD5:** {file_info['md5']}\n- **SHA256:** {file_info['sha256']}\n\n## 2. Functional Description\n\n[...]\n\n## 3. Key Findings\n\n- [...]\n\"\"\"\n    with open('report.md', 'w') as f:\n        f.write(report)\n\nprint('Conceptual code for report generation.')"
                },
                {
                    "title": "Exporting a Graph from IDA Pro",
                    "language": "text",
                    "code": "// This represents a manual action in a tool for documentation.\n// A defender will often export the Control Flow Graph of a key function as an image\n// to include in their report. It provides excellent visual evidence of the code's complexity.\n\n// 1. In IDA Pro, navigate to the desired function.\n// 2. Go to the Graph View window.\n// 3. File -> Print -> Print to file (as .PNG or .SVG)."
                },
                {
                    "title": "Annotating Decompiled Code for a Report",
                    "language": "c",
                    "code": "/*\nA defender will copy/paste decompiled code into their report and add detailed comments\nto explain exactly what is happening. This is much clearer than just showing the raw code.\n*/\n\n// The function begins by calling IsDebuggerPresent to check for an analyst.\nif (IsDebuggerPresent() != 0) {\n    // If a debugger is found, the program immediately terminates.\n    ExitProcess(1);\n}\n// If no debugger, the program proceeds to its main payload...\nmalicious_payload();"
                },
                {
                    "title": "Ghidra Script to Export Comments",
                    "language": "python",
                    "code": "# A defender might use this Ghidra script to export all of their analysis comments\n# into a text file, which can then be easily incorporated into the final report.\n\n# f = currentProgram.getListing().getCommentHistory()\n# with open('ghidra_comments.txt', 'w') as out_file:\n#     for addr, comments in f:\n#         out_file.write(f'--- Comments at {addr} ---\\n')\n#         for comment in comments:\n#             out_file.write(f'- {comment.getComment()}\\n')\nprint('Conceptual code for exporting comments.')"
                }
              ],
                "activities": [
                    {
                        "title": "Document Analysis of a Benign Binary",
                        "description": "Choose a simple but non-trivial benign program (e.g., `whoami.exe` or `ping.exe` from Windows). Perform a basic static and dynamic analysis. Write a short, one-page report that includes the file's hashes, a description of its main function (based on the decompiled code), and a list of the key WinAPI calls it makes to achieve its purpose."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the purpose of the 'Executive Summary' in a reverse engineering report?",
                        "options": ["To list every single instruction in the program.", "To provide a high-level, non-technical overview of the program's purpose and the most important findings.", "To provide the analyst's contact information.", "To contain all the technical details."],
                        "correct": 1,
                        "explanation": "The executive summary is for decision-makers and managers who need to understand the 'so what?' without getting lost in the technical details."
                    },
                    {
                        "id": 2,
                        "question": "If you find a security vulnerability in a company's software, what is the first step in 'responsible disclosure'?",
                        "options": ["Post it on Twitter immediately.", "Sell the information to the highest bidder.", "Privately contact the vendor and give them time to create a patch.", "Ignore it."],
                        "correct": 2,
                        "explanation": "Responsible disclosure prioritizes user safety by giving the vendor a chance to fix the problem before it is publicly announced."
                    }
                ]
            }
        },
        {
            "id": "lesson-20",
            "title": "Module 6: Capstone Project",
            "duration": "180 min",
            "objectives": [
              "Apply the full range of static and dynamic reverse engineering techniques to a novel problem.",
              "Analyze a benign but obfuscated binary to determine its hidden functionality.",
              "Practice bypassing simple anti-reversing techniques.",
              "Produce a comprehensive, professional report detailing the analysis process and findings."
            ],
            "content": {
              "overview": "This final capstone lesson is a practical challenge that integrates all the skills learned throughout the course. You will be given a 'mystery' binary. It is benign, but its true function is hidden by basic obfuscation and anti-analysis tricks. Your job is to reverse engineer it completely and produce a full report.",
              "sections": [
                {
                  "title": "The Challenge Binary",
                  "content": "<p>The capstone binary will be a simple program (e.g., a key validator, a simple encryption tool, or a network client for a custom protocol) that has been modified with techniques from our lessons:</p><ul><li>It will use simple string obfuscation (e.g., XOR).</li><li>It will have a basic anti-debug check (`IsDebuggerPresent`).</li><li>Its control flow may be slightly obfuscated with opaque predicates.</li></ul>"
                },
                {
                  "title": "The Analysis Workflow",
                  "content": "<p>You will need to apply the full RE workflow:</p><ol><li><strong>Static Analysis:</strong> Start with `pefile`, `strings`, and entropy analysis. Load it into Ghidra and study the CFG and decompiled code.</li><li><strong>Dynamic Analysis:</strong> Load it into x64dbg. Find and bypass the anti-debug check. Step through the string deobfuscation loop and observe the plaintext string in memory.</li><li><strong>Correlation:</strong> Correlate your static and dynamic findings. Use the deobfuscated string you found dynamically to make more sense of the decompiled code you saw statically.</li><li><strong>Reporting:</strong> Document your entire journey in a final, professional report.</li></ol>"
                }
              ],
              "codeExamples":[
                {
                    "title": "Capstone: Deobfuscation Script (Python)",
                    "language": "python",
                    "code": "# During the capstone, a defender might identify a custom encoding routine.\n# They would then replicate that routine in Python to deobfuscate data from the binary.\n\ndef deobfuscate_capstone_string(obfuscated_bytes):\n    # Example: a simple rotate-and-XOR routine\n    deobfuscated = bytearray()\n    key = 0x42\n    for byte in obfuscated_bytes:\n        rotated_byte = ((byte << 4) | (byte >> 4)) & 0xFF\n        deobfuscated.append(rotated_byte ^ key)\n    return deobfuscated.decode()\n\n# obfuscated = b'...' # Extracted from the binary\n# print(deobfuscate_capstone_string(obfuscated))"
                },
                {
                    "title": "Capstone: Patching with a Debugger",
                    "language": "text",
                    "code": "// A key step in the capstone is bypassing the anti-debug check.\n// This summarizes the process in x64dbg:\n// 1. Find the call to `IsDebuggerPresent`.\n// 2. Follow the code after the call to find the conditional jump (e.g., `JNZ bad_guy_exit`).\n// 3. To defeat the check, right-click the `JNZ` instruction and 'Assemble'.\n// 4. Replace `JNZ bad_guy_exit` with `JMP good_guy_continue` or simply `NOP` out the jump.\n// 5. This forces the program down the desired execution path."
                },
                {
                    "title": "Capstone: Ghidra Script to Apply Deobfuscation",
                    "language": "python",
                    "code": "# This advanced Ghidra script automates the deobfuscation process found earlier.\n# It reads the obfuscated bytes from the binary, calls the Python deobfuscation function,\n# and then applies the result as a comment in the disassembly, aiding analysis.\n\n# def deobfuscate_and_comment(addr, length):\n#     obfuscated_bytes = getBytes(addr, length)\n#     deobfuscated_string = deobfuscate_capstone_string(obfuscated_bytes)\n#     setEOLComment(addr, f\"Deobfuscated: {deobfuscated_string}\")\n\n# deobfuscate_and_comment(toAddr(0x401050), 20)"
                },
                {
                    "title": "Capstone: Final Report Snippet",
                    "language": "markdown",
                    "code": "### Finding 2: String Obfuscation\n\n**Risk:** Low\n\n**Description:** The program hides all critical strings using a custom encoding routine. Static analysis via the `strings` utility was ineffective. The routine was identified at address `0x401500`. It performs a 4-bit circular rotation followed by a single-byte XOR with the key `0x42`.\n\n**Evidence:** See attached Python script `deobfuscate.py` for a full implementation of the deobfuscation logic."
                }
              ],
              "activities": [
                {
                  "title": "Reverse Engineer the Capstone Binary",
                  "description": "Perform a complete static and dynamic reverse engineering analysis of the provided benign, obfuscated capstone binary. Your goal is to fully understand its hidden purpose. Your final deliverable is a multi-page PDF report that documents your process, how you bypassed the anti-analysis tricks, the program's true functionality, and any key data structures or algorithms you discovered."
                }
              ]
            },
            "quiz": {
              "passingScore": 80,
              "questions": [
                {
                  "id": 1,
                  "question": "If you encounter an obfuscated string during static analysis, what is a good next step to figure out its plaintext value?",
                  "options": ["Guess what the string is.", "Run the program in a debugger, set a breakpoint after the deobfuscation routine, and inspect the memory where the plaintext string is stored.", "Delete the file.", "Ignore the string."],
                  "correct": 1,
                  "explanation": "Dynamic analysis is the key to defeating obfuscation. You let the program decrypt its own data, and then you use the debugger to inspect the result in memory."
                },
                {
                  "id": 2,
                  "question": "What is the ultimate goal of the capstone project?",
                  "options": ["To run the mystery program.", "To prove that you can apply a methodical, multi-faceted analysis process to an unknown binary and produce a professional report on its function.", "To write your own obfuscator.", "To find as many bugs as possible."],
                  "correct": 1,
                  "explanation": "The capstone is a test of the entire reverse engineering process, from initial static analysis to dynamic debugging and, most importantly, clear and effective documentation of the findings."
                }
              ]
            }
        }
    ]
};

// =====================================================
// GLOBAL VARIABLES
// =====================================================
let currentUser = null;
let currentLessonIndex = 0;
let courseProgress = {};
let userStats = {};
let quizState = {
    currentQuestion: 0,
    answers: [],
    score: 0,
    isComplete: false
};

// Enhanced session tracking
let courseSession = {
    startTime: null,
    totalStudyTime: 0,
    lessonsStarted: 0,
    lessonsCompleted: 0,
    pageLoadTime: new Date(),
    interactionCount: 0,
    lastActivityTime: new Date()
};

// Music Player Variables
let audioPlayer = new Audio();

// Achievement notification system
let notificationQueue = [];
let isShowingNotification = false;

// =====================================================
// INITIALIZATION
// =====================================================
document.addEventListener('DOMContentLoaded', async () => {
    try {
        showLoadingScreen();
        await checkAuth();
        
        if (currentUser) {
            // Initialize session tracking
            startCourseSession();
            
            // Load course data and progress
            await loadCourseData();
            await loadUserProfile();
            await loadProgress();
            
            // Initialize UI
            initializeEventListeners();
            renderSidebar();
            loadLesson(currentLessonIndex);
            
            // Initialize additional features
            initMusicPlayer();
            addMusicIndicator();
            initializeActivityTracking();
            
            hideLoadingScreen();
        } else {
            openAuthModal();
        }
    } catch (error) {
        console.error('Error initializing course:', error);
        hideLoadingScreen();
        showToast('Failed to initialize course system', 'error');
    }
});

// =====================================================
// AUTHENTICATION SYSTEM
// =====================================================
async function checkAuth() {
    try {
        const { data: { session }, error } = await supabase.auth.getSession();
        
        if (error) {
            console.error('Auth error:', error);
            currentUser = null;
            openAuthModal();
            return;
        }

        if (!session) {
            currentUser = null;
            openAuthModal();
            return;
        }

        currentUser = session.user;
        updateUIWithUser();
    } catch (error) {
        console.error('Error checking auth:', error);
        currentUser = null;
        openAuthModal();
    }
}

function updateUIWithUser() {
    if (!currentUser) return;
    
    const name = currentUser.user_metadata?.full_name || currentUser.email.split('@')[0];
    const userElements = document.querySelectorAll('[data-user-name]');
    userElements.forEach(el => el.textContent = name);
}

// =====================================================
// USER PROFILE & STATS MANAGEMENT
// =====================================================
async function loadUserProfile() {
  try {
    // 🔍 Step 1: Try to fetch existing profile
    const { data: profile, error } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', currentUser.id)
      .single();

    if (error && error.code !== 'PGRST116') {
      throw error;
    }

    if (!profile) {
      // 🆕 Step 2: Create new profile if missing
      await createUserProfile();
    } else {
      // ✅ Step 3: Use existing profile
      userStats = profile;
      await updateLastActivity();
    }

  } catch (error) {
    console.error('❌ Error loading user profile:', error);
    showToast('Failed to load user profile', 'error');
  }
}
async function createUserProfile() {
    try {
        const newProfile = {
            id: currentUser.id,
            full_name: currentUser.user_metadata?.full_name || '',
            email: currentUser.email,
            level: 'Script Kiddie',
            total_points: 0,
            completed_courses: 0,
            current_streak: 0,
            total_certificates: 0,
            total_achievements: 0,
            sections_visited: 0,
            bonus_points: 0,
            in_progress_courses: 0,
            settings_changed: 0,
            midnight_sessions: 0,
            early_sessions: 0,
            weekend_sessions: 0,
            last_activity: new Date().toISOString(),
            created_at: new Date().toISOString()
        };

        const { error } = await supabase
            .from('profiles')
            .insert([newProfile]);

        if (!error) {
            userStats = newProfile;
            // Award first login achievement
            setTimeout(() => checkAndUnlockAchievement('first_login'), 1000);
        }
    } catch (error) {
        console.error('Error creating user profile:', error);
    }
}

async function updateLastActivity() {
    try {
        const now = new Date();
        
        // Update activity tracking
        courseSession.lastActivityTime = now;
        
        // Update database
        await supabase
            .from('profiles')
            .update({ 
                last_activity: now.toISOString()
            })
            .eq('id', currentUser.id);

        // Check time-based achievements
        await checkTimeBasedAchievements(now);
        
    } catch (error) {
        console.error('Error updating last activity:', error);
    }
}

// =====================================================
// COURSE SESSION MANAGEMENT
// =====================================================
function startCourseSession() {
    courseSession.startTime = new Date();
    courseSession.pageLoadTime = new Date();
    
    logUserActivity('course_session_start', {
        course_id: COURSE_DATA.id,
        course_title: COURSE_DATA.title,
        user_agent: navigator.userAgent,
        screen_resolution: `${screen.width}x${screen.height}`
    });
    
    // Check daily streak
    checkDailyStreak();
}

function initializeActivityTracking() {
    // Track page focus/blur for accurate study time
    document.addEventListener('visibilitychange', handleVisibilityChange);
    
    // Track user interactions
    ['click', 'keydown', 'scroll', 'mousemove'].forEach(event => {
        document.addEventListener(event, trackUserInteraction, { passive: true });
    });
    
    // Periodic activity updates
    setInterval(updateStudyTime, 60000); // Every minute
    
    // Save session data before page unload
    window.addEventListener('beforeunload', saveSessionData);
}

function handleVisibilityChange() {
    if (document.hidden) {
        courseSession.lastActivityTime = new Date();
    } else {
        // Page became visible again - update activity
        updateLastActivity();
    }
}

function trackUserInteraction() {
    courseSession.interactionCount++;
    courseSession.lastActivityTime = new Date();
    
    // Throttle activity updates
    if (courseSession.interactionCount % 50 === 0) {
        updateLastActivity();
    }
}

function updateStudyTime() {
    if (!courseSession.startTime || document.hidden) return;
    
    const now = new Date();
    const sessionDuration = now - courseSession.startTime;
    courseSession.totalStudyTime = Math.floor(sessionDuration / 1000 / 60); // in minutes
    
    // Update progress with study time
    saveProgress();
}

function saveSessionData() {
    if (!currentUser || !courseSession.startTime) return;
    
    const sessionData = {
        user_id: currentUser.id,
        course_id: COURSE_DATA.id,
        session_duration: courseSession.totalStudyTime,
        lessons_viewed: courseSession.lessonsStarted,
        lessons_completed: courseSession.lessonsCompleted,
        interactions: courseSession.interactionCount,
        session_date: courseSession.startTime.toISOString().split('T')[0]
    };
    
    // Store in localStorage as backup
    localStorage.setItem('course_session_backup', JSON.stringify(sessionData));
    
    // Try to save to database
    logUserActivity('course_session_end', sessionData);
}

// =====================================================
// COURSE DATA & PROGRESS MANAGEMENT
// =====================================================
async function loadCourseData() {
    try {
        // Update course info in UI
        document.getElementById('courseTitle').textContent = COURSE_DATA.title;
        document.getElementById('totalLessons').textContent = COURSE_DATA.lessons.length;
        
        // Log course access
        logUserActivity('course_access', {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title
        });
        
    } catch (error) {
        console.error('Error loading course data:', error);
    }
}

async function loadProgress() {
    try {
        // Get existing progress from database
        const { data, error } = await supabase
            .from('course_progress')
            .select('*')
            .eq('user_id', currentUser.id)
            .eq('course_id', COURSE_DATA.id)
            .single();

        if (error && error.code !== 'PGRST116') {
            throw error;
        }

        if (data) {
            courseProgress = JSON.parse(data.lesson_progress || '{}');
            currentLessonIndex = data.current_lesson || 0;
            
            // Update session tracking
            courseSession.lessonsStarted = Object.keys(courseProgress).length;
            courseSession.lessonsCompleted = Object.values(courseProgress).filter(p => p.completed).length;
        } else {
            // Initialize new progress
            courseProgress = {};
            currentLessonIndex = 0;
            await saveProgress();
            
            // Award first course start achievement
            await checkAndUnlockAchievement('first_course_start');
        }

        updateProgressDisplay();
        
    } catch (error) {
        console.error('Error loading progress:', error);
        showToast('Failed to load progress', 'error');
    }
}

async function saveProgress() {
    try {
        if (!currentUser) return;

        const now = new Date();
        const progressData = {
            user_id: currentUser.id,
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            current_lesson: currentLessonIndex,
            lesson_progress: JSON.stringify(courseProgress),
            progress: calculateOverallProgress(),
            lessons_completed: getCompletedLessonsCount(),
            lessons_started: Object.keys(courseProgress).length,
            study_time_minutes: courseSession.totalStudyTime,
            last_accessed: now.toISOString(),
            updated_at: now.toISOString()
        };

        // Upsert progress
        const { error } = await supabase
            .from('course_progress')
            .upsert([progressData]);

        if (error) throw error;

        // Update user stats
        await updateUserStats();
        
        updateProgressDisplay();

    } catch (error) {
        console.error('Error saving progress:', error);
        showToast('Failed to save progress', 'error');
    }
}

async function updateUserStats() {
    try {
        // Get all course progress for this user
        const { data: allProgress, error } = await supabase
            .from('course_progress')
            .select('progress, course_id, study_time_minutes')
            .eq('user_id', currentUser.id);

        if (error) throw error;

        // Calculate stats
        const completedCourses = allProgress?.filter(p => p.progress >= 100).length || 0;
        const inProgressCourses = allProgress?.filter(p => p.progress > 0 && p.progress < 100).length || 0;
        const totalStudyTime = allProgress?.reduce((sum, p) => sum + (p.study_time_minutes || 0), 0) || 0;

        // Calculate points (500 per completed course + achievement points)
        const coursePoints = completedCourses * 500;
        const bonusPoints = userStats.bonus_points || 0;
        const totalPoints = coursePoints + bonusPoints;

        // Update profile
        const updateData = {
            completed_courses: completedCourses,
            in_progress_courses: inProgressCourses,
            total_points: totalPoints,
            total_study_time: totalStudyTime,
            last_activity: new Date().toISOString()
        };

        const { error: updateError } = await supabase
            .from('profiles')
            .update(updateData)
            .eq('id', currentUser.id);

        if (updateError) throw updateError;

        // Update local stats
        Object.assign(userStats, updateData);

    } catch (error) {
        console.error('Error updating user stats:', error);
    }
}

function calculateOverallProgress() {
    const completedLessons = getCompletedLessonsCount();
    return Math.round((completedLessons / COURSE_DATA.lessons.length) * 100);
}

function getCompletedLessonsCount() {
    return Object.values(courseProgress).filter(lesson => lesson.completed).length;
}

function updateProgressDisplay() {
    const completedCount = getCompletedLessonsCount();
    const progressPercent = calculateOverallProgress();
    
    // Update UI elements
    const elements = {
        'completedLessons': completedCount,
        'courseProgressPercent': `${progressPercent}%`
    };
    
    Object.entries(elements).forEach(([id, value]) => {
        const element = document.getElementById(id);
        if (element) element.textContent = value;
    });
    
    // Update progress bar
    const progressBar = document.getElementById('courseProgressFill');
    if (progressBar) progressBar.style.width = `${progressPercent}%`;
}

// =====================================================
// LESSON MANAGEMENT
// =====================================================
function loadLesson(index) {
    if (index < 0 || index >= COURSE_DATA.lessons.length) return;

    const lesson = COURSE_DATA.lessons[index];
    currentLessonIndex = index;

    // Mark lesson as started and track activity
    if (!courseProgress[lesson.id]) {
        courseProgress[lesson.id] = { 
            started: true, 
            completed: false,
            startedAt: new Date().toISOString(),
            timeSpent: 0
        };
        
        courseSession.lessonsStarted++;
        saveProgress();
        
        // Log lesson start
        logUserActivity('lesson_start', {
            lesson_id: lesson.id,
            lesson_title: lesson.title,
            lesson_index: index
        });
    }

    // Update lesson start time for time tracking
    courseProgress[lesson.id].currentSessionStart = new Date();

    // Update sidebar and navigation
    renderSidebar();
    updateNavigationButtons();

    // Update header info
    updateLessonHeader(lesson, index);

    // Render lesson content
    renderLessonContent(lesson);

    // Smooth scroll and animations
    window.scrollTo({ top: 0, behavior: 'smooth' });
    document.getElementById('contentBody').scrollTop = 0;

    const contentBody = document.getElementById('contentBody');
    contentBody.classList.add('fade-in');
    setTimeout(() => contentBody.classList.remove('fade-in'), 500);
    
    // Check lesson-based achievements
    checkLessonAchievements(index + 1);
}

function updateLessonHeader(lesson, index) {
    const elements = {
        'currentLessonNumber': index + 1,
        'currentLessonTitle': lesson.title,
        'navInfo': `Lesson ${index + 1} of ${COURSE_DATA.lessons.length}`
    };
    
    Object.entries(elements).forEach(([id, value]) => {
        const element = document.getElementById(id);
        if (element) element.textContent = value;
    });
}

function renderSidebar() {
    const lessonNav = document.getElementById('lessonNav');
    if (!lessonNav) return;
    
    lessonNav.innerHTML = '';

    COURSE_DATA.lessons.forEach((lesson, index) => {
        const lessonItem = document.createElement('div');
        lessonItem.className = 'lesson-item';
        
        // Determine lesson status
        const lessonProgress = courseProgress[lesson.id];
        const isCompleted = lessonProgress?.completed || false;
        const isInProgress = lessonProgress?.started || false;
        const isLocked = !isCompleted && !canAccessLesson(index);
        const isActive = index === currentLessonIndex;

        // Apply status classes
        if (isCompleted) lessonItem.classList.add('completed');
        if (isLocked) lessonItem.classList.add('locked');
        if (isActive) lessonItem.classList.add('active');

        // Determine status display
        let statusClass = 'not-started';
        let statusIcon = index + 1;
        
        if (isCompleted) {
            statusClass = 'completed';
            statusIcon = '✓';
        } else if (isInProgress) {
            statusClass = 'in-progress';
            statusIcon = '◐';
        }

        // Create lesson item HTML
        lessonItem.innerHTML = `
            <div class="lesson-status ${statusClass}">${statusIcon}</div>
            <div class="lesson-info">
                <div class="lesson-title">${lesson.title}</div>
                <div class="lesson-meta">
                    ${isCompleted ? 'Completed' : 
                      isInProgress ? 'In Progress' : 
                      isLocked ? 'Locked' : 'Not Started'}
                </div>
            </div>
            <div class="lesson-duration">${lesson.duration}</div>
        `;

        // Add click handler if not locked
        if (!isLocked) {
            lessonItem.addEventListener('click', () => {
                if (index !== currentLessonIndex) {
                    // Track lesson time before switching
                    trackLessonTime();
                    
                    currentLessonIndex = index;
                    loadLesson(index);
                    closeSidebar();
                }
            });
        }

        lessonNav.appendChild(lessonItem);
    });
}

function canAccessLesson(index) {
    if (index === 0) return true; // First lesson always accessible
    
    // Can access if previous lesson is completed
    const previousLessonId = COURSE_DATA.lessons[index - 1].id;
    return courseProgress[previousLessonId]?.completed || false;
}

function trackLessonTime() {
    const currentLesson = COURSE_DATA.lessons[currentLessonIndex];
    const lessonProgress = courseProgress[currentLesson.id];
    
    if (lessonProgress?.currentSessionStart) {
        const sessionTime = Math.floor((new Date() - new Date(lessonProgress.currentSessionStart)) / 1000 / 60);
        lessonProgress.timeSpent = (lessonProgress.timeSpent || 0) + sessionTime;
        delete lessonProgress.currentSessionStart;
    }
}

// =====================================================
// LESSON CONTENT RENDERING
// =====================================================
function renderLessonContent(lesson) {
    const contentContainer = document.getElementById('lessonContent');
    if (!contentContainer) return;
    
    let contentHTML = `
        <div class="content-section">
            <h2>Learning Objectives</h2>
            <ul>
                ${lesson.objectives.map(obj => `<li>${obj}</li>`).join('')}
            </ul>
        </div>
        
        <div class="content-section">
            <h2>Overview</h2>
            <p>${lesson.content.overview}</p>
        </div>
    `;

    // Render content sections
    lesson.content.sections.forEach(section => {
        contentHTML += `
            <div class="content-section">
                <h2>${section.title}</h2>
                ${section.content}
                ${section.image ? `<img src="${section.image}" alt="${section.title}" class="content-image" loading="lazy">` : ''}
            </div>
        `;
    });

    // Render code examples
    if (lesson.content.codeExamples && lesson.content.codeExamples.length > 0) {
        contentHTML += `<div class="content-section"><h2>Code Examples</h2></div>`;
        
        lesson.content.codeExamples.forEach((example, index) => {
            const codeId = `code-${lesson.id}-${index}`;
            contentHTML += `
                <div class="code-section">
                    <div class="code-header">
                        <span class="code-title">${example.title}</span>
                        <button class="copy-btn" onclick="copyCode('${codeId}')">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <pre class="code-block"><code id="${codeId}" class="language-${example.language}">${escapeHtml(example.code)}</code></pre>
                </div>
            `;
        });
    }

    // Render quiz
    contentHTML += renderQuiz(lesson.quiz);

    contentContainer.innerHTML = contentHTML;

    // Highlight code syntax if Prism is available
    setTimeout(() => {
        if (window.Prism) {
            Prism.highlightAll();
        }
    }, 100);
}

// =====================================================
// QUIZ SYSTEM
// =====================================================
function renderQuiz(quiz) {
    const currentLessonProgress = courseProgress[COURSE_DATA.lessons[currentLessonIndex].id];
    const isCompleted = currentLessonProgress?.completed || false;
    
    let quizHTML = `
        <div class="quiz-section" id="quizSection">
            <div class="quiz-header">
                <h2 class="quiz-title">
                    <i class="fas fa-clipboard-check"></i>
                    Knowledge Check
                </h2>
                <p class="quiz-info">
                    Complete this quiz with ${quiz.passingScore}% or higher to unlock the next lesson.
                </p>
            </div>
    `;

    if (isCompleted) {
        const savedScore = currentLessonProgress.quizScore || 0;
        quizHTML += `
            <div class="quiz-results show">
                <div class="quiz-score pass">${savedScore}%</div>
                <div class="quiz-message">
                    <strong>Lesson Completed!</strong><br>
                    You've successfully passed this lesson's quiz.
                </div>
            </div>
        `;
    } else {
        // Render quiz questions
        quiz.questions.forEach((question, qIndex) => {
            quizHTML += `
                <div class="quiz-question ${qIndex === 0 ? 'active' : ''}" data-question="${qIndex}">
                    <div class="question-header">
                        <span class="question-number">Question ${qIndex + 1}</span>
                        <span class="question-progress">${qIndex + 1}/${quiz.questions.length}</span>
                    </div>
                    <div class="question-text">${question.question}</div>
                    <div class="question-options">
                        ${question.options.map((option, oIndex) => `
                            <div class="option" data-option="${oIndex}" onclick="selectOption(${qIndex}, ${oIndex})">
                                <span class="option-letter">${String.fromCharCode(65 + oIndex)}</span>
                                <span class="option-text">${option}</span>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        });

        quizHTML += `
            <div class="quiz-controls">
                <button class="btn btn-secondary" id="prevQuestionBtn" onclick="previousQuestion()" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <div>
                    <button class="btn btn-secondary" id="nextQuestionBtn" onclick="nextQuestion()" disabled>
                        Next
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <button class="btn btn-primary" id="submitQuizBtn" onclick="submitQuiz()" style="display: none;">
                        <i class="fas fa-check"></i>
                        Submit Quiz
                    </button>
                </div>
            </div>

            <div class="quiz-results" id="quizResults">
                <div class="quiz-score" id="quizScore">0%</div>
                <div class="quiz-message" id="quizMessage"></div>
                <div class="quiz-actions">
                    <button class="btn btn-primary" id="continueBtn" onclick="completeLesson()" style="display: none;">
                        <i class="fas fa-arrow-right"></i>
                        Continue to Next Lesson
                    </button>
                    <button class="btn btn-secondary" onclick="retakeQuiz()">
                        <i class="fas fa-redo"></i>
                        Retake Quiz
                    </button>
                </div>
            </div>
        `;
    }

    quizHTML += '</div>';
    return quizHTML;
}

// Quiz interaction functions
function selectOption(questionIndex, optionIndex) {
    // Clear previous selections
    document.querySelectorAll(`[data-question="${questionIndex}"] .option`).forEach(opt => {
        opt.classList.remove('selected');
    });

    // Select current option
    const selectedOption = document.querySelector(`[data-question="${questionIndex}"] [data-option="${optionIndex}"]`);
    selectedOption.classList.add('selected');

    // Store answer
    quizState.answers[questionIndex] = optionIndex;

    // Update navigation
    const isLastQuestion = questionIndex === COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length - 1;
    if (isLastQuestion) {
        document.getElementById('submitQuizBtn').style.display = 'inline-flex';
        document.getElementById('nextQuestionBtn').style.display = 'none';
    } else {
        document.getElementById('nextQuestionBtn').disabled = false;
    }
}

function nextQuestion() {
    const currentQuestionEl = document.querySelector('.quiz-question.active');
    const nextQuestionEl = currentQuestionEl.nextElementSibling;
    
    if (nextQuestionEl && nextQuestionEl.classList.contains('quiz-question')) {
        currentQuestionEl.classList.remove('active');
        nextQuestionEl.classList.add('active');
        quizState.currentQuestion++;
        updateQuizNavigation();
    }
}

function previousQuestion() {
    const currentQuestionEl = document.querySelector('.quiz-question.active');
    const prevQuestionEl = currentQuestionEl.previousElementSibling;
    
    if (prevQuestionEl && prevQuestionEl.classList.contains('quiz-question')) {
        currentQuestionEl.classList.remove('active');
        prevQuestionEl.classList.add('active');
        quizState.currentQuestion--;
        updateQuizNavigation();
    }
}

function updateQuizNavigation() {
    const totalQuestions = COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length;
    const prevBtn = document.getElementById('prevQuestionBtn');
    const nextBtn = document.getElementById('nextQuestionBtn');
    const submitBtn = document.getElementById('submitQuizBtn');

    prevBtn.disabled = quizState.currentQuestion === 0;
    
    const hasAnswer = quizState.answers[quizState.currentQuestion] !== undefined;
    const isLastQuestion = quizState.currentQuestion === totalQuestions - 1;
    
    if (isLastQuestion) {
        nextBtn.style.display = 'none';
        submitBtn.style.display = hasAnswer ? 'inline-flex' : 'none';
    } else {
        nextBtn.style.display = 'inline-flex';
        nextBtn.disabled = !hasAnswer;
        submitBtn.style.display = 'none';
    }
}

async function submitQuiz() {
    const lesson = COURSE_DATA.lessons[currentLessonIndex];
    const quiz = lesson.quiz;
    let correctAnswers = 0;

    // Hide questions and controls
    document.querySelectorAll('.quiz-question').forEach(q => q.style.display = 'none');
    document.querySelector('.quiz-controls').style.display = 'none';

    // Calculate score and highlight answers
    quiz.questions.forEach((question, index) => {
        const userAnswer = quizState.answers[index];
        const correctAnswer = question.correct;
        const isCorrect = userAnswer === correctAnswer;
        
        if (isCorrect) correctAnswers++;

        // Highlight answers
        const questionEl = document.querySelector(`[data-question="${index}"]`);
        const options = questionEl.querySelectorAll('.option');
        
        options[correctAnswer].classList.add('correct');
        if (userAnswer !== correctAnswer && userAnswer !== undefined) {
            options[userAnswer].classList.add('incorrect');
        }
    });

    const score = Math.round((correctAnswers / quiz.questions.length) * 100);
    const passed = score >= quiz.passingScore;

    // Update quiz results UI
    const quizScore = document.getElementById('quizScore');
    const quizMessage = document.getElementById('quizMessage');
    const quizActions = document.querySelector('.quiz-actions');

    quizScore.textContent = `${score}%`;
    quizScore.className = `quiz-score ${passed ? 'pass' : 'fail'}`;

    if (passed) {
        quizMessage.innerHTML = `
            <strong>Congratulations!</strong><br>
            You passed with ${score}%. You can now proceed to the next lesson.
        `;
        
        quizActions.innerHTML = `
            <button class="btn btn-primary" onclick="completeLesson()">
                <i class="fas fa-arrow-right"></i>
                Continue to Next Lesson
            </button>
        `;
        
        // Mark lesson as completed
        await markLessonComplete(score);
        
    } else {
        quizMessage.innerHTML = `
            <strong>Not quite there yet.</strong><br>
            You scored ${score}%. You need ${quiz.passingScore}% to pass. Review the material and try again.
        `;
        
        quizActions.innerHTML = `
            <button class="btn btn-secondary" onclick="retakeQuiz()">
                <i class="fas fa-redo"></i>
                Retake Quiz
            </button>
        `;
    }

    document.getElementById('quizResults').classList.add('show');
    
    // Log quiz completion
    logUserActivity('quiz_completed', {
        lesson_id: lesson.id,
        lesson_title: lesson.title,
        score: score,
        passed: passed,
        attempts: (courseProgress[lesson.id]?.quizAttempts || 0) + 1
    });

    // Scroll to results
    document.getElementById('quizResults').scrollIntoView({ behavior: 'smooth' });
}

function retakeQuiz() {
    // Reset quiz state
    quizState = {
        currentQuestion: 0,
        answers: [],
        score: 0,
        isComplete: false
    };

    // Track quiz retry
    const lessonId = COURSE_DATA.lessons[currentLessonIndex].id;
    if (!courseProgress[lessonId]) courseProgress[lessonId] = {};
    courseProgress[lessonId].quizAttempts = (courseProgress[lessonId].quizAttempts || 0) + 1;

    // Reload lesson content
    loadLesson(currentLessonIndex);
    
    // Scroll to quiz
    setTimeout(() => {
        document.getElementById('quizSection').scrollIntoView({ behavior: 'smooth' });
    }, 500);
}

async function markLessonComplete(score) {
    const lesson = COURSE_DATA.lessons[currentLessonIndex];
    const lessonId = lesson.id;
    
    // Track lesson completion time
    trackLessonTime();
    
    // Update lesson progress
    courseProgress[lessonId] = {
        ...courseProgress[lessonId],
        completed: true,
        quizScore: score,
        completedAt: new Date().toISOString(),
        finalScore: score
    };

    // Update session tracking
    courseSession.lessonsCompleted++;

    // Save progress to database
    await saveProgress();
    
    // Update UI
    renderSidebar();
    updateNavigationButtons();

    // Check various achievements
    await checkLessonCompletionAchievements();
    await checkPerfectScoreAchievements(score);
    await checkStudyTimeAchievements();
    
    // Log lesson completion
    logUserActivity('lesson_completed', {
        lesson_id: lessonId,
        lesson_title: lesson.title,
        final_score: score,
        time_spent: courseProgress[lessonId].timeSpent || 0,
        lesson_number: currentLessonIndex + 1
    });
    
    showToast('Lesson completed successfully!', 'success');
}

async function completeLesson() {
    if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
        // Move to next lesson
        currentLessonIndex++;
        loadLesson(currentLessonIndex);
        
    } else {
        // Course completion
        await completeCourse();
    }
}

async function completeCourse() {
    try {
        const completionTime = courseSession.totalStudyTime;
        
        // Update course progress to 100% completed
        await supabase
            .from('course_progress')
            .update({
                progress: 100,
                completed_at: new Date().toISOString(),
                completion_time_minutes: completionTime
            })
            .eq('user_id', currentUser.id)
            .eq('course_id', COURSE_DATA.id);

        // Award course completion achievements
        await checkAndUnlockAchievement('course_completion_1');
        await checkSpeedCompletionAchievements(completionTime);
        await checkCourseStreakAchievements();
        
        // Update user stats
        await updateUserStats();
        
        // Show completion message
        showToast('Congratulations! Course completed successfully!', 'certificate');
        
        // Log course completion
        logUserActivity('course_completed', {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            completion_time_minutes: completionTime,
            total_lessons: COURSE_DATA.lessons.length,
            average_quiz_score: calculateAverageQuizScore()
        });
        
        // Redirect to dashboard after delay
        setTimeout(() => {
            window.location.href = '/dashboard.html';
        }, 3000);
        
    } catch (error) {
        console.error('Error completing course:', error);
        showToast('Error marking course as complete', 'error');
    }
}

// =====================================================
// ACHIEVEMENT INTEGRATION SYSTEM
// =====================================================
async function checkAndUnlockAchievement(achievementId, skipNotification = false) {
    try {
        // Prevent duplicate checks
        const cacheKey = `achievement_${achievementId}_${currentUser.id}`;
        if (sessionStorage.getItem(cacheKey)) return false;

        // Check if already unlocked
        const { data: existing, error } = await supabase
            .from('user_achievements')
            .select('id')
            .eq('user_id', currentUser.id)
            .eq('achievement_id', achievementId)
            .single();

        if (existing) {
            sessionStorage.setItem(cacheKey, 'true');
            return false;
        }

        // Award achievement
        const achievementData = {
            user_id: currentUser.id,
            achievement_id: achievementId,
            unlocked_at: new Date().toISOString(),
            points_awarded: getAchievementPoints(achievementId),
            context: 'course_system'
        };

        const { data, error: insertError } = await supabase
            .from('user_achievements')
            .insert([achievementData])
            .select()
            .single();

        if (insertError) {
            if (insertError.code === '23505') return false; // Already exists
            throw insertError;
        }

        // Update user points
       await supabase.rpc('increment_user_stats', {
  user_id_param: currentUser.id,
  points_to_add: achievementData.points_awarded,
  achievements_to_add: 1
});

        // Cache and queue notification
        sessionStorage.setItem(cacheKey, 'true');
        
        if (!skipNotification) {
            queueAchievementNotification({
                id: achievementId,
                name: getAchievementName(achievementId),
                description: getAchievementDescription(achievementId),
                points: achievementData.points_awarded,
                rarity: getAchievementRarity(achievementId),
                icon: getAchievementIcon(achievementId)
            });
        }

        return true;

    } catch (error) {
        console.error('Error unlocking achievement:', error);
        return false;
    }
}

// Helper functions for achievement data (replace with your actual achievement definitions)
function getAchievementPoints(id) {
    const pointsMap = {
        'first_course_start': 75,
        'first_lesson': 100,
        'course_completion_1': 500,
        'perfect_score': 250,
        'speed_demon': 750,
        'marathon_learner': 500,
        'night_owl': 200,
        'early_bird': 200,
        'weekend_warrior': 150,
        // Add more as needed
    };
    return pointsMap[id] || 100;
}

function getAchievementName(id) {
    const nameMap = {
        'first_course_start': 'Learning Initiated',
        'first_lesson': 'First Steps',
        'course_completion_1': 'Course Conqueror',
        'perfect_score': 'Perfectionist',
        'speed_demon': 'Speed Demon',
        // Add more as needed
    };
    return nameMap[id] || 'Achievement Unlocked';
}

function getAchievementDescription(id) {
    const descMap = {
        'first_course_start': 'Start your first cybersecurity course',
        'first_lesson': 'Complete your first lesson',
        'course_completion_1': 'Complete your first course',
        'perfect_score': 'Score 100% on any quiz',
        'speed_demon': 'Complete a course in under 2 hours',
        // Add more as needed
    };
    return descMap[id] || 'Achievement description';
}

function getAchievementRarity(id) {
    const rarityMap = {
        'first_course_start': 'common',
        'first_lesson': 'bronze',
        'course_completion_1': 'silver',
        'perfect_score': 'gold',
        'speed_demon': 'legendary',
        // Add more as needed
    };
    return rarityMap[id] || 'common';
}

function getAchievementIcon(id) {
    const iconMap = {
        'first_course_start': 'fas fa-play',
        'first_lesson': 'fas fa-baby',
        'course_completion_1': 'fas fa-trophy',
        'perfect_score': 'fas fa-star',
        'speed_demon': 'fas fa-rocket',
        // Add more as needed
    };
    return iconMap[id] || 'fas fa-award';
}

async function checkLessonAchievements(lessonNumber) {
    if (lessonNumber === 1) {
        await checkAndUnlockAchievement('first_lesson');
    }
    
    // Check if user has completed multiple lessons in one day
    const today = new Date().toISOString().split('T')[0];
    const todayCompletions = Object.values(courseProgress).filter(p => 
        p.completed && p.completedAt?.startsWith(today)
    ).length;
    
    if (todayCompletions >= 3) {
        await checkAndUnlockAchievement('lesson_marathon');
    }
}

async function checkLessonCompletionAchievements() {
    const completedCount = getCompletedLessonsCount();
    
    // Lesson-based achievements
    const lessonMilestones = [1, 5, 10, 25, 50, 100];
    for (const milestone of lessonMilestones) {
        if (completedCount >= milestone) {
            await checkAndUnlockAchievement(`lessons_${milestone}`);
        }
    }
    
    // Course completion achievements
    if (completedCount === COURSE_DATA.lessons.length) {
        await checkAndUnlockAchievement('course_completion_1');
        
        // Check for additional course completion achievements
        const { data: allCourses } = await supabase
            .from('course_progress')
            .select('course_id')
            .eq('user_id', currentUser.id)
            .eq('progress', 100);
        
        const totalCompleted = allCourses?.length || 0;
        
        const courseMilestones = [1, 5, 10, 25];
        for (const milestone of courseMilestones) {
            if (totalCompleted >= milestone) {
                await checkAndUnlockAchievement(`course_completion_${milestone}`);
            }
        }
    }
}

async function checkPerfectScoreAchievements(score) {
    if (score === 100) {
        await checkAndUnlockAchievement('perfect_score');
        
        // Check for consecutive perfect scores
        const recentScores = Object.values(courseProgress)
            .filter(p => p.completed && p.quizScore)
            .slice(-5) // Last 5 completed
            .map(p => p.quizScore);
        
        if (recentScores.length >= 3 && recentScores.every(s => s === 100)) {
            await checkAndUnlockAchievement('perfectionist_streak');
        }
    }
}

async function checkSpeedCompletionAchievements(completionTime) {
    // Speed demon: Complete course in under 2 hours (120 minutes)
    if (completionTime <= 120) {
        await checkAndUnlockAchievement('speed_demon');
    }
    
    // Quick learner: Complete course in under 4 hours (240 minutes)
    if (completionTime <= 240) {
        await checkAndUnlockAchievement('quick_learner');
    }
}

async function checkStudyTimeAchievements() {
    const totalTime = courseSession.totalStudyTime;
    
    // Marathon learner: Study for 8+ hours in a course session
    if (totalTime >= 480) { // 8 hours
        await checkAndUnlockAchievement('marathon_learner');
    }
    
    // Dedicated learner: Study for 4+ hours
    if (totalTime >= 240) { // 4 hours
        await checkAndUnlockAchievement('dedicated_learner');
    }
}

async function checkCourseStreakAchievements() {
    try {
        // Check for consecutive course completions
        const { data: recentCourses, error } = await supabase
            .from('course_progress')
            .select('completed_at, course_id')
            .eq('user_id', currentUser.id)
            .eq('progress', 100)
            .order('completed_at', { ascending: false })
            .limit(10);

        if (error || !recentCourses) return;

        // Check for courses completed on consecutive days
        let consecutiveDays = 1;
        for (let i = 1; i < recentCourses.length; i++) {
            const prevDate = new Date(recentCourses[i-1].completed_at).toDateString();
            const currentDate = new Date(recentCourses[i].completed_at).toDateString();
            const dayDiff = Math.abs(new Date(prevDate) - new Date(currentDate)) / (1000 * 60 * 60 * 24);
            
            if (dayDiff <= 1) {
                consecutiveDays++;
            } else {
                break;
            }
        }

        if (consecutiveDays >= 3) {
            await checkAndUnlockAchievement('learning_streak');
        }

    } catch (error) {
        console.error('Error checking course streak achievements:', error);
    }
}

// =====================================================
// TIME-BASED ACHIEVEMENTS
// =====================================================
async function checkTimeBasedAchievements(timestamp) {
    const hour = timestamp.getHours();
    const dayOfWeek = timestamp.getDay();

    // Night owl (after midnight, before 6 AM)
    if (hour >= 0 && hour < 6) {
        await incrementTimeBasedCounter('midnight_sessions', 'night_owl');
    }

    // Early bird (4 AM to 6 AM)
    if (hour >= 4 && hour < 6) {
        await incrementTimeBasedCounter('early_sessions', 'early_bird');
    }

    // Weekend warrior (Saturday = 6, Sunday = 0)
    if (dayOfWeek === 0 || dayOfWeek === 6) {
        await incrementTimeBasedCounter('weekend_sessions', 'weekend_warrior');
    }
}

async function incrementTimeBasedCounter(counterType, achievementId) {
    try {
        const dateStr = new Date().toISOString().split('T')[0];
        const cacheKey = `${counterType}_${currentUser.id}_${dateStr}`;

        // Prevent multiple increments per day
        if (sessionStorage.getItem(cacheKey)) return;

        // Update counter
        await supabase
            .from('profiles')
            .update({
                [counterType]: supabase.sql`${counterType} + 1`
            })
            .eq('id', currentUser.id);

        // Cache to prevent double counting
        sessionStorage.setItem(cacheKey, 'true');

        // Check related achievement
        if (achievementId) {
            await checkAndUnlockAchievement(achievementId, true);
        }

    } catch (error) {
        console.error(`Error incrementing ${counterType}:`, error);
    }
}

async function checkDailyStreak() {
    try {
        const { data: profile, error } = await supabase
            .from('profiles')
            .select('last_activity, current_streak, last_streak_date')
            .eq('id', currentUser.id)
            .single();

        if (error) throw error;

        const now = new Date();
        const today = now.toDateString();
        const lastActivity = profile.last_activity ? new Date(profile.last_activity) : null;
        const lastStreakDate = profile.last_streak_date ? new Date(profile.last_streak_date).toDateString() : null;

        let newStreak = profile.current_streak || 0;
        let shouldUpdateStreak = false;

        if (!lastActivity) {
            // First time user
            newStreak = 1;
            shouldUpdateStreak = true;
        } else {
            const daysSinceLastActivity = Math.floor((now - lastActivity) / (1000 * 60 * 60 * 24));
            
            if (lastStreakDate === today) {
                // Already counted today's streak
                return newStreak;
            } else if (daysSinceLastActivity === 1 || (daysSinceLastActivity === 0 && lastStreakDate !== today)) {
                // Consecutive day or same day but not counted yet
                newStreak += 1;
                shouldUpdateStreak = true;
            } else if (daysSinceLastActivity > 1) {
                // Streak broken
                newStreak = 1;
                shouldUpdateStreak = true;
            }
        }

        if (shouldUpdateStreak) {
            await supabase
                .from('profiles')
                .update({
                    current_streak: newStreak,
                    last_activity: now.toISOString(),
                    last_streak_date: now.toISOString()
                })
                .eq('id', currentUser.id);

            userStats.current_streak = newStreak;
            
            showToast(`Daily streak: ${newStreak} days!`, 'success');
            await checkStreakAchievements(newStreak);
        }

        return newStreak;
        
    } catch (error) {
        console.error('Error checking daily streak:', error);
        return 0;
    }
}

async function checkStreakAchievements(currentStreak) {
    const streakMilestones = [3, 7, 14, 30, 100, 365];
    
    for (const milestone of streakMilestones) {
        if (currentStreak >= milestone) {
            await checkAndUnlockAchievement(`streak_${milestone}`);
        }
    }
}

// =====================================================
// USER ACTIVITY LOGGING
// =====================================================
async function logUserActivity(activityType, metadata = {}) {
    try {
        const now = new Date();
        
        const activityData = {
            user_id: currentUser.id,
            activity_type: activityType,
            timestamp: now.toISOString(),
            course_id: COURSE_DATA.id,
            lesson_index: currentLessonIndex,
            session_duration: courseSession.totalStudyTime,
            metadata: JSON.stringify(metadata),
            created_at: now.toISOString()
        };

        // Try to log to activities table
        const { error } = await supabase
            .from('user_activities')
            .insert([activityData]);

        if (error && error.code !== '42P01') {
            console.warn('Activity logging failed:', error.message);
        }

        // Always update last activity in profile
        await supabase
            .from('profiles')
            .update({ last_activity: now.toISOString() })
            .eq('id', currentUser.id);

    } catch (error) {
        console.error('Error logging user activity:', error);
    }
}

// =====================================================
// NAVIGATION SYSTEM
// =====================================================
function updateNavigationButtons() {
    const prevBtn = document.getElementById('prevLessonBtn');
    const nextBtn = document.getElementById('nextLessonBtn');
    
    if (!prevBtn || !nextBtn) return;

    // Previous button
    prevBtn.disabled = currentLessonIndex === 0;
    
    // Next button logic
    const isLastLesson = currentLessonIndex === COURSE_DATA.lessons.length - 1;
    const canGoNext = currentLessonIndex < COURSE_DATA.lessons.length - 1 && 
                     canAccessLesson(currentLessonIndex + 1);
    
    if (isLastLesson) {
        const isCurrentCompleted = courseProgress[COURSE_DATA.lessons[currentLessonIndex].id]?.completed;
        nextBtn.disabled = !isCurrentCompleted;
        nextBtn.innerHTML = '<i class="fas fa-trophy"></i> Complete Course';
    } else {
        nextBtn.disabled = !canGoNext;
        nextBtn.innerHTML = 'Next <i class="fas fa-chevron-right"></i>';
    }
}

// Navigation button event handlers
function goToPreviousLesson() {
    if (currentLessonIndex > 0) {
        trackLessonTime(); // Track time spent on current lesson
        currentLessonIndex--;
        loadLesson(currentLessonIndex);
    }
}

function goToNextLesson() {
    if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
        const canGoNext = canAccessLesson(currentLessonIndex + 1);
        if (canGoNext) {
            trackLessonTime();
            currentLessonIndex++;
            loadLesson(currentLessonIndex);
        } else {
            showToast('Complete the current lesson quiz to proceed', 'warning');
        }
    } else {
        // Complete course
        completeCourse();
    }
}

// =====================================================
// SIDEBAR FUNCTIONS
// =====================================================
function toggleSidebar() {
    const sidebar = document.getElementById('sidebar');
    const overlay = document.getElementById('sidebarOverlay');
    
    if (sidebar) sidebar.classList.toggle('open');
    if (overlay) overlay.classList.toggle('active');
}

function closeSidebar() {
    const sidebar = document.getElementById('sidebar');
    const overlay = document.getElementById('sidebarOverlay');
    
    if (sidebar) sidebar.classList.remove('open');
    if (overlay) overlay.classList.remove('active');
}

// =====================================================
// ACHIEVEMENT NOTIFICATION SYSTEM
// =====================================================
function queueAchievementNotification(achievement) {
    notificationQueue.push(achievement);
    processNotificationQueue();
}

function processNotificationQueue() {
    if (isShowingNotification || notificationQueue.length === 0) return;

    isShowingNotification = true;
    const achievement = notificationQueue.shift();
    showAchievementNotification(achievement);

    const duration = achievement.rarity === 'mythic' ? 8000 :
                     achievement.rarity === 'legendary' ? 7000 : 6000;

    setTimeout(() => {
        isShowingNotification = false;
        processNotificationQueue();
    }, duration + 500);
}

function showAchievementNotification(achievement) {
    const notification = document.getElementById('achievementNotification');
    if (!notification) return;

    const icon = document.getElementById('notificationIcon');
    const title = document.getElementById('notificationTitle');
    const description = document.getElementById('notificationDescription');
    const points = document.getElementById('notificationPoints');

    if (icon) {
        icon.innerHTML = `<i class="${achievement.icon}"></i>`;
        icon.className = `notification-icon ${achievement.rarity}`;
    }
    if (title) title.textContent = achievement.name;
    if (description) description.textContent = achievement.description;
    if (points) points.textContent = `+${achievement.points} Points`;

    notification.className = `achievement-notification ${achievement.rarity}`;
    notification.classList.add('show');

    const duration = achievement.rarity === 'mythic' ? 8000 :
                     achievement.rarity === 'legendary' ? 7000 : 6000;

    setTimeout(() => {
        notification.classList.remove('show');
    }, duration);
}

// =====================================================
// UTILITY FUNCTIONS
// =====================================================
function calculateAverageQuizScore() {
    const scores = Object.values(courseProgress)
        .filter(p => p.completed && p.quizScore)
        .map(p => p.quizScore);
    
    if (scores.length === 0) return 0;
    return Math.round(scores.reduce((sum, score) => sum + score, 0) / scores.length);
}

async function resetProgress() {
    if (!confirm('Are you sure you want to reset your progress? This action cannot be undone.')) {
        return;
    }

    try {
        // Track lesson time before reset
        trackLessonTime();
        
        // Reset local state
        courseProgress = {};
        currentLessonIndex = 0;
        courseSession = {
            startTime: new Date(),
            totalStudyTime: 0,
            lessonsStarted: 0,
            lessonsCompleted: 0,
            pageLoadTime: new Date(),
            interactionCount: 0,
            lastActivityTime: new Date()
        };
        
        // Delete from database
        await supabase
            .from('course_progress')
            .delete()
            .eq('user_id', currentUser.id)
            .eq('course_id', COURSE_DATA.id);

        // Log reset activity
        logUserActivity('progress_reset', {
            course_id: COURSE_DATA.id,
            reset_reason: 'manual'
        });

        // Reinitialize
        await saveProgress();
        renderSidebar();
        loadLesson(0);
        
        showToast('Progress reset successfully', 'success');
        
    } catch (error) {
        console.error('Error resetting progress:', error);
        showToast('Failed to reset progress', 'error');
    }
}

function copyCode(codeId) {
    const codeElement = document.getElementById(codeId);
    if (!codeElement) return;
    
    const text = codeElement.textContent;
    
    navigator.clipboard.writeText(text).then(() => {
        showToast('Code copied to clipboard!', 'success');
        
        // Track code copy for achievements
        logUserActivity('code_copied', {
            code_section: codeId,
            lesson_id: COURSE_DATA.lessons[currentLessonIndex].id
        });
        
    }).catch(err => {
        console.error('Failed to copy code:', err);
        showToast('Failed to copy code', 'error');
        
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.select();
        try {
            document.execCommand('copy');
            showToast('Code copied to clipboard!', 'success');
        } catch (fallbackError) {
            showToast('Copy failed - please select and copy manually', 'error');
        }
        document.body.removeChild(textArea);
    });
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// =====================================================
// UI FEEDBACK SYSTEMS
// =====================================================
function showToast(message, type = 'success') {
    const toast = document.getElementById('toast');
    const messageEl = document.getElementById('toastMessage');
    
    if (!toast || !messageEl) {
        console.log(`Toast: ${message} (${type})`);
        return;
    }
    
    messageEl.textContent = message;
    toast.className = `toast ${type} show`;

    setTimeout(() => {
        toast.classList.remove('show');
    }, 4000);
}

function showLoadingScreen() {
    const loadingScreen = document.getElementById('loadingScreen');
    if (loadingScreen) loadingScreen.classList.remove('hidden');
}

function hideLoadingScreen() {
    const loadingScreen = document.getElementById('loadingScreen');
    if (loadingScreen) {
        setTimeout(() => {
            loadingScreen.classList.add('hidden');
        }, 1000);
    }
}

// =====================================================
// MUSIC PLAYER INTEGRATION
// =====================================================
function initMusicPlayer() {
    const btnText = document.getElementById('music-button-text');
    const icon = document.getElementById('music-icon');
    const dropdown = document.getElementById('music-dropdown-content');
    
    if (!btnText || !icon || !dropdown) return;
    
    function setUI(state) {
        btnText.textContent = state === "Playing" ? "PAUSE MUSIC" : "STUDY MUSIC";
        icon.className = state === "Playing" ? "fa-solid fa-circle-pause" : "fa-solid fa-music";
    }

    // Load saved music state
    const savedSrc = localStorage.getItem("cybersec_music_src");
    const savedTime = parseFloat(localStorage.getItem("cybersec_music_time") || 0);
    
    if (savedSrc) {
        audioPlayer.src = savedSrc;
        audioPlayer.currentTime = savedTime;
        audioPlayer.play()
            .then(() => setUI("Playing"))
            .catch(() => setUI("Stopped"));
    }

    // Music button click handler
    document.getElementById('music-dropdown').querySelector('button').addEventListener('click', (e) => {
        e.stopPropagation();
        dropdown.style.display = dropdown.style.display === "block" ? "none" : "block";
        
        if (audioPlayer.src && !audioPlayer.paused) {
            audioPlayer.pause();
            setUI("Stopped");
        } else if (audioPlayer.src) {
            audioPlayer.play().then(() => setUI("Playing"));
        }
    });

    // Music selection handlers
    dropdown.querySelectorAll("a[data-src]").forEach((link) => {
        link.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.src = link.dataset.src;
            audioPlayer.play().then(() => setUI("Playing"));
            localStorage.setItem("cybersec_music_src", link.dataset.src);
            dropdown.style.display = "none";
        });
    });

    // Stop music handler
    const stopLink = document.getElementById("stop-music-link");
    if (stopLink) {
        stopLink.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            audioPlayer.removeAttribute("src");
            setUI("Stopped");
            localStorage.removeItem("cybersec_music_src");
            localStorage.removeItem("cybersec_music_time");
            dropdown.style.display = "none";
        });
    }

    // Save music state before page unload
    window.addEventListener("beforeunload", () => {
        if (!audioPlayer.paused && audioPlayer.src) {
            localStorage.setItem("cybersec_music_src", audioPlayer.src);
            localStorage.setItem(
                "cybersec_music_time",
                audioPlayer.currentTime
            );
        }
    });

    // Close dropdown when clicking outside
    window.addEventListener("click", (e) => {
        if (!e.target.closest("#music-dropdown")) {
            dropdown.style.display = "none";
        }
    });
}

// Show initial music indicator
function addMusicIndicator() {
    const musicBtn = document.querySelector("#music-dropdown");
    if (musicBtn) {
        const indicator = document.createElement("div");
        indicator.className = "music-indicator";
        indicator.innerHTML = `<i class="fa-solid fa-music"></i> Try Study Music!`;

        musicBtn.style.position = "relative";
        musicBtn.appendChild(indicator);

        setTimeout(() => indicator.remove(), 3000);
    }
}

// Initialize Event Listeners
function initializeEventListeners() {
    // Navigation buttons
    document.getElementById('prevLessonBtn')?.addEventListener('click', goToPreviousLesson);
    document.getElementById('nextLessonBtn')?.addEventListener('click', goToNextLesson);

    // Reset progress button
    document.getElementById('resetProgressBtn')?.addEventListener('click', resetProgress);

    // Mobile menu toggle
    document.getElementById('menuToggle')?.addEventListener('click', toggleSidebar);
    document.getElementById('sidebarOverlay')?.addEventListener('click', closeSidebar);

    // Keyboard shortcuts
    document.addEventListener('keydown', handleKeyboardShortcuts);

    // Window resize handler
    window.addEventListener('resize', handleWindowResize);

    // Content interaction tracking
    document.getElementById('contentBody')?.addEventListener('scroll', debounce(() => {
        trackUserInteraction();
    }, 1000));
}

// Keyboard Shortcuts
function handleKeyboardShortcuts(e) {
    if (document.querySelector('.quiz-question.active')) return;

    if (e.key === 'ArrowLeft' && e.ctrlKey) {
        e.preventDefault();
        goToPreviousLesson();
    } else if (e.key === 'ArrowRight' && e.ctrlKey) {
        e.preventDefault();
        goToNextLesson();
    }
}

// Window Resize Handler
function handleWindowResize() {
    if (window.innerWidth > 768) {
        closeSidebar();
    }
}

// Debounce Helper
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// Initialize responsive behavior
if (window.innerWidth <= 768) {
    document.getElementById('menuToggle').style.display = 'inline-flex';
}

// Auto-save progress periodically
setInterval(async () => {
    if (currentUser && Object.keys(courseProgress).length > 0) {
        await saveProgress();
    }
}, 60000); // Save every minute

// System initialization logging
console.log('CyberSec Academy Course System Initialized');
console.log('Current Course:', COURSE_DATA.title);
console.log('Total Lessons:', COURSE_DATA.lessons.length);

// Google OAuth Integration
const googleBtn = document.querySelector(".btn-google");
if (googleBtn) {
    googleBtn.addEventListener("click", async () => {
        const { data, error } = await supabase.auth.signInWithOAuth({
            provider: "google",
            options: {
                redirectTo: window.location.origin + "/courses/reverse-engineering-professional-expanded.html",
            },
        });

        if (error) {
            console.error("Google login error:", error.message);
            showToast("Google login failed: " + error.message, "error");
        }
    });
}

// Check for existing session
supabase.auth.getSession().then(({ data }) => {
    if (data.session) {
        console.log("User already logged in:", data.session.user);
        currentUser = data.session.user;
        startCourseSession();
    }
});


// Add missing auth modal functions
function openAuthModal() {
    const modal = document.getElementById('authModal');
    if (modal) {
        modal.style.display = 'flex';
    }
}

function closeAuthModal() {
    const modal = document.getElementById('authModal');
    if (modal) {
        modal.style.display = 'none';
    }
}

// Add auth tab switching functionality
document.getElementById('tabSignIn')?.addEventListener('click', () => {
    document.getElementById('tabSignIn').classList.add('active');
    document.getElementById('tabSignUp').classList.remove('active');
    document.getElementById('signInForm').style.display = 'block';
    document.getElementById('signUpForm').style.display = 'none';
});

document.getElementById('tabSignUp')?.addEventListener('click', () => {
    document.getElementById('tabSignUp').classList.add('active');
    document.getElementById('tabSignIn').classList.remove('active');
    document.getElementById('signUpForm').style.display = 'block';
    document.getElementById('signInForm').style.display = 'none';
});

document.getElementById('closeAuthModal')?.addEventListener('click', closeAuthModal);

// Improved error handling for auth session
supabase.auth.onAuthStateChange((event, session) => {
    if (event === 'SIGNED_IN') {
        currentUser = session.user;
        closeAuthModal();
        startCourseSession();
    } else if (event === 'SIGNED_OUT') {
        currentUser = null;
        openAuthModal();
    }
});

// Add form submission handlers
document.getElementById('emailSignInForm')?.addEventListener('submit', async (e) => {
    e.preventDefault();
    const email = document.getElementById('signInEmail').value;
    const password = document.getElementById('signInPassword').value;
    
    try {
        const { data, error } = await supabase.auth.signInWithPassword({
            email,
            password
        });
        
        if (error) throw error;
        
        closeAuthModal();
    } catch (error) {
        showToast(error.message, 'error');
    }
});

document.getElementById('emailSignUpForm')?.addEventListener('submit', async (e) => {
    e.preventDefault();
    const email = document.getElementById('signUpEmail').value;
    const password = document.getElementById('signUpPassword').value;
    const name = document.getElementById('signUpName').value;
    
    try {
        const { data, error } = await supabase.auth.signUp({
            email,
            password,
            options: {
                data: {
                    full_name: name
                }
            }
        });
        
        if (error) throw error;
        
        showToast('Account created successfully! Please check your email.', 'success');
    } catch (error) {
        showToast(error.message, 'error');
    }
});
    </script>
</body>
</html>