




<!DOCTYPE html>
<html lang="en">
 <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>System Hardening Basics Course Curriculum | CipherHall</title>
    <meta name="description" content="Begin your free System Hardening course. This curriculum covers endpoint security, patch management, cloud hardening, Zero Trust principles, and more." />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png" />
    <link rel="shortcut icon" href="/favicon.png" type="image/x-icon" />
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png" />
    <link rel="canonical" href="https://www.cipherhall.com/courses/system-hardening-basics.html" />

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Course",
      "name": "System Hardening Basics",
      "description": "Learn to secure systems against threats by mastering configuration, vulnerability management, and essential security principles.",
      "provider": {
        "@type": "Organization",
        "name": "CipherHall",
        "sameAs": "https://www.cipherhall.com"
      },
      "hasCourseInstance": {
        "@type": "CourseInstance",
        "courseMode": "Online",
        "instructor": {
          "@type": "Person",
          "name": "Alex Vance"
        }
      }
    }
    </script>

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Exo+2:wght@700;800;900&display=swap" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" />
    <link rel="stylesheet" href="assets/css/coursepages.css">
</head>
  <body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
      <div class="loader-icon">
        <i class="fas fa-graduation-cap"></i>
      </div>
      <div class="loader-text">Loading Course Content...</div>
    </div>

    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- Music Player (fixed at top right) -->
    <div class="header-controls">
      <div class="music-dropdown" id="music-dropdown">
        <button class="btn btn-secondary">
          <span id="music-button-text">STUDY MUSIC</span>
          <i id="music-icon" class="fa-solid fa-music"></i>
        </button>
        <div class="music-dropdown-content" id="music-dropdown-content">
          <a
            href="#"
            data-src="https://www.learningcontainer.com/wp-content/uploads/2020/02/Kalimba.mp3"
            >1. Coffee Shop Vibes</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3"
            >2. City Lights Lofi</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-15.mp3"
            >3. Mellow Thoughts</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-13.mp3"
            >4. Rainy Mood</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3"
            >5. Time Alone</a
          >
          <a href="#" id="stop-music-link"
            ><i class="fa-solid fa-stop-circle"></i> Stop Music</a
          >
        </div>
      </div>

      <button class="btn btn-secondary" id="resetProgressBtn">
        <i class="fas fa-redo"></i>
        Reset Progress
      </button>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal" style="display: none">
      <div class="modal-overlay"></div>
      <div class="modal-content">
        <span class="close" id="closeAuthModal">&times;</span>
        <div class="auth-tabs">
          <button id="tabSignIn" class="auth-tab active">Sign In</button>
          <button id="tabSignUp" class="auth-tab">Sign Up</button>
        </div>
        <div
          id="authLoader"
          style="display: none; text-align: center; padding: 2rem"
        >
          <i
            class="fas fa-spinner fa-spin fa-2x"
            style="color: var(--color-green)"
          ></i>
          <p style="margin-top: 0.5rem">Authenticating...</p>
        </div>
        <div id="signInForm" class="auth-form">
          <h2>Sign In to CipherHall</h2>
          <button id="googleSignIn" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignInForm">
            <input
              type="email"
              id="signInEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signInPassword"
              placeholder="Password"
              required
            />
            <button type="submit" class="btn btn-primary">Sign In</button>
          </form>
        </div>
        <div id="signUpForm" class="auth-form" style="display: none">
          <h2>Join CipherHall</h2>
          <button id="googleSignUp" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignUpForm">
            <input
              type="text"
              id="signUpName"
              placeholder="Full Name"
              required
            />
            <input
              type="email"
              id="signUpEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signUpPassword"
              placeholder="Password (min. 8 characters)"
              required
            />
            <button type="submit" class="btn btn-secondary">
              Create Account
            </button>
          </form>
        </div>
        <div id="authMessage"></div>
      </div>
    </div>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="course-info">
          <h1 class="course-title" id="courseTitle">Loading...</h1>
          <div class="course-progress">
            <div class="progress-header">
              <span class="progress-label">Course Progress</span>
              <span class="progress-percentage" id="courseProgressPercent"
                >0%</span
              >
            </div>
            <div class="progress-bar">
              <div
                class="progress-fill"
                id="courseProgressFill"
                style="width: 0%"
              ></div>
            </div>
            <div class="progress-stats">
              <span id="completedLessons">0</span>
              <span id="totalLessons">0</span>
            </div>
          </div>
          <a href="/dashboard.html" class="back-to-dashboard">
            <i class="fas fa-arrow-left"></i>
            Back to Dashboard
          </a>
        </div>
      </div>

      <nav class="lesson-nav" id="lessonNav">
        <!-- Lessons will be loaded dynamically -->
      </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <header class="content-header">
        <div class="lesson-header">
          <div class="lesson-header-left">
            <span class="lesson-number" id="currentLessonNumber">1</span>
            <h1 class="lesson-header-title" id="currentLessonTitle">
              Loading...
            </h1>
          </div>
          <div class="lesson-actions">
            <button class="mbtn btn-primary" id="menuToggle">
              <i class="fas fa-bars"></i>
            </button>
          </div>
        </div>
      </header>

      <div class="content-body" id="contentBody">
        <div class="lesson-content" id="lessonContent">
          <!-- Lesson content will be loaded dynamically -->
        </div>
      </div>

      <footer class="lesson-navigation">
        <div class="nav-info" id="navInfo">Lesson 1 of 10</div>
        <div class="nav-controls">
          <button class="btn btn-secondary" id="prevLessonBtn" disabled>
            <i class="fas fa-chevron-left"></i>
            Previous
          </button>
          <button class="btn btn-primary" id="nextLessonBtn" disabled>
            Next
            <i class="fas fa-chevron-right"></i>
          </button>
        </div>
      </footer>
    </main>

    <!-- Achievement Notification -->
    <div id="achievementNotification" class="achievement-notification">
      <div class="notification-header">
        <div class="notification-icon" id="notificationIcon">
          <i class="fas fa-trophy"></i>
        </div>
        <div class="notification-content">
          <h3 id="notificationTitle">Achievement Unlocked!</h3>
          <p id="notificationDescription">Description here...</p>
        </div>
      </div>
      <div class="notification-reward" id="notificationReward">
        <i class="fas fa-coins"></i>
        <span id="notificationPoints">+100 Points</span>
      </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast">
      <span id="toastMessage"></span>
    </div>

    <script>
      // =====================================================
      // SYNCHRONIZED COURSE SYSTEM WITH DASHBOARD INTEGRATION
      // =====================================================

      // Supabase Configuration - Replace with your config
      const supabaseUrl = "https://lzcmzulemfubjaksoqor.supabase.co";
      const supabaseKey =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx6Y216dWxlbWZ1Ympha3NvcW9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzMzM5MDgsImV4cCI6MjA3MDkwOTkwOH0.crhPH4YWtRsr1BJTpAQcmPbWSpwIWRbzoI4sRb2_fPI";
      const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

      // =====================================================
      // COURSE DATA STRUCTURE - REPLACE WITH YOUR COURSE JSON
      // =====================================================
      const COURSE_DATA = {
        id: "system-hardening-basics",
        title: "System Hardening Basics",
        description:
          "Learn to secure systems against threats by mastering configuration, vulnerability management, and essential security principles.",
        category: "cybersecurity-fundamentals",
        difficulty: "Beginner to Intermediate",
        duration: "40 hours",
        instructor: "Dr. Evelyn Reed",
        lessons: [
          {
            id: "lesson-1",
            title: "Introduction to System Hardening",
            duration: "90 min",
            objectives: [
              "Understand the core principles of system hardening",
              "Learn about the CIA Triad (Confidentiality, Integrity, Availability)",
              "Identify the modern threat landscape for computer systems",
              "Recognize common system misconfigurations",
            ],
            content: {
              overview:
                "This foundational lesson introduces the 'why' behind system hardening. We'll explore the core security principles that guide every decision and identify the common threats and vulnerabilities that make hardening a critical practice for any IT professional.",
              sections: [
                {
                  title: "What is System Hardening?",
                  content:
                    '<p>System hardening is the process of securing a system by reducing its surface of vulnerability. A larger vulnerability surface means more security risks. The goal is to eliminate potential attack vectors by removing unnecessary software, accounts, services, and features, and by configuring what remains to be as secure as possible.</p><h3>Key Principles:</h3><ul><li><strong>Principle of Least Privilege:</strong> Users and programs should only have the minimum privileges necessary to perform their functions.</li><li><strong>Defense in Depth:</strong> Security should be layered, so if one control fails, others are in place to stop an attack.</li><li><strong>Minimization:</strong> Reduce the attack surface by disabling or removing unnecessary services, applications, and ports.</li><li><strong>Secure Defaults:</strong> Start with a secure configuration and only enable features as needed.</li></ul><div class="info-box tip"><div class="info-box-header"><i class="fas fa-lightbulb"></i><strong>Analogy</strong></div><p>Think of system hardening like securing a house. You don\'t just lock the front door; you also lock windows, install an alarm, and don\'t leave spare keys under the mat. Each step reduces the risk of a break-in.</p></div>',
                  image:
                    "https://images.unsplash.com/photo-1550751827-4138d04d405f?w=800&h=400&fit=crop",
                },
                {
                  title: "The CIA Triad",
                  content:
                    '<p>The CIA Triad is a widely used security model that forms the bedrock of information security. It provides the essential goals for any security program.</p><h3>The Three Pillars:</h3><ul><li><strong>Confidentiality:</strong> Ensuring that data is accessible only to authorized users. This involves measures like encryption and access control.</li><li><strong>Integrity:</strong> Maintaining the consistency, accuracy, and trustworthiness of data over its entire lifecycle. This prevents unauthorized modification of data.</li><li><strong>Availability:</strong> Guaranteeing that systems and data are accessible to authorized users when they need them. This involves protection against denial-of-service attacks and ensuring system uptime.</li></ul><div class="info-box note"><div class="info-box-header"><i class="fas fa-info-circle"></i><strong>Balancing the Triad</strong></div><p>Sometimes, these principles conflict. For example, extremely strict confidentiality controls might make a system less available. The key is to find the right balance for your organization\'s needs.</p></div>',
                  image:
                    "https://images.unsplash.com/photo-1573496130489-9434806141c2?w=800&h=400&fit=crop",
                },
                {
                  title: "Understanding the Threat Landscape",
                  content:
                    '<p>The threat landscape is the collection of all threats and actors that can potentially harm a system or organization. It is constantly evolving.</p><h3>Common Threats:</h3><ul><li><strong>Malware:</strong> Ransomware, spyware, viruses, and worms designed to disrupt operations or steal data.</li><li><strong>Phishing:</strong> Social engineering attacks to trick users into revealing sensitive information.</li><li><strong>Insider Threats:</strong> Malicious or unintentional harm caused by employees or trusted partners.</li><li><strong>Zero-Day Exploits:</strong> Attacks that target previously unknown vulnerabilities.</li><li><strong>Denial-of-Service (DoS) Attacks:</strong> Efforts to make a system unavailable to its intended users.</li></ul><div class="info-box warning"><div class="info-box-header"><i class="fas fa-exclamation-triangle"></i><strong>Stay Informed</strong></div><p>The threat landscape changes daily. Security professionals must stay informed through threat intelligence feeds, security news, and vendor advisories.</p></div>',
                  image:
                    "https://images.unsplash.com/photo-1585226985175-c93c35b9e832?w=800&h=400&fit=crop",
                },
              ],
            },
            codeExamples: [
              {
                title: "Lab: Identify Misconfigurations in a Linux VM",
                language: "bash",
                code: "# 1. Check for world-writable files (a common misconfiguration)\nfind / -type f -perm -0002\n\n# 2. List services that are running. Are they all necessary?\nsudo netstat -tulpn\n\n# 3. Check for users with no password set\nsudo awk -F: '($2 == \"\") {print $1}' /etc/shadow\n\n# 4. Review open network ports\nsudo ss -lntu\n\n# 5. Check sudo permissions. Is anyone given excessive rights?\nsudo cat /etc/sudoers",
              },
            ],
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question: "What is the primary goal of system hardening?",
                  options: [
                    "To increase system performance",
                    "To reduce the attack surface",
                    "To install more software",
                    "To make the system easier to use",
                  ],
                  correct: 1,
                  explanation:
                    "System hardening focuses on minimizing the number of vulnerabilities by removing unnecessary components and securing what's left, thereby reducing the attack surface.",
                },
                {
                  id: 2,
                  question:
                    "Which component of the CIA Triad ensures that data is not altered or destroyed in an unauthorized manner?",
                  options: [
                    "Confidentiality",
                    "Integrity",
                    "Availability",
                    "Authentication",
                  ],
                  correct: 1,
                  explanation:
                    "Integrity is the principle that guarantees the accuracy and trustworthiness of data, protecting it from unauthorized modification.",
                },
                {
                  id: 3,
                  question: "The 'Principle of Least Privilege' means that:",
                  options: [
                    "All users should have administrator rights",
                    "Users should have the maximum privileges possible",
                    "Users should only have the permissions essential to perform their job",
                    "Programs should always run as root",
                  ],
                  correct: 2,
                  explanation:
                    "The Principle of Least Privilege dictates that any user, program, or process should have only the bare minimum privileges necessary to perform its function.",
                },
              ],
            },
          },
          {
            id: "lesson-2",
            title: "Common Vulnerabilities and Exposures",
            duration: "75 min",
            objectives: [
              "Understand what CVEs (Common Vulnerabilities and Exposures) are and how they are used",
              "Learn about common vulnerability types like buffer overflows and privilege escalation",
              "Know how to use a CVE database to find information about vulnerabilities",
              "Recognize the importance of vulnerability scoring (CVSS)",
            ],
            content: {
              overview:
                "This lesson dives into the specific flaws that attackers exploit. We'll learn how the security community catalogs these weaknesses using the CVE system and explore high-level concepts behind common vulnerability types that have plagued software for decades.",
              sections: [
                {
                  title: "Understanding CVEs",
                  content:
                    '<p>A CVE, or Common Vulnerabilities and Exposures, is a system that provides a unique identifier for a specific, publicly known cybersecurity vulnerability. The format is always CVE-YYYY-NNNN, where YYYY is the year and NNNN is a sequence number.</p><h3>Why CVEs are Important:</h3><ul><li><strong>Standardization:</strong> They provide a standardized way for security professionals, vendors, and researchers to refer to a specific vulnerability.</li><li><strong>Information Sharing:</strong> A CVE ID acts as a key to look up information about the flaw across multiple databases, tools, and advisories.</li><li><strong>Vulnerability Management:</strong> CVEs are essential for tracking and prioritizing the remediation of vulnerabilities in your systems.</li></ul><div class="info-box note"><div class="info-box-header"><i class="fas fa-info-circle"></i><strong>CVE vs. CVSS</strong></div><p>A CVE identifies a vulnerability. The Common Vulnerability Scoring System (CVSS) provides a score (0-10) that represents its severity. They are often used together.</p></div>',
                  image:
                    "https://images.unsplash.com/photo-1563206767-5b18f218e8de?w=800&h=400&fit=crop",
                },
                {
                  title: "Buffer Overflows",
                  content:
                    "<p>A buffer overflow is a type of software vulnerability that exists when an area of memory within a software application reaches its address boundary and writes into an adjacent memory region. This can lead to erratic program behavior, crashes, or, most critically, the execution of malicious code.</p><h3>How it Works:</h3><ol><li>A program allocates a fixed-size buffer in memory (e.g., to store a username).</li><li>The program receives user input that is larger than the buffer.</li><li>The program fails to check the input size and writes it anyway, overflowing the buffer.</li><li>The excess data overwrites adjacent memory, which could include the program's instructions.</li><li>An attacker can craft this excess data to be malicious code, which the program then executes.</li></ol>",
                  image:
                    "https://images.unsplash.com/photo-1544890225-2fde0e66f35b?w=800&h=400&fit=crop",
                },
                {
                  title: "Privilege Escalation",
                  content:
                    '<p>Privilege escalation is the act of exploiting a bug, design flaw, or configuration oversight in an operating system or software application to gain elevated access to resources that are normally protected from an application or user.</p><h3>Types of Privilege Escalation:</h3><ul><li><strong>Vertical Privilege Escalation:</strong> A lower-privilege user or application gains access to functions or content reserved for higher-privilege users (e.g., a standard user becoming an administrator).</li><li><strong>Horizontal Privilege Escalation:</strong> A normal user accesses functions or content reserved for other normal users (e.g., User A accessing User B\'s bank account).</li></ul><div class="info-box warning"><div class="info-box-header"><i class="fas fa-exclamation-triangle"></i><strong>A Critical Step for Attackers</strong></div><p>Attackers often gain initial access as a low-privilege user and then use privilege escalation exploits to gain full control over the system.</p></div>',
                  image:
                    "https://images.unsplash.com/photo-1504868584819-f8e8b4b6d7e3?w=800&h=400&fit=crop",
                },
              ],
            },
            codeExamples: [
              {
                title: "Lab: Using a CVE Database",
                language: "bash",
                code: "# This lab is conceptual and involves using a web browser.\n\n# 1. Open your web browser and navigate to a CVE database like:\n#    - MITRE CVE List: https://cve.mitre.org/\n#    - NIST NVD: https://nvd.nist.gov/vuln/search\n\n# 2. Search for a well-known vulnerability, for example: CVE-2014-0160 (Heartbleed)\n\n# 3. Analyze the entry:\n#    - Read the description of the vulnerability.\n#    - Note the CVSS score. What is its severity (e.g., Critical, High)?\n#    - Look at the list of affected software versions.\n#    - Find links to vendor advisories and patches.\n\n# 4. Try searching for a vulnerability in software you use, e.g., 'Apache 2.4 vulnerability'.",
              },
            ],
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question: "What is the purpose of a CVE identifier?",
                  options: [
                    "To provide a patch for a vulnerability",
                    "To assign a severity score to a vulnerability",
                    "To uniquely identify a specific, public vulnerability",
                    "To exploit a vulnerability",
                  ],
                  correct: 2,
                  explanation:
                    "A CVE provides a unique, standardized name for a public cybersecurity vulnerability, making it easier to track and share information about it.",
                },
                {
                  id: 2,
                  question:
                    "An attacker gaining administrator access from a standard user account is an example of what?",
                  options: [
                    "Buffer Overflow",
                    "Horizontal Privilege Escalation",
                    "Denial of Service",
                    "Vertical Privilege Escalation",
                  ],
                  correct: 3,
                  explanation:
                    "Vertical privilege escalation involves moving from a lower privilege level to a higher one, such as from a standard user to an administrator.",
                },
                {
                  id: 3,
                  question:
                    "What system is used to rate the severity of a vulnerability?",
                  options: ["CVE", "TCP/IP", "CVSS", "NIST"],
                  correct: 2,
                  explanation:
                    "The Common Vulnerability Scoring System (CVSS) is the standard for rating the severity of vulnerabilities, typically on a scale from 0 to 10.",
                },
              ],
            },
          },
          {
            id: "lesson-3",
            title: "Password Policies and Protection",
            duration: "90 min",
            objectives: [
              "Understand the importance of strong password policies",
              "Learn about password hashing, salting, and peppering",
              "Recognize the role of Multi-Factor Authentication (MFA)",
              "Implement password complexity and aging policies in Windows and Linux",
            ],
            content: {
              overview:
                "Passwords are the first line of defense. This lesson covers how to protect them effectively, both from a policy perspective and a technical one. We'll explore how modern systems store passwords securely and how to enforce policies that encourage users to create strong, resilient credentials.",
              sections: [
                {
                  title: "Password Hashing and Salting",
                  content:
                    "<p>Passwords should never be stored in plaintext. Instead, they are processed through a one-way cryptographic function to create a unique 'hash'.</p><h3>Key Concepts:</h3><ul><li><strong>Hashing:</strong> A process that converts a password into a fixed-length, unpredictable string of characters. It's a one-way function, meaning you cannot reverse it to get the original password.</li><li><strong>Salting:</strong> A unique, randomly generated string of data that is added to each user's password before it is hashed. The salt is then stored with the hash. This ensures that two users with the same password will have different hashes, preventing rainbow table attacks.</li><li><strong>Peppering:</strong> Similar to a salt, but a single 'pepper' is added to all passwords before hashing. The pepper is stored separately from the hashes, for instance, in a configuration file, adding another layer of security.</li></ul><div class=\"info-box note\"><div class=\"info-box-header\"><i class=\"fas fa-info-circle\"></i><strong>Hashing Algorithms</strong></div><p>Avoid outdated algorithms like MD5 or SHA-1. Modern, strong hashing algorithms designed for passwords include Argon2, scrypt, and bcrypt.</p></div>",
                  image:
                    "https://images.unsplash.com/photo-1542831371-29b0f74f9713?w=800&h=400&fit=crop",
                },
                {
                  title: "Multi-Factor Authentication (MFA)",
                  content:
                    '<p>Multi-Factor Authentication (MFA) is a security enhancement that requires users to provide two or more verification factors to gain access to a resource. It adds a critical second layer of security, making it much harder for unauthorized users to gain access.</p><h3>Authentication Factors:</h3><ol><li><strong>Something you know:</strong> A password, PIN, or answer to a secret question.</li><li><strong>Something you have:</strong> A physical object like a smartphone (for an authenticator app), a hardware token, or a smart card.</li><li><strong>Something you are:</strong> A biometric trait like a fingerprint, facial scan, or iris scan.</li></ol><div class="info-box tip"><div class="info-box-header"><i class="fas fa-lightbulb"></i><strong>MFA is a Must</strong></div><p>Even a strong password can be stolen. MFA provides robust protection against password breaches, phishing, and other credential theft attacks. It is one of the most effective security controls you can implement.</p></div>',
                  image:
                    "https://images.unsplash.com/photo-1558522195-e1279a321947?w=800&h=400&fit=crop",
                },
              ],
            },
            codeExamples: [
              {
                title: "Lab: Enforce Password Complexity in Linux",
                language: "bash",
                code: "# 1. Install the libpam-pwquality library\nsudo apt-get update\nsudo apt-get install libpam-pwquality\n\n# 2. Edit the common-password configuration file\nsudo nano /etc/pam.d/common-password\n\n# 3. Find the line starting with 'password requisite pam_pwquality.so'\n# Modify it to enforce complexity. For example:\n# retry=3 minlen=12 difok=3 dcredit=-1 ucredit=-1 lcredit=-1 ocredit=-1\n#\n# Explanation of options:\n# minlen=12    -> Minimum length of 12 characters\n# dcredit=-1   -> At least 1 digit\n# ucredit=-1   -> At least 1 uppercase character\n# lcredit=-1   -> At least 1 lowercase character\n# ocredit=-1   -> At least 1 special character\n# difok=3      -> At least 3 characters must be different from the old password\n\n# 4. Save the file and exit. New passwords will now be checked against this policy.",
              },
              {
                title:
                  "Lab: Enforce Password Complexity in Windows (Local GPO)",
                language: "powershell",
                code: "# This lab uses the Local Group Policy Editor (gpedit.msc)\n\n# 1. Open the editor by running 'gpedit.msc'.\n\n# 2. Navigate to:\n#    Computer Configuration > Windows Settings > Security Settings > Account Policies > Password Policy\n\n# 3. Configure the following policies:\n#    - Enforce password history: 24 passwords remembered\n#    - Maximum password age: 60 days\n#    - Minimum password age: 1 day\n#    - Minimum password length: 12 characters\n#    - Password must meet complexity requirements: Enabled\n\n# 4. Complexity requirements in Windows mean the password must contain characters from three of the following four categories:\n#    - Uppercase letters\n#    - Lowercase letters\n#    - Digits (0-9)\n#    - Special characters (!, $, #, %, etc.)",
              },
            ],
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the purpose of adding a 'salt' to a password before hashing?",
                  options: [
                    "To make the hash shorter",
                    "To ensure two identical passwords have different hashes",
                    "To make the password easier to remember",
                    "To encrypt the password",
                  ],
                  correct: 1,
                  explanation:
                    "Salting adds unique, random data to each password before hashing, which prevents attackers from using precomputed hash tables (rainbow tables) to crack multiple passwords at once.",
                },
                {
                  id: 2,
                  question:
                    "Using a fingerprint to unlock your phone is an example of which MFA factor?",
                  options: [
                    "Something you know",
                    "Something you have",
                    "Something you are",
                    "Something you do",
                  ],
                  correct: 2,
                  explanation:
                    "'Something you are' refers to biometric factors, such as fingerprints, facial recognition, or iris scans.",
                },
                {
                  id: 3,
                  question:
                    "Which of these is considered a modern, secure password hashing algorithm?",
                  options: ["MD5", "SHA-1", "Argon2", "Base64"],
                  correct: 2,
                  explanation:
                    "MD5 and SHA-1 are outdated and insecure for password hashing. Argon2, along with scrypt and bcrypt, is a modern algorithm designed to be resistant to hardware-based cracking attempts.",
                },
              ],
            },
          },
          {
            id: "lesson-4",
            title: "File System Hardening",
            duration: "120 min",
            objectives: [
              "Understand standard Linux file permissions (read, write, execute)",
              "Identify the risks of SUID and SGID bits",
              "Learn how to audit and secure critical system files",
              "Apply the principle of least privilege to the file system",
            ],
            content: {
              overview:
                "The file system is the backbone of the operating system, and its permissions control who can access what. This lesson covers how to properly configure file and directory permissions in Linux to prevent unauthorized access and privilege escalation.",
              sections: [
                {
                  title: "Linux File Permissions",
                  content:
                    '<p>In Linux, every file and directory has a set of permissions that determines who can access it and what they can do. Permissions are divided into three categories for three types of users.</p><h3>User Types:</h3><ul><li><strong>Owner:</strong> The user who owns the file.</li><li><strong>Group:</strong> A group of users who share permissions.</li><li><strong>Other (World):</strong> All other users on the system.</li></ul><h3>Permission Types:</h3><ul><li><strong>Read (r):</strong> View the contents of a file or list the contents of a directory.</li><li><strong>Write (w):</strong> Modify a file or create/delete files within a directory.</li><li><strong>Execute (x):</strong> Run a file as a program or enter a directory.</li></ul><div class="info-box note"><div class="info-box-header"><i class="fas fa-info-circle"></i><strong>Numeric Notation</strong></div><p>Permissions are often represented numerically: Read=4, Write=2, Execute=1. For example, `rwx` is 4+2+1=7, and `r-x` is 4+0+1=5. A permission setting of `755` means the owner has `rwx`, while the group and others have `r-x`.</p></div>',
                  image:
                    "https://images.unsplash.com/photo-1516135246747-2367873a4b08?w=800&h=400&fit=crop",
                },
                {
                  title: "The Danger of SUID and SGID",
                  content:
                    '<p>SUID (Set User ID) and SGID (Set Group ID) are special permissions that can be a significant security risk if misused. </p><h3>How They Work:</h3><ul><li><strong>SUID:</strong> When an executable file with the SUID bit is run, it executes with the permissions of the file owner, not the user who ran it. This is how the `passwd` command allows a normal user to change their password, as it runs as the `root` user to modify the shadow file.</li><li><strong>SGID:</strong> When set on an executable, it runs with the permissions of the file\'s group. When set on a directory, new files created in that directory inherit the group ownership of the directory itself.</li></ul><div class="info-box warning"><div class="info-box-header"><i class="fas fa-exclamation-triangle"></i><strong>Security Risk</strong></div><p>If a vulnerability is found in a SUID-root program, an attacker could exploit it to execute arbitrary code as the root user, leading to a full system compromise. It\'s critical to minimize the number of SUID/SGID executables on a system.</p></div>',
                  image:
                    "https://images.unsplash.com/photo-1599691533267-be243a970634?w=800&h=400&fit=crop",
                },
              ],
            },
            codeExamples: [
              {
                title: "Lab: Audit /etc/passwd & /etc/shadow",
                language: "bash",
                code: "# 1. View the permissions of /etc/passwd\nls -l /etc/passwd\n# Expected output: -rw-r--r-- 1 root root ...\n# This means the root user can read/write, while everyone else can only read.\n\n# 2. View the permissions of /etc/shadow\nls -l /etc/shadow\n# Expected output: -rw-r----- 1 root shadow ... or -rw------- 1 root root ...\n# This is critical. It means only root and members of the 'shadow' group (or just root) can read the file, and only root can write. No 'other' permissions should be present.\n\n# 3. Find all SUID files on the system\nsudo find / -perm /4000 -type f -exec ls -ld {} \\;\n# Review this list. Do all of these programs need to run as root? Could any be disabled?\n\n# 4. Find all SGID files on the system\nsudo find / -perm /2000 -type f -exec ls -ld {} \\;\n# Similarly, review this list for any unnecessary permissions.",
              },
            ],
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question: "What does the permission `755` mean for a file?",
                  options: [
                    "Everyone has full read, write, and execute permissions.",
                    "The owner has read/write, group and others have read-only.",
                    "The owner has read/write/execute, while group and others have read/execute.",
                    "Only the owner can access the file.",
                  ],
                  correct: 2,
                  explanation:
                    "In numeric notation, 7 (4+2+1) is rwx, and 5 (4+0+1) is r-x. So, 755 translates to rwxr-xr-x.",
                },
                {
                  id: 2,
                  question:
                    "Why is a SUID-root binary a potential security risk?",
                  options: [
                    "It cannot be executed by normal users.",
                    "It runs with the permissions of the user who executes it.",
                    "It slows down the system.",
                    "A vulnerability in the binary could be exploited to gain root access.",
                  ],
                  correct: 3,
                  explanation:
                    "Because a SUID-root program runs with root privileges, any flaw that allows an attacker to control its execution can lead to a full system compromise.",
                },
                {
                  id: 3,
                  question:
                    "Which command is used to change file permissions in Linux?",
                  options: ["chown", "chmod", "chgrp", "setperm"],
                  correct: 1,
                  explanation:
                    "The `chmod` (change mode) command is used to set or modify the read, write, and execute permissions of files and directories.",
                },
              ],
            },
          },
          {
            id: "lesson-5",
            title: "Securing Network Services",
            duration: "90 min",
            objectives: [
              "Understand the principle of minimizing network-facing services",
              "Learn the basics of host-based firewalls (iptables/UFW)",
              "Know how to identify and disable unused or insecure services",
              "Recognize the importance of port scanning from a defensive perspective",
            ],
            content: {
              overview:
                "Every service listening on a network port is a potential entry point for an attacker. This lesson focuses on reducing the network attack surface by disabling unnecessary services and using a host-based firewall to control traffic to the services that remain.",
              sections: [
                {
                  title: "Disabling Unused Services",
                  content:
                    "<p>A default installation of an operating system often includes numerous network services that you may not need, such as FTP, Telnet, or printing services. Each of these services increases the attack surface of the system.</p><h3>The Hardening Process:</h3><ol><li><strong>Identify Listening Services:</strong> Use tools like `netstat` or `ss` to see which ports are open and which processes are listening on them.</li><li><strong>Evaluate Necessity:</strong> For each service, determine if it is essential for the system's function. If not, it should be disabled.</li><li><strong>Disable and Mask:</strong> Use the system's service manager (like `systemd`) to stop the service from running and prevent it from starting on boot.</li></ol>",
                  image:
                    "https://images.unsplash.com/photo-1504384308090-c894fdcc538d?w=800&h=400&fit=crop",
                },
                {
                  title: "Host-Based Firewalls",
                  content:
                    '<p>A host-based firewall runs on an individual server and controls network traffic coming into and out of that specific machine. It acts as a crucial layer of defense, especially if a network-level firewall is breached.</p><h3>Key Concepts:</h3><ul><li><strong>Default Deny Policy:</strong> The most secure firewall policy is to deny all traffic by default and then create specific rules to allow only the traffic that is absolutely necessary.</li><li><strong>Stateful Inspection:</strong> Modern firewalls are stateful, meaning they track the state of network connections. If they see an outgoing request, they will automatically allow the incoming response, making rule creation easier.</li><li><strong>Common Tools:</strong> In Linux, `iptables` is the powerful but complex underlying firewall technology. `UFW` (Uncomplicated Firewall) is a user-friendly frontend for `iptables` that is ideal for most use cases.</li></ul><div class="info-box note"><div class="info-box-header"><i class="fas fa-info-circle"></i><strong>Defense in Depth</strong></div><p>Even if a service has a vulnerability, a properly configured firewall that blocks access to it from untrusted sources can prevent an exploit from succeeding.</p></div>',
                  image:
                    "https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?w=800&h=400&fit=crop",
                },
              ],
            },
            codeExamples: [
              {
                title: "Lab: Disable Telnet and Allow SSH Only",
                language: "bash",
                code: "# 1. Check if Telnet service is running (it might be called telnetd or inetd)\nsudo systemctl status inetd\n\n# 2. If it exists, stop and disable it\nsudo systemctl stop inetd\nsudo systemctl disable inetd\n\n# 3. Install UFW (Uncomplicated Firewall)\nsudo apt-get update\nsudo apt-get install ufw\n\n# 4. Set the default policy to deny incoming traffic\nsudo ufw default deny incoming\n\n# 5. Explicitly allow SSH traffic (port 22)\nsudo ufw allow ssh\n# Alternative: sudo ufw allow 22/tcp\n\n# 6. Enable the firewall\nsudo ufw enable\n# Make sure to type 'y' when prompted, ensuring your SSH connection won't be dropped.\n\n# 7. Check the firewall status\nsudo ufw status verbose\n# You should see that traffic is denied by default, with an exception for port 22.",
              },
            ],
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the primary reason to disable unused network services?",
                  options: [
                    "To save disk space",
                    "To improve network speed",
                    "To reduce the system's attack surface",
                    "To free up memory",
                  ],
                  correct: 2,
                  explanation:
                    "Every listening service is a potential point of entry for an attacker. Disabling services you don't need minimizes these potential entry points.",
                },
                {
                  id: 2,
                  question: "A 'default deny' firewall policy means:",
                  options: [
                    "All traffic is allowed by default.",
                    "All traffic is blocked unless a specific rule allows it.",
                    "Only web traffic is allowed.",
                    "The firewall is turned off.",
                  ],
                  correct: 1,
                  explanation:
                    "A 'default deny' or 'implicit deny' policy is a best practice where all traffic is blocked, and you must explicitly create 'allow' rules for necessary services.",
                },
                {
                  id: 3,
                  question:
                    "Which Linux command is commonly used to see which network ports are open and listening?",
                  options: ["ls -p", "netstat -tulpn", "ps aux", "df -h"],
                  correct: 1,
                  explanation:
                    "`netstat -tulpn` (or its modern equivalent `ss -tulpn`) is a command used to display all listening TCP and UDP ports and the programs associated with them.",
                },
              ],
            },
          },
          {
            id: "lesson-6",
            title: "Windows Hardening",
            duration: "120 min",
            objectives: [
              "Understand the role of Microsoft Defender Antivirus",
              "Learn how to use Group Policy Objects (GPOs) to enforce security settings",
              "Recognize the importance of BitLocker for disk encryption",
              "Apply security settings from a recognized benchmark like CIS",
            ],
            content: {
              overview:
                "This lesson focuses on the security features built into the Windows operating system. We will explore how to leverage tools like Group Policy, Microsoft Defender, and BitLocker to create a robust and secure Windows environment based on industry-standard benchmarks.",
              sections: [
                {
                  title: "Group Policy Objects (GPO)",
                  content:
                    "<p>Group Policy is a feature in Windows that provides centralized management and configuration of operating systems, applications, and users' settings in an Active Directory environment. For standalone machines, the Local Group Policy Editor provides similar functionality.</p><h3>Common Hardening GPOs:</h3><ul><li><strong>Password Policies:</strong> Enforce complexity, length, and history requirements.</li><li><strong>Account Lockout Policies:</strong> Lock accounts after a certain number of failed login attempts to thwart brute-force attacks.</li><li><strong>Audit Policies:</strong> Configure detailed logging for security events like logon attempts and object access.</li><li><strong>User Rights Assignment:</strong> Control which users and groups can perform specific actions, like shutting down the system or logging on locally.</li><li><strong>Software Restriction Policies:</strong> Prevent unauthorized software from running.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1614285459395-654981d3e232?w=800&h=400&fit=crop",
                },
                {
                  title: "Microsoft Defender and BitLocker",
                  content:
                    '<p>Windows includes powerful, built-in security tools that provide essential protection against common threats.</p><h3>Microsoft Defender Antivirus:</h3><ul><li>Provides real-time protection against viruses, malware, spyware, and other threats.</li><li>Includes features like cloud-delivered protection for rapid threat identification and tamper protection to prevent malicious apps from changing important security settings.</li></ul><h3>BitLocker Drive Encryption:</h3><ul><li>A full-volume encryption feature that protects your data if a device is lost or stolen.</li><li>It encrypts the entire drive, and the system will not boot or resume from hibernation until the user presents the correct PIN, password, or USB key.</li><li>It leverages a Trusted Platform Module (TPM) chip for the most secure implementation, which stores the encryption keys separately from the disk.</li></ul><div class="info-box note"><div class="info-box-header"><i class="fas fa-info-circle"></i><strong>Built-in and Effective</strong></div><p>For most users and many organizations, the security tools built into modern Windows versions provide a very high level of protection when configured correctly.</p></div>',
                  image:
                    "https://images.unsplash.com/photo-1593642702821-c8da6771f0c6?w=800&h=400&fit=crop",
                },
              ],
            },
            codeExamples: [
              {
                title:
                  "Lab: Apply CIS Benchmark Settings in Windows (Local GPO)",
                language: "powershell",
                code: "# This lab uses the Local Group Policy Editor (gpedit.msc) and references a CIS Benchmark document.\n\n# 1. Download the CIS Benchmark for your Windows version (e.g., Windows 10, Windows Server 2022). These are available from the Center for Internet Security website.\n\n# 2. Open the Local Group Policy Editor: Run `gpedit.msc`\n\n# 3. Pick a specific setting from the benchmark document. For example, Section 2.2.2: 'Ensure 'Access this computer from the network' is set to 'Administrators, Remote Desktop Users''.\n\n# 4. In gpedit, navigate to:\n#    Computer Configuration > Windows Settings > Security Settings > Local Policies > User Rights Assignment\n\n# 5. Find the policy 'Access this computer from the network'.\n\n# 6. Double-click the policy and remove any unnecessary groups (like 'Everyone' or 'Users'). Add 'Administrators' and 'Remote Desktop Users' if they are not present.\n\n# 7. Apply the changes. This is a manual but effective way to harden a standalone system according to best practices.",
              },
            ],
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "Which Windows feature is used for centralized configuration management in an Active Directory environment?",
                  options: [
                    "BitLocker",
                    "Microsoft Defender",
                    "Group Policy (GPO)",
                    "Windows Firewall",
                  ],
                  correct: 2,
                  explanation:
                    "Group Policy Objects (GPOs) are the primary tool for administrators to enforce security settings and configurations across a network of Windows machines.",
                },
                {
                  id: 2,
                  question: "What is the primary purpose of BitLocker?",
                  options: [
                    "To prevent viruses",
                    "To encrypt the entire hard drive",
                    "To manage user passwords",
                    "To block network attacks",
                  ],
                  correct: 1,
                  explanation:
                    "BitLocker is a full-volume encryption feature designed to protect data at rest, making it unreadable if the physical device is stolen.",
                },
                {
                  id: 3,
                  question:
                    "An 'Account Lockout Policy' helps protect against which type of attack?",
                  options: [
                    "Phishing",
                    "Denial of Service",
                    "Brute-Force Password Guessing",
                    "Malware",
                  ],
                  correct: 2,
                  explanation:
                    "By locking an account after a set number of incorrect password attempts, an Account Lockout Policy makes it infeasible for an attacker to guess a password through automated brute-force methods.",
                },
              ],
            },
          },
          {
            id: "lesson-7",
            title: "Linux Hardening",
            duration: "120 min",
            objectives: [
              "Understand the concept of Mandatory Access Control (MAC)",
              "Learn about SELinux and AppArmor",
              "Use Fail2ban to mitigate brute-force attacks",
              "Recognize the importance of kernel parameter tuning",
            ],
            content: {
              overview:
                "This lesson goes beyond standard permissions to explore advanced Linux security mechanisms. We will cover Mandatory Access Control systems like SELinux and AppArmor, which provide granular control over processes, and proactive defense tools like Fail2ban that respond to malicious activity in real time.",
              sections: [
                {
                  title: "SELinux and AppArmor",
                  content:
                    "<p>Standard Linux permissions are a form of Discretionary Access Control (DAC), where the user (owner) can change permissions. Mandatory Access Control (MAC) is a system where a central policy dictates what processes can do, regardless of ownership.</p><h3>SELinux (Security-Enhanced Linux):</h3><ul><li>Extremely powerful and granular. It labels every file, process, and port on the system.</li><li>A central policy defines how labeled objects can interact (e.g., process 'httpd_t' can read files labeled 'httpd_sys_content_t').</li><li>Common in Red Hat-based distributions (RHEL, CentOS, Fedora).</li><li>Operates in one of three modes: Enforcing (blocks violations), Permissive (logs but allows violations), and Disabled.</li></ul><h3>AppArmor (Application Armor):</h3><ul><li>Profile-based, focusing on paths. It defines which files a specific application is allowed to access.</li><li>Generally considered easier to configure and manage than SELinux.</li><li>Common in Debian-based distributions (Ubuntu, Debian, SUSE).</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1629654297299-c8506221ca97?w=800&h=400&fit=crop",
                },
                {
                  title: "Fail2ban",
                  content:
                    '<p>Fail2ban is an intrusion prevention software framework that protects computer servers from brute-force attacks. It works by scanning log files (e.g., for SSH, Apache, etc.) and banning IP addresses that show malicious signs, such as too many password failures.</p><h3>How it Works:</h3><ol><li><strong>Monitor Logs:</strong> Fail2ban \'jails\' are configured to monitor specific log files for patterns (e.g., \'Failed password for root\').</li><li><strong>Detect Intrusion:</strong> If an IP address generates too many of these patterns within a set time, it is considered an attacker.</li><li><strong>Ban IP:</strong> Fail2ban then updates the system\'s firewall (e.g., iptables) to drop all packets from that IP address for a configurable amount of time.</li></ol><div class="info-box note"><div class="info-box-header"><i class="fas fa-info-circle"></i><strong>Proactive Defense</strong></div><p>Fail2ban is an excellent example of an automated, proactive defense that can stop many common, low-sophistication attacks before they succeed.</p></div>',
                  image:
                    "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit=crop",
                },
              ],
            },
            codeExamples: [
              {
                title: "Lab: Configure Fail2ban for SSH",
                language: "bash",
                code: "# 1. Install Fail2ban\nsudo apt-get update\nsudo apt-get install fail2ban\n\n# 2. The service starts automatically. To configure it, copy the default config file to a local version.\n# Never edit the .conf file directly, as it can be overwritten by updates.\nsudo cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local\n\n# 3. Open the new local configuration file for editing\nsudo nano /etc/fail2ban/jail.local\n\n# 4. Find the [sshd] section. You can customize settings here. For example:\n# bantime  = 1h       # How long to ban an IP (e.g., 1 hour)\n# findtime = 10m      # The time window to watch for failures (e.g., 10 minutes)\n# maxretry = 3        # The number of failures before a ban\n\n# 5. Make sure the [sshd] section is enabled:\nenabled = true\n\n# 6. Save the file and restart the Fail2ban service for changes to take effect\nsudo systemctl restart fail2ban\n\n# 7. Check the status of the SSH jail\nsudo fail2ban-client status sshd\n# This will show you a list of currently banned IPs.",
              },
            ],
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the primary difference between Mandatory Access Control (MAC) and Discretionary Access Control (DAC)?",
                  options: [
                    "MAC is for networks, DAC is for files.",
                    "In MAC, a central policy determines access, while in DAC, the owner does.",
                    "MAC is only on Linux, DAC is only on Windows.",
                    "There is no difference.",
                  ],
                  correct: 1,
                  explanation:
                    "In DAC (standard permissions), the owner of an object can change its permissions. In MAC (SELinux/AppArmor), access is dictated by a system-wide policy that users cannot change.",
                },
                {
                  id: 2,
                  question: "What is the main function of Fail2ban?",
                  options: [
                    "To encrypt files.",
                    "To update software packages.",
                    "To scan log files and block malicious IPs.",
                    "To manage user accounts.",
                  ],
                  correct: 2,
                  explanation:
                    "Fail2ban's core purpose is to parse log files for signs of automated attacks (like brute-forcing) and use the firewall to block the offending IP addresses.",
                },
                {
                  id: 3,
                  question:
                    "Which of these is a popular Mandatory Access Control system in Red Hat-based Linux distributions?",
                  options: ["AppArmor", "Fail2ban", "SELinux", "UFW"],
                  correct: 2,
                  explanation:
                    "SELinux (Security-Enhanced Linux) is the MAC system most closely associated with and enabled by default in distributions like RHEL, CentOS, and Fedora.",
                },
              ],
            },
          },
          {
            id: "lesson-8",
            title: "Patch Management",
            duration: "75 min",
            objectives: [
              "Understand why timely patch management is critical for security",
              "Learn the difference between patches, updates, and upgrades",
              "Recognize the risks and benefits of automated patching",
              "Configure automated security updates on a Linux system",
            ],
            content: {
              overview:
                "Unpatched software is one of the most common ways attackers compromise systems. This lesson covers the crucial process of patch management, from understanding patch types to implementing a strategy that ensures systems are protected from known vulnerabilities in a timely manner.",
              sections: [
                {
                  title: "The Importance of Patching",
                  content:
                    '<p>When a security vulnerability is discovered in software, the vendor typically releases a \'patch\' to fix it. Patch management is the process of identifying, testing, and deploying these patches to your systems. </p><h3>Why it\'s Critical:</h3><ul><li><strong>Closing Attack Windows:</strong> Attackers actively scan for systems that are vulnerable to newly announced exploits. Fast patching closes this window of opportunity.</li><li><strong>Compliance:</strong> Many regulatory and compliance frameworks (like PCI-DSS and HIPAA) mandate timely patching of systems.</li><li><strong>System Stability:</strong> Patches often include bug fixes that improve the stability and performance of software, not just its security.</li></ul><div class="info-box warning"><div class="info-box-header"><i class="fas fa-exclamation-triangle"></i><strong>Exploits Follow Patches</strong></div><p>Attackers often reverse-engineer security patches to understand the vulnerability they fix. This makes it a race to apply the patch before the exploit becomes widespread.</p></div>',
                  image:
                    "https://images.unsplash.com/photo-1529465230221-a0d100463342?w=800&h=400&fit=crop",
                },
                {
                  title: "Patch Management Strategy",
                  content:
                    "<p>A good patch management strategy balances security with stability. While applying patches quickly is important, applying an untested patch could also cause an outage.</p><h3>Key Steps:</h3><ol><li><strong>Inventory:</strong> Know what systems and software you have. You can't patch what you don't know you have.</li><li><strong>Monitor:</strong> Subscribe to vendor security mailing lists and threat intelligence feeds to be notified of new patches.</li><li><strong>Prioritize:</strong> Assess the risk of the vulnerability. A critical remote code execution flaw in a public-facing web server should be patched before a low-severity flaw in an internal tool. Use the CVSS score to help.</li><li><strong>Test:</strong> Apply patches in a non-production environment first to ensure they don't break critical applications.</li><li><strong>Deploy:</strong> Roll out the patches to production systems. This can be done manually or using automated tools.</li><li><strong>Verify:</strong> Confirm that the patches were successfully installed and that the systems are functioning correctly.</li></ol>",
                  image:
                    "https://images.unsplash.com/photo-1581093450021-4a7360b9a6b5?w=800&h=400&fit=crop",
                },
              ],
            },
            codeExamples: [
              {
                title: "Lab: Configure Unattended Upgrades on Debian/Ubuntu",
                language: "bash",
                code: '# 1. Install the necessary package\nsudo apt-get update\nsudo apt-get install unattended-upgrades\n\n# 2. Configure the main settings. The file is /etc/apt/apt.conf.d/50unattended-upgrades.\n# By default, it\'s often configured to install security updates automatically.\n# You can review the file to see which sources are enabled:\n# For example, `"${distro_id}:${distro_codename}-security";` should be uncommented.\n\n# 3. To enable automatic installation, you need to configure APT\'s periodic settings.\nsudo nano /etc/apt/apt.conf.d/20auto-upgrades\n\n# 4. Make sure the file contains the following lines to check daily and install upgrades:\n# APT::Periodic::Update-Package-Lists "1";\n# APT::Periodic::Unattended-Upgrade "1";\n\n# 5. You can also enable options like automatic cleaning of old packages or rebooting if necessary.\n# APT::Periodic::AutocleanInterval "7";\n# Unattended-Upgrade::Automatic-Reboot "true";\n\n# 6. Save the file. The system will now automatically download and apply security patches daily.',
              },
            ],
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the primary reason for prompt patch management?",
                  options: [
                    "To get new software features",
                    "To reduce the window of opportunity for attackers to exploit known vulnerabilities",
                    "To free up disk space",
                    "To make the system run faster",
                  ],
                  correct: 1,
                  explanation:
                    "The main driver for patch management from a security perspective is to close known security holes before they can be exploited by malicious actors.",
                },
                {
                  id: 2,
                  question:
                    "What is a common first step in a patch management strategy?",
                  options: [
                    "Deploying all patches immediately",
                    "Creating an inventory of all systems and software",
                    "Ignoring low-severity patches",
                    "Disabling automatic updates",
                  ],
                  correct: 1,
                  explanation:
                    "You cannot effectively manage patches for systems and software you are not aware of. A comprehensive inventory is a foundational step.",
                },
                {
                  id: 3,
                  question:
                    "What is a potential risk of a fully automated patching process?",
                  options: [
                    "Patches might not be applied quickly enough",
                    "It requires too much manual work",
                    "An untested patch could cause a service outage or instability",
                    "It is too expensive",
                  ],
                  correct: 2,
                  explanation:
                    "While automation is efficient, it carries the risk that a patch with an unforeseen bug could be rolled out across all systems simultaneously, potentially causing widespread issues. This is why testing is crucial.",
                },
              ],
            },
          },
          {
            id: "lesson-9",
            title: "Secure Remote Access",
            duration: "90 min",
            objectives: [
              "Understand best practices for hardening the SSH service",
              "Learn how to implement key-based authentication for SSH",
              "Recognize security considerations for Remote Desktop Protocol (RDP)",
              "Disable insecure remote access protocols",
            ],
            content: {
              overview:
                "Remote administration is essential, but it's also a primary target for attackers. This lesson covers how to secure the two most common remote access protocols: SSH for Linux and RDP for Windows. We'll focus on moving beyond passwords to more secure authentication methods and configuring these services to resist attacks.",
              sections: [
                {
                  title: "Hardening SSH",
                  content:
                    "<p>Secure Shell (SSH) is the standard for remote management of Linux systems. A default SSH configuration is good, but it can be made much more secure.</p><h3>Key Hardening Steps:</h3><ul><li><strong>Disable Root Login:</strong> Attackers know the 'root' username exists. Disabling direct root login (`PermitRootLogin no`) forces them to guess a username and forces administrators to log in as a standard user and elevate privileges with `sudo`, which provides an audit trail.</li><li><strong>Disable Password Authentication:</strong> Password-based logins are susceptible to brute-force attacks. Disabling them (`PasswordAuthentication no`) and requiring key-based authentication is a massive security improvement.</li><li><strong>Use a Non-Standard Port:</strong> While this is 'security through obscurity' and won't stop a determined attacker, changing the SSH port from 22 to something else will dramatically reduce the number of automated scans and bots hitting your server.</li><li><strong>Limit User Access:</strong> Use the `AllowUsers` or `AllowGroups` directives to explicitly specify which users or groups are allowed to log in via SSH.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1614064548237-096537e54249?w=800&h=400&fit=crop",
                },
                {
                  title: "Securing RDP",
                  content:
                    '<p>Remote Desktop Protocol (RDP) is the equivalent of SSH for Windows graphical remote access. Publicly exposed RDP is a major target for ransomware gangs.</p><h3>Key Hardening Steps:</h3><ul><li><strong>Use a VPN:</strong> Do not expose RDP directly to the internet. Require users to connect to a Virtual Private Network (VPN) first, and then allow RDP access over the VPN tunnel.</li><li><strong>Enable Network Level Authentication (NLA):</strong> NLA requires a user to authenticate to the remote server before a full RDP session is established. This helps mitigate denial-of-service attacks and saves server resources.</li><li><strong>Use Strong Passwords and Account Lockout:</strong> Since RDP often relies on passwords, it\'s crucial that strong password and account lockout policies are enforced.</li><li><strong>Limit Administrator Access:</strong> Ensure that only necessary users are members of the \'Remote Desktop Users\' group.</li></ul><div class="info-box tip"><div class="info-box-header"><i class="fas fa-lightbulb"></i><strong>RDP Gateway</strong></div><p>For larger environments, a Remote Desktop Gateway allows authorized users to connect to internal network resources from any internet-connected device without exposing the RDP port on the servers themselves.</p></div>',
                  image:
                    "https://images.unsplash.com/photo-1544197150-b99a580bb7a8?w=800&h=400&fit=crop",
                },
              ],
            },
            codeExamples: [
              {
                title: "Lab: Configure Key-Based SSH Authentication",
                language: "bash",
                code: "# On your LOCAL (client) machine:\n# 1. Generate an SSH key pair. Press Enter to accept defaults.\nssh-keygen -t rsa -b 4096\n\n# 2. Copy your public key to the remote server (replace 'user' and 'remote_host').\nssh-copy-id user@remote_host\n# This command appends your public key to ~/.ssh/authorized_keys on the server.\n\n# On the REMOTE server:\n# 3. Now, try to log in. You should not be prompted for a password.\nssh user@remote_host\n\n# 4. Once you've confirmed key-based login works, you can disable password authentication.\n#    Edit the SSH daemon configuration file:\nsudo nano /etc/ssh/sshd_config\n\n# 5. Find and change the following lines:\n# PasswordAuthentication no\n# PermitRootLogin no\n\n# 6. Restart the SSH service to apply the changes.\nsudo systemctl restart sshd\n\n# Now, only users with a valid private key can log in.",
              },
            ],
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the most significant security benefit of using SSH keys instead of passwords?",
                  options: [
                    "It makes logins faster.",
                    "It makes logins easier to remember.",
                    "It protects against brute-force password guessing attacks.",
                    "It uses less network bandwidth.",
                  ],
                  correct: 2,
                  explanation:
                    "Since a private key is a very large, cryptographically secure file, it is practically impossible to brute-force. Disabling password authentication entirely eliminates the risk of password guessing attacks.",
                },
                {
                  id: 2,
                  question:
                    "Why is it recommended to disable direct root login via SSH?",
                  options: [
                    "The root account is slow.",
                    "It forces administrators to use sudo, which creates an audit log of their actions.",
                    "The root account cannot use SSH keys.",
                    "It is no longer supported in modern Linux.",
                  ],
                  correct: 1,
                  explanation:
                    "Disabling direct root login improves accountability, as actions are tied to a specific user's account in the sudo logs. It also forces an attacker to guess a valid username in addition to a password/key.",
                },
                {
                  id: 3,
                  question:
                    "What is the best practice for securing RDP access from the internet?",
                  options: [
                    "Use a very simple password.",
                    "Expose it directly to the internet on the default port 3389.",
                    "Require users to connect through a VPN first.",
                    "Disable Network Level Authentication (NLA).",
                  ],
                  correct: 2,
                  explanation:
                    "Exposing RDP directly to the internet is extremely risky. The best practice is to place the server behind a VPN or an RDP Gateway, which adds a layer of authentication and encryption before the RDP protocol is even accessible.",
                },
              ],
            },
          },
          {
            id: "lesson-10",
            title: "Logging & Auditing",
            duration: "90 min",
            objectives: [
              "Understand the importance of system logging for security",
              "Learn about the syslog standard and its components",
              "Explore the Linux audit framework (auditd)",
              "Grasp the concept of a SIEM for centralized log analysis",
            ],
            content: {
              overview:
                "You cannot defend against what you cannot see. Effective logging and auditing are the cornerstones of security monitoring, incident response, and forensic analysis. This lesson covers how systems generate logs, how to configure more detailed auditing, and how organizations manage logs at scale.",
              sections: [
                {
                  title: "The Role of Logging",
                  content:
                    '<p>System logs are records of events that occur on a computer system. From a security perspective, they are essential for several reasons:</p><h3>Key Uses of Logs:</h3><ul><li><strong>Intrusion Detection:</strong> Analyzing logs can reveal suspicious activity, such as repeated failed login attempts, which could indicate a brute-force attack.</li><li><strong>Incident Response:</strong> During and after a security breach, logs provide a timeline of events, showing what an attacker did, which files they accessed, and how they gained entry.</li><li><strong>Auditing and Compliance:</strong> Logs provide an audit trail to demonstrate compliance with security policies and regulations. They show who accessed what data and when.</li><li><strong>Troubleshooting:</strong> Logs are also invaluable for diagnosing system errors and performance issues.</li></ul><div class="info-box note"><div class="info-box-header"><i class="fas fa-info-circle"></i><strong>What to Log</strong></div><p>Key events to log include: user logins (success and failure), privilege escalations (e.g., use of `sudo`), software installation, system startup/shutdown, and access to sensitive files.</p></div>',
                  image:
                    "https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?w=800&h=400&fit=crop",
                },
                {
                  title: "Centralized Logging and SIEM",
                  content:
                    "<p>Managing logs on individual machines doesn't scale and is insecure (an attacker could alter local logs). Therefore, organizations use centralized logging.</p><h3>Syslog:</h3><p>Syslog is a standard protocol for sending log messages. Most network devices and Linux systems can be configured to act as syslog clients, forwarding their logs to a central syslog server.</p><h3>SIEM (Security Information and Event Management):</h3><p>A SIEM is a sophisticated system that goes far beyond simple log collection. It provides:<ul><li><strong>Aggregation:</strong> Collects logs from diverse sources (servers, firewalls, applications, etc.).</li><li><strong>Correlation:</strong> Analyzes events from different sources to identify patterns and potential security incidents. For example, it could correlate a firewall alert with a server login failure and a malware detection event to identify a coordinated attack.</li><li><strong>Alerting:</strong> Automatically notifies security personnel of high-priority incidents.</li><li><strong>Reporting and Dashboards:</strong> Provides visualization and reporting for compliance and analysis.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop",
                },
              ],
            },
            codeExamples: [
              {
                title: "Lab: Configure auditd in Linux to Monitor a File",
                language: "bash",
                code: "# 1. Install the auditd package\nsudo apt-get update\nsudo apt-get install auditd audispd-plugins\n\n# 2. Let's create a rule to watch for any read, write, or attribute changes to /etc/shadow.\n#    Add a rule to the audit rules file:\nsudo nano /etc/audit/rules.d/audit.rules\n\n# 3. Add the following line to the end of the file:\n# -w /etc/shadow -p rwa -k shadow_watch\n#\n# Explanation:\n# -w /etc/shadow : The file to watch.\n# -p rwa         : The permissions to watch for (read, write, attribute change).\n# -k shadow_watch: A key to uniquely identify this rule in the logs.\n\n# 4. Restart the auditd service to load the new rule.\nsudo systemctl restart auditd\n\n# 5. Now, trigger the rule by trying to read the file.\nsudo cat /etc/shadow\n\n# 6. Search the audit log for events matching our key.\nsudo ausearch -k shadow_watch | aureport -f -i\n# This will show you a formatted report of the access event, including the user who ran the command.",
              },
            ],
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question: "What is the primary purpose of a SIEM system?",
                  options: [
                    "To install software patches.",
                    "To block network traffic.",
                    "To aggregate and correlate logs from multiple sources for security analysis.",
                    "To encrypt hard drives.",
                  ],
                  correct: 2,
                  explanation:
                    "A SIEM's core function is to provide a single pane of glass for security events by collecting, parsing, and correlating log data from across the entire IT environment.",
                },
                {
                  id: 2,
                  question:
                    "Why is centralized logging considered more secure than local logging?",
                  options: [
                    "It uses less disk space.",
                    "It prevents an attacker from easily erasing their tracks by deleting local log files.",
                    "It is faster.",
                    "It doesn't require any configuration.",
                  ],
                  correct: 1,
                  explanation:
                    "By immediately forwarding logs to a remote, secure server, you ensure that even if an attacker compromises a machine, the record of their initial actions is preserved elsewhere.",
                },
                {
                  id: 3,
                  question:
                    "In the context of security, what is an 'audit trail'?",
                  options: [
                    "A list of available software updates.",
                    "A chronological record of system activities that provides evidence of events.",
                    "A network firewall configuration.",
                    "A user's password history.",
                  ],
                  correct: 1,
                  explanation:
                    "An audit trail is a log that tracks activities step-by-step, allowing security professionals to reconstruct events, determine who did what, and when they did it.",
                },
              ],
            },
          },
          {
            id: "lesson-11",
            title: "Application Security",
            duration: "90 min",
            objectives: [
              "Understand the importance of hardening web-application stacks",
              "Learn key configuration options for Apache and MySQL",
              "Apply the principle of least privilege to application services",
              "Perform a hands-on lab to secure an Apache web server",
            ],
            content: {
              overview:
                "Web applications are among the most targeted components of any infrastructure. This lesson focuses on hardening the two pillars of the classic LAMP stack—Apache and MySQL—by removing unnecessary features, enforcing secure defaults, and limiting exposure at every layer.",
              sections: [
                {
                  title: "Hardening Apache HTTP Server",
                  content:
                    "<p>Apache ships with many convenience features that are rarely needed in production and often enlarge the attack surface. The goal is to disable what you don’t use and lock down what you do.</p><h3>Key Hardening Steps</h3><ul><li><strong>Hide version/OS banners:</strong> Prevent information leakage in HTTP response headers (<code>ServerTokens Prod</code> and <code>ServerSignature Off</code>).</li><li><strong>Disable directory indexing:</strong> Ensure <code>Options -Indexes</code> is set so that sensitive file listings are never exposed.</li><li><strong>Uninstall unused modules:</strong> Remove or disable modules like <code>status</code>, <code>autoindex</code>, <code>userdir</code>, <code>info</code>, etc.</li><li><strong>Enforce HTTPS:</strong> Redirect all HTTP traffic to HTTPS and use strong ciphers (<code>SSLProtocol all -SSLv3 -TLSv1 -TLSv1.1</code>).</li><li><strong>Run as an unprivileged user:</strong> Create a dedicated, non-login user (<code>www-data</code> or <code>apache</code>) and ensure Apache processes run under that account only.</li><li><strong>Limit request size and timeouts:</strong> Configure <code>LimitRequestBody</code>, <code>RequestReadTimeout</code>, and <code>Timeout</code> to mitigate DoS vectors.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit=crop",
                },
                {
                  title: "Hardening MySQL Server",
                  content:
                    "<p>MySQL’s default installation is intended for ease of use, not security. The following measures reduce risk without breaking common applications.</p><h3>Key Hardening Steps</h3><ul><li><strong>Run <code>mysql_secure_installation</code>:</strong> Removes anonymous users, disables remote root login, and deletes the test database.</li><li><strong>Create application-specific accounts:</strong> Grant the minimal set of privileges (SELECT, INSERT, UPDATE, DELETE) on only the databases the app needs.</li><li><strong>Disable or restrict networking:</strong> Bind MySQL to <code>127.0.0.1</code> or a private subnet interface; disable <code>skip-networking</code> if not required.</li><li><strong>Encrypt connections:</strong> Require SSL/TLS for client connections and enforce <code>REQUIRE SSL</code> on user accounts.</li><li><strong>Enable binary logging & audit plugin:</strong> Capture all DDL/DML statements for forensic analysis.</li><li><strong>Secure the file system:</strong> Ensure the MySQL data directory and configuration files are readable only by the <code>mysql</code> user.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?w=800&h=400&fit=crop",
                },
              ],
            },
            codeExamples: [
              {
                title: "Lab: Harden Apache Web Server",
                language: "bash",
                code: '# 0. Prerequisites (Ubuntu 22.04)\nsudo apt update && sudo apt install -y apache2\n\n# 1. Backup original configuration\nsudo cp /etc/apache2/apache2.conf /etc/apache2/apache2.conf.bak\nsudo cp /etc/apache2/sites-available/000-default.conf /etc/apache2/sites-available/000-default.conf.bak\n\n# 2. Hide server banners and disable server-status\necho "ServerTokens Prod" | sudo tee -a /etc/apache2/conf-available/security.conf\necho "ServerSignature Off" | sudo tee -a /etc/apache2/conf-available/security.conf\nsudo a2enconf security\n\n# 3. Disable unused modules\nsudo a2dismod status autoindex info userdir\n\n# 4. Disable directory indexing\nsudo sed -i \'s/Options Indexes FollowSymLinks/Options FollowSymLinks/\' /etc/apache2/sites-available/000-default.conf\n\n# 5. Redirect HTTP to HTTPS (requires SSL site)\nsudo a2enmod rewrite ssl\nsudo tee /etc/apache2/sites-available/000-default-ssl.conf > /dev/null <<EOF\n<VirtualHost *:443>\n    ServerAdmin webmaster@localhost\n    DocumentRoot /var/www/html\n    SSLEngine on\n    SSLCertificateFile /etc/ssl/certs/ssl-cert-snakeoil.pem\n    SSLCertificateKeyFile /etc/ssl/private/ssl-cert-snakeoil.key\n    SSLProtocol all -SSLv3 -TLSv1 -TLSv1.1\n    SSLCipherSuite ECDHE+AESGCM:ECDHE+CHACHA20:DHE+AESGCM:DHE+CHACHA20:!aNULL:!MD5:!DSS\n</VirtualHost>\nEOF\nsudo a2ensite 000-default-ssl\nsudo tee /etc/apache2/sites-available/000-default.conf > /dev/null <<EOF\n<VirtualHost *:80>\n    ServerAdmin webmaster@localhost\n    DocumentRoot /var/www/html\n    RewriteEngine On\n    RewriteCond %{HTTPS} off\n    RewriteRule ^ https://%{HTTP_HOST}%{REQUEST_URI} [L,R=301]\n</VirtualHost>\nEOF\n\n# 6. Run Apache under dedicated user (already default on Ubuntu)\n#    Check: grep -E \'^User|^Group\' /etc/apache2/apache2.conf\n\n# 7. Limit request body size (e.g., 10 MB)\necho "LimitRequestBody 10485760" | sudo tee -a /etc/apache2/conf-available/security.conf\n\n# 8. Restart Apache to apply all changes\nsudo systemctl restart apache2\n\n# 9. Verify configuration\nsudo apache2ctl configtest\nsudo systemctl status apache2 --no-pager',
              },
            ],
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the primary reason to disable directory indexing in Apache?",
                  options: [
                    "To improve page load speed",
                    "To prevent attackers from listing files in a directory",
                    "To enable HTTPS",
                    "To reduce memory usage",
                  ],
                  correct: 1,
                  explanation:
                    "Directory indexing can expose sensitive files (e.g., backups, source code) to attackers who browse the directory structure.",
                },
                {
                  id: 2,
                  question:
                    "Which Apache directive hides the server version from HTTP response headers?",
                  options: [
                    "ServerTokens Prod",
                    "Options -Indexes",
                    "AllowOverride None",
                    "SSLProtocol all",
                  ],
                  correct: 0,
                  explanation:
                    "`ServerTokens Prod` replaces the detailed server string with a single word 'Apache', reducing information leakage.",
                },
                {
                  id: 3,
                  question:
                    "After hardening, how do you verify that the Apache configuration is syntactically correct?",
                  options: [
                    "sudo systemctl restart apache2",
                    "sudo apache2ctl configtest",
                    "curl -I http://localhost",
                    "ps aux | grep apache",
                  ],
                  correct: 1,
                  explanation:
                    "`apache2ctl configtest` (or `httpd -t`) checks the configuration files for syntax errors before restarting the service.",
                },
              ],
            },
          },

          {
            id: "lesson-12",
            title: "Browser & Endpoint Security",
            duration: "75 min",
            objectives: [
              "Recognize the browser as a major attack vector",
              "Understand threats from malicious extensions and websites",
              "Learn about Endpoint Protection Platforms (EPP) and Antivirus (AV)",
              "Explore how enterprise policies can enforce browser security",
            ],
            content: {
              overview:
                "The endpoint—the user's computer—is often the weakest link in the security chain. This lesson focuses on securing the two primary components of the endpoint: the web browser, which is the gateway to the internet, and the endpoint protection software that acts as the last line of defense.",
              sections: [
                {
                  title: "The Browser as an Attack Vector",
                  content:
                    "<p>Modern web browsers are incredibly complex pieces of software that process untrusted code from the internet all day long. This makes them a prime target for attackers.</p><h3>Common Browser-Based Threats:</h3><ul><li><strong>Malicious Extensions:</strong> Browser extensions that seem useful can be a front for spyware, adware, or credential theft. It's crucial to only install extensions from reputable sources and grant them minimal permissions.</li><li><strong>Drive-By Downloads:</strong> A user can get infected with malware simply by visiting a compromised website, with no clicking or downloading required. The site exploits a vulnerability in the browser or one of its plugins.</li><li><strong>Phishing and Social Engineering:</strong> Malicious websites are designed to look legitimate to trick users into entering passwords, credit card numbers, or other sensitive information.</li><li><strong>Session Hijacking:</strong> Attackers can steal a user's session cookies to gain access to their logged-in accounts on websites.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1618401471353-b98afee0b2eb?w=800&h=400&fit=crop",
                },
                {
                  title: "Endpoint Protection",
                  content:
                    '<p>Endpoint security refers to the practice of securing endpoints or end-user devices like desktops, laptops, and mobile devices.</p><h3>Key Technologies:</h3><ul><li><strong>Traditional Antivirus (AV):</strong> Scans files for known malware signatures. It\'s effective against known threats but can miss new, unknown malware (zero-day attacks).</li><li><strong>Next-Generation Antivirus (NGAV) / Endpoint Protection Platform (EPP):</strong> Goes beyond signatures. It uses machine learning, behavioral analysis, and exploit prevention techniques to detect and block malicious activity even from unknown malware.</li><li><strong>Endpoint Detection and Response (EDR):</strong> Assumes a breach will happen. EDR tools provide deep visibility into endpoint activity, continuously monitoring and recording events. This allows security teams to detect, investigate, and respond to advanced threats that might bypass protection mechanisms.</li></ul><div class="info-box note"><div class="info-box-header"><i class="fas fa-info-circle"></i><strong>Layered Defense</strong></div><p>A strong endpoint security strategy combines multiple layers: a secure browser configuration, a robust EPP for prevention, and an EDR for detection and response.</p></div>',
                  image:
                    "https://images.unsplash.com/photo-1563986768711-b3Bde3dc821e?w=800&h=400&fit=crop",
                },
              ],
            },
            codeExamples: [
              {
                title: "Lab: Configure Chrome Enterprise Policies (Conceptual)",
                language: "bash",
                code: "# This lab is conceptual, as it requires a Google Admin console or modifying the Windows Registry/macOS profiles.\n\n# In an enterprise environment, administrators can enforce hundreds of Chrome policies.\n# Key security policies to enforce include:\n\n# 1. Block malicious sites:\n#    - Set 'SafeBrowsingEnabled' to 'true'.\n\n# 2. Control extensions:\n#    - Set 'ExtensionInstallBlocklist' to '*' (block all).\n#    - Then, use 'ExtensionInstallAllowlist' to specify only approved, vetted extensions.\n\n# 3. Disable outdated or insecure protocols:\n#    - Set 'SSLVersionMin' to 'tls1.2' to prevent downgrades to insecure SSL/TLS versions.\n\n# 4. Enforce updates:\n#    - Set 'RelaunchNotification' to '2' (required relaunch) and 'RelaunchWindow' to a set time (e.g., 72 hours) to ensure the browser is restarted to apply updates.\n\n# 5. Disable data leakage vectors:\n#    - Set 'PrintingEnabled' to 'false' if not needed.\n#    - Set 'DefaultDownloadDirectory' to a managed location.",
              },
            ],
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question: "What is a 'drive-by download'?",
                  options: [
                    "A download initiated by the user from a trusted website.",
                    "Malware downloaded and installed just by visiting a compromised website, without user interaction.",
                    "A file transferred from a USB drive.",
                    "An update to the web browser.",
                  ],
                  correct: 1,
                  explanation:
                    "A drive-by download exploits vulnerabilities in the browser or its plugins to install malware silently in the background as soon as a malicious page is loaded.",
                },
                {
                  id: 2,
                  question:
                    "What is the main advantage of Next-Generation Antivirus (NGAV) over traditional AV?",
                  options: [
                    "It only works on Windows.",
                    "It uses behavioral analysis and machine learning to detect unknown (zero-day) malware.",
                    "It is always free.",
                    "It doesn't require any updates.",
                  ],
                  correct: 1,
                  explanation:
                    "While traditional AV relies on signatures of known malware, NGAV focuses on detecting malicious behavior, allowing it to identify and block new threats that have never been seen before.",
                },
                {
                  id: 3,
                  question:
                    "Why is it a good security practice for an enterprise to blocklist all browser extensions by default?",
                  options: [
                    "Extensions make the browser slow.",
                    "It ensures that only extensions that have been reviewed and approved for security can be installed by users.",
                    "Extensions are expensive.",
                    "It's impossible to block extensions.",
                  ],
                  correct: 1,
                  explanation:
                    "This 'default deny' approach to extensions prevents users from inadvertently installing malicious or data-leaking add-ons, significantly reducing the browser's attack surface.",
                },
              ],
            },
          },
          {
            id: "lesson-13",
            title: "Disk Encryption",
            duration: "90 min",
            objectives: [
              "Understand the difference between data at rest and data in transit",
              "Learn the purpose of Full Disk Encryption (FDE)",
              "Explore FDE technologies like BitLocker (Windows) and LUKS (Linux)",
              "Recognize the role of the Trusted Platform Module (TPM)",
            ],
            content: {
              overview:
                "What happens if a laptop or server is physically stolen? If the data on the disk is not encrypted, it's trivial for a thief to access it. This lesson covers the crucial practice of encrypting data at rest using full disk encryption to ensure that physical theft does not result in a data breach.",
              sections: [
                {
                  title: "Data at Rest vs. Data in Transit",
                  content:
                    '<p>When discussing encryption, it\'s important to distinguish between the two states of data:</p><ul><li><strong>Data in Transit:</strong> Data that is actively moving from one location to another, such as across the internet or a private network. This data is protected by protocols like TLS/SSL (for HTTPS) and SSH.</li><li><strong>Data at Rest:</strong> Data that is inactive and stored physically in any digital form, such as on a hard drive, solid-state drive, or USB flash drive. Full Disk Encryption protects data at rest.</li></ul><div class="info-box tip"><div class="info-box-header"><i class="fas fa-lightbulb"></i><strong>Complete Protection</strong></div><p>To fully protect data, you must encrypt it both in transit and at rest. One without the other leaves a critical security gap.</p></div>',
                  image:
                    "https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?w=800&h=400&fit=crop",
                },
                {
                  title: "Full Disk Encryption (FDE)",
                  content:
                    "<p>Full Disk Encryption (FDE) is a technology that encrypts every bit of data that goes on a disk or disk volume. It happens automatically and is transparent to the user.</p><h3>Key Technologies:</h3><ul><li><strong>BitLocker (Windows):</strong> The FDE solution built into Professional and Enterprise versions of Windows. It's easy to use and provides strong security, especially when combined with a TPM.</li><li><strong>LUKS (Linux Unified Key Setup):</strong> The standard for disk encryption in Linux. LUKS is a specification that provides a standard on-disk format for encryption keys, making it compatible and flexible. It is the backend for most Linux FDE implementations.</li></ul><h3>Trusted Platform Module (TPM):</h3><p>A TPM is a dedicated microchip in a modern computer designed to secure hardware by integrating cryptographic keys into devices. For FDE, the TPM can store the disk encryption keys. This is more secure than just using a password because the keys are tied to the specific hardware, preventing someone from simply removing the hard drive and putting it in another machine to try and crack the password.</p>",
                  image:
                    "https://images.unsplash.com/photo-1548226509-108151480ac2?w=800&h=400&fit=crop",
                },
              ],
            },
            codeExamples: [
              {
                title: "Lab: Encrypt a Partition with LUKS on Linux",
                language: "bash",
                code: "# WARNING: This process is destructive to the data on the target partition. Use a new, unformatted partition or a virtual disk.\n# Replace '/dev/sdb1' with your target partition.\n\n# 1. Install the necessary tools\nsudo apt-get update\nsudo apt-get install cryptsetup\n\n# 2. Format the partition with LUKS. You will be prompted to create a strong passphrase.\n# This is the master passphrase that unlocks the encryption key.\nsudo cryptsetup luksFormat /dev/sdb1\n\n# 3. Open the encrypted partition. This creates a decrypted mapping in /dev/mapper.\n# You will be prompted for the passphrase you just created.\nsudo cryptsetup luksOpen /dev/sdb1 my_encrypted_volume\n\n# 4. Now, you can create a filesystem on the decrypted volume, just like any other device.\nsudo mkfs.ext4 /dev/mapper/my_encrypted_volume\n\n# 5. Create a mount point and mount the filesystem.\nsudo mkdir /mnt/secretdata\nsudo mount /dev/mapper/my_encrypted_volume /mnt/secretdata\n\n# 6. You can now read and write files to /mnt/secretdata. They will be encrypted automatically.\n\n# 7. When you are done, unmount and close the encrypted volume.\nsudo umount /mnt/secretdata\nsudo cryptsetup luksClose my_encrypted_volume",
              },
            ],
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "Full Disk Encryption primarily protects against what type of threat?",
                  options: [
                    "Network-based attacks like phishing.",
                    "Malware and viruses.",
                    "Physical theft of a laptop or hard drive.",
                    "Denial of Service attacks.",
                  ],
                  correct: 2,
                  explanation:
                    "The main purpose of FDE is to make the data on a drive unreadable if the physical device is lost or stolen, thus preventing a data breach.",
                },
                {
                  id: 2,
                  question:
                    "What is the role of a Trusted Platform Module (TPM) in disk encryption?",
                  options: [
                    "It increases the speed of the hard drive.",
                    "It securely stores the encryption keys, tying them to the specific hardware.",
                    "It scans for viruses.",
                    "It backs up the data.",
                  ],
                  correct: 1,
                  explanation:
                    "A TPM provides hardware-based security by storing the encryption keys separately from the encrypted disk, making it much harder for an attacker to extract them.",
                },
                {
                  id: 3,
                  question:
                    "Which technology is the standard for disk encryption in the Linux world?",
                  options: ["BitLocker", "FileVault", "LUKS", "EncryptFS"],
                  correct: 2,
                  explanation:
                    "LUKS (Linux Unified Key Setup) is the cross-distribution standard that provides a robust framework for managing encrypted volumes on Linux.",
                },
              ],
            },
          },
          {
            id: "lesson-14",
            title: "Backup Security",
            duration: "75 min",
            objectives: [
              "Understand why backups are a critical component of security",
              "Learn the 3-2-1 backup rule",
              "Recognize the importance of encrypting and testing backups",
              "See how backups are the last line of defense against ransomware",
            ],
            content: {
              overview:
                "A system can be hardened, patched, and monitored, but things can still go wrong. A robust backup strategy is the ultimate safety net, allowing you to recover from hardware failure, catastrophic data corruption, or a devastating ransomware attack. This lesson covers how to create a resilient and secure backup plan.",
              sections: [
                {
                  title: "The 3-2-1 Backup Rule",
                  content:
                    "<p>The 3-2-1 rule is a simple but powerful and widely accepted best practice for creating a resilient backup strategy.</p><ul><li><strong>THREE copies of your data:</strong> The original data on your primary device plus at least two backups.</li><li><strong>TWO different media types:</strong> Store your backups on at least two different types of storage to protect against failures of a specific medium. For example, an internal hard drive and an external USB drive, or an external drive and cloud storage.</li><li><strong>ONE copy off-site:</strong> Keep at least one backup copy in a different physical location from your primary data. This protects you from localized disasters like fire, flood, or theft.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1544890225-2fde0e66f35b?w=800&h=400&fit=crop",
                },
                {
                  title: "Backups and Ransomware Defense",
                  content:
                    "<p>Ransomware is a type of malware that encrypts a victim's files, making them inaccessible. The attacker then demands a ransom to provide the decryption key. In this scenario, secure backups are often the only way to recover without paying the ransom.</p><h3>Key Backup Security Practices:</h3><ul><li><strong>Encrypt Your Backups:</strong> The data in your backups can be just as sensitive as your live data. Always encrypt your backup files to protect them if the backup media is lost or stolen.</li><li><strong>Offline and Immutable Backups:</strong> Modern ransomware actively seeks out and tries to encrypt or delete connected backup drives. An offline backup (one that is physically disconnected, like a rotated USB drive) is immune to this. An immutable backup (often a feature of cloud storage) is one that cannot be changed or deleted for a set period, even by an administrator account, providing strong protection.</li><li><strong>Test Your Backups:</strong> A backup is useless if it can't be restored. Regularly test your recovery process to ensure the backups are not corrupt and that you know how to perform a restore when you're under pressure.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1599691533267-be243a970634?w=800&h=400&fit=crop",
                },
              ],
            },
            codeExamples: [
              {
                title: "Lab: Create an Encrypted Backup with GPG and Tar",
                language: "bash",
                code: "# This lab creates an encrypted, compressed archive of a user's home directory.\n\n# 1. We will use GnuPG (GPG) for symmetric encryption (using a passphrase).\n#    First, create the compressed archive using tar.\n#    Replace 'user' with your username.\n\ntar czf - /home/user > my_home_backup.tar.gz\n\n# 2. Now, encrypt the archive using GPG. The '-c' flag indicates symmetric encryption.\n#    You will be prompted to create and confirm a strong passphrase.\n\ngpg -c my_home_backup.tar.gz\n\n# 3. This creates a new file: 'my_home_backup.tar.gz.gpg'.\n#    This is your encrypted backup file. You can now securely move it to an external drive or cloud storage.\n\n# 4. Securely delete the unencrypted archive.\nrm my_home_backup.tar.gz\n\n# 5. To restore, you first need to decrypt the file.\n#    You will be prompted for the passphrase you created.\ngpg -o my_home_backup.tar.gz -d my_home_backup.tar.gz.gpg\n\n# 6. Then, you can extract the contents of the archive.\ntar xzf my_home_backup.tar.gz",
              },
            ],
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "According to the 3-2-1 backup rule, where should at least one copy of your data be stored?",
                  options: [
                    "On the same computer.",
                    "In an off-site location.",
                    "On a CD-ROM.",
                    "In an unencrypted format.",
                  ],
                  correct: 1,
                  explanation:
                    "Keeping one copy off-site is crucial for protecting against local disasters like fire, theft, or flood that could destroy both the primary data and any local backups.",
                },
                {
                  id: 2,
                  question:
                    "Why is it important to regularly test your backups?",
                  options: [
                    "To make them smaller.",
                    "To ensure they are not corrupt and can be successfully restored.",
                    "Testing is not necessary.",
                    "To change the encryption key.",
                  ],
                  correct: 1,
                  explanation:
                    "An untested backup provides a false sense of security. Regular testing verifies the integrity of the data and the viability of the recovery process.",
                },
                {
                  id: 3,
                  question: "What is an 'immutable' backup?",
                  options: [
                    "A backup that is stored on two different drives.",
                    "A backup that cannot be changed or deleted for a specific period of time.",
                    "A backup that is not encrypted.",
                    "A backup that is updated every minute.",
                  ],
                  correct: 1,
                  explanation:
                    "Immutability is a key defense against ransomware, as it prevents the malware (or a compromised administrator) from deleting the clean recovery copies.",
                },
              ],
            },
          },
          {
            id: "lesson-15",
            title: "Email Security",
            duration: "90 min",
            objectives: [
              "Understand email spoofing and its role in phishing",
              "Learn how SPF (Sender Policy Framework) works",
              "Learn how DKIM (DomainKeys Identified Mail) works",
              "Learn how DMARC (Domain-based Message Authentication, Reporting, and Conformance) ties them together",
            ],
            content: {
              overview:
                "Email is the number one vector for cyberattacks, particularly phishing. This lesson covers the foundational protocols—SPF, DKIM, and DMARC—that work together to authenticate email senders, making it much harder for attackers to impersonate your domain and trick your employees, customers, and partners.",
              sections: [
                {
                  title: "SPF (Sender Policy Framework)",
                  content:
                    "<p>SPF is an email authentication method designed to prevent sender address forgery. It allows a domain owner to specify which mail servers they authorize to send email on behalf of their domain.</p><h3>How it Works:</h3><ol><li>A domain administrator publishes a special TXT record in their DNS.</li><li>This SPF record contains a list of IP addresses that are authorized to send email for that domain.</li><li>When a receiving mail server gets an email, it looks at the sender's domain, checks the DNS for an SPF record, and compares the IP address of the sending server to the authorized list.</li><li>If the IP is on the list, the SPF check passes. If not, it fails.</li></ol><div class=\"info-box note\"><div class=\"info-box-header\"><i class=\"fas fa-info-circle\"></i><strong>The 'Envelope From' Address</strong></div><p>SPF validates the 'envelope from' address, which is used during the SMTP transaction, not the 'header from' address that the user sees in their email client. This is a key limitation.</p></div>",
                  image:
                    "https://images.unsplash.com/photo-1586000085528-765715589146?w=800&h=400&fit=crop",
                },
                {
                  title: "DKIM (DomainKeys Identified Mail)",
                  content:
                    "<p>DKIM provides a way to verify that an email's content has not been tampered with and that it truly came from the claimed domain. It uses public-key cryptography to add a digital signature to the email.</p><h3>How it Works:</h3><ol><li>The sending mail server generates a cryptographic hash of parts of the email (like the body and certain headers).</li><li>It then uses a private key (kept secret on the server) to encrypt this hash, creating a digital signature. This signature is added to the email as a header.</li><li>The receiving server sees the DKIM signature, retrieves the public key from the sender's DNS (published in another TXT record), and uses it to decrypt the signature.</li><li>The receiver then calculates its own hash of the email content and compares it to the decrypted hash. If they match, the DKIM check passes, proving authenticity and integrity.</li></ol>",
                  image:
                    "https://images.unsplash.com/photo-1542831371-29b0f74f9713?w=800&h=400&fit=crop",
                },
                {
                  title:
                    "DMARC (Domain-based Message Authentication, Reporting, and Conformance)",
                  content:
                    "<p>DMARC is a policy layer that builds on SPF and DKIM. It tells receiving mail servers what to do if an email fails SPF or DKIM checks, and it provides a reporting mechanism.</p><h3>How it Works:</h3><ol><li>DMARC requires that an email passes either SPF or DKIM, and that the domain used in the validation (the 'envelope from' for SPF or the signing domain for DKIM) aligns with the 'header from' domain that the user sees.</li><li>The DMARC policy, also published in a DNS TXT record, tells the receiver how to handle failures: `p=none` (monitor only), `p=quarantine` (send to spam), or `p=reject` (block the email entirely).</li><li>It also provides addresses for receivers to send aggregate and forensic reports, giving domain owners visibility into who is sending email on their behalf.</li></ol>",
                  image:
                    "https://images.unsplash.com/photo-1586717791821-3f44a563fa4c?w=800&h=400&fit=crop",
                },
              ],
            },
            codeExamples: [
              {
                title: "Lab: Example DNS Records for SPF, DKIM, DMARC",
                language: "bash",
                code: "# This is a conceptual lab showing what the DNS records look like.\n# You would configure these in your domain's DNS management panel.\n\n# 1. SPF Record (as a TXT record for 'example.com')\n# This record says email can come from Google's servers and the server at IP 192.0.2.1.\n# All other sources should be treated as a 'soft fail' (~all).\n\nexample.com. IN TXT \"v=spf1 include:_spf.google.com ip4:192.0.2.1 ~all\"\n\n\n# 2. DKIM Record (as a TXT record for a specific 'selector')\n# The sending server would be configured to use the 'selector1' key.\n# The 'p=' field contains the public key.\n\nselector1._domainkey.example.com. IN TXT \"v=DKIM1; k=rsa; p=MIGfMA0GCSq...\"\n\n\n# 3. DMARC Record (as a TXT record for '_dmarc.example.com')\n# This policy says to reject failing emails (p=reject), and send reports to the specified email address.\n\n_dmarc.example.com. IN TXT \"v=DMARC1; p=reject; rua=mailto:dmarcreports@example.com\"",
              },
            ],
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "Which email security protocol is used to specify which mail servers are authorized to send email for a domain?",
                  options: ["DKIM", "DMARC", "SPF", "TLS"],
                  correct: 2,
                  explanation:
                    "SPF (Sender Policy Framework) is essentially a list of authorized IP addresses, published in DNS, that are allowed to send mail for a domain.",
                },
                {
                  id: 2,
                  question: "What is the primary function of DKIM?",
                  options: [
                    "To encrypt the entire email body.",
                    "To add a cryptographic signature to an email to verify its authenticity and integrity.",
                    "To check the sender's IP address.",
                    "To report delivery errors.",
                  ],
                  correct: 1,
                  explanation:
                    "DKIM uses public-key cryptography to sign the email, proving that it came from the specified domain and that its contents were not tampered with in transit.",
                },
                {
                  id: 3,
                  question:
                    "What does a DMARC policy of 'p=reject' instruct a receiving mail server to do?",
                  options: [
                    "Deliver the email to the inbox.",
                    "Monitor the email but take no action.",
                    "Send the email to the spam/junk folder.",
                    "Completely block the email from being delivered.",
                  ],
                  correct: 3,
                  explanation:
                    "`p=reject` is the strictest DMARC policy, telling receivers to drop any email that fails the DMARC check.",
                },
              ],
            },
          },
          {
            id: "lesson-16",
            title: "Cloud Hardening",
            duration: "120 min",
            objectives: [
              "Understand the Shared Responsibility Model in the cloud",
              "Learn the importance of Identity and Access Management (IAM)",
              "Configure cloud firewall rules (Security Groups / Network ACLs)",
              "Recognize common cloud misconfigurations",
            ],
            content: {
              overview:
                "Moving to the cloud doesn't mean security is handled for you. This lesson introduces the fundamental principles of cloud security, focusing on the Shared Responsibility Model, managing identities and permissions with IAM, and configuring network security in a cloud environment.",
              sections: [
                {
                  title: "The Shared Responsibility Model",
                  content:
                    '<p>The Shared Responsibility Model is a crucial concept in cloud security. It defines which security tasks are handled by the cloud provider (like AWS, Azure, GCP) and which are handled by you, the customer.</p><ul><li><strong>The Cloud Provider is Responsible for \'Security OF the Cloud\':</strong> This includes protecting the physical hardware, data centers, and the underlying network and virtualization infrastructure.</li><li><strong>The Customer is Responsible for \'Security IN the Cloud\':</strong> This includes everything you build on top of the cloud infrastructure. You are responsible for configuring your virtual machines, managing user access (IAM), configuring firewalls (Security Groups), patching operating systems, and securing your data and applications.</li></ul><div class="info-box warning"><div class="info-box-header"><i class="fas fa-exclamation-triangle"></i><strong>You Are Responsible</strong></div><p>A common mistake is assuming the cloud provider secures your data. If you misconfigure a storage bucket to be public, the resulting data breach is your responsibility, not the provider\'s.</p></div>',
                  image:
                    "https://images.unsplash.com/photo-1573495627361-d9b87960b12d?w=800&h=400&fit=crop",
                },
                {
                  title: "Identity and Access Management (IAM)",
                  content:
                    "<p>In the cloud, IAM is the new security perimeter. IAM controls who (users, groups, roles) can do what (actions like starting a VM or reading a database) on which resources. It is the foundation of cloud security.</p><h3>Key IAM Principles:</h3><ul><li><strong>Principle of Least Privilege:</strong> Grant users and applications only the specific permissions they need to perform their tasks. Avoid using the root/administrator account for daily operations.</li><li><strong>Roles over Users:</strong> Instead of assigning permissions directly to users or applications, create roles with specific permissions. Then, users or applications can 'assume' a role to get temporary credentials. This is much more secure and flexible.</li><li><strong>Multi-Factor Authentication (MFA):</strong> Enforce MFA for all user accounts, especially for highly privileged accounts.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1556742502-ec7c0e9f34b1?w=800&h=400&fit=crop",
                },
                {
                  title: "Cloud Firewalls (Security Groups)",
                  content:
                    "<p>Cloud providers offer powerful and flexible virtual firewalls to control traffic to your resources.</p><h3>Security Groups (AWS/GCP) / Network Security Groups (Azure):</h3><ul><li>They act as a stateful firewall for virtual machines (instances).</li><li>You define 'allow' rules for inbound and outbound traffic. By default, all inbound traffic is denied, and all outbound traffic is allowed.</li><li>For example, for a web server, you would create an inbound rule to allow TCP traffic on port 80 (HTTP) and 443 (HTTPS) from any source (0.0.0.0/0). You would also allow SSH traffic on port 22, but only from a trusted IP address (like your office IP).</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1544197150-b99a580bb7a8?w=800&h=400&fit=crop",
                },
              ],
            },
            codeExamples: [
              {
                title: "Lab: Harden an AWS EC2 Instance's Security Group",
                language: "bash",
                code: "# This lab is conceptual, describing the steps you would take in the AWS Management Console.\n\n# 1. You have a newly created EC2 instance (a virtual machine) running a web server.\n\n# 2. Navigate to the EC2 service, select your instance, and find its associated Security Group.\n\n# 3. Edit the 'Inbound rules' for the Security Group.\n\n# 4. A common misconfiguration is to have SSH (port 22) open to the world (Source: 0.0.0.0/0).\n#    This is very risky. Click 'Edit rules'.\n\n# 5. Change the rule for SSH (port 22):\n#    - Set the 'Source' to 'My IP'. AWS will auto-populate this with your current public IP address.\n#    - This ensures that only you can attempt to SSH into the instance.\n\n# 6. Add rules for the web server:\n#    - Add rule: Type 'HTTP', Port '80', Source 'Anywhere' (0.0.0.0/0).\n#    - Add rule: Type 'HTTPS', Port '443', Source 'Anywhere' (0.0.0.0/0).\n\n# 7. Save the rules. The firewall will now only permit web traffic from anyone, and SSH traffic only from your specific IP address.",
              },
            ],
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "In the Shared Responsibility Model, who is responsible for patching the operating system of a virtual machine?",
                  options: [
                    "The cloud provider",
                    "The customer",
                    "Both the provider and the customer",
                    "Neither",
                  ],
                  correct: 1,
                  explanation:
                    "The cloud provider is responsible for the underlying infrastructure, but the customer is responsible for everything they put 'in' the cloud, including configuring and maintaining the guest operating system.",
                },
                {
                  id: 2,
                  question:
                    "What is considered the 'new perimeter' in cloud security?",
                  options: [
                    "The physical data center",
                    "The firewall",
                    "Identity and Access Management (IAM)",
                    "The virtual machine",
                  ],
                  correct: 2,
                  explanation:
                    "Because resources can be accessed from anywhere via APIs, controlling 'who' can do 'what' (identity) has become the most critical security boundary, replacing the traditional network perimeter.",
                },
                {
                  id: 3,
                  question:
                    "What is the default behavior of an AWS Security Group for inbound traffic?",
                  options: [
                    "All traffic is allowed.",
                    "Only HTTP traffic is allowed.",
                    "All traffic is denied unless an 'allow' rule is created.",
                    "All traffic is allowed from within the same network.",
                  ],
                  correct: 2,
                  explanation:
                    "Security Groups operate on a 'default deny' basis for inbound traffic, which is a secure-by-default posture. You must explicitly open the ports your application needs.",
                },
              ],
            },
          },
          {
            id: "lesson-17",
            title: "Zero Trust Security",
            duration: "75 min",
            objectives: [
              "Understand the core philosophy of Zero Trust: 'Never Trust, Always Verify'",
              "Learn the key principles of a Zero Trust architecture",
              "Differentiate Zero Trust from traditional perimeter-based security",
              "Recognize the role of identity in Zero Trust",
            ],
            content: {
              overview:
                "Traditional security models operated like a castle with a moat: once you were inside the network, you were trusted. The Zero Trust model assumes that the network is already compromised. This lesson introduces the modern security paradigm of Zero Trust, where trust is never assumed and every access request must be continuously verified.",
              sections: [
                {
                  title: "From Castle-and-Moat to Zero Trust",
                  content:
                    "<p>The traditional security model focused on building a strong perimeter (firewalls, VPNs) to keep attackers out. However, once an attacker breached the perimeter (e.g., through a phishing attack), they could often move laterally within the network with little resistance because internal traffic was implicitly trusted.</p><h3>The Zero Trust Philosophy:</h3><p>Zero Trust is a security model based on the principle of maintaining strict access controls and not trusting anyone by default, even those already inside the network perimeter. The core mantra is: <strong>'Never Trust, Always Verify.'</strong></p><ul><li><strong>Assume Breach:</strong> Operate as if an attacker is already present on your network.</li><li><strong>Verify Explicitly:</strong> Always authenticate and authorize based on all available data points, including user identity, location, device health, service, and data classification.</li><li><strong>Least Privilege Access:</strong> Grant users just-in-time and just-enough-access (JIT/JEA) to do their job.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1573495627361-d9b87960b12d?w=800&h=400&fit=crop",
                },
                {
                  title: "Pillars of Zero Trust",
                  content:
                    "<p>Implementing Zero Trust is not about a single product, but an integrated approach across several pillars of security.</p><h3>Key Pillars:</h3><ul><li><strong>Identity:</strong> This is the core of Zero Trust. All access is identity-driven. Strong authentication (MFA) and authorization are paramount.</li><li><strong>Devices (Endpoints):</strong> Access requests are only granted from devices that meet a certain security posture (e.g., patched OS, endpoint protection enabled, not jailbroken).</li><li><strong>Network:</strong> The network is segmented into small, isolated zones (micro-segmentation) to prevent lateral movement. All traffic, even internal, is inspected and logged.</li><li><strong>Applications:</strong> Applications are secured with granular access policies and are accessed through secure gateways rather than being broadly exposed on the network.</li><li><strong>Data:</strong> Data is classified, labeled, and encrypted both at rest and in transit. Access policies are based on the sensitivity of the data itself.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1556157382-97eda2d62296?w=800&h=400&fit=crop",
                },
              ],
            },
            codeExamples: [
              {
                title: "Lab: Configure Role-Based Access (Conceptual)",
                language: "bash",
                code: "# This lab demonstrates the Zero Trust principle of least privilege using a conceptual Role-Based Access Control (RBAC) scenario.\n\n# Scenario: A company has a financial database.\n\n# Traditional (Non-Zero Trust) Approach:\n# - A developer joins the 'IT' group.\n# - The 'IT' group has broad access to all servers, including the financial database server.\n# - The developer can log into the database server and potentially access sensitive data, even if their job doesn't require it.\n\n# Zero Trust RBAC Approach:\n# 1. Define Roles based on job function, not broad departments.\n#    - Role: 'DatabaseAdmin' -> Permissions: Full control over the database.\n#    - Role: 'FinancialAnalyst' -> Permissions: Read-only access to specific financial tables.\n#    - Role: 'ApplicationDeveloper' -> Permissions: Access to the development server, but NO access to the production financial database.\n\n# 2. Assign Users to Roles:\n#    - Alice (DBA) is assigned the 'DatabaseAdmin' role.\n#    - Bob (Analyst) is assigned the 'FinancialAnalyst' role.\n#    - Carol (Developer) is assigned the 'ApplicationDeveloper' role.\n\n# 3. An access control system enforces these roles.\n#    - When Carol tries to connect to the production database, the system checks her role, sees she has no permissions, and explicitly denies the request.\n#    - This denial happens even though Carol is a trusted employee and is inside the corporate network.",
              },
            ],
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the core mantra of the Zero Trust security model?",
                  options: [
                    "Trust but verify",
                    "Trust everyone inside the network",
                    "Never trust, always verify",
                    "Build a strong perimeter",
                  ],
                  correct: 2,
                  explanation:
                    "Zero Trust fundamentally rejects the idea of a trusted internal network and instead requires that every access request be treated as if it came from an untrusted network.",
                },
                {
                  id: 2,
                  question:
                    "What is 'micro-segmentation' in the context of Zero Trust?",
                  options: [
                    "Using very small passwords.",
                    "Breaking the network into small, isolated zones to prevent lateral movement.",
                    "Giving all users the same level of access.",
                    "A type of firewall.",
                  ],
                  correct: 1,
                  explanation:
                    "Micro-segmentation is a key Zero Trust strategy that contains attackers to a small part of the network, preventing them from moving freely from a compromised machine to critical assets.",
                },
                {
                  id: 3,
                  question:
                    "Which of these is the most central and critical pillar of a Zero Trust architecture?",
                  options: ["Network", "Identity", "Devices", "Data"],
                  correct: 1,
                  explanation:
                    "Identity serves as the foundation for Zero Trust. Access decisions are primarily based on verifying the identity of the user and/or device and granting access based on their assigned, least-privilege role.",
                },
              ],
            },
          },
          {
            id: "lesson-18",
            title: "Security Benchmarking",
            duration: "90 min",
            objectives: [
              "Understand the purpose of security benchmarks",
              "Learn about major benchmarking organizations like CIS and NIST",
              "Differentiate between Level 1 and Level 2 benchmark profiles",
              "Use an automated tool to audit a system against a benchmark",
            ],
            content: {
              overview:
                "How do you know if your system is securely configured? Instead of guessing, you can measure it against an industry-standard security benchmark. This lesson introduces security benchmarks and shows how to use automated tools to audit your system's configuration against established best practices.",
              sections: [
                {
                  title: "What are Security Benchmarks?",
                  content:
                    "<p>A security benchmark is a document that provides prescriptive guidance for establishing a secure configuration for a specific technology. It's essentially a detailed checklist developed by a consensus of cybersecurity experts.</p><h3>Why Use Benchmarks?</h3><ul><li><strong>Expert Guidance:</strong> They provide a well-researched, expert-vetted starting point for hardening, saving you from having to figure everything out yourself.</li><li><strong>Measurable Security:</strong> They allow you to score your system's configuration, providing a concrete measurement of its security posture.</li><li><strong>Consistency:</strong> Using a benchmark ensures that systems across your organization are hardened to a consistent standard.</li><li><strong>Compliance:</strong> Adhering to a recognized benchmark is often a requirement for compliance with regulations like PCI-DSS, HIPAA, and GDPR.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop",
                },
                {
                  title: "CIS and NIST",
                  content:
                    "<p>Several organizations publish security benchmarks, but two of the most well-known are CIS and NIST.</p><h3>CIS Benchmarks (Center for Internet Security):</h3><ul><li>Provides highly detailed, step-by-step configuration guides for over 100 different technologies, including operating systems, cloud services, and applications.</li><li>Often divided into two profiles:</li><ul><li><strong>Level 1:</strong> Practical, prudent security settings that should be implemented on all systems. They are designed to not cause service interruptions.</li><li><strong>Level 2:</strong> Settings for high-security environments. These provide enhanced security but may require more planning and could potentially impact functionality.</li></ul></ul><h3>NIST (National Institute of Standards and Technology):</h3><ul><li>A US government agency that produces various cybersecurity frameworks and guidelines, including the well-known Cybersecurity Framework (CSF).</li><li>Their guidance is often less prescriptive than CIS and more focused on establishing a risk management framework, but they also provide configuration checklists through programs like the National Checklist Program (NCP).</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1519403339839-847293525243?w=800&h=400&fit=crop",
                },
              ],
            },
            codeExamples: [
              {
                title: "Lab: Run Lynis on Linux",
                language: "bash",
                code: "# Lynis is an open-source security auditing tool. It scans a Linux system and checks its configuration against security best practices, many of which are derived from benchmarks like CIS.\n\n# 1. Install Lynis\nsudo apt-get update\nsudo apt-get install lynis\n\n# 2. Run the audit. It needs to be run as root to check all system files.\n# '--auditor \"Your Name\"' is optional but good practice.\n# '--verbose' shows more detail about the tests being performed.\nsudo lynis audit system --auditor \"Student\" --verbose\n\n# 3. Review the output. Lynis will provide:\n#    - General system information.\n#    - A list of findings, categorized by severity (Suggestion, Warning, etc.).\n#    - A hardening index, which is a score from 0-100 representing the system's security posture.\n#    - A link to the detailed report file in /var/log/lynis-report.dat.\n\n# 4. Pay close attention to the 'Suggestions' section at the end of the output.\n#    Lynis will give you specific recommendations on how to fix the issues it found.\n#    For example, it might suggest disabling a kernel module or hardening SSH configuration.",
              },
            ],
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the primary purpose of a security benchmark?",
                  options: [
                    "To scan for viruses.",
                    "To provide a detailed checklist for securely configuring a system.",
                    "To back up data.",
                    "To test network performance.",
                  ],
                  correct: 1,
                  explanation:
                    "A benchmark is a prescriptive guide that details specific settings and configurations to achieve a hardened, secure state for a piece of technology.",
                },
                {
                  id: 2,
                  question:
                    "In the CIS Benchmarks, what is the difference between a Level 1 and a Level 2 profile?",
                  options: [
                    "Level 1 is for servers, Level 2 is for workstations.",
                    "Level 1 provides basic security that shouldn't impact functionality, while Level 2 is for high-security environments and might impact functionality.",
                    "Level 1 is free, Level 2 is paid.",
                    "There is no difference.",
                  ],
                  correct: 1,
                  explanation:
                    "Level 1 is the baseline recommended for everyone, while Level 2 includes more stringent controls for systems handling highly sensitive data where security is paramount.",
                },
                {
                  id: 3,
                  question: "What kind of tool is Lynis?",
                  options: [
                    "A firewall.",
                    "An antivirus program.",
                    "A security auditing and hardening tool.",
                    "A backup utility.",
                  ],
                  correct: 2,
                  explanation:
                    "Lynis is a configuration scanner that audits a system against a set of security best practices to identify weaknesses and provide suggestions for hardening.",
                },
              ],
            },
          },
          {
            id: "lesson-19",
            title: "Vulnerability Scanning",
            duration: "90 min",
            objectives: [
              "Differentiate between vulnerability scanning and security benchmarking",
              "Understand the goal of a vulnerability scanner",
              "Learn about popular scanning tools like Nessus and OpenVAS",
              "Recognize the importance of credentialed vs. uncredentialed scans",
            ],
            content: {
              overview:
                "While benchmarking checks if a system is configured securely, vulnerability scanning checks for known software flaws (CVEs). This lesson covers the process of actively scanning systems to find vulnerabilities like unpatched software, open ports, and other weaknesses that an attacker could exploit.",
              sections: [
                {
                  title: "Benchmarking vs. Vulnerability Scanning",
                  content:
                    "<p>It's important to understand the difference between these two related but distinct activities:</p><ul><li><strong>Security Benchmarking (Lesson 18):</strong> Compares the system's <em>configuration</em> against a best-practice standard. It answers the question: 'Is my system set up securely?'</li><li><strong>Vulnerability Scanning:</strong> Probes a system for known <em>vulnerabilities</em>, typically in the software versions it is running. It answers the question: 'Does my system have any known flaws that can be exploited?'</li></ul><div class=\"info-box tip\"><div class=\"info-box-header\"><i class=\"fas fa-lightbulb\"></i><strong>A Complete Picture</strong></div><p>You need both. A system can be perfectly benchmarked but still be vulnerable if it's running an old, unpatched version of Apache. Conversely, a fully patched system can still be at risk if it's poorly configured (e.g., SSH allows root login with a weak password).</p></div>",
                  image:
                    "https://images.unsplash.com/photo-1563206767-5b18f218e8de?w=800&h=400&fit=crop",
                },
                {
                  title: "How Vulnerability Scanners Work",
                  content:
                    "<p>Vulnerability scanners are automated tools that check computers, networks, or applications for known weaknesses. They typically work by:</p><ol><li><strong>Discovery:</strong> Identifying live hosts and open ports on the network.</li><li><strong>Banner Grabbing / Fingerprinting:</strong> Identifying the operating systems and the services (including version numbers) running on the open ports.</li><li><strong>Vulnerability Check:</strong> Comparing the identified versions against a large database of known vulnerabilities (CVEs).</li><li><strong>Reporting:</strong> Generating a prioritized report of all findings, usually including the CVE, a CVSS severity score, and recommendations for remediation (e.g., 'Apply vendor patch XYZ').</li></ol><h3>Popular Tools:</h3><ul><li><strong>Nessus:</strong> A widely used commercial vulnerability scanner.</li><li><strong>OpenVAS / Greenbone:</strong> A powerful, open-source alternative to Nessus.</li><li><strong>Nmap Scripting Engine (NSE):</strong> While primarily a port scanner, Nmap can be extended with scripts to perform basic vulnerability checks.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1544890225-2fde0e66f35b?w=800&h=400&fit=crop",
                },
                {
                  title: "Credentialed vs. Uncredentialed Scans",
                  content:
                    '<p>There are two main ways to perform a vulnerability scan:</p><ul><li><strong>Uncredentialed (External) Scan:</strong> The scanner has no special access to the target. It scans from the network, simulating what an external attacker would see. It\'s good at finding network-level vulnerabilities but can miss issues on the host itself.</li><li><strong>Credentialed (Authenticated) Scan:</strong> The scanner is given read-only credentials (e.g., an SSH user on Linux or a service account on Windows). It can log into the system and check the exact versions of all installed software against a list of patches. This provides a much more accurate and detailed view of the system\'s vulnerabilities.</li></ul><div class="info-box note"><div class="info-box-header"><i class="fas fa-info-circle"></i><strong>Credentialed is Better</strong></div><p>A credentialed scan is always preferred for assessing the security posture of your own systems, as it is far more accurate and produces fewer false positives.</p></div>',
                  image:
                    "https://images.unsplash.com/photo-1510511459019-5dda7724fd87?w=800&h=400&fit=crop",
                },
              ],
            },
            codeExamples: [
              {
                title: "Lab: Scan a VM with OpenVAS",
                language: "bash",
                code: "# This lab is conceptual due to the complexity of setting up OpenVAS. It outlines the general steps.\n\n# 1. Install OpenVAS / Greenbone Community Edition. This is often done via Docker or a dedicated appliance for simplicity.\n\n# 2. Update the Vulnerability Feeds. This is the most critical step, as it downloads the latest information about CVEs.\n#    (e.g., `greenbone-nvt-sync`)\n\n# 3. Define a Target: In the OpenVAS web interface, define the IP address of the virtual machine you want to scan.\n\n# 4. Configure Credentials (for a credentialed scan):\n#    - Create a new Credential object in OpenVAS.\n#    - Provide the username and password/SSH key for an account on the target VM.\n#    - Associate this credential with the Target definition.\n\n# 5. Create and Launch a Scan Task:\n#    - Select a scan configuration (e.g., 'Full and fast').\n#    - Select your target.\n#    - Launch the scan.\n\n# 6. Analyze the Report:\n#    - Once the scan is complete, a report will be generated.\n#    - The report will list all found vulnerabilities, sorted by severity (High, Medium, Low).\n#    - Each finding will include a summary, the affected software, and a solution (e.g., 'Upgrade package X to version Y').",
              },
            ],
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the main difference between a vulnerability scan and a benchmark audit?",
                  options: [
                    "There is no difference.",
                    "A benchmark checks for secure configurations, while a vulnerability scan checks for known software flaws (CVEs).",
                    "A vulnerability scan is manual, while a benchmark is automated.",
                    "A benchmark is for networks, a vulnerability scan is for applications.",
                  ],
                  correct: 1,
                  explanation:
                    "Benchmarking is about the 'how'—how the system is configured. Vulnerability scanning is about the 'what'—what software is installed and what known flaws it has.",
                },
                {
                  id: 2,
                  question:
                    "Why is a credentialed (authenticated) scan more accurate than an uncredentialed scan?",
                  options: [
                    "It runs faster.",
                    "It can log into the system to check the exact patch levels of installed software, reducing guesswork.",
                    "It doesn't require a network connection.",
                    "It is less expensive.",
                  ],
                  correct: 1,
                  explanation:
                    "By logging in, the scanner can see the system from the inside, providing a complete and accurate list of installed software and applied patches. An uncredentialed scan can only infer information from network banners, which can be inaccurate.",
                },
                {
                  id: 3,
                  question:
                    "What is the primary output of a vulnerability scanner?",
                  options: [
                    "A new firewall configuration.",
                    "A backup of the system.",
                    "A prioritized report of found vulnerabilities with recommendations for remediation.",
                    "A performance score.",
                  ],
                  correct: 2,
                  explanation:
                    "The goal of a vulnerability scan is to produce an actionable report that allows administrators to identify, prioritize, and fix the security weaknesses in their systems.",
                },
              ],
            },
          },
          {
            id: "lesson-20",
            title: "Incident Response",
            duration: "120 min",
            objectives: [
              "Understand the phases of the incident response lifecycle",
              "Learn the importance of preparation in incident response",
              "Recognize the goals of containment, eradication, and recovery",
              "Appreciate the value of post-incident analysis (lessons learned)",
            ],
            content: {
              overview:
                "Even with the best defenses, security incidents can happen. How you respond is critical to minimizing damage, restoring services, and preventing recurrence. This final lesson covers the structured process of incident response, from preparing for an incident to learning from it after it's over.",
              sections: [
                {
                  title: "The Incident Response Lifecycle",
                  content:
                    "<p>Incident response (IR) is not a chaotic, ad-hoc process. It follows a structured, cyclical lifecycle, often based on the NIST framework. The goal is to handle the incident in a way that limits damage and reduces recovery time and costs.</p><h3>The Six Phases:</h3><ol><li><strong>Preparation:</strong> This is the most important phase. It involves creating an IR plan, forming a response team, and having the necessary tools and access ready *before* an incident occurs.</li><li><strong>Detection & Analysis:</strong> Identifying that an incident has occurred (e.g., through alerts from a SIEM or antivirus) and analyzing its scope and severity.</li><li><strong>Containment:</strong> Taking immediate steps to stop the incident from causing further damage. This could involve isolating a compromised machine from the network.</li><li><strong>Eradication:</strong> Removing the root cause of the incident, such as eliminating the malware and patching the vulnerability that was exploited.</li><li><strong>Recovery:</strong> Restoring affected systems to normal operation, often from clean backups, and verifying that they are secure.</li><li><strong>Post-Incident Activity (Lessons Learned):</strong> Analyzing the incident and the response to identify areas for improvement in security controls and the IR process itself.</li></ol>",
                  image:
                    "https://images.unsplash.com/photo-1518432031352-d6fc5c10da5a?w=800&h=400&fit=crop",
                },
                {
                  title: "Containment, Eradication, and Recovery",
                  content:
                    '<p>These three phases form the core of the active response to an incident.</p><h3>Containment:</h3><p>The primary goal is to stop the bleeding. It\'s a trade-off between speed and precision. Short-term containment might be disconnecting a server\'s network cable. Long-term containment might involve placing the server on an isolated VLAN where forensic data can be collected.</p><h3>Eradication:</h3><p>This is about cleaning up the mess. It\'s not enough to just delete the malware; you must find and fix the root cause. Why did the attack succeed? Was it an unpatched server? A successful phishing email? This vulnerability must be fixed to prevent an immediate recurrence.</p><h3>Recovery:</h3><p>The goal is to get back to business safely. This often means rebuilding the compromised system from a known-good OS image, patching it, restoring data from a trusted backup, and then carefully monitoring it as it\'s brought back online.</p><div class="info-box warning"><div class="info-box-header"><i class="fas fa-exclamation-triangle"></i><strong>Don\'t Just Clean, Rebuild</strong></div><p>Simply running an antivirus scan on a compromised server is often not enough. Sophisticated attackers can leave behind hidden backdoors or rootkits. The safest recovery strategy is to wipe and rebuild the system.</p></div>',
                  image:
                    "https://images.unsplash.com/photo-1542744095-fcf48d80b0fd?w=800&h=400&fit=crop",
                },
              ],
            },
            codeExamples: [
              {
                title:
                  "Lab: Simulate a Breach and Perform Response Steps (Tabletop Exercise)",
                language: "bash",
                code: "# This is a conceptual 'tabletop' exercise. Read the scenario and think through the steps.\n\n# Scenario: Your SIEM alerts you that a web server (10.0.0.50) is making suspicious outgoing connections to a known malicious IP address.\n\n# 1. Detection & Analysis:\n#    - The SIEM alert is the detection. You confirm the traffic is real using `netstat` or a packet capture tool on the server.\n#    - You analyze server logs and see a web shell was uploaded via a vulnerability in a web application plugin.\n\n# 2. Containment:\n#    - What is your first step? The fastest way to stop the server from communicating with the attacker is to apply a firewall rule to block all outbound traffic from 10.0.0.50.\n#    - This contains the threat without taking the web server completely offline.\n\n# 3. Eradication:\n#    - Identify the vulnerable plugin. Remove it.\n#    - Delete the web shell file.\n#    - Review the entire web root for any other malicious files.\n#    - Find out how the attacker got in. Patch the vulnerability.\n#    - Review accounts on the server. Did the attacker create any new users?\n\n# 4. Recovery:\n#    - Since the attacker gained access, the server is untrusted. The best practice is to deploy a new, clean web server from your standard image.\n#    - Before deploying, ensure the new server image has the patch for the vulnerability that was exploited.\n#    - Restore the website's content from a clean backup taken before the incident.\n#    - Point the network load balancer to the new server and decommission the old one.\n\n# 5. Post-Incident Activity:\n#    - Why was the vulnerable plugin not updated? Review your patch management process.\n#    - Can you create a better alert to detect this kind of activity faster in the future?\n#    - Update your incident response plan with lessons learned.",
              },
            ],
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the primary goal of the 'Containment' phase in incident response?",
                  options: [
                    "To restore data from backups.",
                    "To figure out who the attacker was.",
                    "To take immediate action to prevent an incident from spreading and causing more damage.",
                    "To write a report about the incident.",
                  ],
                  correct: 2,
                  explanation:
                    "Containment is about stopping the bleeding. The immediate priority is to limit the scope and magnitude of the incident, even if it's a temporary measure.",
                },
                {
                  id: 2,
                  question:
                    "Which phase of the incident response lifecycle is considered the most important for ensuring an effective response?",
                  options: [
                    "Recovery",
                    "Eradication",
                    "Detection",
                    "Preparation",
                  ],
                  correct: 3,
                  explanation:
                    "The 'Preparation' phase is the most critical. Having a plan, a trained team, and the right tools in place before an incident occurs is the single biggest factor in determining the success of the response.",
                },
                {
                  id: 3,
                  question:
                    "Why is it often recommended to rebuild a compromised server from a clean image instead of just trying to 'clean' it?",
                  options: [
                    "It is faster.",
                    "It ensures that any hidden backdoors or rootkits left by the attacker are completely eliminated.",
                    "Cleaning the server is impossible.",
                    "Rebuilding uses less disk space.",
                  ],
                  correct: 1,
                  explanation:
                    "Advanced attackers are skilled at hiding their persistence mechanisms. Wiping the system and restoring from a known-good state is the only way to be confident that the machine is truly clean and secure.",
                },
              ],
            },
          },
        ],
      };

      // =====================================================
      // GLOBAL VARIABLES
      // =====================================================
      let currentUser = null;
      let currentLessonIndex = 0;
      let courseProgress = {};
      let userStats = {};
      let quizState = {
        currentQuestion: 0,
        answers: [],
        score: 0,
        isComplete: false,
      };

      // Enhanced session tracking
      let courseSession = {
        startTime: null,
        totalStudyTime: 0,
        lessonsStarted: 0,
        lessonsCompleted: 0,
        pageLoadTime: new Date(),
        interactionCount: 0,
        lastActivityTime: new Date(),
      };

      // Music Player Variables
      let audioPlayer = new Audio();

      // Achievement notification system
      let notificationQueue = [];
      let isShowingNotification = false;

      // =====================================================
      // INITIALIZATION
      // =====================================================
      document.addEventListener("DOMContentLoaded", async () => {
        try {
          showLoadingScreen();
          await checkAuth();

          if (currentUser) {
            // Initialize session tracking
            startCourseSession();

            // Load course data and progress
            await loadCourseData();
            await loadUserProfile();
            await loadProgress();

            // Initialize UI
            initializeEventListeners();
            renderSidebar();
            loadLesson(currentLessonIndex);

            // Initialize additional features
            initMusicPlayer();
            addMusicIndicator();
            initializeActivityTracking();

            hideLoadingScreen();
          } else {
            openAuthModal();
          }
        } catch (error) {
          console.error("Error initializing course:", error);
          hideLoadingScreen();
          showToast("Failed to initialize course system", "error");
        }
      });

      // =====================================================
      // AUTHENTICATION SYSTEM
      // =====================================================
      async function checkAuth() {
        try {
          const {
            data: { session },
            error,
          } = await supabase.auth.getSession();

          if (error) {
            console.error("Auth error:", error);
            currentUser = null;
            openAuthModal();
            return;
          }

          if (!session) {
            currentUser = null;
            openAuthModal();
            return;
          }

          currentUser = session.user;
          updateUIWithUser();
        } catch (error) {
          console.error("Error checking auth:", error);
          currentUser = null;
          openAuthModal();
        }
      }

      function updateUIWithUser() {
        if (!currentUser) return;

        const name =
          currentUser.user_metadata?.full_name ||
          currentUser.email.split("@")[0];
        const userElements = document.querySelectorAll("[data-user-name]");
        userElements.forEach((el) => (el.textContent = name));
      }

      // =====================================================
      // USER PROFILE & STATS MANAGEMENT
      // =====================================================
      async function loadUserProfile() {
        try {
          // 🔍 Step 1: Try to fetch existing profile
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("*")
            .eq("id", currentUser.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (!profile) {
            // 🆕 Step 2: Create new profile if missing
            await createUserProfile();
          } else {
            // ✅ Step 3: Use existing profile
            userStats = profile;
            await updateLastActivity();
          }
        } catch (error) {
          console.error("❌ Error loading user profile:", error);
          showToast("Failed to load user profile", "error");
        }
      }
      async function createUserProfile() {
        try {
          const newProfile = {
            id: currentUser.id,
            full_name: currentUser.user_metadata?.full_name || "",
            email: currentUser.email,
            level: "Script Kiddie",
            total_points: 0,
            completed_courses: 0,
            current_streak: 0,
            total_certificates: 0,
            total_achievements: 0,
            sections_visited: 0,
            bonus_points: 0,
            in_progress_courses: 0,
            settings_changed: 0,
            midnight_sessions: 0,
            early_sessions: 0,
            weekend_sessions: 0,
            last_activity: new Date().toISOString(),
            created_at: new Date().toISOString(),
          };

          const { error } = await supabase
            .from("profiles")
            .insert([newProfile]);

          if (!error) {
            userStats = newProfile;
            // Award first login achievement
            setTimeout(() => checkAndUnlockAchievement("first_login"), 1000);
          }
        } catch (error) {
          console.error("Error creating user profile:", error);
        }
      }

      async function updateLastActivity() {
        try {
          const now = new Date();

          // Update activity tracking
          courseSession.lastActivityTime = now;

          // Update database
          await supabase
            .from("profiles")
            .update({
              last_activity: now.toISOString(),
            })
            .eq("id", currentUser.id);

          // Check time-based achievements
          await checkTimeBasedAchievements(now);
        } catch (error) {
          console.error("Error updating last activity:", error);
        }
      }

      // =====================================================
      // COURSE SESSION MANAGEMENT
      // =====================================================
      function startCourseSession() {
        courseSession.startTime = new Date();
        courseSession.pageLoadTime = new Date();

        logUserActivity("course_session_start", {
          course_id: COURSE_DATA.id,
          course_title: COURSE_DATA.title,
          user_agent: navigator.userAgent,
          screen_resolution: `${screen.width}x${screen.height}`,
        });

        // Check daily streak
        checkDailyStreak();
      }

      function initializeActivityTracking() {
        // Track page focus/blur for accurate study time
        document.addEventListener("visibilitychange", handleVisibilityChange);

        // Track user interactions
        ["click", "keydown", "scroll", "mousemove"].forEach((event) => {
          document.addEventListener(event, trackUserInteraction, {
            passive: true,
          });
        });

        // Periodic activity updates
        setInterval(updateStudyTime, 60000); // Every minute

        // Save session data before page unload
        window.addEventListener("beforeunload", saveSessionData);
      }

      function handleVisibilityChange() {
        if (document.hidden) {
          courseSession.lastActivityTime = new Date();
        } else {
          // Page became visible again - update activity
          updateLastActivity();
        }
      }

      function trackUserInteraction() {
        courseSession.interactionCount++;
        courseSession.lastActivityTime = new Date();

        // Throttle activity updates
        if (courseSession.interactionCount % 50 === 0) {
          updateLastActivity();
        }
      }

      function updateStudyTime() {
        if (!courseSession.startTime || document.hidden) return;

        const now = new Date();
        const sessionDuration = now - courseSession.startTime;
        courseSession.totalStudyTime = Math.floor(sessionDuration / 1000 / 60); // in minutes

        // Update progress with study time
        saveProgress();
      }

      function saveSessionData() {
        if (!currentUser || !courseSession.startTime) return;

        const sessionData = {
          user_id: currentUser.id,
          course_id: COURSE_DATA.id,
          session_duration: courseSession.totalStudyTime,
          lessons_viewed: courseSession.lessonsStarted,
          lessons_completed: courseSession.lessonsCompleted,
          interactions: courseSession.interactionCount,
          session_date: courseSession.startTime.toISOString().split("T")[0],
        };

        // Store in localStorage as backup
        localStorage.setItem(
          "course_session_backup",
          JSON.stringify(sessionData)
        );

        // Try to save to database
        logUserActivity("course_session_end", sessionData);
      }

      // =====================================================
      // COURSE DATA & PROGRESS MANAGEMENT
      // =====================================================
      async function loadCourseData() {
        try {
          // Update course info in UI
          document.getElementById("courseTitle").textContent =
            COURSE_DATA.title;
          document.getElementById("totalLessons").textContent =
            COURSE_DATA.lessons.length;

          // Log course access
          logUserActivity("course_access", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
          });
        } catch (error) {
          console.error("Error loading course data:", error);
        }
      }

      async function loadProgress() {
        try {
          // Get existing progress from database
          const { data, error } = await supabase
            .from("course_progress")
            .select("*")
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (data) {
            courseProgress = JSON.parse(data.lesson_progress || "{}");
            currentLessonIndex = data.current_lesson || 0;

            // Update session tracking
            courseSession.lessonsStarted = Object.keys(courseProgress).length;
            courseSession.lessonsCompleted = Object.values(
              courseProgress
            ).filter((p) => p.completed).length;
          } else {
            // Initialize new progress
            courseProgress = {};
            currentLessonIndex = 0;
            await saveProgress();

            // Award first course start achievement
            await checkAndUnlockAchievement("first_course_start");
          }

          updateProgressDisplay();
        } catch (error) {
          console.error("Error loading progress:", error);
          showToast("Failed to load progress", "error");
        }
      }

      async function saveProgress() {
        try {
          if (!currentUser) return;

          const now = new Date();
          const progressData = {
            user_id: currentUser.id,
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            current_lesson: currentLessonIndex,
            lesson_progress: JSON.stringify(courseProgress),
            progress: calculateOverallProgress(),
            lessons_completed: getCompletedLessonsCount(),
            lessons_started: Object.keys(courseProgress).length,
            study_time_minutes: courseSession.totalStudyTime,
            last_accessed: now.toISOString(),
            updated_at: now.toISOString(),
          };

          // Upsert progress
          const { error } = await supabase
            .from("course_progress")
            .upsert([progressData]);

          if (error) throw error;

          // Update user stats
          await updateUserStats();

          updateProgressDisplay();
        } catch (error) {
          console.error("Error saving progress:", error);
          showToast("Failed to save progress", "error");
        }
      }

      async function updateUserStats() {
        try {
          // Get all course progress for this user
          const { data: allProgress, error } = await supabase
            .from("course_progress")
            .select("progress, course_id, study_time_minutes")
            .eq("user_id", currentUser.id);

          if (error) throw error;

          // Calculate stats
          const completedCourses =
            allProgress?.filter((p) => p.progress >= 100).length || 0;
          const inProgressCourses =
            allProgress?.filter((p) => p.progress > 0 && p.progress < 100)
              .length || 0;
          const totalStudyTime =
            allProgress?.reduce(
              (sum, p) => sum + (p.study_time_minutes || 0),
              0
            ) || 0;

          // Calculate points (500 per completed course + achievement points)
          const coursePoints = completedCourses * 500;
          const bonusPoints = userStats.bonus_points || 0;
          const totalPoints = coursePoints + bonusPoints;

          // Update profile
          const updateData = {
            completed_courses: completedCourses,
            in_progress_courses: inProgressCourses,
            total_points: totalPoints,
            total_study_time: totalStudyTime,
            last_activity: new Date().toISOString(),
          };

          const { error: updateError } = await supabase
            .from("profiles")
            .update(updateData)
            .eq("id", currentUser.id);

          if (updateError) throw updateError;

          // Update local stats
          Object.assign(userStats, updateData);
        } catch (error) {
          console.error("Error updating user stats:", error);
        }
      }

      function calculateOverallProgress() {
        const completedLessons = getCompletedLessonsCount();
        return Math.round(
          (completedLessons / COURSE_DATA.lessons.length) * 100
        );
      }

      function getCompletedLessonsCount() {
        return Object.values(courseProgress).filter(
          (lesson) => lesson.completed
        ).length;
      }

      function updateProgressDisplay() {
        const completedCount = getCompletedLessonsCount();
        const progressPercent = calculateOverallProgress();

        // Update UI elements
        const elements = {
          completedLessons: completedCount,
          courseProgressPercent: `${progressPercent}%`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });

        // Update progress bar
        const progressBar = document.getElementById("courseProgressFill");
        if (progressBar) progressBar.style.width = `${progressPercent}%`;
      }

      // =====================================================
      // LESSON MANAGEMENT
      // =====================================================
      function loadLesson(index) {
        if (index < 0 || index >= COURSE_DATA.lessons.length) return;

        const lesson = COURSE_DATA.lessons[index];
        currentLessonIndex = index;

        // Mark lesson as started and track activity
        if (!courseProgress[lesson.id]) {
          courseProgress[lesson.id] = {
            started: true,
            completed: false,
            startedAt: new Date().toISOString(),
            timeSpent: 0,
          };

          courseSession.lessonsStarted++;
          saveProgress();

          // Log lesson start
          logUserActivity("lesson_start", {
            lesson_id: lesson.id,
            lesson_title: lesson.title,
            lesson_index: index,
          });
        }

        // Update lesson start time for time tracking
        courseProgress[lesson.id].currentSessionStart = new Date();

        // Update sidebar and navigation
        renderSidebar();
        updateNavigationButtons();

        // Update header info
        updateLessonHeader(lesson, index);

        // Render lesson content
        renderLessonContent(lesson);

        // Smooth scroll and animations
        window.scrollTo({ top: 0, behavior: "smooth" });
        document.getElementById("contentBody").scrollTop = 0;

        const contentBody = document.getElementById("contentBody");
        contentBody.classList.add("fade-in");
        setTimeout(() => contentBody.classList.remove("fade-in"), 500);

        // Check lesson-based achievements
        checkLessonAchievements(index + 1);
      }

      function updateLessonHeader(lesson, index) {
        const elements = {
          currentLessonNumber: index + 1,
          currentLessonTitle: lesson.title,
          navInfo: `Lesson ${index + 1} of ${COURSE_DATA.lessons.length}`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });
      }

      function renderSidebar() {
        const lessonNav = document.getElementById("lessonNav");
        if (!lessonNav) return;

        lessonNav.innerHTML = "";

        COURSE_DATA.lessons.forEach((lesson, index) => {
          const lessonItem = document.createElement("div");
          lessonItem.className = "lesson-item";

          // Determine lesson status
          const lessonProgress = courseProgress[lesson.id];
          const isCompleted = lessonProgress?.completed || false;
          const isInProgress = lessonProgress?.started || false;
          const isLocked = !isCompleted && !canAccessLesson(index);
          const isActive = index === currentLessonIndex;

          // Apply status classes
          if (isCompleted) lessonItem.classList.add("completed");
          if (isLocked) lessonItem.classList.add("locked");
          if (isActive) lessonItem.classList.add("active");

          // Determine status display
          let statusClass = "not-started";
          let statusIcon = index + 1;

          if (isCompleted) {
            statusClass = "completed";
            statusIcon = "✓";
          } else if (isInProgress) {
            statusClass = "in-progress";
            statusIcon = "◐";
          }

          // Create lesson item HTML
          lessonItem.innerHTML = `
            <div class="lesson-status ${statusClass}">${statusIcon}</div>
            <div class="lesson-info">
                <div class="lesson-title">${lesson.title}</div>
                <div class="lesson-meta">
                    ${
                      isCompleted
                        ? "Completed"
                        : isInProgress
                        ? "In Progress"
                        : isLocked
                        ? "Locked"
                        : "Not Started"
                    }
                </div>
            </div>
            <div class="lesson-duration">${lesson.duration}</div>
        `;

          // Add click handler if not locked
          if (!isLocked) {
            lessonItem.addEventListener("click", () => {
              if (index !== currentLessonIndex) {
                // Track lesson time before switching
                trackLessonTime();

                currentLessonIndex = index;
                loadLesson(index);
                closeSidebar();
              }
            });
          }

          lessonNav.appendChild(lessonItem);
        });
      }

      function canAccessLesson(index) {
        if (index === 0) return true; // First lesson always accessible

        // Can access if previous lesson is completed
        const previousLessonId = COURSE_DATA.lessons[index - 1].id;
        return courseProgress[previousLessonId]?.completed || false;
      }

      function trackLessonTime() {
        const currentLesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonProgress = courseProgress[currentLesson.id];

        if (lessonProgress?.currentSessionStart) {
          const sessionTime = Math.floor(
            (new Date() - new Date(lessonProgress.currentSessionStart)) /
              1000 /
              60
          );
          lessonProgress.timeSpent =
            (lessonProgress.timeSpent || 0) + sessionTime;
          delete lessonProgress.currentSessionStart;
        }
      }

      // =====================================================
      // LESSON CONTENT RENDERING
      // =====================================================
      function renderLessonContent(lesson) {
        const contentContainer = document.getElementById("lessonContent");
        if (!contentContainer) return;

        let contentHTML = `
        <div class="content-section">
            <h2>Learning Objectives</h2>
            <ul>
                ${lesson.objectives.map((obj) => `<li>${obj}</li>`).join("")}
            </ul>
        </div>
        
        <div class="content-section">
            <h2>Overview</h2>
            <p>${lesson.content.overview}</p>
        </div>
    `;

        // Render content sections
        lesson.content.sections.forEach((section) => {
          contentHTML += `
            <div class="content-section">
                <h2>${section.title}</h2>
                ${section.content}
                ${
                  section.image
                    ? `<img src="${section.image}" alt="${section.title}" class="content-image" loading="lazy">`
                    : ""
                }
            </div>
        `;
        });

        // Render code examples
        if (
          lesson.content.codeExamples &&
          lesson.content.codeExamples.length > 0
        ) {
          contentHTML += `<div class="content-section"><h2>Code Examples</h2></div>`;

          lesson.content.codeExamples.forEach((example, index) => {
            const codeId = `code-${lesson.id}-${index}`;
            contentHTML += `
                <div class="code-section">
                    <div class="code-header">
                        <span class="code-title">${example.title}</span>
                        <button class="copy-btn" onclick="copyCode('${codeId}')">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <pre class="code-block"><code id="${codeId}" class="language-${
              example.language
            }">${escapeHtml(example.code)}</code></pre>
                </div>
            `;
          });
        }

        // Render quiz
        contentHTML += renderQuiz(lesson.quiz);

        contentContainer.innerHTML = contentHTML;

        // Highlight code syntax if Prism is available
        setTimeout(() => {
          if (window.Prism) {
            Prism.highlightAll();
          }
        }, 100);
      }

      // =====================================================
      // QUIZ SYSTEM
      // =====================================================
      function renderQuiz(quiz) {
        const currentLessonProgress =
          courseProgress[COURSE_DATA.lessons[currentLessonIndex].id];
        const isCompleted = currentLessonProgress?.completed || false;

        let quizHTML = `
        <div class="quiz-section" id="quizSection">
            <div class="quiz-header">
                <h2 class="quiz-title">
                    <i class="fas fa-clipboard-check"></i>
                    Knowledge Check
                </h2>
                <p class="quiz-info">
                    Complete this quiz with ${quiz.passingScore}% or higher to unlock the next lesson.
                </p>
            </div>
    `;

        if (isCompleted) {
          const savedScore = currentLessonProgress.quizScore || 0;
          quizHTML += `
            <div class="quiz-results show">
                <div class="quiz-score pass">${savedScore}%</div>
                <div class="quiz-message">
                    <strong>Lesson Completed!</strong><br>
                    You've successfully passed this lesson's quiz.
                </div>
            </div>
        `;
        } else {
          // Render quiz questions
          quiz.questions.forEach((question, qIndex) => {
            quizHTML += `
                <div class="quiz-question ${
                  qIndex === 0 ? "active" : ""
                }" data-question="${qIndex}">
                    <div class="question-header">
                        <span class="question-number">Question ${
                          qIndex + 1
                        }</span>
                        <span class="question-progress">${qIndex + 1}/${
              quiz.questions.length
            }</span>
                    </div>
                    <div class="question-text">${question.question}</div>
                    <div class="question-options">
                        ${question.options
                          .map(
                            (option, oIndex) => `
                            <div class="option" data-option="${oIndex}" onclick="selectOption(${qIndex}, ${oIndex})">
                                <span class="option-letter">${String.fromCharCode(
                                  65 + oIndex
                                )}</span>
                                <span class="option-text">${option}</span>
                            </div>
                        `
                          )
                          .join("")}
                    </div>
                </div>
            `;
          });

          quizHTML += `
            <div class="quiz-controls">
                <button class="btn btn-secondary" id="prevQuestionBtn" onclick="previousQuestion()" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <div>
                    <button class="btn btn-secondary" id="nextQuestionBtn" onclick="nextQuestion()" disabled>
                        Next
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <button class="btn btn-primary" id="submitQuizBtn" onclick="submitQuiz()" style="display: none;">
                        <i class="fas fa-check"></i>
                        Submit Quiz
                    </button>
                </div>
            </div>

            <div class="quiz-results" id="quizResults">
                <div class="quiz-score" id="quizScore">0%</div>
                <div class="quiz-message" id="quizMessage"></div>
                <div class="quiz-actions">
                    <button class="btn btn-primary" id="continueBtn" onclick="completeLesson()" style="display: none;">
                        <i class="fas fa-arrow-right"></i>
                        Continue to Next Lesson
                    </button>
                    <button class="btn btn-secondary" onclick="retakeQuiz()">
                        <i class="fas fa-redo"></i>
                        Retake Quiz
                    </button>
                </div>
            </div>
        `;
        }

        quizHTML += "</div>";
        return quizHTML;
      }

      // Quiz interaction functions
      function selectOption(questionIndex, optionIndex) {
        // Clear previous selections
        document
          .querySelectorAll(`[data-question="${questionIndex}"] .option`)
          .forEach((opt) => {
            opt.classList.remove("selected");
          });

        // Select current option
        const selectedOption = document.querySelector(
          `[data-question="${questionIndex}"] [data-option="${optionIndex}"]`
        );
        selectedOption.classList.add("selected");

        // Store answer
        quizState.answers[questionIndex] = optionIndex;

        // Update navigation
        const isLastQuestion =
          questionIndex ===
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length - 1;
        if (isLastQuestion) {
          document.getElementById("submitQuizBtn").style.display =
            "inline-flex";
          document.getElementById("nextQuestionBtn").style.display = "none";
        } else {
          document.getElementById("nextQuestionBtn").disabled = false;
        }
      }

      function nextQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const nextQuestionEl = currentQuestionEl.nextElementSibling;

        if (
          nextQuestionEl &&
          nextQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          nextQuestionEl.classList.add("active");
          quizState.currentQuestion++;
          updateQuizNavigation();
        }
      }

      function previousQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const prevQuestionEl = currentQuestionEl.previousElementSibling;

        if (
          prevQuestionEl &&
          prevQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          prevQuestionEl.classList.add("active");
          quizState.currentQuestion--;
          updateQuizNavigation();
        }
      }

      function updateQuizNavigation() {
        const totalQuestions =
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length;
        const prevBtn = document.getElementById("prevQuestionBtn");
        const nextBtn = document.getElementById("nextQuestionBtn");
        const submitBtn = document.getElementById("submitQuizBtn");

        prevBtn.disabled = quizState.currentQuestion === 0;

        const hasAnswer =
          quizState.answers[quizState.currentQuestion] !== undefined;
        const isLastQuestion = quizState.currentQuestion === totalQuestions - 1;

        if (isLastQuestion) {
          nextBtn.style.display = "none";
          submitBtn.style.display = hasAnswer ? "inline-flex" : "none";
        } else {
          nextBtn.style.display = "inline-flex";
          nextBtn.disabled = !hasAnswer;
          submitBtn.style.display = "none";
        }
      }

      async function submitQuiz() {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const quiz = lesson.quiz;
        let correctAnswers = 0;

        // Hide questions and controls
        document
          .querySelectorAll(".quiz-question")
          .forEach((q) => (q.style.display = "none"));
        document.querySelector(".quiz-controls").style.display = "none";

        // Calculate score and highlight answers
        quiz.questions.forEach((question, index) => {
          const userAnswer = quizState.answers[index];
          const correctAnswer = question.correct;
          const isCorrect = userAnswer === correctAnswer;

          if (isCorrect) correctAnswers++;

          // Highlight answers
          const questionEl = document.querySelector(
            `[data-question="${index}"]`
          );
          const options = questionEl.querySelectorAll(".option");

          options[correctAnswer].classList.add("correct");
          if (userAnswer !== correctAnswer && userAnswer !== undefined) {
            options[userAnswer].classList.add("incorrect");
          }
        });

        const score = Math.round(
          (correctAnswers / quiz.questions.length) * 100
        );
        const passed = score >= quiz.passingScore;

        // Update quiz results UI
        const quizScore = document.getElementById("quizScore");
        const quizMessage = document.getElementById("quizMessage");
        const quizActions = document.querySelector(".quiz-actions");

        quizScore.textContent = `${score}%`;
        quizScore.className = `quiz-score ${passed ? "pass" : "fail"}`;

        if (passed) {
          quizMessage.innerHTML = `
            <strong>Congratulations!</strong><br>
            You passed with ${score}%. You can now proceed to the next lesson.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-primary" onclick="completeLesson()">
                <i class="fas fa-arrow-right"></i>
                Continue to Next Lesson
            </button>
        `;

          // Mark lesson as completed
          await markLessonComplete(score);
        } else {
          quizMessage.innerHTML = `
            <strong>Not quite there yet.</strong><br>
            You scored ${score}%. You need ${quiz.passingScore}% to pass. Review the material and try again.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-secondary" onclick="retakeQuiz()">
                <i class="fas fa-redo"></i>
                Retake Quiz
            </button>
        `;
        }

        document.getElementById("quizResults").classList.add("show");

        // Log quiz completion
        logUserActivity("quiz_completed", {
          lesson_id: lesson.id,
          lesson_title: lesson.title,
          score: score,
          passed: passed,
          attempts: (courseProgress[lesson.id]?.quizAttempts || 0) + 1,
        });

        // Scroll to results
        document
          .getElementById("quizResults")
          .scrollIntoView({ behavior: "smooth" });
      }

      function retakeQuiz() {
        // Reset quiz state
        quizState = {
          currentQuestion: 0,
          answers: [],
          score: 0,
          isComplete: false,
        };

        // Track quiz retry
        const lessonId = COURSE_DATA.lessons[currentLessonIndex].id;
        if (!courseProgress[lessonId]) courseProgress[lessonId] = {};
        courseProgress[lessonId].quizAttempts =
          (courseProgress[lessonId].quizAttempts || 0) + 1;

        // Reload lesson content
        loadLesson(currentLessonIndex);

        // Scroll to quiz
        setTimeout(() => {
          document
            .getElementById("quizSection")
            .scrollIntoView({ behavior: "smooth" });
        }, 500);
      }

      async function markLessonComplete(score) {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonId = lesson.id;

        // Track lesson completion time
        trackLessonTime();

        // Update lesson progress
        courseProgress[lessonId] = {
          ...courseProgress[lessonId],
          completed: true,
          quizScore: score,
          completedAt: new Date().toISOString(),
          finalScore: score,
        };

        // Update session tracking
        courseSession.lessonsCompleted++;

        // Save progress to database
        await saveProgress();

        // Update UI
        renderSidebar();
        updateNavigationButtons();

        // Check various achievements
        await checkLessonCompletionAchievements();
        await checkPerfectScoreAchievements(score);
        await checkStudyTimeAchievements();

        // Log lesson completion
        logUserActivity("lesson_completed", {
          lesson_id: lessonId,
          lesson_title: lesson.title,
          final_score: score,
          time_spent: courseProgress[lessonId].timeSpent || 0,
          lesson_number: currentLessonIndex + 1,
        });

        showToast("Lesson completed successfully!", "success");
      }

      async function completeLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          // Move to next lesson
          currentLessonIndex++;
          loadLesson(currentLessonIndex);
        } else {
          // Course completion
          await completeCourse();
        }
      }

      async function completeCourse() {
        try {
          const completionTime = courseSession.totalStudyTime;

          // Update course progress to 100% completed
          await supabase
            .from("course_progress")
            .update({
              progress: 100,
              completed_at: new Date().toISOString(),
              completion_time_minutes: completionTime,
            })
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Award course completion achievements
          await checkAndUnlockAchievement("course_completion_1");
          await checkSpeedCompletionAchievements(completionTime);
          await checkCourseStreakAchievements();

          // Update user stats
          await updateUserStats();

          // Show completion message
          showToast(
            "Congratulations! Course completed successfully!",
            "certificate"
          );

          // Log course completion
          logUserActivity("course_completed", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            completion_time_minutes: completionTime,
            total_lessons: COURSE_DATA.lessons.length,
            average_quiz_score: calculateAverageQuizScore(),
          });

          // Redirect to dashboard after delay
          setTimeout(() => {
            window.location.href = "/dashboard.html";
          }, 3000);
        } catch (error) {
          console.error("Error completing course:", error);
          showToast("Error marking course as complete", "error");
        }
      }

      // =====================================================
      // ACHIEVEMENT INTEGRATION SYSTEM
      // =====================================================
      async function checkAndUnlockAchievement(
        achievementId,
        skipNotification = false
      ) {
        try {
          // Prevent duplicate checks
          const cacheKey = `achievement_${achievementId}_${currentUser.id}`;
          if (sessionStorage.getItem(cacheKey)) return false;

          // Check if already unlocked
          const { data: existing, error } = await supabase
            .from("user_achievements")
            .select("id")
            .eq("user_id", currentUser.id)
            .eq("achievement_id", achievementId)
            .single();

          if (existing) {
            sessionStorage.setItem(cacheKey, "true");
            return false;
          }

          // Award achievement
          const achievementData = {
            user_id: currentUser.id,
            achievement_id: achievementId,
            unlocked_at: new Date().toISOString(),
            points_awarded: getAchievementPoints(achievementId),
            context: "course_system",
          };

          const { data, error: insertError } = await supabase
            .from("user_achievements")
            .insert([achievementData])
            .select()
            .single();

          if (insertError) {
            if (insertError.code === "23505") return false; // Already exists
            throw insertError;
          }

          // Update user points
          await supabase.rpc('increment_user_stats', {
  user_id_param: currentUser.id,
  points_to_add: achievementData.points_awarded,
  achievements_to_add: 1
});

          // Cache and queue notification
          sessionStorage.setItem(cacheKey, "true");

          if (!skipNotification) {
            queueAchievementNotification({
              id: achievementId,
              name: getAchievementName(achievementId),
              description: getAchievementDescription(achievementId),
              points: achievementData.points_awarded,
              rarity: getAchievementRarity(achievementId),
              icon: getAchievementIcon(achievementId),
            });
          }

          return true;
        } catch (error) {
          console.error("Error unlocking achievement:", error);
          return false;
        }
      }

      // Helper functions for achievement data (replace with your actual achievement definitions)
      function getAchievementPoints(id) {
        const pointsMap = {
          first_course_start: 75,
          first_lesson: 100,
          course_completion_1: 500,
          perfect_score: 250,
          speed_demon: 750,
          marathon_learner: 500,
          night_owl: 200,
          early_bird: 200,
          weekend_warrior: 150,
          // Add more as needed
        };
        return pointsMap[id] || 100;
      }

      function getAchievementName(id) {
        const nameMap = {
          first_course_start: "Learning Initiated",
          first_lesson: "First Steps",
          course_completion_1: "Course Conqueror",
          perfect_score: "Perfectionist",
          speed_demon: "Speed Demon",
          // Add more as needed
        };
        return nameMap[id] || "Achievement Unlocked";
      }

      function getAchievementDescription(id) {
        const descMap = {
          first_course_start: "Start your first cybersecurity course",
          first_lesson: "Complete your first lesson",
          course_completion_1: "Complete your first course",
          perfect_score: "Score 100% on any quiz",
          speed_demon: "Complete a course in under 2 hours",
          // Add more as needed
        };
        return descMap[id] || "Achievement description";
      }

      function getAchievementRarity(id) {
        const rarityMap = {
          first_course_start: "common",
          first_lesson: "bronze",
          course_completion_1: "silver",
          perfect_score: "gold",
          speed_demon: "legendary",
          // Add more as needed
        };
        return rarityMap[id] || "common";
      }

      function getAchievementIcon(id) {
        const iconMap = {
          first_course_start: "fas fa-play",
          first_lesson: "fas fa-baby",
          course_completion_1: "fas fa-trophy",
          perfect_score: "fas fa-star",
          speed_demon: "fas fa-rocket",
          // Add more as needed
        };
        return iconMap[id] || "fas fa-award";
      }

      async function checkLessonAchievements(lessonNumber) {
        if (lessonNumber === 1) {
          await checkAndUnlockAchievement("first_lesson");
        }

        // Check if user has completed multiple lessons in one day
        const today = new Date().toISOString().split("T")[0];
        const todayCompletions = Object.values(courseProgress).filter(
          (p) => p.completed && p.completedAt?.startsWith(today)
        ).length;

        if (todayCompletions >= 3) {
          await checkAndUnlockAchievement("lesson_marathon");
        }
      }

      async function checkLessonCompletionAchievements() {
        const completedCount = getCompletedLessonsCount();

        // Lesson-based achievements
        const lessonMilestones = [1, 5, 10, 25, 50, 100];
        for (const milestone of lessonMilestones) {
          if (completedCount >= milestone) {
            await checkAndUnlockAchievement(`lessons_${milestone}`);
          }
        }

        // Course completion achievements
        if (completedCount === COURSE_DATA.lessons.length) {
          await checkAndUnlockAchievement("course_completion_1");

          // Check for additional course completion achievements
          const { data: allCourses } = await supabase
            .from("course_progress")
            .select("course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100);

          const totalCompleted = allCourses?.length || 0;

          const courseMilestones = [1, 5, 10, 25];
          for (const milestone of courseMilestones) {
            if (totalCompleted >= milestone) {
              await checkAndUnlockAchievement(`course_completion_${milestone}`);
            }
          }
        }
      }

      async function checkPerfectScoreAchievements(score) {
        if (score === 100) {
          await checkAndUnlockAchievement("perfect_score");

          // Check for consecutive perfect scores
          const recentScores = Object.values(courseProgress)
            .filter((p) => p.completed && p.quizScore)
            .slice(-5) // Last 5 completed
            .map((p) => p.quizScore);

          if (
            recentScores.length >= 3 &&
            recentScores.every((s) => s === 100)
          ) {
            await checkAndUnlockAchievement("perfectionist_streak");
          }
        }
      }

      async function checkSpeedCompletionAchievements(completionTime) {
        // Speed demon: Complete course in under 2 hours (120 minutes)
        if (completionTime <= 120) {
          await checkAndUnlockAchievement("speed_demon");
        }

        // Quick learner: Complete course in under 4 hours (240 minutes)
        if (completionTime <= 240) {
          await checkAndUnlockAchievement("quick_learner");
        }
      }

      async function checkStudyTimeAchievements() {
        const totalTime = courseSession.totalStudyTime;

        // Marathon learner: Study for 8+ hours in a course session
        if (totalTime >= 480) {
          // 8 hours
          await checkAndUnlockAchievement("marathon_learner");
        }

        // Dedicated learner: Study for 4+ hours
        if (totalTime >= 240) {
          // 4 hours
          await checkAndUnlockAchievement("dedicated_learner");
        }
      }

      async function checkCourseStreakAchievements() {
        try {
          // Check for consecutive course completions
          const { data: recentCourses, error } = await supabase
            .from("course_progress")
            .select("completed_at, course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100)
            .order("completed_at", { ascending: false })
            .limit(10);

          if (error || !recentCourses) return;

          // Check for courses completed on consecutive days
          let consecutiveDays = 1;
          for (let i = 1; i < recentCourses.length; i++) {
            const prevDate = new Date(
              recentCourses[i - 1].completed_at
            ).toDateString();
            const currentDate = new Date(
              recentCourses[i].completed_at
            ).toDateString();
            const dayDiff =
              Math.abs(new Date(prevDate) - new Date(currentDate)) /
              (1000 * 60 * 60 * 24);

            if (dayDiff <= 1) {
              consecutiveDays++;
            } else {
              break;
            }
          }

          if (consecutiveDays >= 3) {
            await checkAndUnlockAchievement("learning_streak");
          }
        } catch (error) {
          console.error("Error checking course streak achievements:", error);
        }
      }

      // =====================================================
      // TIME-BASED ACHIEVEMENTS
      // =====================================================
      async function checkTimeBasedAchievements(timestamp) {
        const hour = timestamp.getHours();
        const dayOfWeek = timestamp.getDay();

        // Night owl (after midnight, before 6 AM)
        if (hour >= 0 && hour < 6) {
          await incrementTimeBasedCounter("midnight_sessions", "night_owl");
        }

        // Early bird (4 AM to 6 AM)
        if (hour >= 4 && hour < 6) {
          await incrementTimeBasedCounter("early_sessions", "early_bird");
        }

        // Weekend warrior (Saturday = 6, Sunday = 0)
        if (dayOfWeek === 0 || dayOfWeek === 6) {
          await incrementTimeBasedCounter(
            "weekend_sessions",
            "weekend_warrior"
          );
        }
      }

      async function incrementTimeBasedCounter(counterType, achievementId) {
        try {
          const dateStr = new Date().toISOString().split("T")[0];
          const cacheKey = `${counterType}_${currentUser.id}_${dateStr}`;

          // Prevent multiple increments per day
          if (sessionStorage.getItem(cacheKey)) return;

          // Update counter
      await supabase.rpc('increment_profile_counter', {
  user_id_param: currentUser.id,
  counter_field: counterType,
  increment_value: 1
});

          // Cache to prevent double counting
          sessionStorage.setItem(cacheKey, "true");

          // Check related achievement
          if (achievementId) {
            await checkAndUnlockAchievement(achievementId, true);
          }
        } catch (error) {
          console.error(`Error incrementing ${counterType}:`, error);
        }
      }

      async function checkDailyStreak() {
        try {
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("last_activity, current_streak, last_streak_date")
            .eq("id", currentUser.id)
            .single();

          if (error) throw error;

          const now = new Date();
          const today = now.toDateString();
          const lastActivity = profile.last_activity
            ? new Date(profile.last_activity)
            : null;
          const lastStreakDate = profile.last_streak_date
            ? new Date(profile.last_streak_date).toDateString()
            : null;

          let newStreak = profile.current_streak || 0;
          let shouldUpdateStreak = false;

          if (!lastActivity) {
            // First time user
            newStreak = 1;
            shouldUpdateStreak = true;
          } else {
            const daysSinceLastActivity = Math.floor(
              (now - lastActivity) / (1000 * 60 * 60 * 24)
            );

            if (lastStreakDate === today) {
              // Already counted today's streak
              return newStreak;
            } else if (
              daysSinceLastActivity === 1 ||
              (daysSinceLastActivity === 0 && lastStreakDate !== today)
            ) {
              // Consecutive day or same day but not counted yet
              newStreak += 1;
              shouldUpdateStreak = true;
            } else if (daysSinceLastActivity > 1) {
              // Streak broken
              newStreak = 1;
              shouldUpdateStreak = true;
            }
          }

          if (shouldUpdateStreak) {
            await supabase
              .from("profiles")
              .update({
                current_streak: newStreak,
                last_activity: now.toISOString(),
                last_streak_date: now.toISOString(),
              })
              .eq("id", currentUser.id);

            userStats.current_streak = newStreak;

            showToast(`Daily streak: ${newStreak} days!`, "success");
            await checkStreakAchievements(newStreak);
          }

          return newStreak;
        } catch (error) {
          console.error("Error checking daily streak:", error);
          return 0;
        }
      }

      async function checkStreakAchievements(currentStreak) {
        const streakMilestones = [3, 7, 14, 30, 100, 365];

        for (const milestone of streakMilestones) {
          if (currentStreak >= milestone) {
            await checkAndUnlockAchievement(`streak_${milestone}`);
          }
        }
      }

      // =====================================================
      // USER ACTIVITY LOGGING
      // =====================================================
      async function logUserActivity(activityType, metadata = {}) {
        try {
          const now = new Date();

          const activityData = {
            user_id: currentUser.id,
            activity_type: activityType,
            timestamp: now.toISOString(),
            course_id: COURSE_DATA.id,
            lesson_index: currentLessonIndex,
            session_duration: courseSession.totalStudyTime,
            metadata: JSON.stringify(metadata),
            created_at: now.toISOString(),
          };

          // Try to log to activities table
          const { error } = await supabase
            .from("user_activities")
            .insert([activityData]);

          if (error && error.code !== "42P01") {
            console.warn("Activity logging failed:", error.message);
          }

          // Always update last activity in profile
          await supabase
            .from("profiles")
            .update({ last_activity: now.toISOString() })
            .eq("id", currentUser.id);
        } catch (error) {
          console.error("Error logging user activity:", error);
        }
      }

      // =====================================================
      // NAVIGATION SYSTEM
      // =====================================================
      function updateNavigationButtons() {
        const prevBtn = document.getElementById("prevLessonBtn");
        const nextBtn = document.getElementById("nextLessonBtn");

        if (!prevBtn || !nextBtn) return;

        // Previous button
        prevBtn.disabled = currentLessonIndex === 0;

        // Next button logic
        const isLastLesson =
          currentLessonIndex === COURSE_DATA.lessons.length - 1;
        const canGoNext =
          currentLessonIndex < COURSE_DATA.lessons.length - 1 &&
          canAccessLesson(currentLessonIndex + 1);

        if (isLastLesson) {
          const isCurrentCompleted =
            courseProgress[COURSE_DATA.lessons[currentLessonIndex].id]
              ?.completed;
          nextBtn.disabled = !isCurrentCompleted;
          nextBtn.innerHTML = '<i class="fas fa-trophy"></i> Complete Course';
        } else {
          nextBtn.disabled = !canGoNext;
          nextBtn.innerHTML = 'Next <i class="fas fa-chevron-right"></i>';
        }
      }

      // Navigation button event handlers
      function goToPreviousLesson() {
        if (currentLessonIndex > 0) {
          trackLessonTime(); // Track time spent on current lesson
          currentLessonIndex--;
          loadLesson(currentLessonIndex);
        }
      }

      function goToNextLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          const canGoNext = canAccessLesson(currentLessonIndex + 1);
          if (canGoNext) {
            trackLessonTime();
            currentLessonIndex++;
            loadLesson(currentLessonIndex);
          } else {
            showToast("Complete the current lesson quiz to proceed", "warning");
          }
        } else {
          // Complete course
          completeCourse();
        }
      }

      // =====================================================
      // SIDEBAR FUNCTIONS
      // =====================================================
      function toggleSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.toggle("open");
        if (overlay) overlay.classList.toggle("active");
      }

      function closeSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.remove("open");
        if (overlay) overlay.classList.remove("active");
      }

      // =====================================================
      // ACHIEVEMENT NOTIFICATION SYSTEM
      // =====================================================
      function queueAchievementNotification(achievement) {
        notificationQueue.push(achievement);
        processNotificationQueue();
      }

      function processNotificationQueue() {
        if (isShowingNotification || notificationQueue.length === 0) return;

        isShowingNotification = true;
        const achievement = notificationQueue.shift();
        showAchievementNotification(achievement);

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          isShowingNotification = false;
          processNotificationQueue();
        }, duration + 500);
      }

      function showAchievementNotification(achievement) {
        const notification = document.getElementById("achievementNotification");
        if (!notification) return;

        const icon = document.getElementById("notificationIcon");
        const title = document.getElementById("notificationTitle");
        const description = document.getElementById("notificationDescription");
        const points = document.getElementById("notificationPoints");

        if (icon) {
          icon.innerHTML = `<i class="${achievement.icon}"></i>`;
          icon.className = `notification-icon ${achievement.rarity}`;
        }
        if (title) title.textContent = achievement.name;
        if (description) description.textContent = achievement.description;
        if (points) points.textContent = `+${achievement.points} Points`;

        notification.className = `achievement-notification ${achievement.rarity}`;
        notification.classList.add("show");

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          notification.classList.remove("show");
        }, duration);
      }

      // =====================================================
      // UTILITY FUNCTIONS
      // =====================================================
      function calculateAverageQuizScore() {
        const scores = Object.values(courseProgress)
          .filter((p) => p.completed && p.quizScore)
          .map((p) => p.quizScore);

        if (scores.length === 0) return 0;
        return Math.round(
          scores.reduce((sum, score) => sum + score, 0) / scores.length
        );
      }

      async function resetProgress() {
        if (
          !confirm(
            "Are you sure you want to reset your progress? This action cannot be undone."
          )
        ) {
          return;
        }

        try {
          // Track lesson time before reset
          trackLessonTime();

          // Reset local state
          courseProgress = {};
          currentLessonIndex = 0;
          courseSession = {
            startTime: new Date(),
            totalStudyTime: 0,
            lessonsStarted: 0,
            lessonsCompleted: 0,
            pageLoadTime: new Date(),
            interactionCount: 0,
            lastActivityTime: new Date(),
          };

          // Delete from database
          await supabase
            .from("course_progress")
            .delete()
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Log reset activity
          logUserActivity("progress_reset", {
            course_id: COURSE_DATA.id,
            reset_reason: "manual",
          });

          // Reinitialize
          await saveProgress();
          renderSidebar();
          loadLesson(0);

          showToast("Progress reset successfully", "success");
        } catch (error) {
          console.error("Error resetting progress:", error);
          showToast("Failed to reset progress", "error");
        }
      }

      function copyCode(codeId) {
        const codeElement = document.getElementById(codeId);
        if (!codeElement) return;

        const text = codeElement.textContent;

        navigator.clipboard
          .writeText(text)
          .then(() => {
            showToast("Code copied to clipboard!", "success");

            // Track code copy for achievements
            logUserActivity("code_copied", {
              code_section: codeId,
              lesson_id: COURSE_DATA.lessons[currentLessonIndex].id,
            });
          })
          .catch((err) => {
            console.error("Failed to copy code:", err);
            showToast("Failed to copy code", "error");

            // Fallback for older browsers
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            try {
              document.execCommand("copy");
              showToast("Code copied to clipboard!", "success");
            } catch (fallbackError) {
              showToast(
                "Copy failed - please select and copy manually",
                "error"
              );
            }
            document.body.removeChild(textArea);
          });
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // =====================================================
      // UI FEEDBACK SYSTEMS
      // =====================================================
      function showToast(message, type = "success") {
        const toast = document.getElementById("toast");
        const messageEl = document.getElementById("toastMessage");

        if (!toast || !messageEl) {
          console.log(`Toast: ${message} (${type})`);
          return;
        }

        messageEl.textContent = message;
        toast.className = `toast ${type} show`;

        setTimeout(() => {
          toast.classList.remove("show");
        }, 4000);
      }

      function showLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) loadingScreen.classList.remove("hidden");
      }

      function hideLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) {
          setTimeout(() => {
            loadingScreen.classList.add("hidden");
          }, 1000);
        }
      }

      // =====================================================
      // MUSIC PLAYER INTEGRATION
      // =====================================================
      function initMusicPlayer() {
        const btnText = document.getElementById("music-button-text");
        const icon = document.getElementById("music-icon");
        const dropdown = document.getElementById("music-dropdown-content");

        if (!btnText || !icon || !dropdown) return;

        function setUI(state) {
          btnText.textContent =
            state === "Playing" ? "PAUSE MUSIC" : "STUDY MUSIC";
          icon.className =
            state === "Playing"
              ? "fa-solid fa-circle-pause"
              : "fa-solid fa-music";
        }

        // Load saved music state
        const savedSrc = localStorage.getItem("cybersec_music_src");
        const savedTime = parseFloat(
          localStorage.getItem("cybersec_music_time") || 0
        );

        if (savedSrc) {
          audioPlayer.src = savedSrc;
          audioPlayer.currentTime = savedTime;
          audioPlayer
            .play()
            .then(() => setUI("Playing"))
            .catch(() => setUI("Stopped"));
        }

        // Music button click handler
        document
          .getElementById("music-dropdown")
          .querySelector("button")
          .addEventListener("click", (e) => {
            e.stopPropagation();
            dropdown.style.display =
              dropdown.style.display === "block" ? "none" : "block";

            if (audioPlayer.src && !audioPlayer.paused) {
              audioPlayer.pause();
              setUI("Stopped");
            } else if (audioPlayer.src) {
              audioPlayer.play().then(() => setUI("Playing"));
            }
          });

        // Music selection handlers
        dropdown.querySelectorAll("a[data-src]").forEach((link) => {
          link.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.src = link.dataset.src;
            audioPlayer.play().then(() => setUI("Playing"));
            localStorage.setItem("cybersec_music_src", link.dataset.src);
            dropdown.style.display = "none";
          });
        });

        // Stop music handler
        const stopLink = document.getElementById("stop-music-link");
        if (stopLink) {
          stopLink.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            audioPlayer.removeAttribute("src");
            setUI("Stopped");
            localStorage.removeItem("cybersec_music_src");
            localStorage.removeItem("cybersec_music_time");
            dropdown.style.display = "none";
          });
        }

        // Save music state before page unload
        window.addEventListener("beforeunload", () => {
          if (!audioPlayer.paused && audioPlayer.src) {
            localStorage.setItem("cybersec_music_src", audioPlayer.src);
            localStorage.setItem(
              "cybersec_music_time",
              audioPlayer.currentTime
            );
          }
        });

        // Close dropdown when clicking outside
        window.addEventListener("click", (e) => {
          if (!e.target.closest("#music-dropdown")) {
            dropdown.style.display = "none";
          }
        });
      }

      // Show initial music indicator
      function addMusicIndicator() {
        const musicBtn = document.querySelector("#music-dropdown");
        if (musicBtn) {
          const indicator = document.createElement("div");
          indicator.className = "music-indicator";
          indicator.innerHTML = `<i class="fa-solid fa-music"></i> Try Study Music!`;

          musicBtn.style.position = "relative";
          musicBtn.appendChild(indicator);

          setTimeout(() => indicator.remove(), 3000);
        }
      }

      // Initialize Event Listeners
      function initializeEventListeners() {
        // Navigation buttons
        document
          .getElementById("prevLessonBtn")
          ?.addEventListener("click", goToPreviousLesson);
        document
          .getElementById("nextLessonBtn")
          ?.addEventListener("click", goToNextLesson);

        // Reset progress button
        document
          .getElementById("resetProgressBtn")
          ?.addEventListener("click", resetProgress);

        // Mobile menu toggle
        document
          .getElementById("menuToggle")
          ?.addEventListener("click", toggleSidebar);
        document
          .getElementById("sidebarOverlay")
          ?.addEventListener("click", closeSidebar);

        // Keyboard shortcuts
        document.addEventListener("keydown", handleKeyboardShortcuts);

        // Window resize handler
        window.addEventListener("resize", handleWindowResize);

        // Content interaction tracking
        document.getElementById("contentBody")?.addEventListener(
          "scroll",
          debounce(() => {
            trackUserInteraction();
          }, 1000)
        );
      }

      // Keyboard Shortcuts
      function handleKeyboardShortcuts(e) {
        if (document.querySelector(".quiz-question.active")) return;

        if (e.key === "ArrowLeft" && e.ctrlKey) {
          e.preventDefault();
          goToPreviousLesson();
        } else if (e.key === "ArrowRight" && e.ctrlKey) {
          e.preventDefault();
          goToNextLesson();
        }
      }

      // Window Resize Handler
      function handleWindowResize() {
        if (window.innerWidth > 768) {
          closeSidebar();
        }
      }

      // Debounce Helper
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Initialize responsive behavior
      if (window.innerWidth <= 768) {
        document.getElementById("menuToggle").style.display = "inline-flex";
      }

      // Auto-save progress periodically
      setInterval(async () => {
        if (currentUser && Object.keys(courseProgress).length > 0) {
          await saveProgress();
        }
      }, 60000); // Save every minute

      // System initialization logging
      console.log("CyberSec Academy Course System Initialized");
      console.log("Current Course:", COURSE_DATA.title);
      console.log("Total Lessons:", COURSE_DATA.lessons.length);

      // Google OAuth Integration
      const googleBtn = document.querySelector(".btn-google");
      if (googleBtn) {
        googleBtn.addEventListener("click", async () => {
          const { data, error } = await supabase.auth.signInWithOAuth({
            provider: "google",
            options: {
              redirectTo: window.location.origin + "/courses/system-hardening-basics.html",
            },
          });

          if (error) {
            console.error("Google login error:", error.message);
            showToast("Google login failed: " + error.message, "error");
          }
        });
      }

      // Check for existing session
      supabase.auth.getSession().then(({ data }) => {
        if (data.session) {
          console.log("User already logged in:", data.session.user);
          currentUser = data.session.user;
          startCourseSession();
        }
      });

      // Add missing auth modal functions
      function openAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "flex";
        }
      }

      function closeAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Add auth tab switching functionality
      document.getElementById("tabSignIn")?.addEventListener("click", () => {
        document.getElementById("tabSignIn").classList.add("active");
        document.getElementById("tabSignUp").classList.remove("active");
        document.getElementById("signInForm").style.display = "block";
        document.getElementById("signUpForm").style.display = "none";
      });

      document.getElementById("tabSignUp")?.addEventListener("click", () => {
        document.getElementById("tabSignUp").classList.add("active");
        document.getElementById("tabSignIn").classList.remove("active");
        document.getElementById("signUpForm").style.display = "block";
        document.getElementById("signInForm").style.display = "none";
      });

      document
        .getElementById("closeAuthModal")
        ?.addEventListener("click", closeAuthModal);

      // Improved error handling for auth session
      supabase.auth.onAuthStateChange((event, session) => {
        if (event === "SIGNED_IN") {
          currentUser = session.user;
          closeAuthModal();
          startCourseSession();
        } else if (event === "SIGNED_OUT") {
          currentUser = null;
          openAuthModal();
        }
      });

      // Add form submission handlers
      document
        .getElementById("emailSignInForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signInEmail").value;
          const password = document.getElementById("signInPassword").value;

          try {
            const { data, error } = await supabase.auth.signInWithPassword({
              email,
              password,
            });

            if (error) throw error;

            closeAuthModal();
          } catch (error) {
            showToast(error.message, "error");
          }
        });

      document
        .getElementById("emailSignUpForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signUpEmail").value;
          const password = document.getElementById("signUpPassword").value;
          const name = document.getElementById("signUpName").value;

          try {
            const { data, error } = await supabase.auth.signUp({
              email,
              password,
              options: {
                data: {
                  full_name: name,
                },
              },
            });

            if (error) throw error;

            showToast(
              "Account created successfully! Please check your email.",
              "success"
            );
          } catch (error) {
            showToast(error.message, "error");
          }
        });
    </script>
  </body>
</html>

