





<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- ========== Start: SEO & Schema Enhancement ========== -->
    <title>Cryptography Essentials Course | CipherHall</title>
    <meta name="description" content="Enroll in our free, expert-led Cryptography Essentials course. Learn the foundations of modern encryption, from AES to RSA and beyond." />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png" />
    <link rel="shortcut icon" href="/favicon.png" type="image/x-icon" />
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png" />
    <link rel="canonical" href="https://www.cipherhall.com/courses/cryptography-essentials" />

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Course",
      "name": "Cryptography Essentials",
      "description": "Learn the foundations of cryptography, from classical ciphers to modern algorithms and their practical applications in cybersecurity.",
      "provider": {
        "@type": "Organization",
        "name": "CipherHall",
        "sameAs": "https://www.cipherhall.com"
      },
      "hasCourseInstance": {
        "@type": "CourseInstance",
        "courseMode": "Online",
        "instructor": {
          "@type": "Person",
          "name": "Dr. Evelyn Reed"
        }
      }
    }
    </script>
    <!-- ========== End: SEO & Schema Enhancement ========== -->
    
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Exo+2:wght@700;800;900&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css"
    />
    <link rel="icon" type="image/x-icon" href="assets/favicon.ico" />

    <link rel="stylesheet" href="assets/css/coursepages.css" />
</head>
<body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
        <div class="loader-icon">
            <i class="fas fa-graduation-cap"></i>
        </div>
        <div class="loader-text">Loading Course Content...</div>
    </div>
    
    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>
    
    <!-- Music Player (fixed at top right) -->
    <div class="header-controls">
        <div class="music-dropdown" id="music-dropdown">
            <button class="btn btn-secondary">
                <span id="music-button-text">STUDY MUSIC</span>
                <i id="music-icon" class="fa-solid fa-music"></i>
            </button>
            <div class="music-dropdown-content" id="music-dropdown-content">
                <a href="#" data-src="https://www.learningcontainer.com/wp-content/uploads/2020/02/Kalimba.mp3">1. Coffee Shop Vibes</a>
                <a href="#" data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3">2. City Lights Lofi</a>
                <a href="#" data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-15.mp3">3. Mellow Thoughts</a>
                <a href="#" data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-13.mp3">4. Rainy Mood</a>
                <a href="#" data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3">5. Time Alone</a>
                <a href="#" id="stop-music-link"><i class="fa-solid fa-stop-circle"></i> Stop Music</a>
            </div>
        </div>
        
        <button class="btn btn-secondary" id="resetProgressBtn">
            <i class="fas fa-redo"></i>
            Reset Progress
        </button>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal" style="display: none">
        <div class="modal-overlay"></div>
        <div class="modal-content">
            <span class="close" id="closeAuthModal">&times;</span>
            <div class="auth-tabs">
                <button id="tabSignIn" class="auth-tab active">Sign In</button>
                <button id="tabSignUp" class="auth-tab">Sign Up</button>
            </div>
            <div id="authLoader" style="display: none; text-align: center; padding: 2rem">
                <i class="fas fa-spinner fa-spin fa-2x" style="color: var(--color-green)"></i>
                <p style="margin-top: 0.5rem">Authenticating...</p>
            </div>
            <div id="signInForm" class="auth-form">
                <h2>Sign In to CiperHall</h2>
                <button id="googleSignIn" class="btn btn-google">
                    <i class="fab fa-google"></i> Continue with Google
                </button>
                <div class="divider"><span>or</span></div>
                <form id="emailSignInForm">
                    <input type="email" id="signInEmail" placeholder="Email Address" required>
                    <input type="password" id="signInPassword" placeholder="Password" required>
                    <button type="submit" class="btn btn-primary">Sign In</button>
                </form>
            </div>
            <div id="signUpForm" class="auth-form" style="display: none">
                <h2>Join CiperHall</h2>
                <button id="googleSignUp" class="btn btn-google">
                    <i class="fab fa-google"></i> Continue with Google
                </button>
                <div class="divider"><span>or</span></div>
                <form id="emailSignUpForm">
                    <input type="text" id="signUpName" placeholder="Full Name" required>
                    <input type="email" id="signUpEmail" placeholder="Email Address" required>
                    <input type="password" id="signUpPassword" placeholder="Password (min. 8 characters)" required>
                    <button type="submit" class="btn btn-secondary">Create Account</button>
                </form>
            </div>
            <div id="authMessage"></div>
        </div>
    </div>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <div class="course-info">
                <h1 class="course-title" id="courseTitle">Loading...</h1>
                <div class="course-progress">
                    <div class="progress-header">
                        <span class="progress-label">Course Progress</span>
                        <span class="progress-percentage" id="courseProgressPercent">0%</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="courseProgressFill" style="width: 0%"></div>
                    </div>
                    <div class="progress-stats">
                        <span id="completedLessons">0</span>
                        <span id="totalLessons">0</span>
                    </div>
                </div>
                <a href="/dashboard" class="back-to-dashboard">
                    <i class="fas fa-arrow-left"></i>
                    Back to Dashboard
                </a>
            </div>
        </div>

        <nav class="lesson-nav" id="lessonNav">
            <!-- Lessons will be loaded dynamically -->
        </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
        <header class="content-header">
            <div class="lesson-header">
                <div class="lesson-header-left">
                    <span class="lesson-number" id="currentLessonNumber">1</span>
                    <h1 class="lesson-header-title" id="currentLessonTitle">Loading...</h1>
                </div>
                <div class="lesson-actions">
                    <button class="mbtn btn-primary" id="menuToggle">
                        <i class="fas fa-bars"></i>
                       
                    </button>
                </div>
            </div>
        </header>

        <div class="content-body" id="contentBody">
            <div class="lesson-content" id="lessonContent">
                <!-- Lesson content will be loaded dynamically -->
            </div>
        </div>

        <footer class="lesson-navigation">
            <div class="nav-info" id="navInfo">
                Lesson 1 of 10
            </div>
            <div class="nav-controls">
                <button class="btn btn-secondary" id="prevLessonBtn" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <button class="btn btn-primary" id="nextLessonBtn" disabled>
                    Next
                    <i class="fas fa-chevron-right"></i>
                </button>
            </div>
        </footer>
    </main>

    <!-- Achievement Notification -->
    <div id="achievementNotification" class="achievement-notification">
        <div class="notification-header">
            <div class="notification-icon" id="notificationIcon">
                <i class="fas fa-trophy"></i>
            </div>
            <div class="notification-content">
                <h3 id="notificationTitle">Achievement Unlocked!</h3>
                <p id="notificationDescription">Description here...</p>
            </div>
        </div>
        <div class="notification-reward" id="notificationReward">
            <i class="fas fa-coins"></i>
            <span id="notificationPoints">+100 Points</span>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast">
        <span id="toastMessage"></span>
    </div>

    <script>
       // =====================================================
// SYNCHRONIZED COURSE SYSTEM WITH DASHBOARD INTEGRATION
// =====================================================

// Supabase Configuration - Replace with your config
const supabaseUrl = 'https://lzcmzulemfubjaksoqor.supabase.co';
const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx6Y216dWxlbWZ1Ympha3NvcW9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzMzM5MDgsImV4cCI6MjA3MDkwOTkwOH0.crhPH4YWtRsr1BJTpAQcmPbWSpwIWRbzoI4sRb2_fPI';
const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

// =====================================================
// COURSE DATA STRUCTURE - REPLACE WITH YOUR COURSE JSON
// =====================================================
const COURSE_DATA = {
    id: 'cryptography-essentials',
    title: 'Cryptography Essentials',
    description: 'Learn the foundations of cryptography, from classical ciphers to modern algorithms and their practical applications in cybersecurity.',
    category: 'cybersecurity-fundamentals',
    difficulty: 'Beginner to Intermediate',
    duration: '40 hours',
    instructor: 'Dr. Evelyn Reed',
    lessons: [
        {
            id: 'lesson-1',
            title: 'Introduction to Cryptography',
            duration: '60 min',
            objectives: [
                'Understand the history of cryptography from classical to modern times',
                'Define the core goals of cryptography',
                'Explain the three components of the CIA triad',
                'Learn the basics of the Caesar cipher'
            ],
            content: {
                overview: 'This introductory lesson provides a foundation for your journey into cryptography. We will explore its historical roots, define its fundamental goals, and understand the core principles of information security.',
                sections: [
                    {
                        title: 'A Brief History of Cryptography',
                        content: `
                            <p>Cryptography, the practice of secure communication, has been used for millennia. Early forms were simple substitution ciphers used by military and political leaders.</p>
                            
                            <h3>Notable Historical Ciphers:</h3>
                            <ul>
                                <li><strong>Caesar Cipher:</strong> Used by Julius Caesar, this simple substitution cipher shifts letters of the alphabet by a fixed number of places.</li>
                                <li><strong>Vigenère Cipher:</strong> An improvement on the Caesar cipher, it uses a keyword to apply a series of different shifts, making it more resistant to simple frequency analysis.</li>
                                <li><strong>Enigma Machine:</strong> A complex electro-mechanical device used by Germany in World War II. Its encryption was famously broken by Allied cryptanalysts, including Alan Turing, significantly impacting the war's outcome.</li>
                            </ul>
                            
                            <div class="info-box tip">
                                <div class="info-box-header">
                                    <i class="fas fa-lightbulb"></i>
                                    <strong>Fun Fact</strong>
                                </div>
                                <p>The cracking of the Enigma code at Bletchley Park is considered one of the most crucial intelligence breakthroughs of WWII and a foundational moment in the history of computing.</p>
                            </div>
                        `,
                        image: 'https://images.unsplash.com/photo-1585043834359-2e2e7a42a6e8?w=800&h=400&fit=crop'
                    },
                    {
                        title: 'The Goals of Modern Cryptography',
                        content: `
                            <p>Modern cryptography has evolved beyond simple secrecy to address a broader range of security challenges. Its primary goals are often summarized by the CIA triad.</p>
                            
                            <h3>The CIA Triad:</h3>
                            <ul>
                                <li><strong>Confidentiality:</strong> Ensures that information is accessible only to authorized individuals. This is achieved through encryption.</li>
                                <li><strong>Integrity:</strong> Guarantees that information is trustworthy and has not been altered in transit or storage. This is managed using hash functions and message authentication codes.</li>
                                <li><strong>Availability:</strong> Ensures that information and systems are accessible to authorized users when needed. While not a direct cryptographic goal, cryptography can protect systems from attacks that would compromise availability.</li>
                            </ul>

                            <h3>Other Key Goals:</h3>
                            <ul>
                                <li><strong>Non-repudiation:</strong> Provides proof of the origin of data, preventing the sender from denying they sent it. Achieved with digital signatures.</li>
                                <li><strong>Authentication:</strong> Confirms the identity of a user or system.</li>
                            </ul>
                        `,
                        image: 'https://images.unsplash.com/photo-1550751827-4138d04d4051?w=800&h=400&fit=crop'
                    }
                ],
                codeExamples: [
                    {
                        title: 'Lab: Manual Caesar Cipher Encryption',
                        language: 'python',
                        code: `def caesar_encrypt(text, shift):
    """Encrypts text using the Caesar cipher."""
    result = ""
    for char in text:
        if char.isalpha():
            start = ord('a') if char.islower() else ord('A')
            # Calculate the shifted position
            shifted = (ord(char) - start + shift) % 26 + start
            result += chr(shifted)
        else:
            result += char
    return result

# --- Lab Task ---
# 1. Understand the code above.
# 2. Encrypt the message "Hello World" with a shift of 3.
# 3. Decrypt the message "Khoor Zruog" by using a negative shift.

plaintext = "Hello World"
shift_key = 3
encrypted_text = caesar_encrypt(plaintext, shift_key)
print(f"Plaintext: {plaintext}")
print(f"Encrypted: {encrypted_text}")

# To decrypt, use the negative of the shift key
decrypted_text = caesar_encrypt(encrypted_text, -shift_key)
print(f"Decrypted: {decrypted_text}")`
                    }
                ]
            },
            quiz: {
                passingScore: 75,
                questions: [
                    {
                        id: 1,
                        question: "What is the primary goal of confidentiality in cryptography?",
                        options: [
                            "To ensure data is not altered.",
                            "To ensure data is available when needed.",
                            "To prevent unauthorized access to information.",
                            "To prove the origin of data."
                        ],
                        correct: 2,
                        explanation: "Confidentiality is concerned with ensuring that only authorized parties can access sensitive information, primarily through encryption."
                    },
                    {
                        id: 2,
                        question: "Which historical cipher was famously broken by Alan Turing and his team during WWII?",
                        options: [
                            "Caesar Cipher",
                            "Vigenère Cipher",
                            "Enigma Machine",
                            "DES"
                        ],
                        correct: 2,
                        explanation: "The Enigma Machine, used by Nazi Germany, was a complex electro-mechanical cipher that was broken by Allied cryptanalysts at Bletchley Park."
                    },
                    {
                        id: 3,
                        question: "The 'I' in the CIA triad stands for:",
                        options: [
                            "Information",
                            "Integrity",
                            "Identity",
                            "Intelligence"
                        ],
                        correct: 1,
                        explanation: "The 'I' in the CIA triad stands for Integrity, which ensures that data has not been tampered with or altered."
                    }
                ]
            }
        },
        {
            id: 'lesson-2',
            title: 'Mathematics of Cryptography',
            duration: '75 min',
            objectives: [
                'Understand the role of number theory in cryptography',
                'Learn the principles of modular arithmetic',
                'Recognize the importance of prime numbers and factorization',
                'Grasp the concept of Euler\'s totient function'
            ],
            content: {
                overview: 'Cryptography is built on a foundation of mathematics. This lesson explores the essential mathematical concepts, including number theory, modular arithmetic, and prime numbers, that underpin modern encryption algorithms.',
                sections: [
                    {
                        title: 'Number Theory and Prime Numbers',
                        content: `
                            <p>Number theory is the branch of mathematics that deals with the properties of integers. It is fundamental to public-key cryptography.</p>
                            
                            <h3>Prime Numbers:</h3>
                            <p>A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. They are the building blocks of integers.</p>
                            <ul>
                                <li><strong>Importance:</strong> The difficulty of factoring large numbers into their prime components is the basis for the security of algorithms like RSA.</li>
                                <li><strong>Example:</strong> 2, 3, 5, 7, 11, and 13 are prime. 21 is not prime because it can be factored into 3 * 7.</li>
                            </ul>
                        `,
                        image: 'https://images.unsplash.com/photo-1635070045099-5a1835565551?w=800&h=400&fit=crop'
                    },
                    {
                        title: 'Modular Arithmetic',
                        content: `
                            <p>Modular arithmetic is a system of arithmetic for integers, where numbers "wrap around" upon reaching a certain value—the modulus. It is sometimes called "clock arithmetic."</p>
                            
                            <h3>Core Concept:</h3>
                            <p>We say that <code>a</code> is congruent to <code>b</code> modulo <code>n</code>, written as <code>a ≡ b (mod n)</code>, if their difference <code>a - b</code> is an integer multiple of <code>n</code>. Equivalently, <code>a</code> and <code>b</code> have the same remainder when divided by <code>n</code>.</p>
                            <ul>
                                <li><strong>Example:</strong> <code>17 ≡ 5 (mod 12)</code> because 17 and 5 both have a remainder of 5 when divided by 12. On a clock, 17 o'clock is 5 PM.</li>
                                <li><strong>Operations:</strong> Addition, subtraction, and multiplication can be performed as usual, followed by taking the result modulo <code>n</code>.</li>
                            </ul>
                            
                            <div class="info-box note">
                                <div class="info-box-header">
                                    <i class="fas fa-info-circle"></i>
                                    <strong>Real-World Analogy</strong>
                                </div>
                                <p>A 12-hour clock is a perfect example of modulus 12 arithmetic. If it's 8 o'clock and you add 5 hours, it becomes 1 o'clock, not 13 o'clock. (8 + 5) mod 12 = 1.</p>
                            </div>
                        `,
                        image: 'https://images.unsplash.com/photo-1508873535684-277a3cbcc4e8?w=800&h=400&fit=crop'
                    }
                ],
                codeExamples: [
                    {
                        title: 'Lab: Implement Modular Arithmetic in Python',
                        language: 'python',
                        code: `def modular_add(a, b, n):
    """Computes (a + b) mod n"""
    return (a + b) % n

def modular_multiply(a, b, n):
    """Computes (a * b) mod n"""
    return (a * b) % n

def modular_exponentiation(base, exponent, modulus):
    """Computes (base^exponent) mod modulus efficiently"""
    return pow(base, exponent, modulus)

# --- Lab Task ---
# 1. Define a modulus, for example, n = 13.
# 2. Calculate (7 + 10) mod 13.
# 3. Calculate (7 * 10) mod 13.
# 4. Calculate (5^3) mod 13.

n = 13
a = 7
b = 10
base = 5
exponent = 3

print(f"({a} + {b}) mod {n} = {modular_add(a, b, n)}")
print(f"({a} * {b}) mod {n} = {modular_multiply(a, b, n)}")
print(f"({base}^{exponent}) mod {n} = {modular_exponentiation(base, exponent, n)}")`
                    }
                ]
            },
            quiz: {
                passingScore: 75,
                questions: [
                    {
                        id: 1,
                        question: "Which mathematical problem's difficulty is the basis for RSA's security?",
                        options: [
                            "Solving quadratic equations",
                            "Prime factorization of large numbers",
                            "Calculating logarithms",
                            "Finding the square root of large numbers"
                        ],
                        correct: 1,
                        explanation: "The security of the RSA algorithm relies on the fact that it is computationally very difficult to factor a large integer into its constituent prime numbers."
                    },
                    {
                        id: 2,
                        question: "What is the result of 25 mod 7?",
                        options: [
                            "3",
                            "4",
                            "5",
                            "6"
                        ],
                        correct: 1,
                        explanation: "25 divided by 7 is 3 with a remainder of 4. Therefore, 25 mod 7 = 4."
                    },
                    {
                        id: 3,
                        question: "In cryptography, what does 'a ≡ b (mod n)' mean?",
                        options: [
                            "a is greater than b",
                            "a and b are equal",
                            "a and b have the same remainder when divided by n",
                            "a is a multiple of b"
                        ],
                        correct: 2,
                        explanation: "The congruence relation 'a ≡ b (mod n)' means that 'a' and 'b' have the same remainder when divided by the modulus 'n'."
                    }
                ]
            }
        },
        {
            id: 'lesson-3',
            title: 'Symmetric Cryptography Basics',
            duration: '60 min',
            objectives: [
                'Define symmetric-key cryptography and its core concepts',
                'Differentiate between stream ciphers and block ciphers',
                'Understand the role and importance of the secret key',
                'Recognize common symmetric encryption algorithms'
            ],
            content: {
                overview: 'Symmetric cryptography is a fundamental pillar of data encryption where a single key is used for both encryption and decryption. This lesson covers the basic principles, two major types of symmetric ciphers, and the critical role of key management.',
                sections: [
                    {
                        title: 'The Principle of Symmetric Encryption',
                        content: `
                            <p>Symmetric-key cryptography, also known as secret-key or single-key cryptography, is an encryption scheme where the same key is used to both encrypt plaintext and decrypt ciphertext. The sender and receiver must share this secret key before they can communicate securely.</p>
                            
                            <h3>Key Characteristics:</h3>
                            <ul>
                                <li><strong>Single Key:</strong> One key for both encryption and decryption.</li>
                                <li><strong>Speed:</strong> Symmetric algorithms are generally very fast and computationally efficient, making them ideal for encrypting large volumes of data.</li>
                                <li><strong>Challenge:</strong> The primary challenge is secure key distribution—how to share the secret key with the recipient without it being intercepted.</li>
                            </ul>
                            
                            <div class="info-box note">
                                <div class="info-box-header">
                                    <i class="fas fa-info-circle"></i>
                                    <strong>Analogy: A Locked Box</strong>
                                </div>
                                <p>Think of symmetric encryption like a locked box. You use a physical key to lock it (encrypt) and the exact same key to unlock it (decrypt). Anyone who has a copy of the key can open the box.</p>
                            </div>
                        `,
                        image: 'https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?w=800&h=400&fit=crop'
                    },
                    {
                        title: 'Stream Ciphers vs. Block Ciphers',
                        content: `
                            <p>Symmetric ciphers are primarily categorized into two types: stream ciphers and block ciphers.</p>
                            
                            <h3>Stream Ciphers:</h3>
                            <p>Stream ciphers encrypt data one bit or one byte at a time. They generate a pseudorandom keystream which is combined with the plaintext using an XOR operation.</p>
                            <ul>
                                <li><strong>Characteristics:</strong> Fast, low error propagation. Good for real-time applications like voice and video streaming.</li>
                                <li><strong>Examples:</strong> RC4, ChaCha20.</li>
                            </ul>

                            <h3>Block Ciphers:</h3>
                            <p>Block ciphers operate on fixed-size blocks of data (e.g., 128 bits). The plaintext is divided into blocks, and each block is encrypted separately. If the last block is not full, it must be padded.</p>
                            <ul>
                                <li><strong>Characteristics:</strong> More common, form the basis for many cryptographic protocols. Require a mode of operation (covered in the next lesson).</li>
                                <li><strong>Examples:</strong> AES, DES, 3DES.</li>
                            </ul>
                        `,
                        image: 'https://images.unsplash.com/photo-1614064548237-0965305021b4?w=800&h=400&fit=crop'
                    }
                ],
                codeExamples: [
                    {
                        title: 'Lab: Encrypt/Decrypt a File using AES with OpenSSL',
                        language: 'bash',
                        code: `# --- Lab Task ---
# 1. Create a sample text file to encrypt.
# 2. Use OpenSSL to encrypt the file with AES-256-CBC.
# 3. You will be prompted for a password, which acts as the secret key.
# 4. Observe the encrypted output file.
# 5. Decrypt the file back to its original form using the same password.

# Step 1: Create a plaintext file
echo "This is a secret message for the symmetric encryption lab." > plaintext.txt
echo "Original file content:"
cat plaintext.txt

# Step 2: Encrypt the file using AES-256
# The '-salt' option is used to prevent dictionary attacks
openssl enc -aes-256-cbc -salt -in plaintext.txt -out encrypted.bin
echo -e "\\nEncryption complete. The file 'encrypted.bin' has been created."
echo "Note: The content of encrypted.bin is not human-readable."

# Step 3: Decrypt the file
# Use the same password you provided during encryption
echo -e "\\nAttempting to decrypt 'encrypted.bin'..."
openssl enc -d -aes-256-cbc -in encrypted.bin -out decrypted.txt

# Step 4: Verify the decrypted content
echo "Decryption complete. Verifying content:"
cat decrypted.txt`
                    }
                ]
            },
            quiz: {
                passingScore: 75,
                questions: [
                    {
                        id: 1,
                        question: "What is the main characteristic of symmetric-key cryptography?",
                        options: [
                            "It uses two different keys.",
                            "It uses one key for encryption and a different one for decryption.",
                            "It uses the same key for both encryption and decryption.",
                            "It does not use any keys."
                        ],
                        correct: 2,
                        explanation: "Symmetric cryptography is defined by its use of a single, shared secret key for both the encryption and decryption processes."
                    },
                    {
                        id: 2,
                        question: "Which type of cipher encrypts data one bit or byte at a time?",
                        options: [
                            "Block Cipher",
                            "Asymmetric Cipher",
                            "Public Cipher",
                            "Stream Cipher"
                        ],
                        correct: 3,
                        explanation: "Stream ciphers operate on a continuous stream of data, encrypting it one unit (typically a bit or byte) at a time."
                    },
                    {
                        id: 3,
                        question: "What is the primary challenge associated with symmetric encryption?",
                        options: [
                            "Slow encryption speed",
                            "Complex mathematical operations",
                            "Secure distribution of the shared key",
                            "Large key sizes"
                        ],
                        correct: 2,
                        explanation: "The main difficulty in symmetric cryptography is securely sharing the secret key between the sender and receiver without an attacker intercepting it."
                    }
                ]
            }
        },
        {
            id: 'lesson-4',
            title: 'Block Cipher Modes of Operation',
            duration: '75 min',
            objectives: [
                'Understand why block cipher modes of operation are necessary',
                'Describe the functionality of Electronic Codebook (ECB) and its weaknesses',
                'Explain Cipher Block Chaining (CBC) and its use of an IV',
                'Learn about Counter (CTR) and Galois/Counter Mode (GCM)'
            ],
            content: {
                overview: 'A block cipher encrypts only a single, fixed-size block of data. To encrypt messages longer than the block size, we must use a mode of operation. This lesson explores several common modes, their characteristics, and their security implications.',
                sections: [
                    {
                        title: 'Electronic Codebook (ECB)',
                        content: `
                            <p>ECB is the simplest mode of operation. The message is divided into blocks, and each block is encrypted separately with the same key.</p>
                            
                            <h3>Characteristics:</h3>
                            <ul>
                                <li><strong>Simple and Fast:</strong> Each block can be encrypted or decrypted in parallel.</li>
                                <li><strong>Deterministic:</strong> Identical plaintext blocks are encrypted into identical ciphertext blocks.</li>
                            </ul>

                            <h3>Major Weakness:</h3>
                            <p>The deterministic nature of ECB is a critical security flaw. Patterns in the plaintext are preserved in the ciphertext. This can leak significant information about the original message. For this reason, <strong>ECB mode should not be used in most applications.</strong></p>
                            
                            <div class="info-box warning">
                                <div class="info-box-header">
                                    <i class="fas fa-exclamation-triangle"></i>
                                    <strong>Avoid ECB Mode</strong>
                                </div>
                                <p>The classic example of ECB's weakness is an encrypted image of a penguin where the outline of the penguin remains visible in the ciphertext because identical color blocks are encrypted to the same value.</p>
                            </div>
                        `,
                        image: 'https://images.unsplash.com/photo-1562911791-c3a1a3969a2a?w=800&h=400&fit=crop'
                    },
                    {
                        title: 'Cipher Block Chaining (CBC)',
                        content: `
                            <p>CBC mode addresses the main weakness of ECB. Before each plaintext block is encrypted, it is XORed with the previous ciphertext block. This makes each ciphertext block dependent on all preceding plaintext blocks.</p>
                            
                            <h3>Initialization Vector (IV):</h3>
                            <p>For the very first block, which has no preceding ciphertext block, a random block of data called an Initialization Vector (IV) is used. The IV must be random but does not need to be kept secret; it is typically sent along with the ciphertext.</p>

                            <h3>Characteristics:</h3>
                            <ul>
                                <li><strong>Non-Deterministic:</strong> Encrypting the same message twice with different IVs will produce different ciphertexts.</li>
                                <li><strong>Sequential Encryption:</strong> Encryption cannot be parallelized because each block depends on the previous one. Decryption, however, can be.</li>
                                <li><strong>Error Propagation:</strong> An error in one ciphertext block will corrupt its corresponding plaintext block and the next one.</li>
                            </ul>
                        `,
                        image: 'https://images.unsplash.com/photo-1611606013532-b115f8c679a6?w=800&h=400&fit=crop'
                    },
                    {
                        title: 'Counter (CTR) and Galois/Counter Mode (GCM)',
                        content: `
                            <p>CTR and GCM are modern, high-performance modes of operation.</p>
                            
                            <h3>Counter (CTR) Mode:</h3>
                            <p>CTR mode turns a block cipher into a stream cipher. It encrypts a sequence of "counters" (e.g., a number that increments for each block) and then XORs the result with the plaintext blocks. It is fully parallelizable for both encryption and decryption and is very fast.</p>

                            <h3>Galois/Counter Mode (GCM):</h3>
                            <p>GCM is an authenticated encryption with associated data (AEAD) mode. It combines the efficient CTR mode for encryption with a Galois Message Authentication Code (GMAC) for authentication. This means it provides both confidentiality and integrity in a single, highly efficient operation.</p>
                            
                            <div class="info-box tip">
                                <div class="info-box-header">
                                    <i class="fas fa-lightbulb"></i>
                                    <strong>Modern Recommendation</strong>
                                </div>
                                <p>GCM is now widely recommended for most applications (e.g., in TLS 1.3) because it provides both confidentiality and data integrity, protecting against both eavesdropping and tampering.</p>
                            </div>
                        `,
                        image: 'https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop'
                    }
                ],
                codeExamples: [
                    {
                        title: 'Lab: Compare ECB vs CBC Encryption using OpenSSL',
                        language: 'bash',
                        code: `# --- Lab Task ---
# We will use a simple bitmap image (PBM) to visualize the weakness of ECB.
# A PBM file with a simple pattern will be created.

# Step 1: Create a patterned PBM image file
# This creates a 128x128 image with black and white stripes
echo "P1 128 128" > pattern.pbm
for i in {1..128}; do
    for j in {1..128}; do
        if [ $((i/16 % 2)) -eq 0 ]; then echo -n "0 "; else echo -n "1 "; fi
    done
    echo ""
done >> pattern.pbm
echo "Created pattern.pbm"

# Step 2: Encrypt using ECB mode (note: patterns will be preserved)
# We need a 16-byte key and IV (for CBC). Let's define them.
KEY='0123456789abcdef0123456789abcdef' # 128-bit key in hex
IV='fedcba9876543210fedcba9876543210'  # 128-bit IV in hex
openssl enc -aes-128-ecb -nosalt -nopad -in pattern.pbm -out ecb_encrypted.pbm -K $KEY
echo "Encrypted with ECB. The header needs to be restored to view it."
(echo "P1 128 128"; tail -c +4 pattern.pbm | openssl enc -aes-128-ecb -nosalt -nopad -K $KEY) > ecb_final.pbm

# Step 3: Encrypt using CBC mode (patterns will be destroyed)
openssl enc -aes-128-cbc -nosalt -nopad -in pattern.pbm -out cbc_encrypted.pbm -K $KEY -iv $IV
echo "Encrypted with CBC. The header needs to be restored to view it."
(echo "P1 128 128"; tail -c +4 pattern.pbm | openssl enc -aes-128-cbc -nosalt -nopad -K $KEY -iv $IV) > cbc_final.pbm

# --- Observation ---
# Try to open 'ecb_final.pbm' and 'cbc_final.pbm' with an image viewer.
# You will see the original pattern in the ECB version, while the CBC version looks like random noise.
# This demonstrates why ECB is insecure.`
                    }
                ]
            },
            quiz: {
                passingScore: 75,
                questions: [
                    {
                        id: 1,
                        question: "What is the primary security weakness of ECB mode?",
                        options: [
                            "It is too slow.",
                            "It requires a very long key.",
                            "Identical plaintext blocks produce identical ciphertext blocks.",
                            "It only works with AES."
                        ],
                        correct: 2,
                        explanation: "ECB's main flaw is that it is deterministic, meaning identical plaintext blocks encrypt to identical ciphertext blocks, which leaks information about patterns in the data."
                    },
                    {
                        id: 2,
                        question: "What is the purpose of the Initialization Vector (IV) in CBC mode?",
                        options: [
                            "To act as the encryption key.",
                            "To pad the final block of data.",
                            "To ensure that encrypting the same message twice produces different ciphertexts.",
                            "To authenticate the message."
                        ],
                        correct: 2,
                        explanation: "The IV introduces randomness into the first block of encryption, which then cascades through the rest of the blocks, ensuring that identical plaintexts produce unique ciphertexts."
                    },
                    {
                        id: 3,
                        question: "Which mode of operation provides both confidentiality and authentication (integrity)?",
                        options: [
                            "ECB",
                            "CBC",
                            "CTR",
                            "GCM"
                        ],
                        correct: 3,
                        explanation: "Galois/Counter Mode (GCM) is an AEAD (Authenticated Encryption with Associated Data) mode that efficiently combines encryption for confidentiality with an authentication tag for integrity."
                    }
                ]
            }
        },
        {
            id: 'lesson-5',
            title: 'Data Encryption Standard (DES, 3DES)',
            duration: '60 min',
            objectives: [
                'Understand the history and structure of the Data Encryption Standard (DES)',
                'Identify the primary weakness of DES (key size)',
                'Explain how Triple DES (3DES) improves upon DES',
                'Recognize why both DES and 3DES are now considered outdated'
            ],
            content: {
                overview: 'The Data Encryption Standard (DES) was once a cornerstone of modern cryptography. This lesson examines the history of DES, its critical vulnerabilities, the development of its successor Triple DES (3DES), and the reasons why both are now deprecated in favor of more secure standards like AES.',
                sections: [
                    {
                        title: 'The Data Encryption Standard (DES)',
                        content: `
                            <p>DES was developed by IBM in the 1970s and adopted as a U.S. government standard in 1977. It is a symmetric block cipher that operates on 64-bit blocks of data.</p>
                            
                            <h3>Structure:</h3>
                            <p>DES is based on a Feistel network structure, which involves splitting data into two halves and applying a series of repetitive operations (rounds) to them. DES uses 16 rounds of substitution and permutation.</p>

                            <h3>The Critical Weakness: Key Size</h3>
                            <p>The most significant flaw of DES is its small key size: <strong>56 bits</strong>. In the 1970s, this was considered sufficient. However, with the rapid advancement of computing power, a 56-bit key is now vulnerable to a brute-force attack, where an attacker simply tries every possible key. In 1998, the Electronic Frontier Foundation (EFF) built a machine called "Deep Crack" that could break a DES key in under 3 days.</p>
                        `,
                        image: 'https://images.unsplash.com/photo-1618625232402-0e9602561914?w=800&h=400&fit=crop'
                    },
                    {
                        title: 'Triple DES (3DES)',
                        content: `
                            <p>To extend the life of DES in the face of growing computational power, Triple DES (3DES or TDEA) was introduced. It applies the DES algorithm three times in a row to each data block.</p>
                            
                            <h3>How It Works:</h3>
                            <p>The most common method is using an Encrypt-Decrypt-Encrypt (EDE) sequence with two or three distinct keys:</p>
                            <ul>
                                <li><strong>3TDEA (3-key 3DES):</strong> Uses three independent keys (K1, K2, K3). Effective key strength is 112 bits.</li>
                                <li><strong>2TDEA (2-key 3DES):</strong> Uses two keys, with K1 used for the first and third operations (K1, K2, K1). Effective key strength is 80 bits.</li>
                            </ul>

                            <h3>Why 3DES is Outdated:</h3>
                            <ul>
                                <li><strong>Slow Performance:</strong> Applying DES three times makes it significantly slower than modern ciphers like AES.</li>
                                <li><strong>Small Block Size:</strong> 3DES still uses a 64-bit block size, which can be problematic in some applications (e.g., the "Sweet32" attack).</li>
                            </ul>

                            <div class="info-box warning">
                                <div class="info-box-header">
                                    <i class="fas fa-exclamation-triangle"></i>
                                    <strong>Deprecated Standard</strong>
                                </div>
                                <p>NIST (National Institute of Standards and Technology) has officially deprecated 3DES for all new applications since 2023. It should only be used to decrypt legacy data. All new systems must use AES.</p>
                            </div>
                        `,
                        image: 'https://images.unsplash.com/photo-1516110833944-766d35a50730?w=800&h=400&fit=crop'
                    }
                ],
                codeExamples: [
                    {
                        title: 'Lab: Encrypt Text using DES in OpenSSL',
                        language: 'bash',
                        code: `# --- Lab Task ---
# This lab demonstrates DES encryption for educational purposes only.
# Do NOT use DES for any real-world security.

# Step 1: Create a simple text string
PLAINTEXT="This is a weak encryption."

# Step 2: Encrypt using DES in ECB mode
# OpenSSL requires the key to be provided in hex format.
# A DES key is 8 bytes (64 bits), but only 56 are used.
KEY_HEX='0123456789abcdef'
echo "Encrypting with DES (ECB mode)..."
ENCRYPTED=$(echo -n "$PLAINTEXT" | openssl enc -des-ecb -nopad -K $KEY_HEX)

# Step 3: Base64 encode for printing
ENCRYPTED_B64=$(echo -n "$ENCRYPTED" | base64)
echo "Encrypted (Base64): $ENCRYPTED_B64"

# Step 4: Decrypt the text
DECRYPTED=$(echo -n "$ENCRYPTED" | openssl enc -d -des-ecb -nopad -K $KEY_HEX)
echo "Decrypted: $DECRYPTED"

# --- Triple DES (3DES) Example ---
# Uses the -des-ede3 command
echo -e "\\nEncrypting with 3DES..."
KEY_3DES_HEX='0123456789abcdef0123456789abcdef0123456789abcdef'
ENCRYPTED_3DES_B64=$(echo -n "$PLAINTEXT" | openssl enc -des-ede3 -nopad -K $KEY_3DES_HEX | base64)
echo "Encrypted 3DES (Base64): $ENCRYPTED_3DES_B64"`
                    }
                ]
            },
            quiz: {
                passingScore: 75,
                questions: [
                    {
                        id: 1,
                        question: "What is the primary reason DES is considered insecure today?",
                        options: [
                            "It has a mathematical flaw in its algorithm.",
                            "Its 56-bit key size is too short and vulnerable to brute-force attacks.",
                            "It only works on 32-bit computers.",
                            "It was never publicly reviewed."
                        ],
                        correct: 1,
                        explanation: "The 56-bit key space of DES is too small to withstand modern computing power, making it feasible to break by trying all possible keys (brute-force)."
                    },
                    {
                        id: 2,
                        question: "How does Triple DES (3DES) enhance the security of DES?",
                        options: [
                            "By increasing the block size to 128 bits.",
                            "By applying the DES algorithm three times with different keys.",
                            "By adding more rounds to the DES algorithm.",
                            "By using a completely new mathematical structure."
                        ],
                        correct: 1,
                        explanation: "3DES increases the effective key length by running the DES algorithm three times, typically in an Encrypt-Decrypt-Encrypt sequence, making it more resistant to brute-force attacks."
                    },
                    {
                        id: 3,
                        question: "Why is 3DES no longer recommended for new applications?",
                        options: [
                            "It is vulnerable to brute-force attacks.",
                            "It is much slower than modern alternatives like AES.",
                            "It was never standardized.",
                            "It can only be used for decryption."
                        ],
                        correct: 1,
                        explanation: "While more secure than DES, 3DES is computationally intensive and much slower than AES. Its 64-bit block size also makes it vulnerable to certain attacks like 'Sweet32' when encrypting large amounts of data."
                    }
                ]
            }
        },
        {
            id: 'lesson-6',
            title: 'Advanced Encryption Standard (AES)',
            duration: '75 min',
            objectives: [
                'Understand the origin and purpose of the Advanced Encryption Standard (AES)',
                'Describe the structure of AES, including rounds and key sizes',
                'Differentiate between AES-128, AES-192, and AES-256',
                'Recognize AES as the current industry standard for symmetric encryption'
            ],
            content: {
                overview: 'The Advanced Encryption Standard (AES) is the de facto global standard for symmetric data encryption. This lesson covers its history, how it works, its different key sizes, and why it is trusted by governments and industries worldwide for securing sensitive information.',
                sections: [
                    {
                        title: 'The Rise of AES',
                        content: `
                            <p>In 1997, the U.S. National Institute of Standards and Technology (NIST) initiated a process to find a replacement for the aging DES algorithm. The process was a public competition to develop a new, secure, and efficient encryption standard.</p>
                            
                            <h3>The Rijndael Algorithm:</h3>
                            <p>The winning algorithm was called <strong>Rijndael</strong>, created by Belgian cryptographers Joan Daemen and Vincent Rijmen. In 2001, it was officially adopted as the Advanced Encryption Standard (AES).</p>

                            <h3>Key Features:</h3>
                            <ul>
                                <li><strong>Block Size:</strong> Fixed block size of 128 bits.</li>
                                <li><strong>Key Sizes:</strong> Supports key lengths of 128, 192, or 256 bits.</li>
                                <li><strong>Structure:</strong> It is based on a "substitution-permutation network," which is faster and more efficient in software and hardware than the Feistel network of DES.</li>
                                <li><strong>Security:</strong> To date, there are no known practical attacks that would allow someone to read AES-encrypted data without knowing the key.</li>
                            </ul>
                        `,
                        image: 'https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?w=800&h=400&fit=crop'
                    },
                    {
                        title: 'How AES Works: Rounds and Key Sizes',
                        content: `
                            <p>AES operates on a 4x4 matrix of bytes called the "state." It processes the entire 128-bit data block in each round through a series of mathematical transformations.</p>
                            
                            <h3>The Number of Rounds:</h3>
                            <p>The strength of AES comes from applying simple, reversible steps multiple times. The number of rounds depends on the key size:</p>
                            <ul>
                                <li><strong>AES-128:</strong> 10 rounds</li>
                                <li><strong>AES-192:</strong> 12 rounds</li>
                                <li><strong>AES-256:</strong> 14 rounds</li>
                            </ul>

                            <h3>Steps in Each Round:</h3>
                            <p>Each round (except the last) consists of four main steps:</p>
                            <ol>
                                <li><strong>SubBytes:</strong> A non-linear substitution step where each byte is replaced with another according to a lookup table (the Rijndael S-box).</li>
                                <li><strong>ShiftRows:</strong> A transposition step where the last three rows of the state are shifted cyclically a certain number of steps.</li>
                                <li><strong>MixColumns:</strong> A mixing operation which operates on the columns of the state, combining the four bytes in each column.</li>
                                <li><strong>AddRoundKey:</strong> Each byte of the state is combined with a round key derived from the main encryption key.</li>
                            </ol>
                            
                            <div class="info-box tip">
                                <div class="info-box-header">
                                    <i class="fas fa-lightbulb"></i>
                                    <strong>Why More Rounds for Longer Keys?</strong>
                                </div>
                                <p>Longer keys require more rounds to ensure the entire key influences the entire ciphertext, a property called "diffusion." This prevents attacks that target parts of the key separately.</p>
                            </div>
                        `,
                        image: 'https://images.unsplash.com/photo-1614064548237-0965305021b4?w=800&h=400&fit=crop'
                    }
                ],
                codeExamples: [
                    {
                        title: 'Lab: File Encryption with AES',
                        language: 'bash',
                        code: `# --- Lab Task ---
# Use OpenSSL to encrypt and decrypt a file using the modern and secure AES-256-GCM.
# GCM mode provides both confidentiality and authentication.

# Step 1: Create a sensitive data file
echo "Account Number: 1234-5678-9012-3456" > sensitive_data.txt
echo "Password: MySuperSecretPassword123!" >> sensitive_data.txt
echo "Original data:"
cat sensitive_data.txt

# Step 2: Encrypt the file with AES-256-GCM
# We will use a password to derive the key.
# The IV (nonce) and authentication tag will be stored in the output file by OpenSSL.
echo -e "\\nEncrypting with AES-256-GCM..."
openssl enc -aes-256-gcm -in sensitive_data.txt -out encrypted_data.enc
echo "Encryption complete."

# Step 3: Attempt to view the encrypted file (it will be unreadable)
echo -e "\\nEncrypted file content (partial):"
head -c 50 encrypted_data.enc; echo

# Step 4: Decrypt the file
# You must use the same password.
echo -e "\\nDecrypting the file..."
openssl enc -d -aes-256-gcm -in encrypted_data.enc -out decrypted_data.txt

# Step 5: Verify the content is restored
echo "Decryption complete. Verifying content:"
cat decrypted_data.txt

# Step 6: Test integrity - corrupt the encrypted file and try to decrypt
echo "corrupt" >> encrypted_data.enc
echo -e "\\nAttempting to decrypt corrupted file..."
openssl enc -d -aes-256-gcm -in encrypted_data.enc -out failed_decryption.txt
# This command will fail with a "bad decrypt" error, proving GCM's integrity check worked.`
                    }
                ]
            },
            quiz: {
                passingScore: 75,
                questions: [
                    {
                        id: 1,
                        question: "What algorithm was selected to become the Advanced Encryption Standard (AES)?",
                        options: [
                            "Blowfish",
                            "Serpent",
                            "Rijndael",
                            "Twofish"
                        ],
                        correct: 2,
                        explanation: "The Rijndael algorithm, developed by Joan Daemen and Vincent Rijmen, was the winner of the NIST competition and was standardized as AES."
                    },
                    {
                        id: 2,
                        question: "Which of the following is NOT a valid key size for AES?",
                        options: [
                            "128 bits",
                            "192 bits",
                            "256 bits",
                            "512 bits"
                        ],
                        correct: 3,
                        explanation: "The AES standard specifies three possible key sizes: 128, 192, and 256 bits."
                    },
                    {
                        id: 3,
                        question: "How many rounds does AES-256 perform?",
                        options: [
                            "10",
                            "12",
                            "14",
                            "16"
                        ],
                        correct: 2,
                        explanation: "AES-256 uses a 256-bit key and performs 14 rounds of encryption to ensure thorough diffusion and confusion."
                    },
                    {
                        id: 4,
                        question: "AES is what type of cipher?",
                        options: [
                            "Stream cipher",
                            "Asymmetric cipher",
                            "Substitution-permutation network block cipher",
                            "Feistel network block cipher"
                        ],
                        correct: 2,
                        explanation: "Unlike DES, which uses a Feistel network, AES is a substitution-permutation network (SPN), which allows for more efficient implementation in software and hardware."
                    }
                ]
            }
        },
        {
            id: 'lesson-7',
            title: 'Asymmetric Cryptography Basics',
            duration: '60 min',
            objectives: [
                'Define asymmetric cryptography and its core principles',
                'Understand the concept of a public/private key pair',
                'Explain how public and private keys are used for encryption and digital signatures',
                'Recognize the main use cases for asymmetric cryptography'
            ],
            content: {
                overview: 'Asymmetric cryptography, also known as public-key cryptography, revolutionized secure communication by using a pair of keys instead of a single shared key. This lesson introduces the fundamental concepts of public and private keys and how they work together to provide confidentiality and authentication.',
                sections: [
                    {
                        title: 'The Key Pair: Public and Private Keys',
                        content: `
                            <p>Asymmetric cryptography uses a mathematically linked pair of keys for each user: a public key and a private key.</p>
                            
                            <ul>
                                <li><strong>Public Key:</strong> This key can be shared freely with anyone. It is used to encrypt data or to verify a digital signature.</li>
                                <li><strong>Private Key:</strong> This key must be kept secret and secure by its owner. It is used to decrypt data that was encrypted with the corresponding public key, or to create a digital signature.</li>
                            </ul>

                            <h3>The Core Principle:</h3>
                            <p>What is encrypted with one key in the pair can <strong>only</strong> be decrypted by the other key. It is computationally infeasible to derive the private key from the public key.</p>
                            
                            <div class="info-box note">
                                <div class="info-box-header">
                                    <i class="fas fa-info-circle"></i>
                                    <strong>Analogy: A Mailbox with Two Slots</strong>
                                </div>
                                <p>Think of your public key as the address and mail slot of your personal mailbox. Anyone can use it to drop a letter (encrypted message) inside. However, only you have the unique private key to open the mailbox and read the letters.</p>
                            </div>
                        `,
                        image: 'https://images.unsplash.com/photo-1599058917212-d750089bc074?w=800&h=400&fit=crop'
                    },
                    {
                        title: 'Use Cases: Confidentiality and Digital Signatures',
                        content: `
                            <p>The public/private key pair can be used in two primary ways:</p>
                            
                            <h3>1. Confidentiality (Encryption):</h3>
                            <p>To send a secret message to someone, you use <strong>their public key</strong> to encrypt it. Because only they possess the corresponding private key, only they can decrypt and read the message.</p>
                            <ul>
                                <li><strong>Sender:</strong> Encrypts message with Receiver's PUBLIC key.</li>
                                <li><strong>Receiver:</strong> Decrypts message with their own PRIVATE key.</li>
                            </ul>

                            <h3>2. Authenticity & Non-Repudiation (Digital Signatures):</h3>
                            <p>To prove that a message came from you and has not been altered, you create a digital signature using <strong>your private key</strong>. Anyone can then use your public key to verify the signature.</p>
                            <ul>
                                <li><strong>Signer:</strong> Creates signature with their own PRIVATE key.</li>
                                <li><strong>Verifier:</strong> Verifies signature with Signer's PUBLIC key.</li>
                            </ul>

                            <h3>Hybrid Encryption:</h3>
                            <p>Asymmetric encryption is much slower than symmetric encryption. In practice, systems use a hybrid approach: asymmetric encryption is used to securely exchange a temporary symmetric key (a "session key"), and then that fast symmetric key is used to encrypt the bulk of the data.</p>
                        `,
                        image: 'https://images.unsplash.com/photo-1555949963-aa79dcee981c?w=800&h=400&fit=crop'
                    }
                ],
                codeExamples: [
                    {
                        title: 'Lab: Generate RSA Key Pair and Encrypt a Message',
                        language: 'bash',
                        code: `# --- Lab Task ---
# Use OpenSSL to generate an RSA key pair and perform a simple encryption/decryption.

# Step 1: Generate a private key
# This command creates a 2048-bit RSA private key.
openssl genpkey -algorithm RSA -out private_key.pem -pkeyopt rsa_keygen_bits:2048
echo "Generated private_key.pem"

# Step 2: Extract the public key from the private key
# The public key can be derived from the private key, but not the other way around.
openssl rsa -pubout -in private_key.pem -out public_key.pem
echo "Extracted public_key.pem"

# Step 3: Create a secret message
echo "Asymmetric encryption is powerful." > secret.txt
echo "Original Message: $(cat secret.txt)"

# Step 4: Encrypt the message with the public key
# This is what someone would do to send you a secret message.
openssl pkeyutl -encrypt -inkey public_key.pem -pubin -in secret.txt -out encrypted_secret.bin
echo "Message encrypted with public key."

# Step 5: Decrypt the message with the private key
# Only you, the holder of the private key, can do this.
openssl pkeyutl -decrypt -inkey private_key.pem -in encrypted_secret.bin -out decrypted_secret.txt
echo "Message decrypted with private key."

# Step 6: Verify the content
echo "Decrypted Message: $(cat decrypted_secret.txt)"`
                    }
                ]
            },
            quiz: {
                passingScore: 75,
                questions: [
                    {
                        id: 1,
                        question: "In asymmetric cryptography, which key should be kept secret?",
                        options: [
                            "Public Key",
                            "Private Key",
                            "Shared Key",
                            "Session Key"
                        ],
                        correct: 1,
                        explanation: "The private key is the secret component of the key pair and must be protected by its owner. The public key is designed to be distributed freely."
                    },
                    {
                        id: 2,
                        question: "If Alice wants to send an encrypted message to Bob, which key does she use to encrypt it?",
                        options: [
                            "Alice's private key",
                            "Alice's public key",
                            "Bob's private key",
                            "Bob's public key"
                        ],
                        correct: 3,
                        explanation: "To ensure confidentiality, the sender (Alice) must encrypt the message with the recipient's (Bob's) public key. Only Bob can decrypt it with his corresponding private key."
                    },
                    {
                        id: 3,
                        question: "What is the primary disadvantage of asymmetric encryption compared to symmetric encryption?",
                        options: [
                            "It is less secure.",
                            "It is significantly slower.",
                            "The keys are shorter.",
                            "It cannot be used for digital signatures."
                        ],
                        correct: 1,
                        explanation: "The mathematical operations involved in asymmetric cryptography are much more computationally intensive, making it much slower than symmetric algorithms like AES. This is why it's often used in a hybrid model."
                    }
                ]
            }
        },
        {
            id: 'lesson-8',
            title: 'RSA Algorithm',
            duration: '75 min',
            objectives: [
                'Understand the mathematical foundation of the RSA algorithm',
                'Describe the steps involved in RSA key generation',
                'Explain the process of RSA encryption and decryption',
                'Learn how RSA is used to create digital signatures'
            ],
            content: {
                overview: 'Named after its inventors Rivest, Shamir, and Adleman, the RSA algorithm is the most widely used asymmetric cryptosystem. This lesson delves into the mathematics behind RSA, detailing how keys are generated and how they are used for both secure data transmission and digital signatures.',
                sections: [
                    {
                        title: 'RSA Key Generation',
                        content: `
                            <p>The security of RSA relies on the practical difficulty of factoring the product of two large prime numbers. The key generation process involves the following steps:</p>
                            
                            <ol>
                                <li><strong>Choose two large, distinct prime numbers, <code>p</code> and <code>q</code>.</strong> In practice, these primes are hundreds of digits long.</li>
                                <li><strong>Compute <code>n = p * q</code>.</strong> This value, <code>n</code>, is the modulus for both the public and private keys. Its length (in bits) is the key length (e.g., 2048 bits).</li>
                                <li><strong>Compute Euler's totient function: <code>φ(n) = (p-1) * (q-1)</code>.</strong> This value is kept secret.</li>
                                <li><strong>Choose an integer <code>e</code> (the public key exponent).</strong> <code>e</code> must be between 1 and <code>φ(n)</code> and be coprime to <code>φ(n)</code>. A common value for <code>e</code> is 65537.</li>
                                <li><strong>Compute <code>d</code> (the private key exponent).</strong> <code>d</code> is the modular multiplicative inverse of <code>e</code> modulo <code>φ(n)</code>. It satisfies the congruence relation <code>d * e ≡ 1 (mod φ(n))</code>.</li>
                            </ol>

                            <h3>The Resulting Keys:</h3>
                            <ul>
                                <li><strong>Public Key:</strong> The pair <code>(n, e)</code>.</li>
                                <li><strong>Private Key:</strong> The pair <code>(n, d)</code>.</li>
                            </ul>
                        `,
                        image: 'https://images.unsplash.com/photo-1635070045099-5a1835565551?w=800&h=400&fit=crop'
                    },
                    {
                        title: 'RSA Encryption, Decryption, and Signing',
                        content: `
                            <p>Once the keys are generated, the processes for encryption and decryption are mathematically straightforward, based on modular exponentiation.</p>
                            
                            <h3>Encryption:</h3>
                            <p>To encrypt a plaintext message <code>M</code> (represented as a number less than <code>n</code>), the sender uses the recipient's public key <code>(n, e)</code>. The ciphertext <code>C</code> is calculated as:</p>
                            <code>C = M^e mod n</code>

                            <h3>Decryption:</h3>
                            <p>The recipient uses their private key <code>(n, d)</code> to decrypt the ciphertext <code>C</code>. The original message <code>M</code> is recovered by:</p>
                            <code>M = C^d mod n</code>

                            <h3>Digital Signing:</h3>
                            <p>To sign a message hash <code>H</code>, the signer uses their own private key <code>(n, d)</code>. The signature <code>S</code> is:</p>
                            <code>S = H^d mod n</code>
                            <p>A verifier with the signer's public key <code>(n, e)</code> can then check the signature by calculating:</p>
                            <code>H' = S^e mod n</code>
                            <p>If <code>H'</code> equals the original hash <code>H</code>, the signature is valid.</p>
                            
                            <div class="info-box tip">
                                <div class="info-box-header">
                                    <i class="fas fa-lightbulb"></i>
                                    <strong>Padding is Crucial</strong>
                                </div>
                                <p>In real-world implementations, "textbook" RSA as described here is insecure. Messages must be padded using a secure padding scheme like OAEP for encryption or PSS for signatures to prevent various cryptographic attacks.</p>
                            </div>
                        `,
                        image: 'https://images.unsplash.com/photo-1555949963-aa79dcee981c?w=800&h=400&fit=crop'
                    }
                ],
                codeExamples: [
                    {
                        title: 'Lab: Create RSA Key and Test Encryption/Decryption',
                        language: 'bash',
                        code: `# --- Lab Task ---
# This lab repeats the previous lesson's key generation but focuses on the RSA specifics.

# Step 1: Generate a 2048-bit RSA private key
# The '-algorithm RSA' explicitly tells OpenSSL to use RSA.
openssl genpkey -algorithm RSA -out rsa_private.pem -pkeyopt rsa_keygen_bits:2048
echo "Generated rsa_private.pem"

# Step 2: Examine the key components (for educational purposes)
# This command shows the primes p, q, exponents e, d, and modulus n.
openssl rsa -in rsa_private.pem -text -noout
echo -e "\\nExamine the output above to see the mathematical components of the RSA key."

# Step 3: Extract the public key
openssl rsa -pubout -in rsa_private.pem -out rsa_public.pem
echo "Extracted rsa_public.pem"

# Step 4: Create a message file
echo "RSA is based on prime factorization." > rsa_message.txt
echo "Original: $(cat rsa_message.txt)"

# Step 5: Encrypt with the RSA public key
openssl pkeyutl -encrypt -inkey rsa_public.pem -pubin -in rsa_message.txt -out rsa_encrypted.bin
echo "Message encrypted."

# Step 6: Decrypt with the RSA private key
openssl pkeyutl -decrypt -inkey rsa_private.pem -in rsa_encrypted.bin -out rsa_decrypted.txt
echo "Message decrypted."
echo "Decrypted: $(cat rsa_decrypted.txt)"`
                    }
                ]
            },
            quiz: {
                passingScore: 75,
                questions: [
                    {
                        id: 1,
                        question: "The security of the RSA algorithm depends on the difficulty of what mathematical problem?",
                        options: [
                            "Modular exponentiation",
                            "Finding the modular multiplicative inverse",
                            "Factoring the product of two large prime numbers",
                            "Solving elliptic curve discrete logarithms"
                        ],
                        correct: 2,
                        explanation: "If an attacker could easily factor the public modulus 'n' back into its prime components 'p' and 'q', they could then compute the private exponent 'd'. The entire security of RSA rests on this being computationally infeasible."
                    },
                    {
                        id: 2,
                        question: "What does the RSA public key consist of?",
                        options: [
                            "Two prime numbers, p and q",
                            "The private exponent d and the modulus n",
                            "The public exponent e and the modulus n",
                            "The prime number p and the public exponent e"
                        ],
                        correct: 2,
                        explanation: "The public key is the pair of numbers (n, e), where n is the modulus and e is the public exponent. This is all that is needed to encrypt data."
                    },
                    {
                        id: 3,
                        question: "To create a digital signature with RSA, what does the signer use?",
                        options: [
                            "Their public key",
                            "The recipient's public key",
                            "Their private key",
                            "The recipient's private key"
                        ],
                        correct: 2,
                        explanation: "Creating a digital signature is an action that only the key owner can perform, so it requires the use of their secret private key."
                    }
                ]
            }
        },
        {
            id: 'lesson-9',
            title: 'Elliptic Curve Cryptography (ECC)',
            duration: '75 min',
            objectives: [
                'Understand the basic concept of elliptic curves in cryptography',
                'Recognize the main advantage of ECC over RSA (key size)',
                'Learn about the Elliptic Curve Discrete Logarithm Problem (ECDLP)',
                'Identify common applications of ECC'
            ],
            content: {
                overview: 'Elliptic Curve Cryptography (ECC) is a powerful and efficient alternative to RSA. This lesson introduces the high-level concepts of how ECC works, why it can provide the same level of security as RSA with much smaller keys, and where it is commonly used today.',
                sections: [
                    {
                        title: 'What is an Elliptic Curve?',
                        content: `
                            <p>In the context of cryptography, an elliptic curve is the set of points (x, y) that satisfy a specific mathematical equation. For cryptography, we consider curves over finite fields, which means the points on the curve are limited to a fixed range of integer coordinates.</p>
                            
                            <h3>Point Addition:</h3>
                            <p>A special property of elliptic curves is that you can define a "point addition" operation. If you take two points on the curve, P and Q, a line drawn through them will intersect the curve at a third point. Reflecting this point across the x-axis gives you the result, R = P + Q. This operation is the basis of ECC.</p>

                            <h3>Scalar Multiplication:</h3>
                            <p>We can extend point addition to scalar multiplication: <code>k * P = P + P + ... + P</code> (k times). This is easy to compute if you know <code>k</code> and <code>P</code>.</p>
                        `,
                        image: 'https://images.unsplash.com/photo-1621596131495-257a75b22e70?w=800&h=400&fit=crop'
                    },
                    {
                        title: 'The Advantage of ECC: Smaller Keys for Equal Security',
                        content: `
                            <p>The security of ECC is based on the <strong>Elliptic Curve Discrete Logarithm Problem (ECDLP)</strong>. This problem states that if you know the starting point <code>P</code> and the resulting point <code>R</code> from a scalar multiplication (where <code>R = k * P</code>), it is extremely difficult to find the scalar value <code>k</code>.</p>
                            
                            <h3>ECC vs. RSA:</h3>
                            <p>The ECDLP is believed to be a much harder mathematical problem than prime factorization (which RSA relies on). Because of this, ECC can achieve the same level of security as RSA but with significantly smaller key sizes.</p>
                            
                            <table>
                              <thead>
                                <tr>
                                  <th>ECC Key Size (bits)</th>
                                  <th>Comparable RSA Key Size (bits)</th>
                                  <th>Symmetric Key Size (bits)</th>
                                </tr>
                              </thead>
                              <tbody>
                                <tr>
                                  <td>256</td>
                                  <td>3072</td>
                                  <td>128</td>
                                </tr>
                                <tr>
                                  <td>384</td>
                                  <td>7680</td>
                                  <td>192</td>
                                </tr>
                                <tr>
                                  <td>521</td>
                                  <td>15360</td>
                                  <td>256</td>
                                </tr>
                              </tbody>
                            </table>
                            
                            <div class="info-box note">
                                <div class="info-box-header">
                                    <i class="fas fa-info-circle"></i>
                                    <strong>Why Smaller Keys Matter</strong>
                                </div>
                                <p>Smaller key sizes mean less storage, less bandwidth, and faster computations. This makes ECC ideal for mobile devices, IoT devices, and other resource-constrained environments.</p>
                            </div>

                            <h3>Applications of ECC:</h3>
                            <ul>
                                <li><strong>Cryptocurrencies:</strong> Bitcoin, Ethereum, and many others use ECC to generate wallet addresses and sign transactions.</li>
                                <li><strong>Secure Messaging:</strong> Apps like Signal and WhatsApp use ECC for end-to-end encryption.</li>
                                <li><strong>TLS/SSL:</strong> Modern web encryption (HTTPS) often uses ECC for its key exchange mechanism (ECDHE).</li>
                            </ul>
                        `,
                        image: 'https://images.unsplash.com/photo-1642150133240-33345d4d3d77?w=800&h=400&fit=crop'
                    }
                ],
                codeExamples: [
                    {
                        title: 'Lab: Generate ECC Keys using OpenSSL',
                        language: 'bash',
                        code: `# --- Lab Task ---
# Use OpenSSL to generate an Elliptic Curve key pair.

# Step 1: List available elliptic curves
# OpenSSL supports many standardized curves. 'prime256v1' is a common and secure choice.
openssl ecparam -list_curves
echo -e "\\nThe list above shows the many curves supported by OpenSSL."

# Step 2: Generate an ECC private key
# We will use the 'prime256v1' curve (equivalent to NIST P-256).
openssl ecparam -name prime256v1 -genkey -out ecc_private.pem
echo "Generated ECC private key using prime256v1."

# Step 3: Examine the key details
# You can see the private key value and the curve name.
openssl ec -in ecc_private.pem -text -noout

# Step 4: Extract the public key
openssl ec -in ecc_private.pem -pubout -out ecc_public.pem
echo -e "\\nExtracted ECC public key."

# Step 5: Compare file sizes
echo -e "\\nComparing key file sizes:"
ls -l rsa_private.pem ecc_private.pem
echo "Note how the ECC private key file is significantly smaller than the RSA 2048-bit key."`
                    }
                ]
            },
            quiz: {
                passingScore: 75,
                questions: [
                    {
                        id: 1,
                        question: "What is the primary advantage of Elliptic Curve Cryptography (ECC) over RSA?",
                        options: [
                            "It is an older, more tested algorithm.",
                            "It is easier to understand mathematically.",
                            "It provides the same level of security with smaller key sizes.",
                            "It can only be used for encryption."
                        ],
                        correct: 2,
                        explanation: "The main benefit of ECC is its efficiency. It can achieve an equivalent level of security to RSA with much smaller keys, saving computational power, storage, and bandwidth."
                    },
                    {
                        id: 2,
                        question: "The security of ECC is based on the difficulty of which problem?",
                        options: [
                            "The Prime Factorization Problem",
                            "The Elliptic Curve Discrete Logarithm Problem (ECDLP)",
                            "The Knapsack Problem",
                            "The Integer Congruence Problem"
                        ],
                        correct: 1,
                        explanation: "ECC's security relies on the hardness of the ECDLP: given a starting point P and a final point R (where R = k*P), it is computationally infeasible to find the integer k."
                    },
                    {
                        id: 3,
                        question: "A 256-bit ECC key is generally considered to be as secure as an RSA key of what size?",
                        options: [
                            "256 bits",
                            "1024 bits",
                            "2048 bits",
                            "3072 bits"
                        ],
                        correct: 3,
                        explanation: "Due to the hardness of the ECDLP, a 256-bit ECC key offers a level of security comparable to a 3072-bit RSA key."
                    }
                ]
            }
        },
        {
            id: 'lesson-10',
            title: 'Diffie-Hellman Key Exchange',
            duration: '60 min',
            objectives: [
                'Understand the purpose of a key exchange protocol',
                'Explain the steps of the Diffie-Hellman key exchange',
                'Recognize that Diffie-Hellman establishes a shared secret, but does not provide authentication on its own',
                'Learn about the role of Diffie-Hellman in modern protocols like TLS'
            ],
            content: {
                overview: 'How can two people who have never met agree on a secret key while communicating over an insecure channel? The Diffie-Hellman key exchange protocol brilliantly solves this problem. This lesson explains the steps of this foundational cryptographic protocol and its importance in securing modern communications.',
                sections: [
                    {
                        title: 'The Key Exchange Problem',
                        content: `
                            <p>Symmetric encryption (like AES) is very fast, but it requires both parties to have the same secret key. If Alice and Bob want to communicate securely, how can they agree on a key if their only communication channel is being monitored by an eavesdropper, Eve?</p>
                            <p>They can't simply send the key in plaintext. The Diffie-Hellman (DH) protocol allows them to collaboratively create a shared secret key without ever sending the key itself across the wire.</p>
                        `,
                        image: 'https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit=crop'
                    },
                    {
                        title: 'How Diffie-Hellman Works',
                        content: `
                            <p>The DH protocol is based on the difficulty of the discrete logarithm problem in modular arithmetic. It works as follows:</p>
                            
                            <ol>
                                <li><strong>Public Parameters:</strong> Alice and Bob agree, publicly, on two numbers: a large prime modulus <code>p</code> and a generator <code>g</code>. Eve, the eavesdropper, also knows these numbers.</li>
                                <li><strong>Private Keys:</strong> Alice secretly chooses a private number <code>a</code>, and Bob secretly chooses a private number <code>b</code>.</li>
                                <li><strong>Public Keys:</strong>
                                    <ul>
                                        <li>Alice computes her public key <code>A = g^a mod p</code> and sends it to Bob.</li>
                                        <li>Bob computes his public key <code>B = g^b mod p</code> and sends it to Alice.</li>
                                    </ul>
                                    Eve can see both <code>A</code> and <code>B</code> as they cross the network.
                                </li>
                                <li><strong>Shared Secret Calculation:</strong>
                                    <ul>
                                        <li>Alice takes Bob's public key <code>B</code> and computes the shared secret: <code>s = B^a mod p</code>.</li>
                                        <li>Bob takes Alice's public key <code>A</code> and computes the shared secret: <code>s = A^b mod p</code>.</li>
                                    </ul>
                                </li>
                            </ol>
                            <p>Both Alice and Bob arrive at the exact same secret number <code>s</code>, because <code>(g^b)^a mod p = (g^a)^b mod p</code>. Eve, who only knows <code>p, g, A, B</code>, cannot compute <code>s</code> because she does not know the secret exponents <code>a</code> or <code>b</code>.</p>
                            
                            <div class="info-box warning">
                                <div class="info-box-header">
                                    <i class="fas fa-exclamation-triangle"></i>
                                    <strong>Vulnerability to Man-in-the-Middle (MitM) Attacks</strong>
                                </div>
                                <p>Standard Diffie-Hellman does not authenticate the participants. An attacker, Mallory, could intercept the communication, establish a separate key with Alice and another with Bob, and relay messages between them, reading and modifying everything. This is why DH is almost always used with digital signatures or other forms of authentication.</p>
                            </div>
                        `,
                        image: 'https://images.unsplash.com/photo-1618335914360-a158657784b4?w=800&h=400&fit=crop'
                    }
                ],
                codeExamples: [
                    {
                        title: 'Lab: Perform Diffie-Hellman Exchange in Python',
                        language: 'python',
                        code: `# This script simulates the Diffie-Hellman key exchange.

# 1. Publicly agreed upon parameters
p = 23    # A small prime number for simplicity
g = 5     # A generator

print(f"Public Parameters: p={p}, g={g}\\n")

# 2. Alice's side
a = 6     # Alice's secret private key
A = pow(g, a, p)
print(f"Alice's private key (a): {a}")
print(f"Alice calculates her public key (A = g^a mod p): {A}")
print("Alice sends A to Bob.\\n")

# 3. Bob's side
b = 15    # Bob's secret private key
B = pow(g, b, p)
print(f"Bob's private key (b): {b}")
print(f"Bob calculates his public key (B = g^b mod p): {B}")
print("Bob sends B to Alice.\\n")

# --- An eavesdropper, Eve, would see A={A} and B={B} ---
print("--- Both parties now compute the shared secret ---")

# 4. Shared Secret Calculation
# Alice receives B from Bob
alice_shared_secret = pow(B, a, p)
print(f"Alice computes the shared secret (s = B^a mod p): {alice_shared_secret}")

# Bob receives A from Alice
bob_shared_secret = pow(A, b, p)
print(f"Bob computes the shared secret (s = A^b mod p): {bob_shared_secret}")

if alice_shared_secret == bob_shared_secret:
    print("\\nSuccess! Both Alice and Bob have the same secret key.")
else:
    print("\\nError! The keys do not match.")`
                    }
                ]
            },
            quiz: {
                passingScore: 75,
                questions: [
                    {
                        id: 1,
                        question: "What is the primary purpose of the Diffie-Hellman protocol?",
                        options: [
                            "To encrypt large files.",
                            "To create digital signatures.",
                            "To allow two parties to establish a shared secret over an insecure channel.",
                            "To hash passwords securely."
                        ],
                        correct: 2,
                        explanation: "Diffie-Hellman is a key agreement protocol, specifically designed to solve the problem of securely establishing a shared secret key for later use with symmetric encryption."
                    },
                    {
                        id: 2,
                        question: "In the Diffie-Hellman exchange, what information is considered public and can be seen by an eavesdropper?",
                        options: [
                            "Alice's private key 'a' and Bob's private key 'b'.",
                            "The final shared secret 's'.",
                            "The modulus 'p', generator 'g', Alice's public key 'A', and Bob's public key 'B'.",
                            "Only the modulus 'p'."
                        ],
                        correct: 2,
                        explanation: "The private keys are kept secret, but the parameters used for the exchange (p, g) and the calculated public keys (A, B) are transmitted over the insecure channel."
                    },
                    {
                        id: 3,
                        question: "What type of attack is the basic Diffie-Hellman protocol vulnerable to if not combined with an authentication mechanism?",
                        options: [
                            "Brute-force attack",
                            "Frequency analysis",
                            "Man-in-the-middle (MitM) attack",
                            "Side-channel attack"
                        ],
                        correct: 2,
                        explanation: "Without a way to authenticate that they are talking to the correct person, both parties are vulnerable to a man-in-the-middle attack where an adversary sits between them and establishes separate secret keys with each."
                    }
                ]
            }
        },
        {
            id: 'lesson-11',
            title: 'Hash Functions',
            duration: '60 min',
            objectives: [
                'Define a cryptographic hash function and its properties',
                'Differentiate between outdated hash functions (MD5, SHA-1) and secure ones (SHA-2, SHA-3)',
                'Understand the concept of a hash collision',
                'Identify common use cases for hash functions, such as data integrity'
            ],
            content: {
                overview: 'A cryptographic hash function is a one-way mathematical algorithm that maps data of any size to a fixed-size string of characters. This lesson explores the essential properties of hash functions, the evolution from insecure to secure algorithms, and their critical role in ensuring data integrity.',
                sections: [
                    {
                        title: 'Properties of a Cryptographic Hash Function',
                        content: `
                            <p>A hash function acts like a unique fingerprint for digital data. To be cryptographically secure, it must have the following properties:</p>
                            
                            <ul>
                                <li><strong>Deterministic:</strong> The same input message will always produce the exact same output hash.</li>
                                <li><strong>One-way (Pre-image Resistance):</strong> It should be computationally infeasible to find the original input message given only its output hash.</li>
                                <li><strong>Second Pre-image Resistance:</strong> Given an input M1, it should be infeasible to find a different input M2 such that hash(M1) = hash(M2).</li>
                                <li><strong>Collision Resistance:</strong> It should be extremely difficult to find two different input messages that produce the same output hash.</li>
                                <li><strong>Avalanche Effect:</strong> A tiny change in the input message (e.g., changing a single bit) should produce a drastically different output hash.</li>
                            </ul>
                        `,
                        image: 'https://images.unsplash.com/photo-1599837568392-2313d552654c?w=800&h=400&fit=crop'
                    },
                    {
                        title: 'The Evolution of Hash Algorithms',
                        content: `
                            <p>Over time, vulnerabilities have been discovered in older hash functions, leading to the development of stronger replacements.</p>
                            
                            <h3>Outdated/Broken Algorithms:</h3>
                            <ul>
                                <li><strong>MD5 (Message Digest 5):</strong> Produces a 128-bit hash. It is severely broken and should not be used for security purposes. Collisions can be generated in seconds. Its only valid use today is as a non-cryptographic checksum.</li>
                                <li><strong>SHA-1 (Secure Hash Algorithm 1):</strong> Produces a 160-bit hash. It is also considered broken. In 2017, a practical collision attack was demonstrated. All major browsers and operating systems no longer trust SHA-1 certificates.</li>
                            </ul>

                            <h3>Secure Modern Algorithms:</h3>
                            <ul>
                                <li><strong>SHA-2 Family:</strong> Includes SHA-224, SHA-256, SHA-384, and SHA-512. SHA-256 is the most widely used hash function today, used in everything from code signing to cryptocurrencies.</li>
                                <li><strong>SHA-3 Family:</strong> A result of a separate NIST competition, SHA-3 has a different internal structure (a "sponge construction") than SHA-2, making it a good alternative if a major flaw were ever found in SHA-2.</li>
                            </ul>
                            
                            <div class="info-box warning">
                                <div class="info-box-header">
                                    <i class="fas fa-exclamation-triangle"></i>
                                    <strong>Always Use Secure Algorithms</strong>
                                </div>
                                <p>For any new application requiring a hash function, you should use a member of the SHA-2 or SHA-3 family. SHA-256 is a safe, standard choice.</p>
                            </div>
                        `,
                        image: 'https://images.unsplash.com/photo-1544256718-3bcf237f3974?w=800&h=400&fit=crop'
                    }
                ],
                codeExamples: [
                    {
                        title: 'Lab: Generate File Hash with sha256sum',
                        language: 'bash',
                        code: `# --- Lab Task ---
# Use the sha256sum command-line tool to verify file integrity.

# Step 1: Create a file with some content
echo "This is a test file for hashing." > my_document.txt
echo "File content: $(cat my_document.txt)"

# Step 2: Calculate the SHA-256 hash of the file
HASH_ORIGINAL=$(sha256sum my_document.txt)
echo "Original SHA-256 Hash: $HASH_ORIGINAL"

# Step 3: Simulate file transmission or storage
# Let's save the hash to a separate file, as is common practice.
sha256sum my_document.txt > my_document.sha256

# Step 4: Verify the integrity
# The '-c' flag checks the file against its corresponding hash file.
echo -e "\\nVerifying the file against its stored hash..."
sha256sum -c my_document.sha256

# Step 5: Modify the file slightly (tamper with it)
echo "An extra line is added." >> my_document.txt
echo -e "\\nFile has been modified. New content: $(cat my_document.txt)"

# Step 6: Try to verify the tampered file
echo "Verifying the modified file..."
sha256sum -c my_document.sha256
# This command will now report a FAILED verification, proving the tampering was detected.`
                    }
                ]
            },
            quiz: {
                passingScore: 75,
                questions: [
                    {
                        id: 1,
                        question: "What is the primary purpose of a cryptographic hash function?",
                        options: [
                            "To encrypt data so it cannot be read.",
                            "To create a fixed-size, unique fingerprint of data to verify its integrity.",
                            "To exchange secret keys securely.",
                            "To compress large files."
                        ],
                        correct: 1,
                        explanation: "Hash functions are primarily used to ensure data integrity. By comparing the hash of a received file with the original hash, you can verify that the file has not been altered."
                    },
                    {
                        id: 2,
                        question: "What is a hash collision?",
                        options: [
                            "When a hash function produces an error.",
                            "When two different inputs produce the same output hash.",
                            "When a hash output is the same as the input.",
                            "When the hash function is too slow."
                        ],
                        correct: 1,
                        explanation: "A collision occurs when two distinct pieces of data result in the same hash value. For a secure hash function, finding such a collision should be computationally infeasible."
                    },
                    {
                        id: 3,
                        question: "Which of the following hash algorithms is still considered secure for use today?",
                        options: [
                            "MD5",
                            "SHA-1",
                            "SHA-256",
                            "LANMAN"
                        ],
                        correct: 2,
                        explanation: "SHA-256 is part of the SHA-2 family and is the current industry standard for hashing. MD5 and SHA-1 are considered broken and should not be used for security."
                    }
                ]
            }
        },
        {
            id: 'lesson-12',
            title: 'Message Authentication Codes (MAC & HMAC)',
            duration: '60 min',
            objectives: [
                'Define a Message Authentication Code (MAC) and its purpose',
                'Understand how a MAC provides both integrity and authenticity',
                'Explain how HMAC (Hash-based MAC) is constructed',
                'Differentiate between a MAC and a simple hash'
            ],
            content: {
                overview: 'While a hash function can guarantee data integrity, it doesn\'t prove who created the hash. A Message Authentication Code (MAC) solves this by combining a hash function with a secret key, providing both data integrity and authenticity. This lesson covers the concept of MACs and the most common implementation, HMAC.',
                sections: [
                    {
                        title: 'What is a Message Authentication Code (MAC)?',
                        content: `
                            <p>A MAC is a short piece of information used to authenticate a message. It is a cryptographic checksum generated using a secret key. To verify a message, the receiver uses the same secret key to independently compute the MAC and compares it to the one sent with the message.</p>
                            
                            <h3>Goals of a MAC:</h3>
                            <ul>
                                <li><strong>Integrity:</strong> A MAC ensures the message has not been altered. If even one bit of the message changes, the recomputed MAC will not match the original.</li>
                                <li><strong>Authenticity:</strong> Because the MAC is generated with a secret key known only to the sender and receiver, it confirms that the message originated from a party who possesses the key.</li>
                            </ul>
                            
                            <div class="info-box note">
                                <div class="info-box-header">
                                    <i class="fas fa-info-circle"></i>
                                    <strong>Hash vs. MAC</strong>
                                </div>
                                <p>A simple hash provides integrity but not authenticity. Anyone can compute a hash for a message. A MAC requires a secret key, so only parties with the key can create or verify the tag, providing authenticity.</p>
                            </div>
                        `,
                        image: 'https://images.unsplash.com/photo-1550751827-4138d04d4051?w=800&h=400&fit=crop'
                    },
                    {
                        title: 'HMAC: Hash-based Message Authentication Code',
                        content: `
                            <p>HMAC is a specific and standardized method for creating a MAC using any cryptographic hash function (like SHA-256). It is highly secure and efficient.</p>
                            
                            <h3>How HMAC Works:</h3>
                            <p>HMAC doesn't just prepend or append the key to the message before hashing. It uses a more complex construction involving two hashing steps to protect against certain attacks (like length-extension attacks).</p>
                            <ol>
                                <li>The secret key is padded to match the block size of the hash function and XORed with an inner padding constant (<code>ipad</code>).</li>
                                <li>The result is prepended to the message, and the whole thing is hashed.</li>
                                <li>The secret key is padded again and XORed with an outer padding constant (<code>opad</code>).</li>
                                <li>The result is prepended to the hash from step 2, and this is hashed a final time to produce the HMAC.</li>
                            </ol>
                            <p>The standard construction is: <code>HMAC(K, m) = H((K' ⊕ opad) || H((K' ⊕ ipad) || m))</code></p>
                            
                            <h3>Usage:</h3>
                            <p>The resulting HMAC tag is sent along with the message. The receiver, who has the same secret key, performs the exact same calculation on the received message. If the tags match, the message is authentic and has not been tampered with.</p>
                        `,
                        image: 'https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop'
                    }
                ],
                codeExamples: [
                    {
                        title: 'Lab: Create an HMAC using Python',
                        language: 'python',
                        code: `import hmac
import hashlib

# --- Lab Task ---
# 1. Define a secret key and a message.
# 2. Create an HMAC-SHA256 tag for the message.
# 3. Simulate a receiver verifying the tag.
# 4. Modify the message and show that verification fails.

# Shared secret key (must be bytes)
secret_key = b'my-super-secret-key-123'

# Original message (must be bytes)
message = b'This is the message to authenticate.'

# --- Sender Side ---
# Create the HMAC object
h = hmac.new(secret_key, message, hashlib.sha256)

# Get the HMAC tag in hexadecimal format
tag = h.hexdigest()

print(f"Original Message: {message.decode()}")
print(f"Secret Key: {secret_key.decode()}")
print(f"Generated HMAC-SHA256 Tag: {tag}\\n")

# --- Receiver Side ---
# Receiver has the same key and receives the message and tag
received_message = message
received_tag = tag

# Verify the tag
verifier = hmac.new(secret_key, received_message, hashlib.sha256)
try:
    verifier.hexdigest() == received_tag
    print("Verification Successful: The message is authentic and has not been tampered with.")
except Exception as e:
    print(f"Verification Failed: {e}")

# --- Tampering Simulation ---
tampered_message = b'This is the message to NOT authenticate.'
print(f"\\nTampered Message: {tampered_message.decode()}")
tampered_verifier = hmac.new(secret_key, tampered_message, hashlib.sha256)

if tampered_verifier.hexdigest() == received_tag:
    print("Verification Succeeded (ERROR: This should not happen!)")
else:
    print("Verification Failed: The MAC does not match. The message was altered.")`
                    }
                ]
            },
            quiz: {
                passingScore: 75,
                questions: [
                    {
                        id: 1,
                        question: "A MAC provides which two security services?",
                        options: [
                            "Confidentiality and Integrity",
                            "Integrity and Authenticity",
                            "Authenticity and Non-repudiation",
                            "Confidentiality and Availability"
                        ],
                        correct: 1,
                        explanation: "A MAC verifies that a message has not been altered (integrity) and that it came from someone who possesses the secret key (authenticity)."
                    },
                    {
                        id: 2,
                        question: "What is the key difference between a cryptographic hash and a MAC?",
                        options: [
                            "A MAC is faster than a hash.",
                            "A MAC uses a secret key, while a hash does not.",
                            "A MAC produces a longer output.",
                            "A hash can be reversed, but a MAC cannot."
                        ],
                        correct: 1,
                        explanation: "The use of a shared secret key is the defining feature of a MAC. This key is what provides the authenticity guarantee that is absent from a simple hash."
                    },
                    {
                        id: 3,
                        question: "What does HMAC stand for?",
                        options: [
                            "Hashed Message Authentication Code",
                            "Hash-based Message Authentication Code",
                            "Hexadecimal Message Authentication Code",
                            "Hypertext Message Authentication Code"
                        ],
                        correct: 1,
                        explanation: "HMAC stands for Hash-based Message Authentication Code, indicating that it is a specific construction for a MAC that uses a cryptographic hash function like SHA-256 as its core component."
                    }
                ]
            }
        },
        {
            id: 'lesson-13',
            title: 'Digital Signatures',
            duration: '75 min',
            objectives: [
                'Define a digital signature and its purpose',
                'Understand the three properties of a digital signature: authenticity, integrity, and non-repudiation',
                'Explain the process of creating and verifying a digital signature',
                'Differentiate between signing and encryption'
            ],
            content: {
                overview: 'A digital signature is the electronic equivalent of a handwritten signature, but with far stronger security properties. It uses public-key cryptography to provide assurance about a message\'s origin and integrity. This lesson explains how digital signatures work and why they are a cornerstone of modern secure communication.',
                sections: [
                    {
                        title: 'Properties of a Digital Signature',
                        content: `
                            <p>A digital signature is a mathematical scheme for demonstrating the authenticity of a digital message or document. A valid digital signature gives a recipient very high confidence that the message was created by a known sender (authenticity), that it was not altered in transit (integrity), and that the sender cannot deny having sent it (non-repudiation).</p>
                            
                            <h3>Key Properties:</h3>
                            <ul>
                                <li><strong>Authenticity:</strong> Verifying the signature proves that it was created by the owner of the corresponding private key.</li>
                                <li><strong>Integrity:</strong> The signature is based on the content of the message. If the message changes, the signature will no longer verify, proving the message has been tampered with.</li>
                                <li><strong>Non-repudiation:</strong> Because only the owner has the private key, they cannot later claim they did not sign the message. This is a legally important property.</li>
                            </ul>
                        `,
                        image: 'https://images.unsplash.com/photo-1589998059171-988d887df646?w=800&h=400&fit=crop'
                    },
                    {
                        title: 'How Digital Signatures Work: Signing and Verification',
                        content: `
                            <p>Digital signatures use asymmetric cryptography, but the roles of the keys are reversed compared to encryption.</p>
                            
                            <h3>Creating a Signature (The Signer's Side):</h3>
                            <ol>
                                <li>The message to be signed is first run through a hash function (e.g., SHA-256) to produce a fixed-size hash digest.</li>
                                <li>The signer uses their <strong>PRIVATE KEY</strong> to encrypt this hash digest.</li>
                                <li>The resulting encrypted hash is the digital signature. It is attached to the original message.</li>
                            </ol>

                            <h3>Verifying a Signature (The Recipient's Side):</h3>
                            <ol>
                                <li>The recipient receives the message and the attached digital signature.</li>
                                <li>The recipient uses the signer's <strong>PUBLIC KEY</strong> to decrypt the signature, revealing the original hash digest.</li>
                                <li>The recipient independently computes the hash of the received message using the same hash function.</li>
                                <li>The recipient compares the decrypted hash (from step 2) with the newly computed hash (from step 3). If they match exactly, the signature is valid.</li>
                            </ol>
                            
                            <div class="info-box note">
                                <div class="info-box-header">
                                    <i class="fas fa-info-circle"></i>
                                    <strong>Signing vs. Encryption</strong>
                                </div>
                                <p><strong>Encryption provides confidentiality.</strong> You encrypt with the recipient's PUBLIC key. <br><strong>Signing provides authenticity and integrity.</strong> You sign with your own PRIVATE key.</p>
                            </div>
                        `,
                        image: 'https://images.unsplash.com/photo-1606128881525-082875f54b6a?w=800&h=400&fit=crop'
                    }
                ],
                codeExamples: [
                    {
                        title: 'Lab: Sign a Message with RSA and Verify the Signature',
                        language: 'bash',
                        code: `# --- Lab Task ---
# Use OpenSSL to create and verify a digital signature.

# Step 1: We need a key pair. Let's generate one if it doesn't exist.
if [ ! -f signer_private_key.pem ]; then
    openssl genpkey -algorithm RSA -out signer_private_key.pem -pkeyopt rsa_keygen_bits:2048
    openssl rsa -pubout -in signer_private_key.pem -out signer_public_key.pem
    echo "Generated new RSA key pair for signing."
fi

# Step 2: Create a document to sign
echo "This is an official document that requires a digital signature." > document.txt
echo "Document content: $(cat document.txt)"

# Step 3: Create the digital signature
# This command hashes the document (with sha256) and then signs the hash with the private key.
openssl dgst -sha256 -sign signer_private_key.pem -out document.sig document.txt
echo -e "\\nCreated digital signature: document.sig"

# Step 4: Verify the signature
# This command uses the public key to verify that the signature is valid for the given document.
echo "Verifying the signature..."
openssl dgst -sha256 -verify signer_public_key.pem -signature document.sig document.txt

# --- Tampering Simulation ---
echo -e "\\n--- Now, let's tamper with the document ---"
echo "This line was added maliciously." >> document.txt
echo "New document content: $(cat document.txt)"

# Step 5: Try to verify the signature against the tampered document
echo "Verifying the signature against the MODIFIED document..."
openssl dgst -sha256 -verify signer_public_key.pem -signature document.sig document.txt
# This will now fail with a "Verification Failure" message.`
                    }
                ]
            },
            quiz: {
                passingScore: 75,
                questions: [
                    {
                        id: 1,
                        question: "Which key is used to CREATE a digital signature?",
                        options: [
                            "The signer's public key",
                            "The verifier's public key",
                            "A shared symmetric key",
                            "The signer's private key"
                        ],
                        correct: 3,
                        explanation: "A digital signature can only be created by the owner of the key pair, so it requires the use of their secret private key."
                    },
                    {
                        id: 2,
                        question: "Which security property ensures that a signer cannot later deny having signed a message?",
                        options: [
                            "Confidentiality",
                            "Integrity",
                            "Non-repudiation",
                            "Availability"
                        ],
                        correct: 2,
                        explanation: "Non-repudiation is the assurance that someone cannot deny the validity of something. Digital signatures provide this because only the key owner could have created the signature."
                    },
                    {
                        id: 3,
                        question: "What is actually being encrypted with the private key when creating a digital signature?",
                        options: [
                            "The entire message",
                            "The public key",
                            "A hash of the message",
                            "A random number"
                        ],
                        correct: 2,
                        explanation: "Signing the entire message would be very slow. Instead, we sign a small, fixed-size hash of the message. This is efficient and provides the same security guarantees."
                    }
                ]
            }
        },
        {
            id: 'lesson-14',
            title: 'Key Management',
            duration: '60 min',
            objectives: [
                'Understand the importance of the key management lifecycle',
                'Learn best practices for key generation and storage',
                'Explain the concepts of key rotation and revocation',
                'Be introduced to tools like GPG for managing keys'
            ],
            content: {
                overview: 'The security of any cryptosystem is completely dependent on the security of its keys. Strong algorithms are useless if keys are mishandled. This lesson covers the crucial discipline of key management, including the key lifecycle, best practices for storage and rotation, and an introduction to practical tools.',
                sections: [
                    {
                        title: 'The Key Management Lifecycle',
                        content: `
                            <p>Effective key management involves handling keys securely throughout their entire lifespan. This lifecycle consists of several stages:</p>
                            
                            <ol>
                                <li><strong>Generation:</strong> Creating keys using a secure random number generator and appropriate algorithm parameters (e.g., sufficient length).</li>
                                <li><strong>Storage:</strong> Storing keys securely to prevent unauthorized access. Private keys should be encrypted at rest, often protected by a strong passphrase. Hardware Security Modules (HSMs) provide the highest level of protection.</li>
                                <li><strong>Distribution:</strong> Securely distributing keys to authorized parties. For symmetric keys, this is a major challenge. For asymmetric keys, this involves sharing public keys, often via a Public Key Infrastructure (PKI).</li>
                                <li><strong>Usage:</strong> Using keys for their intended cryptographic purpose (encryption, signing, etc.) in a secure environment.</li>
                                <li><strong>Rotation:</strong> Periodically replacing old keys with new ones to limit the amount of data exposed if a key is compromised.</li>
                                <li><strong>Revocation/Destruction:</strong> Deactivating and securely deleting keys when they are compromised or no longer needed. For public keys, this involves publishing a revocation certificate.</li>
                            </ol>
                        `,
                        image: 'https://images.unsplash.com/photo-1556157382-97eda2d62296?w=800&h=400&fit=crop'
                    },
                    {
                        title: 'Best Practices and Tools',
                        content: `
                            <p>Following best practices is essential for robust security.</p>
                            
                            <h3>Key Storage Best Practices:</h3>
                            <ul>
                                <li><strong>Never store keys in plaintext.</strong></li>
                                <li><strong>Never hard-code keys in source code.</strong></li>
                                <li>Use a dedicated key management system (KMS) or a Hardware Security Module (HSM) for high-value keys.</li>
                                <li>For personal use, use a trusted password manager or key management tool.</li>
                            </ul>

                            <h3>GNU Privacy Guard (GPG):</h3>
                            <p>GPG is a popular open-source implementation of the OpenPGP standard used for encrypting and signing data and communications. It is a powerful command-line tool for managing your own public/private key pairs.</p>
                            <ul>
                                <li><strong>Key Generation:</strong> <code>gpg --full-generate-key</code></li>
                                <li><strong>Listing Keys:</strong> <code>gpg --list-keys</code></li>
                                <li><strong>Exporting a Public Key:</strong> <code>gpg --armor --export [key-id]</code></li>
                                <li><strong>Encrypting/Signing:</strong> GPG can be used to encrypt files, sign documents, and secure emails.</li>
                            </ul>
                            
                            <div class="info-box note">
                                <div class="info-box-header">
                                    <i class="fas fa-info-circle"></i>
                                    <strong>Kerckhoffs's Principle</strong>
                                </div>
                                <p>This fundamental principle states that a cryptosystem should be secure even if everything about the system, except the key, is public knowledge. This highlights why the security of the key itself is paramount.</p>
                            </div>
                        `,
                        image: 'https://images.unsplash.com/photo-1614064548237-0965305021b4?w=800&h=400&fit=crop'
                    }
                ],
                codeExamples: [
                    {
                        title: 'Lab: Manage Keys with GPG',
                        language: 'bash',
                        code: `# --- Lab Task ---
# Use GPG to generate a key pair and list it.
# Note: This will create keys in your personal GPG keyring.

# Step 1: Generate a new GPG key pair
# The '--full-generate-key' command will walk you through a series of prompts.
# Choose the default (RSA and RSA), a key size of 3072 or 4096, and set an expiration.
# You will need to provide a name, email address, and a secure passphrase.
# This process might take a moment as it needs to gather entropy (randomness).
echo "Starting GPG key generation. Please follow the prompts."
gpg --full-generate-key

# Step 2: List your public keys
# This shows the keys in your public keyring, including the one you just created.
echo -e "\\n--- Your Public Keys ---"
gpg --list-keys

# Step 3: List your private keys
# This shows the corresponding private keys.
echo -e "\\n--- Your Private Keys ---"
gpg --list-secret-keys

# Step 4: Export your public key
# Replace 'your-email@example.com' with the email you used.
# The '--armor' flag creates ASCII-armored output that you can easily copy and paste.
echo -e "\\n--- Exporting Your Public Key ---"
gpg --armor --export your-email@example.com`
                    }
                ]
            },
            quiz: {
                passingScore: 75,
                questions: [
                    {
                        id: 1,
                        question: "What is the primary reason for key rotation?",
                        options: [
                            "To make keys easier to remember.",
                            "To limit the damage if a key is eventually compromised.",
                            "To convert keys to a new algorithm.",
                            "To make encryption faster."
                        ],
                        correct: 1,
                        explanation: "Key rotation limits a key's lifespan. This means that if an attacker ever compromises a key, they can only decrypt data that was protected by that specific key during its limited period of use."
                    },
                    {
                        id: 2,
                        question: "According to Kerckhoffs's Principle, where should the security of a cryptosystem reside?",
                        options: [
                            "In the secrecy of the algorithm.",
                            "In the secrecy of the key.",
                            "In the complexity of the software.",
                            "In the physical security of the server."
                        ],
                        correct: 1,
                        explanation: "Kerckhoffs's Principle dictates that the algorithm should be assumed to be public. The entire security of the system must therefore depend only on the secrecy of the key."
                    },
                    {
                        id: 3,
                        question: "What is a Hardware Security Module (HSM)?",
                        options: [
                            "A software-based key manager.",
                            "A USB stick for storing passwords.",
                            "A dedicated physical device for securely generating, storing, and using cryptographic keys.",
                            "A type of firewall."
                        ],
                        correct: 2,
                        explanation: "An HSM is a specialized, tamper-resistant hardware device that provides the highest level of security for cryptographic keys. The keys often cannot be exported from the HSM in plaintext."
                    }
                ]
            }
        },
        {
            id: 'lesson-15',
            title: 'Cryptographic Random Numbers',
            duration: '60 min',
            objectives: [
                'Understand why randomness is critical in cryptography',
                'Differentiate between a Pseudorandom Number Generator (PRNG) and a Cryptographically Secure PRNG (CSPRNG)',
                'Learn about sources of entropy for generating random numbers',
                'Recognize the dangers of using predictable or non-secure random numbers'
            ],
            content: {
                overview: 'Random numbers are the lifeblood of cryptography. They are essential for generating keys, nonces, and initialization vectors. This lesson explores the critical need for high-quality randomness, the difference between standard and cryptographically secure random number generators, and the severe consequences of getting it wrong.',
                sections: [
                    {
                        title: 'The Need for Unpredictability',
                        content: `
                            <p>Many cryptographic operations require values that must be secret and unpredictable. If an attacker can guess these values, the security of the entire system collapses.</p>
                            
                            <h3>Where Randomness is Used:</h3>
                            <ul>
                                <li><strong>Key Generation:</strong> All cryptographic keys (symmetric, RSA, ECC) must be generated from a random source.</li>
                                <li><strong>Nonces ("Number used once"):</strong> A random number used to prevent replay attacks, for example in authentication protocols.</li>
                                <li><strong>Initialization Vectors (IVs):</strong> Used in block cipher modes like CBC to ensure identical plaintexts produce different ciphertexts.</li>
                                <li><strong>Salts:</strong> A random value added to a password before hashing to protect against rainbow table attacks.</li>
                            </ul>
                            
                            <div class="info-box warning">
                                <div class="info-box-header">
                                    <i class="fas fa-exclamation-triangle"></i>
                                    <strong>The Danger of Predictable "Randomness"</strong>
                                </div>
                                <p>If a "random" number generator produces a predictable sequence, an attacker who observes a few outputs can potentially predict all future (and past) outputs, allowing them to guess keys, IVs, and other secrets.</p>
                            </div>
                        `,
                        image: 'https://images.unsplash.com/photo-1557682224-5b8590cd9ec5?w=800&h=400&fit=crop'
                    },
                    {
                        title: 'PRNG vs. CSPRNG',
                        content: `
                            <p>Not all random number generators are suitable for cryptographic use.</p>
                            
                            <h3>Pseudorandom Number Generator (PRNG):</h3>
                            <p>Standard PRNGs, found in most programming languages' basic math libraries (e.g., <code>random()</code>), are designed for statistical randomness, not unpredictability. They are fine for simulations or games, but are often predictable and <strong>must not be used for cryptography</strong>.</p>
                            <ul>
                                <li><strong>Characteristics:</strong> Fast, produces statistically random sequences.</li>
                                <li><strong>Weakness:</strong> The sequence can often be reproduced if you know the initial "seed" value.</li>
                            </ul>

                            <h3>Cryptographically Secure PRNG (CSPRNG):</h3>
                            <p>A CSPRNG is designed specifically to be unpredictable. It generates random numbers from a source of genuine randomness called entropy.</p>
                            <ul>
                                <li><strong>Entropy Sources:</strong> The operating system collects entropy from unpredictable physical events, such as mouse movements, keyboard timings, network packet arrival times, and hardware-based random number generators.</li>
                                <li><strong>Characteristics:</strong> Given a sequence of bits from a CSPRNG, it is computationally infeasible to predict the next bit in the sequence.</li>
                                <li><strong>Examples:</strong> In Linux, <code>/dev/random</code> and <code>/dev/urandom</code> provide access to the OS's CSPRNG. In Python, the <code>secrets</code> module or <code>os.urandom()</code> should be used.</li>
                            </ul>
                        `,
                        image: 'https://images.unsplash.com/photo-1633435639423-643d517c2a75?w=800&h=400&fit=crop'
                    }
                ],
                codeExamples: [
                    {
                        title: 'Lab: Generate Secure Random Bytes in Python',
                        language: 'python',
                        code: `import secrets
import os
import random

# --- Lab Task ---
# Compare the output of a standard PRNG with a CSPRNG.

# 1. Standard PRNG (NOT for security)
# Seeding the generator makes the sequence predictable.
random.seed(12345)
print("--- Standard PRNG (e.g., random.random()) ---")
print("This sequence is predictable if the seed is known.")
print(random.random())
print(random.random())
print(random.random())

# 2. Cryptographically Secure PRNG (CSPRNG)
# The 'secrets' module in Python is the recommended way to get crypto-grade randomness.
# It uses the operating system's entropy sources.
print("\\n--- CSPRNG (secrets module) ---")
print("This output is unpredictable.")
# Generate a random integer
print(f"Secure random integer: {secrets.randbelow(1000)}")
# Generate a URL-safe random text string (e.g., for a session token)
print(f"Secure token: {secrets.token_urlsafe(16)}")
# Generate random bytes
print(f"Secure random bytes: {secrets.token_bytes(8)}")

# Another way to get secure bytes is os.urandom()
print(f"Secure bytes from os.urandom(): {os.urandom(8)}")`
                    }
                ]
            },
            quiz: {
                passingScore: 75,
                questions: [
                    {
                        id: 1,
                        question: "Why is a standard PRNG (like Python's `random` module) unsuitable for generating cryptographic keys?",
                        options: [
                            "It is too slow.",
                            "It produces numbers that are not evenly distributed.",
                            "Its output can be predicted if the initial seed is known.",
                            "It can only produce integers."
                        ],
                        correct: 2,
                        explanation: "Standard PRNGs are designed for speed and statistical quality, not unpredictability. Their output is deterministic based on an initial seed, making them completely insecure for cryptographic purposes."
                    },
                    {
                        id: 2,
                        question: "What is 'entropy' in the context of random number generation?",
                        options: [
                            "A type of encryption algorithm.",
                            "The process of making numbers less random.",
                            "Data gathered from unpredictable physical events used to seed a CSPRNG.",
                            "A measure of the speed of the generator."
                        ],
                        correct: 2,
                        explanation: "Entropy is a measure of disorder or unpredictability. In cryptography, it refers to the random data collected by the operating system from sources like mouse movements or network timings, which is used to ensure the CSPRNG's output is truly unpredictable."
                    },
                    {
                        id: 3,
                        question: "Which of the following would be an appropriate use for a CSPRNG?",
                        options: [
                            "Generating a temporary session key for a web application.",
                            "Shuffling a deck of cards in a computer game.",
                            "Creating random enemy movements in a simulation.",
                            "Picking a random winner from a list of names."
                        ],
        
                correct: 0,
                        explanation: "Generating a session key requires high-quality, unpredictable randomness to prevent hijacking. The other options do not have security implications, so a standard PRNG would be sufficient and more performant."
                    }
                ]
            }
        },
        {
            id: 'lesson-16',
            title: 'Password Hashing & Key Derivation',
            duration: '75 min',
            objectives: [
                'Understand why passwords should never be stored in plaintext',
                'Learn the importance of using a salt when hashing passwords',
                'Differentiate between fast hash functions (SHA-256) and slow password hashing functions (bcrypt, Argon2)',
                'Define a Key Derivation Function (KDF) and its purpose'
            ],
            content: {
                overview: 'Storing user passwords securely is one of the most critical responsibilities of any application developer. Simply hashing a password is not enough. This lesson covers the modern techniques for secure password storage, including salting and the use of slow, resource-intensive hashing functions designed specifically for this purpose.',
                sections: [
                    {
                        title: 'Why Plain Hashing is Not Enough: Salts and Rainbow Tables',
                        content: `
                            <p>Storing a direct hash (e.g., SHA-256) of a password is a dangerous practice. If two users choose the same password, they will have the same hash. An attacker with a database of pre-computed hashes, called a <strong>rainbow table</strong>, can look up the hash and instantly find the original password.</p>
                            
                            <h3>Salting:</h3>
                            <p>To defeat rainbow tables, we use a <strong>salt</strong>. A salt is a unique, random string that is generated for each user and stored alongside their password hash. The salt is combined with the password before hashing.</p>
                            <code>Hashed_Password = Hash(Password + Salt)</code>
                            <p>Now, even if two users have the same password, their hashes will be different because they have different salts. This makes pre-computation attacks like rainbow tables ineffective.</p>
                        `,
                        image: 'https://images.unsplash.com/photo-1542831371-29b0f74f9713?w=800&h=400&fit=crop'
                    },
                    {
                        title: 'Slow Hashing Functions: bcrypt, PBKDF2, Argon2',
                        content: `
                            <p>General-purpose hash functions like SHA-256 are designed to be extremely fast. This is a problem for password hashing because it allows an attacker to try billions of guesses per second in an offline brute-force attack. To counter this, we use specialized password hashing functions that are deliberately slow and computationally expensive.</p>
                            
                            <h3>Key Characteristics:</h3>
                            <ul>
                                <li><strong>Adaptive Cost Factor:</strong> These functions have a configurable "work factor" or "cost" parameter. As computers get faster, you can increase the cost factor to maintain the same level of security.</li>
                                <li><strong>Memory-Hard (for Argon2):</strong> Some functions are designed to require a large amount of memory, making it expensive to build specialized password-cracking hardware (like GPUs or ASICs).</li>
                            </ul>

                            <h3>Popular Algorithms:</h3>
                            <ul>
                                <li><strong>bcrypt:</strong> A widely used and trusted algorithm based on the Blowfish cipher. It is very well-tested.</li>
                                <li><strong>PBKDF2 (Password-Based Key Derivation Function 2):</strong> A standard that repeatedly applies a cryptographic hash function thousands of times. It is secure but vulnerable to hardware-based attacks.</li>
                                <li><strong>scrypt:</strong> A memory-hard function designed to be more resistant to custom hardware attacks than bcrypt and PBKDF2.</li>
                                <li><strong>Argon2:</strong> The winner of the Password Hashing Competition (2015), Argon2 is the current state-of-the-art. It is highly resistant to GPU cracking and has configurable time and memory costs. It is the recommended choice for new applications.</li>
                            </ul>
                        `,
                        image: 'https://images.unsplash.com/photo-1550009158-94ae7d6ab98d?w=800&h=400&fit=crop'
                    },
                    {
                        title: 'Key Derivation Functions (KDFs)',
                        content: `
                            <p>A Key Derivation Function (KDF) takes a low-entropy input, like a user's password, and produces a strong, cryptographically secure key. Password hashing functions like PBKDF2 and Argon2 are types of KDFs.</p>
                            <p>KDFs are used to convert a memorable password into a key suitable for use in other cryptographic algorithms, such as encrypting a file or a hard drive. For example, when you use a tool like VeraCrypt or BitLocker, a KDF takes your passphrase and derives the actual AES key used to encrypt the disk.</p>
                        `,
                        image: 'https://images.unsplash.com/photo-1614064548237-0965305021b4?w=800&h=400&fit=crop'
                    }
                ],
                codeExamples: [
                    {
                        title: 'Lab: Hash a Password with bcrypt',
                        language: 'python',
                        code: `# You need to install the bcrypt library first: pip install bcrypt

import bcrypt

# --- Lab Task ---
# 1. Choose a password.
# 2. Generate a salted hash for the password using bcrypt.
# 3. Verify the original password against the generated hash.
# 4. Try to verify an incorrect password and see it fail.

password = b"SuperSecretP@ssw0rd!"

# --- Hashing the password ---
# bcrypt.gensalt() creates a new random salt for each call.
# The 'salt' is automatically included in the resulting hash string.
salt = bcrypt.gensalt(rounds=12) # rounds is the cost factor
hashed_password = bcrypt.hashpw(password, salt)

print(f"Original Password: {password.decode()}")
print(f"Generated Hash: {hashed_password.decode()}")
# Note that the hash contains the algorithm, cost factor, salt, and hash all in one string.

# --- Verifying the password ---
# To check a password, you use bcrypt.checkpw().
# It will extract the salt from the hashed_password string and use it.
print("\\n--- Verification ---")
if bcrypt.checkpw(password, hashed_password):
    print("Password verification SUCCESSFUL.")
else:
    print("Password verification FAILED.")

# --- Verifying an incorrect password ---
incorrect_password = b"WrongPassword"
if bcrypt.checkpw(incorrect_password, hashed_password):
    print("Incorrect password verification SUCCESSFUL. (ERROR!)")
else:
    print("Incorrect password verification FAILED, as expected.")`
                    }
                ]
            },
            quiz: {
                passingScore: 75,
                questions: [
                    {
                        id: 1,
                        question: "What is the purpose of using a 'salt' when hashing passwords?",
                        options: [
                            "To make the hash shorter.",
                            "To make the hashing process faster.",
                            "To make the hash reversible.",
                            "To ensure two users with the same password have different hashes, defeating rainbow table attacks."
                        ],
                        correct: 3,
                        explanation: "A unique, random salt is added to each password before hashing. This ensures that identical passwords produce different hashes, rendering pre-computed rainbow tables useless."
                    },
                    {
                        id: 2,
                        question: "Why should a fast hash function like SHA-256 NOT be used directly for password hashing?",
                        options: [
                            "It is not secure.",
                            "It is too slow for modern computers.",
                            "Its speed allows attackers to make billions of guesses per second in a brute-force attack.",
                            "It produces a hash that is too long."
                        ],
                        correct: 2,
                        explanation: "The extreme speed of functions like SHA-256 is a disadvantage for password hashing because it allows an attacker who has stolen the hash database to perform offline brute-force attacks very quickly."
                    },
                    {
                        id: 3,
                        question: "Which of the following is considered the modern, state-of-the-art password hashing algorithm?",
                        options: [
                            "MD5",
                            "bcrypt",
                            "PBKDF2",
                            "Argon2"
                        ],
                        correct: 3,
                        explanation: "Argon2 was the winner of the Password Hashing Competition and is recommended for new applications due to its resistance to GPU-based cracking and its configurable memory and time costs."
                    }
                ]
            }
        },
        {
            id: 'lesson-17',
            title: 'Cryptanalysis Basics',
            duration: '60 min',
            objectives: [
                'Define cryptanalysis and its goals',
                'Understand the concept of a brute-force attack',
                'Learn about frequency analysis and its use against classical ciphers',
                'Be introduced to the idea of side-channel attacks'
            ],
            content: {
                overview: 'Cryptanalysis is the art and science of analyzing and breaking codes. Understanding the mindset and methods of a cryptanalyst is crucial for building secure systems. This lesson provides a basic introduction to common attack vectors, from simple brute-force to the elegant frequency analysis and the subtle side-channel attack.',
                sections: [
                    {
                        title: 'Brute-Force and Frequency Analysis',
                        content: `
                            <p>Cryptanalytic attacks range from unsophisticated to highly complex.</p>
                            
                            <h3>Brute-Force Attack:</h3>
                            <p>This is the simplest form of attack. The attacker tries every possible key, one by one, until the correct one is found. The feasibility of a brute-force attack is determined entirely by the key length. A 56-bit key (like in DES) is vulnerable, while a 128-bit or 256-bit key (like in AES) is computationally infeasible to brute-force with current technology.</p>
                            
                            <h3>Frequency Analysis:</h3>
                            <p>This is a powerful technique for breaking classical substitution ciphers. It relies on the fact that certain letters and letter combinations appear with known frequencies in any given language (e.g., in English, 'E' is the most common letter, followed by 'T', 'A', etc.). By analyzing the frequency of characters in the ciphertext, an attacker can make educated guesses about the substitution key.</p>
                        `,
                        image: 'https://images.unsplash.com/photo-1554435493-95242d513e3b?w=800&h=400&fit=crop'
                    },
                    {
                        title: 'Side-Channel Attacks',
                        content: `
                            <p>Side-channel attacks are a clever and often devastating category of attack that does not target weaknesses in the cryptographic algorithm itself. Instead, they exploit information gained from the <strong>physical implementation</strong> of the cryptosystem.</p>
                            
                            <h3>Types of Side-Channels:</h3>
                            <ul>
                                <li><strong>Timing Analysis:</strong> Observing how long it takes for a system to perform cryptographic operations. Different inputs might cause slight variations in processing time, which can leak information about the secret key.</li>
                                <li><strong>Power Monitoring:</strong> Analyzing the power consumption of a device (like a smart card or processor) while it performs cryptography. The amount of power used can correlate with the data being processed and the operations being performed.</li>
                                <li><strong>Electromagnetic (EM) Analysis:</strong> Measuring the EM radiation emitted by a device. These emissions can also leak information about internal operations.</li>
                                <li><strong>Acoustic Analysis:</strong> Analyzing the sounds produced by a computer or device as it works. High-frequency sounds from capacitors or other components can sometimes reveal information about the computations being performed.</li>
                            </ul>
                            
                            <div class="info-box note">
                                <div class="info-box-header">
                                    <i class="fas fa-info-circle"></i>
                                    <strong>Real-World Impact</strong>
                                </div>
                                <p>Side-channel attacks are a serious threat, especially for embedded systems and smart cards. Defending against them requires careful hardware and software design, such as ensuring that all cryptographic operations take a constant amount of time regardless of the input.</p>
                            </div>
                        `,
                        image: 'https://images.unsplash.com/photo-1590237735430-8ea243c32a7e?w=800&h=400&fit=crop'
                    }
                ],
                codeExamples: [
                    {
                        title: 'Lab: Break a Caesar Cipher with Frequency Analysis',
                        language: 'python',
                        code: `from collections import Counter

def caesar_decrypt(ciphertext, shift):
    """Decrypts Caesar cipher text by shifting letters back."""
    decrypted_text = ""
    for char in ciphertext:
        if 'a' <= char <= 'z':
            decrypted_text += chr(((ord(char) - ord('a') - shift + 26) % 26) + ord('a'))
        elif 'A' <= char <= 'Z':
            decrypted_text += chr(((ord(char) - ord('A') - shift + 26) % 26) + ord('A'))
        else:
            decrypted_text += char
    return decrypted_text

# --- Lab Task ---
# 1. We have a ciphertext encrypted with an unknown Caesar cipher shift.
# 2. We will find the most frequent letter in the ciphertext.
# 3. Assuming the most frequent letter in English is 'e', we can deduce the shift.

ciphertext = "Uif rvjdl cspxo gpy kvnqt pwfs uif mbaz eph."
print(f"Ciphertext: {ciphertext}\\n")

# Find the most frequent letter in the ciphertext
letter_counts = Counter(c.lower() for c in ciphertext if c.isalpha())
most_frequent_char = letter_counts.most_common(1)[0][0]
print(f"The most frequent character in the ciphertext is: '{most_frequent_char}'")

# Assume the most frequent character corresponds to 'e' in the plaintext.
# The shift is the distance between them in the alphabet.
assumed_shift = (ord(most_frequent_char) - ord('e')) % 26
print(f"Assuming this corresponds to 'e', the calculated shift is: {assumed_shift}")

# Decrypt the message using the deduced shift
plaintext = caesar_decrypt(ciphertext, assumed_shift)
print(f"\\nDecrypted Plaintext: {plaintext}")`
                    }
                ]
            },
            quiz: {
                passingScore: 75,
                questions: [
                    {
                        id: 1,
                        question: "What is a brute-force attack?",
                        options: [
                            "Exploiting a flaw in the algorithm's mathematics.",
                            "Systematically trying every possible key until the correct one is found.",
                            "Analyzing the power consumption of the encrypting device.",
                            "Guessing the key based on common words."
                        ],
                        correct: 1,
                        explanation: "A brute-force attack is an exhaustive search that involves trying all possible combinations for the key. Its success depends on the key length and available computing power."
                    },
                    {
                        id: 2,
                        question: "Frequency analysis is most effective against which type of cipher?",
                        options: [
                            "Modern block ciphers like AES.",
                            "Classical monoalphabetic substitution ciphers.",
                            "Asymmetric ciphers like RSA.",
                            "Hash functions like SHA-256."
                        ],
                        correct: 1,
                        explanation: "Simple substitution ciphers preserve the underlying frequency patterns of the plaintext language, making them highly vulnerable to frequency analysis. Modern ciphers are designed to eliminate these patterns."
                    },
                    {
                        id: 3,
                        question: "A side-channel attack exploits weaknesses in what?",
                        options: [
                            "The mathematical theory of the cipher.",
                            "The user's choice of password.",
                            "The physical implementation of the cryptosystem.",
                            "The network protocol used for communication."
                        ],
                        correct: 2,
                        explanation: "Side-channel attacks focus on information leaked from the physical hardware executing the algorithm, such as its power consumption, timing variations, or electromagnetic emissions, rather than the algorithm itself."
                    }
                ]
            }
        },
        {
            id: 'lesson-18',
            title: 'Applications of Cryptography',
            duration: '75 min',
            objectives: [
                'Understand the role of cryptography in SSL/TLS for securing web traffic',
                'Learn how cryptography enables Virtual Private Networks (VPNs)',
                'Explore the fundamental use of cryptography in blockchain and cryptocurrencies',
                'Recognize other common real-world applications'
            ],
            content: {
                overview: 'Cryptography is not just a theoretical field; it is the engine that powers security and trust across the internet and modern technology. This lesson explores some of the most important real-world applications, including how your web browsing is secured, how VPNs protect your privacy, and how cryptocurrencies are built on a cryptographic foundation.',
                sections: [
                    {
                        title: 'SSL/TLS: Securing the Web',
                        content: `
                            <p>Secure Sockets Layer (SSL) and its modern successor, Transport Layer Security (TLS), are cryptographic protocols that provide secure communication over a computer network. TLS is the "S" in HTTPS that secures your browsing activity.</p>
                            
                            <h3>How the TLS Handshake Works:</h3>
                            <ol>
                                <li><strong>Client Hello:</strong> Your browser connects to a server and sends a list of the cipher suites (combinations of algorithms) it supports.</li>
                                <li><strong>Server Hello & Certificate:</strong> The server chooses a cipher suite and sends back its public key in a digital certificate. This certificate is signed by a trusted Certificate Authority (CA), which proves the server's identity.</li>
                                <li><strong>Key Exchange:</strong> The client and server use an asymmetric protocol (like Diffie-Hellman with Elliptic Curves - ECDHE) to securely establish a shared symmetric "session key."</li>
                                <li><strong>Finished:</strong> Both parties confirm the handshake was successful, and all future communication for that session is encrypted using the fast symmetric session key (e.g., AES-256-GCM).</li>
                            </ol>
                        `,
                        image: 'https://images.unsplash.com/photo-1599507593498-27b3b4d45595?w=800&h=400&fit=crop'
                    },
                    {
                        title: 'Virtual Private Networks (VPNs)',
                        content: `
                            <p>A VPN creates a secure, encrypted "tunnel" over a public network (like the internet). All the traffic that passes through this tunnel is encrypted, protecting it from eavesdropping by an Internet Service Provider (ISP) or attackers on a public Wi-Fi network.</p>
                            
                            <h3>Core Cryptographic Components:</h3>
                            <ul>
                                <li><strong>Authentication:</strong> Ensures you are connecting to a legitimate VPN server.</li>
                                <li><strong>Key Exchange:</strong> A protocol like Diffie-Hellman is used to establish session keys.</li>
                                <li><strong>Confidentiality:</strong> A strong symmetric cipher like AES is used to encrypt all the data flowing through the tunnel.</li>
                                <li><strong>Integrity:</strong> A MAC or HMAC is used to ensure the data is not tampered with in transit.</li>
                            </ul>
                        `,
                        image: 'https://images.unsplash.com/photo-1563013544-824ae1b704d3?w=800&h=400&fit=crop'
                    },
                    {
                        title: 'Blockchain and Cryptocurrencies',
                        content: `
                            <p>Blockchain is a decentralized, distributed digital ledger that is secured using cryptography. Every component of a system like Bitcoin relies on cryptographic principles.</p>
                            
                            <h3>Key Cryptographic Elements:</h3>
                            <ul>
                                <li><strong>Hash Functions (SHA-256):</strong> Used extensively to link blocks together (each block contains the hash of the previous one, forming a "chain") and in the "proof-of-work" mining process.</li>
                                <li><strong>Public-Key Cryptography (ECC):</strong> User "wallets" are essentially public/private key pairs. Your public key is used to generate your wallet address (where you receive funds), and your private key is used to create digital signatures to authorize transactions (spending your funds).</li>
                                <li><strong>Digital Signatures:</strong> Every transaction on the blockchain must be digitally signed with the sender's private key, proving ownership of the funds being spent.</li>
                            </ul>
                        `,
                        image: 'https://images.unsplash.com/photo-1621418763593-e1a53311029c?w=800&h=400&fit=crop'
                    }
                ],
                codeExamples: [
                    {
                        title: 'Lab: Analyze Bitcoin Transaction Cryptography',
                        language: 'python',
                        code: `# We will use a library to demonstrate Bitcoin's cryptographic principles.
# First, install it: pip install bitcoin
from bitcoin import *

# --- Lab Task ---
# 1. Generate a new private key.
# 2. Derive the public key and Bitcoin address from it.
# 3. Create a simple (mock) transaction and sign it.
# 4. Verify the signature.

# 1. Generate a random private key
# A Bitcoin private key is just a very large random number.
private_key = random_key()
print(f"Private Key: {private_key}")

# 2. Derive the public key
public_key = privtopub(private_key)
print(f"\\nPublic Key: {public_key}")

# 3. Derive the Bitcoin address from the public key
# The address is derived by hashing the public key.
address = pubtoaddr(public_key)
print(f"\\nBitcoin Address: {address}")

# 4. Create a mock transaction message to sign
# In a real transaction, this would be a hash of the transaction data.
message = "This is a message representing a transaction."

# 5. Sign the message with the private key
signature = ecdsa_sign(message, private_key)
print(f"\\nGenerated Signature: {signature}")

# 6. Verify the signature
# Anyone can use the public key to verify that the signature was created
# by the holder of the corresponding private key.
is_valid = ecdsa_verify(message, signature, public_key)
print(f"\\nIs the signature valid for this message and public key? {is_valid}")`
                    }
                ]
            },
            quiz: {
                passingScore: 75,
                questions: [
                    {
                        id: 1,
                        question: "In the TLS protocol, what is the primary purpose of the server's digital certificate?",
                        options: [
                            "To encrypt the entire web session.",
                            "To prove the server's identity to the client.",
                            "To store the client's password.",
                            "To speed up the connection."
                        ],
                        correct: 1,
                        explanation: "The server's certificate, signed by a trusted Certificate Authority, contains its public key and domain name. This allows your browser to verify that it is connecting to the legitimate server and not an impostor."
                    },
                    {
                        id: 2,
                        question: "In Bitcoin, what is used to authorize the spending of funds from a wallet?",
                        options: [
                            "The user's password.",
                            "A digital signature created with the user's private key.",
                            "The hash of the user's public key.",
                            "A symmetric key shared with the network."
                        ],
                        correct: 1,
                        explanation: "A transaction is only valid if it is signed with the private key corresponding to the public key (address) from which the funds are being sent. This proves ownership."
                    },
                    {
                        id: 3,
                        question: "What is the main function of cryptography in a VPN?",
                        options: [
                            "To assign an IP address.",
                            "To create a secure, encrypted tunnel for data over a public network.",
                            "To block advertisements.",
                            "To compress data and make it faster."
                        ],
                        correct: 1,
                        explanation: "A VPN's core purpose is to provide confidentiality and integrity for your network traffic by encrypting it and sending it through a protected tunnel, shielding it from observation on the local network or by an ISP."
                    }
                ]
            }
        },
        {
            id: 'lesson-19',
            title: 'Quantum Cryptography',
            duration: '60 min',
            objectives: [
                'Understand the threat that quantum computers pose to current cryptography',
                'Learn about Shor\'s algorithm and Grover\'s algorithm',
                'Define Post-Quantum Cryptography (PQC)',
                'Be introduced to the main categories of quantum-resistant algorithms'
            ],
            content: {
                overview: 'The advent of large-scale quantum computers represents a paradigm shift for cryptography. While still largely theoretical, they have the potential to break many of the public-key cryptosystems we rely on today. This lesson explores this threat and the ongoing effort to develop quantum-resistant algorithms to secure our future.',
                sections: [
                    {
                        title: 'The Quantum Threat',
                        content: `
                            <p>Quantum computers operate on the principles of quantum mechanics, such as superposition and entanglement. This allows them to solve certain types of mathematical problems much faster than classical computers.</p>
                            
                            <h3>Shor's Algorithm:</h3>
                            <p>Published in 1994, Shor's algorithm shows that a sufficiently powerful quantum computer could efficiently solve the integer factorization and discrete logarithm problems. This means it could break cryptosystems based on these problems, including:</p>
                            <ul>
                                <li><strong>RSA</strong> (based on factorization)</li>
                                <li><strong>Diffie-Hellman</strong> (based on discrete logarithms)</li>
                                <li><strong>Elliptic Curve Cryptography (ECC)</strong> (based on elliptic curve discrete logarithms)</li>
                            </ul>
                            <p>Essentially, most of our current public-key cryptography would be rendered insecure.</p>

                            <h3>Grover's Algorithm:</h3>
                            <p>Grover's algorithm provides a quadratic speedup for searching an unsorted database. This has an impact on symmetric-key cryptography. To maintain the same level of security against a quantum attacker, we would need to double the key length. For example, AES-128 would only offer 64 bits of security, so we would need to switch to <strong>AES-256</strong> to maintain a 128-bit security level.</p>
                        `,
                        image: 'https://images.unsplash.com/photo-1614064548237-0965305021b4?w=800&h=400&fit=crop'
                    },
                    {
                        title: 'Post-Quantum Cryptography (PQC)',
                        content: `
                            <p>Post-Quantum Cryptography (PQC), also called quantum-resistant cryptography, refers to cryptographic algorithms that are thought to be secure against attack by both classical and quantum computers. These algorithms are based on mathematical problems that are believed to be difficult for even a quantum computer to solve.</p>
                            
                            <h3>The NIST PQC Standardization Process:</h3>
                            <p>The U.S. National Institute of Standards and Technology (NIST) is currently running a multi-year public competition to select and standardize one or more PQC algorithms. The process is in its final stages, and several promising candidates have emerged.</p>

                            <h3>Main Categories of PQC Candidates:</h3>
                            <ul>
                                <li><strong>Lattice-based Cryptography:</strong> Based on the difficulty of problems related to geometric structures called lattices. This is one of the most promising categories. (e.g., CRYSTALS-Kyber, CRYSTALS-Dilithium)</li>
                                <li><strong>Code-based Cryptography:</strong> Based on the difficulty of decoding a general linear code. (e.g., Classic McEliece)</li>
                                <li><strong>Hash-based Signatures:</strong> Uses hash functions to build digital signature schemes. These are well-understood but can have limitations, such as a finite number of signatures. (e.g., SPHINCS+)</li>
                                <li><strong>Multivariate Cryptography:</strong> Based on the difficulty of solving systems of multivariate polynomial equations.</li>
                            </ul>
                            
                            <div class="info-box tip">
                                <div class="info-box-header">
                                    <i class="fas fa-lightbulb"></i>
                                    <strong>"Harvest Now, Decrypt Later"</strong>
                                </div>
                                <p>The threat is not just in the future. Adversaries can record encrypted data today and store it, waiting for the day they have a quantum computer capable of decrypting it. This makes the transition to PQC an urgent matter.</p>
                            </div>
                        `,
                        image: 'https://images.unsplash.com/photo-1620712943543-285f5add6905?w=800&h=400&fit=crop'
                    }
                ],
                codeExamples: [
                    {
                        title: 'Lab: Explore NIST PQC Candidates',
                        language: 'bash',
                        code: `# --- Lab Task ---
# This is a conceptual lab. We will not implement PQC but explore the official resources.
# Your task is to visit the NIST PQC website and identify the algorithms selected for standardization.

# Step 1: Open a web browser and navigate to the official NIST PQC page:
# https://csrc.nist.gov/Projects/post-quantum-cryptography

# Step 2: Look for the "Round 3" or "Standardization" announcements.
# As of mid-2022, NIST announced its first selections.

# Step 3: Answer the following questions based on the website:
# 1. Which algorithm was selected for general encryption (Public-Key Encryption and KEMs)?
#    (Answer hint: It's a lattice-based KEM)
# 2. Which algorithms were selected for digital signatures?
#    (Answer hint: There are three, all based on different structures)
# 3. Which algorithms are still being considered for future standardization in a 4th round?
#    (Answer hint: These are primarily non-lattice-based KEMs)

echo "Please visit the NIST PQC website to complete this lab."
echo "URL: https://csrc.nist.gov/Projects/post-quantum-cryptography"
echo ""
echo "--- Example Answers (Check for the latest on the NIST site!) ---"
echo "1. For general encryption/KEM: CRYSTALS-Kyber"
echo "2. For digital signatures: CRYSTALS-Dilithium, FALCON, and SPHINCS+"
echo "3. 4th Round Candidates: Classic McEliece, BIKE, HQC, SIKE"
`
                    }
                ]
            },
            quiz: {
                passingScore: 75,
                questions: [
                    {
                        id: 1,
                        question: "Shor's algorithm, when run on a quantum computer, would be able to break which of the following cryptosystems?",
                        options: [
                            "AES-256",
                            "SHA-3",
                            "RSA and ECC",
                            "HMAC"
                        ],
                        correct: 2,
                        explanation: "Shor's algorithm efficiently solves the integer factorization and discrete logarithm problems, which are the mathematical foundations for RSA and ECC, respectively."
                    },
                    {
                        id: 2,
                        question: "What does Post-Quantum Cryptography (PQC) refer to?",
                        options: [
                            "Cryptography that uses quantum computers to encrypt data.",
                            "Algorithms that are secure against attacks from both classical and quantum computers.",
                            "A method for breaking AES.",
                            "Encrypting data to be sent to a quantum computer."
                        ],
                        correct: 1,
                        explanation: "PQC algorithms are classical algorithms (they run on regular computers) designed to be resistant to the new types of attacks that quantum computers will make possible."
                    },
                    {
                        id: 3,
                        question: "What is the recommended mitigation against the threat of Grover's algorithm on symmetric encryption like AES-128?",
                        options: [
                            "Stop using AES entirely.",
                            "Use a longer key, such as AES-256.",
                            "Combine AES with RSA.",
                            "There is no mitigation."
                        ],
                        correct: 1,
                        explanation: "Grover's algorithm effectively halves the bit-strength of a symmetric key. To maintain a 128-bit security level, one must use a key of at least 256 bits."
                    }
                ]
            }
        },
        {
            id: 'lesson-20',
            title: 'Cryptography in Real World Security',
            duration: '75 min',
            objectives: [
                'Understand how end-to-end encryption works in secure messaging',
                'Learn the role of cryptography in full-disk encryption',
                'Explain the basics of a Public Key Infrastructure (PKI)',
                'Recap and connect the cryptographic primitives learned to real-world systems'
            ],
            content: {
                overview: 'This final lesson brings together all the concepts we have learned by examining how they are combined to build the secure systems we use every day. We will look at the architecture of secure messaging, disk encryption, and the Public Key Infrastructure that underpins trust on the internet.',
                sections: [
                    {
                        title: 'Secure Messaging and End-to-End Encryption (E2EE)',
                        content: `
                            <p>End-to-end encryption ensures that only the sender and the intended recipient can read the messages they exchange. The service provider (e.g., WhatsApp, Signal) cannot access the message content.</p>
                            
                            <h3>The Signal Protocol:</h3>
                            <p>The Signal Protocol is a state-of-the-art E2EE protocol that combines several cryptographic primitives:</p>
                            <ul>
                                <li><strong>Key Exchange:</strong> It uses an advanced Diffie-Hellman protocol (Extended Triple Diffie-Hellman, or X3DH) to establish initial keys between users.</li>
                                <li><strong>Forward Secrecy:</strong> It uses a "Double Ratchet" algorithm that generates a new session key for every single message. This means that if an attacker compromises a key, they can only read a very limited number of messages, not the entire past or future conversation. This property is also called "Future Secrecy".</li>
                                <li><strong>Confidentiality and Integrity:</strong> Messages are encrypted with AES and authenticated with HMAC.</li>
                            </ul>
                        `,
                        image: 'https://images.unsplash.com/photo-1611605698335-8b1569810432?w=800&h=400&fit=crop'
                    },
                    {
                        title: 'Full-Disk Encryption (FDE)',
                        content: `
                            <p>Full-disk encryption (FDE) protects data at rest by encrypting the entire storage device (e.g., SSD or HDD). If the device is lost or stolen, the data is unreadable without the key. Examples include BitLocker (Windows) and FileVault (macOS).</p>
                            
                            <h3>How it Works:</h3>
                            <ol>
                                <li>A strong symmetric cipher, almost always <strong>AES</strong> (often in XTS mode, designed for disk encryption), is used.</li>
                                <li>The encryption key is derived from the user's login password or passphrase using a strong <strong>Key Derivation Function (KDF)</strong> like Argon2 or PBKDF2.</li>
                                <li>In modern systems, the key may be further protected by a hardware component like a Trusted Platform Module (TPM), which securely stores the key and releases it only after successful user authentication.</li>
                            </ol>
                        `,
                        image: 'https://images.unsplash.com/photo-1593345418237-08b53b215753?w=800&h=400&fit=crop'
                    },
                    {
                        title: 'Public Key Infrastructure (PKI)',
                        content: `
                            <p>How do you trust that a public key actually belongs to the person or entity you think it does? This is the problem that Public Key Infrastructure (PKI) solves. PKI is the system of hardware, software, policies, and standards used to create, manage, distribute, and revoke digital certificates.</p>
                            
                            <h3>Core Components:</h3>
                            <ul>
                                <li><strong>Certificate Authority (CA):</strong> A trusted third party (like Let's Encrypt or DigiCert) that issues digital certificates. The CA verifies the identity of an entity (like a website) and then uses its own private key to sign that entity's public key, creating a certificate.</li>
                                <li><strong>Digital Certificate:</strong> A data structure that binds a public key to an identity (e.g., a domain name). It contains the public key, information about the owner, and the digital signature of the CA that issued it.</li>
                                <li><strong>Root CAs:</strong> Your operating system and browser come with a pre-installed list of public keys from trusted Root CAs. When you receive a certificate from a website, your browser checks if it was signed by a CA that it trusts. This chain of trust is what underpins HTTPS security.</li>
                            </ul>
                        `,
                        image: 'https://images.unsplash.com/photo-1573497121226-5b4a70482b88?w=800&h=400&fit=crop'
                    }
                ],
                codeExamples: [
                    {
                        title: 'Lab: Encrypt & Sign Emails with GPG',
                        language: 'bash',
                        code: `# --- Lab Task ---
# This lab requires you to have a GPG key (from Lesson 14) and a friend's public key.
# For this simulation, we'll use your own key as the recipient.

# Step 1: You'll need your key ID (email address).
MY_EMAIL="your-email@example.com"

# Step 2: Create a message file.
echo "This is a top-secret email message." > email.txt
echo "It is both encrypted for confidentiality and signed for authenticity." >> email.txt

# Step 3: Encrypt AND Sign the file.
# --encrypt: Encrypts the message with the recipient's public key.
# --sign: Signs the message with your private key.
# --armor: Creates text output instead of binary.
# --recipient: Specifies who the message is for.
gpg --encrypt --sign --armor --recipient "$MY_EMAIL" email.txt

# Step 4: Examine the output.
# You will see a file called 'email.txt.asc'.
# This file is an encrypted PGP message.
echo -e "\\n--- Encrypted and Signed Message ---"
cat email.txt.asc

# Step 5: Decrypt and Verify the message.
# GPG will automatically use your private key to decrypt and the sender's public key to verify.
# You will be prompted for your GPG passphrase.
echo -e "\\n--- Decrypting and Verifying ---"
gpg --decrypt email.txt.asc

# The output will show the original message and a confirmation of the valid signature.`
                    }
                ]
            },
            quiz: {
                passingScore: 75,
                questions: [
                    {
                        id: 1,
                        question: "What is the primary benefit of End-to-End Encryption (E2EE) in a messaging app?",
                        options: [
                            "It makes the app run faster.",
                            "It allows the service provider to scan messages for spam.",
                            "It ensures that only the sender and recipient can read the message content, not even the service provider.",
                            "It compresses the messages to save data."
                        ],
                        correct: 2,
                        explanation: "E2EE means the encryption and decryption happen only on the end-user devices. The servers in the middle only relay encrypted data and do not have the keys to read it."
                    },
                    {
                        id: 2,
                        question: "In a Public Key Infrastructure (PKI), what is the role of a Certificate Authority (CA)?",
                        options: [
                            "To invent new encryption algorithms.",
                            "To generate private keys for users.",
                            "To verify the identity of an entity and sign their public key, creating a trusted digital certificate.",
                            "To monitor network traffic for attacks."
                        ],
                        correct: 2,
                        explanation: "A CA acts as a trusted third party. Its primary function is to vouch for the link between a public key and a specific real-world identity (like a person or a website)."
                    },
                    {
                        id: 3,
                        question: "Full-disk encryption primarily protects against what type of threat?",
                        options: [
                            "Network eavesdropping while data is in transit.",
                            "Phishing attacks.",
                            "Data theft from a lost or stolen device (data at rest).",
                            "Viruses and malware."
                        ],
                        correct: 2,
                        explanation: "FDE protects 'data at rest.' If a laptop is stolen, an attacker cannot simply remove the hard drive and read its contents, because the entire drive is encrypted."
                    }
                ]
            }
        }
    ]
};
// =====================================================
// GLOBAL VARIABLES
// =====================================================
let currentUser = null;
let currentLessonIndex = 0;
let courseProgress = {};
let userStats = {};
let quizState = {
    currentQuestion: 0,
    answers: [],
    score: 0,
    isComplete: false
};

// Enhanced session tracking
let courseSession = {
    startTime: null,
    totalStudyTime: 0,
    lessonsStarted: 0,
    lessonsCompleted: 0,
    pageLoadTime: new Date(),
    interactionCount: 0,
    lastActivityTime: new Date()
};

// Music Player Variables
let audioPlayer = new Audio();

// Achievement notification system
let notificationQueue = [];
let isShowingNotification = false;

// =====================================================
// INITIALIZATION
// =====================================================
document.addEventListener('DOMContentLoaded', async () => {
    try {
        showLoadingScreen();
        await checkAuth();
        
        if (currentUser) {
            // Initialize session tracking
            startCourseSession();
            
            // Load course data and progress
            await loadCourseData();
            await loadUserProfile();
            await loadProgress();
            
            // Initialize UI
            initializeEventListeners();
            renderSidebar();
            loadLesson(currentLessonIndex);
            
            // Initialize additional features
            initMusicPlayer();
            addMusicIndicator();
            initializeActivityTracking();
            
            hideLoadingScreen();
        } else {
            openAuthModal();
        }
    } catch (error) {
        console.error('Error initializing course:', error);
        hideLoadingScreen();
        showToast('Failed to initialize course system', 'error');
    }
});

// =====================================================
// AUTHENTICATION SYSTEM
// =====================================================
async function checkAuth() {
    try {
        const { data: { session }, error } = await supabase.auth.getSession();
        
        if (error) {
            console.error('Auth error:', error);
            currentUser = null;
            openAuthModal();
            return;
        }

        if (!session) {
            currentUser = null;
            openAuthModal();
            return;
        }

        currentUser = session.user;
        updateUIWithUser();
    } catch (error) {
        console.error('Error checking auth:', error);
        currentUser = null;
        openAuthModal();
    }
}

function updateUIWithUser() {
    if (!currentUser) return;
    
    const name = currentUser.user_metadata?.full_name || currentUser.email.split('@')[0];
    const userElements = document.querySelectorAll('[data-user-name]');
    userElements.forEach(el => el.textContent = name);
}

// =====================================================
// USER PROFILE & STATS MANAGEMENT
// =====================================================
async function loadUserProfile() {
  try {
    // 🔍 Step 1: Try to fetch existing profile
    const { data: profile, error } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', currentUser.id)
      .single();

    if (error && error.code !== 'PGRST116') {
      throw error;
    }

    if (!profile) {
      // 🆕 Step 2: Create new profile if missing
      await createUserProfile();
    } else {
      // ✅ Step 3: Use existing profile
      userStats = profile;
      await updateLastActivity();
    }

  } catch (error) {
    console.error('❌ Error loading user profile:', error);
    showToast('Failed to load user profile', 'error');
  }
}
async function createUserProfile() {
    try {
        const newProfile = {
            id: currentUser.id,
            full_name: currentUser.user_metadata?.full_name || '',
            email: currentUser.email,
            level: 'Script Kiddie',
            total_points: 0,
            completed_courses: 0,
            current_streak: 0,
            total_certificates: 0,
            total_achievements: 0,
            sections_visited: 0,
            bonus_points: 0,
            in_progress_courses: 0,
            settings_changed: 0,
            midnight_sessions: 0,
            early_sessions: 0,
            weekend_sessions: 0,
            last_activity: new Date().toISOString(),
            created_at: new Date().toISOString()
        };

        const { error } = await supabase
            .from('profiles')
            .insert([newProfile]);

        if (!error) {
            userStats = newProfile;
            // Award first login achievement
            setTimeout(() => checkAndUnlockAchievement('first_login'), 1000);
        }
    } catch (error) {
        console.error('Error creating user profile:', error);
    }
}

async function updateLastActivity() {
    try {
        const now = new Date();
        
        // Update activity tracking
        courseSession.lastActivityTime = now;
        
        // Update database
        await supabase
            .from('profiles')
            .update({ 
                last_activity: now.toISOString()
            })
            .eq('id', currentUser.id);

        // Check time-based achievements
        await checkTimeBasedAchievements(now);
        
    } catch (error) {
        console.error('Error updating last activity:', error);
    }
}

// =====================================================
// COURSE SESSION MANAGEMENT
// =====================================================
function startCourseSession() {
    courseSession.startTime = new Date();
    courseSession.pageLoadTime = new Date();
    
    logUserActivity('course_session_start', {
        course_id: COURSE_DATA.id,
        course_title: COURSE_DATA.title,
        user_agent: navigator.userAgent,
        screen_resolution: `${screen.width}x${screen.height}`
    });
    
    // Check daily streak
    checkDailyStreak();
}

function initializeActivityTracking() {
    // Track page focus/blur for accurate study time
    document.addEventListener('visibilitychange', handleVisibilityChange);
    
    // Track user interactions
    ['click', 'keydown', 'scroll', 'mousemove'].forEach(event => {
        document.addEventListener(event, trackUserInteraction, { passive: true });
    });
    
    // Periodic activity updates
    setInterval(updateStudyTime, 60000); // Every minute
    
    // Save session data before page unload
    window.addEventListener('beforeunload', saveSessionData);
}

function handleVisibilityChange() {
    if (document.hidden) {
        courseSession.lastActivityTime = new Date();
    } else {
        // Page became visible again - update activity
        updateLastActivity();
    }
}

function trackUserInteraction() {
    courseSession.interactionCount++;
    courseSession.lastActivityTime = new Date();
    
    // Throttle activity updates
    if (courseSession.interactionCount % 50 === 0) {
        updateLastActivity();
    }
}

function updateStudyTime() {
    if (!courseSession.startTime || document.hidden) return;
    
    const now = new Date();
    const sessionDuration = now - courseSession.startTime;
    courseSession.totalStudyTime = Math.floor(sessionDuration / 1000 / 60); // in minutes
    
    // Update progress with study time
    saveProgress();
}

function saveSessionData() {
    if (!currentUser || !courseSession.startTime) return;
    
    const sessionData = {
        user_id: currentUser.id,
        course_id: COURSE_DATA.id,
        session_duration: courseSession.totalStudyTime,
        lessons_viewed: courseSession.lessonsStarted,
        lessons_completed: courseSession.lessonsCompleted,
        interactions: courseSession.interactionCount,
        session_date: courseSession.startTime.toISOString().split('T')[0]
    };
    
    // Store in localStorage as backup
    localStorage.setItem('course_session_backup', JSON.stringify(sessionData));
    
    // Try to save to database
    logUserActivity('course_session_end', sessionData);
}

// =====================================================
// COURSE DATA & PROGRESS MANAGEMENT
// =====================================================
async function loadCourseData() {
    try {
        // Update course info in UI
        document.getElementById('courseTitle').textContent = COURSE_DATA.title;
        document.getElementById('totalLessons').textContent = COURSE_DATA.lessons.length;
        
        // Log course access
        logUserActivity('course_access', {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title
        });
        
    } catch (error) {
        console.error('Error loading course data:', error);
    }
}

async function loadProgress() {
    try {
        // Get existing progress from database
        const { data, error } = await supabase
            .from('course_progress')
            .select('*')
            .eq('user_id', currentUser.id)
            .eq('course_id', COURSE_DATA.id)
            .single();

        if (error && error.code !== 'PGRST116') {
            throw error;
        }

        if (data) {
            courseProgress = JSON.parse(data.lesson_progress || '{}');
            currentLessonIndex = data.current_lesson || 0;
            
            // Update session tracking
            courseSession.lessonsStarted = Object.keys(courseProgress).length;
            courseSession.lessonsCompleted = Object.values(courseProgress).filter(p => p.completed).length;
        } else {
            // Initialize new progress
            courseProgress = {};
            currentLessonIndex = 0;
            await saveProgress();
            
            // Award first course start achievement
            await checkAndUnlockAchievement('first_course_start');
        }

        updateProgressDisplay();
        
    } catch (error) {
        console.error('Error loading progress:', error);
        showToast('Failed to load progress', 'error');
    }
}

async function saveProgress() {
    try {
        if (!currentUser) return;

        const now = new Date();
        const progressData = {
            user_id: currentUser.id,
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            current_lesson: currentLessonIndex,
            lesson_progress: JSON.stringify(courseProgress),
            progress: calculateOverallProgress(),
            lessons_completed: getCompletedLessonsCount(),
            lessons_started: Object.keys(courseProgress).length,
            study_time_minutes: courseSession.totalStudyTime,
            last_accessed: now.toISOString(),
            updated_at: now.toISOString()
        };

        // Upsert progress
        const { error } = await supabase
            .from('course_progress')
            .upsert([progressData]);

        if (error) throw error;

        // Update user stats
        await updateUserStats();
        
        updateProgressDisplay();

    } catch (error) {
        console.error('Error saving progress:', error);
        showToast('Failed to save progress', 'error');
    }
}

async function updateUserStats() {
    try {
        // Get all course progress for this user
        const { data: allProgress, error } = await supabase
            .from('course_progress')
            .select('progress, course_id, study_time_minutes')
            .eq('user_id', currentUser.id);

        if (error) throw error;

        // Calculate stats
        const completedCourses = allProgress?.filter(p => p.progress >= 100).length || 0;
        const inProgressCourses = allProgress?.filter(p => p.progress > 0 && p.progress < 100).length || 0;
        const totalStudyTime = allProgress?.reduce((sum, p) => sum + (p.study_time_minutes || 0), 0) || 0;

        // Calculate points (500 per completed course + achievement points)
        const coursePoints = completedCourses * 500;
        const bonusPoints = userStats.bonus_points || 0;
        const totalPoints = coursePoints + bonusPoints;

        // Update profile
        const updateData = {
            completed_courses: completedCourses,
            in_progress_courses: inProgressCourses,
            total_points: totalPoints,
            total_study_time: totalStudyTime,
            last_activity: new Date().toISOString()
        };

        const { error: updateError } = await supabase
            .from('profiles')
            .update(updateData)
            .eq('id', currentUser.id);

        if (updateError) throw updateError;

        // Update local stats
        Object.assign(userStats, updateData);

    } catch (error) {
        console.error('Error updating user stats:', error);
    }
}

function calculateOverallProgress() {
    const completedLessons = getCompletedLessonsCount();
    return Math.round((completedLessons / COURSE_DATA.lessons.length) * 100);
}

function getCompletedLessonsCount() {
    return Object.values(courseProgress).filter(lesson => lesson.completed).length;
}

function updateProgressDisplay() {
    const completedCount = getCompletedLessonsCount();
    const progressPercent = calculateOverallProgress();
    
    // Update UI elements
    const elements = {
        'completedLessons': completedCount,
        'courseProgressPercent': `${progressPercent}%`
    };
    
    Object.entries(elements).forEach(([id, value]) => {
        const element = document.getElementById(id);
        if (element) element.textContent = value;
    });
    
    // Update progress bar
    const progressBar = document.getElementById('courseProgressFill');
    if (progressBar) progressBar.style.width = `${progressPercent}%`;
}

// =====================================================
// LESSON MANAGEMENT
// =====================================================
function loadLesson(index) {
    if (index < 0 || index >= COURSE_DATA.lessons.length) return;

    const lesson = COURSE_DATA.lessons[index];
    currentLessonIndex = index;

    // Mark lesson as started and track activity
    if (!courseProgress[lesson.id]) {
        courseProgress[lesson.id] = { 
            started: true, 
            completed: false,
            startedAt: new Date().toISOString(),
            timeSpent: 0
        };
        
        courseSession.lessonsStarted++;
        saveProgress();
        
        // Log lesson start
        logUserActivity('lesson_start', {
            lesson_id: lesson.id,
            lesson_title: lesson.title,
            lesson_index: index
        });
    }

    // Update lesson start time for time tracking
    courseProgress[lesson.id].currentSessionStart = new Date();

    // Update sidebar and navigation
    renderSidebar();
    updateNavigationButtons();

    // Update header info
    updateLessonHeader(lesson, index);

    // Render lesson content
    renderLessonContent(lesson);

    // Smooth scroll and animations
    window.scrollTo({ top: 0, behavior: 'smooth' });
    document.getElementById('contentBody').scrollTop = 0;

    const contentBody = document.getElementById('contentBody');
    contentBody.classList.add('fade-in');
    setTimeout(() => contentBody.classList.remove('fade-in'), 500);
    
    // Check lesson-based achievements
    checkLessonAchievements(index + 1);
}

function updateLessonHeader(lesson, index) {
    const elements = {
        'currentLessonNumber': index + 1,
        'currentLessonTitle': lesson.title,
        'navInfo': `Lesson ${index + 1} of ${COURSE_DATA.lessons.length}`
    };
    
    Object.entries(elements).forEach(([id, value]) => {
        const element = document.getElementById(id);
        if (element) element.textContent = value;
    });
}

function renderSidebar() {
    const lessonNav = document.getElementById('lessonNav');
    if (!lessonNav) return;
    
    lessonNav.innerHTML = '';

    COURSE_DATA.lessons.forEach((lesson, index) => {
        const lessonItem = document.createElement('div');
        lessonItem.className = 'lesson-item';
        
        // Determine lesson status
        const lessonProgress = courseProgress[lesson.id];
        const isCompleted = lessonProgress?.completed || false;
        const isInProgress = lessonProgress?.started || false;
        const isLocked = !isCompleted && !canAccessLesson(index);
        const isActive = index === currentLessonIndex;

        // Apply status classes
        if (isCompleted) lessonItem.classList.add('completed');
        if (isLocked) lessonItem.classList.add('locked');
        if (isActive) lessonItem.classList.add('active');

        // Determine status display
        let statusClass = 'not-started';
        let statusIcon = index + 1;
        
        if (isCompleted) {
            statusClass = 'completed';
            statusIcon = '✓';
        } else if (isInProgress) {
            statusClass = 'in-progress';
            statusIcon = '◐';
        }

        // Create lesson item HTML
        lessonItem.innerHTML = `
            <div class="lesson-status ${statusClass}">${statusIcon}</div>
            <div class="lesson-info">
                <div class="lesson-title">${lesson.title}</div>
                <div class="lesson-meta">
                    ${isCompleted ? 'Completed' : 
                      isInProgress ? 'In Progress' : 
                      isLocked ? 'Locked' : 'Not Started'}
                </div>
            </div>
            <div class="lesson-duration">${lesson.duration}</div>
        `;

        // Add click handler if not locked
        if (!isLocked) {
            lessonItem.addEventListener('click', () => {
                if (index !== currentLessonIndex) {
                    // Track lesson time before switching
                    trackLessonTime();
                    
                    currentLessonIndex = index;
                    loadLesson(index);
                    closeSidebar();
                }
            });
        }

        lessonNav.appendChild(lessonItem);
    });
}

function canAccessLesson(index) {
    if (index === 0) return true; // First lesson always accessible
    
    // Can access if previous lesson is completed
    const previousLessonId = COURSE_DATA.lessons[index - 1].id;
    return courseProgress[previousLessonId]?.completed || false;
}

function trackLessonTime() {
    const currentLesson = COURSE_DATA.lessons[currentLessonIndex];
    const lessonProgress = courseProgress[currentLesson.id];
    
    if (lessonProgress?.currentSessionStart) {
        const sessionTime = Math.floor((new Date() - new Date(lessonProgress.currentSessionStart)) / 1000 / 60);
        lessonProgress.timeSpent = (lessonProgress.timeSpent || 0) + sessionTime;
        delete lessonProgress.currentSessionStart;
    }
}

// =====================================================
// LESSON CONTENT RENDERING
// =====================================================
function renderLessonContent(lesson) {
    const contentContainer = document.getElementById('lessonContent');
    if (!contentContainer) return;
    
    let contentHTML = `
        <div class="content-section">
            <h2>Learning Objectives</h2>
            <ul>
                ${lesson.objectives.map(obj => `<li>${obj}</li>`).join('')}
            </ul>
        </div>
        
        <div class="content-section">
            <h2>Overview</h2>
            <p>${lesson.content.overview}</p>
        </div>
    `;

    // Render content sections
    lesson.content.sections.forEach(section => {
        contentHTML += `
            <div class="content-section">
                <h2>${section.title}</h2>
                ${section.content}
                ${section.image ? `<img src="${section.image}" alt="${section.title}" class="content-image" loading="lazy">` : ''}
            </div>
        `;
    });

    // Render code examples
    if (lesson.content.codeExamples && lesson.content.codeExamples.length > 0) {
        contentHTML += `<div class="content-section"><h2>Code Examples</h2></div>`;
        
        lesson.content.codeExamples.forEach((example, index) => {
            const codeId = `code-${lesson.id}-${index}`;
            contentHTML += `
                <div class="code-section">
                    <div class="code-header">
                        <span class="code-title">${example.title}</span>
                        <button class="copy-btn" onclick="copyCode('${codeId}')">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <pre class="code-block"><code id="${codeId}" class="language-${example.language}">${escapeHtml(example.code)}</code></pre>
                </div>
            `;
        });
    }

    // Render quiz
    contentHTML += renderQuiz(lesson.quiz);

    contentContainer.innerHTML = contentHTML;

    // Highlight code syntax if Prism is available
    setTimeout(() => {
        if (window.Prism) {
            Prism.highlightAll();
        }
    }, 100);
}

// =====================================================
// QUIZ SYSTEM
// =====================================================
function renderQuiz(quiz) {
    const currentLessonProgress = courseProgress[COURSE_DATA.lessons[currentLessonIndex].id];
    const isCompleted = currentLessonProgress?.completed || false;
    
    let quizHTML = `
        <div class="quiz-section" id="quizSection">
            <div class="quiz-header">
                <h2 class="quiz-title">
                    <i class="fas fa-clipboard-check"></i>
                    Knowledge Check
                </h2>
                <p class="quiz-info">
                    Complete this quiz with ${quiz.passingScore}% or higher to unlock the next lesson.
                </p>
            </div>
    `;

    if (isCompleted) {
        const savedScore = currentLessonProgress.quizScore || 0;
        quizHTML += `
            <div class="quiz-results show">
                <div class="quiz-score pass">${savedScore}%</div>
                <div class="quiz-message">
                    <strong>Lesson Completed!</strong><br>
                    You've successfully passed this lesson's quiz.
                </div>
            </div>
        `;
    } else {
        // Render quiz questions
        quiz.questions.forEach((question, qIndex) => {
            quizHTML += `
                <div class="quiz-question ${qIndex === 0 ? 'active' : ''}" data-question="${qIndex}">
                    <div class="question-header">
                        <span class="question-number">Question ${qIndex + 1}</span>
                        <span class="question-progress">${qIndex + 1}/${quiz.questions.length}</span>
                    </div>
                    <div class="question-text">${question.question}</div>
                    <div class="question-options">
                        ${question.options.map((option, oIndex) => `
                            <div class="option" data-option="${oIndex}" onclick="selectOption(${qIndex}, ${oIndex})">
                                <span class="option-letter">${String.fromCharCode(65 + oIndex)}</span>
                                <span class="option-text">${option}</span>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        });

        quizHTML += `
            <div class="quiz-controls">
                <button class="btn btn-secondary" id="prevQuestionBtn" onclick="previousQuestion()" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <div>
                    <button class="btn btn-secondary" id="nextQuestionBtn" onclick="nextQuestion()" disabled>
                        Next
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <button class="btn btn-primary" id="submitQuizBtn" onclick="submitQuiz()" style="display: none;">
                        <i class="fas fa-check"></i>
                        Submit Quiz
                    </button>
                </div>
            </div>

            <div class="quiz-results" id="quizResults">
                <div class="quiz-score" id="quizScore">0%</div>
                <div class="quiz-message" id="quizMessage"></div>
                <div class="quiz-actions">
                    <button class="btn btn-primary" id="continueBtn" onclick="completeLesson()" style="display: none;">
                        <i class="fas fa-arrow-right"></i>
                        Continue to Next Lesson
                    </button>
                    <button class="btn btn-secondary" onclick="retakeQuiz()">
                        <i class="fas fa-redo"></i>
                        Retake Quiz
                    </button>
                </div>
            </div>
        `;
    }

    quizHTML += '</div>';
    return quizHTML;
}

// Quiz interaction functions
function selectOption(questionIndex, optionIndex) {
    // Clear previous selections
    document.querySelectorAll(`[data-question="${questionIndex}"] .option`).forEach(opt => {
        opt.classList.remove('selected');
    });

    // Select current option
    const selectedOption = document.querySelector(`[data-question="${questionIndex}"] [data-option="${optionIndex}"]`);
    selectedOption.classList.add('selected');

    // Store answer
    quizState.answers[questionIndex] = optionIndex;

    // Update navigation
    const isLastQuestion = questionIndex === COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length - 1;
    if (isLastQuestion) {
        document.getElementById('submitQuizBtn').style.display = 'inline-flex';
        document.getElementById('nextQuestionBtn').style.display = 'none';
    } else {
        document.getElementById('nextQuestionBtn').disabled = false;
    }
}

function nextQuestion() {
    const currentQuestionEl = document.querySelector('.quiz-question.active');
    const nextQuestionEl = currentQuestionEl.nextElementSibling;
    
    if (nextQuestionEl && nextQuestionEl.classList.contains('quiz-question')) {
        currentQuestionEl.classList.remove('active');
        nextQuestionEl.classList.add('active');
        quizState.currentQuestion++;
        updateQuizNavigation();
    }
}

function previousQuestion() {
    const currentQuestionEl = document.querySelector('.quiz-question.active');
    const prevQuestionEl = currentQuestionEl.previousElementSibling;
    
    if (prevQuestionEl && prevQuestionEl.classList.contains('quiz-question')) {
        currentQuestionEl.classList.remove('active');
        prevQuestionEl.classList.add('active');
        quizState.currentQuestion--;
        updateQuizNavigation();
    }
}

function updateQuizNavigation() {
    const totalQuestions = COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length;
    const prevBtn = document.getElementById('prevQuestionBtn');
    const nextBtn = document.getElementById('nextQuestionBtn');
    const submitBtn = document.getElementById('submitQuizBtn');

    prevBtn.disabled = quizState.currentQuestion === 0;
    
    const hasAnswer = quizState.answers[quizState.currentQuestion] !== undefined;
    const isLastQuestion = quizState.currentQuestion === totalQuestions - 1;
    
    if (isLastQuestion) {
        nextBtn.style.display = 'none';
        submitBtn.style.display = hasAnswer ? 'inline-flex' : 'none';
    } else {
        nextBtn.style.display = 'inline-flex';
        nextBtn.disabled = !hasAnswer;
        submitBtn.style.display = 'none';
    }
}

async function submitQuiz() {
    const lesson = COURSE_DATA.lessons[currentLessonIndex];
    const quiz = lesson.quiz;
    let correctAnswers = 0;

    // Hide questions and controls
    document.querySelectorAll('.quiz-question').forEach(q => q.style.display = 'none');
    document.querySelector('.quiz-controls').style.display = 'none';

    // Calculate score and highlight answers
    quiz.questions.forEach((question, index) => {
        const userAnswer = quizState.answers[index];
        const correctAnswer = question.correct;
        const isCorrect = userAnswer === correctAnswer;
        
        if (isCorrect) correctAnswers++;

        // Highlight answers
        const questionEl = document.querySelector(`[data-question="${index}"]`);
        const options = questionEl.querySelectorAll('.option');
        
        options[correctAnswer].classList.add('correct');
        if (userAnswer !== correctAnswer && userAnswer !== undefined) {
            options[userAnswer].classList.add('incorrect');
        }
    });

    const score = Math.round((correctAnswers / quiz.questions.length) * 100);
    const passed = score >= quiz.passingScore;

    // Update quiz results UI
    const quizScore = document.getElementById('quizScore');
    const quizMessage = document.getElementById('quizMessage');
    const quizActions = document.querySelector('.quiz-actions');

    quizScore.textContent = `${score}%`;
    quizScore.className = `quiz-score ${passed ? 'pass' : 'fail'}`;

    if (passed) {
        quizMessage.innerHTML = `
            <strong>Congratulations!</strong><br>
            You passed with ${score}%. You can now proceed to the next lesson.
        `;
        
        quizActions.innerHTML = `
            <button class="btn btn-primary" onclick="completeLesson()">
                <i class="fas fa-arrow-right"></i>
                Continue to Next Lesson
            </button>
        `;
        
        // Mark lesson as completed
        await markLessonComplete(score);
        
    } else {
        quizMessage.innerHTML = `
            <strong>Not quite there yet.</strong><br>
            You scored ${score}%. You need ${quiz.passingScore}% to pass. Review the material and try again.
        `;
        
        quizActions.innerHTML = `
            <button class="btn btn-secondary" onclick="retakeQuiz()">
                <i class="fas fa-redo"></i>
                Retake Quiz
            </button>
        `;
    }

    document.getElementById('quizResults').classList.add('show');
    
    // Log quiz completion
    logUserActivity('quiz_completed', {
        lesson_id: lesson.id,
        lesson_title: lesson.title,
        score: score,
        passed: passed,
        attempts: (courseProgress[lesson.id]?.quizAttempts || 0) + 1
    });

    // Scroll to results
    document.getElementById('quizResults').scrollIntoView({ behavior: 'smooth' });
}

function retakeQuiz() {
    // Reset quiz state
    quizState = {
        currentQuestion: 0,
        answers: [],
        score: 0,
        isComplete: false
    };

    // Track quiz retry
    const lessonId = COURSE_DATA.lessons[currentLessonIndex].id;
    if (!courseProgress[lessonId]) courseProgress[lessonId] = {};
    courseProgress[lessonId].quizAttempts = (courseProgress[lessonId].quizAttempts || 0) + 1;

    // Reload lesson content
    loadLesson(currentLessonIndex);
    
    // Scroll to quiz
    setTimeout(() => {
        document.getElementById('quizSection').scrollIntoView({ behavior: 'smooth' });
    }, 500);
}

async function markLessonComplete(score) {
    const lesson = COURSE_DATA.lessons[currentLessonIndex];
    const lessonId = lesson.id;
    
    // Track lesson completion time
    trackLessonTime();
    
    // Update lesson progress
    courseProgress[lessonId] = {
        ...courseProgress[lessonId],
        completed: true,
        quizScore: score,
        completedAt: new Date().toISOString(),
        finalScore: score
    };

    // Update session tracking
    courseSession.lessonsCompleted++;

    // Save progress to database
    await saveProgress();
    
    // Update UI
    renderSidebar();
    updateNavigationButtons();

    // Check various achievements
    await checkLessonCompletionAchievements();
    await checkPerfectScoreAchievements(score);
    await checkStudyTimeAchievements();
    
    // Log lesson completion
    logUserActivity('lesson_completed', {
        lesson_id: lessonId,
        lesson_title: lesson.title,
        final_score: score,
        time_spent: courseProgress[lessonId].timeSpent || 0,
        lesson_number: currentLessonIndex + 1
    });
    
    showToast('Lesson completed successfully!', 'success');
}

async function completeLesson() {
    if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
        // Move to next lesson
        currentLessonIndex++;
        loadLesson(currentLessonIndex);
        
    } else {
        // Course completion
        await completeCourse();
    }
}

async function completeCourse() {
    try {
        const completionTime = courseSession.totalStudyTime;
        
        // Update course progress to 100% completed
        await supabase
            .from('course_progress')
            .update({
                progress: 100,
                completed_at: new Date().toISOString(),
                completion_time_minutes: completionTime
            })
            .eq('user_id', currentUser.id)
            .eq('course_id', COURSE_DATA.id);

        // Award course completion achievements
        await checkAndUnlockAchievement('course_completion_1');
        await checkSpeedCompletionAchievements(completionTime);
        await checkCourseStreakAchievements();
        
        // Update user stats
        await updateUserStats();
        
        // Show completion message
        showToast('Congratulations! Course completed successfully!', 'certificate');
        
        // Log course completion
        logUserActivity('course_completed', {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            completion_time_minutes: completionTime,
            total_lessons: COURSE_DATA.lessons.length,
            average_quiz_score: calculateAverageQuizScore()
        });
        
        // Redirect to dashboard after delay
        setTimeout(() => {
            window.location.href = '/dashboard';
        }, 3000);
        
    } catch (error) {
        console.error('Error completing course:', error);
        showToast('Error marking course as complete', 'error');
    }
}

// =====================================================
// ACHIEVEMENT INTEGRATION SYSTEM
// =====================================================
async function checkAndUnlockAchievement(achievementId, skipNotification = false) {
    try {
        // Prevent duplicate checks
        const cacheKey = `achievement_${achievementId}_${currentUser.id}`;
        if (sessionStorage.getItem(cacheKey)) return false;

        // Check if already unlocked
        const { data: existing, error } = await supabase
            .from('user_achievements')
            .select('id')
            .eq('user_id', currentUser.id)
            .eq('achievement_id', achievementId)
            .single();

        if (existing) {
            sessionStorage.setItem(cacheKey, 'true');
            return false;
        }

        // Award achievement
        const achievementData = {
            user_id: currentUser.id,
            achievement_id: achievementId,
            unlocked_at: new Date().toISOString(),
            points_awarded: getAchievementPoints(achievementId),
            context: 'course_system'
        };

        const { data, error: insertError } = await supabase
            .from('user_achievements')
            .insert([achievementData])
            .select()
            .single();

        if (insertError) {
            if (insertError.code === '23505') return false; // Already exists
            throw insertError;
        }

        // Update user points
      await supabase.rpc('increment_user_stats', {
  user_id_param: currentUser.id,
  points_to_add: achievementData.points_awarded,
  achievements_to_add: 1
});
        // Cache and queue notification
        sessionStorage.setItem(cacheKey, 'true');
        
        if (!skipNotification) {
            queueAchievementNotification({
                id: achievementId,
                name: getAchievementName(achievementId),
                description: getAchievementDescription(achievementId),
                points: achievementData.points_awarded,
                rarity: getAchievementRarity(achievementId),
                icon: getAchievementIcon(achievementId)
            });
        }

        return true;

    } catch (error) {
        console.error('Error unlocking achievement:', error);
        return false;
    }
}

// Helper functions for achievement data (replace with your actual achievement definitions)
function getAchievementPoints(id) {
    const pointsMap = {
        'first_course_start': 75,
        'first_lesson': 100,
        'course_completion_1': 500,
        'perfect_score': 250,
        'speed_demon': 750,
        'marathon_learner': 500,
        'night_owl': 200,
        'early_bird': 200,
        'weekend_warrior': 150,
        // Add more as needed
    };
    return pointsMap[id] || 100;
}

function getAchievementName(id) {
    const nameMap = {
        'first_course_start': 'Learning Initiated',
        'first_lesson': 'First Steps',
        'course_completion_1': 'Course Conqueror',
        'perfect_score': 'Perfectionist',
        'speed_demon': 'Speed Demon',
        // Add more as needed
    };
    return nameMap[id] || 'Achievement Unlocked';
}

function getAchievementDescription(id) {
    const descMap = {
        'first_course_start': 'Start your first cybersecurity course',
        'first_lesson': 'Complete your first lesson',
        'course_completion_1': 'Complete your first course',
        'perfect_score': 'Score 100% on any quiz',
        'speed_demon': 'Complete a course in under 2 hours',
        // Add more as needed
    };
    return descMap[id] || 'Achievement description';
}

function getAchievementRarity(id) {
    const rarityMap = {
        'first_course_start': 'common',
        'first_lesson': 'bronze',
        'course_completion_1': 'silver',
        'perfect_score': 'gold',
        'speed_demon': 'legendary',
        // Add more as needed
    };
    return rarityMap[id] || 'common';
}

function getAchievementIcon(id) {
    const iconMap = {
        'first_course_start': 'fas fa-play',
        'first_lesson': 'fas fa-baby',
        'course_completion_1': 'fas fa-trophy',
        'perfect_score': 'fas fa-star',
        'speed_demon': 'fas fa-rocket',
        // Add more as needed
    };
    return iconMap[id] || 'fas fa-award';
}

async function checkLessonAchievements(lessonNumber) {
    if (lessonNumber === 1) {
        await checkAndUnlockAchievement('first_lesson');
    }
    
    // Check if user has completed multiple lessons in one day
    const today = new Date().toISOString().split('T')[0];
    const todayCompletions = Object.values(courseProgress).filter(p => 
        p.completed && p.completedAt?.startsWith(today)
    ).length;
    
    if (todayCompletions >= 3) {
        await checkAndUnlockAchievement('lesson_marathon');
    }
}

async function checkLessonCompletionAchievements() {
    const completedCount = getCompletedLessonsCount();
    
    // Lesson-based achievements
    const lessonMilestones = [1, 5, 10, 25, 50, 100];
    for (const milestone of lessonMilestones) {
        if (completedCount >= milestone) {
            await checkAndUnlockAchievement(`lessons_${milestone}`);
        }
    }
    
    // Course completion achievements
    if (completedCount === COURSE_DATA.lessons.length) {
        await checkAndUnlockAchievement('course_completion_1');
        
        // Check for additional course completion achievements
        const { data: allCourses } = await supabase
            .from('course_progress')
            .select('course_id')
            .eq('user_id', currentUser.id)
            .eq('progress', 100);
        
        const totalCompleted = allCourses?.length || 0;
        
        const courseMilestones = [1, 5, 10, 25];
        for (const milestone of courseMilestones) {
            if (totalCompleted >= milestone) {
                await checkAndUnlockAchievement(`course_completion_${milestone}`);
            }
        }
    }
}

async function checkPerfectScoreAchievements(score) {
    if (score === 100) {
        await checkAndUnlockAchievement('perfect_score');
        
        // Check for consecutive perfect scores
        const recentScores = Object.values(courseProgress)
            .filter(p => p.completed && p.quizScore)
            .slice(-5) // Last 5 completed
            .map(p => p.quizScore);
        
        if (recentScores.length >= 3 && recentScores.every(s => s === 100)) {
            await checkAndUnlockAchievement('perfectionist_streak');
        }
    }
}

async function checkSpeedCompletionAchievements(completionTime) {
    // Speed demon: Complete course in under 2 hours (120 minutes)
    if (completionTime <= 120) {
        await checkAndUnlockAchievement('speed_demon');
    }
    
    // Quick learner: Complete course in under 4 hours (240 minutes)
    if (completionTime <= 240) {
        await checkAndUnlockAchievement('quick_learner');
    }
}

async function checkStudyTimeAchievements() {
    const totalTime = courseSession.totalStudyTime;
    
    // Marathon learner: Study for 8+ hours in a course session
    if (totalTime >= 480) { // 8 hours
        await checkAndUnlockAchievement('marathon_learner');
    }
    
    // Dedicated learner: Study for 4+ hours
    if (totalTime >= 240) { // 4 hours
        await checkAndUnlockAchievement('dedicated_learner');
    }
}

async function checkCourseStreakAchievements() {
    try {
        // Check for consecutive course completions
        const { data: recentCourses, error } = await supabase
            .from('course_progress')
            .select('completed_at, course_id')
            .eq('user_id', currentUser.id)
            .eq('progress', 100)
            .order('completed_at', { ascending: false })
            .limit(10);

        if (error || !recentCourses) return;

        // Check for courses completed on consecutive days
        let consecutiveDays = 1;
        for (let i = 1; i < recentCourses.length; i++) {
            const prevDate = new Date(recentCourses[i-1].completed_at).toDateString();
            const currentDate = new Date(recentCourses[i].completed_at).toDateString();
            const dayDiff = Math.abs(new Date(prevDate) - new Date(currentDate)) / (1000 * 60 * 60 * 24);
            
            if (dayDiff <= 1) {
                consecutiveDays++;
            } else {
                break;
            }
        }

        if (consecutiveDays >= 3) {
            await checkAndUnlockAchievement('learning_streak');
        }

    } catch (error) {
        console.error('Error checking course streak achievements:', error);
    }
}

// =====================================================
// TIME-BASED ACHIEVEMENTS
// =====================================================
async function checkTimeBasedAchievements(timestamp) {
    const hour = timestamp.getHours();
    const dayOfWeek = timestamp.getDay();

    // Night owl (after midnight, before 6 AM)
    if (hour >= 0 && hour < 6) {
        await incrementTimeBasedCounter('midnight_sessions', 'night_owl');
    }

    // Early bird (4 AM to 6 AM)
    if (hour >= 4 && hour < 6) {
        await incrementTimeBasedCounter('early_sessions', 'early_bird');
    }

    // Weekend warrior (Saturday = 6, Sunday = 0)
    if (dayOfWeek === 0 || dayOfWeek === 6) {
        await incrementTimeBasedCounter('weekend_sessions', 'weekend_warrior');
    }
}

async function incrementTimeBasedCounter(counterType, achievementId) {
    try {
        const dateStr = new Date().toISOString().split('T')[0];
        const cacheKey = `${counterType}_${currentUser.id}_${dateStr}`;

        // Prevent multiple increments per day
        if (sessionStorage.getItem(cacheKey)) return;

        // Update counter
        await supabase.rpc('increment_profile_counter', {
  user_id_param: currentUser.id,
  counter_field: counterType,
  increment_value: 1
});

        // Cache to prevent double counting
        sessionStorage.setItem(cacheKey, 'true');

        // Check related achievement
        if (achievementId) {
            await checkAndUnlockAchievement(achievementId, true);
        }

    } catch (error) {
        console.error(`Error incrementing ${counterType}:`, error);
    }
}

async function checkDailyStreak() {
    try {
        const { data: profile, error } = await supabase
            .from('profiles')
            .select('last_activity, current_streak, last_streak_date')
            .eq('id', currentUser.id)
            .single();

        if (error) throw error;

        const now = new Date();
        const today = now.toDateString();
        const lastActivity = profile.last_activity ? new Date(profile.last_activity) : null;
        const lastStreakDate = profile.last_streak_date ? new Date(profile.last_streak_date).toDateString() : null;

        let newStreak = profile.current_streak || 0;
        let shouldUpdateStreak = false;

        if (!lastActivity) {
            // First time user
            newStreak = 1;
            shouldUpdateStreak = true;
        } else {
            const daysSinceLastActivity = Math.floor((now - lastActivity) / (1000 * 60 * 60 * 24));
            
            if (lastStreakDate === today) {
                // Already counted today's streak
                return newStreak;
            } else if (daysSinceLastActivity === 1 || (daysSinceLastActivity === 0 && lastStreakDate !== today)) {
                // Consecutive day or same day but not counted yet
                newStreak += 1;
                shouldUpdateStreak = true;
            } else if (daysSinceLastActivity > 1) {
                // Streak broken
                newStreak = 1;
                shouldUpdateStreak = true;
            }
        }

        if (shouldUpdateStreak) {
            await supabase
                .from('profiles')
                .update({
                    current_streak: newStreak,
                    last_activity: now.toISOString(),
                    last_streak_date: now.toISOString()
                })
                .eq('id', currentUser.id);

            userStats.current_streak = newStreak;
            
            showToast(`Daily streak: ${newStreak} days!`, 'success');
            await checkStreakAchievements(newStreak);
        }

        return newStreak;
        
    } catch (error) {
        console.error('Error checking daily streak:', error);
        return 0;
    }
}

async function checkStreakAchievements(currentStreak) {
    const streakMilestones = [3, 7, 14, 30, 100, 365];
    
    for (const milestone of streakMilestones) {
        if (currentStreak >= milestone) {
            await checkAndUnlockAchievement(`streak_${milestone}`);
        }
    }
}

// =====================================================
// USER ACTIVITY LOGGING
// =====================================================
async function logUserActivity(activityType, metadata = {}) {
    try {
        const now = new Date();
        
        const activityData = {
            user_id: currentUser.id,
            activity_type: activityType,
            timestamp: now.toISOString(),
            course_id: COURSE_DATA.id,
            lesson_index: currentLessonIndex,
            session_duration: courseSession.totalStudyTime,
            metadata: JSON.stringify(metadata),
            created_at: now.toISOString()
        };

        // Try to log to activities table
        const { error } = await supabase
            .from('user_activities')
            .insert([activityData]);

        if (error && error.code !== '42P01') {
            console.warn('Activity logging failed:', error.message);
        }

        // Always update last activity in profile
        await supabase
            .from('profiles')
            .update({ last_activity: now.toISOString() })
            .eq('id', currentUser.id);

    } catch (error) {
        console.error('Error logging user activity:', error);
    }
}

// =====================================================
// NAVIGATION SYSTEM
// =====================================================
function updateNavigationButtons() {
    const prevBtn = document.getElementById('prevLessonBtn');
    const nextBtn = document.getElementById('nextLessonBtn');
    
    if (!prevBtn || !nextBtn) return;

    // Previous button
    prevBtn.disabled = currentLessonIndex === 0;
    
    // Next button logic
    const isLastLesson = currentLessonIndex === COURSE_DATA.lessons.length - 1;
    const canGoNext = currentLessonIndex < COURSE_DATA.lessons.length - 1 && 
                     canAccessLesson(currentLessonIndex + 1);
    
    if (isLastLesson) {
        const isCurrentCompleted = courseProgress[COURSE_DATA.lessons[currentLessonIndex].id]?.completed;
        nextBtn.disabled = !isCurrentCompleted;
        nextBtn.innerHTML = '<i class="fas fa-trophy"></i> Complete Course';
    } else {
        nextBtn.disabled = !canGoNext;
        nextBtn.innerHTML = 'Next <i class="fas fa-chevron-right"></i>';
    }
}

// Navigation button event handlers
function goToPreviousLesson() {
    if (currentLessonIndex > 0) {
        trackLessonTime(); // Track time spent on current lesson
        currentLessonIndex--;
        loadLesson(currentLessonIndex);
    }
}

function goToNextLesson() {
    if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
        const canGoNext = canAccessLesson(currentLessonIndex + 1);
        if (canGoNext) {
            trackLessonTime();
            currentLessonIndex++;
            loadLesson(currentLessonIndex);
        } else {
            showToast('Complete the current lesson quiz to proceed', 'warning');
        }
    } else {
        // Complete course
        completeCourse();
    }
}

// =====================================================
// SIDEBAR FUNCTIONS
// =====================================================
function toggleSidebar() {
    const sidebar = document.getElementById('sidebar');
    const overlay = document.getElementById('sidebarOverlay');
    
    if (sidebar) sidebar.classList.toggle('open');
    if (overlay) overlay.classList.toggle('active');
}

function closeSidebar() {
    const sidebar = document.getElementById('sidebar');
    const overlay = document.getElementById('sidebarOverlay');
    
    if (sidebar) sidebar.classList.remove('open');
    if (overlay) overlay.classList.remove('active');
}

// =====================================================
// ACHIEVEMENT NOTIFICATION SYSTEM
// =====================================================
function queueAchievementNotification(achievement) {
    notificationQueue.push(achievement);
    processNotificationQueue();
}

function processNotificationQueue() {
    if (isShowingNotification || notificationQueue.length === 0) return;

    isShowingNotification = true;
    const achievement = notificationQueue.shift();
    showAchievementNotification(achievement);

    const duration = achievement.rarity === 'mythic' ? 8000 :
                     achievement.rarity === 'legendary' ? 7000 : 6000;

    setTimeout(() => {
        isShowingNotification = false;
        processNotificationQueue();
    }, duration + 500);
}

function showAchievementNotification(achievement) {
    const notification = document.getElementById('achievementNotification');
    if (!notification) return;

    const icon = document.getElementById('notificationIcon');
    const title = document.getElementById('notificationTitle');
    const description = document.getElementById('notificationDescription');
    const points = document.getElementById('notificationPoints');

    if (icon) {
        icon.innerHTML = `<i class="${achievement.icon}"></i>`;
        icon.className = `notification-icon ${achievement.rarity}`;
    }
    if (title) title.textContent = achievement.name;
    if (description) description.textContent = achievement.description;
    if (points) points.textContent = `+${achievement.points} Points`;

    notification.className = `achievement-notification ${achievement.rarity}`;
    notification.classList.add('show');

    const duration = achievement.rarity === 'mythic' ? 8000 :
                     achievement.rarity === 'legendary' ? 7000 : 6000;

    setTimeout(() => {
        notification.classList.remove('show');
    }, duration);
}

// =====================================================
// UTILITY FUNCTIONS
// =====================================================
function calculateAverageQuizScore() {
    const scores = Object.values(courseProgress)
        .filter(p => p.completed && p.quizScore)
        .map(p => p.quizScore);
    
    if (scores.length === 0) return 0;
    return Math.round(scores.reduce((sum, score) => sum + score, 0) / scores.length);
}

async function resetProgress() {
    if (!confirm('Are you sure you want to reset your progress? This action cannot be undone.')) {
        return;
    }

    try {
        // Track lesson time before reset
        trackLessonTime();
        
        // Reset local state
        courseProgress = {};
        currentLessonIndex = 0;
        courseSession = {
            startTime: new Date(),
            totalStudyTime: 0,
            lessonsStarted: 0,
            lessonsCompleted: 0,
            pageLoadTime: new Date(),
            interactionCount: 0,
            lastActivityTime: new Date()
        };
        
        // Delete from database
        await supabase
            .from('course_progress')
            .delete()
            .eq('user_id', currentUser.id)
            .eq('course_id', COURSE_DATA.id);

        // Log reset activity
        logUserActivity('progress_reset', {
            course_id: COURSE_DATA.id,
            reset_reason: 'manual'
        });

        // Reinitialize
        await saveProgress();
        renderSidebar();
        loadLesson(0);
        
        showToast('Progress reset successfully', 'success');
        
    } catch (error) {
        console.error('Error resetting progress:', error);
        showToast('Failed to reset progress', 'error');
    }
}

function copyCode(codeId) {
    const codeElement = document.getElementById(codeId);
    if (!codeElement) return;
    
    const text = codeElement.textContent;
    
    navigator.clipboard.writeText(text).then(() => {
        showToast('Code copied to clipboard!', 'success');
        
        // Track code copy for achievements
        logUserActivity('code_copied', {
            code_section: codeId,
            lesson_id: COURSE_DATA.lessons[currentLessonIndex].id
        });
        
    }).catch(err => {
        console.error('Failed to copy code:', err);
        showToast('Failed to copy code', 'error');
        
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.select();
        try {
            document.execCommand('copy');
            showToast('Code copied to clipboard!', 'success');
        } catch (fallbackError) {
            showToast('Copy failed - please select and copy manually', 'error');
        }
        document.body.removeChild(textArea);
    });
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// =====================================================
// UI FEEDBACK SYSTEMS
// =====================================================
function showToast(message, type = 'success') {
    const toast = document.getElementById('toast');
    const messageEl = document.getElementById('toastMessage');
    
    if (!toast || !messageEl) {
        console.log(`Toast: ${message} (${type})`);
        return;
    }
    
    messageEl.textContent = message;
    toast.className = `toast ${type} show`;

    setTimeout(() => {
        toast.classList.remove('show');
    }, 4000);
}

function showLoadingScreen() {
    const loadingScreen = document.getElementById('loadingScreen');
    if (loadingScreen) loadingScreen.classList.remove('hidden');
}

function hideLoadingScreen() {
    const loadingScreen = document.getElementById('loadingScreen');
    if (loadingScreen) {
        setTimeout(() => {
            loadingScreen.classList.add('hidden');
        }, 1000);
    }
}

// =====================================================
// MUSIC PLAYER INTEGRATION
// =====================================================
function initMusicPlayer() {
    const btnText = document.getElementById('music-button-text');
    const icon = document.getElementById('music-icon');
    const dropdown = document.getElementById('music-dropdown-content');
    
    if (!btnText || !icon || !dropdown) return;
    
    function setUI(state) {
        btnText.textContent = state === "Playing" ? "PAUSE MUSIC" : "STUDY MUSIC";
        icon.className = state === "Playing" ? "fa-solid fa-circle-pause" : "fa-solid fa-music";
    }

    // Load saved music state
    const savedSrc = localStorage.getItem("cybersec_music_src");
    const savedTime = parseFloat(localStorage.getItem("cybersec_music_time") || 0);
    
    if (savedSrc) {
        audioPlayer.src = savedSrc;
        audioPlayer.currentTime = savedTime;
        audioPlayer.play()
            .then(() => setUI("Playing"))
            .catch(() => setUI("Stopped"));
    }

    // Music button click handler
    document.getElementById('music-dropdown').querySelector('button').addEventListener('click', (e) => {
        e.stopPropagation();
        dropdown.style.display = dropdown.style.display === "block" ? "none" : "block";
        
        if (audioPlayer.src && !audioPlayer.paused) {
            audioPlayer.pause();
            setUI("Stopped");
        } else if (audioPlayer.src) {
            audioPlayer.play().then(() => setUI("Playing"));
        }
    });

    // Music selection handlers
    dropdown.querySelectorAll("a[data-src]").forEach((link) => {
        link.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.src = link.dataset.src;
            audioPlayer.play().then(() => setUI("Playing"));
            localStorage.setItem("cybersec_music_src", link.dataset.src);
            dropdown.style.display = "none";
        });
    });

    // Stop music handler
    const stopLink = document.getElementById("stop-music-link");
    if (stopLink) {
        stopLink.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            audioPlayer.removeAttribute("src");
            setUI("Stopped");
            localStorage.removeItem("cybersec_music_src");
            localStorage.removeItem("cybersec_music_time");
            dropdown.style.display = "none";
        });
    }

    // Save music state before page unload
    window.addEventListener("beforeunload", () => {
        if (!audioPlayer.paused && audioPlayer.src) {
            localStorage.setItem("cybersec_music_src", audioPlayer.src);
            localStorage.setItem(
                "cybersec_music_time",
                audioPlayer.currentTime
            );
        }
    });

    // Close dropdown when clicking outside
    window.addEventListener("click", (e) => {
        if (!e.target.closest("#music-dropdown")) {
            dropdown.style.display = "none";
        }
    });
}

// Show initial music indicator
function addMusicIndicator() {
    const musicBtn = document.querySelector("#music-dropdown");
    if (musicBtn) {
        const indicator = document.createElement("div");
        indicator.className = "music-indicator";
        indicator.innerHTML = `<i class="fa-solid fa-music"></i> Try Study Music!`;

        musicBtn.style.position = "relative";
        musicBtn.appendChild(indicator);

        setTimeout(() => indicator.remove(), 3000);
    }
}

// Initialize Event Listeners
function initializeEventListeners() {
    // Navigation buttons
    document.getElementById('prevLessonBtn')?.addEventListener('click', goToPreviousLesson);
    document.getElementById('nextLessonBtn')?.addEventListener('click', goToNextLesson);

    // Reset progress button
    document.getElementById('resetProgressBtn')?.addEventListener('click', resetProgress);

    // Mobile menu toggle
    document.getElementById('menuToggle')?.addEventListener('click', toggleSidebar);
    document.getElementById('sidebarOverlay')?.addEventListener('click', closeSidebar);

    // Keyboard shortcuts
    document.addEventListener('keydown', handleKeyboardShortcuts);

    // Window resize handler
    window.addEventListener('resize', handleWindowResize);

    // Content interaction tracking
    document.getElementById('contentBody')?.addEventListener('scroll', debounce(() => {
        trackUserInteraction();
    }, 1000));
}

// Keyboard Shortcuts
function handleKeyboardShortcuts(e) {
    if (document.querySelector('.quiz-question.active')) return;

    if (e.key === 'ArrowLeft' && e.ctrlKey) {
        e.preventDefault();
        goToPreviousLesson();
    } else if (e.key === 'ArrowRight' && e.ctrlKey) {
        e.preventDefault();
        goToNextLesson();
    }
}

// Window Resize Handler
function handleWindowResize() {
    if (window.innerWidth > 768) {
        closeSidebar();
    }
}

// Debounce Helper
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// Initialize responsive behavior
if (window.innerWidth <= 768) {
    document.getElementById('menuToggle').style.display = 'inline-flex';
}

// Auto-save progress periodically
setInterval(async () => {
    if (currentUser && Object.keys(courseProgress).length > 0) {
        await saveProgress();
    }
}, 60000); // Save every minute

// System initialization logging
console.log('CyberSec Academy Course System Initialized');
console.log('Current Course:', COURSE_DATA.title);
console.log('Total Lessons:', COURSE_DATA.lessons.length);

// Google OAuth Integration
const googleBtn = document.querySelector(".btn-google");
if (googleBtn) {
    googleBtn.addEventListener("click", async () => {
        const { data, error } = await supabase.auth.signInWithOAuth({
            provider: "google",
            options: {
                redirectTo: window.location.origin + "/courses/cryptography-essentials",
            },
        });

        if (error) {
            console.error("Google login error:", error.message);
            showToast("Google login failed: " + error.message, "error");
        }
    });
}

// Check for existing session
supabase.auth.getSession().then(({ data }) => {
    if (data.session) {
        console.log("User already logged in:", data.session.user);
        currentUser = data.session.user;
        startCourseSession();
    }
});


// Add missing auth modal functions
function openAuthModal() {
    const modal = document.getElementById('authModal');
    if (modal) {
        modal.style.display = 'flex';
    }
}

function closeAuthModal() {
    const modal = document.getElementById('authModal');
    if (modal) {
        modal.style.display = 'none';
    }
}

// Add auth tab switching functionality
document.getElementById('tabSignIn')?.addEventListener('click', () => {
    document.getElementById('tabSignIn').classList.add('active');
    document.getElementById('tabSignUp').classList.remove('active');
    document.getElementById('signInForm').style.display = 'block';
    document.getElementById('signUpForm').style.display = 'none';
});

document.getElementById('tabSignUp')?.addEventListener('click', () => {
    document.getElementById('tabSignUp').classList.add('active');
    document.getElementById('tabSignIn').classList.remove('active');
    document.getElementById('signUpForm').style.display = 'block';
    document.getElementById('signInForm').style.display = 'none';
});

document.getElementById('closeAuthModal')?.addEventListener('click', closeAuthModal);

// Improved error handling for auth session
supabase.auth.onAuthStateChange((event, session) => {
    if (event === 'SIGNED_IN') {
        currentUser = session.user;
        closeAuthModal();
        startCourseSession();
    } else if (event === 'SIGNED_OUT') {
        currentUser = null;
        openAuthModal();
    }
});

// Add form submission handlers
document.getElementById('emailSignInForm')?.addEventListener('submit', async (e) => {
    e.preventDefault();
    const email = document.getElementById('signInEmail').value;
    const password = document.getElementById('signInPassword').value;
    
    try {
        const { data, error } = await supabase.auth.signInWithPassword({
            email,
            password
        });
        
        if (error) throw error;
        
        closeAuthModal();
    } catch (error) {
        showToast(error.message, 'error');
    }
});

document.getElementById('emailSignUpForm')?.addEventListener('submit', async (e) => {
    e.preventDefault();
    const email = document.getElementById('signUpEmail').value;
    const password = document.getElementById('signUpPassword').value;
    const name = document.getElementById('signUpName').value;
    
    try {
        const { data, error } = await supabase.auth.signUp({
            email,
            password,
            options: {
                data: {
                    full_name: name
                }
            }
        });
        
        if (error) throw error;
        
        showToast('Account created successfully! Please check your email.', 'success');
    } catch (error) {
        showToast(error.message, 'error');
    }
});
    </script>
</body>

</html>
