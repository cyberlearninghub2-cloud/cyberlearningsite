


<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Exo+2:wght@700;800;900&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css"
    />
    <link rel="icon" type="image/x-icon" href="assets/favicon.ico" />
<link rel="stylesheet" href="assets/css/coursepages.css">
    <!-- ========== Start: SEO & Schema Enhancement ========== -->
    <title>Advanced Malware Research Course | CipherHall</title>
    <meta name="description" content="Enroll in our expert-led Advanced Malware Research course. Master novel detection techniques, reverse engineer sophisticated threats, and become an elite cybersecurity researcher.">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png" />
    <link rel="shortcut icon" href="/favicon.png" type="image/x-icon" />
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png" />
    <link rel="canonical" href="https://www.cipherhall.com/courses/advanced-malware-research-complete-course" />

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Course",
      "name": "Advanced Malware Research - Complete Course",
      "description": "A doctoral-level course designed for the next generation of malware researchers. Move beyond analysis to active research, developing novel techniques to detect, classify, and defeat the most sophisticated cyber threats.",
      "provider": {
        "@type": "Organization",
        "name": "CipherHall",
        "sameAs": "https://www.cipherhall.com"
      },
      "hasCourseInstance": {
        "@type": "CourseInstance",
        "courseMode": "Online",
        "instructor": {
          "@type": "Person",
          "name": "Dr. Evelyn Reed"
        }
      }
    }
    </script>
    <!-- ========== End: SEO & Schema Enhancement ========== -->
  </head>
  <body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
      <div class="loader-icon">
        <i class="fas fa-graduation-cap"></i>
      </div>
      <div class="loader-text">Loading Course Content...</div>
    </div>

    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- Music Player (fixed at top right) -->
    <div class="header-controls">
      <div class="music-dropdown" id="music-dropdown">
        <button class="btn btn-secondary">
          <span id="music-button-text">STUDY MUSIC</span>
          <i id="music-icon" class="fa-solid fa-music"></i>
        </button>
        <div class="music-dropdown-content" id="music-dropdown-content">
          <a
            href="#"
            data-src="https://www.learningcontainer.com/wp-content/uploads/2020/02/Kalimba.mp3"
            >1. Coffee Shop Vibes</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3"
            >2. City Lights Lofi</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-15.mp3"
            >3. Mellow Thoughts</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-13.mp3"
            >4. Rainy Mood</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3"
            >5. Time Alone</a
          >
          <a href="#" id="stop-music-link"
            ><i class="fa-solid fa-stop-circle"></i> Stop Music</a
          >
        </div>
      </div>

      <button class="btn btn-secondary" id="resetProgressBtn">
        <i class="fas fa-redo"></i>
        Reset Progress
      </button>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal" style="display: none">
      <div class="modal-overlay"></div>
      <div class="modal-content">
        <span class="close" id="closeAuthModal">&times;</span>
        <div class="auth-tabs">
          <button id="tabSignIn" class="auth-tab active">Sign In</button>
          <button id="tabSignUp" class="auth-tab">Sign Up</button>
        </div>
        <div
          id="authLoader"
          style="display: none; text-align: center; padding: 2rem"
        >
          <i
            class="fas fa-spinner fa-spin fa-2x"
            style="color: var(--color-green)"
          ></i>
          <p style="margin-top: 0.5rem">Authenticating...</p>
        </div>
        <div id="signInForm" class="auth-form">
          <h2>Sign In to CipherHall</h2>
          <button id="googleSignIn" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignInForm">
            <input
              type="email"
              id="signInEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signInPassword"
              placeholder="Password"
              required
            />
            <button type="submit" class="btn btn-primary">Sign In</button>
          </form>
        </div>
        <div id="signUpForm" class="auth-form" style="display: none">
          <h2>Join CipherHall</h2>
          <button id="googleSignUp" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignUpForm">
            <input
              type="text"
              id="signUpName"
              placeholder="Full Name"
              required
            />
            <input
              type="email"
              id="signUpEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signUpPassword"
              placeholder="Password (min. 8 characters)"
              required
            />
            <button type="submit" class="btn btn-secondary">
              Create Account
            </button>
          </form>
        </div>
        <div id="authMessage"></div>
      </div>
    </div>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="course-info">
          <h1 class="course-title" id="courseTitle">Loading...</h1>
          <div class="course-progress">
            <div class="progress-header">
              <span class="progress-label">Course Progress</span>
              <span class="progress-percentage" id="courseProgressPercent"
                >0%</span
              >
            </div>
            <div class="progress-bar">
              <div
                class="progress-fill"
                id="courseProgressFill"
                style="width: 0%"
              ></div>
            </div>
            <div class="progress-stats">
              <span id="completedLessons">0</span>
              <span id="totalLessons">0</span>
            </div>
          </div>
          <a href="/dashboard" class="back-to-dashboard">
            <i class="fas fa-arrow-left"></i>
            Back to Dashboard
          </a>
        </div>
      </div>

      <nav class="lesson-nav" id="lessonNav">
        <!-- Lessons will be loaded dynamically -->
      </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <header class="content-header">
        <div class="lesson-header">
          <div class="lesson-header-left">
            <span class="lesson-number" id="currentLessonNumber">1</span>
            <h1 class="lesson-header-title" id="currentLessonTitle">
              Loading...
            </h1>
          </div>
          <div class="lesson-actions">
            <button class="mbtn btn-primary" id="menuToggle">
              <i class="fas fa-bars"></i>
            </button>
          </div>
        </div>
      </header>

      <div class="content-body" id="contentBody">
        <div class="lesson-content" id="lessonContent">
          <!-- Lesson content will be loaded dynamically -->
        </div>
      </div>

      <footer class="lesson-navigation">
        <div class="nav-info" id="navInfo">Lesson 1 of 10</div>
        <div class="nav-controls">
          <button class="btn btn-secondary" id="prevLessonBtn" disabled>
            <i class="fas fa-chevron-left"></i>
            Previous
          </button>
          <button class="btn btn-primary" id="nextLessonBtn" disabled>
            Next
            <i class="fas fa-chevron-right"></i>
          </button>
        </div>
      </footer>
    </main>

    <!-- Achievement Notification -->
    <div id="achievementNotification" class="achievement-notification">
      <div class="notification-header">
        <div class="notification-icon" id="notificationIcon">
          <i class="fas fa-trophy"></i>
        </div>
        <div class="notification-content">
          <h3 id="notificationTitle">Achievement Unlocked!</h3>
          <p id="notificationDescription">Description here...</p>
        </div>
      </div>
      <div class="notification-reward" id="notificationReward">
        <i class="fas fa-coins"></i>
        <span id="notificationPoints">+100 Points</span>
      </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast">
      <span id="toastMessage"></span>
    </div>

    <script>
      // =====================================================
      // SYNCHRONIZED COURSE SYSTEM WITH DASHBOARD INTEGRATION
      // =====================================================

      // Supabase Configuration - Replace with your config
      const supabaseUrl = "https://lzcmzulemfubjaksoqor.supabase.co";
      const supabaseKey =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx6Y216dWxlbWZ1Ympha3NvcW9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzMzM5MDgsImV4cCI6MjA3MDkwOTkwOH0.crhPH4YWtRsr1BJTpAQcmPbWSpwIWRbzoI4sRb2_fPI";
      const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

      // =====================================================
      // COURSE DATA STRUCTURE - REPLACE WITH YOUR COURSE JSON
      // =====================================================

      const COURSE_DATA =  {
        "id": "advanced-malware-research",
        "title": "Advanced Malware Research - Complete Course Curriculum",
        "description": "A doctoral-level course designed for the next generation of malware researchers. Move beyond analysis to active research, developing novel techniques to detect, classify, and defeat the most sophisticated cyber threats.",
        "category": "cybersecurity-research",
        "difficulty": "Expert",
        "duration": "120 hours",
        "instructor": "Dr. Evelyn Reed",
        "lessons": [
            {
                "id": "lesson-1",
                "title": "Fundamentals of Advanced Malware Research",
                "duration": "120 min",
                "objectives": [
                    "Establish a formal methodology and ethical framework for malware research.",
                    "Design and implement a secure, multi-level research laboratory.",
                    "Understand the legal considerations of malware handling and responsible disclosure.",
                    "Differentiate between academic and commercial research goals.",
                    "Outline the process for research publication and peer review.",
                    "Navigate international collaboration and research funding."
                ],
                "content": {
                    "overview": "This foundational lesson moves beyond the role of a malware analyst to that of a malware researcher. We will establish the rigorous scientific, ethical, and legal principles that govern advanced research. The focus is on building a safe and effective research environment and understanding the methodologies that underpin the discovery of new knowledge in the field.",
                    "sections": [
                        {
                            "title": "Malware Research Methodology and Ethics",
                            "content": "<p>Advanced malware research is a formal scientific process, not just ad-hoc reverse engineering. It follows the scientific method.</p><h3>The Research Cycle:</h3><ol><li><strong>Observation:</strong> Identify a new or poorly understood piece of malware or technique.</li><li><strong>Hypothesis:</strong> Formulate a specific question or hypothesis. (e.g., 'I hypothesize this malware family uses a novel persistence mechanism that other researchers have missed.')</li><li><strong>Experimentation:</strong> Conduct static and dynamic analysis in a controlled lab environment to test the hypothesis.</li><li><strong>Conclusion:</strong> Analyze the results to confirm or deny the hypothesis.</li><li><strong>Publication:</strong> Document and share the findings with the community through a formal publication or conference presentation.</li></ol><p><strong>Ethical Considerations:</strong> A researcher has an ethical duty to 'do no harm'. This means never experimenting on live networks, protecting any victim data found within a sample, and following a process of responsible disclosure when a new vulnerability is discovered.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Research Laboratory Setup and Safety",
                            "content": "<p>A malware research lab is not a standard IT environment. It is a purpose-built, highly isolated network designed to handle live malware safely.</p><h3>Core Components:</h3><ul><li><strong>Physical Isolation:</strong> The research network must be physically disconnected from any corporate or production network.</li><li><strong>Layered Virtualization:</strong> Analysis is typically done within multiple layers of virtual machines. A common setup is a host OS running a VM for analysis, which itself might contain another VM or sandbox.</li><li><strong>Controlled Network Environment:</strong> The lab uses tools like INetSim to emulate internet services (HTTP, DNS, SMTP) locally. This allows the malware to run and make network connections, but all traffic is safely contained and monitored within the lab.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Legal Considerations and Responsible Disclosure",
                            "content": "<p>Handling malware and discovering vulnerabilities has significant legal implications.</p><p><strong>Real-time Problem: Establishing a secure research environment.</strong> A new researcher receives a live malware sample. If they accidentally run it on their corporate machine, it could lead to a major breach. The correct procedure is to only handle the sample on a dedicated, isolated 'dirty' machine. From there, it is moved into the virtualized analysis lab. The analyst ensures the host VM has networking disabled and no shared folders with the host OS. All network analysis is done using the internal INetSim server. This strict isolation prevents the malware from ever touching a real network or the host computer.</p><p><strong>Responsible Disclosure:</strong> If a researcher discovers a new zero-day vulnerability exploited by malware, the standard ethical process is to privately report the vulnerability to the affected software vendor first, giving them a reasonable amount of time (e.g., 90 days) to develop and release a patch before the researcher publishes their findings publicly.</p>",
                            "image": "https://images.unsplash.com/photo-1505664194779-8beace7a2044?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Professional Malware Research Lab Setup (Firewall Rules)",
                            "language": "shell",
                            "code": "# This is a conceptual firewall ruleset for the physical router\n# that isolates the malware research lab from the rest of the world.\n\n# --- Default Policy: Deny All ---\n# No traffic is allowed in or out by default.\nDEFAULT_POLICY=DROP\n\n# --- Rule 1: Management Access ---\n# Allow SSH access to the lab's management host ONLY from a specific, trusted\n# IP address on the corporate network.\n-A INPUT -s 192.168.1.100 -p tcp --dport 22 -j ACCEPT\n\n# --- Rule 2: Block Everything Else ---\n# Explicitly log and drop all other inbound traffic.\n-A INPUT -j LOG --log-prefix \"BLOCKED_LAB_ACCESS: \"\n-A INPUT -j DROP\n\n# --- Rule 3: Block All Outbound Traffic ---\n# This is the most critical rule. It ensures that no malware can accidentally\n# communicate from inside the lab to the real internet.\n-A FORWARD -j DROP\n\necho \"[+] Secure lab firewall policy applied. All outbound traffic is blocked.\""
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the most critical safety feature of a malware research laboratory?",
                            "options": [
                                "It must have the fastest possible internet connection.",
                                "It must be physically and logically isolated from any production or corporate network.",
                                "It must run the latest version of Windows.",
                                "It must have a comfortable chair."
                            ],
                            "correct": 1,
                            "explanation": "Strict isolation is the cardinal rule of malware research. A breach of this isolation could cause a live malware sample to escape and infect the researcher's organization or the wider internet."
                        },
                        {
                            "id": 2,
                            "question": "The ethical process of notifying a software vendor about a vulnerability you discovered before publishing your findings is known as:",
                            "options": [
                                "Peer review",
                                "Responsible disclosure",
                                "A zero-day attack",
                                "Dynamic analysis"
                            ],
                            "correct": 1,
                            "explanation": "Responsible disclosure is the industry-standard ethical framework. It prioritizes user safety by giving vendors a chance to fix a flaw before it is widely publicized and exploited."
                        },
                        {
                            "id": 3,
                            "question": "A tool like INetSim is used in a malware lab for what purpose?",
                            "options": [
                                "To reverse engineer malware.",
                                "To safely emulate internet services (like HTTP and DNS) locally so that malware can run and make network connections without touching the real internet.",
                                "To analyze the malware's file structure.",
                                "To debug the malware's code."
                            ],
                            "correct": 1,
                            "explanation": "INetSim provides a controlled 'fake internet'. This is crucial for dynamic analysis, as it tricks the malware into revealing its network behavior in a completely safe and monitored environment."
                        }
                    ]
                }
            },
            {
                "id": "lesson-2",
                "title": "Advanced Static Analysis Techniques",
                "duration": "120 min",
                "objectives": [
                    "Perform advanced disassembly and reverse engineering using tools like IDA Pro and Ghidra.",
                    "Achieve mastery of assembly language (x86, x64, ARM).",
                    "Analyze control flow graphs to understand program logic.",
                    "Identify and analyze common obfuscation techniques.",
                    "Statically unpack and decompress malware.",
                    "Analyze import/export tables and resource sections for clues."
                ],
                "content": {
                    "overview": "Advanced static analysis is the art of reverse engineering a malicious program without ever running it. This lesson provides a deep dive into the tools and techniques used to deconstruct a program's machine code, understand its logic, and uncover its hidden capabilities. Mastery of this skill is the foundation of professional malware research.",
                    "sections": [
                        {
                            "title": "Advanced Disassembly and Reverse Engineering",
                            "content": "<p>A disassembler is a tool that converts a program's binary machine code into a human-readable format called assembly language. A decompiler goes one step further and attempts to convert the assembly language back into a high-level language like C.</p><h3>Primary Tools:</h3><ul><li><strong>IDA Pro:</strong> The long-time commercial industry standard for disassembly and reverse engineering.</li><li><strong>Ghidra:</strong> A powerful, free alternative developed and released by the NSA. It includes a decompiler as a core feature.</li><li><strong>Radare2 / Cutter:</strong> Open-source frameworks that are highly scriptable and powerful for advanced users.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Control Flow Graph (CFG) Analysis",
                            "content": "<p>A Control Flow Graph is a visual representation of a program's logic. Each block of straight-line code is a 'node', and the lines ('edges') between them represent branches (e.g., if/else statements, loops). By analyzing the CFG, a researcher can understand the decision-making structure of a program without having to read every single line of code. It provides a roadmap of the malware's functionality.</p><p><strong>Real-world Example:</strong> A researcher is analyzing a piece of ransomware. They generate a CFG in Ghidra. They immediately spot a loop that contains calls to cryptographic functions and file I/O functions. This is the core encryption loop. By focusing their analysis on this specific part of the graph, they can quickly understand how the ransomware encrypts files and look for any weaknesses in its implementation.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Packing and Obfuscation Analysis",
                            "content": "<p>Malware authors almost never ship their raw, unobfuscated code. They use packers and obfuscators to make static analysis much more difficult.</p><ul><li><strong>Packing:</strong> The malware executable is compressed and/or encrypted. The final file consists of a small 'unpacker stub' and a large block of packed data. When run, the stub unpacks the real malware into memory and executes it.</li><li><strong>Obfuscation:</strong> The code's logic is intentionally made confusing and difficult for a human to read. This can involve inserting junk instructions, using complex mathematical operations to hide simple values, and replacing simple calls with convoluted jumps.</li></ul><p><strong>Real-time Problem: Analyzing heavily obfuscated nation-state malware.</strong> An analyst is looking at malware from a sophisticated APT. The control flow graph is a tangled mess, often called a 'spaghetti graph', due to heavy obfuscation. The analyst must painstakingly 'de-obfuscate' the code. This involves writing scripts (e.g., in Python for Ghidra) to automatically identify and reverse the obfuscation patterns, simplifying the code until its true logic becomes clear. This is an advanced, time-consuming process that is often required for the most complex threats.</p>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Advanced Static Analysis Automation (Ghidra/Python)",
                            "language": "python",
                            "code": "# This is a conceptual Ghidra script written in Python (Jython).\n# It automates the process of finding and commenting on all calls to a specific Windows API function.\n\nfrom ghidra.app.decompiler import DecompileOptions, DecompInterface\nfrom ghidra.util.task import ConsoleTaskMonitor\n\n# The function we are interested in (a common function for C2 communication)\ntarget_function = \"InternetOpenUrlA\"\n\ndef run():\n    # Set up the decompiler\n    decompiler = DecompInterface()\n    decompiler.openProgram(currentProgram)\n\n    print(f\"[*] Searching for calls to {target_function}...\")\n    \n    # Get a reference to the function manager\n    fm = currentProgram.getFunctionManager()\n    functions = fm.getFunctions(True) # True means iterate forward\n\n    for function in functions:\n        # Get all the functions called by this function\n        called_funcs = function.getCalledFunctions(ConsoleTaskMonitor())\n        for called_func in called_funcs:\n            if called_func.getName() == target_function:\n                print(f\"[+] Found call to {target_function} inside function: {function.getName()} at {function.getEntryPoint()}\")\n                # Automatically add a comment in the Ghidra listing\n                listing = currentProgram.getListing()\n                codeUnit = listing.getCodeUnitAt(function.getEntryPoint())\n                codeUnit.setComment(codeUnit.PLATE_COMMENT, \"Malware C2 Communication Point\")\n"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "Which tool, developed and released by the NSA, is a powerful, free alternative to IDA Pro and includes a built-in decompiler?",
                            "options": [
                                "Wireshark",
                                "Volatility",
                                "Ghidra",
                                "Snort"
                            ],
                            "correct": 2,
                            "explanation": "Ghidra is a comprehensive, free software reverse engineering suite developed by the NSA, and its release has been a game-changer for the research community."
                        },
                        {
                            "id": 2,
                            "question": "A visual representation of a program's logic, showing blocks of code and the branches between them, is called a:",
                            "options": [
                                "Flowchart",
                                "Control Flow Graph (CFG)",
                                "Mind Map",
                                "Network Diagram"
                            ],
                            "correct": 1,
                            "explanation": "The Control Flow Graph is a fundamental tool for reverse engineers. It provides a high-level roadmap of a function's logic, allowing analysts to quickly identify key areas like loops and decision points."
                        },
                        {
                            "id": 3,
                            "question": "A malware author compresses their malicious executable to make it smaller and harder for antivirus to detect. This technique is known as:",
                            "options": [
                                "Packing",
                                "Obfuscation",
                                "Encryption",
                                "Steganography"
                            ],
                            "correct": 0,
                            "explanation": "Packing is the process of compressing or encrypting an executable. The resulting file has a small 'unpacker stub' that will decompress the real code into memory at runtime. This is a common technique to evade static signature-based detection."
                        }
                    ]
                }
            },
            {
                "id": "lesson-3",
                "title": "Dynamic Analysis and Sandbox Development",
                "duration": "120 min",
                "objectives": [
                    "Perform advanced debugging of malware samples.",
                    "Understand the architecture and design of a custom sandbox environment.",
                    "Implement API hooking and monitoring to intercept malware behavior.",
                    "Analyze the trade-offs between emulation and full-system virtualization.",
                    "Identify and bypass common anti-analysis and sandbox-evasion techniques.",
                    "Develop automated pipelines for large-scale dynamic analysis."
                ],
                "content": {
                    "overview": "Dynamic analysis is the process of running malware in a safe, monitored environment to observe its behavior. This lesson moves beyond using off-the-shelf sandboxes to understanding how they work under the hood. We will explore the techniques of debugging, API hooking, and the advanced cat-and-mouse game of sandbox evasion.",
                    "sections": [
                        {
                            "title": "Advanced Debugging Techniques",
                            "content": "<p>A debugger is a tool that allows a researcher to run a program step-by-step, instruction by instruction. It provides the most granular view of a program's execution.</p><h3>Key Debugger Functions:</h3><ul><li><strong>Breakpoints:</strong> The researcher can set a 'breakpoint' at a specific instruction. The program will run at full speed until it hits the breakpoint, at which point it will pause, allowing the researcher to inspect its state.</li><li><strong>Stepping:</strong> The researcher can execute the program one instruction at a time ('stepping into' or 'stepping over' function calls).</li><li><strong>Register and Memory Inspection:</strong> At any point while the program is paused, the researcher can inspect the contents of the CPU registers and any part of the process's memory.</li></ul><p><strong>Real-world Example:</strong> A piece of malware has an encrypted string in its code. A static analysis tool can't read it. The researcher sets a breakpoint right after the function that decrypts the string. They run the malware in the debugger. It hits the breakpoint and pauses. The researcher can now inspect the memory where the decrypted string is stored and find the plaintext C2 server address.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Custom Sandbox Environment Creation",
                            "content": "<p>A sandbox is an automated system for dynamic analysis. While commercial sandboxes are powerful, building a custom one can provide more control and help evade detection.</p><h3>Core Sandbox Components:</h3><ul><li><strong>Virtual Machine:</strong> An isolated guest OS (usually Windows) where the malware is run.</li><li><strong>Monitoring Agent:</strong> A tool running on the guest or in the hypervisor that monitors all activity. This is often done via **API hooking**, where the agent intercepts calls to key Windows API functions (like `CreateFile` or `InternetConnect`).</li><li><strong>Network Simulator:</strong> A tool like INetSim that provides fake internet services.</li><li><strong>Orchestration Engine:</strong> A script or program that manages the whole process: starts the VM from a clean snapshot, copies the malware in, runs it for a set time, collects the logs, and then destroys the VM.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Anti-Analysis and Sandbox Evasion",
                            "content": "<p>Malware authors know their creations will be analyzed, so they build in checks to detect if they are running in a sandbox or being debugged.</p><p><strong>Real-time Problem: Analyzing sandbox-evasive malware.</strong> A researcher submits malware to a sandbox, but the report comes back clean. The malware did nothing. The researcher suspects it is sandbox-aware. They run the malware in a debugger and find a piece of code that checks the computer's MAC address. If the MAC address starts with `08:00:27` (the default for VirtualBox), the malware immediately exits. The researcher changes the VM's MAC address to mimic a real Dell machine, and runs the malware again. This time, it executes its full malicious payload, which can now be analyzed.</p><h3>Common Evasion Checks:</h3><ul><li>Checking for virtual machine artifacts (e.g., VirtualBox guest additions).</li><li>Checking for the presence of a debugger.</li><li>Checking for a low number of CPU cores or small amount of RAM.</li><li>'Stalling': The malware will sleep for a very long time, hoping the automated sandbox will time out before it does anything malicious.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Custom Malware Sandbox Implementation (API Hooking)",
                            "language": "python",
                            "code": "# This is a conceptual example of API hooking using the Frida toolkit.\n# This script attaches to a process and intercepts all calls to the 'CreateFileW' function,\n# logging the filename that the malware is trying to create.\n\nimport frida\nimport sys\n\n# The JavaScript code that will be injected into the target process\nhook_script = \"\"\"\nInterceptor.attach(Module.getExportByName('kernel32.dll', 'CreateFileW'), {\n    onEnter: function (args) {\n        // args[0] is the first argument to CreateFileW, which is the filename.\n        var filename = args[0].readUtf16String();\n        console.log('[+] CreateFileW called with filename: ' + filename);\n    }\n});\n\"\"\"\n\ndef run_and_monitor(executable_path):\n    # Launch the executable in a suspended state\n    pid = frida.spawn([executable_path])\n    session = frida.attach(pid)\n\n    # Inject the JavaScript hook\n    script = session.create_script(hook_script)\n    script.load()\n\n    # Resume the process and let it run\n    frida.resume(pid)\n\n    # Keep the script running to receive messages\n    print(\"[*] Monitoring process. Press Ctrl+C to exit.\")\n    sys.stdin.read()\n\n# run_and_monitor(\"C:\\\\malware\\\\sample.exe\")"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "In a debugger, what is the purpose of setting a 'breakpoint'?",
                            "options": [
                                "To crash the program.",
                                "To delete a line of code.",
                                "To pause the program's execution at a specific instruction to allow the researcher to inspect its state.",
                                "To make the program run faster."
                            ],
                            "correct": 2,
                            "explanation": "A breakpoint is a fundamental debugging concept. It allows a researcher to run the program at full speed to a point of interest and then stop it for detailed, step-by-step analysis."
                        },
                        {
                            "id": 2,
                            "question": "The technique of intercepting a program's calls to operating system functions (like `CreateFile` or `Socket`) to monitor its behavior is known as:",
                            "options": [
                                "Disassembly",
                                "Decompilation",
                                "API Hooking",
                                "Control Flow Analysis"
                            ],
                            "correct": 2,
                            "explanation": "API hooking is the core monitoring technique used by most sandboxes and behavioral analysis tools. By intercepting these key functions, the monitor can create a detailed log of all the malware's significant actions."
                        },
                        {
                            "id": 3,
                            "question": "A piece of malware checks to see if it is running in a virtual machine before executing its malicious payload. This is an example of what?",
                            "options": [
                                "A bug in the malware.",
                                "A persistence mechanism.",
                                "A sandbox evasion or anti-analysis technique.",
                                "A C2 communication."
                            ],
                            "correct": 2,
                            "explanation": "Malware authors are aware of automated analysis systems and build in checks to detect them. Sandbox evasion is a constant cat-and-mouse game between malware authors and researchers."
                        }
                    ]
                }
            },
            {
                "id": "lesson-4",
                "title": "Malware Family Classification and Clustering",
                "duration": "90 min",
                "objectives": [
                    "Apply machine learning techniques for malware classification.",
                    "Understand various feature extraction methods (e.g., strings, API calls, byte sequences).",
                    "Use similarity and clustering algorithms to group related malware samples.",
                    "Perform phylogenetic analysis to model malware evolution.",
                    "Automate the attribution of a new sample to a known malware family.",
                    "Detect code reuse between different malware families."
                ],
                "content": {
                    "overview": "Researchers are inundated with millions of new malware samples every day. Manually analyzing each one is impossible. This lesson explores the automated, data-driven techniques used to classify and cluster malware at scale. We will learn how to use machine learning and similarity algorithms to automatically group related samples, attribute them to known families, and track their evolution over time.",
                    "sections": [
                        {
                            "title": "Feature Extraction for Machine Learning",
                            "content": "<p>To use machine learning, you must first convert a malware file into a set of numerical 'features' that a model can understand.</p><h3>Common Feature Types:</h3><ul><li><strong>Byte Sequences (N-grams):</strong> The raw sequence of bytes in the file.</li><li><strong>Strings:</strong> The list of readable strings extracted from the binary.</li><li><strong>API Imports:</strong> The list of Windows API functions that the malware imports. This can reveal its capabilities.</li><li><strong>Structural Features:</strong> Information about the file's structure, like the number of sections and the size of the code.</li></ul><p>The goal is to create a 'feature vector'—a numerical fingerprint—that represents the malware file.</p>",
                            "image": "https://images.unsplash.com/photo-1620712943543-285f212a5a54?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Similarity and Clustering Algorithms",
                            "content": "<p>Once you have a way to represent samples as feature vectors, you can use algorithms to compare them.</p><h3>Common Techniques:</h3><ul><li><strong>Similarity Hashing (Fuzzy Hashing):</strong> Unlike a standard hash like SHA256 (which changes completely if one bit changes), a fuzzy hash (like SSDEEP) will be very similar for files that are mostly the same. This is excellent for finding minor variants of the same malware.</li><li><strong>Clustering Algorithms (e.g., K-Means):</strong> A clustering algorithm can take thousands of feature vectors and automatically group them into clusters of similar samples, without any prior knowledge of what the families are. This is a powerful way to discover new, emerging malware families.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Phylogenetic Analysis of Malware Evolution",
                            "content": "<p>By comparing the code of different variants of a malware family over time, researchers can create a 'family tree' or phylogenetic tree. This is the same technique used in biology to study the evolution of species.</p><p><strong>Real-time Problem: Classifying a zero-day malware sample.</strong> A company's sandbox analyzes a new, unknown sample. The automated system extracts a feature vector and compares it against a massive database of known malware families using a machine learning classifier. The model reports that it is '85% confident this sample belongs to the Emotet malware family'. The analyst now has an immediate, high-confidence starting point for their incident response. They know Emotet's typical TTPs and can begin hunting for the specific persistence mechanisms and C2 channels that Emotet is known to use.</p>",
                            "image": "https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "ML-Based Malware Classifier (Scikit-learn)",
                            "language": "python",
                            "code": "from sklearn.feature_extraction.text import CountVectorizer\nfrom sklearn.ensemble import RandomForestClassifier\n\n# This is a conceptual script demonstrating malware classification.\n\n# 1. Training Data: A list of features (e.g., API calls) and their labels (family)\n# In a real system, this would be millions of samples.\ntraining_data = [\n    \"CreateFileW WriteFile InternetOpenUrlA\", # Sample 1\n    \"RegCreateKeyEx RegSetValueEx Socket Send\",   # Sample 2\n    \"CreateFileW WriteFile GetProcAddress\"     # Sample 3\n]\ntraining_labels = [\"Downloader\", \"Backdoor\", \"Downloader\"]\n\n# 2. Feature Extraction: Convert the API strings into a numerical vector\nvectorizer = CountVectorizer()\nX_train = vectorizer.fit_transform(training_data)\n\n# 3. Model Training: Train a classifier (e.g., Random Forest)\nclassifier = RandomForestClassifier()\nclassifier.fit(X_train, training_labels)\n\n# 4. Classification: Classify a new, unknown sample\nunknown_sample_features = [\"CreateFileW WriteFile InternetOpenUrlA CreateProcessA\"]\nX_unknown = vectorizer.transform(unknown_sample_features)\n\nprediction = classifier.predict(X_unknown)\nprint(f\"[*] The new sample is classified as: {prediction[0]}\")"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "The process of converting a malware file into a numerical representation (a 'feature vector') that a machine learning model can understand is called:",
                            "options": [
                                "Disassembly",
                                "Feature Extraction",
                                "Debugging",
                                "Clustering"
                            ],
                            "correct": 1,
                            "explanation": "Feature extraction is the critical first step in any machine learning pipeline. It involves selecting and calculating the key characteristics of the data that will be used to train the model."
                        },
                        {
                            "id": 2,
                            "question": "A type of hash that will be very similar for files that are mostly the same, making it useful for finding minor variants of malware, is known as a:",
                            "options": [
                                "SHA-256 hash",
                                "MD5 hash",
                                "Fuzzy hash (e.g., SSDEEP)",
                                "Password hash"
                            ],
                            "correct": 2,
                            "explanation": "Fuzzy hashing (also known as context-triggered piecewise hashing) is specifically designed to measure the similarity between files, unlike cryptographic hashes which are designed to be completely different if even one bit changes."
                        },
                        {
                            "id": 3,
                            "question": "An unsupervised machine learning technique that can automatically group thousands of malware samples into distinct families without prior knowledge is called:",
                            "options": [
                                "Classification",
                                "Regression",
                                "Clustering",
                                "Reinforcement learning"
                            ],
                            "correct": 2,
                            "explanation": "Clustering is an unsupervised learning method used to discover natural groupings in data. It is extremely valuable for identifying new, previously unknown malware families from a large collection of samples."
                        }
                    ]
                }
            },
            {
                "id": "lesson-5",
                "title": "Advanced Obfuscation and Evasion Analysis",
                "duration": "120 min",
                "objectives": [
                    "Analyze various code and control flow obfuscation techniques.",
                    "Deconstruct metamorphic and polymorphic malware.",
                    "Perform runtime unpacking and memory analysis of packed executables.",
                    "Understand and bypass virtual machine-based protection (VM protection).",
                    "Detect and defeat common anti-debugging and anti-emulation techniques.",
                    "Investigate environment-aware malware that changes its behavior based on its surroundings."
                ],
                "content": {
                    "overview": "Malware authors go to great lengths to protect their creations from analysis. This lesson is a deep dive into the advanced techniques of obfuscation and evasion. We will learn to recognize and defeat the complex layers of protection that malware uses to hide its true purpose from both static and dynamic analysis.",
                    "sections": [
                        {
                            "title": "Code and Control Flow Obfuscation",
                            "content": "<p>Obfuscation is the process of making code intentionally difficult for humans to understand, without changing its actual functionality.</p><h3>Common Techniques:</h3><ul><li><strong>Junk Code Insertion:</strong> Adding meaningless instructions that do nothing but confuse a reverse engineer.</li><li><strong>Opaque Predicates:</strong> Inserting branches that always go the same way, but are difficult for an automated tool to figure out.</li><li><strong>Control Flow Flattening:</strong> Reconstructing the code to remove all clear `if/else` and `loop` structures, replacing them with a giant `switch` statement that is a nightmare to follow. This results in a 'spaghetti graph'.</li></ul><p>Defeating this often requires writing custom scripts to automate the de-obfuscation process and simplify the code back to a readable state.</p>",
                            "image": "https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Polymorphic and Metamorphic Malware",
                            "content": "<p>These are advanced techniques designed to defeat signature-based antivirus.</p><ul><li><strong>Polymorphic Malware:</strong> The malware uses an encryption routine to encipher its main body. Each time it infects a new file, it uses a different encryption key and generates a brand new decryptor routine. The main body of the malware is the same, but the decryptor looks different every time.</li><li><strong>Metamorphic Malware:</strong> The most advanced technique. The malware completely rewrites its own code with each infection. It is a 'true' shape-shifter. There is no common signature to find.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1548092372-2d987bde898b?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Runtime Unpacking and VM Protection",
                            "content": "<p><strong>Runtime Unpacking:</strong> As discussed, malware is often 'packed'. While static analysis is difficult, the malware *must* unpack itself in memory to run. The primary technique to defeat packing is to run the malware in a debugger, let the unpacker stub run, and then dump the process's memory after the real, unpacked code has been written to it.</p><p><strong>VM Protection:</strong> An extreme form of obfuscation where the malware's original code is converted into a custom, proprietary bytecode, and the malware itself includes its own virtual machine to interpret that bytecode. <strong>Real-world Problem: Defeating advanced obfuscation layers.</strong> A researcher is analyzing a sample protected by a commercial tool like VMProtect. Static analysis is useless. They must run the malware in a debugger. The process is painstaking: they must reverse engineer the malware's custom virtual machine to understand its unique instruction set, and then manually trace the execution of the bytecode within that VM to figure out the malware's true logic. This is one of the most challenging tasks in reverse engineering.</p>",
                            "image": "https://images.unsplash.com/photo-1504384308090-c894fdcc538d?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Deobfuscation Automation Toolkit (Conceptual)",
                            "language": "python",
                            "code": "# This conceptual Ghidra/Python script demonstrates how to automate the deobfuscation\n# of a simple XOR-based string encryption routine.\n\ndef deobfuscate_strings():\n    \"\"\"Finds encrypted strings and patches the binary with the decrypted version.\"\"\"\n    # 1. Find the decryption function by searching for a specific pattern of instructions.\n    # (e.g., a loop containing an XOR instruction)\n    decryption_function_address = find_decryption_function()\n\n    # 2. Find all the cross-references to this decryption function.\n    # These are the locations where encrypted strings are being decrypted.\n    call_sites = get_references_to(decryption_function_address)\n\n    for site in call_sites:\n        # 3. For each call site, emulate the instructions backwards to find the\n        # address of the encrypted string buffer and the encryption key.\n        encrypted_buffer_addr = get_argument_at(site, 1)\n        xor_key = get_argument_at(site, 2)\n        \n        # 4. Read the encrypted data and apply the reverse XOR operation.\n        encrypted_data = get_bytes(encrypted_buffer_addr)\n        decrypted_data = ''.join(chr(b ^ xor_key) for b in encrypted_data)\n\n        # 5. Place a comment in the Ghidra listing with the decrypted string.\n        print(f\"Decrypted string at {site}: {decrypted_data}\")\n        set_comment_at(site, f\"Decrypted: {decrypted_data}\")"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "The technique of intentionally making a program's code difficult for a human to read and understand, for example by inserting junk instructions, is known as:",
                            "options": [
                                "Packing",
                                "Obfuscation",
                                "Encryption",
                                "Steganography"
                            ],
                            "correct": 1,
                            "explanation": "Obfuscation's goal is to confuse the analyst. It modifies the code's structure and logic to be unintuitive while preserving its original functionality."
                        },
                        {
                            "id": 2,
                            "question": "What is the key difference between polymorphic and metamorphic malware?",
                            "options": [
                                "There is no difference.",
                                "Polymorphic malware encrypts a static body with a changing decryptor, while metamorphic malware completely rewrites its own code with each infection.",
                                "Metamorphic malware is easier to detect.",
                                "Polymorphic malware only infects mobile devices."
                            ],
                            "correct": 1,
                            "explanation": "Metamorphism is a more advanced technique. A polymorphic sample has a common, static 'core' that is just encrypted differently each time. A metamorphic sample has no such static core, making signature-based detection practically impossible."
                        },
                        {
                            "id": 3,
                            "question": "What is the most effective technique for analyzing a packed executable?",
                            "options": [
                                "Running a strings utility on the packed file.",
                                "Running it in a debugger, allowing the unpacker stub to execute, and then dumping the process memory to get the unpacked code.",
                                "Looking at the file's icon.",
                                "Guessing what the malware does."
                            ],
                            "correct": 1,
                            "explanation": "The weakness of packing is that the malware must be unpacked in memory to run. Dynamic analysis in a debugger allows a researcher to capture this unpacked code after the malware has done the hard work of decrypting itself."
                        }
                    ]
                }
            },
            {
                "id": "lesson-6",
                "title": "Rootkit and Kernel-Level Malware Research",
                "duration": "120 min",
                "objectives": [
                    "Understand kernel architecture and the concept of rings of privilege.",
                    "Analyze malware that operates in Ring 0 (kernel mode).",
                    "Investigate hypervisor-based rootkits (hyperjacking).",
                    "Perform reverse engineering of malicious kernel drivers.",
                    "Detect and analyze System Call (SSDT) hooking.",
                    "Understand Direct Kernel Object Manipulation (DKOM).",
                    "Analyze and detect bootkits and UEFI/firmware-level malware."
                ],
                "content": {
                    "overview": "The most powerful and stealthy malware operates at the lowest levels of the operating system. This lesson explores the advanced world of kernel-level malware and rootkits. We will learn how these threats subvert the core of the OS to become nearly invisible and how to use memory forensics and deep system analysis to hunt for them.",
                    "sections": [
                        {
                            "title": "Kernel Architecture and Privilege Rings",
                            "content": "<p>Modern CPUs enforce a security model based on 'privilege rings'.</p><ul><li><strong>Ring 3 (User Mode):</strong> The least privileged level. This is where user applications run.</li><li><strong>Ring 0 (Kernel Mode):</strong> The most privileged level. This is where the core OS kernel and its drivers run. Code running in Ring 0 has complete access to all system memory and hardware.</li></ul><p>A standard piece of malware runs in Ring 3. A rootkit runs in Ring 0. By gaining kernel-level execution, the malware becomes part of the trusted operating system itself, allowing it to hide its presence and control the entire machine.</p>",
                            "image": "https://images.unsplash.com/photo-1504384308090-c894fdcc538d?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "System Call Hooking and DKOM",
                            "content": "<p>These are the primary techniques a rootkit uses to hide.</p><ul><li><strong>System Call Hooking:</strong> The rootkit modifies a key kernel data structure, like the System Service Descriptor Table (SSDT), to redirect a system call to its own malicious code. When a user-mode application tries to list files, the rootkit's code runs first, filters out its own files from the list, and then passes the sanitized list back.</li><li><strong>Direct Kernel Object Manipulation (DKOM):</strong> A more advanced technique. The rootkit doesn't hook a function; it directly manipulates the kernel's internal data structures in memory. For example, to hide a process, it can find that process's `EPROCESS` structure in the kernel's linked list and simply remove it from the list.</li></ul><p><strong>Detection:</strong> These techniques can only be reliably detected through memory forensics. A tool like Volatility does not trust the OS's API calls. It scans the raw memory for the data structures themselves (e.g., with `psscan` instead of `pslist`) to find the discrepancies that prove a rootkit is active.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Bootkits and UEFI/Firmware Malware",
                            "content": "<p>This is the ultimate form of persistence. The malware infects the code that runs *before* the operating system even starts loading.</p><ul><li><strong>Bootkit:</strong> Infects the Master Boot Record (MBR) or Volume Boot Record (VBR).</li><li><strong>UEFI/Firmware Malware:</strong> Infects the code stored on the motherboard's firmware chip.</li></ul><p><strong>Real-time Problem: Analyzing a UEFI rootkit.</strong> A researcher is investigating a machine that is behaving strangely, but multiple OS reinstalls do not fix the problem. This suggests a firmware-level implant. The researcher must use specialized tools to dump the contents of the motherboard's UEFI firmware chip. They then use reverse engineering tools to analyze this firmware code. They find a malicious module that has been added to the firmware. This module is designed to inject a small piece of malware into the Windows kernel (`ntoskrnl.exe`) as it is being loaded from disk into memory during the boot process. The only way to remove this type of infection is to re-flash the motherboard's firmware with a clean version from the manufacturer.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Kernel Rootkit Detection System (Volatility)",
                            "language": "bash",
                            "code": "# This script demonstrates a cross-view validation technique in Volatility\n# to detect a common rootkit behavior: a hidden process.\n\nMEMORY_FILE=\"rootkit_infected.mem\"\n\n# 1. Get the process list using the standard OS method (walking the EPROCESS list).\nvol -f $MEMORY_FILE windows.pslist > pslist.txt\n\n# 2. Get the process list by scanning physical memory for EPROCESS structures.\n# This method does not trust the OS's linked list.\nvol -f $MEMORY_FILE windows.psscan > psscan.txt\n\n# 3. Compare the two lists. Any process in psscan.txt that is NOT in pslist.txt\n# is being hidden by a rootkit using DKOM.\n\n# A simple 'diff' can often highlight the differences.\ndiff <(awk '{print $1}' pslist.txt | sort) <(awk '{print $1}' psscan.txt | sort)\n\n# The output of the diff will show the PID of the hidden process."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "In the x86/x64 architecture, which privilege 'ring' does the operating system kernel run in?",
                            "options": [
                                "Ring 1",
                                "Ring 2",
                                "Ring 3 (User Mode)",
                                "Ring 0 (Kernel Mode)"
                            ],
                            "correct": 3,
                            "explanation": "Ring 0 is the most privileged level, with direct access to all memory and hardware. This is why gaining kernel-level execution is the primary goal for a sophisticated rootkit."
                        },
                        {
                            "id": 2,
                            "question": "The rootkit technique of directly manipulating the kernel's linked list of processes in memory to hide a malicious process is known as:",
                            "options": [
                                "System Call Hooking",
                                "Direct Kernel Object Manipulation (DKOM)",
                                "Process Injection",
                                "A Bootkit"
                            ],
                            "correct": 1,
                            "explanation": "DKOM is a very stealthy technique because it doesn't modify any code (like a hook does). It just modifies the kernel's data structures in memory, making it invisible to tools that trust those data structures."
                        },
                        {
                            "id": 3,
                            "question": "Malware that infects the motherboard's firmware to execute before the operating system even starts is known as:",
                            "options": [
                                "A virus",
                                "A worm",
                                "A UEFI/Firmware rootkit",
                                "A Trojan"
                            ],
                            "correct": 2,
                            "explanation": "This is the ultimate form of persistence. Because the malware is stored on a chip on the motherboard, it is not on the hard drive and will survive a complete wipe and reinstall of the operating system."
                        }
                    ]
                }
            },
            {
                "id": "lesson-7",
                "title": "Mobile Malware Research and Analysis",
                "duration": "100 min",
                "objectives": [
                    "Understand the security architecture of Android and iOS.",
                    "Perform static and dynamic analysis of Android (APK) and iOS (IPA) applications.",
                    "Investigate mobile banking trojans and spyware.",
                    "Analyze the distribution of malware through official and third-party app stores.",
                    "Research mobile botnets and SMS-based threats.",
                    "Understand the challenges of analyzing cross-platform mobile malware."
                ],
                "content": {
                    "overview": "As our lives have moved to mobile devices, so have the attackers. This lesson focuses on the specialized skills required for mobile malware research. We will dissect the security models of Android and iOS, learn how to reverse engineer mobile applications, and investigate the common threats targeting these platforms, from banking trojans to sophisticated spyware.",
                    "sections": [
                        {
                            "title": "Mobile Platform Security Architecture",
                            "content": "<h3>Android:</h3><ul><li><strong>Open Source:</strong> Based on the Linux kernel.</li><li><strong>Application Sandboxing:</strong> Each app runs as its own user with its own unique UID, isolating its data from other apps.</li><li><strong>Permissions Model:</strong> Apps must explicitly request permissions to access sensitive data or features (e.g., contacts, camera, location).</li><li><strong>Sideloading:</strong> By default, Android allows users to install applications from sources other than the official Google Play Store, which is a major vector for malware infection.</li></ul><h3>iOS:</h3><ul><li><strong>Closed Source:</strong> Tightly controlled by Apple.</li><li><strong>Strict Sandboxing:</strong> A very restrictive sandbox model limits what an app can do.</li><li><strong>Mandatory Code Signing:</strong> All apps must be cryptographically signed by Apple to run on a non-jailbroken device.</li><li><strong>No Sideloading:</strong> Apps can only be installed from the official App Store, which acts as a strong gatekeeper.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1610465213254-2c35a8276b4a?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Android Malware Analysis",
                            "content": "<p>Android apps are distributed as APK files, which are essentially ZIP archives containing the application's code and resources.</p><h3>Static Analysis:</h3><p>A researcher can unzip the APK and use a tool like `jadx` to decompile the Dalvik bytecode (`classes.dex`) back into mostly readable Java code. This allows for a detailed analysis of the app's functionality.</p><h3>Dynamic Analysis:</h3><p>The APK can be run on an Android emulator or a physical device within a controlled environment (like a mobile sandbox) to observe its behavior: what network connections does it make, what SMS messages does it try to send, what files does it access?</p>",
                            "image": "https://images.unsplash.com/photo-1585255428357-ac758950454a?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Common Mobile Threats",
                            "content": "<p><strong>Real-time Problem: Investigating sophisticated mobile banking malware.</strong> A new Android banking trojan is discovered. A researcher performs dynamic analysis. They observe that the malware, once installed, does nothing until the user opens their legitimate banking app. At that moment, the malware displays a perfect replica of the banking app's login screen as an *overlay* on top of the real app. The unsuspecting user types their username and password into the malware's fake screen. The malware captures the credentials, sends them to the attacker's C2 server, and then closes the overlay, returning the user to their real banking app. The user is unaware their credentials have been stolen. This overlay attack is a common and effective mobile threat.</p><h3>Other Threats:</h3><ul><li><strong>Spyware:</strong> Malware that uses the device's permissions to covertly activate the microphone and camera, steal contacts, and track the user's location.</li><li><strong>SMS Trojans:</strong> Malware that sends premium-rate SMS messages to numbers owned by the attacker, generating revenue.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1533139143976-3d235835932c?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Mobile Malware Analysis Framework (Frida)",
                            "language": "javascript",
                            "code": "// This Frida script demonstrates how to bypass SSL certificate pinning in an Android app.\n// Many apps use pinning to prevent man-in-the-middle analysis of their network traffic.\n// This hook disables that check, allowing an analyst to intercept and decrypt the app's HTTPS traffic.\n\nJava.perform(function() {\n    console.log(\"[*] Bypassing SSL Pinning...\");\n\n    // Hook the TrustManager's checkServerTrusted method.\n    var TrustManager = Java.use('javax.net.ssl.X509TrustManager');\n    var TrustManagerImpl = Java.use('com.android.org.conscrypt.TrustManagerImpl');\n\n    TrustManagerImpl.checkServerTrusted.overload('[Ljava.security.cert.X509Certificate;', 'java.lang.String').implementation = function(chain, authType) {\n        console.log(\"[+] Bypassed checkServerTrusted for authType: \" + authType);\n        return;\n    };\n\n    TrustManagerImpl.checkServerTrusted.overload('[Ljava.security.cert.X509Certificate;', 'java.lang.String', 'java.lang.String').implementation = function(chain, authType, host) {\n        console.log(\"[+] Bypassed checkServerTrusted for host: \" + host);\n        return;\n    };\n});"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "The ability for a user to install an application from a source other than the official app store, a major malware vector, is known as:",
                            "options": [
                                "Rooting",
                                "Jailbreaking",
                                "Sideloading",
                                "Sandboxing"
                            ],
                            "correct": 2,
                            "explanation": "Sideloading is a feature of Android that allows for greater openness but also introduces significant security risks, as apps from third-party stores are not subject to the same security vetting as those on the Google Play Store."
                        },
                        {
                            "id": 2,
                            "question": "An Android application package file has what extension?",
                            "options": [
                                ".EXE",
                                ".IPA",
                                ".DEX",
                                ".APK"
                            ],
                            "correct": 3,
                            "explanation": "APK (Android Package Kit) is the file format used by the Android operating system for the distribution and installation of mobile apps."
                        },
                        {
                            "id": 3,
                            "question": "A type of mobile malware that displays a fake login screen on top of a legitimate application to steal credentials is known as an:",
                            "options": [
                                "Overlay attack",
                                "SMS Trojan",
                                "Rootkit",
                                "Worm"
                            ],
                            "correct": 0,
                            "explanation": "The overlay attack is a very common and effective technique used by mobile banking trojans. It abuses Android's accessibility features to draw its malicious window on top of a legitimate app, tricking the user into entering their credentials."
                        }
                    ]
                }
            },
            {
                "id": "lesson-8",
                "title": "IoT and Embedded Malware Research",
                "duration": "100 min",
                "objectives": [
                    "Perform reverse engineering of IoT device firmware.",
                    "Analyze malware targeting embedded Linux and Real-Time Operating Systems (RTOS).",
                    "Use hardware debugging techniques (e.g., JTAG, UART) to access embedded devices.",
                    "Investigate malware that propagates over radio frequencies.",
                    "Research threats to Industrial IoT, automotive, and medical devices.",
                    "Understand the challenges of the IoT supply chain."
                ],
                "content": {
                    "overview": "The Internet of Things (IoT) has introduced a world of new, often highly insecure, computing devices into our networks. This lesson explores the specialized field of IoT and embedded malware research, covering everything from firmware reverse engineering to hardware-level debugging to understand and combat threats in this rapidly expanding landscape.",
                    "sections": [
                        {
                            "title": "Firmware Reverse Engineering",
                            "content": "<p>The 'software' on an embedded device is called firmware. The first step in an investigation is often to acquire this firmware, which can be done by downloading it from the manufacturer's website or by physically extracting it from the device's flash memory chip.</p><p>Once acquired, a researcher can use a tool like `binwalk` to analyze and extract the contents of the firmware file. Often, the firmware is a compressed file system (like SquashFS) containing a small, embedded version of Linux and the device's application binaries. The researcher can then analyze these binaries using standard reverse engineering tools like Ghidra.</p>",
                            "image": "https://images.unsplash.com/photo-1535683416248-8495c6b8159b?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Hardware Debugging and Analysis",
                            "content": "<p>When a device is completely locked down, a researcher must resort to hardware-level techniques to gain access.</p><h3>Common Hardware Interfaces:</h3><ul><li><strong>UART (Universal Asynchronous Receiver-Transmitter):</strong> Often, a device's circuit board will have an unpopulated serial port (UART). By soldering on a header, a researcher can often get direct access to the device's bootloader and a root-level command shell.</li><li><strong>JTAG (Joint Test Action Group):</strong> A powerful debugging interface that can allow a researcher to directly access the device's memory and CPU. Gaining access via JTAG often provides complete control over the device.</li></ul><p>These techniques require skills in electronics and soldering in addition to software reverse engineering.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "The Mirai Botnet: A Case Study",
                            "content": "<p>The Mirai botnet was a landmark piece of IoT malware that demonstrated the power of an insecure embedded landscape.</p><p><strong>Real-time Problem: Analyzing smart city infrastructure malware.</strong> Mirai worked by continuously scanning the internet for exposed IoT devices (like routers and security cameras) that were still using their factory default usernames and passwords. When it found one, it would log in, infect the device with its botnet client, and then continue scanning for new victims. The massive botnet of hundreds of thousands of infected devices was then used to launch some of the largest DDoS attacks ever recorded. The research into Mirai was a classic example of IoT forensics: researchers captured the malware, reverse-engineered it to extract the list of default credentials it was using, and then used that intelligence to help clean up the infected devices.</p>",
                            "image": "https://images.unsplash.com/photo-1548092372-2d987bde898b?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "IoT Malware Detection System (Firmware Analysis)",
                            "language": "bash",
                            "code": "# This script uses the 'binwalk' tool to automate the analysis and extraction of a firmware image.\n\nFIRMWARE_FILE=\"router_firmware.bin\"\n\n# 1. Run binwalk with the '--signature' flag to identify known file types and data structures\n# within the firmware binary.\nbinwalk --signature $FIRMWARE_FILE\n\n# --- Sample Output ---\n# DECIMAL       HEXADECIMAL     DESCRIPTION\n# --------------------------------------------------------------------------------\n# 0             0x0             U-Boot boot loader\n# 123456        0x1E240         SquashFS filesystem, little endian, version 4.0\n\n# 2. Automatically extract the discovered file system.\n# The '-e' or '--extract' flag tells binwalk to carve and decompress any known file types.\nbinwalk --extract $FIRMWARE_FILE\n\n# 3. This will create a directory named '_router_firmware.bin.extracted' containing the\n#    full file system from the device.\n# A researcher can now browse this file system, look for hardcoded passwords in scripts,\n# and analyze the application binaries for vulnerabilities.\nls -la _router_firmware.bin.extracted/squashfs-root/bin/"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the primary goal of using a tool like `binwalk` on a firmware image?",
                            "options": [
                                "To run the firmware in a virtual machine.",
                                "To identify and extract embedded file systems and other data from the firmware binary.",
                                "To check the firmware for viruses.",
                                "To install the firmware on a new device."
                            ],
                            "correct": 1,
                            "explanation": "`binwalk` is a fundamental tool for firmware reverse engineering. It scans a binary blob for the signatures of known file types, file systems, and compressed data, allowing a researcher to automatically unpack the firmware's contents."
                        },
                        {
                            "id": 2,
                            "question": "JTAG and UART are examples of what?",
                            "options": [
                                "Types of IoT malware.",
                                "Wireless communication protocols.",
                                "Hardware debugging interfaces that can be used to gain low-level access to an embedded device.",
                                "Brands of security cameras."
                            ],
                            "correct": 2,
                            "explanation": "JTAG and UART are physical interfaces on a device's circuit board. Gaining access to them is a key technique in hardware hacking and embedded device forensics, often providing a root shell when software-based access is impossible."
                        },
                        {
                            "id": 3,
                            "question": "The Mirai botnet primarily infected IoT devices by what method?",
                            "options": [
                                "Using a zero-day exploit.",
                                "Sending a phishing email to the device.",
                                "Guessing the device's weak or factory-default administrative passwords.",
                                "Using a malicious USB drive."
                            ],
                            "correct": 2,
                            "explanation": "Mirai's success was not due to a sophisticated technical exploit, but rather to a simple and widespread problem: users not changing the default credentials on their devices. It simply logged in with a list of common default passwords."
                        }
                    ]
                }
            },
            {
                "id": "lesson-9",
                "title": "Advanced Persistence Mechanism Research",
                "duration": "100 min",
                "objectives": [
                    "Research and discover novel fileless malware techniques.",
                    "Analyze how attackers abuse legitimate tools for 'living-off-the-land'.",
                    "Investigate advanced registry, WMI, and scheduled task-based persistence.",
                    "Reverse engineer malware that uses DLL hijacking and COM hijacking.",
                    "Analyze boot process manipulation and hardware-based persistence.",
                    "Develop new methods for detecting undiscovered persistence techniques."
                ],
                "content": {
                    "overview": "Persistence is an attacker's ability to maintain access to a compromised system across reboots. Advanced adversaries are in a constant state of innovation, developing new and stealthy ways to hide on a system. This lesson moves beyond cataloging known persistence methods to the research mindset required to discover and analyze novel techniques in the wild.",
                    "sections": [
                        {
                            "title": "Fileless and Living-off-the-Land (LotL) Persistence",
                            "content": "<p>These techniques aim to achieve persistence without dropping a new malicious executable file to the disk, making them very difficult for traditional antivirus to detect.</p><h3>Research Areas:</h3><ul><li><strong>Registry-Based Fileless Persistence:</strong> Storing the entire malicious script (e.g., PowerShell) directly in a registry key, and then using a legitimate system binary to read and execute that script from the registry at startup.</li><li><strong>WMI-Based Persistence:</strong> Windows Management Instrumentation (WMI) can be used to create event-driven persistence. An attacker can create a WMI event subscription that triggers their malicious script whenever a certain event occurs (e.g., a user logs in).</li></ul>",
                            "image": "https://images.unsplash.com/photo-1548092372-2d987bde898b?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "DLL and COM Hijacking Research",
                            "content": "<p>These techniques involve tricking a legitimate, trusted application into loading a malicious library on the attacker's behalf.</p><ul><li><strong>DLL Hijacking:</strong> A legitimate application is designed to load a specific DLL. The attacker replaces the legitimate DLL with their own malicious one, giving it the same name. When the trusted application starts, it unknowingly loads and executes the attacker's code.</li><li><strong>COM Hijacking:</strong> A more complex technique where an attacker hijacks the Component Object Model (COM) registry entries that Windows uses to find and load software components. They can redirect a call for a legitimate COM object to their own malicious code.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1504384308090-c894fdcc538d?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Discovering Novel Techniques",
                            "content": "<p>Finding new persistence techniques is a core task of malware research. It requires a deep understanding of the operating system and a creative, 'attacker' mindset.</p><p><strong>Real-time Problem: Discovering novel persistence techniques.</strong> A researcher is hunting for new persistence methods. They use monitoring tools (like ProcMon) to log every single file and registry access that occurs during the Windows boot process. They then analyze this massive log, looking for legitimate Microsoft binaries that are attempting to load files or registry keys that *do not exist* on a clean system. Each of these is a potential hijacking opportunity. If a legitimate, signed executable tries to load `missing.dll` from its directory, the researcher knows that if they create a malicious `missing.dll` and place it in that directory, the trusted program will load it for them, creating a new, undiscovered persistence mechanism.</p>",
                            "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Persistence Detection and Analysis Suite (PowerShell)",
                            "language": "powershell",
                            "code": "# This PowerShell script demonstrates how to query for a specific, advanced persistence technique:\n# WMI Event Consumer bindings.\n\n# Get all WMI event filters, consumers, and their bindings.\n$filters = Get-WmiObject -Namespace root\\subscription -Class __EventFilter\n$consumers = Get-WmiObject -Namespace root\\subscription -Class __EventConsumer\n$bindings = Get-WmiObject -Namespace root\\subscription -Class __FilterToConsumerBinding\n\nWrite-Host \"[*] Searching for suspicious WMI persistence...\"\n\nforeach ($binding in $bindings) {\n    # For each binding, find the corresponding filter (the trigger) and consumer (the action).\n    $filter = $filters | Where-Object { $binding.Filter -match $_.Name } \n    $consumer = $consumers | Where-Object { $binding.Consumer -match $_.Name } \n\n    # A common malicious pattern is to use a command-line based consumer to run a script.\n    if ($consumer -is [Management.ManagementObject] -and $consumer.__CLASS -eq 'CommandLineEventConsumer') {\n        Write-Host \"[!] Suspicious WMI Command Line Consumer Found!\"\n        Write-Host \"    Filter Query: $($filter.Query)\"\n        Write-Host \"    Consumer Command: $($consumer.CommandLineTemplate)\"\n    }\n}"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "A type of persistence where the malware's code is stored entirely in the Windows Registry and executed by a legitimate binary is an example of what?",
                            "options": [
                                "A bootkit",
                                "Fileless persistence",
                                "A hardware implant",
                                "DLL Hijacking"
                            ],
                            "correct": 1,
                            "explanation": "Fileless persistence techniques avoid writing traditional executable files to disk, instead hiding their code in alternative data stores like the registry, WMI, or event logs to evade detection."
                        },
                        {
                            "id": 2,
                            "question": "The technique of replacing a legitimate application's library file with a malicious one of the same name is known as:",
                            "options": [
                                "WMI persistence",
                                "COM Hijacking",
                                "DLL Hijacking",
                                "A rootkit"
                            ],
                            "correct": 2,
                            "explanation": "DLL hijacking abuses the way that Windows searches for and loads DLLs. By placing a malicious DLL in a location that is searched before the legitimate one, an attacker can trick a trusted application into loading their code."
                        },
                        {
                            "id": 3,
                            "question": "What is the primary goal of a researcher who is hunting for novel persistence techniques?",
                            "options": [
                                "To document all the already known methods.",
                                "To find bugs in monitoring tools like ProcMon.",
                                "To find and document previously unknown ways that an attacker can achieve persistence on an operating system.",
                                "To write a new piece of malware."
                            ],
                            "correct": 2,
                            "explanation": "This is a proactive form of research. The goal is to discover new attack techniques so that defensive tools (like EDR and autoruns) can be updated to detect them, staying ahead of the adversaries."
                        }
                    ]
                }
            },
            {
                "id": "lesson-10",
                "title": "Cryptographic Malware and Ransomware Research",
                "duration": "120 min",
                "objectives": [
                    "Reverse engineer the encryption algorithms used in malware.",
                    "Analyze key generation and management routines for weaknesses.",
                    "Research and discover flaws in cryptographic implementations.",
                    "Track the evolution of major ransomware families.",
                    "Investigate the Ransomware-as-a-Service (RaaS) ecosystem.",
                    "Analyze double and triple extortion techniques.",
                    "Research the abuse of cryptographic protocols and cryptocurrencies by malware."
                ],
                "content": {
                    "overview": "Cryptography is a powerful tool for both defense and attack. This lesson focuses on the research of 'crypto-malware', with a special emphasis on ransomware. We will move beyond just responding to ransomware to the deep reverse engineering required to analyze its encryption, hunt for flaws, and potentially develop decryptors.",
                    "sections": [
                        {
                            "title": "Encryption Algorithm and Implementation Analysis",
                            "content": "<p>When analyzing ransomware, the first step is to identify the cryptographic primitives it is using.</p><ul><li><strong>Symmetric Encryption:</strong> Algorithms like AES or ChaCha20 are typically used to encrypt the actual file content.</li><li><strong>Asymmetric Encryption:</strong> Algorithms like RSA or ECC are often used to protect the symmetric key. The ransomware encrypts the AES key with the attacker's public key, and only the attacker, with the private key, can decrypt it.</li></ul><p><strong>Real-time Problem: Breaking flawed ransomware encryption.</strong> A researcher is analyzing a new piece of ransomware. By reverse engineering the code in Ghidra, they find the function that generates the AES key for each file. They discover that the malware author made a critical mistake: instead of using a cryptographically secure random number generator, they used the system's millisecond timestamp as the seed for the key. The researcher now knows that there are only 1000 possible keys for any given second. They can write a simple tool that generates all 1000 keys and tries each one on an encrypted file until it finds the correct one. They have found a flaw in the implementation that allows them to write a universal decryptor, even though the AES algorithm itself is strong.</p>",
                            "image": "https://images.unsplash.com/photo-1614064548237-096537d54645?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Ransomware-as-a-Service (RaaS) Research",
                            "content": "<p>Modern ransomware is a professional, billion-dollar industry. The RaaS model is a key part of this ecosystem.</p><h3>The RaaS Model:</h3><ul><li><strong>Developers:</strong> A core group of highly skilled developers who create and maintain the ransomware itself.</li><li><strong>Affiliates:</strong> A large number of less-skilled criminal actors who are responsible for gaining access to victim networks (e.g., through phishing, exploiting vulnerabilities).</li><li><strong>The Platform:</strong> The developers provide the affiliates with the ransomware payload and a web portal to manage their victims. The affiliate launches the attack, and if the victim pays, the developers and the affiliate split the ransom, often with the developers taking a 20-30% cut.</li></ul><p>Researching RaaS involves tracking these different groups, analyzing their TTPs, and understanding the underground economy that supports them.</p>",
                            "image": "https://images.unsplash.com/photo-1642155998158-9416a041cb42?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Double and Triple Extortion",
                            "content": "<p>The tactics of ransomware gangs are constantly evolving to increase pressure on victims.</p><ul><li><strong>Single Extortion:</strong> 'Pay us to get your files back.' (The original model)</li><li><strong>Double Extortion:</strong> 'Pay us to get your files back, AND pay us so we don't leak the sensitive data we stole before we encrypted your files.'</li><li><strong>Triple Extortion:</strong> Adds a third layer of pressure, such as launching a DDoS attack against the victim's public website or directly contacting the victim's customers or patients to inform them of the breach.</li></ul><p>Research in this area focuses on tracking these tactical shifts and providing intelligence to incident responders and negotiators.</p>",
                            "image": "https://images.unsplash.com/photo-1544327415-77222e20790b?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Ransomware Decryption Toolkit (Conceptual)",
                            "language": "python",
                            "code": "# This conceptual script demonstrates the logic for a decryptor that exploits a\n# common flaw: using a hardcoded or easily guessable encryption key.\n\nfrom Crypto.Cipher import AES\n\n# Assume this is the encrypted file from the ransomware\nencrypted_file_path = \"document.docx.locked\"\n\n# The researcher discovered through reverse engineering that the malware always\n# uses the same hardcoded key.\n_HARDCODED_KEY = b'ThisIsAVeryBadKey1234567890!@#$'\n\ndef decrypt_file(file_path, key):\n    with open(file_path, 'rb') as f_in:\n        # The first 16 bytes are the IV (Initialization Vector)\n        iv = f_in.read(16)\n        # The rest is the encrypted data\n        ciphertext = f_in.read()\n\n    cipher = AES.new(key, AES.MODE_CBC, iv)\n    plaintext = cipher.decrypt(ciphertext)\n    \n    # Remove padding\n    # A real implementation would need robust unpadding.\n    unpadded_plaintext = plaintext.rstrip(b'\\x00')\n\n    output_path = file_path.replace(\".locked\", \"_decrypted.docx\")\n    with open(output_path, 'wb') as f_out:\n        f_out.write(unpadded_plaintext)\n    \n    print(f\"[+] File decrypted to {output_path}\")\n\n# decrypt_file(encrypted_file_path, _HARDCODED_KEY)"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "In a ransomware attack, which type of cryptography is typically used to encrypt the actual content of large files?",
                            "options": [
                                "Asymmetric Cryptography (e.g., RSA)",
                                "Symmetric Cryptography (e.g., AES)",
                                "Hashing (e.g., SHA-256)",
                                "Steganography"
                            ],
                            "correct": 1,
                            "explanation": "Symmetric algorithms like AES are much faster than asymmetric ones, making them suitable for encrypting large amounts of data. The malware then typically uses asymmetric cryptography to encrypt the much smaller symmetric key."
                        },
                        {
                            "id": 2,
                            "question": "What is the primary goal of a malware researcher when analyzing the cryptographic implementation of ransomware?",
                            "options": [
                                "To admire the complexity of the algorithm.",
                                "To find a flaw or weakness in how the cryptography was *implemented*, which could allow for the development of a decryptor.",
                                "To find a mathematical flaw in the AES or RSA algorithm itself.",
                                "To determine how much the ransom is."
                            ],
                            "correct": 1,
                            "explanation": "The standard cryptographic algorithms themselves are secure. However, malware authors often make mistakes in how they *use* them (e.g., weak key generation, hardcoded keys). These implementation flaws are the primary target for researchers trying to break ransomware."
                        },
                        {
                            "id": 3,
                            "question": "The business model where a core group of developers provides ransomware to less-skilled criminals in exchange for a percentage of the profits is known as:",
                            "options": [
                                "Double Extortion",
                                "A botnet",
                                "Ransomware-as-a-Service (RaaS)",
                                "A zero-day"
                            ],
                            "correct": 2,
                            "explanation": "RaaS is the dominant business model for the modern ransomware ecosystem. It has allowed ransomware to scale dramatically by separating the difficult job of malware development from the easier job of network intrusion."
                        }
                    ]
                }
            },
            {
                "id": "lesson-11",
                "title": "Nation-State and APT Malware Research",
                "duration": "120 min",
                "objectives": [
                    "Analyze the unique characteristics and goals of nation-state malware.",
                    "Understand the challenges of attributing attacks to Advanced Persistent Threats (APTs).",
                    "Research the TTPs of major APT groups.",
                    "Analyze malware used in supply chain attacks and cyber warfare.",
                    "Investigate the use of zero-day exploits by state actors.",
                    "Discuss the geopolitical context and international law implications of APT research."
                ],
                "content": {
                    "overview": "The most sophisticated malware is not built for financial gain; it is built as an instrument of national power. This lesson focuses on the research of nation-state malware and the Advanced Persistent Threat (APT) groups that wield it. We will explore the advanced TTPs, custom frameworks, and geopolitical motivations that define this top tier of the threat landscape.",
                    "sections": [
                        {
                            "title": "Characteristics of Nation-State Malware",
                            "content": "<p>Unlike commodity criminal malware, APT malware is defined by its goals and sophistication.</p><h3>Key Differentiators:</h3><ul><li><strong>Goal-Oriented:</strong> The goal is not quick profit, but long-term espionage, intellectual property theft, or sabotage to achieve a strategic national objective.</li><li><strong>Stealth:</strong> The malware is designed to be as stealthy as possible, often remaining undetected in a network for months or years.</li><li><strong>Custom and Modular:</strong> APTs often use custom-built, modular malware frameworks. This allows them to deploy only the specific tools needed for a given target, reducing their footprint.</li><li><strong>Use of Zero-Days:</strong> Nation-state actors are the primary users of zero-day exploits due to the high cost and skill required to develop or acquire them.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1573495782740-62c135d54483?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Attribution and Campaign Tracking",
                            "content": "<p>Attribution—linking a specific piece of malware or an intrusion to a specific APT group—is a complex process based on a convergence of evidence.</p><p><strong>Real-time Problem: Attributing sophisticated nation-state malware.</strong> Researchers discover a new, highly sophisticated rootkit. They cannot definitively say who wrote it. However, they analyze the C2 protocol and find that it is a new version of a protocol used exclusively by an APT group known as 'Fancy Bear' (APT28), which is linked to Russian intelligence. They also find code overlaps and shared data structures with previous Fancy Bear malware. Finally, the targets of this new malware are all government agencies in Eastern Europe, consistent with Fancy Bear's known geopolitical objectives. Based on this convergence of TTPs, code similarity, and targeting, the researchers can make a *high-confidence assessment* that this new malware is a tool of Fancy Bear.</p>",
                            "image": "https://images.unsplash.com/photo-1556091212-a1b6379a05de?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Cyber Warfare and Supply Chain Attacks",
                            "content": "<p>Nation-states are the primary actors in the most significant cyber events.</p><h3>Landmark Examples:</h3><ul><li><strong>Stuxnet:</strong> Widely believed to be a US/Israeli operation, Stuxnet was a highly advanced worm that physically destroyed centrifuges in an Iranian nuclear facility. It is the textbook example of malware designed for physical sabotage.</li><li><strong>SolarWinds (Sunburst):</strong> A sophisticated supply chain attack attributed to Russian intelligence (APT29). The attackers compromised the build process of a trusted software vendor to distribute their backdoor to over 18,000 organizations, allowing them to perform targeted espionage against high-value government and corporate networks.</li></ul><p>Researching this class of malware often requires a deep understanding of not just the technical details, but also the geopolitical context in which these tools are deployed.</p>",
                            "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "APT Campaign Tracking System (MITRE ATT&CK)",
                            "language": "json",
                            "code": "{\n  \"name\": \"APT29 (Cozy Bear) TTP Profile\",\n  \"description\": \"Commonly observed TTPs for the APT29 group, linked to Russian foreign intelligence.\",\n  \"domain\": \"enterprise-attack\",\n  \"techniques\": [\n    {\n      \"technique_id\": \"T1566.001\",\n      \"tactic\": \"initial-access\",\n      \"comment\": \"Frequently uses spearphishing with a link to a malicious file.\"\n    },\n    {\n      \"technique_id\": \"T1059.003\",\n      \"tactic\": \"execution\",\n      \"comment\": \"Extensive use of PowerShell for execution and fileless malware.\"\n    },\n    {\n      \"technique_id\": \"T1071.001\",\n      \"tactic\": \"command-and-control\",\n      \"comment\": \"Uses standard HTTPS for C2 to blend in with normal traffic.\"\n    },\n    {\n      \"technique_id\": \"T1558.003\",\n      \"tactic\": \"credential-access\",\n      \"comment\": \"Known for using Kerberoasting to steal service account credentials.\"\n    }\n  ]\n}"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the primary motivation for most nation-state APT groups?",
                            "options": [
                                "Short-term financial gain through ransomware.",
                                "Long-term espionage, intellectual property theft, or sabotage to achieve a strategic national objective.",
                                "Website defacement for ideological reasons.",
                                "Testing the security of corporate networks for fun."
                            ],
                            "correct": 1,
                            "explanation": "APTs are instruments of state power. Their goals are not criminal in the traditional sense, but are aligned with the intelligence-gathering or military objectives of the country they serve."
                        },
                        {
                            "id": 2,
                            "question": "The process of linking a piece of malware to a specific known threat actor group is known as:",
                            "options": [
                                "Reverse Engineering",
                                "Dynamic Analysis",
                                "Attribution",
                                "Decompilation"
                            ],
                            "correct": 2,
                            "explanation": "Attribution is the analytical process of determining the 'who' behind an attack. It is a difficult process that relies on correlating many different pieces of evidence, from technical TTPs to geopolitical context."
                        },
                        {
                            "id": 3,
                            "question": "The SolarWinds attack, where attackers compromised a software vendor to distribute malware to their customers, is a classic example of what?",
                            "options": [
                                "A DDoS attack",
                                "A phishing attack",
                                "A software supply chain attack",
                                "An insider threat"
                            ],
                            "correct": 2,
                            "explanation": "This is the textbook example of a sophisticated, nation-state-led supply chain attack. The attackers abused the trust relationship between a vendor (SolarWinds) and its customers to achieve widespread initial access."
                        }
                    ]
                }
            },
            {
                "id": "lesson-12",
                "title": "Artificial Intelligence and Machine Learning Malware",
                "duration": "90 min",
                "objectives": [
                    "Research the potential for AI-powered malware development.",
                    "Understand and defend against adversarial machine learning attacks.",
                    "Analyze the use of neural networks for evasion and obfuscation.",
                    "Develop defenses against AI-generated polymorphic malware.",
                    "Investigate the poisoning of machine learning models.",
                    "Research the use of AI for automated exploit generation and social engineering.",
                    "Discuss the ethical implications of AI in malware research."
                ],
                "content": {
                    "overview": "Artificial intelligence is poised to revolutionize the field of malware, creating a new generation of autonomous and adaptive threats. This lesson explores the cutting edge of research into AI-driven malware and the corresponding AI-driven defenses needed to counter it. We will discuss everything from AI-generated polymorphic code to the new threat of adversarial attacks against the machine learning models themselves.",
                    "sections": [
                        {
                            "title": "AI-Generated and Polymorphic Malware",
                            "content": "<p>AI, particularly Generative Adversarial Networks (GANs), can be trained to automatically generate new, functional malware variants. A GAN consists of two neural networks:</p><ul><li><strong>The Generator:</strong> Tries to create new malware samples that look like real malware.</li><li><strong>The Discriminator:</strong> Tries to distinguish between the real malware and the generated samples.</li></ul><p>The two networks train against each other. The generator's goal is to fool the discriminator. This can be adapted so that the discriminator is an AI-based antivirus engine. The generator's goal then becomes to automatically create new malware variants that can evade the latest AI defenses.</p>",
                            "image": "https://images.unsplash.com/photo-1620712943543-285f212a5a54?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Adversarial Machine Learning",
                            "content": "<p>This is a new class of attack that doesn't target the user or the OS, but targets the machine learning model of the security product itself.</p><h3>Types of Adversarial Attacks:</h3><ul><li><strong>Evasion:</strong> An attacker makes tiny, carefully crafted modifications to a piece of malware that are imperceptible to a human, but are just enough to trick an AI classifier into mislabeling it as 'benign'.</li><li><strong>Model Poisoning:</strong> An attacker with the ability to influence the training data for a model can intentionally insert mislabeled examples. This can create a 'backdoor' in the AI model, causing it to misclassify specific types of malware in the future.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "AI for Defense",
                            "content": "<p>While AI creates new threats, it is also the most powerful tool for defense.</p><p><strong>Real-time Problem: Analyzing AI-generated polymorphic malware.</strong> An attacker is using a GAN to generate thousands of unique malware variants per hour, each with a different signature, making traditional antivirus useless. The defending organization uses its own AI-based EDR agent. This agent was not trained on signatures, but on the *behavior* of malware. It has learned a high-dimensional model of what malicious process behavior looks like (e.g., opening a process, injecting code, connecting to the internet). Even though every variant of the malware file is different, the *behavior* once it runs is still fundamentally the same. The behavioral AI model detects this malicious pattern and blocks the threat, even though it has never seen that specific file before.</p>",
                            "image": "https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "AI Malware Detection and Generation (Conceptual GAN)",
                            "language": "python",
                            "code": "# This is a highly conceptual pseudocode representation of a Generative Adversarial Network (GAN)\n# for malware evasion research.\n\nclass Generator:\n    def create_variant(self, original_malware):\n        # Applies subtle, non-functional changes to the binary\n        # (e.g., reordering functions, adding junk code, changing strings)\n        new_variant = self.mutate(original_malware)\n        return new_variant\n\nclass Discriminator: # Represents the AI-based antivirus\n    def __init__(self, ai_model):\n        self.model = ai_model\n\n    def classify(self, malware_sample):\n        return self.model.predict(malware_sample)\n\n# --- Training Loop ---\n# generator = Generator()\n# ai_antivirus = Discriminator(load_model())\n# original_malware = load_sample()\n\n# for i in range(10000): # Train for many iterations\n#    variant = generator.create_variant(original_malware)\n#    prediction = ai_antivirus.classify(variant)\n\n#    # Provide feedback to the generator\n#    # If the AV detected the variant, the generator 'loses'.\n#    # If the AV missed the variant, the generator 'wins'.\n#    generator.train(feedback=prediction)\n\n# The goal is for the generator to learn which mutations are most likely\n# to fool the AI antivirus."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "A type of attack where an adversary makes tiny, calculated changes to a malware file to trick an AI-based antivirus into misclassifying it as benign is known as:",
                            "options": [
                                "A DDoS attack",
                                "An adversarial evasion attack",
                                "A supply chain attack",
                                "A physical attack"
                            ],
                            "correct": 1,
                            "explanation": "Adversarial evasion is a key threat to AI security. It exploits the fact that machine learning models can be 'fooled' by inputs that are crafted to fall just on the wrong side of their decision boundary."
                        },
                        {
                            "id": 2,
                            "question": "What is the primary advantage of using behavioral AI for defense against polymorphic malware?",
                            "options": [
                                "It is faster than signature-based detection.",
                                "Behavioral AI is trained on the typical *actions* of malware, not its file signature. Even if the malware file changes, its malicious behavior often remains the same.",
                                "It uses less memory.",
                                "It is always 100% accurate."
                            ],
                            "correct": 1,
                            "explanation": "Behavioral detection is the key defense against polymorphism. Since the malware's goal is the same, its core behavior (e.g., encrypting files, connecting to a C2) is often consistent, even if the code itself is different. Behavioral AI is designed to detect these malicious patterns of action."
                        },
                        {
                            "id": 3,
                            "question": "A Generative Adversarial Network (GAN) is composed of what two competing neural networks?",
                            "options": [
                                "A firewall and an antivirus.",
                                "A generator and a discriminator.",
                                "A client and a server.",
                                "A packer and an unpacker."
                            ],
                            "correct": 1,
                            "explanation": "A GAN uses a competitive dynamic. The generator creates fake data, and the discriminator tries to tell the fake data from the real data. This process allows the generator to become extremely good at creating realistic synthetic data, which can be applied to generating malware."
                        }
                    ]
                }
            },
            
        {
            "id": "lesson-13",
            "title": "Next-Generation Malware Platforms",
            "duration": "100 min",
            "objectives": [
                "Research the challenges of cross-platform malware (e.g., written in Go, Rust).",
                "Analyze malware that targets WebAssembly instead of traditional binaries.",
                "Investigate threats in containerized and serverless environments.",
                "Explore malware designed for edge computing and 5G networks.",
                "Discuss the long-term implications of quantum computing and brain-computer interfaces on malware.",
                "Research threats against space-based assets."
            ],
            "content": {
                "overview": "The computing landscape is undergoing a fundamental shift away from traditional desktop operating systems. This lesson explores the emerging platforms that will be the battleground for the next generation of malware research. From cross-platform languages and WebAssembly to serverless functions and space-based assets, we will examine the unique challenges of these new frontiers.",
                "sections": [
                    {
                        "title": "Cross-Platform Malware Research",
                        "content": "<p>Malware authors are increasingly using modern, cross-platform languages like Go and Rust. This allows them to write a single piece of malware that can be easily compiled to run on Windows, macOS, and Linux.</p><h3>Forensic Challenges:</h3><ul><li><strong>Large Binaries:</strong> Go binaries are statically linked, meaning they include all their library code in the executable. This makes them very large, which can challenge some analysis tools.</li><li><strong>Reverse Engineering Complexity:</strong> These modern languages have different and more complex internal structures than traditional C/C++ programs, requiring new reverse engineering skills and tools.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1587620962725-abab7fe55159?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "WebAssembly (WASM) Malware Analysis",
                        "content": "<p>WebAssembly is a binary instruction format for a stack-based virtual machine. It allows code written in languages like C++ or Rust to run in a web browser at near-native speed. It is also being used for server-side applications.</p><p><strong>Real-time Problem: Investigating WebAssembly-based malware.</strong> Attackers are now compiling malware to WASM for use in browser-based attacks like crypto-mining ('cryptojacking') or for highly portable server-side implants. Researching WASM malware requires a new set of tools. Instead of using IDA Pro to look at x86 assembly, the researcher must use specialized WASM disassemblers and decompilers to analyze the low-level bytecode of the WASM module and understand its malicious logic.</p>",
                        "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Container and Serverless Malware",
                        "content": "<p>As applications move to the cloud, so does the malware.</p><ul><li><strong>Container-Based Malware:</strong> Malware is now being designed to specifically target and compromise Docker and Kubernetes environments. This can include backdoored container images being uploaded to public registries or worms that exploit vulnerabilities to spread between containers.</li><li><strong>Serverless Malware:</strong> Research is emerging on malware that can infect serverless platforms like AWS Lambda. This is a major challenge as the execution environment is highly ephemeral and provides very limited forensic visibility.</li></ul><p>The research in this area is focused on supply chain security (scanning container images) and the deep analysis of cloud provider logs to find the faint trail of these fast-moving threats.</p>",
                        "image": "https://images.unsplash.com/photo-1544197150-b99a580bb7a8?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Next-Gen Platform Analysis Toolkit (WASM Decompiler)",
                        "language": "c",
                        "code": "/* This is conceptual output from a WebAssembly decompiler like wasm2c.\n   The tool takes a binary .wasm file and converts it back into a more readable,\n   C-like syntax, allowing a researcher to analyze its logic.\n*/\n\n// Original WASM binary: malware.wasm\n\n// --- Decompiled Output: malware.c ---\n\n// Function to allocate memory in the WASM environment\nu32 wasm_allocate(u32 size) { ... }\n\n// The core malicious function\nvoid perform_attack(u32 ip_address, u32 port) {\n  // Create a socket\n  u32 socket = wasm_socket_create();\n\n  // Connect to the C2 server\n  wasm_socket_connect(socket, ip_address, port);\n\n  // Receive a command\n  u32 command_buffer = wasm_allocate(1024);\n  wasm_socket_receive(socket, command_buffer);\n\n  // Execute the command\n  wasm_execute(command_buffer);\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is a primary advantage for malware authors using a cross-platform language like Go?",
                        "options": [
                            "The malware is easier to detect.",
                            "They can write a single codebase that can be easily compiled to run on Windows, macOS, and Linux.",
                            "The malware runs slower.",
                            "The executables are smaller."
                        ],
                        "correct": 1,
                        "explanation": "Cross-platform languages significantly reduce the development effort for attackers, allowing them to target a wider range of victims with the same malware family."
                    },
                    {
                        "id": 2,
                        "question": "WebAssembly (WASM) is a technology that allows code written in languages like C++ to run where?",
                        "options": [
                            "Only on mobile devices.",
                            "Only in the operating system kernel.",
                            "Inside a web browser and on server-side platforms.",
                            "Only on IoT devices."
                        ],
                        "correct": 2,
                        "explanation": "WASM is a portable binary format for the web, but its efficiency and portability are also making it a popular choice for server-side and edge computing, creating a new platform for malware to target."
                    },
                    {
                        "id": 3,
                        "question": "What is the primary forensic challenge of serverless malware (e.g., in AWS Lambda)?",
                        "options": [
                            "The execution environment is highly ephemeral, existing for only a few seconds, which makes traditional memory or disk forensics nearly impossible.",
                            "Serverless functions do not have access to the internet.",
                            "Serverless functions are too slow to run malware.",
                            "There are no logs for serverless functions."
                        ],
                        "correct": 0,
                        "explanation": "The extremely short-lived and stateless nature of serverless functions is their key forensic challenge. Investigation must shift almost entirely to the analysis of the detailed logs provided by the cloud platform."
                    }
                ]
            }
        },
        {
            "id": "lesson-14",
            "title": "Malware Economics and Underground Markets",
            "duration": "90 min",
            "objectives": [
                "Analyze the structure and operation of the cybercrime economy.",
                "Research the Malware-as-a-Service (MaaS) and Ransomware-as-a-Service (RaaS) business models.",
                "Investigate underground marketplaces on the dark web.",
                "Analyze the pricing models and supply chains for malware, exploits, and stolen data.",
                "Assess the economic impact of major malware campaigns.",
                "Develop strategies for disrupting the economic incentives of cybercrime."
            ],
            "content": {
                "overview": "Cybercrime is not a hobby; it is a multi-billion dollar industry with its own economy, supply chains, and business models. This lesson explores the field of malware economics, investigating the underground markets where malware is sold, the business models that drive the industry, and the economic incentives that motivate cybercriminals.",
                "sections": [
                    {
                        "title": "The Cybercrime Economy as a Supply Chain",
                        "content": "<p>The modern cybercrime ecosystem is highly specialized, much like a legitimate industry.</p><h3>The Roles in the Supply Chain:</h3><ul><li><strong>Developers:</strong> Write the malware (e.g., the ransomware payload).</li><li><strong>Initial Access Brokers:</strong> Specialize in gaining access to corporate networks, which they then sell to other criminals.</li><li><strong>Affiliates (Operators):</strong> 'Rent' the malware from the developers and use the access they bought to deploy it in a victim's network.</li><li><strong>Money Launderers:</strong> Provide services to cash out the cryptocurrency payments from a ransom into traditional currency.</li></ul><p>This specialization makes the ecosystem highly efficient and resilient.</p>",
                        "image": "https://images.unsplash.com/photo-1556742502-ec7c0e9f34b1?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Malware-as-a-Service (MaaS) and RaaS",
                        "content": "<p>This is the dominant business model for modern cybercrime. The MaaS model lowers the barrier to entry, allowing criminals with low technical skill to launch sophisticated attacks.</p><p><strong>Real-world Example: Ransomware-as-a-Service (RaaS).</strong> A skilled team of Russian developers creates a powerful piece of ransomware. They do not attack victims themselves. Instead, they recruit affiliates on dark web forums. They provide the affiliates with the ransomware, a list of targets, and a web portal to manage their attacks. The affiliate performs the intrusion and deploys the ransomware. When the victim pays, the developers automatically get a 20% cut of the ransom, and the affiliate gets the remaining 80%. The developers can support hundreds of affiliates, creating a highly scalable criminal enterprise.</p>",
                        "image": "https.unsplash.com/photo-1642155998158-9416a041cb42?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Market Disruption Strategies",
                        "content": "<p>Research in malware economics also informs strategies to fight cybercrime. By understanding the business model, law enforcement and security companies can launch operations to disrupt it.</p><h3>Disruption Tactics:</h3><ul><li><strong>Targeting the Choke Points:</strong> Instead of chasing thousands of low-level affiliates, law enforcement can focus on identifying and arresting the small number of core developers, which can dismantle an entire RaaS operation.</li><li><strong>Disrupting the Money Flow:</strong> Tracing and seizing the cryptocurrency wallets used by the criminals can disrupt their ability to profit from attacks.</li><li><strong>Infiltrating Markets:</strong> Law enforcement agencies often conduct covert operations to infiltrate or take over underground marketplaces to gather intelligence and identify the key actors.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1505664194779-8beace7a2044?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Underground Market Monitoring System (Conceptual)",
                        "language": "python",
                        "code": "import requests\nimport re\n\n# This conceptual script simulates scraping a dark web forum (via a Tor proxy)\n# to monitor for new malware listings.\n\n# Tor proxy must be running (e.g., on localhost:9050)\nproxies = {\n    'http': 'socks5h://localhost:9050',\n    'https': 'socks5h://localhost:9050'\n}\n\ndef monitor_market(forum_url):\n    \"\"\"Scrapes a dark web forum for keywords related to malware sales.\"\"\"\n    try:\n        response = requests.get(forum_url, proxies=proxies, timeout=30)\n        response.raise_for_status()\n\n        # In a real tool, this would be a sophisticated HTML parser.\n        # Here we just use a simple regex.\n        listings = re.findall(r'<a href=\"/listings/.*\">\\[WTS\\].*</a>', response.text)\n\n        print(f\"--- Monitoring Market: {forum_url} ---\")\n        for listing in listings:\n            if 'Ransomware' in listing or 'Botnet' in listing:\n                print(f\"[!] Potential Malware-as-a-Service Listing Found: {listing}\")\n\n    except requests.exceptions.RequestException as e:\n        print(f\"Error connecting to the Tor network or site: {e}\")\n\n# You would pass the .onion address of a known underground marketplace.\n# monitor_market(\"http://someforumxyz.onion/listings\")"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "The business model where skilled developers rent out their malware to less-skilled criminals in exchange for a cut of the profits is known as:",
                        "options": [
                            "A supply chain attack",
                            "A zero-day",
                            "Malware-as-a-Service (MaaS)",
                            "A botnet"
                        ],
                        "correct": 2,
                        "explanation": "MaaS (and its subset, RaaS) is the dominant business model for cybercrime. It lowers the barrier to entry and allows for massive scaling of criminal operations."
                    },
                    {
                        "id": 2,
                        "question": "In the cybercrime supply chain, what is the role of an 'Initial Access Broker'?",
                        "options": [
                            "To write the malware.",
                            "To launder the money.",
                            "To specialize in gaining access to corporate networks, which they then sell to other criminal groups.",
                            "To negotiate the ransom with the victim."
                        ],
                        "correct": 2,
                        "explanation": "Initial Access Brokers are specialists. Their entire business is breaching networks. They then sell that access on underground markets to other groups, like ransomware affiliates, who then carry out the final phase of the attack."
                    },
                    {
                        "id": 3,
                        "question": "From a law enforcement perspective, what is a primary goal of malware economics research?",
                        "options": [
                            "To learn how to write better malware.",
                            "To understand the business models and supply chains of cybercrime in order to develop effective disruption strategies.",
                            "To determine the fair market price for a zero-day exploit.",
                            "To invest in cryptocurrency."
                        ],
                        "correct": 1,
                        "explanation": "By understanding the economics, law enforcement can move beyond just responding to individual crimes and can launch strategic operations to disrupt the entire criminal ecosystem at its key choke points, like arresting the core developers or seizing their financial assets."
                    }
                ]
            }
        },
        {
            "id": "lesson-15",
            "title": "Malware Communication and Command Control Research",
            "duration": "100 min",
            "objectives": [
                "Reverse engineer and analyze custom C2 protocols.",
                "Research the use of legitimate services (e.g., social media, cloud storage) for C2.",
                "Develop methods to detect and decode DGA and fast flux networks.",
                "Investigate the use of blockchain and P2P networks for decentralized C2.",
                "Analyze steganographic techniques for hiding C2 in legitimate traffic.",
                "Develop strategies for C2 infrastructure takedown and disruption."
            ],
            "content": {
                "overview": "The Command and Control (C2) channel is the malware's lifeline to its master. Disrupting this channel can neutralize an entire botnet. This lesson is a deep dive into the research of malware C2, exploring the evolution of communication protocols from simple HTTP to advanced, decentralized, and hidden channels designed to be incredibly resilient.",
                "sections": [
                    {
                        "title": "C2 Architecture and Protocol Research",
                        "content": "<p>Malware C2 has evolved significantly.</p><h3>The Evolution:</h3><ul><li><strong>Centralized C2:</strong> The original model. All bots connect to a single, hardcoded IP address or domain. This is easy to disrupt: find the C2 server and take it down.</li><li><strong>Resilient C2:</strong> Attackers started using techniques like DGA and fast flux to make their C2 domains change constantly, making simple blocklists ineffective.</li><li><strong>Decentralized C2:</strong> Modern malware may use peer-to-peer (P2P) networks, where infected bots talk to each other to relay commands. There is no central server to take down. Others use public blockchains to store C2 information in a decentralized and uncensorable way.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Using Legitimate Services for C2",
                        "content": "<p>One of the most effective modern C2 techniques is to hide in plain sight by using popular, legitimate web services for communication.</p><p><strong>Real-time Problem: Disrupting advanced C2 infrastructure.</strong> A researcher is analyzing an APT's malware. They find that it does not connect to a suspicious IP address. Instead, it uses the Twitter API. The malware searches Twitter for a specific, obscure hashtag. The attacker posts a tweet containing that hashtag, and the tweet's content is actually an encoded, encrypted command for the botnet. Because the traffic is going to `api.twitter.com`, it is encrypted with a legitimate Twitter TLS certificate and is almost impossible to block at the network level without blocking all of Twitter. Researching this involves reverse engineering the malware to understand the C2 protocol (e.g., which hashtag it looks for, how the commands are encoded) to provide high-fidelity intelligence for detection.</p><h3>Other Abused Services:</h3><ul><li>Google Drive, Dropbox, Telegram, Discord, and even Gmail.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1611605698335-8b1569810432?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Steganographic and Covert Channels",
                        "content": "<p>The stealthiest C2 channels hide their data within what appears to be normal network traffic.</p><ul><li><strong>Steganography:</strong> A malware sample might download a seemingly innocent image file from a public website. However, the C2 command is hidden in the least significant bits of the image's pixel data.</li><li><strong>Protocol Tunneling:</strong> Hiding C2 traffic inside a protocol that is almost always allowed, like DNS or ICMP.</li></ul><p>Researching these requires deep protocol analysis and statistical methods to find the hidden data that deviates from the normal protocol specification.</p>",
                        "image": "https://images.unsplash.com/photo-1548092372-2d987bde8h98b?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "C2 Protocol Analysis and Simulation (Scapy)",
                        "language": "python",
                        "code": "# This Scapy script demonstrates reverse engineering a simple, custom C2 protocol.\n# The malware sends a beacon with a magic value, and the server replies with a command.\n\nfrom scapy.all import sniff, TCP, IP, Raw\n\nC2_SERVER_IP = \"198.51.100.55\"\nC2_PORT = 1337\nBEACON_MAGIC = b'\\xDE\\xAD\\xBE\\xEF'\n\ndef process_packet(packet):\n    \"\"\"This function is called for each packet sniffed.\"\"\"\n    if packet.haslayer(TCP) and packet[IP].src == C2_SERVER_IP and packet[TCP].sport == C2_PORT:\n        if packet.haslayer(Raw):\n            payload = packet[Raw].load\n            # Reverse engineer the command structure\n            command_code = payload[0]\n            command_arg = payload[1:].decode('utf-8', errors='ignore')\n\n            print(f\"[+] Received C2 Command:\")\n            print(f\"    Command Code: {hex(command_code)}\")\n            print(f\"    Argument: {command_arg}\")\n\n# Sniff for traffic coming from the C2 server.\n# A researcher would first run the malware to generate the initial beacon,\n# then run this script to capture and decode the server's reply.\nsniff(filter=f\"tcp and host {C2_SERVER_IP} and port {C2_PORT}\", prn=process_packet)"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "A malware technique that generates thousands of new, pseudo-random domain names each day to find its C2 server is known as:",
                        "options": [
                            "Fast Flux",
                            "A Domain Generation Algorithm (DGA)",
                            "DNS Tunneling",
                            "A DDoS Attack"
                        ],
                        "correct": 1,
                        "explanation": "DGA is a resiliency technique. By generating a huge number of potential domains, the malware ensures it can find its C2 server even if defenders are constantly blocking the previously used domains."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary advantage for an attacker using a legitimate service like Twitter or Google Drive for their C2 channel?",
                        "options": [
                            "These services are slower, which makes the malware harder to track.",
                            "The C2 traffic is encrypted with a legitimate certificate from a trusted provider and goes to a domain that cannot be blocked, making it extremely difficult to detect at the network level.",
                            "These services are free.",
                            "It is easier to write the malware."
                        ],
                        "correct": 1,
                        "explanation": "This technique, known as 'domain fronting' or simply abusing legitimate services, is a highly effective evasion method. It blends malicious traffic with legitimate traffic, making network-based detection a major challenge."
                    },
                    {
                        "id": 3,
                        "question": "A type of C2 architecture where infected machines communicate with each other to relay commands, rather than relying on a single central server, is known as:",
                        "options": [
                            "Centralized C2",
                            "Fast Flux C2",
                            "Peer-to-Peer (P2P) C2",
                            "HTTP C2"
                        ],
                        "correct": 2,
                        "explanation": "P2P C2 is a decentralized model that is highly resilient to takedowns. Because there is no single server to disable, disrupting a P2P botnet is significantly more difficult."
                    }
                ]
            }
        },
        {
            "id": "lesson-16",
            "title": "Malware Propagation and Distribution Research",
            "duration": "90 min",
            "objectives": [
                "Analyze the different infection vectors used by malware.",
                "Model the propagation of self-spreading worms.",
                "Research the integration of social engineering in malware distribution.",
                "Investigate supply chain infection and patch delivery attacks.",
                "Analyze the mechanics of web-based exploit kits.",
                "Research autonomous propagation and its potential impact."
            ],
            "content": {
                "overview": "Before malware can act, it must arrive. This lesson focuses on the research of malware distribution and propagation—the methods attackers use to deliver their payloads to victims and the techniques worms use to spread autonomously from one system to another. Understanding these mechanisms is key to preventing infections in the first place.",
                "sections": [
                    {
                        "title": "Infection Vector Analysis",
                        "content": "<p>The infection vector is the method by which the malware is delivered to the initial target system.</p><h3>Common Vectors:</h3><ul><li><strong>Email Attachments/Links:</strong> Still the number one vector. Involves social engineering to trick the user into opening a malicious document or clicking a link.</li><li><strong>Web-Based (Exploit Kits):</strong> The user visits a compromised website, which redirects them to a server hosting an exploit kit. The kit probes the user's browser for vulnerabilities and, if one is found, delivers the malware payload.</li><li><strong>Software Supply Chain:</strong> As seen with SolarWinds, the malware is delivered via a legitimate software update from a trusted vendor.</li><li><strong>Removable Media:</strong> The classic vector for worms like Stuxnet, spreading via infected USB drives.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1563206414-99371216c39a?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Worm Propagation Modeling",
                        "content": "<p>A worm is a piece of malware that, once it infects a machine, can autonomously propagate or spread to other machines without any human interaction. Researching worms often involves modeling their behavior to predict their speed and impact.</p><p><strong>Real-world Example: The WannaCry Worm.</strong> WannaCry was a ransomware worm that spread with devastating speed in 2017. It used the 'EternalBlue' exploit, which targeted a vulnerability in the Windows SMB protocol. Once it infected a machine, it would scan the local network and the internet for other vulnerable machines and use the exploit to infect them. This self-propagation allowed it to infect hundreds of thousands of computers in a single day. Research into WannaCry's propagation involved creating epidemiological models, similar to those used for disease, to map and predict its spread.</p>",
                        "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Exploit Kit Analysis",
                        "content": "<p>An exploit kit is a piece of software that runs on a web server, designed to automate the exploitation of client-side vulnerabilities.</p><h3>The Exploit Kit Workflow:</h3><ol><li>A user visits a compromised website.</li><li>They are silently redirected to the exploit kit's 'landing page'.</li><li>The landing page runs code to probe the victim's browser and its plugins (like Flash or Java) for a list of known vulnerabilities.</li><li>If a vulnerability is found, the kit serves up the corresponding exploit.</li><li>If the exploit is successful, it delivers the final malware payload (e.g., ransomware or a banking trojan).</li></ol><p>Research in this area involves capturing and reverse engineering the exploit code and the sophisticated obfuscation that exploit kits use to evade detection.</p>",
                        "image": "https://images.unsplash.com/photo-1555949963-ff9fe0c870eb?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Propagation Simulation and Analysis Platform (Conceptual)",
                        "language": "python",
                        "code": "import networkx as nx\nimport random\n\n# This conceptual script uses the NetworkX library to model the spread of a worm.\n\ndef simulate_worm_spread(network_graph, initial_infected_node, vulnerability_rate):\n    infected = {initial_infected_node}\n    \n    for t in range(10): # Simulate 10 time steps\n        newly_infected = set()\n        for node in infected:\n            for neighbor in network_graph.neighbors(node):\n                # Check if the neighbor is vulnerable and not already infected\n                if random.random() < vulnerability_rate and neighbor not in infected:\n                    newly_infected.add(neighbor)\n        infected.update(newly_infected)\n        print(f\"Time {t}: {len(infected)} nodes infected.\")\n\n# 1. Create a sample network topology (e.g., a scale-free network)\nG = nx.barabasi_albert_graph(1000, 3) # 1000 nodes\n\n# 2. Run the simulation\nsimulate_worm_spread(G, initial_infected_node=0, vulnerability_rate=0.10)"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "A self-propagating piece of malware that spreads from one computer to another without human interaction is known as a:",
                        "options": [
                            "Trojan",
                            "Virus",
                            "Worm",
                            "Rootkit"
                        ],
                        "correct": 2,
                        "explanation": "The key characteristic of a worm is its ability to spread autonomously. A virus requires a host file to spread, and a trojan does not self-propagate."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary function of a web-based exploit kit?",
                        "options": [
                            "To send phishing emails.",
                            "To launch a DDoS attack.",
                            "To automate the process of probing a victim's browser for vulnerabilities and delivering a malware payload if one is found.",
                            "To encrypt files for ransom."
                        ],
                        "correct": 2,
                        "explanation": "Exploit kits are automated attack platforms. They act as the delivery mechanism for many types of malware by finding and exploiting vulnerabilities in the browsers of users who visit a compromised site."
                    },
                    {
                        "id": 3,
                        "question": "The WannaCry attack was a hybrid of ransomware and what other type of malware?",
                        "options": [
                            "A virus",
                            "Spyware",
                            "A worm",
                            "A trojan"
                        ],
                        "correct": 2,
                        "explanation": "WannaCry was a ransomware worm. The ransomware was the payload, but the worm-like, self-propagating behavior (using the EternalBlue exploit) was what made it spread so rapidly and cause such widespread damage."
                    }
                ]
            }
        },
        {
            "id": "lesson-17",
            "title": "Malware Detection and Evasion Research",
            "duration": "100 min",
            "objectives": [
                "Research methods to bypass signature-based and heuristic antivirus.",
                "Develop techniques to evade behavioral analysis and EDR systems.",
                "Research and implement sandbox detection and evasion.",
                "Analyze memory-based detection evasion techniques.",
                "Explore the research of hardware-based detection and its potential bypasses."
            ],
            "content": {
                "overview": "Malware research is an arms race. As defenders develop new detection technologies, attackers develop new evasion techniques. This lesson explores the offensive side of research: understanding and replicating the methods that malware authors use to bypass the latest and greatest defensive technologies, from antivirus and EDR to advanced sandboxes.",
                "sections": [
                    {
                        "title": "Bypassing Signature-Based and Heuristic AV",
                        "content": "<p>This is the most basic level of evasion.</p><ul><li><strong>Signature Bypass:</strong> A signature is a unique fingerprint of a known malicious file. Any minor change to the file—even appending a single null byte—will change its hash and evade a simple signature-based check. This is why polymorphic malware is so effective.</li><li><strong>Heuristic Bypass:</strong> Heuristic engines look for suspicious characteristics (e.g., the presence of a packing routine). Attackers can bypass this by carefully crafting their code to avoid these suspicious indicators, or by using encryption and obfuscation to hide them.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1548092372-2d987bde898b?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Endpoint Detection and Response (EDR) Evasion",
                        "content": "<p>EDR is a behavioral defense, so bypassing it requires more advanced techniques.</p><h3>Evasion Techniques:</h3><ul><li><strong>Direct System Calls:</strong> Many EDRs work by hooking common Windows API functions in user-mode. Sophisticated malware can bypass these hooks by making the system call directly to the kernel, which is a much stealthier way to execute a command.</li><li><strong>Living-off-the-Land:</strong> By using only legitimate, signed Microsoft binaries (like PowerShell), malware can make its behavior appear more like a legitimate administrator's activity, making it harder for a behavioral engine to flag as malicious.</li><li><strong>Kernel-Level Tampering:</strong> The most advanced EDR bypasses involve a kernel-mode component (a rootkit) that can directly attack the EDR's own driver, disabling its protections from Ring 0.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1504384308090-c894fdcc538d?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Sandbox Detection and Evasion Research",
                        "content": "<p>As covered previously, malware is often designed to detect when it is running in an automated analysis environment.</p><p><strong>Real-time Problem: Developing an undetectable research sample.</strong> A red team is developing a new implant for an adversary emulation exercise. They know the target uses a specific sandbox product. The red team researchers get a copy of that sandbox and analyze its environment in detail. They find that the sandbox VM always has a specific hardware ID for its virtual network card. The researchers then add a check to their malware: 'Get the hardware ID of the network card. If it matches the sandbox's ID, exit immediately.' By building in these specific checks, they can create a payload that will appear benign in the automated sandbox but will execute normally on a real user's machine. This type of research is crucial for both attackers and defenders to understand the limitations of their tools.</p>",
                        "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Advanced Evasion Technique Framework (Sandbox Evasion)",
                        "language": "c",
                        "code": "// This is a conceptual C++ code snippet demonstrating a common sandbox evasion technique:\n// checking the amount of time that has passed.\n\n#include <iostream>\n#include <chrono>\n#include <thread>\n\n// Many sandboxes will accelerate the system clock or skip over 'sleep' calls\n// to make the analysis faster. This code tries to detect that.\n\nbool is_in_sandbox() {\n    auto start_time = std::chrono::steady_clock::now();\n\n    // Sleep for 2 seconds.\n    std::this_thread::sleep_for(std::chrono::seconds(2));\n\n    auto end_time = std::chrono::steady_clock::now();\n\n    auto elapsed_seconds = std::chrono::duration_cast<std::chrono::seconds>(end_time - start_time).count();\n\n    // If the sleep call was accelerated by the sandbox, less than 2 seconds will have passed.\n    if (elapsed_seconds < 2) {\n        return true; // We are likely in a sandbox\n    } else {\n        return false; // Likely a real system\n    }\n}\n\nint main() {\n    if (is_in_sandbox()) {\n        std::cout << \"Sandbox detected. Exiting.\" << std::endl;\n        return 0;\n    } else {\n        std::cout << \"Executing malicious payload...\" << std::endl;\n        // Malicious code would go here.\n    }\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "A piece of malware that changes its code with every new infection to evade signature-based detection is known as:",
                        "options": [
                            "A rootkit",
                            "A worm",
                            "Polymorphic malware",
                            "A bootkit"
                        ],
                        "correct": 2,
                        "explanation": "Polymorphism is a classic evasion technique. By constantly changing its own structure, the malware ensures that no two samples have the same file hash or signature."
                    },
                    {
                        "id": 2,
                        "question": "A sophisticated piece of malware that wants to bypass a user-mode EDR agent might do what?",
                        "options": [
                            "Use direct system calls to communicate with the kernel, bypassing the EDR's hooks on the Windows API.",
                            "Ask the user for permission to turn off the EDR.",
                            "Delete the EDR's executable file from the hard drive.",
                            "Connect to the internet over a faster connection."
                        ],
                        "correct": 0,
                        "explanation": "Many EDRs work by hooking API calls in user mode. By using a direct system call, the malware can talk to the kernel without going through the hooked, monitored functions, effectively making its actions invisible to that type of EDR."
                    },
                    {
                        "id": 3,
                        "question": "A malware sample that checks the MAC address of the network card or the number of recent documents to see if it's running on a real user's machine is performing what?",
                        "options": [
                            "C2 communication",
                            "Data exfiltration",
                            "Sandbox evasion",
                            "File encryption"
                        ],
                        "correct": 2,
                        "explanation": "These are 'environmental' checks. The malware is looking for the signs of a real, lived-in computer. Automated sandboxes often have generic hardware IDs and a sterile environment, which this malware is designed to detect so it can avoid revealing its true behavior."
                    }
                ]
            }
        },
        {
            "id": "lesson-18",
            "title": "Malware Attribution and Threat Intelligence Research",
            "duration": "100 min",
            "objectives": [
                "Apply code similarity analysis to link related malware samples.",
                "Identify the compiler, language, and tools used by a malware author.",
                "Use infrastructure analysis and timing analysis for attribution.",
                "Detect false flag operations and intentional misdirection.",
                "Develop and apply a formal attribution confidence scoring model.",
                "Contribute research findings to the broader threat intelligence community."
            ],
            "content": {
                "overview": "Attribution—determining the 'who' behind a piece of malware—is one of the most challenging and high-stakes aspects of research. This lesson covers the advanced analytical techniques used to link malware samples to specific campaigns and threat actors. We will explore how to move beyond a single sample to the campaign-level tracking that defines modern threat intelligence.",
                "sections": [
                    {
                        "title": "Code Similarity and Threat Actor Profiling",
                        "content": "<p>Attackers, like all developers, are lazy. They reuse code, tools, and infrastructure. Finding these overlaps is the key to attribution.</p><h3>Techniques for Finding Overlaps:</h3><ul><li><strong>Code Similarity (BinDiff):</strong> Tools like BinDiff can compare the functions in two different executables and identify which ones are identical or highly similar. Finding a significant amount of shared code between a new sample and a known malware family is a strong link.</li><li><strong>Compiler and Toolchain Analysis:</strong> Analyzing the specific compiler, packer, and libraries used can create a fingerprint. Some APT groups consistently use a specific, older version of a compiler for all their tools.</li><li><strong>Programming Style:</strong> Even in compiled code, a researcher can sometimes identify the unique 'style' of a developer, such as how they handle errors or structure their code.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1556091212-a1b6379a05de?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Infrastructure and Timing Analysis",
                        "content": "<p>The infrastructure an attacker uses can also be a powerful fingerprint.</p><ul><li><strong>Infrastructure Overlap:</strong> An attacker might reuse the same C2 server, domain registration information, or TLS certificate across multiple campaigns.</li><li><strong>Timing Analysis:</strong> By analyzing the timestamps in malware samples or the active times of C2 servers, a researcher might be able to determine the attacker's working hours and infer their time zone, which can be a clue to their country of origin.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "False Flags and Attribution Confidence",
                        "content": "<p>Sophisticated adversaries know that researchers are looking for these overlaps. They can intentionally plant 'false flags'—clues designed to mislead analysts and make an attack look like it was carried out by a different group.</p><p><strong>Real-time Problem: Attributing a sophisticated false flag operation.</strong> A new piece of malware is discovered that contains code snippets and C2 domains known to be used by a Chinese APT group. However, a deeper analysis by a senior researcher reveals that the code, while similar, has subtle but significant errors that the real Chinese group would not make. Furthermore, the compile times of the malware all correspond to a 9-to-5 workday in the UTC+3 timezone (Moscow). The researcher concludes that the Chinese clues were likely a false flag, and makes a *moderate-confidence assessment* that the attack was actually carried out by a Russian APT group.</p><h3>Attribution Confidence Levels:</h3><p>Because of false flags and incomplete data, attribution is never 100% certain. Researchers use formal confidence levels (e.g., High, Moderate, Low) to express their analytical judgment based on the weight of the evidence.</p>",
                        "image": "https://images.unsplash.com/photo-1548092372-2d987bde898b?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Attribution Analysis Automation System (Conceptual)",
                        "language": "python",
                        "code": "class AttributionEngine:\n    def __init__(self, threat_intel_db):\n        self.db = threat_intel_db\n\n    def attribute_sample(self, new_sample_features):\n        \"\"\"Compares a new sample's features against a database of known APT groups.\"\"\"\n        scores = {}\n\n        for apt_profile in self.db.get_all_apt_profiles():\n            current_score = 0\n            # Compare code similarity (e.g., using fuzzy hashes of functions)\n            code_similarity_score = self.db.compare_code(new_sample_features.functions, apt_profile.functions)\n            current_score += code_similarity_score * 0.5 # Weight code similarity heavily\n\n            # Compare C2 infrastructure\n            if new_sample_features.c2_domain in apt_profile.known_domains:\n                current_score += 0.3 # High score for infrastructure overlap\n\n            # Compare TTPs (e.g., specific persistence method)\n            if new_sample_features.persistence_method == apt_profile.preferred_ttp:\n                current_score += 0.2\n            \n            scores[apt_profile.name] = current_score\n\n        # Return the APT with the highest matching score\n        best_match = max(scores, key=scores.get)\n        confidence = scores[best_match]\n        return best_match, confidence\n"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "The process of linking a piece of malware to a specific known threat actor group is known as:",
                        "options": [
                            "Reverse Engineering",
                            "Dynamic Analysis",
                            "Attribution",
                            "Decompilation"
                        ],
                        "correct": 2,
                        "explanation": "Attribution is the analytical process of determining the 'who' behind an attack. It is a difficult process that relies on correlating many different pieces of evidence, from technical TTPs to geopolitical context."
                    },
                    {
                        "id": 2,
                        "question": "An attacker intentionally plants clues (e.g., code from another malware family) in their malware to mislead investigators. This is known as a:",
                        "options": [
                            "A watering hole attack",
                            "A false flag operation",
                            "A denial-of-service attack",
                            "A zero-day exploit"
                        ],
                        "correct": 1,
                        "explanation": "A false flag is a deliberate misdirection technique designed to make an attack appear as if it was carried out by someone other than the true perpetrator."
                    },
                    {
                        "id": 3,
                        "question": "An analyst discovers that a new piece of malware communicates with a C2 server that was used in a previous campaign by a known APT group. This is an example of what kind of attribution indicator?",
                        "options": [
                            "Code Similarity",
                            "Timing Analysis",
                            "Infrastructure Overlap",
                            "Programming Style"
                        ],
                        "correct": 2,
                        "explanation": "Infrastructure overlap is a powerful indicator. Attackers often reuse their servers, domains, and certificates, and finding this overlap provides a strong link between different campaigns."
                    }
                ]
            }
        },
        {
            "id": "lesson-19",
            "title": "Vulnerability Research and Exploit Development",
            "duration": "120 min",
            "objectives": [
                "Understand the methodologies for discovering new vulnerabilities (e.g., fuzzing, static analysis).",
                "Learn the fundamentals of exploit development.",
                "Analyze advanced exploitation techniques like Return-Oriented Programming (ROP).",
                "Investigate heap and stack-based memory corruption vulnerabilities.",
                "Explore kernel and browser exploitation techniques.",
                "Understand the process of responsible disclosure for newly discovered vulnerabilities."
            ],
            "content": {
                "overview": "Malware often gets its initial foothold by exploiting a vulnerability in a piece of software. This lesson delves into the world of vulnerability research and exploit development, covering the techniques researchers use to find new bugs ('zero-days') and the methods attackers use to turn those bugs into reliable exploits that can be used to compromise a system.",
                "sections": [
                    {
                        "title": "Vulnerability Discovery Methodologies",
                        "content": "<p>A vulnerability is a flaw in a program's code that can be leveraged by an attacker to cause an unintended behavior.</p><h3>Common Discovery Methods:</h3><ul><li><strong>Fuzzing:</strong> The most common method. A 'fuzzer' is an automated tool that sends a huge volume of malformed, unexpected, and random data to an application's input, hoping to trigger a crash. Every crash is a potential vulnerability that can then be investigated.</li><li><strong>Static Code Analysis (SCA):</strong> Analyzing a program's source code (if available) or its disassembled binary to look for common programming errors that lead to vulnerabilities (e.g., buffer overflows).</li><li><strong>Patch Diffing:</strong> When a vendor releases a security patch, a researcher can reverse engineer the patch to see exactly what code was changed. This tells them exactly where the vulnerability was, and they can then develop an exploit for it to use against unpatched systems.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Exploit Development Fundamentals",
                        "content": "<p>An exploit is the specific piece of code that takes advantage of a vulnerability to achieve code execution.</p><p><strong>Real-world Example: A basic stack buffer overflow.</strong> A program has a small buffer (e.g., 128 bytes) on the stack to hold the user's name. It uses an unsafe function like `strcpy` to copy the user's input into the buffer, but it doesn't check the length. An attacker provides an input of 200 bytes. The extra bytes overflow the buffer and overwrite other critical data on the stack, including the 'return address', which tells the CPU where to go after the function is done. The attacker crafts their input so that they overwrite the return address with the address of their own malicious code (the 'shellcode'). When the function finishes, instead of returning to the legitimate program, the CPU jumps to the attacker's shellcode and executes it, compromising the system.</p>",
                        "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Advanced Exploitation: ROP and Heap Spraying",
                        "content": "<p>Modern operating systems have defenses that make basic exploitation much harder, like Data Execution Prevention (DEP), which prevents code on the stack from being executed.</p><h3>Bypass Techniques:</h3><ul><li><strong>Return-Oriented Programming (ROP):</strong> Instead of writing their own shellcode, an attacker uses small, existing snippets of code ('gadgets') from the legitimate program's libraries. They chain these gadgets together by manipulating the stack, effectively building their desired functionality out of the program's own code, thus bypassing DEP.</li><li><strong>Heap Spraying:</strong> A technique used in browser exploits where the attacker fills the browser's memory (the heap) with many copies of their shellcode, increasing the probability that they can successfully redirect execution to it.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Advanced Fuzzing Framework (Conceptual Boofuzz)",
                        "language": "python",
                        "code": "# This is a conceptual script using the 'boofuzz' fuzzing framework.\n# It defines a simple protocol and then automatically sends thousands of\n# malformed variations to the target server to try and find a crash.\n\nfrom boofuzz import Session, Target, s_initialize, s_string, s_static\n\n# 1. Define the protocol we want to fuzz\n# A simple protocol with a command and a string argument\ns_initialize(name=\"Request\")\ns_static(\"CMD=\", name=\"command_key\")\ns_string(\"DEFAULT\", name=\"command_value\")\ns_static(\"\\r\\n\", name=\"end\")\n\n# 2. Define the session and target\nsession = Session(\n    target=Target(connection_string=\"tcp://127.0.0.1:9999\"),\n)\nsession.connect(s_get(\"Request\"))\n\n# 3. Start the fuzzer\nsession.fuzz()\n\n# The boofuzz engine will now automatically generate thousands of mutations\n# (e.g., very long strings, weird characters, incorrect formats) and send them\n# to the target. The researcher monitors the target application for any crashes,\n# which indicate a potential vulnerability."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "The automated technique of sending a large volume of malformed and random data to an application to find crashes is known as:",
                        "options": [
                            "Fuzzing",
                            "Patch Diffing",
                            "Static Analysis",
                            "A ROP Chain"
                        ],
                        "correct": 0,
                        "explanation": "Fuzzing is the most common and effective method for discovering new vulnerabilities. It is a brute-force approach that automatically finds edge cases the original programmers didn't anticipate."
                    },
                    {
                        "id": 2,
                        "question": "A stack buffer overflow exploit works by overwriting what critical piece of data on the stack?",
                        "options": [
                            "The user's password.",
                            "The function's return address.",
                            "A global variable.",
                            "The heap pointer."
                        ],
                        "correct": 1,
                        "explanation": "The return address tells the CPU where to resume execution after a function completes. By overwriting it, an attacker can hijack the program's control flow and redirect it to their own malicious code."
                    },
                    {
                        "id": 3,
                        "question": "Return-Oriented Programming (ROP) is an advanced exploitation technique primarily designed to bypass what common OS security mitigation?",
                        "options": [
                            "The firewall",
                            "Antivirus",
                            "Address Space Layout Randomization (ASLR)",
                            "Data Execution Prevention (DEP)"
                        ],
                        "correct": 3,
                        "explanation": "DEP prevents an attacker from simply placing their shellcode on the stack and executing it. ROP bypasses this by reusing existing, legitimate code snippets ('gadgets') to build its payload, so it is only ever executing code in memory that is already marked as executable."
                    }
                ]
            }
        },
        {
            "id": "lesson-20",
            "title": "Malware Research Automation and Scalability",
            "duration": "90 min",
            "objectives": [
                "Design and build an automated pipeline for large-scale malware analysis.",
                "Utilize distributed architectures for processing millions of samples.",
                "Integrate cloud-based platforms for scalable research.",
                "Automate the process of acquiring new malware samples.",
                "Develop systems for automatic correlation and reporting of analysis results.",
                "Implement quality assurance and reproducibility frameworks for automated systems."
            ],
            "content": {
                "overview": "The volume of new malware is far too great for any human or team to analyze manually. Modern malware research relies on large-scale automation to process, analyze, and classify millions of samples per day. This lesson covers the architectural and engineering principles for building a scalable, automated malware analysis pipeline.",
                "sections": [
                    {
                        "title": "The Automated Analysis Pipeline",
                        "content": "<p>A high-throughput analysis pipeline is a multi-stage, automated workflow that takes a raw malware sample as input and produces a structured report as output.</p><h3>A Typical Pipeline:</h3><ol><li><strong>Acquisition:</strong> Automated systems (e.g., honeypots, spam traps, web crawlers) collect hundreds of thousands of new samples per day.</li><li><strong>Triage & Deduplication:</strong> The pipeline first hashes each sample. If the hash has been seen before, it is discarded.</li><li><strong>Static Analysis:</strong> The unique sample is run through a bank of rapid static analysis tools to extract features like strings, imports, and fuzzy hashes.</li><li><strong>Dynamic Analysis:</strong> The sample is submitted to a large cluster of sandbox VMs for behavioral analysis.</li><li><strong>Correlation & Reporting:</strong> The results from the static and dynamic analysis are aggregated, correlated, and stored in a searchable database. A structured report (e.g., in JSON format) is generated for each sample.</li></ol>",
                        "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Distributed and Cloud-Based Architectures",
                        "content": "<p>To process millions of samples, the analysis cannot run on a single machine. The pipeline is built on a distributed architecture.</p><p><strong>Real-time Problem: Processing millions of malware samples.</strong> A major antivirus company receives 500,000 new potential malware samples every day. Their automated pipeline is built on a cloud platform. When a new sample arrives, a cloud function triggers. It spins up a temporary virtual machine, performs the static analysis, and then submits the file to a large-scale sandbox cluster (which might have thousands of VMs running in parallel). The entire process for a single file might take 5 minutes, but by running thousands of these analyses concurrently in the cloud, the system can easily handle the massive daily volume.</p>",
                        "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Research Reproducibility in Automated Systems",
                        "content": "<p>Even in an automated system, the scientific principle of reproducibility is key. A good research pipeline does not just produce a final report; it preserves all the intermediate data.</p><h3>Ensuring Reproducibility:</h3><ul><li><strong>Preserve the Sample:</strong> The original malware sample is stored in a secure repository.</li><li><strong>Log Everything:</strong> The exact versions of all analysis tools used are logged.</li><li><strong>Capture Raw Data:</strong> All the raw output from the analysis (e.g., the memory dump and PCAP from the sandbox) is preserved.</li></ul><p>This allows a researcher to come back months or years later, re-run an analysis with a new tool, and reproduce or challenge the original findings.</p>",
                        "image": "https://images.unsplash.com/photo-1454165804606-c3d57bc86b40?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Scalable Automated Analysis Platform (Conceptual)",
                        "language": "python",
                        "code": "# This conceptual script outlines the logic for a dispatcher in a distributed\n# malware analysis system, using a task queue like RabbitMQ or Celery.\n\nimport task_queue\n\ndef acquire_new_samples(source):\n    # This function would get new malware samples from a source (e.g., a honeypot).\n    return [\"sample1.exe\", \"sample2.exe\"]\n\ndef main():\n    # 1. Acquire new samples to be processed.\n    new_samples = acquire_new_samples(source=\"spam_trap\")\n\n    print(f\"[*] Acquired {len(new_samples)} new samples. Submitting for analysis.\")\n\n    for sample_path in new_samples:\n        # 2. Check if we have seen this hash before.\n        # if not database.has_hash(calculate_hash(sample_path)):\n        \n        # 3. For each unique sample, submit a task to the distributed queue.\n        # A worker machine in the analysis cluster will pick up this task and execute it.\n        task_queue.submit(\n            analysis_type=\"full_pipeline\", \n            sample_path=sample_path\n        )\n\n    print(\"[+] All new samples have been submitted to the analysis cluster.\")\n\n# A separate worker script would define the 'full_pipeline' task, which would\n# include static analysis, dynamic analysis, and reporting."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary purpose of an automated malware analysis pipeline?",
                        "options": [
                            "To replace the need for human researchers.",
                            "To handle the massive volume of new malware samples by automating the triage, analysis, and classification process.",
                            "To make malware analysis reports more complicated.",
                            "To develop new malware."
                        ],
                        "correct": 1,
                        "explanation": "Automation is the only way to cope with the scale of the modern malware problem. The pipeline handles the millions of commodity samples, allowing human experts to focus on the most novel and sophisticated threats."
                    },
                    {
                        "id": 2,
                        "question": "In a large-scale analysis pipeline, what is the first step that is typically performed on a newly acquired sample?",
                        "options": [
                            "A deep reverse engineering of its code.",
                            "Its cryptographic hash is calculated and checked against a database to see if it's a duplicate of a previously analyzed sample.",
                            "It is submitted to law enforcement.",
                            "It is immediately deleted."
                        ],
                        "correct": 1,
                        "explanation": "Deduplication is a critical first step for efficiency. The vast majority of malware samples seen in the wild are duplicates. By hashing the file first, the pipeline can avoid re-analyzing millions of identical files."
                    },
                    {
                        "id": 3,
                        "question": "Why is it important for an automated research pipeline to preserve all the raw data from its analysis (e.g., the memory dump from the sandbox)?",
                        "options": [
                            "To make the storage costs higher.",
                            "To ensure the scientific principle of reproducibility, allowing a researcher to re-examine the raw evidence with new tools in the future.",
                            "It is not important to preserve the raw data.",
                            "To use as a screensaver."
                        ],
                        "correct": 1,
                        "explanation": "Reproducibility is a core scientific principle. A finding is not truly valid unless another researcher can reproduce it. Preserving the raw evidence allows for this re-examination and validation, which is essential for credible research."
                    }
                ]
            }
        },
        {
            "id": "lesson-21",
            "title": "Advanced Research Methodologies",
            "duration": "90 min",
            "objectives": [
                "Apply formal experimental design to malware research.",
                "Use statistical analysis to validate research findings.",
                "Design and conduct a longitudinal study of malware evolution.",
                "Understand the requirements and process for IRB (Institutional Review Board) approval.",
                "Master the process of academic peer review and publication.",
                "Develop effective grant writing and conference presentation skills."
            ],
            "content": {
                "overview": "Advanced research requires more than just technical skill; it requires a mastery of the formal scientific process. This lesson covers the methodologies that are the foundation of credible academic and commercial research, from designing a controlled experiment and analyzing data statistically to publishing the results in a peer-reviewed journal.",
                "sections": [
                    {
                        "title": "Experimental Design for Malware Research",
                        "content": "<p>A good research project is not a random walk; it is a carefully designed experiment to answer a specific question.</p><h3>Key Components of Experimental Design:</h3><ul><li><strong>Hypothesis:</strong> A clear, testable statement. (e.g., 'Malware that uses API hooking will have a higher sandbox evasion rate than malware that does not.')</li><li><strong>Control Group:</strong> A baseline group to compare against. (e.g., A set of benign files, or malware without the specific feature being tested).</li><li><strong>Independent Variable:</strong> The thing you are changing or testing (e.g., the presence of API hooking).</li><li><strong>Dependent Variable:</strong> The thing you are measuring (e.g., the sandbox detection rate).</li></ul><p>A well-designed experiment ensures that the results are statistically significant and not just due to random chance.</p>",
                        "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Statistical Analysis of Malware Data",
                        "content": "<p>Statistics are essential for interpreting the results of a large-scale experiment and proving that the findings are meaningful.</p><p><strong>Real-world Example: Designing a longitudinal malware evolution study.</strong> A researcher wants to study how the use of packers has changed over time. They obtain a dataset of 1 million malware samples per year for the last 10 years. For each sample, they determine if it is packed. They can then use statistical methods like time series analysis to show, for example, that 'the use of the UPX packer has decreased by 80% over the last decade, while the use of commercial packers like VMProtect has increased by 500%'. This provides a quantifiable, data-driven insight into the evolution of the threat landscape.</p>",
                        "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The Peer Review and Publication Process",
                        "content": "<p>The final step of any research project is to share the findings with the community. In academia and at top commercial labs, this is done through a formal peer review process.</p><h3>The Process:</h3><ol><li>The researcher writes a formal academic paper detailing their methodology, data, results, and conclusions.</li><li>They submit the paper to a reputable conference (e.g., USENIX Security, IEEE S&P) or journal.</li><li>The paper is sent to a panel of other anonymous experts ('peers') in the field.</li><li>The peers rigorously review the paper for technical accuracy, scientific rigor, and novelty.</li><li>Based on the reviews, the paper is either accepted, rejected, or sent back for revisions.</li></ol><p>This process is the gold standard for ensuring the quality and credibility of scientific research.</p>",
                        "image": "https://images.unsplash.com/photo-1454165804606-c3d57bc86b40?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Research Data Analysis Framework (Python with SciPy)",
                        "language": "python",
                        "code": "from scipy.stats import ttest_ind\n\n# This conceptual script uses a statistical test (independent t-test)\n# to determine if the difference between two groups is significant.\n\n# --- Hypothesis ---\n# Our new detection method ('Method A') is better than the old one ('Method B').\n\n# --- Experiment Data ---\n# The detection scores for 10 malware samples using Method A\nmethod_a_scores = [95, 98, 89, 92, 99, 96, 97, 91, 94, 93]\n# The detection scores for the same 10 samples using Method B\nmethod_b_scores = [85, 88, 81, 84, 90, 86, 89, 82, 83, 87]\n\n# --- Statistical Analysis ---\n# Perform an independent t-test\n# The null hypothesis is that the two methods have identical average scores.\nt_statistic, p_value = ttest_ind(method_a_scores, method_b_scores)\n\nprint(f\"T-statistic: {t_statistic:.4f}\")\nprint(f\"P-value: {p_value:.4f}\")\n\n# The p-value is the probability that the observed difference is due to random chance.\n# A small p-value (typically < 0.05) allows us to reject the null hypothesis.\nif p_value < 0.05:\n    print(\"\\n[Conclusion] The difference is statistically significant. Method A is demonstrably better.\")\nelse:\n    print(\"\\n[Conclusion] The difference is not statistically significant.\")"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "A clear, testable statement that a research experiment is designed to prove or disprove is known as a:",
                        "options": [
                            "Conclusion",
                            "Hypothesis",
                            "Variable",
                            "Data Point"
                        ],
                        "correct": 1,
                        "explanation": "The hypothesis is the starting point of the scientific method. It's the specific question or claim that the entire research project is structured to investigate."
                    },
                    {
                        "id": 2,
                        "question": "A type of study that analyzes data over a long period of time to observe how trends evolve is known as a:",
                        "options": [
                            "Controlled experiment",
                            "Longitudinal study",
                            "Peer review",
                            "Case study"
                        ],
                        "correct": 1,
                        "explanation": "A longitudinal study is crucial for understanding evolution and trends, such as how ransomware tactics have changed over the last decade. It involves analyzing data from multiple points in time."
                    },
                    {
                        "id": 3,
                        "question": "What is the primary purpose of the academic peer review process?",
                        "options": [
                            "To check for spelling mistakes.",
                            "To ensure that research is novel, technically accurate, and methodologically sound before it is published.",
                            "To give researchers feedback on their presentation skills.",
                            "To help researchers get funding."
                        ],
                        "correct": 1,
                        "explanation": "Peer review is the quality control system of science. It enlists other experts in the field to rigorously vet a piece of research to ensure it meets high standards of quality and credibility before it is accepted as part of the scientific literature."
                    }
                ]
            }
        },
        {
            "id": "lesson-22",
            "title": "Defensive Technology Research",
            "duration": "100 min",
            "objectives": [
                "Research and design next-generation antivirus and EDR technologies.",
                "Develop novel algorithms for behavioral analysis and anomaly detection.",
                "Apply machine learning to create more effective defensive models.",
                "Research and develop deception technologies like honeypots and honeytokens.",
                "Design and build frameworks for automated threat hunting and incident response.",
                "Explore the concept of autonomous defense systems."
            ],
            "content": {
                "overview": "The most impactful research not only analyzes the threats of today but builds the defenses of tomorrow. This lesson focuses on defensive research and development, exploring how to design and build the next generation of security technologies, from AI-powered EDR to fully autonomous response systems.",
                "sections": [
                    {
                        "title": "Next-Generation Detection Research",
                        "content": "<p>Research in detection focuses on moving beyond simple signatures to more robust and intelligent methods.</p><h3>Areas of Research:</h3><ul><li><strong>Behavioral Analysis:</strong> Instead of looking for a specific file hash, a behavioral system looks for a suspicious *sequence of actions* (e.g., a Word document spawning PowerShell which then makes a network connection). Research focuses on finding new, high-confidence behavioral patterns.</li><li><strong>Machine Learning Defense:</strong> Training ML models to distinguish between benign and malicious behavior. A key area of research is making these models resilient to the adversarial attacks discussed in Lesson 12.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Deception Technology Development",
                        "content": "<p>Deception technology turns the tables on an attacker by creating an environment of attractive, fake assets that are heavily monitored.</p><h3>Research Areas:</h3><ul><li><strong>Honeypots:</strong> Decoy systems (e.g., a fake web server) that are designed to be attacked. Any interaction with a honeypot is by definition malicious.</li><li><strong>Honeytokens:</strong> Fake data designed to be stolen. <strong>Real-world Example:</strong> A researcher creates a fake AWS access key (a 'honeytoken') and places it in a public GitHub repository. They set up an alert that will fire the instant that key is used. This provides a high-fidelity, real-time alert that the token has been found and is being used by an attacker, providing valuable intelligence on their TTPs.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1548092372-2d987bde898b?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Autonomous Defense Systems",
                        "content": "<p>This is the future of incident response. An autonomous defense system would use AI to not only detect a threat, but to automatically select and execute a response playbook without any human intervention.</p><p><strong>Real-time Problem: Developing an AI-powered defense against AI malware.</strong> The attacks of the future will be AI-driven and will operate at machine speed, too fast for a human to respond. The defense must also be AI-driven. Research in this area, sponsored by organizations like DARPA, focuses on building systems that can perform a full 'observe, orient, decide, act' (OODA) loop in milliseconds. The AI would detect a novel threat, analyze its behavior, correlate it with other events, decide on the optimal containment strategy (e.g., 'isolate this host' vs. 'deceive this attacker with a honeypot'), and execute that strategy, all before a human analyst has even seen the first alert.</p>",
                        "image": "https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Autonomous Malware Defense System (Conceptual)",
                        "language": "python",
                        "code": "# This conceptual script outlines the decision-making logic of an autonomous defense AI.\n\ndef autonomous_defense_agent(threat_object):\n    \"\"\"Analyzes a threat and automatically chooses a response strategy.\"\"\"\n    \n    # 1. Analyze the threat's characteristics using multiple AI models.\n    threat_class = classify_threat(threat_object) # e.g., 'Ransomware', 'APT_Espionage'\n    confidence_score = get_confidence(threat_object)\n    asset_critically = get_asset_value(threat_object.target_host)\n\n    # 2. Use a decision-making model (e.g., a policy network from reinforcement learning)\n    # to select the optimal response.\n    if threat_class == 'Ransomware' and confidence_score > 0.99:\n        # For high-confidence, fast-moving threats, take immediate, aggressive action.\n        response_playbook = 'Isolate_And_Reimage'\n    elif threat_class == 'APT_Espionage' and asset_critically < 5:\n        # For stealthy threats on low-value assets, the goal is intelligence gathering.\n        response_playbook = 'Deceive_And_Monitor'\n    else:\n        # If confidence is low, escalate to a human analyst.\n        response_playbook = 'Escalate_To_Human'\n\n    print(f\"[*] Autonomous decision: Threat class '{threat_class}', selected playbook '{response_playbook}'.\")\n    # 3. Execute the chosen playbook via the SOAR platform.\n    # execute_soar_playbook(response_playbook, threat_object)"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "A defensive technology that focuses on detecting a threat by looking for a suspicious *sequence of actions* rather than a file signature is known as:",
                        "options": [
                            "Signature-based detection",
                            "Behavioral analysis",
                            "Static analysis",
                            "A honeypot"
                        ],
                        "correct": 1,
                        "explanation": "Behavioral analysis is the core of modern EDR and next-generation antivirus. It moves beyond what a file *is* to what a file *does*, making it much more effective against novel and polymorphic threats."
                    },
                    {
                        "id": 2,
                        "question": "A fake, high-value asset, such as a decoy database server or a fake AWS access key, that is placed in a network to be found by an attacker is known as what?",
                        "options": [
                            "A production server",
                            "A firewall",
                            "A honeypot or a honeytoken",
                            "A vulnerability"
                        ],
                        "correct": 2,
                        "explanation": "Honeypots and honeytokens are core components of deception technology. They are traps for attackers. Any interaction with them is, by definition, malicious and provides a very high-fidelity alert."
                    },
                    {
                        "id": 3,
                        "question": "What is the ultimate goal of research into autonomous defense systems?",
                        "options": [
                            "To create a system that can detect and respond to threats at machine speed, faster than a human operator could.",
                            "To replace the need for firewalls.",
                            "To make security alerts easier to read.",
                            "To help researchers get more funding."
                        ],
                        "correct": 0,
                        "explanation": "As attacks become faster and more automated, defenses must as well. The goal of autonomous defense is to create a system that can complete the entire incident response lifecycle in seconds or milliseconds to counter AI-driven threats."
                    }
                ]
            }
        },
        {
            "id": "lesson-23",
            "title": "Malware Research Ethics and Legal Framework",
            "duration": "90 min",
            "objectives": [
                "Establish a formal ethical framework for malware research.",
                "Understand the role and process of an Institutional Review Board (IRB).",
                "Navigate the legal frameworks governing malware research (e.g., CFAA, DMCA).",
                "Implement and follow strict responsible disclosure protocols.",
                "Assess the public safety and dual-use implications of research.",
                "Uphold the professional integrity standards of the research community."
            ],
            "content": {
                "overview": "With great power comes great responsibility. Malware research involves handling dangerous code and discovering powerful vulnerabilities. This lesson covers the critical ethical and legal frameworks that govern responsible research, ensuring that the work protects the public, respects the law, and upholds the highest standards of professional integrity.",
                "sections": [
                    {
                        "title": "Research Ethics and the IRB",
                        "content": "<p>The primary ethical principle of malware research is to 'do no harm'.</p><h3>Institutional Review Board (IRB):</h3><p>In academia, any research that involves human subjects must be approved by an IRB. In malware research, this can apply to studies that involve analyzing user data found in malware, or research into online communities. The IRB's job is to ensure the research is ethical and that the privacy and safety of any individuals involved are protected.</p>",
                        "image": "https://images.unsplash.com/photo-1505664194779-8beace7a2044?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Legal Frameworks (CFAA, DMCA)",
                        "content": "<p>Researchers must operate within the law. In the United States, two key laws are:</p><ul><li><strong>Computer Fraud and Abuse Act (CFAA):</strong> The primary anti-hacking law. It makes it illegal to access a computer without authorization. This is why a researcher must *never* perform analysis on systems they do not own or have explicit permission to test.</li><li><strong>Digital Millennium Copyright Act (DMCA):</strong> Contains provisions that can make it illegal to circumvent copy protection or other technical protection measures, which can sometimes complicate the reverse engineering of certain software.</li></ul><p>A researcher must have a basic understanding of these laws and work closely with legal counsel to ensure their work is compliant.</p>",
                        "image": "https.unsplash.com/photo-1589994235863-118b6256f693?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Responsible Disclosure and Dual-Use Research",
                        "content": "<p><strong>Responsible Disclosure:</strong> As covered previously, this is the ethical process for reporting vulnerabilities to vendors. It is the community standard.</p><p><strong>Dual-Use Research:</strong> This is research that could be used for both good and bad purposes. <strong>Real-time Problem: Navigating an ethical dilemma in sensitive research.</strong> A researcher develops a powerful new technique for bypassing a common type of EDR. This research has a dual use. It can be used by defenders to build better EDRs, but if released irresponsibly, it could be immediately weaponized by attackers. The ethical path is to first share the findings privately with the affected EDR vendors so they can develop mitigations. Only after the vendors have had a chance to deploy fixes should the researcher consider a public release, often with some details redacted to make it harder for attackers to copy.</p>",
                        "image": "https://images.unsplash.com/photo-1552664730-d307ca884978?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Ethical Framework for Research Lab (Policy)",
                        "language": "markdown",
                        "code": "# Malware Research Lab - Code of Conduct\n\n1.  **Principle of No Harm:** All research must be conducted in a way that avoids harm to any individual, organization, or the internet at large. All analysis will be performed in a fully isolated environment.\n\n2.  **Principle of Legality:** All activities will be conducted in strict compliance with all applicable local and international laws.\n\n3.  **Principle of Responsible Disclosure:** Any newly discovered vulnerabilities in third-party software will be reported privately to the affected vendor before any public disclosure.\n\n4.  **Principle of Data Minimization:** Only the minimum amount of data necessary will be collected to answer the research question. Any Personal Identifiable Information (PII) found in malware samples will be anonymized or deleted from research data whenever possible.\n\n5.  **Principle of Objectivity:** All research findings will be reported objectively and without bias. All methodologies and data will be preserved to ensure reproducibility.\n\n6.  **Principle of Community:** We will share our research findings to help the defensive community, contributing to the collective security of the ecosystem."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary ethical principle of malware research?",
                        "options": [
                            "To publish findings as quickly as possible.",
                            "To 'do no harm'.",
                            "To find as many zero-days as possible.",
                            "To get a job at a major tech company."
                        ],
                        "correct": 1,
                        "explanation": "This is the guiding ethical principle. The researcher has a duty to ensure that their work, which involves dangerous materials and powerful knowledge, does not cause unintentional harm to others."
                    },
                    {
                        "id": 2,
                        "question": "The US law that makes it illegal to access a computer without authorization is known as the:",
                        "options": [
                            "DMCA",
                            "HIPAA",
                            "CFAA",
                            "SOX"
                        ],
                        "correct": 2,
                        "explanation": "The Computer Fraud and Abuse Act (CFAA) is the primary anti-hacking statute in the United States. It is the reason why all legitimate research and testing must be done on systems you own or have explicit, written permission to test."
                    },
                    {
                        "id": 3,
                        "question": "Research that could be used for both defensive and offensive purposes is known as what?",
                        "options": [
                            "Classified research",
                            "Dual-use research",
                            "Unethical research",
                            "Pointless research"
                        ],
                        "correct": 1,
                        "explanation": "Dual-use research presents a significant ethical dilemma. The researcher must carefully consider the potential for their work to be weaponized by adversaries and follow strict responsible disclosure protocols to mitigate this risk."
                    }
                ]
            }
        },
        {
            "id": "lesson-24",
            "title": "Future Directions and Emerging Research Areas",
            "duration": "90 min",
            "objectives": [
                "Discuss the long-term research implications of quantum computing and AGI.",
                "Explore the future of biotechnology and genetic malware research.",
                "Consider the security and forensic challenges of space-based assets and neural interfaces.",
                "Understand the importance of interdisciplinary collaboration for future research.",
                "Develop a long-term research roadmap.",
                "Reflect on the evolution of malware and the enduring principles of research."
            ],
            "content": {
                "overview": "This final lesson looks to the distant horizon, exploring the truly next-generation technologies that will shape the future of malware research. From the impact of Artificial General Intelligence to the security of our biological data, we will discuss the emerging research areas that will define the field for decades to come and the importance of a forward-looking, adaptable research mindset.",
                "sections": [
                    {
                        "title": "Quantum Computing and AI Implications",
                        "content": "<ul><li><strong>Quantum Malware:</strong> The long-term threat of quantum computing is its ability to break current cryptography. The corresponding research will be in developing and testing quantum-resistant cryptographic algorithms.</li><li><strong>Artificial General Intelligence (AGI):</strong> While current AI is narrow, a future AGI could create novel, highly complex malware and evasion techniques that are beyond human comprehension. The research challenge will be to create equally powerful AGI-based defensive systems to counter this.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1635070049035-5a79a8385075?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "New Frontiers: Space, Biology, and Neural Interfaces",
                        "content": "<p>As technology integrates into new domains, the attack surface expands with it.</p><h3>Future Research Areas:</h3><ul><li><strong>Space-Based Malware:</strong> As we become more reliant on satellites for communication and GPS, research into securing these space-based assets from malware and cyberattack will become a critical area of national security.</li><li><strong>Biotechnology and Genetic Malware:</strong> As DNA sequencing and synthesis become commonplace, the concept of a 'virus' becomes both digital and biological. Research will be needed to secure the digital systems that manage genetic data and to defend against the possibility of malware designed to manipulate biological processes.</li><li><strong>Brain-Computer Interfaces (BCIs):</strong> The ultimate frontier. As neural interfaces become more common, research into securing these devices from malware that could potentially read thoughts or manipulate neural signals will be one of the most profound and ethically complex challenges imaginable.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1522071820081-009f0129c71c?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The Constant: The Research Mindset",
                        "content": "<p>While the technologies will change in ways we can't even predict, the principles of good research will remain the same. The future of malware research will always belong to those who are curious, rigorous, ethical, and relentlessly driven to understand how things work so they can figure out how they can be broken—and how they can be defended.</p>",
                        "image": "https://images.unsplash.com/photo-1454165804606-c3d57bc86b40?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Future Technology Research Framework (Conceptual)",
                        "language": "python",
                        "code": "class ResearchRoadmap:\n    def __init__(self, lab_name):\n        self.lab_name = lab_name\n        self.timeline = {\n            '1-3 Years (Current)': ['AI Model Poisoning Defense', 'WASM Malware Analysis'],\n            '3-5 Years (Near-Term)': ['Post-Quantum Crypto Implementation', 'Autonomous Defense Agents'],\n            '5-10 Years (Mid-Term)': ['Satellite Network Security', 'Securing Genetic Databases'],\n            '10+ Years (Long-Term)': ['Brain-Computer Interface Security', 'AGI Threat Modeling']\n        }\n\n    def display_roadmap(self):\n        \"\"\"Prints the lab's strategic research plan.\"\"\"\n        print(f\"--- Research Roadmap for {self.lab_name} ---\")\n        for timeframe, projects in self.timeline.items():\n            print(f\"\\n{timeframe}:\")\n            for project in projects:\n                print(f\"  - {project}\")\n\n# This represents the strategic planning process required for a long-term research program.\n# lab_roadmap = ResearchRoadmap(\"Future Threats Research Lab\")\n# lab_roadmap.display_roadmap()"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary long-term security threat posed by quantum computing?",
                        "options": [
                            "It will make malware run faster.",
                            "Its ability to break current public-key cryptographic algorithms.",
                            "It will use too much electricity.",
                            "It will make computers sentient."
                        ],
                        "correct": 1,
                        "explanation": "The most significant and well-understood threat from quantum computing is its ability to break the encryption that underpins almost all modern secure communication and data protection."
                    },
                    {
                        "id": 2,
                        "question": "The study of malware that could potentially target DNA sequencing equipment or manipulate genetic data falls under what emerging research area?",
                        "options": [
                            "Space-based malware",
                            "Serverless malware",
                            "Biotechnology and genetic malware",
                            "Container malware"
                        ],
                        "correct": 2,
                        "explanation": "As biology becomes increasingly digitized, the security of the systems that manage this data becomes a critical new frontier for malware research, with profound safety and ethical implications."
                    },
                    {
                        "id": 3,
                        "question": "What is the most enduring and important attribute for a successful career in advanced malware research?",
                        "options": [
                            "Mastery of a single programming language.",
                            "A commitment to being a lifelong learner and adapting to new technologies.",
                            "The ability to work alone.",
                            "Having a favorite antivirus product."
                        ],
                        "correct": 1,
                        "explanation": "The technology and the threats are in a constant state of rapid evolution. The only way to succeed in the long term is to have a mindset of continuous learning, curiosity, and adaptation."
                    }
                ]
            }
        }
    ]
}

      // =====================================================
      // GLOBAL VARIABLES
      // =====================================================
      let currentUser = null;
      let currentLessonIndex = 0;
      let courseProgress = {};
      let userStats = {};
      let quizState = {
        currentQuestion: 0,
        answers: [],
        score: 0,
        isComplete: false,
        timeStarted: null,
        timeCompleted: null,
        currentQuestionIndex: 0,
      };

      // Enhanced session tracking
      let courseSession = {
        startTime: null,
        totalStudyTime: 0,
        lessonsStarted: 0,
        lessonsCompleted: 0,
        pageLoadTime: new Date(),
        lastActive: new Date(),
        interactions: 0,
        completedSections: [],
        totalTime: 0,
        interactionCount: 0,
        lastActivityTime: new Date(),
      };

      // Music Player Variables
      let audioPlayer = new Audio();

      // Achievement notification system
      let notificationQueue = [];
      let isShowingNotification = false;

      // =====================================================
      // INITIALIZATION
      // =====================================================
      document.addEventListener("DOMContentLoaded", async () => {
        try {
          showLoadingScreen();
          await checkAuth();

          if (currentUser) {
            // Initialize session tracking
            startCourseSession();

            // Load course data and progress
            await loadCourseData();
            await loadUserProfile();
            await loadProgress();

            // Initialize UI
            initializeEventListeners();
            renderSidebar();
            loadLesson(currentLessonIndex);

            // Initialize additional features
            initMusicPlayer();
            addMusicIndicator();
            initializeActivityTracking();

            hideLoadingScreen();
          } else {
            openAuthModal();
          }
        } catch (error) {
          console.error("Error initializing course:", error);
          hideLoadingScreen();
          showToast("Failed to initialize course system", "error");
        }
      });

      // =====================================================
      // AUTHENTICATION SYSTEM
      // =====================================================
      async function checkAuth() {
        try {
          const {
            data: { session },
            error,
          } = await supabase.auth.getSession();

          if (error) {
            console.error("Auth error:", error);
            currentUser = null;
            openAuthModal();
            return;
          }

          if (!session) {
            currentUser = null;
            openAuthModal();
            return;
          }

          currentUser = session.user;
          updateUIWithUser();
        } catch (error) {
          console.error("Error checking auth:", error);
          currentUser = null;
          openAuthModal();
        }
      }

      function updateUIWithUser() {
        if (!currentUser) return;

        const name =
          currentUser.user_metadata?.full_name ||
          currentUser.email.split("@")[0];
        const userElements = document.querySelectorAll("[data-user-name]");
        userElements.forEach((el) => (el.textContent = name));
      }

      // =====================================================
      // USER PROFILE & STATS MANAGEMENT
      // =====================================================
      async function loadUserProfile() {
        try {
          // 🔍 Step 1: Try to fetch existing profile
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("*")
            .eq("id", currentUser.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (!profile) {
            // 🆕 Step 2: Create new profile if missing
            await createUserProfile();
          } else {
            // ✅ Step 3: Use existing profile
            userStats = profile;
            await updateLastActivity();
          }
        } catch (error) {
          console.error("❌ Error loading user profile:", error);
          showToast("Failed to load user profile", "error");
        }
      }
      async function createUserProfile() {
        try {
          const newProfile = {
            id: currentUser.id,
            full_name: currentUser.user_metadata?.full_name || "",
            email: currentUser.email,
            level: "Script Kiddie",
            total_points: 0,
            completed_courses: 0,
            current_streak: 0,
            total_certificates: 0,
            total_achievements: 0,
            sections_visited: 0,
            bonus_points: 0,
            in_progress_courses: 0,
            settings_changed: 0,
            midnight_sessions: 0,
            early_sessions: 0,
            weekend_sessions: 0,
            last_activity: new Date().toISOString(),
            created_at: new Date().toISOString(),
          };

          const { error } = await supabase
            .from("profiles")
            .insert([newProfile]);

          if (!error) {
            userStats = newProfile;
            // Award first login achievement
            setTimeout(() => checkAndUnlockAchievement("first_login"), 1000);
          }
        } catch (error) {
          console.error("Error creating user profile:", error);
        }
      }

      async function updateLastActivity() {
        try {
          const now = new Date();

          // Update activity tracking
          courseSession.lastActivityTime = now;

          // Update database
          await supabase
            .from("profiles")
            .update({
              last_activity: now.toISOString(),
            })
            .eq("id", currentUser.id);

          // Check time-based achievements
          await checkTimeBasedAchievements(now);
        } catch (error) {
          console.error("Error updating last activity:", error);
        }
      }

      // =====================================================
      // COURSE SESSION MANAGEMENT
      // =====================================================
      function startCourseSession() {
        courseSession.startTime = new Date();
        courseSession.pageLoadTime = new Date();

        logUserActivity("course_session_start", {
          course_id: COURSE_DATA.id,
          course_title: COURSE_DATA.title,
          user_agent: navigator.userAgent,
          screen_resolution: `${screen.width}x${screen.height}`,
        });

        // Check daily streak
        checkDailyStreak();
      }

      function initializeActivityTracking() {
        // Track page focus/blur for accurate study time
        document.addEventListener("visibilitychange", handleVisibilityChange);

        // Track user interactions
        ["click", "keydown", "scroll", "mousemove"].forEach((event) => {
          document.addEventListener(event, trackUserInteraction, {
            passive: true,
          });
        });

        // Periodic activity updates
        setInterval(updateStudyTime, 60000); // Every minute

        // Save session data before page unload
        window.addEventListener("beforeunload", saveSessionData);
      }

      function handleVisibilityChange() {
        if (document.hidden) {
          courseSession.lastActivityTime = new Date();
        } else {
          // Page became visible again - update activity
          updateLastActivity();
        }
      }

      function trackUserInteraction() {
        courseSession.interactionCount++;
        courseSession.lastActivityTime = new Date();

        // Throttle activity updates
        if (courseSession.interactionCount % 50 === 0) {
          updateLastActivity();
        }
      }

      function updateStudyTime() {
        if (!courseSession.startTime || document.hidden) return;

        const now = new Date();
        const sessionDuration = now - courseSession.startTime;
        courseSession.totalStudyTime = Math.floor(sessionDuration / 1000 / 60); // in minutes

        // Update progress with study time
        saveProgress();
      }

      function saveSessionData() {
        if (!currentUser || !courseSession.startTime) return;

        const sessionData = {
          user_id: currentUser.id,
          course_id: COURSE_DATA.id,
          session_duration: courseSession.totalStudyTime,
          lessons_viewed: courseSession.lessonsStarted,
          lessons_completed: courseSession.lessonsCompleted,
          interactions: courseSession.interactionCount,
          session_date: courseSession.startTime.toISOString().split("T")[0],
        };

        // Store in localStorage as backup
        localStorage.setItem(
          "course_session_backup",
          JSON.stringify(sessionData)
        );

        // Try to save to database
        logUserActivity("course_session_end", sessionData);
      }

      // =====================================================
      // COURSE DATA & PROGRESS MANAGEMENT
      // =====================================================
      async function loadCourseData() {
        try {
          // Update course info in UI
          document.getElementById("courseTitle").textContent =
            COURSE_DATA.title;
          document.getElementById("totalLessons").textContent =
            COURSE_DATA.lessons.length;

          // Log course access
          logUserActivity("course_access", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
          });
        } catch (error) {
          console.error("Error loading course data:", error);
        }
      }

      async function loadProgress() {
        try {
          // Get existing progress from database
          const { data, error } = await supabase
            .from("course_progress")
            .select("*")
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (data) {
            courseProgress = JSON.parse(data.lesson_progress || "{}");
            currentLessonIndex = data.current_lesson || 0;

            // Update session tracking
            courseSession.lessonsStarted = Object.keys(courseProgress).length;
            courseSession.lessonsCompleted = Object.values(
              courseProgress
            ).filter((p) => p.completed).length;
          } else {
            // Initialize new progress
            courseProgress = {};
            currentLessonIndex = 0;
            await saveProgress();

            // Award first course start achievement
            await checkAndUnlockAchievement("first_course_start");
          }

          updateProgressDisplay();
        } catch (error) {
          console.error("Error loading progress:", error);
          showToast("Failed to load progress", "error");
        }
      }

      async function saveProgress() {
        try {
          if (!currentUser) return;

          const now = new Date();
          const progressData = {
            user_id: currentUser.id,
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            current_lesson: currentLessonIndex,
            lesson_progress: JSON.stringify(courseProgress),
            progress: calculateOverallProgress(),
            lessons_completed: getCompletedLessonsCount(),
            lessons_started: Object.keys(courseProgress).length,
            study_time_minutes: courseSession.totalStudyTime,
            last_accessed: now.toISOString(),
            updated_at: now.toISOString(),
          };

          // Upsert progress
          const { error } = await supabase
            .from("course_progress")
            .upsert([progressData]);

          if (error) throw error;

          // Update user stats
          await updateUserStats();

          updateProgressDisplay();
        } catch (error) {
          console.error("Error saving progress:", error);
          showToast("Failed to save progress", "error");
        }
      }

      async function updateUserStats() {
        try {
          // Get all course progress for this user
          const { data: allProgress, error } = await supabase
            .from("course_progress")
            .select("progress, course_id, study_time_minutes")
            .eq("user_id", currentUser.id);

          if (error) throw error;

          // Calculate stats
          const completedCourses =
            allProgress?.filter((p) => p.progress >= 100).length || 0;
          const inProgressCourses =
            allProgress?.filter((p) => p.progress > 0 && p.progress < 100)
              .length || 0;
          const totalStudyTime =
            allProgress?.reduce(
              (sum, p) => sum + (p.study_time_minutes || 0),
              0
            ) || 0;

          // Calculate points (500 per completed course + achievement points)
          const coursePoints = completedCourses * 500;
          const bonusPoints = userStats.bonus_points || 0;
          const totalPoints = coursePoints + bonusPoints;

          // Update profile
          const updateData = {
            completed_courses: completedCourses,
            in_progress_courses: inProgressCourses,
            total_points: totalPoints,
            total_study_time: totalStudyTime,
            last_activity: new Date().toISOString(),
          };

          const { error: updateError } = await supabase
            .from("profiles")
            .update(updateData)
            .eq("id", currentUser.id);

          if (updateError) throw updateError;

          // Update local stats
          Object.assign(userStats, updateData);
        } catch (error) {
          console.error("Error updating user stats:", error);
        }
      }

      function calculateOverallProgress() {
        const completedLessons = getCompletedLessonsCount();
        return Math.round(
          (completedLessons / COURSE_DATA.lessons.length) * 100
        );
      }

      function getCompletedLessonsCount() {
        return Object.values(courseProgress).filter(
          (lesson) => lesson.completed
        ).length;
      }

      function updateProgressDisplay() {
        const completedCount = getCompletedLessonsCount();
        const progressPercent = calculateOverallProgress();

        // Update UI elements
        const elements = {
          completedLessons: completedCount,
          courseProgressPercent: `${progressPercent}%`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });

        // Update progress bar
        const progressBar = document.getElementById("courseProgressFill");
        if (progressBar) progressBar.style.width = `${progressPercent}%`;
      }

      // =====================================================
      // LESSON MANAGEMENT
      // =====================================================
      function loadLesson(index) {
        if (index < 0 || index >= COURSE_DATA.lessons.length) return;

        const lesson = COURSE_DATA.lessons[index];
        currentLessonIndex = index;

        // Mark lesson as started and track activity
        if (!courseProgress[lesson.id]) {
          courseProgress[lesson.id] = {
            started: true,
            completed: false,
            startedAt: new Date().toISOString(),
            timeSpent: 0,
          };

          courseSession.lessonsStarted++;
          saveProgress();

          // Log lesson start
          logUserActivity("lesson_start", {
            lesson_id: lesson.id,
            lesson_title: lesson.title,
            lesson_index: index,
          });
        }

        // Update lesson start time for time tracking
        courseProgress[lesson.id].currentSessionStart = new Date();

        // Update sidebar and navigation
        renderSidebar();
        updateNavigationButtons();

        // Update header info
        updateLessonHeader(lesson, index);

        // Render lesson content
        renderLessonContent(lesson);

        // Smooth scroll and animations
        window.scrollTo({ top: 0, behavior: "smooth" });
        document.getElementById("contentBody").scrollTop = 0;

        const contentBody = document.getElementById("contentBody");
        contentBody.classList.add("fade-in");
        setTimeout(() => contentBody.classList.remove("fade-in"), 500);

        // Check lesson-based achievements
        checkLessonAchievements(index + 1);
      }

      function updateLessonHeader(lesson, index) {
        const elements = {
          currentLessonNumber: index + 1,
          currentLessonTitle: lesson.title,
          navInfo: `Lesson ${index + 1} of ${COURSE_DATA.lessons.length}`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });
      }

      function renderSidebar() {
        const lessonNav = document.getElementById("lessonNav");
        if (!lessonNav) return;

        lessonNav.innerHTML = "";

        COURSE_DATA.lessons.forEach((lesson, index) => {
          const lessonItem = document.createElement("div");
          lessonItem.className = "lesson-item";

          // Determine lesson status
          const lessonProgress = courseProgress[lesson.id];
          const isCompleted = lessonProgress?.completed || false;
          const isInProgress = lessonProgress?.started || false;
          const isLocked = !isCompleted && !canAccessLesson(index);
          const isActive = index === currentLessonIndex;

          // Apply status classes
          if (isCompleted) lessonItem.classList.add("completed");
          if (isLocked) lessonItem.classList.add("locked");
          if (isActive) lessonItem.classList.add("active");

          // Determine status display
          let statusClass = "not-started";
          let statusIcon = index + 1;

          if (isCompleted) {
            statusClass = "completed";
            statusIcon = "✓";
          } else if (isInProgress) {
            statusClass = "in-progress";
            statusIcon = "◐";
          }

          // Create lesson item HTML
          lessonItem.innerHTML = `
            <div class="lesson-status ${statusClass}">${statusIcon}</div>
            <div class="lesson-info">
                <div class="lesson-title">${lesson.title}</div>
                <div class="lesson-meta">
                    ${
                      isCompleted
                        ? "Completed"
                        : isInProgress
                        ? "In Progress"
                        : isLocked
                        ? "Locked"
                        : "Not Started"
                    }
                </div>
            </div>
            <div class="lesson-duration">${lesson.duration}</div>
        `;

          // Add click handler if not locked
          if (!isLocked) {
            lessonItem.addEventListener("click", () => {
              if (index !== currentLessonIndex) {
                // Track lesson time before switching
                trackLessonTime();

                currentLessonIndex = index;
                loadLesson(index);
                closeSidebar();
              }
            });
          }

          lessonNav.appendChild(lessonItem);
        });
      }

      function canAccessLesson(index) {
        if (index === 0) return true; // First lesson always accessible

        // Can access if previous lesson is completed
        const previousLessonId = COURSE_DATA.lessons[index - 1].id;
        return courseProgress[previousLessonId]?.completed || false;
      }

      function trackLessonTime() {
        const currentLesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonProgress = courseProgress[currentLesson.id];

        if (lessonProgress?.currentSessionStart) {
          const sessionTime = Math.floor(
            (new Date() - new Date(lessonProgress.currentSessionStart)) /
              1000 /
              60
          );
          lessonProgress.timeSpent =
            (lessonProgress.timeSpent || 0) + sessionTime;
          delete lessonProgress.currentSessionStart;
        }
      }

      // =====================================================
      // LESSON CONTENT RENDERING
      // =====================================================
      function renderLessonContent(lesson) {
        const contentContainer = document.getElementById("lessonContent");
        if (!contentContainer) return;

        let contentHTML = `
        <div class="content-section">
            <h2>Learning Objectives</h2>
            <ul>
                ${lesson.objectives.map((obj) => `<li>${obj}</li>`).join("")}
            </ul>
        </div>
        
        <div class="content-section">
            <h2>Overview</h2>
            <p>${lesson.content.overview}</p>
        </div>
    `;

        // Render content sections
        lesson.content.sections.forEach((section) => {
          contentHTML += `
            <div class="content-section">
                <h2>${section.title}</h2>
                ${section.content}
                ${
                  section.image
                    ? `<img src="${section.image}" alt="${section.title}" class="content-image" loading="lazy">`
                    : ""
                }
            </div>
        `;
        });

        // Render code examples
        if (
          lesson.content.codeExamples &&
          lesson.content.codeExamples.length > 0
        ) {
          contentHTML += `<div class="content-section"><h2>Code Examples</h2></div>`;

          lesson.content.codeExamples.forEach((example, index) => {
            const codeId = `code-${lesson.id}-${index}`;
            contentHTML += `
                <div class="code-section">
                    <div class="code-header">
                        <span class="code-title">${example.title}</span>
                        <button class="copy-btn" onclick="copyCode('${codeId}')">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <pre class="code-block"><code id="${codeId}" class="language-${
              example.language
            }">${escapeHtml(example.code)}</code></pre>
                </div>
            `;
          });
        }

        // Render quiz
        contentHTML += renderQuiz(lesson.quiz);

        contentContainer.innerHTML = contentHTML;

        // Highlight code syntax if Prism is available
        setTimeout(() => {
          if (window.Prism) {
            Prism.highlightAll();
          }
        }, 100);
      }

      // =====================================================
      // QUIZ SYSTEM
      // =====================================================
      function renderQuiz(quiz) {
        const currentLessonProgress =
          courseProgress[COURSE_DATA.lessons[currentLessonIndex].id];
        const isCompleted = currentLessonProgress?.completed || false;

        let quizHTML = `
        <div class="quiz-section" id="quizSection">
            <div class="quiz-header">
                <h2 class="quiz-title">
                    <i class="fas fa-clipboard-check"></i>
                    Knowledge Check
                </h2>
                <p class="quiz-info">
                    Complete this quiz with ${quiz.passingScore}% or higher to unlock the next lesson.
                </p>
            </div>
    `;

        if (isCompleted) {
          const savedScore = currentLessonProgress.quizScore || 0;
          quizHTML += `
            <div class="quiz-results show">
                <div class="quiz-score pass">${savedScore}%</div>
                <div class="quiz-message">
                    <strong>Lesson Completed!</strong><br>
                    You've successfully passed this lesson's quiz.
                </div>
            </div>
        `;
        } else {
          // Render quiz questions
          quiz.questions.forEach((question, qIndex) => {
            quizHTML += `
                <div class="quiz-question ${
                  qIndex === 0 ? "active" : ""
                }" data-question="${qIndex}">
                    <div class="question-header">
                        <span class="question-number">Question ${
                          qIndex + 1
                        }</span>
                        <span class="question-progress">${qIndex + 1}/${
              quiz.questions.length
            }</span>
                    </div>
                    <div class="question-text">${question.question}</div>
                    <div class="question-options">
                        ${question.options
                          .map(
                            (option, oIndex) => `
                            <div class="option" data-option="${oIndex}" onclick="selectOption(${qIndex}, ${oIndex})">
                                <span class="option-letter">${String.fromCharCode(
                                  65 + oIndex
                                )}</span>
                                <span class="option-text">${option}</span>
                            </div>
                        `
                          )
                          .join("")}
                    </div>
                </div>
            `;
          });

          quizHTML += `
            <div class="quiz-controls">
                <button class="btn btn-secondary" id="prevQuestionBtn" onclick="previousQuestion()" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <div>
                    <button class="btn btn-secondary" id="nextQuestionBtn" onclick="nextQuestion()" disabled>
                        Next
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <button class="btn btn-primary" id="submitQuizBtn" onclick="submitQuiz()" style="display: none;">
                        <i class="fas fa-check"></i>
                        Submit Quiz
                    </button>
                </div>
            </div>

            <div class="quiz-results" id="quizResults">
                <div class="quiz-score" id="quizScore">0%</div>
                <div class="quiz-message" id="quizMessage"></div>
                <div class="quiz-actions">
                    <button class="btn btn-primary" id="continueBtn" onclick="completeLesson()" style="display: none;">
                        <i class="fas fa-arrow-right"></i>
                        Continue to Next Lesson
                    </button>
                    <button class="btn btn-secondary" onclick="retakeQuiz()">
                        <i class="fas fa-redo"></i>
                        Retake Quiz
                    </button>
                </div>
            </div>
        `;
        }

        quizHTML += "</div>";
        return quizHTML;
      }

      // Quiz interaction functions
      function selectOption(questionIndex, optionIndex) {
        // Clear previous selections
        document
          .querySelectorAll(`[data-question="${questionIndex}"] .option`)
          .forEach((opt) => {
            opt.classList.remove("selected");
          });

        // Select current option
        const selectedOption = document.querySelector(
          `[data-question="${questionIndex}"] [data-option="${optionIndex}"]`
        );
        selectedOption.classList.add("selected");

        // Store answer
        quizState.answers[questionIndex] = optionIndex;

        // Update navigation
        const isLastQuestion =
          questionIndex ===
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length - 1;
        if (isLastQuestion) {
          document.getElementById("submitQuizBtn").style.display =
            "inline-flex";
          document.getElementById("nextQuestionBtn").style.display = "none";
        } else {
          document.getElementById("nextQuestionBtn").disabled = false;
        }
      }

      function nextQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const nextQuestionEl = currentQuestionEl.nextElementSibling;

        if (
          nextQuestionEl &&
          nextQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          nextQuestionEl.classList.add("active");
          quizState.currentQuestion++;
          updateQuizNavigation();
        }
      }

      function previousQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const prevQuestionEl = currentQuestionEl.previousElementSibling;

        if (
          prevQuestionEl &&
          prevQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          prevQuestionEl.classList.add("active");
          quizState.currentQuestion--;
          updateQuizNavigation();
        }
      }

      function updateQuizNavigation() {
        const totalQuestions =
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length;
        const prevBtn = document.getElementById("prevQuestionBtn");
        const nextBtn = document.getElementById("nextQuestionBtn");
        const submitBtn = document.getElementById("submitQuizBtn");

        prevBtn.disabled = quizState.currentQuestion === 0;

        const hasAnswer =
          quizState.answers[quizState.currentQuestion] !== undefined;
        const isLastQuestion = quizState.currentQuestion === totalQuestions - 1;

        if (isLastQuestion) {
          nextBtn.style.display = "none";
          submitBtn.style.display = hasAnswer ? "inline-flex" : "none";
        } else {
          nextBtn.style.display = "inline-flex";
          nextBtn.disabled = !hasAnswer;
          submitBtn.style.display = "none";
        }
      }

      async function submitQuiz() {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const quiz = lesson.quiz;
        let correctAnswers = 0;

        // Hide questions and controls
        document
          .querySelectorAll(".quiz-question")
          .forEach((q) => (q.style.display = "none"));
        document.querySelector(".quiz-controls").style.display = "none";

        // Calculate score and highlight answers
        quiz.questions.forEach((question, index) => {
          const userAnswer = quizState.answers[index];
          const correctAnswer = question.correct;
          const isCorrect = userAnswer === correctAnswer;

          if (isCorrect) correctAnswers++;

          // Highlight answers
          const questionEl = document.querySelector(
            `[data-question="${index}"]`
          );
          const options = questionEl.querySelectorAll(".option");

          options[correctAnswer].classList.add("correct");
          if (userAnswer !== correctAnswer && userAnswer !== undefined) {
            options[userAnswer].classList.add("incorrect");
          }
        });

        const score = Math.round(
          (correctAnswers / quiz.questions.length) * 100
        );
        const passed = score >= quiz.passingScore;

        // Update quiz results UI
        const quizScore = document.getElementById("quizScore");
        const quizMessage = document.getElementById("quizMessage");
        const quizActions = document.querySelector(".quiz-actions");

        quizScore.textContent = `${score}%`;
        quizScore.className = `quiz-score ${passed ? "pass" : "fail"}`;

        if (passed) {
          quizMessage.innerHTML = `
            <strong>Congratulations!</strong><br>
            You passed with ${score}%. You can now proceed to the next lesson.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-primary" onclick="completeLesson()">
                <i class="fas fa-arrow-right"></i>
                Continue to Next Lesson
            </button>
        `;

          // Mark lesson as completed
          await markLessonComplete(score);
        } else {
          quizMessage.innerHTML = `
            <strong>Not quite there yet.</strong><br>
            You scored ${score}%. You need ${quiz.passingScore}% to pass. Review the material and try again.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-secondary" onclick="retakeQuiz()">
                <i class="fas fa-redo"></i>
                Retake Quiz
            </button>
        `;
        }

        document.getElementById("quizResults").classList.add("show");

        // Log quiz completion
        logUserActivity("quiz_completed", {
          lesson_id: lesson.id,
          lesson_title: lesson.title,
          score: score,
          passed: passed,
          attempts: (courseProgress[lesson.id]?.quizAttempts || 0) + 1,
        });

        // Scroll to results
        document
          .getElementById("quizResults")
          .scrollIntoView({ behavior: "smooth" });
      }

      function retakeQuiz() {
        // Reset quiz state
        quizState = {
          currentQuestion: 0,
          answers: [],
          score: 0,
          isComplete: false,
        };

        // Track quiz retry
        const lessonId = COURSE_DATA.lessons[currentLessonIndex].id;
        if (!courseProgress[lessonId]) courseProgress[lessonId] = {};
        courseProgress[lessonId].quizAttempts =
          (courseProgress[lessonId].quizAttempts || 0) + 1;

        // Reload lesson content
        loadLesson(currentLessonIndex);

        // Scroll to quiz
        setTimeout(() => {
          document
            .getElementById("quizSection")
            .scrollIntoView({ behavior: "smooth" });
        }, 500);
      }

      async function markLessonComplete(score) {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonId = lesson.id;

        // Track lesson completion time
        trackLessonTime();

        // Update lesson progress
        courseProgress[lessonId] = {
          ...courseProgress[lessonId],
          completed: true,
          quizScore: score,
          completedAt: new Date().toISOString(),
          finalScore: score,
        };

        // Update session tracking
        courseSession.lessonsCompleted++;

        // Save progress to database
        await saveProgress();

        // Update UI
        renderSidebar();
        updateNavigationButtons();

        // Check various achievements
        await checkLessonCompletionAchievements();
        await checkPerfectScoreAchievements(score);
        await checkStudyTimeAchievements();

        // Log lesson completion
        logUserActivity("lesson_completed", {
          lesson_id: lessonId,
          lesson_title: lesson.title,
          final_score: score,
          time_spent: courseProgress[lessonId].timeSpent || 0,
          lesson_number: currentLessonIndex + 1,
        });

        showToast("Lesson completed successfully!", "success");
      }

      async function completeLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          // Move to next lesson
          currentLessonIndex++;
          loadLesson(currentLessonIndex);
        } else {
          // Course completion
          await completeCourse();
        }
      }

      async function completeCourse() {
        try {
          const completionTime = courseSession.totalStudyTime;

          // Update course progress to 100% completed
          await supabase
            .from("course_progress")
            .update({
              progress: 100,
              completed_at: new Date().toISOString(),
              completion_time_minutes: completionTime,
            })
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Award course completion achievements
          await checkAndUnlockAchievement("course_completion_1");
          await checkSpeedCompletionAchievements(completionTime);
          await checkCourseStreakAchievements();

          // Update user stats
          await updateUserStats();

          // Show completion message
          showToast(
            "Congratulations! Course completed successfully!",
            "certificate"
          );

          // Log course completion
          logUserActivity("course_completed", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            completion_time_minutes: completionTime,
            total_lessons: COURSE_DATA.lessons.length,
            average_quiz_score: calculateAverageQuizScore(),
          });

          // Redirect to dashboard after delay
          setTimeout(() => {
            window.location.href = "/dashboard";
          }, 3000);
        } catch (error) {
          console.error("Error completing course:", error);
          showToast("Error marking course as complete", "error");
        }
      }

      // =====================================================
      // ACHIEVEMENT INTEGRATION SYSTEM
      // =====================================================
      async function checkAndUnlockAchievement(
        achievementId,
        skipNotification = false
      ) {
        try {
          // Prevent duplicate checks
          const cacheKey = `achievement_${achievementId}_${currentUser.id}`;
          if (sessionStorage.getItem(cacheKey)) return false;

          // Check if already unlocked
          const { data: existing, error } = await supabase
            .from("user_achievements")
            .select("id")
            .eq("user_id", currentUser.id)
            .eq("achievement_id", achievementId)
            .single();

          if (existing) {
            sessionStorage.setItem(cacheKey, "true");
            return false;
          }

          // Award achievement
          const achievementData = {
            user_id: currentUser.id,
            achievement_id: achievementId,
            unlocked_at: new Date().toISOString(),
            points_awarded: getAchievementPoints(achievementId),
            context: "course_system",
          };

          const { data, error: insertError } = await supabase
            .from("user_achievements")
            .insert([achievementData])
            .select()
            .single();

          if (insertError) {
            if (insertError.code === "23505") return false; // Already exists
            throw insertError;
          }

          // Update user points
 await supabase.rpc('increment_user_stats', {
  user_id_param: currentUser.id,
  points_to_add: achievementData.points_awarded,
  achievements_to_add: 1
});

          // Cache and queue notification
          sessionStorage.setItem(cacheKey, "true");

          if (!skipNotification) {
            queueAchievementNotification({
              id: achievementId,
              name: getAchievementName(achievementId),
              description: getAchievementDescription(achievementId),
              points: achievementData.points_awarded,
              rarity: getAchievementRarity(achievementId),
              icon: getAchievementIcon(achievementId),
            });
          }

          return true;
        } catch (error) {
          console.error("Error unlocking achievement:", error);
          return false;
        }
      }

      // Helper functions for achievement data (replace with your actual achievement definitions)
      function getAchievementPoints(id) {
        const pointsMap = {
          first_course_start: 75,
          first_lesson: 100,
          course_completion_1: 500,
          perfect_score: 250,
          speed_demon: 750,
          marathon_learner: 500,
          night_owl: 200,
          early_bird: 200,
          weekend_warrior: 150,
          // Add more as needed
        };
        return pointsMap[id] || 100;
      }

      function getAchievementName(id) {
        const nameMap = {
          first_course_start: "Learning Initiated",
          first_lesson: "First Steps",
          course_completion_1: "Course Conqueror",
          perfect_score: "Perfectionist",
          speed_demon: "Speed Demon",
          // Add more as needed
        };
        return nameMap[id] || "Achievement Unlocked";
      }

      function getAchievementDescription(id) {
        const descMap = {
          first_course_start: "Start your first cybersecurity course",
          first_lesson: "Complete your first lesson",
          course_completion_1: "Complete your first course",
          perfect_score: "Score 100% on any quiz",
          speed_demon: "Complete a course in under 2 hours",
          // Add more as needed
        };
        return descMap[id] || "Achievement description";
      }

      function getAchievementRarity(id) {
        const rarityMap = {
          first_course_start: "common",
          first_lesson: "bronze",
          course_completion_1: "silver",
          perfect_score: "gold",
          speed_demon: "legendary",
          // Add more as needed
        };
        return rarityMap[id] || "common";
      }

      function getAchievementIcon(id) {
        const iconMap = {
          first_course_start: "fas fa-play",
          first_lesson: "fas fa-baby",
          course_completion_1: "fas fa-trophy",
          perfect_score: "fas fa-star",
          speed_demon: "fas fa-rocket",
          // Add more as needed
        };
        return iconMap[id] || "fas fa-award";
      }

      async function checkLessonAchievements(lessonNumber) {
        if (lessonNumber === 1) {
          await checkAndUnlockAchievement("first_lesson");
        }

        // Check if user has completed multiple lessons in one day
        const today = new Date().toISOString().split("T")[0];
        const todayCompletions = Object.values(courseProgress).filter(
          (p) => p.completed && p.completedAt?.startsWith(today)
        ).length;

        if (todayCompletions >= 3) {
          await checkAndUnlockAchievement("lesson_marathon");
        }
      }

      async function checkLessonCompletionAchievements() {
        const completedCount = getCompletedLessonsCount();

        // Lesson-based achievements
        const lessonMilestones = [1, 5, 10, 25, 50, 100];
        for (const milestone of lessonMilestones) {
          if (completedCount >= milestone) {
            await checkAndUnlockAchievement(`lessons_${milestone}`);
          }
        }

        // Course completion achievements
        if (completedCount === COURSE_DATA.lessons.length) {
          await checkAndUnlockAchievement("course_completion_1");

          // Check for additional course completion achievements
          const { data: allCourses } = await supabase
            .from("course_progress")
            .select("course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100);

          const totalCompleted = allCourses?.length || 0;

          const courseMilestones = [1, 5, 10, 25];
          for (const milestone of courseMilestones) {
            if (totalCompleted >= milestone) {
              await checkAndUnlockAchievement(`course_completion_${milestone}`);
            }
          }
        }
      }

      async function checkPerfectScoreAchievements(score) {
        if (score === 100) {
          await checkAndUnlockAchievement("perfect_score");

          // Check for consecutive perfect scores
          const recentScores = Object.values(courseProgress)
            .filter((p) => p.completed && p.quizScore)
            .slice(-5) // Last 5 completed
            .map((p) => p.quizScore);

          if (
            recentScores.length >= 3 &&
            recentScores.every((s) => s === 100)
          ) {
            await checkAndUnlockAchievement("perfectionist_streak");
          }
        }
      }

      async function checkSpeedCompletionAchievements(completionTime) {
        // Speed demon: Complete course in under 2 hours (120 minutes)
        if (completionTime <= 120) {
          await checkAndUnlockAchievement("speed_demon");
        }

        // Quick learner: Complete course in under 4 hours (240 minutes)
        if (completionTime <= 240) {
          await checkAndUnlockAchievement("quick_learner");
        }
      }

      async function checkStudyTimeAchievements() {
        const totalTime = courseSession.totalStudyTime;

        // Marathon learner: Study for 8+ hours in a course session
        if (totalTime >= 480) {
          // 8 hours
          await checkAndUnlockAchievement("marathon_learner");
        }

        // Dedicated learner: Study for 4+ hours
        if (totalTime >= 240) {
          // 4 hours
          await checkAndUnlockAchievement("dedicated_learner");
        }
      }

      async function checkCourseStreakAchievements() {
        try {
          // Check for consecutive course completions
          const { data: recentCourses, error } = await supabase
            .from("course_progress")
            .select("completed_at, course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100)
            .order("completed_at", { ascending: false })
            .limit(10);

          if (error || !recentCourses) return;

          // Check for courses completed on consecutive days
          let consecutiveDays = 1;
          for (let i = 1; i < recentCourses.length; i++) {
            const prevDate = new Date(
              recentCourses[i - 1].completed_at
            ).toDateString();
            const currentDate = new Date(
              recentCourses[i].completed_at
            ).toDateString();
            const dayDiff =
              Math.abs(new Date(prevDate) - new Date(currentDate)) /
              (1000 * 60 * 60 * 24);

            if (dayDiff <= 1) {
              consecutiveDays++;
            } else {
              break;
            }
          }

          if (consecutiveDays >= 3) {
            await checkAndUnlockAchievement("learning_streak");
          }
        } catch (error) {
          console.error("Error checking course streak achievements:", error);
        }
      }

      // =====================================================
      // TIME-BASED ACHIEVEMENTS
      // =====================================================
      async function checkTimeBasedAchievements(timestamp) {
        const hour = timestamp.getHours();
        const dayOfWeek = timestamp.getDay();

        // Night owl (after midnight, before 6 AM)
        if (hour >= 0 && hour < 6) {
          await incrementTimeBasedCounter("midnight_sessions", "night_owl");
        }

        // Early bird (4 AM to 6 AM)
        if (hour >= 4 && hour < 6) {
          await incrementTimeBasedCounter("early_sessions", "early_bird");
        }

        // Weekend warrior (Saturday = 6, Sunday = 0)
        if (dayOfWeek === 0 || dayOfWeek === 6) {
          await incrementTimeBasedCounter(
            "weekend_sessions",
            "weekend_warrior"
          );
        }
      }

      async function incrementTimeBasedCounter(counterType, achievementId) {
        try {
          const dateStr = new Date().toISOString().split("T")[0];
          const cacheKey = `${counterType}_${currentUser.id}_${dateStr}`;

          // Prevent multiple increments per day
          if (sessionStorage.getItem(cacheKey)) return;

          // Update counter
         await supabase.rpc('increment_profile_counter', {
  user_id_param: currentUser.id,
  counter_field: counterType,
  increment_value: 1
});

          // Cache to prevent double counting
          sessionStorage.setItem(cacheKey, "true");

          // Check related achievement
          if (achievementId) {
            await checkAndUnlockAchievement(achievementId, true);
          }
        } catch (error) {
          console.error(`Error incrementing ${counterType}:`, error);
        }
      }

      async function checkDailyStreak() {
        try {
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("last_activity, current_streak, last_streak_date")
            .eq("id", currentUser.id)
            .single();

          if (error) throw error;

          const now = new Date();
          const today = now.toDateString();
          const lastActivity = profile.last_activity
            ? new Date(profile.last_activity)
            : null;
          const lastStreakDate = profile.last_streak_date
            ? new Date(profile.last_streak_date).toDateString()
            : null;

          let newStreak = profile.current_streak || 0;
          let shouldUpdateStreak = false;

          if (!lastActivity) {
            // First time user
            newStreak = 1;
            shouldUpdateStreak = true;
          } else {
            const daysSinceLastActivity = Math.floor(
              (now - lastActivity) / (1000 * 60 * 60 * 24)
            );

            if (lastStreakDate === today) {
              // Already counted today's streak
              return newStreak;
            } else if (
              daysSinceLastActivity === 1 ||
              (daysSinceLastActivity === 0 && lastStreakDate !== today)
            ) {
              // Consecutive day or same day but not counted yet
              newStreak += 1;
              shouldUpdateStreak = true;
            } else if (daysSinceLastActivity > 1) {
              // Streak broken
              newStreak = 1;
              shouldUpdateStreak = true;
            }
          }

          if (shouldUpdateStreak) {
            await supabase
              .from("profiles")
              .update({
                current_streak: newStreak,
                last_activity: now.toISOString(),
                last_streak_date: now.toISOString(),
              })
              .eq("id", currentUser.id);

            userStats.current_streak = newStreak;

            showToast(`Daily streak: ${newStreak} days!`, "success");
            await checkStreakAchievements(newStreak);
          }

          return newStreak;
        } catch (error) {
          console.error("Error checking daily streak:", error);
          return 0;
        }
      }

      async function checkStreakAchievements(currentStreak) {
        const streakMilestones = [3, 7, 14, 30, 100, 365];

        for (const milestone of streakMilestones) {
          if (currentStreak >= milestone) {
            await checkAndUnlockAchievement(`streak_${milestone}`);
          }
        }
      }

      // =====================================================
      // USER ACTIVITY LOGGING
      // =====================================================
      async function logUserActivity(activityType, metadata = {}) {
        try {
          const now = new Date();

          const activityData = {
            user_id: currentUser.id,
            activity_type: activityType,
            timestamp: now.toISOString(),
            course_id: COURSE_DATA.id,
            lesson_index: currentLessonIndex,
            session_duration: courseSession.totalStudyTime,
            metadata: JSON.stringify(metadata),
            created_at: now.toISOString(),
          };

          // Try to log to activities table
          const { error } = await supabase
            .from("user_activities")
            .insert([activityData]);

          if (error && error.code !== "42P01") {
            console.warn("Activity logging failed:", error.message);
          }

          // Always update last activity in profile
          await supabase
            .from("profiles")
            .update({ last_activity: now.toISOString() })
            .eq("id", currentUser.id);
        } catch (error) {
          console.error("Error logging user activity:", error);
        }
      }

      // =====================================================
      // NAVIGATION SYSTEM
      // =====================================================
      function updateNavigationButtons() {
        const prevBtn = document.getElementById("prevLessonBtn");
        const nextBtn = document.getElementById("nextLessonBtn");

        if (!prevBtn || !nextBtn) return;

        // Previous button
        prevBtn.disabled = currentLessonIndex === 0;

        // Next button logic
        const isLastLesson =
          currentLessonIndex === COURSE_DATA.lessons.length - 1;
        const canGoNext =
          currentLessonIndex < COURSE_DATA.lessons.length - 1 &&
          canAccessLesson(currentLessonIndex + 1);

        if (isLastLesson) {
          const isCurrentCompleted =
            courseProgress[COURSE_DATA.lessons[currentLessonIndex].id]
              ?.completed;
          nextBtn.disabled = !isCurrentCompleted;
          nextBtn.innerHTML = '<i class="fas fa-trophy"></i> Complete Course';
        } else {
          nextBtn.disabled = !canGoNext;
          nextBtn.innerHTML = 'Next <i class="fas fa-chevron-right"></i>';
        }
      }

      // Navigation button event handlers
      function goToPreviousLesson() {
        if (currentLessonIndex > 0) {
          trackLessonTime(); // Track time spent on current lesson
          currentLessonIndex--;
          loadLesson(currentLessonIndex);
        }
      }

      function goToNextLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          const canGoNext = canAccessLesson(currentLessonIndex + 1);
          if (canGoNext) {
            trackLessonTime();
            currentLessonIndex++;
            loadLesson(currentLessonIndex);
          } else {
            showToast("Complete the current lesson quiz to proceed", "warning");
          }
        } else {
          // Complete course
          completeCourse();
        }
      }

      // =====================================================
      // SIDEBAR FUNCTIONS
      // =====================================================
      function toggleSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.toggle("open");
        if (overlay) overlay.classList.toggle("active");
      }

      function closeSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.remove("open");
        if (overlay) overlay.classList.remove("active");
      }

      // =====================================================
      // ACHIEVEMENT NOTIFICATION SYSTEM
      // =====================================================
      function queueAchievementNotification(achievement) {
        notificationQueue.push(achievement);
        processNotificationQueue();
      }

      function processNotificationQueue() {
        if (isShowingNotification || notificationQueue.length === 0) return;

        isShowingNotification = true;
        const achievement = notificationQueue.shift();
        showAchievementNotification(achievement);

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          isShowingNotification = false;
          processNotificationQueue();
        }, duration + 500);
      }

      function showAchievementNotification(achievement) {
        const notification = document.getElementById("achievementNotification");
        if (!notification) return;

        const icon = document.getElementById("notificationIcon");
        const title = document.getElementById("notificationTitle");
        const description = document.getElementById("notificationDescription");
        const points = document.getElementById("notificationPoints");

        if (icon) {
          icon.innerHTML = `<i class="${achievement.icon}"></i>`;
          icon.className = `notification-icon ${achievement.rarity}`;
        }
        if (title) title.textContent = achievement.name;
        if (description) description.textContent = achievement.description;
        if (points) points.textContent = `+${achievement.points} Points`;

        notification.className = `achievement-notification ${achievement.rarity}`;
        notification.classList.add("show");

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          notification.classList.remove("show");
        }, duration);
      }

      // =====================================================
      // UTILITY FUNCTIONS
      // =====================================================
      function calculateAverageQuizScore() {
        const scores = Object.values(courseProgress)
          .filter((p) => p.completed && p.quizScore)
          .map((p) => p.quizScore);

        if (scores.length === 0) return 0;
        return Math.round(
          scores.reduce((sum, score) => sum + score, 0) / scores.length
        );
      }

      async function resetProgress() {
        if (
          !confirm(
            "Are you sure you want to reset your progress? This action cannot be undone."
          )
        ) {
          return;
        }

        try {
          // Track lesson time before reset
          trackLessonTime();

          // Reset local state
          courseProgress = {};
          currentLessonIndex = 0;
          courseSession = {
            startTime: new Date(),
            totalStudyTime: 0,
            lessonsStarted: 0,
            lessonsCompleted: 0,
            pageLoadTime: new Date(),
            interactionCount: 0,
            lastActivityTime: new Date(),
          };

          // Delete from database
          await supabase
            .from("course_progress")
            .delete()
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Log reset activity
          logUserActivity("progress_reset", {
            course_id: COURSE_DATA.id,
            reset_reason: "manual",
          });

          // Reinitialize
          await saveProgress();
          renderSidebar();
          loadLesson(0);

          showToast("Progress reset successfully", "success");
        } catch (error) {
          console.error("Error resetting progress:", error);
          showToast("Failed to reset progress", "error");
        }
      }

      function copyCode(codeId) {
        const codeElement = document.getElementById(codeId);
        if (!codeElement) return;

        const text = codeElement.textContent;

        navigator.clipboard
          .writeText(text)
          .then(() => {
            showToast("Code copied to clipboard!", "success");

            // Track code copy for achievements
            logUserActivity("code_copied", {
              code_section: codeId,
              lesson_id: COURSE_DATA.lessons[currentLessonIndex].id,
            });
          })
          .catch((err) => {
            console.error("Failed to copy code:", err);
            showToast("Failed to copy code", "error");

            // Fallback for older browsers
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            try {
              document.execCommand("copy");
              showToast("Code copied to clipboard!", "success");
            } catch (fallbackError) {
              showToast(
                "Copy failed - please select and copy manually",
                "error"
              );
            }
            document.body.removeChild(textArea);
          });
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // =====================================================
      // UI FEEDBACK SYSTEMS
      // =====================================================
      function showToast(message, type = "success") {
        const toast = document.getElementById("toast");
        const messageEl = document.getElementById("toastMessage");

        if (!toast || !messageEl) {
          console.log(`Toast: ${message} (${type})`);
          return;
        }

        messageEl.textContent = message;
        toast.className = `toast ${type} show`;

        setTimeout(() => {
          toast.classList.remove("show");
        }, 4000);
      }

      function showLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) loadingScreen.classList.remove("hidden");
      }

      function hideLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) {
          setTimeout(() => {
            loadingScreen.classList.add("hidden");
          }, 1000);
        }
      }

      // =====================================================
      // MUSIC PLAYER INTEGRATION
      // =====================================================
      function initMusicPlayer() {
        const btnText = document.getElementById("music-button-text");
        const icon = document.getElementById("music-icon");
        const dropdown = document.getElementById("music-dropdown-content");

        if (!btnText || !icon || !dropdown) return;

        function setUI(state) {
          btnText.textContent =
            state === "Playing" ? "PAUSE MUSIC" : "STUDY MUSIC";
          icon.className =
            state === "Playing"
              ? "fa-solid fa-circle-pause"
              : "fa-solid fa-music";
        }

        // Load saved music state
        const savedSrc = localStorage.getItem("cybersec_music_src");
        const savedTime = parseFloat(
          localStorage.getItem("cybersec_music_time") || 0
        );

        if (savedSrc) {
          audioPlayer.src = savedSrc;
          audioPlayer.currentTime = savedTime;
          audioPlayer
            .play()
            .then(() => setUI("Playing"))
            .catch(() => setUI("Stopped"));
        }

        // Music button click handler
        document
          .getElementById("music-dropdown")
          .querySelector("button")
          .addEventListener("click", (e) => {
            e.stopPropagation();
            dropdown.style.display =
              dropdown.style.display === "block" ? "none" : "block";

            if (audioPlayer.src && !audioPlayer.paused) {
              audioPlayer.pause();
              setUI("Stopped");
            } else if (audioPlayer.src) {
              audioPlayer.play().then(() => setUI("Playing"));
            }
          });

        // Music selection handlers
        dropdown.querySelectorAll("a[data-src]").forEach((link) => {
          link.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.src = link.dataset.src;
            audioPlayer.play().then(() => setUI("Playing"));
            localStorage.setItem("cybersec_music_src", link.dataset.src);
            dropdown.style.display = "none";
          });
        });

        // Stop music handler
        const stopLink = document.getElementById("stop-music-link");
        if (stopLink) {
          stopLink.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            audioPlayer.removeAttribute("src");
            setUI("Stopped");
            localStorage.removeItem("cybersec_music_src");
            localStorage.removeItem("cybersec_music_time");
            dropdown.style.display = "none";
          });
        }

        // Save music state before page unload
        window.addEventListener("beforeunload", () => {
          if (!audioPlayer.paused && audioPlayer.src) {
            localStorage.setItem("cybersec_music_src", audioPlayer.src);
            localStorage.setItem(
              "cybersec_music_time",
              audioPlayer.currentTime
            );
          }
        });

        // Close dropdown when clicking outside
        window.addEventListener("click", (e) => {
          if (!e.target.closest("#music-dropdown")) {
            dropdown.style.display = "none";
          }
        });
      }

      // Show initial music indicator
      function addMusicIndicator() {
        const musicBtn = document.querySelector("#music-dropdown");
        if (musicBtn) {
          const indicator = document.createElement("div");
          indicator.className = "music-indicator";
          indicator.innerHTML = `<i class="fa-solid fa-music"></i> Try Study Music!`;

          musicBtn.style.position = "relative";
          musicBtn.appendChild(indicator);

          setTimeout(() => indicator.remove(), 3000);
        }
      }

      // Initialize Event Listeners
      function initializeEventListeners() {
        // Navigation buttons
        document
          .getElementById("prevLessonBtn")
          ?.addEventListener("click", goToPreviousLesson);
        document
          .getElementById("nextLessonBtn")
          ?.addEventListener("click", goToNextLesson);

        // Reset progress button
        document
          .getElementById("resetProgressBtn")
          ?.addEventListener("click", resetProgress);

        // Mobile menu toggle
        document
          .getElementById("menuToggle")
          ?.addEventListener("click", toggleSidebar);
        document
          .getElementById("sidebarOverlay")
          ?.addEventListener("click", closeSidebar);

        // Keyboard shortcuts
        document.addEventListener("keydown", handleKeyboardShortcuts);

        // Window resize handler
        window.addEventListener("resize", handleWindowResize);

        // Content interaction tracking
        document.getElementById("contentBody")?.addEventListener(
          "scroll",
          debounce(() => {
            trackUserInteraction();
          }, 1000)
        );
      }

      // Keyboard Shortcuts
      function handleKeyboardShortcuts(e) {
        if (document.querySelector(".quiz-question.active")) return;

        if (e.key === "ArrowLeft" && e.ctrlKey) {
          e.preventDefault();
          goToPreviousLesson();
        } else if (e.key === "ArrowRight" && e.ctrlKey) {
          e.preventDefault();
          goToNextLesson();
        }
      }

      // Window Resize Handler
      function handleWindowResize() {
        if (window.innerWidth > 768) {
          closeSidebar();
        }
      }

      // Debounce Helper
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Initialize responsive behavior
      if (window.innerWidth <= 768) {
        document.getElementById("menuToggle").style.display = "inline-flex";
      }

      // Auto-save progress periodically
      setInterval(async () => {
        if (currentUser && Object.keys(courseProgress).length > 0) {
          await saveProgress();
        }
      }, 60000); // Save every minute

      // System initialization logging
      console.log("CyberSec Academy Course System Initialized");
      console.log("Current Course:", COURSE_DATA.title);
      console.log("Total Lessons:", COURSE_DATA.lessons.length);

      // Google OAuth Integration
      const googleBtn = document.querySelector(".btn-google");
      if (googleBtn) {
        googleBtn.addEventListener("click", async () => {
          const { data, error } = await supabase.auth.signInWithOAuth({
            provider: "google",
            options: {
              redirectTo:
                window.location.origin +
                "/courses/advanced-malware-research-complete-course",
            },
          });

          if (error) {
            console.error("Google login error:", error.message);
            showToast("Google login failed: " + error.message, "error");
          }
        });
      }

      // Check for existing session
      supabase.auth.getSession().then(({ data }) => {
        if (data.session) {
          console.log("User already logged in:", data.session.user);
          currentUser = data.session.user;
          startCourseSession();
        }
      });

      // Add missing auth modal functions
      function openAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "flex";
        }
      }

      function closeAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Add auth tab switching functionality
      document.getElementById("tabSignIn")?.addEventListener("click", () => {
        document.getElementById("tabSignIn").classList.add("active");
        document.getElementById("tabSignUp").classList.remove("active");
        document.getElementById("signInForm").style.display = "block";
        document.getElementById("signUpForm").style.display = "none";
      });

      document.getElementById("tabSignUp")?.addEventListener("click", () => {
        document.getElementById("tabSignUp").classList.add("active");
        document.getElementById("tabSignIn").classList.remove("active");
        document.getElementById("signUpForm").style.display = "block";
        document.getElementById("signInForm").style.display = "none";
      });

      document
        .getElementById("closeAuthModal")
        ?.addEventListener("click", closeAuthModal);

      // Improved error handling for auth session
      supabase.auth.onAuthStateChange((event, session) => {
        if (event === "SIGNED_IN") {
          currentUser = session.user;
          closeAuthModal();
          startCourseSession();
        } else if (event === "SIGNED_OUT") {
          currentUser = null;
          openAuthModal();
        }
      });

      // Add form submission handlers
      document
        .getElementById("emailSignInForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signInEmail").value;
          const password = document.getElementById("signInPassword").value;

          try {
            const { data, error } = await supabase.auth.signInWithPassword({
              email,
              password,
            });

            if (error) throw error;

            closeAuthModal();
          } catch (error) {
            showToast(error.message, "error");
          }
        });

      document
        .getElementById("emailSignUpForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signUpEmail").value;
          const password = document.getElementById("signUpPassword").value;
          const name = document.getElementById("signUpName").value;

          try {
            const { data, error } = await supabase.auth.signUp({
              email,
              password,
              options: {
                data: {
                  full_name: name,
                },
              },
            });

            if (error) throw error;

            showToast(
              "Account created successfully! Please check your email.",
              "success"
            );
          } catch (error) {
            showToast(error.message, "error");
          }
        });
    </script>
  </body>
</html>

