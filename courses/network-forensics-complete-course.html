



<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Exo+2:wght@700;800;900&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css"
    />
    <link rel="stylesheet" href="assets/css/coursepages.css">

    <!-- ========== Start: SEO & Schema Enhancement ========== -->
    <title>Network Forensics - Complete Course | CipherHall</title>
    <meta name="description" content="Enroll in our expert-led Network Forensics course. Master packet analysis, threat hunting with Wireshark and Zeek, and investigate complex network intrusions.">
    
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png" />
    <link rel="shortcut icon" href="/favicon.png" type="image/x-icon" />
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png" />
    <link rel="canonical" href="https://www.cipherhall.com/courses/network-forensics-complete-course.html" />

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Course",
      "name": "Network Forensics - Complete Course",
      "description": "A comprehensive course on the art of network traffic analysis for incident response, threat hunting, and digital investigations. Learn to capture, decode, and reconstruct network activity to uncover the full story of a cyberattack.",
      "provider": {
        "@type": "Organization",
        "name": "CipherHall",
        "sameAs": "https://www.cipherhall.com"
      },
      "hasCourseInstance": {
        "@type": "CourseInstance",
        "courseMode": "Online",
        "instructor": {
          "@type": "Person",
          "name": "Dr. Evelyn Reed"
        }
      }
    }
    </script>
    <!-- ========== End: SEO & Schema Enhancement ========== -->
</head>
  <body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
      <div class="loader-icon">
        <i class="fas fa-graduation-cap"></i>
      </div>
      <div class="loader-text">Loading Course Content...</div>
    </div>

    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- Music Player (fixed at top right) -->
    <div class="header-controls">
      <div class="music-dropdown" id="music-dropdown">
        <button class="btn btn-secondary">
          <span id="music-button-text">STUDY MUSIC</span>
          <i id="music-icon" class="fa-solid fa-music"></i>
        </button>
        <div class="music-dropdown-content" id="music-dropdown-content">
          <a
            href="#"
            data-src="https://www.learningcontainer.com/wp-content/uploads/2020/02/Kalimba.mp3"
            >1. Coffee Shop Vibes</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3"
            >2. City Lights Lofi</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-15.mp3"
            >3. Mellow Thoughts</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-13.mp3"
            >4. Rainy Mood</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3"
            >5. Time Alone</a
          >
          <a href="#" id="stop-music-link"
            ><i class="fa-solid fa-stop-circle"></i> Stop Music</a
          >
        </div>
      </div>

      <button class="btn btn-secondary" id="resetProgressBtn">
        <i class="fas fa-redo"></i>
        Reset Progress
      </button>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal" style="display: none">
      <div class="modal-overlay"></div>
      <div class="modal-content">
        <span class="close" id="closeAuthModal">&times;</span>
        <div class="auth-tabs">
          <button id="tabSignIn" class="auth-tab active">Sign In</button>
          <button id="tabSignUp" class="auth-tab">Sign Up</button>
        </div>
        <div
          id="authLoader"
          style="display: none; text-align: center; padding: 2rem"
        >
          <i
            class="fas fa-spinner fa-spin fa-2x"
            style="color: var(--color-green)"
          ></i>
          <p style="margin-top: 0.5rem">Authenticating...</p>
        </div>
        <div id="signInForm" class="auth-form">
          <h2>Sign In to CipherHall</h2>
          <button id="googleSignIn" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignInForm">
            <input
              type="email"
              id="signInEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signInPassword"
              placeholder="Password"
              required
            />
            <button type="submit" class="btn btn-primary">Sign In</button>
          </form>
        </div>
        <div id="signUpForm" class="auth-form" style="display: none">
          <h2>Join CipherHall</h2>
          <button id="googleSignUp" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignUpForm">
            <input
              type="text"
              id="signUpName"
              placeholder="Full Name"
              required
            />
            <input
              type="email"
              id="signUpEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signUpPassword"
              placeholder="Password (min. 8 characters)"
              required
            />
            <button type="submit" class="btn btn-secondary">
              Create Account
            </button>
          </form>
        </div>
        <div id="authMessage"></div>
      </div>
    </div>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="course-info">
          <h1 class="course-title" id="courseTitle">Loading...</h1>
          <div class="course-progress">
            <div class="progress-header">
              <span class="progress-label">Course Progress</span>
              <span class="progress-percentage" id="courseProgressPercent"
                >0%</span
              >
            </div>
            <div class="progress-bar">
              <div
                class="progress-fill"
                id="courseProgressFill"
                style="width: 0%"
              ></div>
            </div>
            <div class="progress-stats">
              <span id="completedLessons">0</span>
              <span id="totalLessons">0</span>
            </div>
          </div>
          <a href="/dashboard.html" class="back-to-dashboard">
            <i class="fas fa-arrow-left"></i>
            Back to Dashboard
          </a>
        </div>
      </div>

      <nav class="lesson-nav" id="lessonNav">
        <!-- Lessons will be loaded dynamically -->
      </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <header class="content-header">
        <div class="lesson-header">
          <div class="lesson-header-left">
            <span class="lesson-number" id="currentLessonNumber">1</span>
            <h1 class="lesson-header-title" id="currentLessonTitle">
              Loading...
            </h1>
          </div>
          <div class="lesson-actions">
            <button class="mbtn btn-primary" id="menuToggle">
              <i class="fas fa-bars"></i>
            </button>
          </div>
        </div>
      </header>

      <div class="content-body" id="contentBody">
        <div class="lesson-content" id="lessonContent">
          <!-- Lesson content will be loaded dynamically -->
        </div>
      </div>

      <footer class="lesson-navigation">
        <div class="nav-info" id="navInfo">Lesson 1 of 10</div>
        <div class="nav-controls">
          <button class="btn btn-secondary" id="prevLessonBtn" disabled>
            <i class="fas fa-chevron-left"></i>
            Previous
          </button>
          <button class="btn btn-primary" id="nextLessonBtn" disabled>
            Next
            <i class="fas fa-chevron-right"></i>
          </button>
        </div>
      </footer>
    </main>

    <!-- Achievement Notification -->
    <div id="achievementNotification" class="achievement-notification">
      <div class="notification-header">
        <div class="notification-icon" id="notificationIcon">
          <i class="fas fa-trophy"></i>
        </div>
        <div class="notification-content">
          <h3 id="notificationTitle">Achievement Unlocked!</h3>
          <p id="notificationDescription">Description here...</p>
        </div>
      </div>
      <div class="notification-reward" id="notificationReward">
        <i class="fas fa-coins"></i>
        <span id="notificationPoints">+100 Points</span>
      </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast">
      <span id="toastMessage"></span>
    </div>

    <script>
      // =====================================================
      // SYNCHRONIZED COURSE SYSTEM WITH DASHBOARD INTEGRATION
      // =====================================================

      // Supabase Configuration - Replace with your config
      const supabaseUrl = "https://lzcmzulemfubjaksoqor.supabase.co";
      const supabaseKey =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx6Y216dWxlbWZ1Ympha3NvcW9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzMzM5MDgsImV4cCI6MjA3MDkwOTkwOH0.crhPH4YWtRsr1BJTpAQcmPbWSpwIWRbzoI4sRb2_fPI";
      const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

      // =====================================================
      // COURSE DATA STRUCTURE - REPLACE WITH YOUR COURSE JSON
      // =====================================================

      const COURSE_DATA =   {
        "id": "network-forensics",
        "title": "Network Forensics - Complete Course Curriculum",
        "description": "A comprehensive course on the art of network traffic analysis for incident response, threat hunting, and digital investigations. Learn to capture, decode, and reconstruct network activity to uncover the full story of a cyberattack.",
        "category": "digital-forensics",
        "difficulty": "Intermediate to Advanced",
        "duration": "80 hours",
        "instructor": "Dr. Evelyn Reed",
        "lessons": [
            {
                "id": "lesson-1",
                "title": "Fundamentals of Network Forensics",
                "duration": "120 min",
                "objectives": [
                    "Define the scope and purpose of network forensics.",
                    "Explain the forensic implications of the OSI and TCP/IP models.",
                    "Differentiate between various types of network evidence (PCAP, NetFlow, logs).",
                    "Understand the legal considerations for the admissibility of network evidence.",
                    "Compare and contrast network forensics with host-based (disk/memory) forensics.",
                    "Discuss the methodologies for both real-time and retrospective network analysis."
                ],
                "content": {
                    "overview": "This foundational lesson introduces the discipline of network forensics. We will define what constitutes network evidence, explore the fundamental models that govern network communication, and establish the legal and procedural frameworks necessary for conducting a sound investigation. You will learn to see the network not just as a data transport layer, but as a rich source of forensic evidence.",
                    "sections": [
                        {
                            "title": "Network Forensics Definition and Scope",
                            "content": "<p>Network forensics is the specialized branch of digital forensics focused on the monitoring, capture, and analysis of network traffic for the purpose of information gathering, legal evidence, or intrusion detection.</p><h3>Key Objectives:</h3><ul><li>Reconstruct events from a network intrusion to understand the attacker's actions.</li><li>Identify the source of an attack and the systems involved.</li><li>Analyze command and control (C2) channels used by malware.</li><li>Trace data exfiltration to determine what information was stolen.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Network Evidence Types and Characteristics",
                            "content": "<p>Network evidence is highly volatile and comes in several forms, each with its own strengths and weaknesses.</p><ul><li><strong>Full Packet Capture (PCAP):</strong> A bit-for-bit copy of all traffic passing over a network segment. It is the most complete and detailed form of evidence, but requires immense storage.</li><li><strong>NetFlow/IPFIX:</strong> A summary or metadata record of network conversations. It's like a phone bill: it shows who talked to whom, when, and for how long, but not the content of the conversation. It is much smaller than PCAP.</li><li><strong>Log Files:</strong> Logs from devices like firewalls, proxies, and DNS servers provide a crucial record of network activity and security alerts.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Network vs. Host-Based Forensics",
                            "content": "<p>A complete investigation requires correlating evidence from both the network and the host (disk/memory).</p><p><strong>Real-time Problem: Identifying an attack source from limited network logs.</strong> A company's web server was compromised. The on-disk logs on the server were wiped by the attacker. However, the company's firewall logs were stored on a separate, secure server. A network forensic analyst can analyze these firewall logs to identify the attacker's IP address, the time of the connection, and the port that was used. Even without the host logs, the network evidence can provide the critical first lead in the investigation.</p>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Network Forensics Lab Setup (Conceptual)",
                            "language": "bash",
                            "code": "# This script outlines the setup of a Linux workstation for network analysis.\n\n# 1. Update the system\nsudo apt update && sudo apt upgrade -y\n\n# 2. Install core packet capture and analysis tools\n# Wireshark is the GUI standard, tcpdump is the command-line standard.\nsudo apt install -y wireshark tcpdump tshark\n\n# 3. Install the Zeek (formerly Bro) Network Security Monitor\n# Zeek is a powerful tool that generates high-fidelity transaction logs from network traffic.\nsudo apt install -y zeek\n\n# 4. Create case directories\nmkdir -p ~/forensics/network_captures\nmkdir -p ~/forensics/case_logs\n\n# 5. Configure a network interface for promiscuous mode to capture all traffic\n# sudo ip link set eth1 promisc on\n\necho \"[+] Network forensics lab environment is ready.\""
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the most complete and detailed form of network evidence?",
                            "options": [
                                "NetFlow data",
                                "Firewall logs",
                                "Full Packet Capture (PCAP)",
                                "A system's ARP cache"
                            ],
                            "correct": 2,
                            "explanation": "A full packet capture is a bit-for-bit recording of the entire network conversation. It contains the complete content of the communication, making it the most detailed but also the largest type of evidence."
                        },
                        {
                            "id": 2,
                            "question": "NetFlow is often compared to a phone bill. What does this analogy mean?",
                            "options": [
                                "NetFlow is very expensive.",
                                "NetFlow records the full content of every conversation.",
                                "NetFlow provides metadata (who talked to whom, when, how long) but does not record the actual content of the conversation.",
                                "NetFlow is only used for telephone networks."
                            ],
                            "correct": 2,
                            "explanation": "This is the classic analogy. NetFlow provides a summary of connections, which is extremely useful for high-level analysis and anomaly detection, but it lacks the deep detail of a full packet capture."
                        },
                        {
                            "id": 3,
                            "question": "Why is it critical to correlate network evidence with host-based evidence?",
                            "options": [
                                "It is not critical; network evidence is always enough.",
                                "Network evidence shows *what* happened between systems, while host evidence shows *what* happened on a specific system (e.g., which process was responsible for the network traffic).",
                                "It is a legal requirement in all countries.",
                                "Host-based evidence is less reliable than network evidence."
                            ],
                            "correct": 1,
                            "explanation": "The two evidence types complement each other. The network shows the communication, but the host shows the cause and effect of that communication on the endpoint, creating a complete narrative of the incident."
                        }
                    ]
                }
            },
            {
                "id": "lesson-2",
                "title": "Network Protocols and Traffic Analysis",
                "duration": "120 min",
                "objectives": [
                    "Perform a detailed analysis of Ethernet frames, IP packets, and TCP segments.",
                    "Reconstruct a TCP conversation and track its state.",
                    "Analyze DNS queries and responses to identify suspicious activity.",
                    "Examine DHCP transactions to link a MAC address to an IP address at a specific time.",
                    "Understand how to dissect common protocols like UDP, ICMP, and ARP for forensic clues."
                ],
                "content": {
                    "overview": "To analyze network traffic, you must speak the language of the network: protocols. This lesson is a deep dive into the structure and function of the core protocols of the TCP/IP suite. We will dissect packets layer by layer, from the Ethernet frame up to the TCP segment, learning how to interpret the fields and flags that reveal the story of a network communication.",
                    "sections": [
                        {
                            "title": "TCP/IP Stack Analysis",
                            "content": "<p>Network communication is layered. Each layer wraps the layer above it in an envelope with its own addressing information.</p><h3>The Layers of a Packet:</h3><ul><li><strong>Layer 2 (Data Link):</strong> The Ethernet frame, which contains the source and destination MAC addresses for communication on the local network.</li><li><strong>Layer 3 (Network):</strong> The IP packet, which contains the source and destination IP addresses for communication across the internet.</li><li><strong>Layer 4 (Transport):</strong> The TCP segment or UDP datagram, which contains the source and destination ports that identify the specific application communicating (e.g., port 443 for HTTPS).</li></ul><p>An analyst must be able to peel back these layers to understand the full context of a communication.</p>",
                            "image": "https://images.unsplash.com/photo-1517694712202-14dd9538aa97?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "TCP Connection Analysis (The Three-Way Handshake)",
                            "content": "<p>TCP is a connection-oriented protocol, meaning it establishes a reliable session before sending data. This session is established with the 'three-way handshake'.</p><ol><li><strong>SYN:</strong> The client sends a synchronize (SYN) packet to the server.</li><li><strong>SYN-ACK:</strong> The server responds with a synchronize-acknowledge (SYN-ACK) packet.</li><li><strong>ACK:</strong> The client acknowledges the server's response with an acknowledge (ACK) packet.</li></ol><p><strong>Forensic Implication:</strong> A SYN flood is a common DDoS attack where an attacker sends a huge number of SYN packets but never completes the handshake with the final ACK. This leaves the server with a large number of half-open connections, exhausting its resources. An analyst can easily spot this in a packet capture by seeing a massive number of SYN and SYN-ACK packets without the corresponding ACKs.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "DNS and DHCP: The Network's Address Books",
                            "content": "<p>These two protocols are critically important sources of evidence.</p><ul><li><strong>DNS (Domain Name System):</strong> Translates human-readable domain names (`www.google.com`) into machine-readable IP addresses (`142.250.190.78`). Analyzing DNS traffic can reveal which websites a user visited or which C2 server a piece of malware was trying to contact.</li><li><strong>DHCP (Dynamic Host Configuration Protocol):</strong> Assigns IP addresses to devices when they join a network.</li></ul><p><strong>Real-time Problem: Reconstructing fragmented communication.</strong> An analyst is investigating a large file transfer. In the packet capture, the file is broken into thousands of small TCP segments. Using a tool like Wireshark, the analyst can select one of the packets in the conversation and use the 'Follow TCP Stream' feature. The tool will automatically reassemble all the segments in the correct order and display the full, reconstructed file or data stream, allowing the analyst to see exactly what was transferred.</p>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Protocol Parser and Analyzer (Scapy)",
                            "language": "python",
                            "code": "from scapy.all import rdpcap, TCP, IP\n\n# This script uses the Scapy library in Python to parse a PCAP file\n# and analyze TCP packets.\n\ndef analyze_pcap(pcap_file):\n    \"\"\"Reads a PCAP file and prints details for each TCP packet.\"\"\"\n    packets = rdpcap(pcap_file)\n\n    print(f\"--- Analyzing TCP packets in {pcap_file} ---\")\n    for packet in packets:\n        # Check if the packet has both an IP and a TCP layer\n        if IP in packet and TCP in packet:\n            ip_layer = packet[IP]\n            tcp_layer = packet[TCP]\n\n            # Extract key information\n            source_ip = ip_layer.src\n            dest_ip = ip_layer.dst\n            source_port = tcp_layer.sport\n            dest_port = tcp_layer.dport\n            flags = tcp_layer.flags\n\n            print(f\"Src: {source_ip}:{source_port} -> Dst: {dest_ip}:{dest_port} | Flags: {flags}\")\n\n# analyze_pcap(\"path/to/your/capture.pcap\")"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "In the TCP/IP stack, which layer is responsible for adding source and destination IP addresses?",
                            "options": [
                                "Layer 2 (Data Link)",
                                "Layer 3 (Network)",
                                "Layer 4 (Transport)",
                                "Layer 7 (Application)"
                            ],
                            "correct": 1,
                            "explanation": "The Network layer, implemented by the Internet Protocol (IP), is responsible for end-to-end addressing and routing across different networks."
                        },
                        {
                            "id": 2,
                            "question": "What are the three steps of the TCP three-way handshake?",
                            "options": [
                                "SYN, ACK, FIN",
                                "SYN, SYN-ACK, ACK",
                                "REQ, RESP, ACK",
                                "ARP, RARP, PING"
                            ],
                            "correct": 1,
                            "explanation": "The three-way handshake (SYN, SYN-ACK, ACK) is the fundamental process by which TCP establishes a reliable connection before any data is transferred."
                        },
                        {
                            "id": 3,
                            "question": "An investigator needs to determine which IP address was assigned to a specific laptop (identified by its MAC address) at noon last Tuesday. Which server's logs would contain this information?",
                            "options": [
                                "The DNS server",
                                "The Web server",
                                "The File server",
                                "The DHCP server"
                            ],
                            "correct": 3,
                            "explanation": "The DHCP server is responsible for leasing IP addresses to devices on the network. Its logs contain a detailed record of which MAC address was assigned which IP address at what specific time, which is crucial for correlating activity to a physical device."
                        }
                    ]
                }
            },
            {
                "id": "lesson-3",
                "title": "Packet Capture and Network Monitoring",
                "duration": "120 min",
                "objectives": [
                    "Implement various packet capture methodologies.",
                    "Understand the difference between a network tap and a SPAN port.",
                    "Use Wireshark and its advanced features for deep packet analysis.",
                    "Leverage tcpdump for efficient command-line packet capture.",
                    "Optimize capture filters to reduce noise and storage requirements.",
                    "Address the bandwidth and storage considerations for long-term capture."
                ],
                "content": {
                    "overview": "The foundation of retrospective network forensics is the packet capture. This lesson covers the practical art and science of capturing network traffic, from the hardware and software used to the techniques for filtering and analyzing the vast amounts of data collected. We will focus on the two most important tools in any network analyst's toolkit: Wireshark and tcpdump.",
                    "sections": [
                        {
                            "title": "Packet Capture Methodologies",
                            "content": "<p>To capture traffic, you need a way to see all the packets flowing through a network segment. There are two primary ways to achieve this.</p><h3>Tap vs. SPAN:</h3><ul><li><strong>Network Tap:</strong> A hardware device that is inserted inline into a network connection (e.g., between a router and a firewall). It creates an exact, passive copy of all traffic—including physical layer errors—and sends it to a monitoring port without affecting the live link. Taps are the most forensically sound and reliable method.</li><li><strong>Switch Port Mirroring (SPAN):</strong> A software feature on a managed network switch that copies all traffic from one or more ports to a designated monitoring port. It is less expensive and easier to configure than a tap, but it is not as reliable; if the switch's CPU is overloaded, it may drop mirrored packets.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Wireshark Advanced Analysis",
                            "content": "<p>Wireshark is the world's foremost network protocol analyzer. It is a powerful GUI tool that can decode thousands of protocols and has a rich set of features for forensic analysis.</p><h3>Key Features for Forensics:</h3><ul><li><strong>Display Filters:</strong> Allow you to filter a massive capture file to show only the packets that matter to your investigation (e.g., `ip.addr == 192.168.1.100 and tcp.port == 443`).</li><li><strong>Follow TCP/UDP Stream:</strong> Reconstructs an entire conversation from individual packets, showing the full data stream (e.g., a downloaded file, an HTML page).</li><li><strong>Expert Information:</strong> Automatically analyzes the capture and flags potential problems like retransmissions, duplicate ACKs, and other protocol anomalies.</li><li><strong>Statistics:</strong> Provides a huge range of statistical tools to analyze conversations, endpoints, protocol hierarchies, and more.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "tcpdump and Command-Line Analysis",
                            "content": "<p>tcpdump is a powerful command-line packet analyzer. While it lacks Wireshark's GUI, it is extremely fast, efficient, and scriptable, making it the tool of choice for capturing traffic on remote servers or for long-term monitoring.</p><p><strong>Real-time Problem: Capturing high-speed network traffic.</strong> A company needs to monitor a 10Gbps internet link, but Wireshark's GUI cannot keep up and drops packets. An analyst uses tcpdump because its command-line nature is much more efficient. They use a capture filter to only write the most important traffic (e.g., DNS and HTTP headers) to disk, drastically reducing the volume of data and allowing them to capture traffic from the high-speed link without loss.</p><h3>Capture vs. Display Filters:</h3><p>This is a critical concept. A **capture filter** (used by tcpdump) tells the capture engine which packets to save to disk. A **display filter** (used by Wireshark) is applied *after* the capture is complete to change which packets are shown on the screen. To reduce the size of a capture file, you must use a capture filter.</p>",
                            "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Automated Packet Capture System (tcpdump)",
                            "language": "bash",
                            "code": "# This script uses tcpdump for a continuous, rotating packet capture.\n# This is a common setup for long-term monitoring.\n\nINTERFACE=\"eth0\"\nOUTPUT_DIR=\"/captures/\"\n\n# Capture traffic on the specified interface.\n# -i: interface\n# -W: number of files to create before overwriting\n# -G: rotate the capture file every X seconds\n# -C: max file size in megabytes\n# -w: write to file (use %F for timestamp in filename)\n# 'port 53 or port 80 or port 443': A capture filter to only save DNS and web traffic.\n\nsudo tcpdump -i $INTERFACE -W 100 -G 3600 -C 200 -w \"$OUTPUT_DIR/%F-%H-%M-%S.pcap\" 'port 53 or port 80 or port 443'\n\n# This command will:\n# - Create a new pcap file every hour (-G 3600).\n# - Limit each file to 200MB (-C 200).\n# - Keep a maximum of 100 files, overwriting the oldest one when the limit is reached (-W 100).\n# - Only capture DNS, HTTP, and HTTPS traffic."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the primary advantage of using a network tap over a SPAN port for packet capture?",
                            "options": [
                                "Taps are less expensive.",
                                "Taps are easier to configure.",
                                "Taps are hardware devices that provide a more reliable, forensically sound copy of traffic and are not susceptible to dropping packets under heavy load.",
                                "Taps can only capture wireless traffic."
                            ],
                            "correct": 2,
                            "explanation": "A hardware tap is the gold standard for forensic acquisition because it is a passive device that does not rely on the switch's CPU, ensuring a full and accurate capture of all traffic, including errors."
                        },
                        {
                            "id": 2,
                            "question": "In Wireshark, what is the 'Follow TCP Stream' feature used for?",
                            "options": [
                                "To filter the display to show only TCP packets.",
                                "To automatically reassemble all the individual TCP segments of a conversation into the complete data stream (e.g., a file or webpage).",
                                "To check for TCP protocol errors.",
                                "To show a graph of TCP traffic over time."
                            ],
                            "correct": 1,
                            "explanation": "This is one of Wireshark's most powerful features. It takes a conversation that is fragmented into potentially thousands of packets and reconstructs it into a human-readable format."
                        },
                        {
                            "id": 3,
                            "question": "What is the critical difference between a capture filter and a display filter?",
                            "options": [
                                "There is no difference.",
                                "A capture filter tells the tool which packets to save to disk, while a display filter is applied after the capture to change what is shown on the screen.",
                                "Display filters are more powerful than capture filters.",
                                "Only tcpdump can use capture filters."
                            ],
                            "correct": 1,
                            "explanation": "This is a fundamental concept. Capture filters are essential for reducing the amount of data you have to store and process, especially on high-speed networks. Display filters are for analysis after the fact."
                        }
                    ]
                }
            },
            {
                "id": "lesson-4",
                "title": "Network Security Device Log Analysis",
                "duration": "100 min",
                "objectives": [
                    "Analyze and correlate firewall logs to track network connections.",
                    "Investigate alerts and logs from Intrusion Detection/Prevention Systems (IDS/IPS).",
                    "Examine Web Application Firewall (WAF) logs for signs of web attacks.",
                    "Reconstruct user activity and authentication from VPN and proxy server logs.",
                    "Analyze router and switch logs for network events and misconfigurations."
                ],
                "content": {
                    "overview": "While packet captures provide the ultimate detail, the logs generated by network security devices like firewalls, IDS, and proxies provide a high-level, summarized view of network activity. This lesson covers how to parse, analyze, and correlate these critical log sources to build a comprehensive picture of an intrusion.",
                    "sections": [
                        {
                            "title": "Firewall Log Analysis",
                            "content": "<p>Firewall logs are the most fundamental source of network log evidence. They record every connection that is allowed or denied by the firewall's rule set.</p><h3>Key Fields in a Firewall Log:</h3><ul><li>Timestamp</li><li>Source IP and Port</li><li>Destination IP and Port</li><li>Protocol (TCP/UDP)</li><li>Action (e.g., ALLOW, DENY, DROP)</li></ul><p><strong>Real-world Example:</strong> An analyst is investigating a compromised server. They know the time of the compromise. They can filter the firewall logs to show all connections that were *allowed* to that server in the minutes leading up to the compromise. This can directly reveal the attacker's source IP address and the port they used to gain entry.</p>",
                            "image": "https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "IDS/IPS Forensics",
                            "content": "<p>An Intrusion Detection System (IDS) or Intrusion Prevention System (IPS) is designed to detect malicious activity by matching network traffic against a set of signatures or by spotting behavioral anomalies.</p><h3>Investigating an IDS/IPS Alert:</h3><p>An IDS alert is the starting point, not the conclusion. When an alert fires (e.g., 'SQL Injection Attempt Detected'), the analyst must pivot to other data sources to validate it.</p><ol><li><strong>The Alert:</strong> IDS alerts that a specific IP attempted SQL injection against a web server.</li><li><strong>Validation:</strong> The analyst goes to the full packet capture for that specific timeframe and examines the traffic. They confirm that the packet content does, in fact, contain a malicious SQL string.</li><li><strong>Impact Assessment:</strong> The analyst then checks the web server's logs to see how the server *responded* to the attack. Did it return an error (attack failed) or a successful page load (attack may have succeeded)?</li></ol>",
                            "image": "https://images.unsplash.com/photo-1548092372-2d987bde898b?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Proxy and VPN Log Examination",
                            "content": "<p>These logs are key for tracking user activity.</p><ul><li><strong>Proxy Server Logs:</strong> A web proxy logs every website that an internal user visits. This provides a detailed record of a user's browsing activity that they cannot erase (unlike their local browser history). It is crucial for insider threat and HR investigations.</li><li><strong>VPN Logs:</strong> Virtual Private Network (VPN) logs show which users connected to the corporate network remotely, when they connected, and what IP address they were assigned. This is critical for investigating incidents involving remote workers or compromised credentials.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Multi-Device Log Correlation Engine (Splunk)",
                            "language": "sql",
                            "code": "/* This is a conceptual Splunk query (SPL) that correlates data from multiple log sources\n   to trace a full attack sequence.\n*/\n\n// 1. Find a successful VPN login from an unexpected country (e.g., North Korea)\nindex=vpn sourcetype=cisco:asa event=login_success country=\"North Korea\"\n| table timestamp, user, source_ip\n\n// 2. Take the user and source_ip from that event and join it with firewall logs\n| join user, source_ip [\n    // Look for traffic from that user/IP that was allowed through the firewall\n    search index=firewall sourcetype=paloalto action=allow\n]\n\n// 3. Join the results with IDS logs\n| join dest_ip [\n    // Look for IDS alerts targeting the destination server the user connected to.\n    search index=ids sourcetype=snort signature=\"ETPRO TROJAN.*\n]\n\n// The final result shows a clear story: a suspicious VPN login, followed by that user\n// connecting through the firewall to an internal server, which then triggered a malware alert."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "Which log source would provide the most definitive record of every connection that was allowed or denied into a protected network segment?",
                            "options": [
                                "The DNS server log",
                                "The Web server access log",
                                "The Firewall log",
                                "The DHCP server log"
                            ],
                            "correct": 2,
                            "explanation": "The firewall's primary function is to enforce access control policy, and its log is the authoritative record of every connection that was permitted or blocked based on its rule set."
                        },
                        {
                            "id": 2,
                            "question": "An analyst receives an IDS alert for a potential web attack. What is the most important next step?",
                            "options": [
                                "Immediately block the source IP address.",
                                "Ignore the alert, as IDS alerts are usually false positives.",
                                "Validate the alert by examining the corresponding full packet capture and server logs to determine if the attack was real and if it was successful.",
                                "Reboot the IDS sensor."
                            ],
                            "correct": 2,
                            "explanation": "An alert is an indicator, not a conclusion. A good analyst must practice 'alert validation' by pivoting to more detailed evidence sources (like PCAP) to confirm the alert's validity and assess the actual impact."
                        },
                        {
                            "id": 3,
                            "question": "An investigator needs to determine which websites a specific employee visited last week. The employee has cleared their local browser history. What is the next best source for this information?",
                            "options": [
                                "The company's web proxy logs",
                                "The employee's mobile phone",
                                "The Domain Controller logs",
                                "The network switch logs"
                            ],
                            "correct": 0,
                            "explanation": "A web proxy sits between the users and the internet and logs all outbound web requests. This provides a centralized, server-side record of browsing activity that a user cannot tamper with."
                        }
                    ]
                }
            },
            {
                "id": "lesson-5",
                "title": "Email and Communication Protocol Forensics",
                "duration": "100 min",
                "objectives": [
                    "Analyze SMTP transactions to understand how email is transferred.",
                    "Perform forensic analysis on POP3 and IMAP traffic.",
                    "Conduct a detailed email header analysis to trace a message's origin and detect spoofing.",
                    "Reconstruct email sessions from network traffic.",
                    "Investigate instant messaging, VoIP, and video conferencing protocols.",
                    "Detect spam and phishing campaigns through traffic analysis."
                ],
                "content": {
                    "overview": "Email is a primary vector for attacks and a rich source of evidence. This lesson focuses on the network-level analysis of communication protocols. We will dissect the SMTP conversations that transfer email, learn to trace an email's path through its headers, and apply these techniques to investigate phishing and other communication-based threats.",
                    "sections": [
                        {
                            "title": "SMTP Transaction Analysis",
                            "content": "<p>The Simple Mail Transfer Protocol (SMTP) is the protocol used to send email between mail servers. It is a simple, text-based protocol that operates on TCP port 25.</p><h3>The SMTP Conversation:</h3><p>An analyst can reconstruct the entire conversation from a packet capture.</p><ul><li><strong>HELO/EHLO:</strong> The sending server introduces itself.</li><li><strong>MAIL FROM:</strong> Specifies the sender's address.</li><li><strong>RCPT TO:</strong> Specifies the recipient's address.</li><li><strong>DATA:</strong> The command that precedes the body of the email, including all the headers and content.</li></ul><p>By reassembling this stream, an analyst can see the exact commands the sending server used and the full, raw content of the message before it was processed by the user's email client.</p>",
                            "image": "https://images.unsplash.com/photo-1563206414-99371216c39a?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Email Header Analysis: The Digital Postmarks",
                            "content": "<p>Every email contains a set of headers that show the path it took across the internet. Analyzing these is the key to tracing an email's true origin.</p><h3>Key Headers for Analysis:</h3><ul><li><strong>Received:</strong> Each server that handles an email adds a 'Received' header to the top. To trace the path, you must read them from the *bottom up*. The bottom-most 'Received' header shows the original sending server.</li><li><strong>Authentication-Results:</strong> This header shows the results of DMARC, SPF, and DKIM checks. A `spf=fail` or `dkim=fail` result is a strong indicator that the sender's address was spoofed.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1558004533-28a9c37a78a6?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "VoIP and Real-Time Communication Forensics",
                            "content": "<p>Voice over IP (VoIP) and video conferencing traffic also leave network artifacts.</p><p><strong>Real-time Problem: Tracing a sophisticated phishing campaign.</strong> An organization is hit by a spear-phishing attack. The email appears to come from a legitimate partner company. An analyst captures the full SMTP conversation. They analyze the headers and see that while the 'From' address is the partner's, the bottom 'Received' header shows the email originated from an IP address in a completely different country, and the `Authentication-Results` header shows `spf=hardfail`. This is definitive proof that the email was spoofed. The analyst now has the attacker's true source IP, which they can use to block further attacks and continue their investigation.</p><h3>VoIP Protocols:</h3><ul><li><strong>SIP (Session Initiation Protocol):</strong> Used to set up, modify, and terminate calls. SIP traffic can reveal the caller and callee's IP addresses and phone numbers.</li><li><strong>RTP (Real-time Transport Protocol):</strong> Carries the actual audio/video payload. An analyst can use Wireshark to reconstruct and even play back unencrypted VoIP calls from a packet capture.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1534643958318-9d41b5311e5f?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Email Flow Reconstruction Tool (Python)",
                            "language": "python",
                            "code": "import re\n\n# This conceptual script parses raw email text to trace its path.\ndef trace_email_path(raw_email_text):\n    \"\"\"Parses 'Received' headers to show the email's path.\"\"\"\n    \n    # Find all 'Received' headers\n    received_headers = re.findall(r\"^Received: .+\", raw_email_text, re.MULTILINE)\n    \n    print(\"--- Email Path (Origin to Destination) ---\")\n    # Reverse the list to show the path in chronological order\n    for i, header in enumerate(reversed(received_headers)):\n        # Try to extract the 'from' part of the header\n        source = re.search(r\"from ([\\w\\.\\-]+)\", header)\n        if source:\n            print(f\"Hop {i+1}: {source.group(1)}\")\n\n# You would pass the full raw source of an email to this function.\n# For example, from an exported .eml file or a reconstructed TCP stream."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "Which protocol is used to send email between mail servers?",
                            "options": [
                                "POP3",
                                "IMAP",
                                "SMTP",
                                "HTTP"
                            ],
                            "correct": 2,
                            "explanation": "SMTP (Simple Mail Transfer Protocol) is the fundamental protocol for sending email across the internet. POP3 and IMAP are used by clients to retrieve email from a server."
                        },
                        {
                            "id": 2,
                            "question": "To trace the path an email took across the internet, an analyst must read the 'Received' headers in which order?",
                            "options": [
                                "From top to bottom.",
                                "From bottom to top.",
                                "In alphabetical order.",
                                "The order does not matter."
                            ],
                            "correct": 1,
                            "explanation": "Each mail server adds its 'Received' header to the top of the list. Therefore, to trace the path from the origin, you must start with the header at the very bottom of the email source."
                        },
                        {
                            "id": 3,
                            "question": "An `Authentication-Results` header that shows `spf=hardfail` is a strong indicator of what?",
                            "options": [
                                "The email content is encrypted.",
                                "The email has a virus attached.",
                                "The email was successfully delivered.",
                                "The sender's address was likely spoofed."
                            ],
                            "correct": 3,
                            "explanation": "SPF (Sender Policy Framework) is a system that allows a domain owner to specify which mail servers are allowed to send email for their domain. An `spf=hardfail` means the email came from a server that was not on that authorized list, which is a classic sign of spoofing."
                        }
                    ]
                }
            },
            {
                "id": "lesson-6",
                "title": "Web Traffic and HTTP/HTTPS Analysis",
                "duration": "120 min",
                "objectives": [
                    "Analyze the structure of HTTP requests and responses.",
                    "Understand the challenges of HTTPS and the role of SSL/TLS inspection.",
                    "Reconstruct web sessions from packet captures.",
                    "Detect common web application attacks like SQL injection and XSS from traffic.",
                    "Analyze cookies and session management artifacts.",
                    "Track file uploads and downloads over HTTP."
                ],
                "content": {
                    "overview": "Web traffic makes up the vast majority of data on the internet and is a primary channel for both legitimate business and malicious activity. This lesson covers the forensic analysis of web protocols, focusing on how to reconstruct user activity, detect attacks, and investigate data exfiltration hidden within HTTP and HTTPS traffic.",
                    "sections": [
                        {
                            "title": "HTTP Request and Response Analysis",
                            "content": "<p>The Hypertext Transfer Protocol (HTTP) is the foundation of the web. It is a simple, text-based request-response protocol.</p><h3>Key Components of an HTTP Request:</h3><ul><li><strong>Request Line:</strong> Contains the method (e.g., GET, POST), the URI (`/index.html`), and the HTTP version.</li><li><strong>Headers:</strong> Provide metadata about the request, such as the `Host`, the `User-Agent` (the browser making the request), and `Referer` (the page that linked to this one).</li></ul><h3>Key Components of an HTTP Response:</h3><ul><li><strong>Status Line:</strong> Contains the status code (e.g., `200 OK`, `404 Not Found`, `302 Redirect`).</li><li><strong>Headers:</strong> Provide metadata about the response, like `Content-Type`.</li><li><strong>Body:</strong> The actual content of the page (e.g., the HTML code).</li></ul>",
                            "image": "https://images.unsplash.com/photo-1555949963-ff9fe0c870eb?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "The Challenge of HTTPS and SSL/TLS Inspection",
                            "content": "<p>The vast majority of web traffic today is encrypted with HTTPS. From a privacy perspective, this is excellent. From a forensic perspective, it creates a massive blind spot, as the entire HTTP conversation is hidden within an encrypted TLS tunnel.</p><p><strong>SSL/TLS Inspection (Decryption):</strong> To analyze this traffic, organizations must use a 'man-in-the-middle' device, typically a web proxy or next-generation firewall. This device decrypts the traffic for inspection, analyzes it for threats, and then re-encrypts it before sending it to the user. Without this capability, it is impossible to detect threats hidden within encrypted traffic.</p>",
                            "image": "https://images.unsplash.com/photo-1548092372-2d987bde898b?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Detecting Web Attacks in Traffic",
                            "content": "<p>Network traffic provides clear evidence of common web application attacks.</p><p><strong>Real-time Problem: Investigating web-based data exfiltration.</strong> An analyst is reviewing a packet capture of traffic from a web server that was compromised. The attacker used a SQL injection vulnerability to steal data. The analyst filters the traffic for all POST requests to the login page. They find one request where, instead of a normal password, the `password` field contains a long SQL query: `password' OR 1=1; SELECT credit_card_number FROM customers--`. The analyst can see the malicious command in the request. They then follow the TCP stream and see that the server's response was not a login failure, but a massive HTML page containing thousands of credit card numbers. The packet capture provides definitive proof of both the vulnerability exploited and the exact data that was stolen.</p>",
                            "image": "https://images.unsplash.com/photo-1504384308090-c894fdcc538d?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Web Session Reconstruction Framework (tshark)",
                            "language": "bash",
                            "code": "# This script uses tshark (the command-line version of Wireshark) to reconstruct\n# and analyze HTTP traffic from a pcap file.\n\nPCAP_FILE=\"web_traffic.pcap\"\n\n# 1. List all unique hosts the client communicated with.\n# -T fields specifies we want to extract specific fields.\n# -e http.host extracts the Host header.\nsudo tshark -r $PCAP_FILE -T fields -e http.host | sort -u\n\n# 2. Reconstruct all HTTP GET requests and their responses.\n# -Y specifies a display filter.\n# -x tells tshark to print the full packet data in hex and ASCII.\nsudo tshark -r $PCAP_FILE -Y \"http.request.method == GET\"\n\n# 3. Extract all downloaded JPEG files from the traffic.\n# Wireshark's 'Export Objects' feature is best for this, but can be scripted with tshark.\n# This advanced command finds HTTP responses with a content type of image/jpeg and exports the body.\nsudo tshark -r $PCAP_FILE -Y \"http.content_type == 'image/jpeg'\" -T fields -e http.file_data | \\\n  xxd -r -p > extracted_image.jpg"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "In an HTTP request, which header identifies the client's browser (e.g., Chrome, Firefox)?",
                            "options": [
                                "Host",
                                "Referer",
                                "User-Agent",
                                "Cookie"
                            ],
                            "correct": 2,
                            "explanation": "The User-Agent string is a header sent by the browser to identify itself and its version to the web server. It can be used to track different types of clients or to spot unusual/malicious tools."
                        },
                        {
                            "id": 2,
                            "question": "What is the primary challenge that HTTPS poses for network forensic analysis?",
                            "options": [
                                "It is slower than HTTP.",
                                "It uses too much bandwidth.",
                                "It encrypts the HTTP traffic, making it unreadable to passive monitoring tools unless SSL/TLS inspection is used.",
                                "It only works on port 80."
                            ],
                            "correct": 2,
                            "explanation": "Encryption is the core challenge. Without a decryption mechanism (like a man-in-the-middle proxy), an analyst can see that a TLS connection happened, but they cannot see any of the actual HTTP requests or responses inside it."
                        },
                        {
                            "id": 3,
                            "question": "An analyst sees the string `' OR 1=1--` in the data of a POST request to a login page. This is a strong indicator of what kind of attack?",
                            "options": [
                                "A DDoS attack",
                                "A Cross-Site Scripting (XSS) attack",
                                "A SQL Injection attack",
                                "A phishing attack"
                            ],
                            "correct": 2,
                            "explanation": "This is a classic SQL injection payload. It is designed to be inserted into a SQL query on the server to bypass authentication logic and gain unauthorized access to the database."
                        }
                    ]
                }
            },
            {
                "id": "lesson-7",
                "title": "Wireless Network Forensics",
                "duration": "100 min",
                "objectives": [
                    "Analyze 802.11 wireless protocol frames (management, control, data).",
                    "Perform a forensic analysis of a wireless access point's configuration and logs.",
                    "Identify unauthorized or 'rogue' access points on a corporate network.",
                    "Investigate wireless intrusions and deauthentication attacks.",
                    "Understand the basics of Bluetooth and cellular network forensics.",
                    "Analyze traffic from IoT devices on a wireless network."
                ],
                "content": {
                    "overview": "Wireless networks introduce a new layer of complexity to forensic investigations. The evidence is not contained within a physical wire but is broadcast through the air. This lesson covers the specific tools and techniques used to capture and analyze wireless traffic, identify rogue devices, and investigate intrusions into Wi-Fi networks.",
                    "sections": [
                        {
                            "title": "802.11 Wireless Protocol Analysis",
                            "content": "<p>Wireless traffic is fundamentally different from wired traffic. In addition to data frames, there are management and control frames that manage the wireless connection itself.</p><h3>The Three Frame Types:</h3><ul><li><strong>Management Frames:</strong> Used to manage the wireless network. This includes Beacon frames (which advertise the network's existence), Probe requests/responses (when a device actively scans for networks), and Association/Authentication requests.</li><li><strong>Control Frames:</strong> Used to control access to the wireless medium (e.g., RTS/CTS - Request to Send/Clear to Send).</li><li><strong>Data Frames:</strong> Carry the actual user data (the IP packets).</li></ul><p>Analyzing management frames can reveal which devices are in the area, which networks they are trying to connect to, and the capabilities of the access points.</p>",
                            "image": "https://images.unsplash.com/photo-1600216893077-84803c48c184?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Rogue Access Point Detection",
                            "content": "<p>A rogue access point is an unauthorized AP connected to the corporate network. It can be malicious (an attacker planting a device) or unintentional (an employee setting up their own router for convenience).</p><p><strong>Real-world Problem: Investigating a wireless network breach.</strong> A company discovers that an attacker has been accessing their internal network. A wireless forensic analyst uses a tool like Kismet to scan the airspace. They discover a rogue access point broadcasting an unsecured network, which is physically plugged into a corporate network jack in a conference room. The analyst examines the logs from the network switch and sees the MAC address of the rogue AP. They then correlate this with DHCP logs to see what internal IP address it was assigned. By analyzing a packet capture of the wireless traffic, they can see the attacker's device connecting to the rogue AP and accessing internal servers, providing a clear picture of the entire intrusion.</p>",
                            "image": "https://images.unsplash.com/photo-1525412847248-e9f0936181f8?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Wireless Attacks and Investigation",
                            "content": "<p>Wireless networks are susceptible to unique attacks that can be detected through traffic analysis.</p><h3>Common Wireless Attacks:</h3><ul><li><strong>Evil Twin Attack:</strong> An attacker sets up a rogue AP with the same name (SSID) as the legitimate corporate network. Unsuspecting users connect to the evil twin, allowing the attacker to intercept all their traffic.</li><li><strong>Deauthentication Attack:</strong> An attacker sends a flood of spoofed deauthentication management frames to a user's device, forcing them to disconnect from the legitimate network. This is often the first step in an evil twin attack, designed to get the user to reconnect to the attacker's network. An analyst can spot this in a packet capture by seeing an abnormally large number of deauthentication frames.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1533139143976-3d235835932c?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Wireless Traffic Analyzer (Airodump-ng)",
                            "language": "bash",
                            "code": "# This command uses airodump-ng (part of the Aircrack-ng suite) to perform\n# a passive scan of the 802.11 wireless landscape.\n# This requires a wireless card that supports monitor mode.\n\n# First, put the wireless card into monitor mode.\n# (Assuming the card is wlan0)\nsudo ip link set wlan0 down\nsudo iw wlan0 set monitor control\nsudo ip link set wlan0 up\n\n# Now, run airodump-ng to see all nearby access points and clients.\nairodump-ng wlan0\n\n# --- Sample Output ---\n# BSSID              PWR  Beacons    #Data, #/s  CH  MB   ENC  CIPHER AUTH ESSID\n# ----------------------------------------------------------------------------------\n# 00:1A:2B:3C:4D:5E  -50       10       20    0   6  54   WPA2 CCMP   PSK  Corporate-WiFi\n# 00:AA:BB:CC:DD:EE  -65        8        5    0  11  54   WPA2 CCMP   PSK  Guest-WiFi\n#\n# BSSID              STATION          PWR   Rate    Lost    Frames  Probe\n# ----------------------------------------------------------------------------------\n# 00:1A:2B:3C:4D:5E  F0:1F:2E:3D:4C:5B  -55    0 - 1e   0       15\n\n# An analyst uses this output to get a baseline of all legitimate APs (BSSIDs)\n# and to spot any unauthorized devices or clients trying to connect."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "Which type of 802.11 frame is used by an access point to advertise its existence and network name (SSID)?",
                            "options": [
                                "Data Frame",
                                "Control Frame",
                                "Management Frame (specifically, a Beacon frame)",
                                "ACK Frame"
                            ],
                            "correct": 2,
                            "explanation": "Beacon frames are a type of management frame that are constantly broadcast by an access point so that client devices can discover the network."
                        },
                        {
                            "id": 2,
                            "question": "An attacker sets up a malicious access point with the same name as the legitimate corporate Wi-Fi. This is known as what kind of attack?",
                            "options": [
                                "A deauthentication attack",
                                "A DDoS attack",
                                "An Evil Twin attack",
                                "A SQL injection attack"
                            ],
                            "correct": 2,
                            "explanation": "An Evil Twin attack is a classic wireless man-in-the-middle attack. It tricks users into connecting to the attacker's AP, allowing the attacker to intercept and monitor all of their network traffic."
                        },
                        {
                            "id": 3,
                            "question": "An analyst sees a massive number of deauthentication frames in a wireless packet capture, all directed at a specific user. This is a strong indicator of what?",
                            "options": [
                                "Normal network activity.",
                                "An attacker is attempting to force the user off the legitimate network, likely as a prelude to an evil twin attack.",
                                "The user has forgotten their Wi-Fi password.",
                                "The access point is rebooting."
                            ],
                            "correct": 1,
                            "explanation": "A flood of deauthentication frames is not normal. It is a specific attack designed to disrupt a user's connection and is a key indicator of malicious activity on a wireless network."
                        }
                    ]
                }
            },
            {
                "id": "lesson-8",
                "title": "Network-Based Malware Analysis",
                "duration": "120 min",
                "objectives": [
                    "Identify malware command and control (C2) traffic.",
                    "Analyze the network communications of a botnet.",
                    "Understand how malware uses the network to propagate.",
                    "Deconstruct Domain Generation Algorithms (DGAs).",
                    "Detect the use of fast flux networks.",
                    "Analyze malware's encrypted communication channels.",
                    "Extract and use network-based Indicators of Compromise (IoCs)."
                ],
                "content": {
                    "overview": "Malware cannot operate in a vacuum; it must use the network to receive commands, exfiltrate data, and spread to new systems. This lesson focuses on the network-level analysis of malware, teaching you how to identify the characteristic traffic patterns of botnets, command and control channels, and other malicious software.",
                    "sections": [
                        {
                            "title": "Command and Control (C2) Detection",
                            "content": "<p>After a machine is infected, the malware needs to 'call home' to an attacker-controlled server to receive instructions. This communication channel is called Command and Control (C2 or C&C).</p><h3>Identifying C2 Traffic:</h3><ul><li><strong>Beaconing:</strong> The most common characteristic. The malware will send out a small packet (a 'beacon') to the C2 server at a highly regular interval (e.g., exactly every 5 minutes). This machine-like regularity is a strong anomaly compared to normal, bursty human traffic.</li><li><strong>Unusual Protocols/Ports:</strong> C2 traffic might use a non-standard port or protocol.</li><li><strong>Suspicious Domains:</strong> Connections to newly registered domains, domains with long, random-looking names, or domains with a bad reputation are all red flags.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1548092372-2d987bde898b?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Domain Generation Algorithms (DGA) and Fast Flux",
                            "content": "<p>Malware authors use advanced techniques to make their C2 infrastructure resilient to takedowns.</p><ul><li><strong>DGA:</strong> Instead of hardcoding a single C2 domain into the malware, the malware contains an algorithm that generates thousands of new, pseudo-random domains every day. The attacker only needs to register *one* of these domains for the malware to be able to phone home. This makes it impossible for defenders to simply block a static list of C2 domains.</li><li><strong>Fast Flux:</strong> The DNS records for a single malicious domain are changed extremely rapidly (sometimes every few minutes), pointing to a large, rotating list of compromised hosts that act as proxies. This makes it very difficult to identify and block the true C2 server.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Analyzing Encrypted C2 Traffic",
                            "content": "<p>Most modern malware encrypts its C2 traffic, usually with TLS (HTTPS). While this hides the *content* of the commands, it does not hide the metadata, which can still be used for detection.</p><p><strong>Real-time Problem: Dismantling a sophisticated botnet.</strong> An analyst identifies a beacon to a suspicious domain, but the traffic is encrypted. They cannot see the commands. However, they can still analyze the TLS handshake. They notice that the malware is using a self-signed TLS certificate with a specific, unusual 'issuer' string. The analyst now has a high-fidelity network-based indicator. They can write an IDS signature to search for that specific issuer string in all TLS handshakes across the enterprise. This signature immediately finds 500 other infected hosts that are part of the same botnet, even though the C2 domain and IP addresses are all different.</p>",
                            "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Botnet Traffic Detection System (Zeek/Bro)",
                            "language": "clojure",
                            "code": "# This Zeek script analyzes DNS traffic to detect potential DGAs.\n# It flags domains with an unusually high character randomness (entropy).\n\n@load policy/frameworks/intel/seen\n@load policy/tuning/json-logs.zeek\n\nmodule DGA;\n\nexport {\n    const entropy_threshold = 3.5 &redef;\n}\n\nfunction calculate_entropy(s: string): double {\n    local counts: table[string] of count;\n    for ( i in 1..|s| ) {\n        local char = s[i-1:i];\n        if ( char in counts ) counts[char] += 1; else counts[char] = 1;\n    }\n    local entropy = 0.0;\n    for ( c in counts ) {\n        local p = counts[c] / |s|;\n        entropy -= p * log2(p);\n    }\n    return entropy;\n}\n\nevent dns_request(c: connection, msg: dns_msg, query: string, qtype: count, qclass: count) {\n    local domain = to_lower(query);\n    # Exclude common TLDs\n    if ( domain !~ /.*\\.(com|net|org)$/ ) {\n        local entropy = calculate_entropy(domain);\n        if ( entropy > entropy_threshold ) {\n            print fmt(\"[!] High Entropy Domain Detected (Potential DGA): %s (Entropy: %.2f)\", domain, entropy);\n        }\n    }\n}"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the most common characteristic of malware C2 beaconing?",
                            "options": [
                                "The traffic is always unencrypted.",
                                "The connections are very large in size.",
                                "The connections occur at a highly regular, machine-like interval.",
                                "The connections only happen once a month."
                            ],
                            "correct": 2,
                            "explanation": "The periodic, metronomic nature of C2 beacons is their most distinguishing feature. This regularity stands out against the bursty, irregular patterns of normal human-generated traffic."
                        },
                        {
                            "id": 2,
                            "question": "A malware technique that generates thousands of new, pseudo-random domain names each day to find its C2 server is known as:",
                            "options": [
                                "Fast Flux",
                                "A Domain Generation Algorithm (DGA)",
                                "DNS Tunneling",
                                "A DDoS Attack"
                            ],
                            "correct": 1,
                            "explanation": "DGA is a resiliency technique. By generating a huge number of potential domains, the malware ensures it can find its C2 server even if defenders are constantly blocking the previously used domains."
                        },
                        {
                            "id": 3,
                            "question": "Even if malware C2 traffic is encrypted with HTTPS, what can an analyst still use to potentially identify it?",
                            "options": [
                                "The content of the commands being sent.",
                                "The password used for the encryption.",
                                "The metadata of the connection, such as the beaconing interval and unique characteristics of the TLS handshake certificate.",
                                "Nothing; encrypted traffic is impossible to analyze."
                            ],
                            "correct": 2,
                            "explanation": "Metadata analysis is key for encrypted traffic. While you can't see the content, you can see the connection patterns (beaconing) and details of the encryption itself (like the TLS certificate), which can serve as a unique fingerprint for the malware."
                        }
                    ]
                }
            },
            {
                "id": "lesson-9",
                "title": "Data Exfiltration and Information Theft Investigation",
                "duration": "100 min",
                "objectives": [
                    "Identify common data exfiltration techniques from network traffic.",
                    "Analyze covert channels used to hide stolen data.",
                    "Detect DNS tunneling as an exfiltration method.",
                    "Investigate data theft via cloud storage and email.",
                    "Analyze FTP and other file transfer protocols for signs of theft.",
                    "Correlate network evidence with host-based artifacts to prove information theft."
                ],
                "content": {
                    "overview": "Data exfiltration is the unauthorized transfer of data from a network. It is the final and most critical stage of many intrusions. This lesson focuses on the network forensic techniques used to detect and analyze data theft, from overt, large-scale transfers to stealthy, covert channels designed to evade detection.",
                    "sections": [
                        {
                            "title": "Overt vs. Covert Exfiltration",
                            "content": "<p>Data exfiltration can be loud and obvious, or slow and stealthy.</p><h3>Exfiltration Methods:</h3><ul><li><strong>Overt (Smash and Grab):</strong> The attacker compresses a large amount of data into a single ZIP file and uploads it to an external server via FTP or a cloud storage provider. This creates a massive, anomalous spike in outbound traffic that is relatively easy to detect.</li><li><strong>Covert (Low and Slow):</strong> The attacker breaks the stolen data into tiny chunks and sends it out over a long period of time, hidden within other protocols. This is designed to blend in with normal traffic and evade detection thresholds.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1543286386-713bdd548da4?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Covert Channels: Hiding in Plain Sight",
                            "content": "<p>A covert channel is a method of transferring data that violates security policy by using a protocol in an unintended way.</p><h3>Common Covert Channels:</h3><ul><li><strong>ICMP Tunneling:</strong> Hiding data within the payload of ICMP (Ping) packets. Since most firewalls allow Ping, this can be an effective way to bypass security controls.</li><li><strong>DNS Tunneling:</strong> This is a very common and powerful technique. The attacker encodes the stolen data into a series of long, pseudo-random subdomains and then makes DNS queries for them (e.g., `[encoded_data_chunk].attacker.com`). The attacker's malicious DNS server receives these queries, extracts the encoded data, and reconstructs the stolen file. To a firewall, it just looks like a lot of normal DNS traffic.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Detecting Data Exfiltration",
                            "content": "<p>Detection relies on baselining normal traffic and looking for anomalies.</p><p><strong>Real-time Problem: Tracking massive intellectual property theft.</strong> A company's network behavior analysis (NBA) tool sends an alert. It has detected that a server in the engineering department, which normally sends about 50MB of data outbound per day, has sent over 500GB of outbound traffic in the last hour to an IP address in a foreign country. This massive deviation from the baseline is a high-confidence indicator of data exfiltration. The network forensics team can then pull the full packet capture for that specific conversation to determine exactly which files were stolen.</p><h3>Key Detection Strategies:</h3><ul><li><strong>Volume-based Analysis:</strong> Look for unusually large outbound data transfers from hosts that do not normally send that much data.</li><li><strong>DNS Analysis:</strong> Look for an unusually high number of DNS requests from a single host, or requests for very long and random-looking domain names (an indicator of DNS tunneling).</li><li><strong>Protocol Analysis:</strong> Look for protocols being used on non-standard ports.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Data Exfiltration Detection Engine (Zeek)",
                            "language": "clojure",
                            "code": "# This Zeek script detects a common sign of DNS tunneling:\n# unusually long hostnames in DNS queries.\n\n@load policy/tuning/json-logs.zeek\n\nmodule DNSTunnel;\n\nexport {\n    const max_hostname_len = 100 &redef;\n}\n\nevent dns_request(c: connection, msg: dns_msg, query: string, qtype: count, qclass: count) {\n    if ( |query| > max_hostname_len ) {\n        print fmt(\"[!] Potential DNS Tunneling Detected from %s:\", c$id$orig_h);\n        print fmt(\"    Query with abnormal length (%d): %s\", |query|, query);\n        \n        # In a real system, this would generate a formal alert.\n    }\n}"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "The technique of hiding stolen data inside the traffic of another protocol, like DNS or ICMP, is known as a:",
                            "options": [
                                "DDoS attack",
                                "Covert channel",
                                "SQL injection",
                                "Session hijack"
                            ],
                            "correct": 1,
                            "explanation": "A covert channel is the use of a protocol in an unintended way to bypass security controls. DNS tunneling is a classic example of a covert channel used for data exfiltration."
                        },
                        {
                            "id": 2,
                            "question": "An analyst sees a massive number of DNS queries from a single host to a specific domain, and the subdomains in the queries appear to be long, random, encoded strings. This is a strong indicator of what?",
                            "options": [
                                "Normal web browsing.",
                                "The user is playing an online game.",
                                "DNS Tunneling being used for data exfiltration or C2.",
                                "The DNS server is misconfigured."
                            ],
                            "correct": 2,
                            "explanation": "This is the classic signature of DNS tunneling. The attacker is encoding the stolen data into the subdomains of their DNS queries, using the DNS protocol itself as the exfiltration channel."
                        },
                        {
                            "id": 3,
                            "question": "What is the most effective way to detect a large-scale, 'smash and grab' data exfiltration event?",
                            "options": [
                                "Analyzing email headers.",
                                "Monitoring for massive, anomalous spikes in outbound traffic volume from internal hosts.",
                                "Checking the system's ARP cache.",
                                "Looking for failed login attempts."
                            ],
                            "correct": 1,
                            "explanation": "Volume-based detection is the key to catching large exfiltration events. By establishing a baseline of normal outbound traffic, a Network Behavior Analysis (NBA) tool can easily spot a host that suddenly starts sending 1000x its normal amount of data."
                        }
                    ]
                }
            },
            {
                "id": "lesson-10",
                "title": "Network Intrusion Investigation",
                "duration": "120 min",
                "objectives": [
                    "Synthesize network evidence to identify an attacker's initial attack vector.",
                    "Trace an attacker's lateral movement across the network.",
                    "Detect privilege escalation attempts from network traffic.",
                    "Reconstruct a multi-stage attack from beginning to end.",
                    "Develop a complete attack timeline using network evidence.",
                    "Use network artifacts for preliminary attribution and actor profiling."
                ],
                "content": {
                    "overview": "This capstone lesson brings everything together. We will move beyond analyzing individual artifacts and learn to synthesize multiple pieces of network evidence to reconstruct a complete, end-to-end network intrusion. We will follow an attacker's trail from their initial reconnaissance to their final objective, creating a comprehensive timeline of the entire attack.",
                    "sections": [
                        {
                            "title": "Reconstructing the Attack Vector",
                            "content": "<p>The first step in any intrusion investigation is to figure out how the attacker got in. Network evidence is often the key.</p><h3>Common Initial Vectors and Their Network Evidence:</h3><ul><li><strong>Phishing Email:</strong> Analysis of SMTP logs and email headers.</li><li><strong>Web Vulnerability (e.g., SQL Injection):</strong> Analysis of WAF logs and web server access logs.</li><li><strong>Exposed RDP Server:</strong> Analysis of firewall logs and Windows security event logs for successful remote logins (Event ID 4624).</li><li><strong>Watering Hole Attack:</strong> Analysis of web proxy logs to see which user visited the compromised site.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Tracing Lateral Movement",
                            "content": "<p>Once an attacker gets a foothold on one machine, their next step is almost always 'lateral movement'—moving from that initial machine to other, more valuable systems on the internal network.</p><p><strong>Real-world Problem: Investigating a sophisticated network breach.</strong> An IDS alert fires for C2 traffic from a workstation, `WS-123`. The investigation begins. The analyst examines firewall and authentication logs. They see that two hours earlier, the user of `WS-123` received a phishing email. One hour ago, `WS-123` connected to an internal file server, `FS-01`, using the SMB protocol. Five minutes later, `FS-01` connected to the Domain Controller using Remote Desktop (RDP). Finally, the Domain Controller made an outbound connection to a known malicious C2 domain. By correlating these different log sources, the analyst has reconstructed the entire attack path: Phishing -> Workstation Compromise -> Lateral Movement to File Server -> Credential Theft -> Lateral Movement to Domain Controller -> Data Exfiltration/C2.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Building the Master Timeline",
                            "content": "<p>The ultimate goal of the investigation is to create a single, unified timeline of the attacker's actions. This involves fusing evidence from every available source.</p><h3>The Correlation Process:</h3><p>The analyst takes the timestamps from firewall logs, DNS logs, proxy logs, packet captures, and correlates them with host-based artifacts like security event logs and memory forensics findings. The result is a detailed, second-by-second narrative of the entire intrusion. This timeline becomes the foundation of the final incident report and is the primary piece of evidence used to explain the attack to management, lawyers, and law enforcement.</p>",
                            "image": "https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Attack Path Reconstruction Tool (Splunk)",
                            "language": "sql",
                            "code": "/* This conceptual Splunk query reconstructs a lateral movement path.\n   It starts with a known compromised host and finds where it connected next.\n*/\n\n// 1. Start with the known Indicator of Compromise (IoC).\nindex=firewall sourcetype=paloalto src_ip=10.1.1.123 \n\n// 2. Look for all allowed connections from this host to other internal IPs.\n| search action=allow dest_ip=10.0.0.0/8 \n\n// 3. Create a transaction of activity, grouping events by user.\n| transaction user maxspan=1h\n\n// 4. Correlate this with Windows authentication logs from the destination IPs.\n| map search=\"search index=wineventlog EventCode=4624 user=$user$ dest_ip=$dest_ip$\"\n\n// 5. Display the results as a timeline.\n| table _time, user, src_ip, dest_ip, app"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "The process of an attacker moving from an initially compromised machine to other systems within the same network is known as:",
                            "options": [
                                "Data exfiltration",
                                "Lateral movement",
                                "Reconnaissance",
                                "Persistence"
                            ],
                            "correct": 1,
                            "explanation": "Lateral movement is the term for an attacker's internal network traversal. Tracking this movement is a key goal of an intrusion investigation."
                        },
                        {
                            "id": 2,
                            "question": "An analyst is investigating a breach and finds evidence of a successful remote login (Event ID 4624) on a server that came from another internal workstation. Which log source is essential for tracking this activity?",
                            "options": [
                                "The web server access log.",
                                "The DNS server log.",
                                "The Windows Security Event Log on the Domain Controller.",
                                "The user's local browser history."
                            ],
                            "correct": 2,
                            "explanation": "The Domain Controller's security event log is the central repository for all authentication events on a Windows network. It is the definitive source for tracking both successful and failed logins and is crucial for tracing lateral movement."
                        },
                        {
                            "id": 3,
                            "question": "What is the ultimate goal of synthesizing evidence from multiple network and host sources in an intrusion investigation?",
                            "options": [
                                "To create the longest report possible.",
                                "To find someone to blame for the incident.",
                                "To create a single, unified, and defensible timeline that tells the complete story of the attack.",
                                "To test the performance of the SIEM."
                            ],
                            "correct": 2,
                            "explanation": "The timeline is the narrative of the investigation. By fusing data from independent sources (firewall, PCAP, host logs, memory), an analyst can build a powerful, correlated story that is much more credible and difficult to refute than any single piece of evidence."
                        }
                    ]
                }
            },
            {
                "id": "lesson-11",
                "title": "Network Forensics in Cloud and Virtual Environments",
                "duration": "100 min",
                "objectives": [
                    "Understand the architecture of cloud networks (e.g., VPCs, VNETs).",
                    "Analyze virtual network traffic and flow logs.",
                    "Investigate the network traffic of containers and microservices.",
                    "Integrate and analyze logs from cloud providers (e.g., AWS CloudTrail).",
                    "Address the forensic challenges of Software-Defined Networking (SDN).",
                    "Investigate incidents in multi-cloud and hybrid environments."
                ],
                "content": {
                    "overview": "As infrastructure moves to the cloud, network forensics must adapt from analyzing physical wires to analyzing virtual constructs and API calls. This lesson covers the specific challenges and techniques for performing network forensics in cloud and virtualized environments, focusing on the logs and tools provided by major cloud platforms.",
                    "sections": [
                        {
                            "title": "Cloud Network Architecture Forensics",
                            "content": "<p>In the cloud, the network is software. Instead of physical routers and switches, you have virtual constructs.</p><h3>Key Cloud Network Constructs:</h3><ul><li><strong>VPC (Virtual Private Cloud) / VNet (Virtual Network):</strong> A logically isolated section of the public cloud where you can launch your resources.</li><li><strong>Security Groups / Network Security Groups (NSGs):</strong> Act as the virtual firewall for your instances, controlling inbound and outbound traffic.</li><li><strong>Flow Logs:</strong> The cloud equivalent of NetFlow. VPC Flow Logs capture metadata about all the IP traffic going to and from network interfaces in your VPC. This is a primary source of evidence.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1588196749597-9ff075ee6b5b?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "The Shift from Packets to Logs",
                            "content": "<p>While it is possible to perform full packet capture in the cloud (using traffic mirroring), it is often complex and expensive. The vast majority of cloud network forensics relies on analyzing the rich log sources provided by the cloud providers.</p><p><strong>Real-time Problem: Investigating a multi-cloud security incident.</strong> An attacker compromises a user's credentials. They use these credentials to access a VM in AWS and then pivot from that VM to attack a server in an Azure environment. The analyst cannot put a single tap in place to see this traffic. Instead, the investigation relies on correlating logs from two different providers. The analyst would examine AWS CloudTrail logs to see the initial suspicious API calls, then analyze VPC Flow Logs to see the connection from the AWS VM to the Azure server's public IP. They would then pivot to Azure's NSG Flow Logs and Activity Logs to see the connection arriving and the subsequent malicious activity. The investigation is an exercise in log correlation across different platforms.</p>",
                            "image": "https://images.unsplash.com/photo-1543286386-713bdd548da4?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Container and Microservices Networking",
                            "content": "<p>In a containerized environment like Kubernetes, applications are broken into many small, independent microservices that communicate over a complex virtual network 'overlay'.</p><h3>Forensic Challenges:</h3><ul><li><strong>East-West Traffic:</strong> Most of the communication is between containers within the same cluster ('east-west' traffic), which may not be monitored by traditional network security tools that focus on the perimeter ('north-south' traffic).</li><li><strong>Ephemeral IPs:</strong> Containers are created and destroyed rapidly, and their internal IP addresses are constantly changing.</li></ul><p>Investigation requires specialized tools that can inspect this inter-container traffic and relies heavily on the detailed API and network logs provided by the container orchestration platform.</p>",
                            "image": "https://images.unsplash.com/photo-1544197150-b99a580bb7a8?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Cloud Network Monitoring System (AWS Athena)",
                            "language": "sql",
                            "code": "/* This is an Amazon Athena query to analyze VPC Flow Logs stored in an S3 bucket.\n   It looks for SSH connections from IP addresses outside of a known, approved list.\n*/\n\nSELECT\n    \"start\",\n    \"srcaddr\",\n    \"dstaddr\"\nFROM \"vpc_flow_logs\"\nWHERE \n    -- Look for traffic on the SSH port\n    \"dstport\" = 22\n    AND\n    -- Look for traffic that was accepted\n    \"action\" = 'ACCEPT'\n    AND\n    -- Filter out connections from our known corporate and VPN IP ranges\n    \"srcaddr\" NOT IN ('203.0.113.0/24', '198.51.100.0/24')\nORDER BY \"start\" DESC\nLIMIT 100;"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the cloud equivalent of NetFlow, providing metadata about IP traffic in an AWS environment?",
                            "options": [
                                "CloudTrail",
                                "Security Groups",
                                "VPC Flow Logs",
                                "EC2 Instances"
                            ],
                            "correct": 2,
                            "explanation": "VPC Flow Logs are the primary tool for capturing metadata about network conversations in an AWS VPC. They are essential for network forensics and incident response in the cloud."
                        },
                        {
                            "id": 2,
                            "question": "In a cloud environment, forensic investigations rely more heavily on what compared to traditional on-premises investigations?",
                            "options": [
                                "Physical hardware taps.",
                                "Analyzing logs provided by the cloud service provider (e.g., API call logs, flow logs).",
                                "Seizing physical servers from the data center.",
                                "Analyzing the BIOS of the hypervisor."
                            ],
                            "correct": 1,
                            "explanation": "Because analysts have no access to the physical infrastructure, cloud forensics is almost entirely a log-based discipline. The richness and completeness of the logs provided by the CSP are therefore critical."
                        },
                        {
                            "id": 3,
                            "question": "What is a major forensic challenge in a containerized (e.g., Kubernetes) environment?",
                            "options": [
                                "Containers do not use the network.",
                                "A large amount of traffic is 'east-west' (between containers) and may not be seen by traditional perimeter security tools, and container IPs are ephemeral.",
                                "Containers run too slowly to be attacked.",
                                "There are no logs in a container environment."
                            ],
                            "correct": 1,
                            "explanation": "The ephemeral and highly dynamic nature of container networking is the key challenge. Traditional tools focused on a stable perimeter can miss the rapid, internal communications between microservices."
                        }
                    ]
                }
            },
            {
                "id": "lesson-12",
                "title": "Industrial Control System (ICS) and SCADA Network Forensics",
                "duration": "100 min",
                "objectives": [
                    "Analyze industrial protocols like Modbus, DNP3, and EtherNet/IP.",
                    "Investigate network traffic in a SCADA environment.",
                    "Understand the forensic analysis of PLCs and HMIs.",
                    "Apply the Purdue Model for network segmentation to an investigation.",
                    "Address the critical intersection of cybersecurity and physical safety.",
                    "Investigate attacks on air-gapped networks."
                ],
                "content": {
                    "overview": "Network forensics in an Industrial Control System (ICS) or Operational Technology (OT) environment is a high-stakes discipline. The evidence not only tells the story of a cyberattack, but of a potential physical event. This lesson covers the unique protocols, architectures, and safety considerations for investigating networks that control critical infrastructure.",
                    "sections": [
                        {
                            "title": "Industrial Protocol Analysis",
                            "content": "<p>ICS networks use specialized, often legacy, protocols that are not typically seen on IT networks. These protocols were often designed for efficiency and reliability, not security.</p><h3>Common Industrial Protocols:</h3><ul><li><strong>Modbus:</strong> A simple, widely used protocol. It has no built-in security, so any command is considered authentic.</li><li><strong>DNP3:</strong> A more advanced protocol used in electric and water utilities.</li><li><strong>EtherNet/IP:</strong> An industrial Ethernet protocol used in manufacturing.</li></ul><p>An analyst must use tools like Wireshark with industrial protocol dissectors to understand these conversations and identify unauthorized or malicious commands being sent to controllers.</p>",
                            "image": "https://images.unsplash.com/photo-1619852184799-2c7e6853a7e5?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "The Purdue Model and Network Segmentation",
                            "content": "<p>The Purdue Model is the foundational architecture for ICS security. It creates strict layers of segmentation between the corporate IT network and the sensitive OT network.</p><p><strong>Forensic Implication:</strong> The point of connection between the IT and OT networks (often a 'DMZ') is the most critical area of focus in an investigation. An analyst will scrutinize the firewall and proxy logs at this boundary to understand how an attacker pivoted from the less-secure IT world into the critical OT environment. A violation of the Purdue model's strict access control rules is often the root cause of the incident.</p>",
                            "image": "https://images.unsplash.com/photo-1567093323631-45c110a88b57?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Safety as the Top Priority",
                            "content": "<p>Unlike in IT forensics, the primary goal of an OT investigation is not data confidentiality, but ensuring the safety and reliability of the physical process.</p><p><strong>Real-time Problem: Investigating a power grid cyber attack.</strong> An attacker gains access to the control network of an electric utility. They send a malicious command via the DNP3 protocol to a Programmable Logic Controller (PLC) that controls a circuit breaker at a substation, causing a power outage. The forensic investigation requires a team of both cybersecurity analysts and power engineers. The cyber analyst captures and decodes the malicious DNP3 packet to create a signature. The power engineer analyzes the command to understand its physical impact and determines the safest way to restore the system. The investigation is a true partnership between the cyber and physical domains.</p>",
                            "image": "https://images.unsplash.com/photo-1533723306924-a20accb1e428?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Industrial Protocol Analyzer (Snort IDS)",
                            "language": "c",
                            "code": "/* This is a Snort IDS rule to detect a specific, potentially malicious Modbus command.\n   Function code 5 (Write Single Coil) can be used to turn a physical process on or off.\n   This rule alerts if it sees this command coming from the IT network into the OT network.\n*/\n\nalert tcp $IT_NETWORK any -> $OT_NETWORK 502 (msg:\"ICS/SCADA: Modbus Write Single Coil from IT to OT\"; flow:to_server,established; content:\"|05|\"; offset:7; depth:1; reference:url,modbus.org/docs/PI_MBUS_300.pdf; classtype:attempted-admin; sid:1000002; rev:1;)"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the primary architectural model used for securing Industrial Control System networks by separating them from corporate IT networks?",
                            "options": [
                                "The OSI Model",
                                "The TCP/IP Model",
                                "The Purdue Model",
                                "The Zero Trust Model"
                            ],
                            "correct": 2,
                            "explanation": "The Purdue Model is the foundational concept for ICS security, providing a hierarchical model for network segmentation to protect the sensitive operational technology (OT) from the less-secure information technology (IT) environment."
                        },
                        {
                            "id": 2,
                            "question": "What is the absolute highest priority during a network forensic investigation in an OT environment like a power plant?",
                            "options": [
                                "Determining what data was stolen.",
                                "Ensuring the physical safety and stability of the industrial process.",
                                "Preserving a perfect chain of custody.",
                                "Identifying the attacker's IP address."
                            ],
                            "correct": 1,
                            "explanation": "In any OT/ICS incident, safety overrides all other concerns. The investigation must not take any action that could inadvertently create a dangerous physical situation."
                        },
                        {
                            "id": 3,
                            "question": "Modbus and DNP3 are examples of what?",
                            "options": [
                                "Types of firewall.",
                                "Common enterprise email clients.",
                                "Specialized industrial protocols used in ICS/SCADA environments.",
                                "Brands of programmable logic controllers (PLCs)."
                            ],
                            "correct": 2,
                            "explanation": "These are common, specialized protocols used for communication between control devices in industrial environments. Analyzing them requires specific knowledge and tools."
                        }
                    ]
                }
            },
            
        {
            "id": "lesson-13",
            "title": "Network Forensics Automation and Orchestration",
            "duration": "100 min",
            "objectives": [
                "Understand how to apply SOAR (Security Orchestration, Automation, and Response) to network forensics.",
                "Develop automated workflows for incident detection and evidence collection.",
                "Integrate threat intelligence feeds for automated alert enrichment.",
                "Trigger dynamic analysis (e.g., sandbox detonation) from network alerts.",
                "Automate the generation of incident reports from network evidence.",
                "Create and manage playbook-driven investigations."
            ],
            "content": {
                "overview": "Manual analysis of network traffic does not scale to the speed and volume of modern threats. This lesson explores how to apply automation and orchestration to the network forensics workflow. We will learn how to use SOAR platforms to connect disparate tools, automate repetitive tasks, and build playbooks that can respond to network-based threats at machine speed.",
                "sections": [
                    {
                        "title": "SOAR for Network Forensics",
                        "content": "<p>Security Orchestration, Automation, and Response (SOAR) platforms are a force multiplier for a network forensics team. They act as the connective tissue between different security tools.</p><h3>The SOAR Workflow:</h3><ol><li><strong>Detection:</strong> An alert fires from an IDS, firewall, or Zeek sensor.</li><li><strong>Enrichment:</strong> The SOAR platform automatically takes the indicators from the alert (e.g., an IP address) and queries other tools for context. It can check the IP against multiple threat intelligence feeds, look up the owner in WHOIS, and check internal asset databases.</li><li><strong>Orchestration & Response:</strong> Based on a playbook, the SOAR platform can take action. It can instruct the firewall to block the IP, tell an EDR agent to isolate the host, and create a ticket in the case management system with all the enriched data.</li></ol>",
                        "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Playbook-Driven Investigations",
                        "content": "<p>A playbook is a pre-defined, automated workflow for handling a specific type of alert. The goal is to automate the repetitive, manual steps an analyst would normally perform.</p><p><strong>Real-time Problem: Managing multiple simultaneous incidents.</strong> A SOC is flooded with hundreds of alerts. Without automation, analysts would be overwhelmed. With a SOAR platform, a playbook can perform the initial triage on all of them. It can automatically enrich the alerts and close the obvious false positives, allowing the human analysts to focus their limited time and attention on the small number of truly critical, verified alerts that require deep investigation.</p>",
                        "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Automated Evidence Collection",
                        "content": "<p>Automation can also be used to preserve highly volatile network evidence.</p><h3>Example Workflow: Dynamic Packet Capture</h3><p>An IDS detects a sophisticated, targeted attack against a critical server. A SOAR playbook can be triggered that:</p><ol><li>Immediately sends a command to a network sensor to start a full packet capture for all traffic to and from that specific server's IP address.</li><li>At the same time, sends a command to the EDR agent on the server to initiate a memory dump.</li><li>After 15 minutes, stops the packet capture.</li></ol><p>This automated workflow ensures that the most volatile and detailed evidence (PCAP and RAM) is captured at the peak of the incident, something that would be nearly impossible for a human analyst to do in time.</p>",
                        "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Comprehensive Automation Framework (SOAR Playbook)",
                        "language": "yaml",
                        "code": "# This is a conceptual SOAR playbook in YAML format for a suspicious file download.\n\nplaybook: Suspicious File Downloaded via HTTP\n\ntrigger:\n  source: IDS Alert\n  signature: \"ETPRO MALWARE Possible EXE Download Over HTTP\"\n\nsteps:\n  - name: Extract Indicators\n    inputs: [alert.source_ip, alert.dest_ip, alert.http.hostname, alert.http.url, alert.file.sha256]\n\n  - name: Enrich Indicators (Parallel)\n    actions:\n      - name: Enrich_IP\n        tool: VirusTotal\n        action: lookup_ip\n        input: alert.dest_ip\n      - name: Enrich_Domain\n        tool: ThreatConnect\n        action: lookup_domain\n        input: alert.http.hostname\n      - name: Enrich_Hash\n        tool: Sandbox\n        action: detonate_hash\n        input: alert.file.sha256\n\n  - name: Decision - Is Malicious?\n    # Condition checks if any enrichment source found a malicious verdict.\n    condition: \"{{Enrich_IP.verdict == 'malicious' or Enrich_Domain.rating > 3 or Enrich_Hash.score > 80}}\"\n    if_true: Execute_Block\n    if_false: Close_False_Positive\n\n  - name: Execute_Block\n    actions:\n      - tool: PaloAltoFirewall\n        action: block_ip\n        input: alert.dest_ip\n      - tool: EDR\n        action: isolate_host\n        input: alert.source_ip\n      - tool: Jira\n        action: create_critical_ticket\n        assignee: \"Tier 2 SOC\""
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary function of a SOAR platform in network forensics?",
                        "options": [
                            "To capture packets from a network tap.",
                            "To act as a firewall.",
                            "To integrate disparate security tools and automate response workflows (playbooks).",
                            "To store long-term packet captures."
                        ],
                        "correct": 2,
                        "explanation": "SOAR stands for Security Orchestration, Automation, and Response. Its core purpose is to be the 'glue' that connects all the other tools and automates the repetitive, manual tasks an analyst would otherwise perform."
                    },
                    {
                        "id": 2,
                        "question": "In a SOAR playbook, the step where the platform automatically queries a threat intelligence feed to get more information about an IP address is called:",
                        "options": [
                            "Containment",
                            "Eradication",
                            "Enrichment",
                            "Collection"
                        ],
                        "correct": 2,
                        "explanation": "Enrichment is the process of adding context to an alert. The SOAR platform automates this by gathering information from other sources (threat intel, asset databases, user directories) to give the analyst a complete picture."
                    },
                    {
                        "id": 3,
                        "question": "What is a major benefit of using automation for evidence collection, such as triggering a dynamic packet capture?",
                        "options": [
                            "It makes the capture files smaller.",
                            "It allows the capture of highly volatile evidence at the exact moment of an incident, which would be too fast for a human to do manually.",
                            "It is less expensive than a network tap.",
                            "It eliminates the need for a human analyst."
                        ],
                        "correct": 1,
                        "explanation": "Speed is the key benefit. Automation allows for the preservation of ephemeral evidence that would be lost by the time a human analyst could react to an alert and manually start a capture."
                    }
                ]
            }
        },
        {
            "id": "lesson-14",
            "title": "Advanced Network Analysis Techniques",
            "duration": "100 min",
            "objectives": [
                "Apply Deep Packet Inspection (DPI) to identify applications and protocols.",
                "Use Network Behavior Analysis (NBA) to find anomalies in traffic patterns.",
                "Employ statistical analysis and frequency analysis to find covert channels.",
                "Use traffic classification algorithms to categorize network activity.",
                "Reconstruct a network's topology from traffic analysis.",
                "Apply predictive analysis to anticipate attacker movements."
            ],
            "content": {
                "overview": "This lesson moves beyond basic protocol decoding into the advanced, data science-driven techniques used to analyze network traffic. We will explore how to use statistical analysis, behavioral modeling, and anomaly detection to find sophisticated threats and covert channels that are invisible to traditional signature-based tools.",
                "sections": [
                    {
                        "title": "Deep Packet Inspection (DPI)",
                        "content": "<p>DPI is the process of examining the data payload of a packet, not just its headers. While a standard firewall might just look at the port number (e.g., port 80 for HTTP), a DPI-capable device can actually read the HTTP conversation to identify the specific application, look for malware signatures, or detect policy violations.</p><h3>Forensic Application:</h3><p>DPI is crucial for identifying protocols that are trying to hide on non-standard ports. <strong>Real-World Example:</strong> An attacker is running a command and control channel over a custom protocol on TCP port 443. A standard firewall sees port 443 and assumes it's normal HTTPS traffic, so it allows it. A next-generation firewall with DPI will inspect the payload, see that it is *not* a valid TLS handshake, and flag or block the traffic as a protocol anomaly.</p>",
                        "image": "https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Network Behavior Analysis (NBA)",
                        "content": "<p>NBA, also known as Network Detection and Response (NDR), focuses on detecting threats by identifying anomalies in traffic patterns. It's a behavioral approach, not a signature-based one.</p><h3>The Process:</h3><ol><li><strong>Baselining:</strong> The NBA tool spends a period of time learning what 'normal' traffic looks like on your network. It learns which hosts talk to which, what protocols they use, and how much data they send.</li><li><strong>Modeling:</strong> It builds a statistical model of this normal behavior.</li><li><strong>Anomaly Detection:</strong> It then monitors the live network and alerts on any activity that deviates significantly from the established baseline.</li></ol><p>This approach is very effective at detecting 'unknown unknowns'—new malware or zero-day attacks for which no signatures exist yet.</p>",
                        "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Statistical and Frequency Analysis",
                        "content": "<p>Statistical analysis of packet data can reveal hidden information.</p><p><strong>Real-time Problem: Detecting novel attack patterns.</strong> An analyst is hunting for covert channels. They use a tool to perform a frequency analysis on the size of all DNS response packets. They create a histogram and see a normal distribution, with most packets being small. However, they also see a second, very unusual spike of packets that are all exactly 1024 bytes long. This is a statistical anomaly. This pattern could indicate a data exfiltration tool that is encoding stolen data into fixed-size DNS responses to evade detection. The statistical analysis provides the initial lead to begin a much deeper investigation into that specific traffic.</p>",
                        "image": "https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Advanced Analytics Engine (Python with Scapy)",
                        "language": "python",
                        "code": "# This conceptual script demonstrates statistical analysis on a PCAP file\n# to find potential beaconing activity by analyzing packet timing.\n\nfrom scapy.all import rdpcap\nimport numpy as np\n\ndef find_beaconing(pcap_file, potential_c2_ip):\n    \"\"\"Analyzes the timing between packets to a specific IP to detect beaconing.\"\"\"\n    packets = rdpcap(pcap_file)\n    \n    connection_times = []\n    for packet in packets:\n        if 'IP' in packet and packet['IP'].dst == potential_c2_ip:\n            connection_times.append(packet.time)\n\n    if len(connection_times) < 10: # Need enough data points\n        print(\"Not enough packets to analyze for beaconing.\")\n        return\n\n    # Calculate the time difference (delta) between consecutive packets\n    deltas = np.diff(connection_times)\n\n    # A low standard deviation in the deltas means the time between packets is very regular\n    stdev = np.std(deltas)\n    mean_interval = np.mean(deltas)\n\n    print(f\"--- Beaconing Analysis for IP: {potential_c2_ip} ---\")\n    print(f\"Average Interval: {mean_interval:.2f} seconds\")\n    print(f\"Standard Deviation: {stdev:.4f} seconds\")\n\n    if stdev < 0.5: # An arbitrary threshold for 'very regular'\n        print(\"[!] High probability of C2 beaconing detected!\")\n    else:\n        print(\"[+] Traffic appears to be irregular (normal).\")\n\n# find_beaconing(\"capture.pcap\", \"198.51.100.55\")"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "The technique of examining the payload of a packet to identify its true application, rather than just looking at the port number, is called:",
                        "options": [
                            "NetFlow analysis",
                            "Deep Packet Inspection (DPI)",
                            "Port scanning",
                            "DNS lookup"
                        ],
                        "correct": 1,
                        "explanation": "DPI goes beyond the headers to inspect the actual content (payload) of the packet, allowing it to identify applications and threats with much greater accuracy than a traditional firewall."
                    },
                    {
                        "id": 2,
                        "question": "Network Behavior Analysis (NBA) tools are primarily designed to detect what?",
                        "options": [
                            "Specific, known malware signatures.",
                            "Deviations from a learned baseline of normal network activity.",
                            "Misconfigured firewall rules.",
                            "Unpatched servers."
                        ],
                        "correct": 1,
                        "explanation": "NBA is a behavioral approach. By learning what's normal, it can detect novel or 'unknown' threats that don't have a signature yet, simply because they are behaving abnormally."
                    },
                    {
                        "id": 3,
                        "question": "An analyst is looking for a C2 channel. They calculate the time difference between every packet sent to a suspicious IP and find that the standard deviation is extremely low. What does this indicate?",
                        "options": [
                            "Normal, human-generated traffic.",
                            "A large file is being downloaded.",
                            "The server is offline.",
                            "The traffic is machine-generated and occurring at a highly regular interval, which is a strong sign of C2 beaconing."
                        ],
                        "correct": 3,
                        "explanation": "Human traffic is bursty and irregular, leading to a high standard deviation in packet timing. Machine-generated beacons are metronomic and regular, leading to a very low standard deviation. This statistical difference is a key detection technique."
                    }
                ]
            }
        },
        {
            "id": "lesson-15",
            "title": "Cryptocurrency and Blockchain Network Forensics",
            "duration": "100 min",
            "objectives": [
                "Understand the fundamentals of blockchain technology.",
                "Analyze transactions on public blockchains like Bitcoin and Ethereum.",
                "Investigate cryptocurrency mixing services used for money laundering.",
                "Trace ransomware payments through the blockchain.",
                "Use clustering analysis to link wallet addresses to a single entity.",
                "Understand the forensic challenges of privacy coins (e.g., Monero).",
                "Investigate smart contract and DeFi protocol exploits."
            ],
            "content": {
                "overview": "Cryptocurrencies have become the financial backbone of the cybercrime economy. Understanding how to trace transactions on the blockchain is now a critical skill for investigating ransomware, online black markets, and other illicit activities. This lesson demystifies blockchain technology and provides a guide to the tools and techniques of cryptocurrency forensics.",
                "sections": [
                    {
                        "title": "Blockchain Fundamentals",
                        "content": "<p>A blockchain is a distributed, immutable public ledger. Every transaction is recorded in a 'block', which is cryptographically linked to the previous block, forming a chain.</p><h3>Key Characteristics:</h3><ul><li><strong>Public:</strong> For most major cryptocurrencies like Bitcoin, every single transaction is publicly visible to anyone.</li><li><strong>Immutable:</strong> Once a transaction is confirmed in a block, it cannot be altered or reversed.</li><li><strong>Pseudonymous:</strong> The parties in a transaction are represented by alphanumeric wallet addresses, not real names. The identities are not anonymous, but pseudonymous.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1621452773352-2a74c35b2917?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Tracing Transactions",
                        "content": "<p>The core of blockchain forensics is tracing the flow of funds from one address to another. This is done using a 'blockchain explorer' or a specialized analysis tool (e.g., Chainalysis, Elliptic).</p><p><strong>Real-time Problem: Tracking ransomware payments.</strong> A company pays a 10 Bitcoin ransom. The analyst uses a blockchain explorer to look up the attacker's wallet address. They see the 10 BTC arrive. They then watch that address. A few hours later, they see the 10 BTC is split and sent to 10 new addresses. They then see those funds move again, and again. The goal is to follow this chain of transactions until the attacker makes a mistake: sending the funds to an address associated with a major, regulated cryptocurrency exchange. The exchange is required by law to have Know Your Customer (KYC) information (like a name and driver's license) for its users. The investigator can then serve a subpoena to the exchange to get the real-world identity of the person who controls that account.</p>",
                        "image": "https://images.unsplash.com/photo-1642155998158-9416a041cb42?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The Challenge of Mixers and Privacy Coins",
                        "content": "<p>Criminals use various techniques to try and break the forensic trail.</p><ul><li><strong>Mixers (Tumblers):</strong> These are services where many users pool their cryptocurrency. The mixer takes in all the 'dirty' coins, mixes them all up, and then sends out smaller amounts to new, clean addresses. This makes it very difficult to trace a specific coin from input to output.</li><li><strong>Privacy Coins:</strong> Cryptocurrencies like Monero are designed with privacy-enhancing technologies built into the protocol itself, making transactions confidential and largely untraceable even on the public ledger.</li></ul><p>Investigating these requires highly advanced techniques and often relies on finding metadata leaks or operational security mistakes made by the criminal.</p>",
                        "image": "https://images.unsplash.com/photo-1548092372-2d987bde898b?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Blockchain Transaction Tracer (Python API)",
                        "language": "python",
                        "code": "import requests\n\n# This conceptual script uses a public blockchain explorer API (e.g., blockchain.info)\n# to get details about a Bitcoin wallet address.\n\ndef trace_bitcoin_address(address):\n    \"\"\"Fetches and displays basic information for a Bitcoin address.\"\"\"\n    try:\n        # Construct the API URL\n        api_url = f\"https://blockchain.info/rawaddr/{address}\"\n        response = requests.get(api_url)\n        response.raise_for_status() # Raise an exception for bad status codes\n\n        data = response.json()\n\n        print(f\"--- Analysis for Address: {address} ---\")\n        print(f\"Total Received: {data['total_received'] / 10**8} BTC\")\n        print(f\"Total Sent: {data['total_sent'] / 10**8} BTC\")\n        print(f\"Final Balance: {data['final_balance'] / 10**8} BTC\")\n        print(f\"Number of Transactions: {data['n_tx']}\")\n\n        print(\"\\n--- Recent Transactions ---\")\n        for tx in data['txs'][:5]: # Show the 5 most recent transactions\n            print(f\"Hash: {tx['hash']}\")\n\n    except requests.exceptions.RequestException as e:\n        print(f\"Error fetching data: {e}\")\n\n# This is a known address from the WannaCry ransomware attack.\n# trace_bitcoin_address(\"13AM4VW2dhxYgXeQepoHkHSQuy6NgaEb94\")"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "The primary characteristic of a public blockchain like Bitcoin is that:",
                        "options": [
                            "All transactions are secret and hidden.",
                            "All transactions are public, but the participants are pseudonymous.",
                            "Only the government can view the transactions.",
                            "Transactions can be easily reversed."
                        ],
                        "correct": 1,
                        "explanation": "This is the core concept. The ledger is public and transparent, but the actors are identified by wallet addresses, not names. The goal of forensics is to bridge the gap between the pseudonym and the real person."
                    },
                    {
                        "id": 2,
                        "question": "In a ransomware investigation, what is the ultimate goal of tracing cryptocurrency payments on the blockchain?",
                        "options": [
                            "To ask the attacker for the money back.",
                            "To see how many transactions the attacker has made.",
                            "To follow the funds until the attacker makes a mistake and moves them to a regulated exchange where their real-world identity can be subpoenaed.",
                            "To admire the complexity of the blockchain."
                        ],
                        "correct": 2,
                        "explanation": "The entire tracing process is a hunt for a 'cash-out' point. Investigators follow the money until it hits a service (like a major exchange) that is subject to Anti-Money Laundering (AML) and Know Your Customer (KYC) laws, which forces the link to a real identity."
                    },
                    {
                        "id": 3,
                        "question": "Services that are designed to obfuscate the trail of cryptocurrency by pooling and mixing funds from many different users are known as:",
                        "options": [
                            "Exchanges",
                            "Wallets",
                            "Miners",
                            "Mixers or Tumblers"
                        ],
                        "correct": 3,
                        "explanation": "Mixers are a primary tool for cryptocurrency money laundering. They intentionally break the chain of custody for the funds, making forensic tracing significantly more difficult."
                    }
                ]
            }
        },
        {
            "id": "lesson-16",
            "title": "Network Forensics for Different Attack Types",
            "duration": "100 min",
            "objectives": [
                "Analyze the network traffic of a Distributed Denial of Service (DDoS) attack.",
                "Investigate a Man-in-the-Middle (MITM) attack.",
                "Detect DNS hijacking and cache poisoning from network evidence.",
                "Identify the network signatures of brute force and credential stuffing attacks.",
                "Find the network indicators of a software supply chain compromise.",
                "Differentiate the network patterns of common vs. state-sponsored attacks."
            ],
            "content": {
                "overview": "Different types of attacks leave different fingerprints on the network. This lesson provides a practical guide to recognizing the specific network traffic patterns and artifacts associated with a wide range of common and advanced attacks, from brute-force password guessing to sophisticated DNS hijacking.",
                "sections": [
                    {
                        "title": "Distributed Denial of Service (DDoS) Analysis",
                        "content": "<p>The network evidence of a DDoS attack is overwhelming but clear. The key is to classify the type of attack.</p><h3>Traffic Patterns:</h3><ul><li><strong>Volumetric Attack:</strong> The packet capture will show a massive flood of traffic, often UDP or ICMP packets, from thousands of different source IPs, all directed at a single victim IP.</li><li><strong>SYN Flood:</strong> The capture will be filled with TCP packets that have only the SYN flag set, with very few corresponding SYN-ACKs or ACKs.</li><li><strong>Application Layer Attack:</strong> The traffic might look like legitimate HTTP GET requests, but the sheer volume from many sources targeting the same URL is the key indicator.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1510511459019-5dda7724fd87?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Man-in-the-Middle (MITM) Attack Investigation",
                        "content": "<p>In a MITM attack, the adversary positions themselves between two communicating parties to intercept or modify the traffic. A common way to do this on a local network is 'ARP spoofing'.</p><p><strong>Real-world Example:</strong> An analyst examines a packet capture and sees a large number of unsolicited 'ARP Reply' packets. They see one packet where a host with MAC address A says 'I am IP address B', and another packet where a host with MAC address C also says 'I am IP address B'. This is a definitive sign of an ARP spoofing attack, where host C is trying to impersonate host B to intercept its traffic.</p>",
                        "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Credential Stuffing and Brute Force Attacks",
                        "content": "<p>These attacks are identified by analyzing authentication logs (from a web server, VPN, etc.).</p><h3>Network Signatures:</h3><ul><li><strong>Brute Force Attack:</strong> A huge number of failed login attempts for a *single* username with many different passwords, often from a single source IP.</li><li><strong>Credential Stuffing Attack:</strong> A huge number of failed login attempts for *many different* usernames, each with only one or two password attempts, coming from a large, distributed set of source IPs. This is the pattern of an attacker using a list of credentials stolen from another breach.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Multi-Attack Detection System (Zeek)",
                        "language": "clojure",
                        "code": "# This Zeek script detects a common sign of a brute force SSH attack.\n\n@load policy/protocols/ssh/detect-bruteforcing\n\n# This script uses Zeek's built-in brute-forcing detection framework.\n# It simply redefines the threshold for what is considered a brute-force attack.\n\nredef SSH::bruteforcing_threshold = 10;\n\n# When more than 10 failed SSH logins are seen from a single host\n# to a single host in a short time, Zeek will generate a notice.\n\nevent notice(n: Notice::Info) {\n    if ( n$note == SSH::Bruteforcing ) {\n        print fmt(\"[!] SSH Brute Force Detected: %s -> %s\", n$src, n$dst);\n    }\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "An analyst sees a massive volume of failed login attempts from a single IP address, all targeting the 'admin' username. This is a classic sign of what kind of attack?",
                        "options": [
                            "A DDoS attack",
                            "A brute force attack",
                            "A credential stuffing attack",
                            "A phishing attack"
                        ],
                        "correct": 1,
                        "explanation": "A brute force attack is characterized by trying many different passwords against a single username. Credential stuffing, by contrast, tries one password against many different usernames."
                    },
                    {
                        "id": 2,
                        "question": "Seeing a large number of unsolicited ARP Reply packets, where multiple MAC addresses are claiming the same IP address, is a definitive indicator of what?",
                        "options": [
                            "A normally functioning network.",
                            "A DNS hijacking attack.",
                            "An ARP spoofing Man-in-the-Middle attack.",
                            "A SYN flood."
                        ],
                        "correct": 2,
                        "explanation": "This is the textbook signature of ARP spoofing. The attacker is poisoning the ARP cache of other hosts on the local network to redirect their traffic through the attacker's machine."
                    },
                    {
                        "id": 3,
                        "question": "Which attack is characterized by a massive flood of TCP packets with only the SYN flag set?",
                        "options": [
                            "An HTTP flood",
                            "A SYN flood",
                            "A UDP flood",
                            "An ICMP flood"
                        ],
                        "correct": 1,
                        "explanation": "A SYN flood is a type of protocol-based DDoS attack that aims to exhaust a server's connection state table by sending a huge volume of connection initiation requests without ever completing the handshake."
                    }
                ]
            }
        },
        {
            "id": "lesson-17",
            "title": "Network Forensics Tool Development",
            "duration": "100 min",
            "objectives": [
                "Design the architecture for a custom network analysis tool.",
                "Use libraries like Scapy and pyshark to parse and manipulate packets.",
                "Optimize custom tools for high-speed packet processing.",
                "Develop a plugin architecture to make a tool extensible.",
                "Address cross-platform compatibility for forensic tools.",
                "Implement proper validation and testing for custom tools.",
                "Automate the generation of reports from a custom tool."
            ],
            "content": {
                "overview": "While tools like Wireshark and Zeek are incredibly powerful, there are times when an investigator needs a specialized tool to solve a unique problem. This lesson introduces the fundamentals of network forensic tool development, focusing on how to use Python and libraries like Scapy to build custom scripts and programs to parse, analyze, and report on network traffic.",
                "sections": [
                    {
                        "title": "Why Develop Custom Tools?",
                        "content": "<p>There are many reasons why an analyst might move from being a tool user to a tool builder.</p><h3>Common Motivations:</h3><ul><li><strong>Parsing Proprietary Protocols:</strong> A company might use a custom, in-house network protocol. No off-the-shelf tool will know how to decode it, requiring a custom parser to be written.</li><li><strong>Automation of Specific Workflows:</strong> An investigation might require a very specific, repetitive task that would be tedious to do manually in Wireshark. A script can automate this workflow perfectly.</li><li><strong>Creating Novel Detections:</strong> An analyst might have a hypothesis for a new way to detect a certain type of attack that isn't implemented in their existing tools. They can write a proof-of-concept tool to test their theory.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1587620962725-abab7fe55159?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Scapy: The Packet Manipulation Swiss Army Knife",
                        "content": "<p>Scapy is a powerful and interactive packet manipulation program and library for Python. It is the go-to tool for crafting, sending, and dissecting network packets.</p><h3>What Scapy Can Do:</h3><ul><li><strong>Parse PCAPs:</strong> Read in a packet capture file and allow you to interact with each packet as a Python object.</li><li><strong>Dissect Layers:</strong> Automatically dissect all the layers of a packet (Ethernet, IP, TCP, DNS, etc.) and give you access to every single field.</li><li><strong>Craft Packets:</strong> You can build any kind of packet you can imagine from scratch, field by field. This is useful for testing network devices and security rules.</li><li><strong>Send and Receive:</strong> Scapy can send your crafted packets onto the network and sniff for the replies.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Tool Validation and Performance",
                        "content": "<p>Any custom tool used for a forensic case must be validated to prove it is accurate. The results must also be independently verifiable with another established tool (like Wireshark).</p><p><strong>Real-time Problem: Developing a tool for a new protocol.</strong> An investigator is examining traffic from an IoT device that uses a custom, undocumented protocol. They capture the traffic and, by observing the patterns, reverse-engineer the protocol's structure. They then write a Scapy script that defines the new protocol as a custom 'layer'. This script can now read in the PCAP file and automatically dissect the custom protocol, revealing the commands being sent to the IoT device. Before using this in a report, they must validate it by creating known traffic, running it through their script, and proving that the output is 100% correct.</p>",
                        "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Professional-Grade Forensic Tool (Python with Scapy)",
                        "language": "python",
                        "code": "from scapy.all import rdpcap, DNS, DNSRR\n\n# This is a simple but practical forensic tool using Scapy.\n# It parses a PCAP file and extracts all the DNS answers to build a list\n# of domains and the IP addresses they resolved to.\n\ndef extract_dns_answers(pcap_file):\n    \"\"\"Parses a PCAP and extracts all DNS A records.\"\"\"\n    packets = rdpcap(pcap_file)\n    dns_mappings = {}\n\n    for packet in packets:\n        # Check if the packet has a DNS layer with an answer\n        if DNS in packet and packet[DNS].ancount > 0 and DNSRR in packet:\n            # The DNSRR layer is the answer record\n            # We iterate because there can be multiple answers\n            for i in range(packet[DNS].ancount):\n                dns_rr = packet[DNS].an[i]\n                # Check if it's an 'A' record (IPv4 address)\n                if dns_rr.type == 1: # 1 = A record\n                    domain = dns_rr.rrname.decode('utf-8')\n                    ip = dns_rr.rdata\n                    if domain not in dns_mappings:\n                        dns_mappings[domain] = set()\n                    dns_mappings[domain].add(ip)\n    \n    print(\"--- DNS Mappings Found ---\")\n    for domain, ips in dns_mappings.items():\n        print(f\"{domain} -> {', '.join(ips)}\")\n\n# extract_dns_answers(\"network_capture.pcap\")"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is Scapy?",
                        "options": [
                            "A graphical packet analyzer like Wireshark.",
                            "A type of firewall.",
                            "A powerful Python library for crafting, sending, and dissecting network packets.",
                            "A network tap."
                        ],
                        "correct": 2,
                        "explanation": "Scapy is the premier Python library for low-level packet manipulation, making it an essential component for anyone wanting to develop custom network analysis tools."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary reason an investigator would need to develop a custom forensic tool?",
                        "options": [
                            "They are bored.",
                            "To automate a repetitive workflow or to parse a proprietary or unknown protocol that off-the-shelf tools do not support.",
                            "Their company requires them to.",
                            "To make the investigation take more time."
                        ],
                        "correct": 1,
                        "explanation": "Custom tool development is driven by necessity. It's about solving a specific problem that a general-purpose tool can't, or making a common task much more efficient through automation."
                    },
                    {
                        "id": 3,
                        "question": "The process of proving that a custom-developed tool works as expected and produces accurate results is called:",
                        "options": [
                            "Compilation",
                            "Validation",
                            "Debugging",
                            "Distribution"
                        ],
                        "correct": 1,
                        "explanation": "Tool validation is a critical scientific and legal step. Before the results of a custom tool can be used as evidence, the developer must be able to prove that the tool is accurate, reliable, and that its results are verifiable."
                    }
                ]
            }
        },
        {
            "id": "lesson-18",
            "title": "Large-Scale Network Forensics",
            "duration": "90 min",
            "objectives": [
                "Apply big data analytics principles to network forensic investigations.",
                "Design and use distributed analysis architectures for high-speed networks.",
                "Process and analyze petabyte-scale datasets of network traffic.",
                "Utilize real-time streaming analysis for immediate threat detection.",
                "Optimize performance and manage resources in a large-scale analysis environment.",
                "Design and implement scalable storage solutions for long-term packet capture."
            ],
            "content": {
                "overview": "In the world of enterprise and nation-state security, investigations can involve analyzing network traffic from thousands of systems across the globe, generating petabytes of data. This lesson explores the tools, architectures, and strategies required to perform network forensics at a massive scale, leveraging big data platforms and distributed computing.",
                "sections": [
                    {
                        "title": "Big Data Analytics for Network Forensics",
                        "content": "<p>Traditional, single-machine analysis with Wireshark is not feasible for enterprise-scale data. The approach must shift from interactive analysis to batch processing and querying.</p><h3>Key Platforms:</h3><ul><li><strong>SIEM (Security Information and Event Management):</strong> While not strictly for forensics, modern SIEMs like Splunk and Elasticsearch are big data platforms that can ingest and index massive volumes of network logs (e.g., firewall, DNS, Zeek logs) for high-speed searching.</li><li><strong>Distributed Computing (Spark, Hadoop):</strong> For full packet captures, frameworks like Apache Spark can be used to distribute the processing of a massive PCAP file across a cluster of hundreds of computers, drastically reducing the time required for analysis.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Real-Time Streaming Analysis",
                        "content": "<p>In addition to retrospective analysis of stored data, large-scale forensics also involves real-time analysis of the live data stream to detect threats as they happen.</p><p><strong>Real-world Example: Nation-wide network compromise.</strong> A national telecommunications provider needs to hunt for a specific threat across its entire network, which handles petabytes of data per day. They cannot store all this traffic. Instead, they use a streaming analysis platform (like Apache Flink or Kafka). They write a query that looks for the specific signature of the threat (e.g., a unique User-Agent string). This query is then run against the live network traffic as it flows through the system. This allows them to detect the threat in real-time, anywhere in the country, without having to store the full packet capture.</p>",
                        "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Scalable Storage Solutions",
                        "content": "<p>Long-term, full packet capture is incredibly expensive from a storage perspective. A 10Gbps link can generate over 100 terabytes of data per day. Designing a storage solution requires a tiered approach.</p><h3>Tiered Storage:</h3><ul><li><strong>Hot Tier:</strong> The most recent data (e.g., the last 72 hours) is stored on very fast, expensive SSD storage for immediate, interactive analysis.</li><li><strong>Warm Tier:</strong> Older data (e.g., 3-30 days) is stored on slower, less expensive hard drive-based systems.</li><li><strong>Cold Tier:</strong> Archival data is compressed and moved to very low-cost cloud storage (e.g., Amazon S3 Glacier).</li></ul><p>This approach balances the need for rapid access to recent data with the cost of long-term retention.</p>",
                        "image": "https://images.unsplash.com/photo-1593435713588-a73de23947db?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Distributed Forensics Processing System (Zeek + Kafka + Spark)",
                        "language": "bash",
                        "code": "# This is a conceptual architecture for a large-scale, real-time analysis pipeline.\n\n# 1. Zeek sensors on the network edge analyze traffic and produce structured logs.\n# They are configured to send these logs to a Kafka topic, not a local file.\nzeek -i eth0 'local_kafka::topic_name=zeek-logs'\n\n# 2. Apache Kafka acts as a high-throughput, distributed message bus.\n# It receives the logs from all the Zeek sensors across the enterprise.\n\n# 3. An Apache Spark Streaming job subscribes to the Kafka topic.\n# It processes the logs in real-time as they arrive.\n\n# --- Conceptual Spark Streaming Code ---\n# from pyspark.sql import SparkSession\n# from pyspark.sql.functions import from_json, col\n\n# spark = SparkSession.builder.appName(\"RealTimeZeekAnalysis\").getOrCreate()\n\n# kafka_stream = spark.readStream.format(\"kafka\").option(\"kafka.bootstrap.servers\", \"...\").option(\"subscribe\", \"zeek-logs\").load()\n\n# parsed_logs = kafka_stream.select(from_json(col(\"value\").cast(\"string\"), zeek_schema).alias(\"log\"))\n\n# high_entropy_dns = parsed_logs.filter(\"log.log_type == 'dns' AND calculate_entropy(log.query) > 3.5\")\n\n# high_entropy_dns.writeStream.format(\"console\").start().awaitTermination()"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary challenge of performing network forensics on a high-speed, enterprise-scale network?",
                        "options": [
                            "The protocols are too simple.",
                            "There is not enough traffic to analyze.",
                            "The massive volume, velocity, and variety of the data make traditional, single-machine analysis impossible.",
                            "The traffic is not interesting."
                        ],
                        "correct": 2,
                        "explanation": "Scale is the defining challenge. The sheer amount of data requires a shift in thinking from interactive, manual analysis to automated, distributed, big-data-driven approaches."
                    },
                    {
                        "id": 2,
                        "question": "What is the main purpose of a streaming analysis platform in network forensics?",
                        "options": [
                            "To store packet captures for a long time.",
                            "To analyze the live network traffic stream in real-time to detect threats as they happen, without needing to store all the data.",
                            "To make web browsing faster.",
                            "To replace the need for firewalls."
                        ],
                        "correct": 1,
                        "explanation": "Streaming analysis is for real-time detection. It allows an organization to run queries against its live data flow, providing immediate alerts on threats without the massive storage overhead of long-term full packet capture."
                    },
                    {
                        "id": 3,
                        "question": "A tiered storage architecture with 'hot', 'warm', and 'cold' layers is designed to solve what problem?",
                        "options": [
                            "It makes all storage as fast as possible.",
                            "It balances the high cost of fast storage with the need for long-term data retention.",
                            "It encrypts all the data.",
                            "It deletes all old data automatically."
                        ],
                        "correct": 1,
                        "explanation": "This is a cost-optimization strategy. It keeps the most recent, most likely to be accessed data on expensive, high-performance storage, while moving older, less critical data to cheaper, slower storage tiers to manage costs."
                    }
                ]
            }
        },
        {
            "id": "lesson-19",
            "title": "Network Forensics Integration and Correlation",
            "duration": "90 min",
            "objectives": [
                "Integrate data from multiple sources (network, host, memory) into a single investigation.",
                "Apply cross-platform correlation techniques to trace an attacker's activity.",
                "Synchronize timelines from different evidence sources with varying time precisions.",
                "Use evidence triangulation to validate findings.",
                "Correlate geographic, temporal, and metadata patterns.",
                "Fuse technical indicators with human intelligence."
            ],
            "content": {
                "overview": "The most powerful investigations are not confined to a single type of evidence. This lesson focuses on the art of correlation and fusion: how to weave together disparate pieces of evidence from the network, the disk, and memory into a single, coherent, and highly defensible narrative of an entire incident.",
                "sections": [
                    {
                        "title": "Multi-Source Data Integration",
                        "content": "<p>Each type of forensic evidence provides a different piece of the puzzle. The goal is to put them all together.</p><h3>The Three Views of an Incident:</h3><ul><li><strong>Network Evidence (PCAP, Logs):</strong> Shows *what happened between* systems. It provides the ground truth of communication.</li><li><strong>Disk Evidence (File System, Logs):</strong> Shows *what happened on* a system over the long term. It provides historical context.</li><li><strong>Memory Evidence (RAM Dump):</strong> Shows *what was happening on* a system at a specific moment in time. It provides the real-time state.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Evidence Triangulation and Timeline Synchronization",
                        "content": "<p>Triangulation is the process of confirming a finding using two or more independent evidence sources. This dramatically increases the confidence in a conclusion.</p><p><strong>Real-world Example:</strong> An analyst is investigating a web shell on a server.</p><ol><li><strong>Network Evidence:</strong> A packet capture shows a POST request to `shell.php` from a malicious IP, containing the command `whoami`. The response contains the username `www-data`.</li><li><strong>Disk Evidence:</strong> An analysis of the web server's file system finds the file `/var/www/html/shell.php`. The file's creation timestamp matches the time of the network connection.</li><li><strong>Host Evidence:</strong> The web server's logs show an entry for the POST request to `shell.php` from the same malicious IP at the same time.</li></ol><p>By triangulating these three independent sources, the analyst can state with extremely high confidence exactly what happened, when it happened, and who did it.</p>",
                        "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Intelligence Fusion",
                        "content": "<p>The final layer of correlation is fusing the technical evidence with non-technical, human intelligence.</p><p>An analyst might find technical evidence that an employee's account was used to exfiltrate data at 2:00 AM. This is suspicious. The analyst then fuses this with information from HR that shows the employee was on vacation in a different time zone that week. This fusion of technical and human intelligence elevates the incident from a potential insider threat to a highly likely account compromise, completely changing the direction of the investigation.</p>",
                        "image": "https://images.unsplash.com/photo-1552664730-d307ca884978?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Universal Correlation Engine (Splunk)",
                        "language": "sql",
                        "code": "/* This conceptual Splunk query demonstrates correlating across different data sources (sourcetypes)\n   to find evidence of a malicious file download and execution.\n*/\n\n// 1. Start by finding a suspicious file download in the proxy logs.\nindex=main sourcetype=proxy action=blocked category=\"malware\"\n| stats values(src_ip) as client_ip, values(url) as malicious_url by file_hash\n\n// 2. Take the client_ip and file_hash and look for them in the endpoint (EDR) logs.\n| map search=\"search index=main sourcetype=edr (src_ip=$client_ip$ OR hash=$file_hash$)\"\n\n// 3. Look for a process creation event involving that hash.\n| search event_type=\"ProcessRollup2\" \n\n// 4. Display the combined timeline of events.\n| table _time, client_ip, malicious_url, file_hash, process_name, command_line\n\n// The result is a single timeline showing: \n// The user at 'client_ip' downloaded a file from 'malicious_url'. \n// That file had a specific 'file_hash'. \n// A process with that same 'file_hash' was then executed on the client machine."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "Which of the three main forensic disciplines shows what was happening on a system at a specific moment in time?",
                        "options": [
                            "Disk Forensics",
                            "Network Forensics",
                            "Memory Forensics",
                            "Email Forensics"
                        ],
                        "correct": 2,
                        "explanation": "Memory forensics provides a snapshot of the live, running state of a computer, including all its processes and network connections, at the exact moment of acquisition."
                    },
                    {
                        "id": 2,
                        "question": "The process of confirming a finding using two or more independent sources of evidence is known as:",
                        "options": [
                            "Guessing",
                            "Triangulation",
                            "NetFlow",
                            "Packet Capture"
                        ],
                        "correct": 1,
                        "explanation": "Triangulation is a core investigative principle. A finding that is supported by network logs, disk artifacts, AND memory artifacts is extremely strong and difficult to refute."
                    },
                    {
                        "id": 3,
                        "question": "What is the ultimate goal of correlating evidence from multiple sources?",
                        "options": [
                            "To create a longer report.",
                            "To use as many forensic tools as possible.",
                            "To create a single, unified timeline and narrative of the entire incident.",
                            "To find a single piece of evidence that proves the case."
                        ],
                        "correct": 2,
                        "explanation": "Correlation is about storytelling. By weaving together different threads of evidence, an investigator can build a comprehensive and compelling narrative that explains the 'who, what, when, where, and how' of the entire incident."
                    }
                ]
            }
        },
        {
            "id": "lesson-20",
            "title": "Privacy and Legal Considerations",
            "duration": "90 min",
            "objectives": [
                "Understand how privacy laws like GDPR and CCPA impact network monitoring.",
                "Apply data minimization and anonymization principles to forensic data.",
                "Understand the legal requirements for lawful intercept.",
                "Navigate the challenges of cross-border investigations and data sharing.",
                "Balance the need for an investigation with the privacy rights of individuals.",
                "Uphold the professional and ethical standards of a network forensic investigator."
            ],
            "content": {
                "overview": "Network monitoring and forensics do not happen in a legal vacuum. The act of capturing and analyzing network traffic is governed by a complex web of privacy laws, regulations, and ethical considerations. This lesson explores the legal framework that every network investigator must operate within to ensure their work is not only technically sound, but legally defensible.",
                "sections": [
                    {
                        "title": "Privacy Law Compliance (GDPR, CCPA)",
                        "content": "<p>Modern privacy laws like Europe's GDPR and the California Consumer Privacy Act (CCPA) place strict controls on the monitoring and processing of any data that can be used to identify a person (Personal Identifiable Information - PII).</p><h3>Key Principles:</h3><ul><li><strong>Lawful Basis:</strong> An organization must have a legitimate, legal basis for monitoring network traffic (e.g., to protect the security of its network).</li><li><strong>Transparency:</strong> Employees and users must be notified that their activity on corporate networks may be monitored. This is typically done via an Acceptable Use Policy (AUP).</li><li><strong>Data Minimization:</strong> You should only collect and retain the data that is strictly necessary for your stated purpose. Long-term, full packet capture of all user activity can be difficult to justify under these laws.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1505664194779-8beace7a2044?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Cross-Border Investigation Challenges",
                        "content": "<p>In a global company, an investigation might require an analyst in the US to examine network traffic captured from a server in Germany. This act of transferring the data across borders is heavily regulated.</p><p><strong>Real-world Problem: Balancing investigation needs with privacy rights.</strong> An analyst is investigating an incident involving a German employee. The PCAP file contains the content of the employee's web browsing. Under GDPR, this is considered sensitive personal data. The analyst cannot simply transfer the PCAP to their workstation in the US. They must follow a strict legal protocol, such as ensuring a legal framework like Standard Contractual Clauses is in place, redacting any data not relevant to the investigation, and potentially conducting the analysis on a machine that is physically located within the EU to avoid a cross-border data transfer violation.</p>",
                        "image": "https://images.unsplash.com/photo-1543286386-713bdd548da4?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Ethics in Network Monitoring",
                        "content": "<p>Beyond the law, network forensics requires a strong ethical framework. The ability to inspect network traffic is a significant power that must not be abused.</p><h3>Ethical Guidelines:</h3><ul><li><strong>Proportionality:</strong> The level of monitoring must be proportional to the threat.</li><li><strong>Confidentiality:</strong> An investigator will inevitably see sensitive, non-work-related information during an investigation. They have an ethical duty to keep this information confidential and only report on findings that are relevant to the case.</li><li><strong>Objectivity:</strong> The investigator's duty is to the facts that the data reveals, not to a preconceived conclusion.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1552664730-d307ca884978?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Privacy-Compliant Investigation Framework (Packet Anonymization)",
                        "language": "bash",
                        "code": "# This example uses a tool like 'b anonymize' to create a privacy-preserving\n# version of a PCAP file by anonymizing IP addresses.\n\n# This allows analysts to study traffic patterns and protocol behavior\n# without exposing the real IP addresses of the users involved.\n\nINPUT_PCAP=\"original_capture.pcap\"\nANONYMIZED_PCAP=\"anonymized_capture.pcap\"\n\n# The tool replaces the original IP addresses with fake but consistent ones.\n# For example, every occurrence of 192.168.1.10 might become 10.0.0.1.\nb anonymize --input-file $INPUT_PCAP --output-file $ANONYMIZED_PCAP\n\n# The analyst can now share and analyze 'anonymized_capture.pcap' with a reduced\n# privacy risk. The original, unaltered evidence must be retained under\n# strict chain of custody."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "Privacy laws like GDPR are primarily concerned with the protection of what?",
                        "options": [
                            "Encrypted data",
                            "Corporate intellectual property",
                            "Personal Identifiable Information (PII)",
                            "Firewall log data"
                        ],
                        "correct": 2,
                        "explanation": "The core purpose of modern privacy laws is to regulate the collection, processing, and protection of any data that can be used to identify a specific individual."
                    },
                    {
                        "id": 2,
                        "question": "What is the most common way an organization provides transparency and obtains consent for network monitoring of its employees?",
                        "options": [
                            "By monitoring them secretly.",
                            "By asking for verbal permission each day.",
                            "Through a clear, written Acceptable Use Policy (AUP) that is acknowledged by all employees.",
                            "By only monitoring employees who are suspected of a crime."
                        ],
                        "correct": 2,
                        "explanation": "A well-drafted and consistently enforced AUP is the legal foundation for corporate network monitoring. It informs employees that their activity on company assets is not private and is subject to monitoring for security purposes."
                    },
                    {
                        "id": 3,
                        "question": "An investigator in the United States needs to analyze a packet capture that was collected in France and contains personal data of French citizens. What is the biggest challenge they face?",
                        "options": [
                            "The file size of the packet capture.",
                            "The time zone difference.",
                            "Navigating the strict cross-border data transfer restrictions of the GDPR.",
                            "The packet capture will be in French."
                        ],
                        "correct": 2,
                        "explanation": "GDPR places very strict limits on transferring the personal data of EU residents outside of the EU. The investigator cannot simply copy the file; they must work with legal counsel to ensure they have a valid legal mechanism for the transfer to avoid massive fines."
                    }
                ]
            }
        },
        {
            "id": "lesson-21",
            "title": "Network Forensics in Different Sectors",
            "duration": "90 min",
            "objectives": [
                "Adapt network forensic techniques for the specific needs of the financial services sector.",
                "Understand the unique challenges and priorities of healthcare network forensics.",
                "Analyze network traffic in government and military environments.",
                "Investigate incidents in retail, manufacturing, and other commercial sectors.",
                "Address the specific regulatory requirements for each industry."
            ],
            "content": {
                "overview": "While the technical principles of network forensics are universal, the specific priorities, regulatory pressures, and types of threats vary dramatically by industry. This lesson explores how network forensic investigations are tailored to the unique context of different sectors, from the high-stakes world of finance to the safety-critical environment of healthcare.",
                "sections": [
                    {
                        "title": "Financial Services: Following the Money",
                        "content": "<h3>Priorities: Transaction Integrity, Fraud Detection, Regulatory Compliance (PCI DSS, NYDFS)</h3><p>In finance, the focus of network forensics is often on protecting the integrity of financial transactions and detecting fraud. Investigations frequently involve tracing the network paths of fraudulent wire transfers or analyzing traffic to and from trading platforms to detect market manipulation. The regulatory environment is extremely strict, with regulations like the Payment Card Industry Data Security Standard (PCI DSS) dictating specific security controls and forensic procedures for any network that handles credit card data.</p>",
                        "image": "https://images.unsplash.com/photo-1501167786227-4cba60f6d58f?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Healthcare: Protecting Patients",
                        "content": "<h3>Priorities: Patient Safety, PHI Confidentiality, Availability of Clinical Systems (HIPAA)</h3><p>In healthcare, the overriding priority is patient safety. A network-based attack, such as ransomware on a hospital's network, is not just an IT problem; it's a patient safety crisis. Network forensics in this environment focuses on threats to medical devices, electronic health record (EHR) systems, and ensuring the availability of critical clinical services. The Health Insurance Portability and Accountability Act (HIPAA) dictates strict rules for protecting patient data (PHI) and for breach notification.</p>",
                        "image": "https://images.unsplash.com/photo-1538688273824-7883ea9f586a?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Government and Defense: Protecting National Security",
                        "content": "<h3>Priorities: Confidentiality of Classified Information, Mission Assurance, Counter-espionage</h3><p>Network forensics in government and military environments is focused on detecting and analyzing attacks from nation-state adversaries (APTs). Investigations involve hunting for the subtle signs of long-term espionage campaigns, analyzing sophisticated custom malware, and maintaining an extremely high level of operational security. The primary goal is to protect classified information and ensure that critical government and military missions can be carried out without disruption. Attribution is a key focus, and investigations are often tightly integrated with national intelligence agencies.</p>",
                        "image": "https://images.unsplash.com/photo-1573495782740-62c135d54483?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Sector-Specific Analysis Toolkit (Healthcare - DICOM)",
                        "language": "python",
                        "code": "from scapy.all import rdpcap\n\n# This conceptual Scapy script demonstrates a sector-specific analysis.\n# DICOM is the standard protocol for medical imaging (e.g., X-rays, MRIs).\n# This script could be used in a hospital network to detect unauthorized\n# transfer of patient imaging data.\n\ndef detect_dicom_exfiltration(pcap_file, patient_id_of_interest):\n    \"\"\"Parses a PCAP to find DICOM traffic for a specific patient.\"\"\"\n    packets = rdpcap(pcap_file)\n\n    print(\"Searching for DICOM traffic...\")\n    for packet in packets:\n        # A real implementation would require a full DICOM dissection layer for Scapy.\n        # We are simulating that here.\n        if packet.haslayer(\"DICOM\"):\n            # Simulate accessing a field within the custom DICOM layer\n            patient_id = packet[\"DICOM\"].PatientID\n            if patient_id == patient_id_of_interest:\n                print(f\"[!] Found DICOM traffic for patient {patient_id_of_interest}\")\n                print(f\"    Source: {packet['IP'].src}, Destination: {packet['IP'].dst}\")\n                # An alert would be generated here."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "A network forensic investigation in a retail company that focuses on a breach of credit card data is most directly governed by which regulatory standard?",
                        "options": [
                            "HIPAA",
                            "NERC CIP",
                            "PCI DSS",
                            "FERPA"
                        ],
                        "correct": 2,
                        "explanation": "The Payment Card Industry Data Security Standard (PCI DSS) is the specific regulation that all organizations handling credit card data must follow."
                    },
                    {
                        "id": 2,
                        "question": "In which sector is a network forensic investigation most likely to be focused on threats from nation-state APTs with a goal of espionage?",
                        "options": [
                            "Retail",
                            "Hospitality",
                            "Government and Defense",
                            "Education"
                        ],
                        "correct": 2,
                        "explanation": "Government and defense networks are prime targets for Advanced Persistent Threats (APTs) seeking to steal classified information or conduct intelligence operations, which shapes the entire focus of their network defense and forensic investigations."
                    },
                    {
                        "id": 3,
                        "question": "What is the absolute highest priority during a network forensic investigation of a hospital's network?",
                        "options": [
                            "Patient safety and the continued availability of clinical systems.",
                            "The financial cost of the breach.",
                            "Determining which doctor's workstation was the source.",
                            "Preserving a perfect chain of custody for all evidence."
                        ],
                        "correct": 0,
                        "explanation": "In healthcare, patient safety trumps all other concerns. Any forensic or incident response action must first be evaluated for its potential impact on patient care."
                    }
                ]
            }
        },
        {
            "id": "lesson-22",
            "title": "Threat Intelligence and Network Forensics",
            "duration": "100 min",
            "objectives": [
                "Understand the role of threat intelligence in the forensic process.",
                "Utilize tactical threat intelligence (IoCs) for immediate detection.",
                "Apply operational and strategic intelligence for actor profiling and attribution.",
                "Integrate threat intelligence platforms with network security tools.",
                "Use network evidence to generate and share new threat intelligence.",
                "Drive a proactive, intelligence-driven threat hunting program."
            ],
            "content": {
                "overview": "Network forensics is not just a reactive discipline; it can be a proactive one. This lesson covers the critical integration of threat intelligence with network forensics. We will learn how to use intelligence to find known threats faster, how to use network evidence to understand an adversary's campaign, and how to contribute back to the intelligence community.",
                "sections": [
                    {
                        "title": "The Levels of Threat Intelligence",
                        "content": "<p>Threat intelligence comes in different forms, each with its own use.</p><h3>The Intelligence Pyramid:</h3><ul><li><strong>Strategic Intelligence (Top):</strong> High-level information about the threat landscape. 'Who are the adversaries, and what are their motivations?' Used by the CISO and leadership to guide strategy.</li><li><strong>Operational Intelligence:</strong> Information about an adversary's TTPs (Tactics, Techniques, and Procedures). 'How do they operate?' Used by incident responders and threat hunters.</li><li><strong>Tactical Intelligence (Bottom):</strong> Specific, technical indicators of compromise (IoCs). 'What are their tools?' This includes things like malicious IP addresses, domain names, and file hashes. Used by automated tools like firewalls and IDS.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Intelligence-Driven Investigations",
                        "content": "<p>Threat intelligence makes investigations faster and more effective by providing immediate context.</p><p><strong>Real-world Example:</strong> A firewall log shows a connection to a random IP address. Without intelligence, this is just an anonymous connection. With intelligence, the analyst's SIEM can automatically query a threat intelligence platform. The platform responds instantly: 'This IP address is a known C2 server for the FIN7 cybercrime group.' The analyst immediately knows the incident is high-priority, has a preliminary attribution, and can use their knowledge of FIN7's TTPs to know exactly where to look for other evidence. The investigation is accelerated from hours to minutes.</p>",
                        "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Threat Hunting: Proactive Forensics",
                        "content": "<p>Threat hunting is a proactive forensic investigation. It assumes that a breach has already occurred and that automated defenses have failed. The hunter's job is to proactively search for the subtle signs of that hidden breach.</p><h3>The Hunt Cycle:</h3><ol><li><strong>Hypothesis:</strong> The hunt starts with a hypothesis based on operational threat intelligence. 'I know that APT29 often uses WMI for persistence. I hypothesize they are in our network. I will now hunt for anomalous WMI activity.'</li><li><strong>Investigation:</strong> The hunter uses tools like the SIEM and EDR to search through network and host data for evidence to support or refute the hypothesis.</li><li><strong>Discovery:</strong> The hunter may find evidence of the threat, or they may find nothing. A hunt that finds nothing is still valuable, as it validates that a specific defense is working.</li><li><strong>Enrichment:</strong> If a threat is found, the new IoCs and TTPs are fed back into the threat intelligence platform and used to create new, automated detection rules. A successful hunt should result in a new signature so you never have to hunt for that exact thing again.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1552664730-d307ca884978?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Threat Intelligence Correlation Platform (MISP)",
                        "language": "json",
                        "code": "{\n  \"Event\": {\n    \"info\": \"FIN7 Activity - New C2 Domain\",\n    \"distribution\": \"1\", // Share with this community only\n    \"threat_level_id\": \"2\", // Medium\n    \"analysis\": \"2\", // Complete\n    \"Attribute\": [\n      {\n        \"type\": \"domain\",\n        \"value\": \"updatemicrosoft.info\",\n        \"comment\": \"C2 domain observed in recent phishing campaign.\",\n        \"to_ids\": true // Mark this as an Indicator of Compromise for IDS\n      },\n      {\n        \"type\": \"ip-dst\",\n        \"value\": \"198.51.100.99\",\n        \"to_ids\": true\n      },\n      {\n        \"type\": \"malware-sample\",\n        \"value\": \"malware.exe|d41d8cd98f00b204e9800998ecf8427e\",\n        \"to_ids\": false\n      }\n    ],\n    \"Galaxy\": [\n      {\n        \"name\": \"attck\",\n        \"type\": \"mitre-attack-pattern\",\n        \"description\": \"T1566.001 - Spearphishing Attachment\"\n      }\n    ]\n  }\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "Malicious IP addresses, file hashes, and domain names are examples of what level of threat intelligence?",
                        "options": [
                            "Strategic Intelligence",
                            "Operational Intelligence",
                            "Tactical Intelligence (Indicators of Compromise)",
                            "Human Intelligence"
                        ],
                        "correct": 2,
                        "explanation": "Tactical intelligence consists of the specific, low-level indicators that can be directly plugged into automated security tools (like firewalls and IDS) for immediate blocking and detection."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary goal of a threat hunt?",
                        "options": [
                            "To respond to active alerts from the SIEM.",
                            "To proactively search for evidence of threats that have already bypassed existing automated defenses.",
                            "To test if the firewall is configured correctly.",
                            "To write the incident response plan."
                        ],
                        "correct": 1,
                        "explanation": "Threat hunting is proactive, not reactive. It operates under the assumption of a breach and involves a human analyst actively searching for the subtle signs of a hidden adversary."
                    },
                    {
                        "id": 3,
                        "question": "What should be the ultimate outcome of a successful threat hunt?",
                        "options": [
                            "A long report for management.",
                            "The creation of a new, automated detection rule so that you never have to hunt for that exact threat again.",
                            "A verbal confirmation that nothing was found.",
                            "The purchase of a new security tool."
                        ],
                        "correct": 1,
                        "explanation": "The goal of threat hunting is to improve the automated defenses. Every successful hunt should result in a new signature, correlation rule, or playbook that turns the manual discovery into an automated detection for the future."
                    }
                ]
            }
        },
        {
            "id": "lesson-23",
            "title": "Network Forensics Quality Management",
            "duration": "90 min",
            "objectives": [
                "Establish a quality assurance framework for network forensic investigations.",
                "Implement a formal peer review process for analysis and reports.",
                "Develop and follow Standard Operating Procedures (SOPs).",
                "Create a program for tool and technique validation.",
                "Verify the reproducibility of forensic findings.",
                "Measure performance and implement a continuous improvement program."
            ],
            "content": {
                "overview": "To be defensible in court and trusted by stakeholders, the findings of a network forensic investigation must be accurate, consistent, and reproducible. This lesson covers the essential elements of a quality management system for a network forensics lab, ensuring that all processes meet rigorous scientific and legal standards.",
                "sections": [
                    {
                        "title": "Standard Operating Procedures (SOPs)",
                        "content": "<p>An SOP is a detailed, written, step-by-step set of instructions for performing a routine task. A network forensics lab should have an SOP for every major function, from evidence intake to packet capture to final report generation.</p><h3>Benefits of SOPs:</h3><ul><li><strong>Consistency:</strong> Ensures every analyst performs a task in the exact same, approved way.</li><li><strong>Defensibility:</strong> In court, an analyst can show they followed a documented, standard procedure, which strengthens their credibility.</li><li><strong>Training:</strong> SOPs are an invaluable tool for training new analysts.</li><li><strong>Error Reduction:</strong> An SOP acts as a checklist, reducing the chance of forgetting a critical step under pressure.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Peer Review and Reproducibility",
                        "content": "<p>These are the core scientific principles that ensure quality.</p><ul><li><strong>Peer Review:</strong> Before any report is finalized, it must be reviewed by another qualified analyst. The technical reviewer checks for errors, confirms that the conclusions are supported by the data, and validates the methodology.</li><li><strong>Reproducibility:</strong> This is the ultimate test. It means that another qualified analyst, given the same evidence and the same documented notes, should be able to follow the process and arrive at the exact same conclusion. This proves that the finding is objective and not just the opinion of one individual.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Continuous Improvement",
                        "content": "<p>A quality management program is not a static document; it's a living process. Every investigation, exercise, and peer review provides an opportunity to learn and improve.</p><p><strong>Real-world Example:</strong> During a peer review of an investigation, the reviewer notices that the analyst misinterpreted the flags in a specific TCP packet. While the mistake did not change the ultimate conclusion of the case, it is identified as a training gap. The lab manager uses this as an opportunity to hold a 30-minute training session for the entire team on advanced TCP flag analysis. This is a perfect example of a continuous improvement loop: the peer review process identified a weakness, and a training action was taken to correct it for the future.</p>",
                        "image": "https://images.unsplash.com/photo-1454165804606-c3d57bc86b40?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Quality Management Automation System (Conceptual)",
                        "language": "python",
                        "code": "import hashlib\n\n# This conceptual script demonstrates a QA check to ensure that the hash of the\n# primary evidence file (PCAP) is correctly recorded in the final report.\n\ndef validate_report_evidence_hash(report_file, pcap_file):\n    \"\"\"Checks if the hash in a report matches the actual evidence hash.\"\"\"\n    # 1. Read the hash value recorded in the report file.\n    # (Assuming the report is structured, e.g., JSON)\n    # report_hash = get_hash_from_report(report_file)\n    report_hash = \"d41d8cd98f00b204e9800998ecf8427e...\"\n\n    # 2. Calculate the actual hash of the evidence file.\n    print(f\"[*] Calculating SHA256 of {pcap_file}...\")\n    actual_hash = hashlib.sha256(open(pcap_file, 'rb').read()).hexdigest()\n    print(f\"[*] Actual Hash: {actual_hash}\")\n\n    # 3. Compare the two.\n    if report_hash == actual_hash:\n        print(\"[SUCCESS] QA Check Passed: Evidence hash in report is correct.\")\n        return True\n    else:\n        print(\"[FAILURE] QA Check Failed: Hash in report does not match evidence!\")\n        return False\n\n# This automated check prevents a simple but critical documentation error."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary purpose of having Standard Operating Procedures (SOPs) in a forensic lab?",
                        "options": [
                            "To make investigations more complicated.",
                            "To ensure that every task is performed in a consistent, repeatable, and defensible manner by all analysts.",
                            "To give the lab manager more control.",
                            "To replace the need for expert analysts."
                        ],
                        "correct": 1,
                        "explanation": "SOPs are the foundation of quality management. They ensure consistency and provide a documented, defensible process that can be presented and validated in court."
                    },
                    {
                        "id": 2,
                        "question": "The principle that another qualified analyst should be able to follow your notes and arrive at the same conclusion is known as:",
                        "options": [
                            "Validation",
                            "Peer Review",
                            "Reproducibility",
                            "Accreditation"
                        ],
                        "correct": 2,
                        "explanation": "Reproducibility is a core tenet of the scientific method and is essential for forensic findings to be considered reliable and objective."
                    },
                    {
                        "id": 3,
                        "question": "What is a 'technical peer review' in the context of a forensic report?",
                        "options": [
                            "A check for spelling and grammar.",
                            "A review by the legal department.",
                            "A review by another qualified analyst to check for technical errors and ensure the conclusions are supported by the evidence.",
                            "A review by the client."
                        ],
                        "correct": 2,
                        "explanation": "The technical peer review is a critical quality control step. It's a sanity check by a colleague to catch any mistakes or unsupported conclusions before the report is finalized."
                    }
                ]
            }
        },
        {
            "id": "lesson-24",
            "title": "Advanced Research and Future Technologies",
            "duration": "90 min",
            "objectives": [
                "Discuss the future forensic implications of quantum networking.",
                "Understand how AI will be used for both attack and defense on networks.",
                "Prepare for the forensic challenges of 6G and future wireless technologies.",
                "Consider the investigation of satellite and space-based network communications.",
                "Analyze the impact of emerging technologies like brain-computer interfaces and biotechnology on network forensics.",
                "Commit to a process of continuous learning and research to stay ahead of adversaries."
            ],
            "content": {
                "overview": "The field of network forensics is in a constant race with technological innovation. The networks of tomorrow will be fundamentally different from the networks of today. This final lesson looks to the horizon, exploring the future challenges that will shape the next generation of network investigation and the importance of a research-oriented mindset.",
                "sections": [
                    {
                        "title": "Quantum Networking and Cryptography",
                        "content": "<p>Quantum technology will fundamentally change network security and forensics.</p><ul><li><strong>The Threat:</strong> A cryptographically relevant quantum computer will be able to break the public-key encryption (like RSA) that underpins HTTPS, VPNs, and most secure communication today.</li><li><strong>The Opportunity:</strong> Quantum Key Distribution (QKD) is a new technology that allows two parties to share an encryption key with the guarantee that any attempt to eavesdrop on the key exchange will be detected.</li></ul><p><strong>Forensic Implication:</strong> In a future QKD-secured network, it may become physically impossible to passively intercept and decrypt traffic. The focus of forensics will have to shift even more heavily towards endpoint analysis and log correlation.</p>",
                        "image": "https://images.unsplash.com/photo-1635070049035-5a79a8385075?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "AI-Driven Network Analysis",
                        "content": "<p>As discussed, AI and machine learning are becoming central to network defense. This trend will only accelerate.</p><h3>The Future of the SOC:</h3><p>The future security operations center will likely involve a human analyst working in partnership with an AI. The AI will perform the massive-scale, real-time analysis of network data, automatically detecting anomalies and correlating events. It will then present a summarized, high-confidence alert to the human analyst. The human's role will shift from being a data-sifter to being a high-level investigator and threat hunter, using their intuition and experience to investigate the complex threats that the AI has already identified and triaged.</p>",
                        "image": "https://images.unsplash.com/photo-1620712943543-285f212a5a54?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The Need for Continuous Learning",
                        "content": "<p>Technology does not stand still, and neither do adversaries. A network forensic investigator's skills have a half-life. The tools and techniques that are cutting-edge today will be obsolete in a few years.</p><p>A career in this field is not just a job; it is a commitment to being a lifelong learner. It requires a constant process of reading research papers, attending conferences, participating in CTFs, and experimenting with new tools and technologies. The future of network forensics belongs to those who are curious, adaptable, and relentlessly dedicated to staying one step ahead of the next threat.</p>",
                        "image": "https://images.unsplash.com/photo-1522071820081-009f0129c71c?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Next-Generation Forensic Framework (Conceptual)",
                        "language": "python",
                        "code": "class FutureForensicFramework:\n    def __init__(self):\n        # The AI model is the core of the system\n        self.ai_correlation_engine = self.load_ai_model()\n\n    def ingest_data_stream(self, data, source_type):\n        # Ingests data from any source: traditional network, IoT, even biometric data\n        pass\n\n    def investigate(self, initial_hypothesis):\n        \"\"\"The human analyst provides a high-level hypothesis.\"\"\"\n        print(f\"[*] Human analyst hypothesis: '{initial_hypothesis}'\")\n        \n        # The AI engine autonomously queries all available data streams,\n        # finds correlations, and generates a report.\n        print(\"[*] AI Engine: Correlating billions of events across all sources...\")\n        ai_findings = self.ai_correlation_engine.find_supporting_evidence(initial_hypothesis)\n        \n        print(\"[*] AI Engine: Findings report generated.\")\n        return ai_findings\n\n# The future workflow is a partnership: the human provides the strategic question,\n# and the AI performs the massive-scale data analysis to find the answer."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary long-term threat that quantum computing poses to network forensics?",
                        "options": [
                            "It will make the internet too fast to monitor.",
                            "It will be able to break the public-key encryption that currently protects most network traffic.",
                            "It will generate too many log files.",
                            "It will make computers too expensive."
                        ],
                        "correct": 1,
                        "explanation": "A cryptographically relevant quantum computer would render much of our current encryption useless, fundamentally changing the landscape of secure communication and the forensic analysis of it."
                    },
                    {
                        "id": 2,
                        "question": "In a future, AI-driven Security Operations Center (SOC), what is the likely role of the human analyst?",
                        "options": [
                            "They will be replaced by the AI.",
                            "Their role will shift from low-level data sifting to high-level investigation, threat hunting, and strategic analysis of the alerts generated by the AI.",
                            "They will be responsible for plugging in the AI.",
                            "They will focus only on physical security."
                        ],
                        "correct": 1,
                        "explanation": "AI will automate the high-volume, low-level tasks, freeing up human experts to focus on the complex, intuitive, and creative aspects of investigation that machines cannot yet do."
                    },
                    {
                        "id": 3,
                        "question": "What is the single most important skill for a long-term career in network forensics?",
                        "options": [
                            "Mastery of a single forensic tool.",
                            "A commitment to continuous learning and adaptation.",
                            "The ability to write long reports.",
                            "A degree in computer science."
                        ],
                        "correct": 1,
                        "explanation": "The technology and the adversaries are constantly changing. The only way to remain effective in this field is to be a lifelong learner who is constantly updating their skills and knowledge."
                    }
                ]
            }
        }
    ]
    }


      // =====================================================
      // GLOBAL VARIABLES
      // =====================================================
      let currentUser = null;
      let currentLessonIndex = 0;
      let courseProgress = {};
      let userStats = {};
      let quizState = {
        currentQuestion: 0,
        answers: [],
        score: 0,
        isComplete: false,
        timeStarted: null,
        timeCompleted: null,
        currentQuestionIndex: 0,
      };

      // Enhanced session tracking
      let courseSession = {
        startTime: null,
        totalStudyTime: 0,
        lessonsStarted: 0,
        lessonsCompleted: 0,
        pageLoadTime: new Date(),
        lastActive: new Date(),
        interactions: 0,
        completedSections: [],
        totalTime: 0,
        interactionCount: 0,
        lastActivityTime: new Date(),
      };

      // Music Player Variables
      let audioPlayer = new Audio();

      // Achievement notification system
      let notificationQueue = [];
      let isShowingNotification = false;

      // =====================================================
      // INITIALIZATION
      // =====================================================
      document.addEventListener("DOMContentLoaded", async () => {
        try {
          showLoadingScreen();
          await checkAuth();

          if (currentUser) {
            // Initialize session tracking
            startCourseSession();

            // Load course data and progress
            await loadCourseData();
            await loadUserProfile();
            await loadProgress();

            // Initialize UI
            initializeEventListeners();
            renderSidebar();
            loadLesson(currentLessonIndex);

            // Initialize additional features
            initMusicPlayer();
            addMusicIndicator();
            initializeActivityTracking();

            hideLoadingScreen();
          } else {
            openAuthModal();
          }
        } catch (error) {
          console.error("Error initializing course:", error);
          hideLoadingScreen();
          showToast("Failed to initialize course system", "error");
        }
      });

      // =====================================================
      // AUTHENTICATION SYSTEM
      // =====================================================
      async function checkAuth() {
        try {
          const {
            data: { session },
            error,
          } = await supabase.auth.getSession();

          if (error) {
            console.error("Auth error:", error);
            currentUser = null;
            openAuthModal();
            return;
          }

          if (!session) {
            currentUser = null;
            openAuthModal();
            return;
          }

          currentUser = session.user;
          updateUIWithUser();
        } catch (error) {
          console.error("Error checking auth:", error);
          currentUser = null;
          openAuthModal();
        }
      }

      function updateUIWithUser() {
        if (!currentUser) return;

        const name =
          currentUser.user_metadata?.full_name ||
          currentUser.email.split("@")[0];
        const userElements = document.querySelectorAll("[data-user-name]");
        userElements.forEach((el) => (el.textContent = name));
      }

      // =====================================================
      // USER PROFILE & STATS MANAGEMENT
      // =====================================================
      async function loadUserProfile() {
        try {
          // 🔍 Step 1: Try to fetch existing profile
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("*")
            .eq("id", currentUser.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (!profile) {
            // 🆕 Step 2: Create new profile if missing
            await createUserProfile();
          } else {
            // ✅ Step 3: Use existing profile
            userStats = profile;
            await updateLastActivity();
          }
        } catch (error) {
          console.error("❌ Error loading user profile:", error);
          showToast("Failed to load user profile", "error");
        }
      }
      async function createUserProfile() {
        try {
          const newProfile = {
            id: currentUser.id,
            full_name: currentUser.user_metadata?.full_name || "",
            email: currentUser.email,
            level: "Script Kiddie",
            total_points: 0,
            completed_courses: 0,
            current_streak: 0,
            total_certificates: 0,
            total_achievements: 0,
            sections_visited: 0,
            bonus_points: 0,
            in_progress_courses: 0,
            settings_changed: 0,
            midnight_sessions: 0,
            early_sessions: 0,
            weekend_sessions: 0,
            last_activity: new Date().toISOString(),
            created_at: new Date().toISOString(),
          };

          const { error } = await supabase
            .from("profiles")
            .insert([newProfile]);

          if (!error) {
            userStats = newProfile;
            // Award first login achievement
            setTimeout(() => checkAndUnlockAchievement("first_login"), 1000);
          }
        } catch (error) {
          console.error("Error creating user profile:", error);
        }
      }

      async function updateLastActivity() {
        try {
          const now = new Date();

          // Update activity tracking
          courseSession.lastActivityTime = now;

          // Update database
          await supabase
            .from("profiles")
            .update({
              last_activity: now.toISOString(),
            })
            .eq("id", currentUser.id);

          // Check time-based achievements
          await checkTimeBasedAchievements(now);
        } catch (error) {
          console.error("Error updating last activity:", error);
        }
      }

      // =====================================================
      // COURSE SESSION MANAGEMENT
      // =====================================================
      function startCourseSession() {
        courseSession.startTime = new Date();
        courseSession.pageLoadTime = new Date();

        logUserActivity("course_session_start", {
          course_id: COURSE_DATA.id,
          course_title: COURSE_DATA.title,
          user_agent: navigator.userAgent,
          screen_resolution: `${screen.width}x${screen.height}`,
        });

        // Check daily streak
        checkDailyStreak();
      }

      function initializeActivityTracking() {
        // Track page focus/blur for accurate study time
        document.addEventListener("visibilitychange", handleVisibilityChange);

        // Track user interactions
        ["click", "keydown", "scroll", "mousemove"].forEach((event) => {
          document.addEventListener(event, trackUserInteraction, {
            passive: true,
          });
        });

        // Periodic activity updates
        setInterval(updateStudyTime, 60000); // Every minute

        // Save session data before page unload
        window.addEventListener("beforeunload", saveSessionData);
      }

      function handleVisibilityChange() {
        if (document.hidden) {
          courseSession.lastActivityTime = new Date();
        } else {
          // Page became visible again - update activity
          updateLastActivity();
        }
      }

      function trackUserInteraction() {
        courseSession.interactionCount++;
        courseSession.lastActivityTime = new Date();

        // Throttle activity updates
        if (courseSession.interactionCount % 50 === 0) {
          updateLastActivity();
        }
      }

      function updateStudyTime() {
        if (!courseSession.startTime || document.hidden) return;

        const now = new Date();
        const sessionDuration = now - courseSession.startTime;
        courseSession.totalStudyTime = Math.floor(sessionDuration / 1000 / 60); // in minutes

        // Update progress with study time
        saveProgress();
      }

      function saveSessionData() {
        if (!currentUser || !courseSession.startTime) return;

        const sessionData = {
          user_id: currentUser.id,
          course_id: COURSE_DATA.id,
          session_duration: courseSession.totalStudyTime,
          lessons_viewed: courseSession.lessonsStarted,
          lessons_completed: courseSession.lessonsCompleted,
          interactions: courseSession.interactionCount,
          session_date: courseSession.startTime.toISOString().split("T")[0],
        };

        // Store in localStorage as backup
        localStorage.setItem(
          "course_session_backup",
          JSON.stringify(sessionData)
        );

        // Try to save to database
        logUserActivity("course_session_end", sessionData);
      }

      // =====================================================
      // COURSE DATA & PROGRESS MANAGEMENT
      // =====================================================
      async function loadCourseData() {
        try {
          // Update course info in UI
          document.getElementById("courseTitle").textContent =
            COURSE_DATA.title;
          document.getElementById("totalLessons").textContent =
            COURSE_DATA.lessons.length;

          // Log course access
          logUserActivity("course_access", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
          });
        } catch (error) {
          console.error("Error loading course data:", error);
        }
      }

      async function loadProgress() {
        try {
          // Get existing progress from database
          const { data, error } = await supabase
            .from("course_progress")
            .select("*")
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (data) {
            courseProgress = JSON.parse(data.lesson_progress || "{}");
            currentLessonIndex = data.current_lesson || 0;

            // Update session tracking
            courseSession.lessonsStarted = Object.keys(courseProgress).length;
            courseSession.lessonsCompleted = Object.values(
              courseProgress
            ).filter((p) => p.completed).length;
          } else {
            // Initialize new progress
            courseProgress = {};
            currentLessonIndex = 0;
            await saveProgress();

            // Award first course start achievement
            await checkAndUnlockAchievement("first_course_start");
          }

          updateProgressDisplay();
        } catch (error) {
          console.error("Error loading progress:", error);
          showToast("Failed to load progress", "error");
        }
      }

      async function saveProgress() {
        try {
          if (!currentUser) return;

          const now = new Date();
          const progressData = {
            user_id: currentUser.id,
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            current_lesson: currentLessonIndex,
            lesson_progress: JSON.stringify(courseProgress),
            progress: calculateOverallProgress(),
            lessons_completed: getCompletedLessonsCount(),
            lessons_started: Object.keys(courseProgress).length,
            study_time_minutes: courseSession.totalStudyTime,
            last_accessed: now.toISOString(),
            updated_at: now.toISOString(),
          };

          // Upsert progress
          const { error } = await supabase
            .from("course_progress")
            .upsert([progressData]);

          if (error) throw error;

          // Update user stats
          await updateUserStats();

          updateProgressDisplay();
        } catch (error) {
          console.error("Error saving progress:", error);
          showToast("Failed to save progress", "error");
        }
      }

      async function updateUserStats() {
        try {
          // Get all course progress for this user
          const { data: allProgress, error } = await supabase
            .from("course_progress")
            .select("progress, course_id, study_time_minutes")
            .eq("user_id", currentUser.id);

          if (error) throw error;

          // Calculate stats
          const completedCourses =
            allProgress?.filter((p) => p.progress >= 100).length || 0;
          const inProgressCourses =
            allProgress?.filter((p) => p.progress > 0 && p.progress < 100)
              .length || 0;
          const totalStudyTime =
            allProgress?.reduce(
              (sum, p) => sum + (p.study_time_minutes || 0),
              0
            ) || 0;

          // Calculate points (500 per completed course + achievement points)
          const coursePoints = completedCourses * 500;
          const bonusPoints = userStats.bonus_points || 0;
          const totalPoints = coursePoints + bonusPoints;

          // Update profile
          const updateData = {
            completed_courses: completedCourses,
            in_progress_courses: inProgressCourses,
            total_points: totalPoints,
            total_study_time: totalStudyTime,
            last_activity: new Date().toISOString(),
          };

          const { error: updateError } = await supabase
            .from("profiles")
            .update(updateData)
            .eq("id", currentUser.id);

          if (updateError) throw updateError;

          // Update local stats
          Object.assign(userStats, updateData);
        } catch (error) {
          console.error("Error updating user stats:", error);
        }
      }

      function calculateOverallProgress() {
        const completedLessons = getCompletedLessonsCount();
        return Math.round(
          (completedLessons / COURSE_DATA.lessons.length) * 100
        );
      }

      function getCompletedLessonsCount() {
        return Object.values(courseProgress).filter(
          (lesson) => lesson.completed
        ).length;
      }

      function updateProgressDisplay() {
        const completedCount = getCompletedLessonsCount();
        const progressPercent = calculateOverallProgress();

        // Update UI elements
        const elements = {
          completedLessons: completedCount,
          courseProgressPercent: `${progressPercent}%`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });

        // Update progress bar
        const progressBar = document.getElementById("courseProgressFill");
        if (progressBar) progressBar.style.width = `${progressPercent}%`;
      }

      // =====================================================
      // LESSON MANAGEMENT
      // =====================================================
      function loadLesson(index) {
        if (index < 0 || index >= COURSE_DATA.lessons.length) return;

        const lesson = COURSE_DATA.lessons[index];
        currentLessonIndex = index;

        // Mark lesson as started and track activity
        if (!courseProgress[lesson.id]) {
          courseProgress[lesson.id] = {
            started: true,
            completed: false,
            startedAt: new Date().toISOString(),
            timeSpent: 0,
          };

          courseSession.lessonsStarted++;
          saveProgress();

          // Log lesson start
          logUserActivity("lesson_start", {
            lesson_id: lesson.id,
            lesson_title: lesson.title,
            lesson_index: index,
          });
        }

        // Update lesson start time for time tracking
        courseProgress[lesson.id].currentSessionStart = new Date();

        // Update sidebar and navigation
        renderSidebar();
        updateNavigationButtons();

        // Update header info
        updateLessonHeader(lesson, index);

        // Render lesson content
        renderLessonContent(lesson);

        // Smooth scroll and animations
        window.scrollTo({ top: 0, behavior: "smooth" });
        document.getElementById("contentBody").scrollTop = 0;

        const contentBody = document.getElementById("contentBody");
        contentBody.classList.add("fade-in");
        setTimeout(() => contentBody.classList.remove("fade-in"), 500);

        // Check lesson-based achievements
        checkLessonAchievements(index + 1);
      }

      function updateLessonHeader(lesson, index) {
        const elements = {
          currentLessonNumber: index + 1,
          currentLessonTitle: lesson.title,
          navInfo: `Lesson ${index + 1} of ${COURSE_DATA.lessons.length}`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });
      }

      function renderSidebar() {
        const lessonNav = document.getElementById("lessonNav");
        if (!lessonNav) return;

        lessonNav.innerHTML = "";

        COURSE_DATA.lessons.forEach((lesson, index) => {
          const lessonItem = document.createElement("div");
          lessonItem.className = "lesson-item";

          // Determine lesson status
          const lessonProgress = courseProgress[lesson.id];
          const isCompleted = lessonProgress?.completed || false;
          const isInProgress = lessonProgress?.started || false;
          const isLocked = !isCompleted && !canAccessLesson(index);
          const isActive = index === currentLessonIndex;

          // Apply status classes
          if (isCompleted) lessonItem.classList.add("completed");
          if (isLocked) lessonItem.classList.add("locked");
          if (isActive) lessonItem.classList.add("active");

          // Determine status display
          let statusClass = "not-started";
          let statusIcon = index + 1;

          if (isCompleted) {
            statusClass = "completed";
            statusIcon = "✓";
          } else if (isInProgress) {
            statusClass = "in-progress";
            statusIcon = "◐";
          }

          // Create lesson item HTML
          lessonItem.innerHTML = `
            <div class="lesson-status ${statusClass}">${statusIcon}</div>
            <div class="lesson-info">
                <div class="lesson-title">${lesson.title}</div>
                <div class="lesson-meta">
                    ${
                      isCompleted
                        ? "Completed"
                        : isInProgress
                        ? "In Progress"
                        : isLocked
                        ? "Locked"
                        : "Not Started"
                    }
                </div>
            </div>
            <div class="lesson-duration">${lesson.duration}</div>
        `;

          // Add click handler if not locked
          if (!isLocked) {
            lessonItem.addEventListener("click", () => {
              if (index !== currentLessonIndex) {
                // Track lesson time before switching
                trackLessonTime();

                currentLessonIndex = index;
                loadLesson(index);
                closeSidebar();
              }
            });
          }

          lessonNav.appendChild(lessonItem);
        });
      }

      function canAccessLesson(index) {
        if (index === 0) return true; // First lesson always accessible

        // Can access if previous lesson is completed
        const previousLessonId = COURSE_DATA.lessons[index - 1].id;
        return courseProgress[previousLessonId]?.completed || false;
      }

      function trackLessonTime() {
        const currentLesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonProgress = courseProgress[currentLesson.id];

        if (lessonProgress?.currentSessionStart) {
          const sessionTime = Math.floor(
            (new Date() - new Date(lessonProgress.currentSessionStart)) /
              1000 /
              60
          );
          lessonProgress.timeSpent =
            (lessonProgress.timeSpent || 0) + sessionTime;
          delete lessonProgress.currentSessionStart;
        }
      }

      // =====================================================
      // LESSON CONTENT RENDERING
      // =====================================================
      function renderLessonContent(lesson) {
        const contentContainer = document.getElementById("lessonContent");
        if (!contentContainer) return;

        let contentHTML = `
        <div class="content-section">
            <h2>Learning Objectives</h2>
            <ul>
                ${lesson.objectives.map((obj) => `<li>${obj}</li>`).join("")}
            </ul>
        </div>
        
        <div class="content-section">
            <h2>Overview</h2>
            <p>${lesson.content.overview}</p>
        </div>
    `;

        // Render content sections
        lesson.content.sections.forEach((section) => {
          contentHTML += `
            <div class="content-section">
                <h2>${section.title}</h2>
                ${section.content}
                ${
                  section.image
                    ? `<img src="${section.image}" alt="${section.title}" class="content-image" loading="lazy">`
                    : ""
                }
            </div>
        `;
        });

        // Render code examples
        if (
          lesson.content.codeExamples &&
          lesson.content.codeExamples.length > 0
        ) {
          contentHTML += `<div class="content-section"><h2>Code Examples</h2></div>`;

          lesson.content.codeExamples.forEach((example, index) => {
            const codeId = `code-${lesson.id}-${index}`;
            contentHTML += `
                <div class="code-section">
                    <div class="code-header">
                        <span class="code-title">${example.title}</span>
                        <button class="copy-btn" onclick="copyCode('${codeId}')">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <pre class="code-block"><code id="${codeId}" class="language-${
              example.language
            }">${escapeHtml(example.code)}</code></pre>
                </div>
            `;
          });
        }

        // Render quiz
        contentHTML += renderQuiz(lesson.quiz);

        contentContainer.innerHTML = contentHTML;

        // Highlight code syntax if Prism is available
        setTimeout(() => {
          if (window.Prism) {
            Prism.highlightAll();
          }
        }, 100);
      }

      // =====================================================
      // QUIZ SYSTEM
      // =====================================================
      function renderQuiz(quiz) {
        const currentLessonProgress =
          courseProgress[COURSE_DATA.lessons[currentLessonIndex].id];
        const isCompleted = currentLessonProgress?.completed || false;

        let quizHTML = `
        <div class="quiz-section" id="quizSection">
            <div class="quiz-header">
                <h2 class="quiz-title">
                    <i class="fas fa-clipboard-check"></i>
                    Knowledge Check
                </h2>
                <p class="quiz-info">
                    Complete this quiz with ${quiz.passingScore}% or higher to unlock the next lesson.
                </p>
            </div>
    `;

        if (isCompleted) {
          const savedScore = currentLessonProgress.quizScore || 0;
          quizHTML += `
            <div class="quiz-results show">
                <div class="quiz-score pass">${savedScore}%</div>
                <div class="quiz-message">
                    <strong>Lesson Completed!</strong><br>
                    You've successfully passed this lesson's quiz.
                </div>
            </div>
        `;
        } else {
          // Render quiz questions
          quiz.questions.forEach((question, qIndex) => {
            quizHTML += `
                <div class="quiz-question ${
                  qIndex === 0 ? "active" : ""
                }" data-question="${qIndex}">
                    <div class="question-header">
                        <span class="question-number">Question ${
                          qIndex + 1
                        }</span>
                        <span class="question-progress">${qIndex + 1}/${
              quiz.questions.length
            }</span>
                    </div>
                    <div class="question-text">${question.question}</div>
                    <div class="question-options">
                        ${question.options
                          .map(
                            (option, oIndex) => `
                            <div class="option" data-option="${oIndex}" onclick="selectOption(${qIndex}, ${oIndex})">
                                <span class="option-letter">${String.fromCharCode(
                                  65 + oIndex
                                )}</span>
                                <span class="option-text">${option}</span>
                            </div>
                        `
                          )
                          .join("")}
                    </div>
                </div>
            `;
          });

          quizHTML += `
            <div class="quiz-controls">
                <button class="btn btn-secondary" id="prevQuestionBtn" onclick="previousQuestion()" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <div>
                    <button class="btn btn-secondary" id="nextQuestionBtn" onclick="nextQuestion()" disabled>
                        Next
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <button class="btn btn-primary" id="submitQuizBtn" onclick="submitQuiz()" style="display: none;">
                        <i class="fas fa-check"></i>
                        Submit Quiz
                    </button>
                </div>
            </div>

            <div class="quiz-results" id="quizResults">
                <div class="quiz-score" id="quizScore">0%</div>
                <div class="quiz-message" id="quizMessage"></div>
                <div class="quiz-actions">
                    <button class="btn btn-primary" id="continueBtn" onclick="completeLesson()" style="display: none;">
                        <i class="fas fa-arrow-right"></i>
                        Continue to Next Lesson
                    </button>
                    <button class="btn btn-secondary" onclick="retakeQuiz()">
                        <i class="fas fa-redo"></i>
                        Retake Quiz
                    </button>
                </div>
            </div>
        `;
        }

        quizHTML += "</div>";
        return quizHTML;
      }

      // Quiz interaction functions
      function selectOption(questionIndex, optionIndex) {
        // Clear previous selections
        document
          .querySelectorAll(`[data-question="${questionIndex}"] .option`)
          .forEach((opt) => {
            opt.classList.remove("selected");
          });

        // Select current option
        const selectedOption = document.querySelector(
          `[data-question="${questionIndex}"] [data-option="${optionIndex}"]`
        );
        selectedOption.classList.add("selected");

        // Store answer
        quizState.answers[questionIndex] = optionIndex;

        // Update navigation
        const isLastQuestion =
          questionIndex ===
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length - 1;
        if (isLastQuestion) {
          document.getElementById("submitQuizBtn").style.display =
            "inline-flex";
          document.getElementById("nextQuestionBtn").style.display = "none";
        } else {
          document.getElementById("nextQuestionBtn").disabled = false;
        }
      }

      function nextQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const nextQuestionEl = currentQuestionEl.nextElementSibling;

        if (
          nextQuestionEl &&
          nextQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          nextQuestionEl.classList.add("active");
          quizState.currentQuestion++;
          updateQuizNavigation();
        }
      }

      function previousQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const prevQuestionEl = currentQuestionEl.previousElementSibling;

        if (
          prevQuestionEl &&
          prevQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          prevQuestionEl.classList.add("active");
          quizState.currentQuestion--;
          updateQuizNavigation();
        }
      }

      function updateQuizNavigation() {
        const totalQuestions =
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length;
        const prevBtn = document.getElementById("prevQuestionBtn");
        const nextBtn = document.getElementById("nextQuestionBtn");
        const submitBtn = document.getElementById("submitQuizBtn");

        prevBtn.disabled = quizState.currentQuestion === 0;

        const hasAnswer =
          quizState.answers[quizState.currentQuestion] !== undefined;
        const isLastQuestion = quizState.currentQuestion === totalQuestions - 1;

        if (isLastQuestion) {
          nextBtn.style.display = "none";
          submitBtn.style.display = hasAnswer ? "inline-flex" : "none";
        } else {
          nextBtn.style.display = "inline-flex";
          nextBtn.disabled = !hasAnswer;
          submitBtn.style.display = "none";
        }
      }

      async function submitQuiz() {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const quiz = lesson.quiz;
        let correctAnswers = 0;

        // Hide questions and controls
        document
          .querySelectorAll(".quiz-question")
          .forEach((q) => (q.style.display = "none"));
        document.querySelector(".quiz-controls").style.display = "none";

        // Calculate score and highlight answers
        quiz.questions.forEach((question, index) => {
          const userAnswer = quizState.answers[index];
          const correctAnswer = question.correct;
          const isCorrect = userAnswer === correctAnswer;

          if (isCorrect) correctAnswers++;

          // Highlight answers
          const questionEl = document.querySelector(
            `[data-question="${index}"]`
          );
          const options = questionEl.querySelectorAll(".option");

          options[correctAnswer].classList.add("correct");
          if (userAnswer !== correctAnswer && userAnswer !== undefined) {
            options[userAnswer].classList.add("incorrect");
          }
        });

        const score = Math.round(
          (correctAnswers / quiz.questions.length) * 100
        );
        const passed = score >= quiz.passingScore;

        // Update quiz results UI
        const quizScore = document.getElementById("quizScore");
        const quizMessage = document.getElementById("quizMessage");
        const quizActions = document.querySelector(".quiz-actions");

        quizScore.textContent = `${score}%`;
        quizScore.className = `quiz-score ${passed ? "pass" : "fail"}`;

        if (passed) {
          quizMessage.innerHTML = `
            <strong>Congratulations!</strong><br>
            You passed with ${score}%. You can now proceed to the next lesson.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-primary" onclick="completeLesson()">
                <i class="fas fa-arrow-right"></i>
                Continue to Next Lesson
            </button>
        `;

          // Mark lesson as completed
          await markLessonComplete(score);
        } else {
          quizMessage.innerHTML = `
            <strong>Not quite there yet.</strong><br>
            You scored ${score}%. You need ${quiz.passingScore}% to pass. Review the material and try again.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-secondary" onclick="retakeQuiz()">
                <i class="fas fa-redo"></i>
                Retake Quiz
            </button>
        `;
        }

        document.getElementById("quizResults").classList.add("show");

        // Log quiz completion
        logUserActivity("quiz_completed", {
          lesson_id: lesson.id,
          lesson_title: lesson.title,
          score: score,
          passed: passed,
          attempts: (courseProgress[lesson.id]?.quizAttempts || 0) + 1,
        });

        // Scroll to results
        document
          .getElementById("quizResults")
          .scrollIntoView({ behavior: "smooth" });
      }

      function retakeQuiz() {
        // Reset quiz state
        quizState = {
          currentQuestion: 0,
          answers: [],
          score: 0,
          isComplete: false,
        };

        // Track quiz retry
        const lessonId = COURSE_DATA.lessons[currentLessonIndex].id;
        if (!courseProgress[lessonId]) courseProgress[lessonId] = {};
        courseProgress[lessonId].quizAttempts =
          (courseProgress[lessonId].quizAttempts || 0) + 1;

        // Reload lesson content
        loadLesson(currentLessonIndex);

        // Scroll to quiz
        setTimeout(() => {
          document
            .getElementById("quizSection")
            .scrollIntoView({ behavior: "smooth" });
        }, 500);
      }

      async function markLessonComplete(score) {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonId = lesson.id;

        // Track lesson completion time
        trackLessonTime();

        // Update lesson progress
        courseProgress[lessonId] = {
          ...courseProgress[lessonId],
          completed: true,
          quizScore: score,
          completedAt: new Date().toISOString(),
          finalScore: score,
        };

        // Update session tracking
        courseSession.lessonsCompleted++;

        // Save progress to database
        await saveProgress();

        // Update UI
        renderSidebar();
        updateNavigationButtons();

        // Check various achievements
        await checkLessonCompletionAchievements();
        await checkPerfectScoreAchievements(score);
        await checkStudyTimeAchievements();

        // Log lesson completion
        logUserActivity("lesson_completed", {
          lesson_id: lessonId,
          lesson_title: lesson.title,
          final_score: score,
          time_spent: courseProgress[lessonId].timeSpent || 0,
          lesson_number: currentLessonIndex + 1,
        });

        showToast("Lesson completed successfully!", "success");
      }

      async function completeLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          // Move to next lesson
          currentLessonIndex++;
          loadLesson(currentLessonIndex);
        } else {
          // Course completion
          await completeCourse();
        }
      }

      async function completeCourse() {
        try {
          const completionTime = courseSession.totalStudyTime;

          // Update course progress to 100% completed
          await supabase
            .from("course_progress")
            .update({
              progress: 100,
              completed_at: new Date().toISOString(),
              completion_time_minutes: completionTime,
            })
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Award course completion achievements
          await checkAndUnlockAchievement("course_completion_1");
          await checkSpeedCompletionAchievements(completionTime);
          await checkCourseStreakAchievements();

          // Update user stats
          await updateUserStats();

          // Show completion message
          showToast(
            "Congratulations! Course completed successfully!",
            "certificate"
          );

          // Log course completion
          logUserActivity("course_completed", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            completion_time_minutes: completionTime,
            total_lessons: COURSE_DATA.lessons.length,
            average_quiz_score: calculateAverageQuizScore(),
          });

          // Redirect to dashboard after delay
          setTimeout(() => {
            window.location.href = "/dashboard.html";
          }, 3000);
        } catch (error) {
          console.error("Error completing course:", error);
          showToast("Error marking course as complete", "error");
        }
      }

      // =====================================================
      // ACHIEVEMENT INTEGRATION SYSTEM
      // =====================================================
      async function checkAndUnlockAchievement(
        achievementId,
        skipNotification = false
      ) {
        try {
          // Prevent duplicate checks
          const cacheKey = `achievement_${achievementId}_${currentUser.id}`;
          if (sessionStorage.getItem(cacheKey)) return false;

          // Check if already unlocked
          const { data: existing, error } = await supabase
            .from("user_achievements")
            .select("id")
            .eq("user_id", currentUser.id)
            .eq("achievement_id", achievementId)
            .single();

          if (existing) {
            sessionStorage.setItem(cacheKey, "true");
            return false;
          }

          // Award achievement
          const achievementData = {
            user_id: currentUser.id,
            achievement_id: achievementId,
            unlocked_at: new Date().toISOString(),
            points_awarded: getAchievementPoints(achievementId),
            context: "course_system",
          };

          const { data, error: insertError } = await supabase
            .from("user_achievements")
            .insert([achievementData])
            .select()
            .single();

          if (insertError) {
            if (insertError.code === "23505") return false; // Already exists
            throw insertError;
          }

          // Update user points
          await supabase.rpc('increment_user_stats', {
  user_id_param: currentUser.id,
  points_to_add: achievementData.points_awarded,
  achievements_to_add: 1
});

          // Cache and queue notification
          sessionStorage.setItem(cacheKey, "true");

          if (!skipNotification) {
            queueAchievementNotification({
              id: achievementId,
              name: getAchievementName(achievementId),
              description: getAchievementDescription(achievementId),
              points: achievementData.points_awarded,
              rarity: getAchievementRarity(achievementId),
              icon: getAchievementIcon(achievementId),
            });
          }

          return true;
        } catch (error) {
          console.error("Error unlocking achievement:", error);
          return false;
        }
      }

      // Helper functions for achievement data (replace with your actual achievement definitions)
      function getAchievementPoints(id) {
        const pointsMap = {
          first_course_start: 75,
          first_lesson: 100,
          course_completion_1: 500,
          perfect_score: 250,
          speed_demon: 750,
          marathon_learner: 500,
          night_owl: 200,
          early_bird: 200,
          weekend_warrior: 150,
          // Add more as needed
        };
        return pointsMap[id] || 100;
      }

      function getAchievementName(id) {
        const nameMap = {
          first_course_start: "Learning Initiated",
          first_lesson: "First Steps",
          course_completion_1: "Course Conqueror",
          perfect_score: "Perfectionist",
          speed_demon: "Speed Demon",
          // Add more as needed
        };
        return nameMap[id] || "Achievement Unlocked";
      }

      function getAchievementDescription(id) {
        const descMap = {
          first_course_start: "Start your first cybersecurity course",
          first_lesson: "Complete your first lesson",
          course_completion_1: "Complete your first course",
          perfect_score: "Score 100% on any quiz",
          speed_demon: "Complete a course in under 2 hours",
          // Add more as needed
        };
        return descMap[id] || "Achievement description";
      }

      function getAchievementRarity(id) {
        const rarityMap = {
          first_course_start: "common",
          first_lesson: "bronze",
          course_completion_1: "silver",
          perfect_score: "gold",
          speed_demon: "legendary",
          // Add more as needed
        };
        return rarityMap[id] || "common";
      }

      function getAchievementIcon(id) {
        const iconMap = {
          first_course_start: "fas fa-play",
          first_lesson: "fas fa-baby",
          course_completion_1: "fas fa-trophy",
          perfect_score: "fas fa-star",
          speed_demon: "fas fa-rocket",
          // Add more as needed
        };
        return iconMap[id] || "fas fa-award";
      }

      async function checkLessonAchievements(lessonNumber) {
        if (lessonNumber === 1) {
          await checkAndUnlockAchievement("first_lesson");
        }

        // Check if user has completed multiple lessons in one day
        const today = new Date().toISOString().split("T")[0];
        const todayCompletions = Object.values(courseProgress).filter(
          (p) => p.completed && p.completedAt?.startsWith(today)
        ).length;

        if (todayCompletions >= 3) {
          await checkAndUnlockAchievement("lesson_marathon");
        }
      }

      async function checkLessonCompletionAchievements() {
        const completedCount = getCompletedLessonsCount();

        // Lesson-based achievements
        const lessonMilestones = [1, 5, 10, 25, 50, 100];
        for (const milestone of lessonMilestones) {
          if (completedCount >= milestone) {
            await checkAndUnlockAchievement(`lessons_${milestone}`);
          }
        }

        // Course completion achievements
        if (completedCount === COURSE_DATA.lessons.length) {
          await checkAndUnlockAchievement("course_completion_1");

          // Check for additional course completion achievements
          const { data: allCourses } = await supabase
            .from("course_progress")
            .select("course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100);

          const totalCompleted = allCourses?.length || 0;

          const courseMilestones = [1, 5, 10, 25];
          for (const milestone of courseMilestones) {
            if (totalCompleted >= milestone) {
              await checkAndUnlockAchievement(`course_completion_${milestone}`);
            }
          }
        }
      }

      async function checkPerfectScoreAchievements(score) {
        if (score === 100) {
          await checkAndUnlockAchievement("perfect_score");

          // Check for consecutive perfect scores
          const recentScores = Object.values(courseProgress)
            .filter((p) => p.completed && p.quizScore)
            .slice(-5) // Last 5 completed
            .map((p) => p.quizScore);

          if (
            recentScores.length >= 3 &&
            recentScores.every((s) => s === 100)
          ) {
            await checkAndUnlockAchievement("perfectionist_streak");
          }
        }
      }

      async function checkSpeedCompletionAchievements(completionTime) {
        // Speed demon: Complete course in under 2 hours (120 minutes)
        if (completionTime <= 120) {
          await checkAndUnlockAchievement("speed_demon");
        }

        // Quick learner: Complete course in under 4 hours (240 minutes)
        if (completionTime <= 240) {
          await checkAndUnlockAchievement("quick_learner");
        }
      }

      async function checkStudyTimeAchievements() {
        const totalTime = courseSession.totalStudyTime;

        // Marathon learner: Study for 8+ hours in a course session
        if (totalTime >= 480) {
          // 8 hours
          await checkAndUnlockAchievement("marathon_learner");
        }

        // Dedicated learner: Study for 4+ hours
        if (totalTime >= 240) {
          // 4 hours
          await checkAndUnlockAchievement("dedicated_learner");
        }
      }

      async function checkCourseStreakAchievements() {
        try {
          // Check for consecutive course completions
          const { data: recentCourses, error } = await supabase
            .from("course_progress")
            .select("completed_at, course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100)
            .order("completed_at", { ascending: false })
            .limit(10);

          if (error || !recentCourses) return;

          // Check for courses completed on consecutive days
          let consecutiveDays = 1;
          for (let i = 1; i < recentCourses.length; i++) {
            const prevDate = new Date(
              recentCourses[i - 1].completed_at
            ).toDateString();
            const currentDate = new Date(
              recentCourses[i].completed_at
            ).toDateString();
            const dayDiff =
              Math.abs(new Date(prevDate) - new Date(currentDate)) /
              (1000 * 60 * 60 * 24);

            if (dayDiff <= 1) {
              consecutiveDays++;
            } else {
              break;
            }
          }

          if (consecutiveDays >= 3) {
            await checkAndUnlockAchievement("learning_streak");
          }
        } catch (error) {
          console.error("Error checking course streak achievements:", error);
        }
      }

      // =====================================================
      // TIME-BASED ACHIEVEMENTS
      // =====================================================
      async function checkTimeBasedAchievements(timestamp) {
        const hour = timestamp.getHours();
        const dayOfWeek = timestamp.getDay();

        // Night owl (after midnight, before 6 AM)
        if (hour >= 0 && hour < 6) {
          await incrementTimeBasedCounter("midnight_sessions", "night_owl");
        }

        // Early bird (4 AM to 6 AM)
        if (hour >= 4 && hour < 6) {
          await incrementTimeBasedCounter("early_sessions", "early_bird");
        }

        // Weekend warrior (Saturday = 6, Sunday = 0)
        if (dayOfWeek === 0 || dayOfWeek === 6) {
          await incrementTimeBasedCounter(
            "weekend_sessions",
            "weekend_warrior"
          );
        }
      }

      async function incrementTimeBasedCounter(counterType, achievementId) {
        try {
          const dateStr = new Date().toISOString().split("T")[0];
          const cacheKey = `${counterType}_${currentUser.id}_${dateStr}`;

          // Prevent multiple increments per day
          if (sessionStorage.getItem(cacheKey)) return;

          // Update counter
          await supabase
            .from("profiles")
            .update({
              [counterType]: supabase.sql`${counterType} + 1`,
            })
            .eq("id", currentUser.id);

          // Cache to prevent double counting
          sessionStorage.setItem(cacheKey, "true");

          // Check related achievement
          if (achievementId) {
            await checkAndUnlockAchievement(achievementId, true);
          }
        } catch (error) {
          console.error(`Error incrementing ${counterType}:`, error);
        }
      }

      async function checkDailyStreak() {
        try {
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("last_activity, current_streak, last_streak_date")
            .eq("id", currentUser.id)
            .single();

          if (error) throw error;

          const now = new Date();
          const today = now.toDateString();
          const lastActivity = profile.last_activity
            ? new Date(profile.last_activity)
            : null;
          const lastStreakDate = profile.last_streak_date
            ? new Date(profile.last_streak_date).toDateString()
            : null;

          let newStreak = profile.current_streak || 0;
          let shouldUpdateStreak = false;

          if (!lastActivity) {
            // First time user
            newStreak = 1;
            shouldUpdateStreak = true;
          } else {
            const daysSinceLastActivity = Math.floor(
              (now - lastActivity) / (1000 * 60 * 60 * 24)
            );

            if (lastStreakDate === today) {
              // Already counted today's streak
              return newStreak;
            } else if (
              daysSinceLastActivity === 1 ||
              (daysSinceLastActivity === 0 && lastStreakDate !== today)
            ) {
              // Consecutive day or same day but not counted yet
              newStreak += 1;
              shouldUpdateStreak = true;
            } else if (daysSinceLastActivity > 1) {
              // Streak broken
              newStreak = 1;
              shouldUpdateStreak = true;
            }
          }

          if (shouldUpdateStreak) {
            await supabase
              .from("profiles")
              .update({
                current_streak: newStreak,
                last_activity: now.toISOString(),
                last_streak_date: now.toISOString(),
              })
              .eq("id", currentUser.id);

            userStats.current_streak = newStreak;

            showToast(`Daily streak: ${newStreak} days!`, "success");
            await checkStreakAchievements(newStreak);
          }

          return newStreak;
        } catch (error) {
          console.error("Error checking daily streak:", error);
          return 0;
        }
      }

      async function checkStreakAchievements(currentStreak) {
        const streakMilestones = [3, 7, 14, 30, 100, 365];

        for (const milestone of streakMilestones) {
          if (currentStreak >= milestone) {
            await checkAndUnlockAchievement(`streak_${milestone}`);
          }
        }
      }

      // =====================================================
      // USER ACTIVITY LOGGING
      // =====================================================
      async function logUserActivity(activityType, metadata = {}) {
        try {
          const now = new Date();

          const activityData = {
            user_id: currentUser.id,
            activity_type: activityType,
            timestamp: now.toISOString(),
            course_id: COURSE_DATA.id,
            lesson_index: currentLessonIndex,
            session_duration: courseSession.totalStudyTime,
            metadata: JSON.stringify(metadata),
            created_at: now.toISOString(),
          };

          // Try to log to activities table
          const { error } = await supabase
            .from("user_activities")
            .insert([activityData]);

          if (error && error.code !== "42P01") {
            console.warn("Activity logging failed:", error.message);
          }

          // Always update last activity in profile
          await supabase
            .from("profiles")
            .update({ last_activity: now.toISOString() })
            .eq("id", currentUser.id);
        } catch (error) {
          console.error("Error logging user activity:", error);
        }
      }

      // =====================================================
      // NAVIGATION SYSTEM
      // =====================================================
      function updateNavigationButtons() {
        const prevBtn = document.getElementById("prevLessonBtn");
        const nextBtn = document.getElementById("nextLessonBtn");

        if (!prevBtn || !nextBtn) return;

        // Previous button
        prevBtn.disabled = currentLessonIndex === 0;

        // Next button logic
        const isLastLesson =
          currentLessonIndex === COURSE_DATA.lessons.length - 1;
        const canGoNext =
          currentLessonIndex < COURSE_DATA.lessons.length - 1 &&
          canAccessLesson(currentLessonIndex + 1);

        if (isLastLesson) {
          const isCurrentCompleted =
            courseProgress[COURSE_DATA.lessons[currentLessonIndex].id]
              ?.completed;
          nextBtn.disabled = !isCurrentCompleted;
          nextBtn.innerHTML = '<i class="fas fa-trophy"></i> Complete Course';
        } else {
          nextBtn.disabled = !canGoNext;
          nextBtn.innerHTML = 'Next <i class="fas fa-chevron-right"></i>';
        }
      }

      // Navigation button event handlers
      function goToPreviousLesson() {
        if (currentLessonIndex > 0) {
          trackLessonTime(); // Track time spent on current lesson
          currentLessonIndex--;
          loadLesson(currentLessonIndex);
        }
      }

      function goToNextLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          const canGoNext = canAccessLesson(currentLessonIndex + 1);
          if (canGoNext) {
            trackLessonTime();
            currentLessonIndex++;
            loadLesson(currentLessonIndex);
          } else {
            showToast("Complete the current lesson quiz to proceed", "warning");
          }
        } else {
          // Complete course
          completeCourse();
        }
      }

      // =====================================================
      // SIDEBAR FUNCTIONS
      // =====================================================
      function toggleSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.toggle("open");
        if (overlay) overlay.classList.toggle("active");
      }

      function closeSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.remove("open");
        if (overlay) overlay.classList.remove("active");
      }

      // =====================================================
      // ACHIEVEMENT NOTIFICATION SYSTEM
      // =====================================================
      function queueAchievementNotification(achievement) {
        notificationQueue.push(achievement);
        processNotificationQueue();
      }

      function processNotificationQueue() {
        if (isShowingNotification || notificationQueue.length === 0) return;

        isShowingNotification = true;
        const achievement = notificationQueue.shift();
        showAchievementNotification(achievement);

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          isShowingNotification = false;
          processNotificationQueue();
        }, duration + 500);
      }

      function showAchievementNotification(achievement) {
        const notification = document.getElementById("achievementNotification");
        if (!notification) return;

        const icon = document.getElementById("notificationIcon");
        const title = document.getElementById("notificationTitle");
        const description = document.getElementById("notificationDescription");
        const points = document.getElementById("notificationPoints");

        if (icon) {
          icon.innerHTML = `<i class="${achievement.icon}"></i>`;
          icon.className = `notification-icon ${achievement.rarity}`;
        }
        if (title) title.textContent = achievement.name;
        if (description) description.textContent = achievement.description;
        if (points) points.textContent = `+${achievement.points} Points`;

        notification.className = `achievement-notification ${achievement.rarity}`;
        notification.classList.add("show");

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          notification.classList.remove("show");
        }, duration);
      }

      // =====================================================
      // UTILITY FUNCTIONS
      // =====================================================
      function calculateAverageQuizScore() {
        const scores = Object.values(courseProgress)
          .filter((p) => p.completed && p.quizScore)
          .map((p) => p.quizScore);

        if (scores.length === 0) return 0;
        return Math.round(
          scores.reduce((sum, score) => sum + score, 0) / scores.length
        );
      }

      async function resetProgress() {
        if (
          !confirm(
            "Are you sure you want to reset your progress? This action cannot be undone."
          )
        ) {
          return;
        }

        try {
          // Track lesson time before reset
          trackLessonTime();

          // Reset local state
          courseProgress = {};
          currentLessonIndex = 0;
          courseSession = {
            startTime: new Date(),
            totalStudyTime: 0,
            lessonsStarted: 0,
            lessonsCompleted: 0,
            pageLoadTime: new Date(),
            interactionCount: 0,
            lastActivityTime: new Date(),
          };

          // Delete from database
          await supabase
            .from("course_progress")
            .delete()
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Log reset activity
          logUserActivity("progress_reset", {
            course_id: COURSE_DATA.id,
            reset_reason: "manual",
          });

          // Reinitialize
          await saveProgress();
          renderSidebar();
          loadLesson(0);

          showToast("Progress reset successfully", "success");
        } catch (error) {
          console.error("Error resetting progress:", error);
          showToast("Failed to reset progress", "error");
        }
      }

      function copyCode(codeId) {
        const codeElement = document.getElementById(codeId);
        if (!codeElement) return;

        const text = codeElement.textContent;

        navigator.clipboard
          .writeText(text)
          .then(() => {
            showToast("Code copied to clipboard!", "success");

            // Track code copy for achievements
            logUserActivity("code_copied", {
              code_section: codeId,
              lesson_id: COURSE_DATA.lessons[currentLessonIndex].id,
            });
          })
          .catch((err) => {
            console.error("Failed to copy code:", err);
            showToast("Failed to copy code", "error");

            // Fallback for older browsers
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            try {
              document.execCommand("copy");
              showToast("Code copied to clipboard!", "success");
            } catch (fallbackError) {
              showToast(
                "Copy failed - please select and copy manually",
                "error"
              );
            }
            document.body.removeChild(textArea);
          });
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // =====================================================
      // UI FEEDBACK SYSTEMS
      // =====================================================
      function showToast(message, type = "success") {
        const toast = document.getElementById("toast");
        const messageEl = document.getElementById("toastMessage");

        if (!toast || !messageEl) {
          console.log(`Toast: ${message} (${type})`);
          return;
        }

        messageEl.textContent = message;
        toast.className = `toast ${type} show`;

        setTimeout(() => {
          toast.classList.remove("show");
        }, 4000);
      }

      function showLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) loadingScreen.classList.remove("hidden");
      }

      function hideLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) {
          setTimeout(() => {
            loadingScreen.classList.add("hidden");
          }, 1000);
        }
      }

      // =====================================================
      // MUSIC PLAYER INTEGRATION
      // =====================================================
      function initMusicPlayer() {
        const btnText = document.getElementById("music-button-text");
        const icon = document.getElementById("music-icon");
        const dropdown = document.getElementById("music-dropdown-content");

        if (!btnText || !icon || !dropdown) return;

        function setUI(state) {
          btnText.textContent =
            state === "Playing" ? "PAUSE MUSIC" : "STUDY MUSIC";
          icon.className =
            state === "Playing"
              ? "fa-solid fa-circle-pause"
              : "fa-solid fa-music";
        }

        // Load saved music state
        const savedSrc = localStorage.getItem("cybersec_music_src");
        const savedTime = parseFloat(
          localStorage.getItem("cybersec_music_time") || 0
        );

        if (savedSrc) {
          audioPlayer.src = savedSrc;
          audioPlayer.currentTime = savedTime;
          audioPlayer
            .play()
            .then(() => setUI("Playing"))
            .catch(() => setUI("Stopped"));
        }

        // Music button click handler
        document
          .getElementById("music-dropdown")
          .querySelector("button")
          .addEventListener("click", (e) => {
            e.stopPropagation();
            dropdown.style.display =
              dropdown.style.display === "block" ? "none" : "block";

            if (audioPlayer.src && !audioPlayer.paused) {
              audioPlayer.pause();
              setUI("Stopped");
            } else if (audioPlayer.src) {
              audioPlayer.play().then(() => setUI("Playing"));
            }
          });

        // Music selection handlers
        dropdown.querySelectorAll("a[data-src]").forEach((link) => {
          link.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.src = link.dataset.src;
            audioPlayer.play().then(() => setUI("Playing"));
            localStorage.setItem("cybersec_music_src", link.dataset.src);
            dropdown.style.display = "none";
          });
        });

        // Stop music handler
        const stopLink = document.getElementById("stop-music-link");
        if (stopLink) {
          stopLink.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            audioPlayer.removeAttribute("src");
            setUI("Stopped");
            localStorage.removeItem("cybersec_music_src");
            localStorage.removeItem("cybersec_music_time");
            dropdown.style.display = "none";
          });
        }

        // Save music state before page unload
        window.addEventListener("beforeunload", () => {
          if (!audioPlayer.paused && audioPlayer.src) {
            localStorage.setItem("cybersec_music_src", audioPlayer.src);
            localStorage.setItem(
              "cybersec_music_time",
              audioPlayer.currentTime
            );
          }
        });

        // Close dropdown when clicking outside
        window.addEventListener("click", (e) => {
          if (!e.target.closest("#music-dropdown")) {
            dropdown.style.display = "none";
          }
        });
      }

      // Show initial music indicator
      function addMusicIndicator() {
        const musicBtn = document.querySelector("#music-dropdown");
        if (musicBtn) {
          const indicator = document.createElement("div");
          indicator.className = "music-indicator";
          indicator.innerHTML = `<i class="fa-solid fa-music"></i> Try Study Music!`;

          musicBtn.style.position = "relative";
          musicBtn.appendChild(indicator);

          setTimeout(() => indicator.remove(), 3000);
        }
      }

      // Initialize Event Listeners
      function initializeEventListeners() {
        // Navigation buttons
        document
          .getElementById("prevLessonBtn")
          ?.addEventListener("click", goToPreviousLesson);
        document
          .getElementById("nextLessonBtn")
          ?.addEventListener("click", goToNextLesson);

        // Reset progress button
        document
          .getElementById("resetProgressBtn")
          ?.addEventListener("click", resetProgress);

        // Mobile menu toggle
        document
          .getElementById("menuToggle")
          ?.addEventListener("click", toggleSidebar);
        document
          .getElementById("sidebarOverlay")
          ?.addEventListener("click", closeSidebar);

        // Keyboard shortcuts
        document.addEventListener("keydown", handleKeyboardShortcuts);

        // Window resize handler
        window.addEventListener("resize", handleWindowResize);

        // Content interaction tracking
        document.getElementById("contentBody")?.addEventListener(
          "scroll",
          debounce(() => {
            trackUserInteraction();
          }, 1000)
        );
      }

      // Keyboard Shortcuts
      function handleKeyboardShortcuts(e) {
        if (document.querySelector(".quiz-question.active")) return;

        if (e.key === "ArrowLeft" && e.ctrlKey) {
          e.preventDefault();
          goToPreviousLesson();
        } else if (e.key === "ArrowRight" && e.ctrlKey) {
          e.preventDefault();
          goToNextLesson();
        }
      }

      // Window Resize Handler
      function handleWindowResize() {
        if (window.innerWidth > 768) {
          closeSidebar();
        }
      }

      // Debounce Helper
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Initialize responsive behavior
      if (window.innerWidth <= 768) {
        document.getElementById("menuToggle").style.display = "inline-flex";
      }

      // Auto-save progress periodically
      setInterval(async () => {
        if (currentUser && Object.keys(courseProgress).length > 0) {
          await saveProgress();
        }
      }, 60000); // Save every minute

      // System initialization logging
      console.log("CyberSec Academy Course System Initialized");
      console.log("Current Course:", COURSE_DATA.title);
      console.log("Total Lessons:", COURSE_DATA.lessons.length);

      // Google OAuth Integration
      const googleBtn = document.querySelector(".btn-google");
      if (googleBtn) {
        googleBtn.addEventListener("click", async () => {
          const { data, error } = await supabase.auth.signInWithOAuth({
            provider: "google",
            options: {
              redirectTo:
                window.location.origin +
                "/courses/network-forensics-complete-course.html",
            },
          });

          if (error) {
            console.error("Google login error:", error.message);
            showToast("Google login failed: " + error.message, "error");
          }
        });
      }

      // Check for existing session
      supabase.auth.getSession().then(({ data }) => {
        if (data.session) {
          console.log("User already logged in:", data.session.user);
          currentUser = data.session.user;
          startCourseSession();
        }
      });

      // Add missing auth modal functions
      function openAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "flex";
        }
      }

      function closeAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Add auth tab switching functionality
      document.getElementById("tabSignIn")?.addEventListener("click", () => {
        document.getElementById("tabSignIn").classList.add("active");
        document.getElementById("tabSignUp").classList.remove("active");
        document.getElementById("signInForm").style.display = "block";
        document.getElementById("signUpForm").style.display = "none";
      });

      document.getElementById("tabSignUp")?.addEventListener("click", () => {
        document.getElementById("tabSignUp").classList.add("active");
        document.getElementById("tabSignIn").classList.remove("active");
        document.getElementById("signUpForm").style.display = "block";
        document.getElementById("signInForm").style.display = "none";
      });

      document
        .getElementById("closeAuthModal")
        ?.addEventListener("click", closeAuthModal);

      // Improved error handling for auth session
      supabase.auth.onAuthStateChange((event, session) => {
        if (event === "SIGNED_IN") {
          currentUser = session.user;
          closeAuthModal();
          startCourseSession();
        } else if (event === "SIGNED_OUT") {
          currentUser = null;
          openAuthModal();
        }
      });

      // Add form submission handlers
      document
        .getElementById("emailSignInForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signInEmail").value;
          const password = document.getElementById("signInPassword").value;

          try {
            const { data, error } = await supabase.auth.signInWithPassword({
              email,
              password,
            });

            if (error) throw error;

            closeAuthModal();
          } catch (error) {
            showToast(error.message, "error");
          }
        });

      document
        .getElementById("emailSignUpForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signUpEmail").value;
          const password = document.getElementById("signUpPassword").value;
          const name = document.getElementById("signUpName").value;

          try {
            const { data, error } = await supabase.auth.signUp({
              email,
              password,
              options: {
                data: {
                  full_name: name,
                },
              },
            });

            if (error) throw error;

            showToast(
              "Account created successfully! Please check your email.",
              "success"
            );
          } catch (error) {
            showToast(error.message, "error");
          }
        });
    </script>
  </body>
</html>

