




<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>TCP/IP Protocols Deep Dive Course Curriculum | CipherHall</title>
    <meta name="description" content="Begin your free, in-depth course on TCP/IP protocols. This curriculum covers the OSI model, IP addressing, TCP vs. UDP, routing, DNS, and network security." />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png" />
    <link rel="shortcut icon" href="/favicon.png" type="image/x-icon" />
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png" />
    <link rel="canonical" href="https://www.cipherhall.com/courses/tcp-ip-protocols-deep-dive" />

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Course",
      "name": "TCP/IP Protocols: A Deep Dive",
      "description": "An in-depth exploration of the TCP/IP suite, from foundational concepts to advanced protocols and security.",
      "provider": {
        "@type": "Organization",
        "name": "CipherHall",
        "sameAs": "https://www.cipherhall.com"
      },
      "hasCourseInstance": {
        "@type": "CourseInstance",
        "courseMode": "Online",
        "instructor": {
          "@type": "Person",
          "name": "Dr. Evelyn Reed"
        }
      }
    }
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Exo+2:wght@700;800;900&display=swap" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" />
    <link rel="stylesheet" href="assets/css/coursepages.css">
</head>
  <body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
      <div class="loader-icon">
        <i class="fas fa-graduation-cap"></i>
      </div>
      <div class="loader-text">Loading Course Content...</div>
    </div>

    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- Music Player (fixed at top right) -->
    <div class="header-controls">
      <div class="music-dropdown" id="music-dropdown">
        <button class="btn btn-secondary">
          <span id="music-button-text">STUDY MUSIC</span>
          <i id="music-icon" class="fa-solid fa-music"></i>
        </button>
        <div class="music-dropdown-content" id="music-dropdown-content">
          <a
            href="#"
            data-src="https://www.learningcontainer.com/wp-content/uploads/2020/02/Kalimba.mp3"
            >1. Coffee Shop Vibes</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3"
            >2. City Lights Lofi</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-15.mp3"
            >3. Mellow Thoughts</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-13.mp3"
            >4. Rainy Mood</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3"
            >5. Time Alone</a
          >
          <a href="#" id="stop-music-link"
            ><i class="fa-solid fa-stop-circle"></i> Stop Music</a
          >
        </div>
      </div>

      <button class="btn btn-secondary" id="resetProgressBtn">
        <i class="fas fa-redo"></i>
        Reset Progress
      </button>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal" style="display: none">
      <div class="modal-overlay"></div>
      <div class="modal-content">
        <span class="close" id="closeAuthModal">&times;</span>
        <div class="auth-tabs">
          <button id="tabSignIn" class="auth-tab active">Sign In</button>
          <button id="tabSignUp" class="auth-tab">Sign Up</button>
        </div>
        <div
          id="authLoader"
          style="display: none; text-align: center; padding: 2rem"
        >
          <i
            class="fas fa-spinner fa-spin fa-2x"
            style="color: var(--color-green)"
          ></i>
          <p style="margin-top: 0.5rem">Authenticating...</p>
        </div>
        <div id="signInForm" class="auth-form">
          <h2>Sign In to CipherHall</h2>
          <button id="googleSignIn" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignInForm">
            <input
              type="email"
              id="signInEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signInPassword"
              placeholder="Password"
              required
            />
            <button type="submit" class="btn btn-primary">Sign In</button>
          </form>
        </div>
        <div id="signUpForm" class="auth-form" style="display: none">
          <h2>Join CipherHall</h2>
          <button id="googleSignUp" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignUpForm">
            <input
              type="text"
              id="signUpName"
              placeholder="Full Name"
              required
            />
            <input
              type="email"
              id="signUpEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signUpPassword"
              placeholder="Password (min. 8 characters)"
              required
            />
            <button type="submit" class="btn btn-secondary">
              Create Account
            </button>
          </form>
        </div>
        <div id="authMessage"></div>
      </div>
    </div>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="course-info">
          <h1 class="course-title" id="courseTitle">Loading...</h1>
          <div class="course-progress">
            <div class="progress-header">
              <span class="progress-label">Course Progress</span>
              <span class="progress-percentage" id="courseProgressPercent"
                >0%</span
              >
            </div>
            <div class="progress-bar">
              <div
                class="progress-fill"
                id="courseProgressFill"
                style="width: 0%"
              ></div>
            </div>
            <div class="progress-stats">
              <span id="completedLessons">0</span>
              <span id="totalLessons">0</span>
            </div>
          </div>
          <a href="/dashboard" class="back-to-dashboard">
            <i class="fas fa-arrow-left"></i>
            Back to Dashboard
          </a>
        </div>
      </div>

      <nav class="lesson-nav" id="lessonNav">
        <!-- Lessons will be loaded dynamically -->
      </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <header class="content-header">
        <div class="lesson-header">
          <div class="lesson-header-left">
            <span class="lesson-number" id="currentLessonNumber">1</span>
            <h1 class="lesson-header-title" id="currentLessonTitle">
              Loading...
            </h1>
          </div>
          <div class="lesson-actions">
            <button class="mbtn btn-primary" id="menuToggle">
              <i class="fas fa-bars"></i>
            </button>
          </div>
        </div>
      </header>

      <div class="content-body" id="contentBody">
        <div class="lesson-content" id="lessonContent">
          <!-- Lesson content will be loaded dynamically -->
        </div>
      </div>

      <footer class="lesson-navigation">
        <div class="nav-info" id="navInfo">Lesson 1 of 10</div>
        <div class="nav-controls">
          <button class="btn btn-secondary" id="prevLessonBtn" disabled>
            <i class="fas fa-chevron-left"></i>
            Previous
          </button>
          <button class="btn btn-primary" id="nextLessonBtn" disabled>
            Next
            <i class="fas fa-chevron-right"></i>
          </button>
        </div>
      </footer>
    </main>

    <!-- Achievement Notification -->
    <div id="achievementNotification" class="achievement-notification">
      <div class="notification-header">
        <div class="notification-icon" id="notificationIcon">
          <i class="fas fa-trophy"></i>
        </div>
        <div class="notification-content">
          <h3 id="notificationTitle">Achievement Unlocked!</h3>
          <p id="notificationDescription">Description here...</p>
        </div>
      </div>
      <div class="notification-reward" id="notificationReward">
        <i class="fas fa-coins"></i>
        <span id="notificationPoints">+100 Points</span>
      </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast">
      <span id="toastMessage"></span>
    </div>

    <script>
      // =====================================================
      // SYNCHRONIZED COURSE SYSTEM WITH DASHBOARD INTEGRATION
      // =====================================================

      // Supabase Configuration - Replace with your config
      const supabaseUrl = "https://lzcmzulemfubjaksoqor.supabase.co";
      const supabaseKey =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx6Y216dWxlbWZ1Ympha3NvcW9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzMzM5MDgsImV4cCI6MjA3MDkwOTkwOH0.crhPH4YWtRsr1BJTpAQcmPbWSpwIWRbzoI4sRb2_fPI";
      const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

      // =====================================================
      // COURSE DATA STRUCTURE - REPLACE WITH YOUR COURSE JSON
      // =====================================================
      const COURSE_DATA = {
    "id": "tcp-ip-protocols-deep-dive",
    "title": "TCP/IP Protocols: A Deep Dive",
    "description": "An in-depth exploration of the TCP/IP suite, from foundational concepts to advanced protocols and security.",
    "category": "networking",
    "difficulty": "Intermediate to Advanced",
    "duration": "14 hours",
    "instructor": "Dr. Evelyn Reed",
    "lessons": [
        {
            "id": "lesson-1",
            "title": "Introduction to Networking & OSI vs TCP/IP Models",
            "duration": "90 min",
            "objectives": [
                "Understand the fundamental concepts of computer networking.",
                "Learn the structure and purpose of the 7-layer OSI model.",
                "Learn the structure and practicality of the 4-layer TCP/IP model.",
                "Grasp the process of encapsulation and decapsulation."
            ],
            "content": {
                "overview": "Welcome to the world of networking. This foundational lesson introduces the core concepts of how computers communicate, comparing the two most important theoretical models: the comprehensive OSI model and the practical TCP/IP model that powers the internet. We will explore how data is packaged and unpackaged as it travels across the network.",
                "sections": [
                    {
                        "title": "The OSI 7-Layer Model",
                        "content": "<p>The Open Systems Interconnection (OSI) model is a conceptual framework that standardizes the functions of a telecommunication or computing system in seven abstract layers. It provides a comprehensive vocabulary for network engineers.</p><h3>The 7 Layers:</h3><ol><li><strong>Physical:</strong> Transmits raw bits over a medium (cables, radio waves).</li><li><strong>Data Link:</strong> Manages node-to-node data transfer and error detection (MAC addresses, switches).</li><li><strong>Network:</strong> Handles packet forwarding and routing across networks (IP addresses, routers).</li><li><strong>Transport:</strong> Provides reliable or unreliable data transfer between hosts (TCP, UDP).</li><li><strong>Session:</strong> Manages dialogues (sessions) between computers.</li><li><strong>Presentation:</strong> Translates, encrypts, and compresses data.</li><li><strong>Application:</strong> Provides network services to end-user applications (HTTP, FTP, DNS).</li></ol><div class=\"info-box tip\"><div class=\"info-box-header\"><i class=\"fas fa-lightbulb\"></i><strong>Mnemonic</strong></div><p>A popular mnemonic to remember the layers is: \"<strong>P</strong>lease <strong>D</strong>o <strong>N</strong>ot <strong>T</strong>hrow <strong>S</strong>ausage <strong>P</strong>izza <strong>A</strong>way\".</p></div>",
                        "image": "https://images.unsplash.com/photo-1554415707-6e8cfc93fe23?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The TCP/IP 4-Layer Model",
                        "content": "<p>The TCP/IP model is the practical implementation that the modern internet is built on. It is less rigid than the OSI model and collapses several layers into single functional groups.</p><h3>The 4 Layers:</h3><ol><li><strong>Network Access (or Link):</strong> Combines the OSI Physical and Data Link layers. Manages hardware devices and protocols like Ethernet.</li><li><strong>Internet:</strong> Corresponds to the OSI Network layer. Responsible for logical addressing and routing (IP, ICMP, ARP).</li><li><strong>Transport:</strong> Corresponds to the OSI Transport layer. Manages host-to-host communication (TCP, UDP).</li><li><strong>Application:</strong> Combines the OSI Session, Presentation, and Application layers. Provides protocols for specific applications (HTTP, DNS, SMTP).</li></ol>",
                        "image": "https://images.unsplash.com/photo-1487058792275-0ad4aaf24ca7?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Encapsulation and Decapsulation",
                        "content": "<p>Encapsulation is the process of adding headers (and sometimes trailers) to data as it moves down the protocol stack from the Application layer to the Physical layer. Each layer adds its own control information.</p><p>For example, the Transport layer takes application data and adds a TCP header, creating a 'segment'. The Internet layer takes the segment and adds an IP header, creating a 'packet'. The Network Access layer takes the packet and adds an Ethernet header, creating a 'frame'.</p><p>Decapsulation is the reverse process, where the receiving computer removes headers at each layer as the data moves up the stack, finally presenting the raw data to the application.</p>",
                        "image": "https://images.unsplash.com/photo-1573495627361-d9b87960b12d?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Conceptual Packet Flow (Encapsulation)",
                        "language": "text",
                        "code": "Application Layer:  [ Your Data ]\n       |\n       V\nTransport Layer:   [ TCP Header | Your Data ]  (Segment)\n       |\n       V\nInternet Layer:    [ IP Header | TCP Header | Your Data ]  (Packet)\n       |\n       V\nNetwork Access:    [ Eth Header | IP Header | TCP Header | Your Data | Eth Trailer ] (Frame)"
                    },
                    {
                        "title": "Wireshark Display Filter Example",
                        "language": "text",
                        "code": "# In Wireshark, you can isolate protocols to see the layers in action.\n# This filter will only show packets that are part of an HTTP conversation over TCP/IP.\n\nhttp"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "Which layer of the OSI model is responsible for logical addressing and routing between networks?",
                        "options": ["Data Link Layer", "Transport Layer", "Network Layer", "Physical Layer"],
                        "correct": 2,
                        "explanation": "The Network Layer (Layer 3) is responsible for path determination and logical addressing, using protocols like IP to route packets across different networks."
                    },
                    {
                        "id": 2,
                        "question": "In the TCP/IP model, which layer combines the functions of the OSI Session, Presentation, and Application layers?",
                        "options": ["Internet Layer", "Transport Layer", "Network Access Layer", "Application Layer"],
                        "correct": 3,
                        "explanation": "The TCP/IP Application Layer is a broad layer that handles all application-specific protocols and functions that are covered by layers 5, 6, and 7 of the OSI model."
                    },
                    {
                        "id": 3,
                        "question": "The process of adding a header to data as it moves down the protocol stack is called:",
                        "options": ["Decapsulation", "Encapsulation", "Segmentation", "Framing"],
                        "correct": 1,
                        "explanation": "Encapsulation is the process of wrapping data with protocol information at each layer. Decapsulation is the reverse process of removing the headers."
                    },
                    {
                        "id": 4,
                        "question": "A switch primarily operates at which layer of the OSI model?",
                        "options": ["Layer 1 (Physical)", "Layer 2 (Data Link)", "Layer 3 (Network)", "Layer 4 (Transport)"],
                        "correct": 1,
                        "explanation": "Switches make forwarding decisions based on MAC addresses, which are part of the Data Link layer. Routers operate at Layer 3."
                    },
                    {
                        "id": 5,
                        "question": "What is the Protocol Data Unit (PDU) at the Internet layer of the TCP/IP model called?",
                        "options": ["Frame", "Segment", "Packet", "Bit"],
                        "correct": 2,
                        "explanation": "At the Internet layer, data is encapsulated into a 'packet' with an IP header. It's a 'segment' at the Transport layer and a 'frame' at the Network Access layer."
                    }
                ]
            }
        },
        {
            "id": "lesson-2",
            "title": "TCP/IP Layers and Their Functions",
            "duration": "75 min",
            "objectives": [
                "Deeply understand the function of each of the four TCP/IP layers.",
                "Identify key protocols that operate at each layer.",
                "Analyze the role each layer plays in a complete network communication.",
                "Map real-world applications to their corresponding protocols and layers."
            ],
            "content": {
                "overview": "This lesson takes a closer look at the four layers of the TCP/IP suite. We will dissect the specific responsibilities of the Network Access, Internet, Transport, and Application layers and identify the core protocols that make them function, providing a practical framework for understanding network traffic.",
                "sections": [
                    {
                        "title": "Layer 1: Network Access Layer",
                        "content": "<p>The Network Access layer (or Link Layer) is responsible for the physical transmission of data. It defines how bits are sent over a physical medium and includes the protocols needed for node-to-node communication on the same local network.</p><h3>Key Responsibilities:</h3><ul><li><strong>Physical Addressing:</strong> Uses MAC (Media Access Control) addresses to identify devices on a local network segment.</li><li><strong>Framing:</strong> Encapsulates IP packets into frames, adding headers and trailers for local delivery.</li><li><strong>Media Access Control:</strong> Manages how devices share the same physical medium (e.g., CSMA/CD for Ethernet).</li></ul><h3>Common Protocols:</h3><ul><li>Ethernet, Wi-Fi (802.11), ARP, PPP.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1525547719571-a2d4ac8945e2?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Layer 2: Internet Layer",
                        "content": "<p>The Internet layer's primary function is to move packets from a source host to a destination host across one or more networks. This is the layer that enables the 'internetworking' of different networks.</p><h3>Key Responsibilities:</h3><ul><li><strong>Logical Addressing:</strong> Uses IP (Internet Protocol) addresses to uniquely identify hosts on the global internet.</li><li><strong>Routing:</strong> Determines the best path for a packet to take to reach its destination using routers.</li><li><strong>Packetizing:</strong> Takes segments from the Transport layer and encapsulates them into packets (datagrams).</li></ul><h3>Core Protocols:</h3><ul><li>IP (IPv4, IPv6), ICMP, IGMP.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1451187580459-43490279c0fa?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Layer 3: Transport Layer",
                        "content": "<p>The Transport layer provides the crucial link between the application layer and the lower layers, managing host-to-host communication sessions. It determines whether communication should be reliable or not.</p><h3>Key Responsibilities:</h3><ul><li><strong>Segmentation and Reassembly:</strong> Breaks down large chunks of application data into smaller segments and reassembles them on the receiving end.</li><li><strong>Port Addressing:</strong> Uses port numbers to identify specific applications or services on a host. A single host can have many applications communicating simultaneously.</li><li><strong>Connection Control:</strong> Can provide connection-oriented (TCP) or connectionless (UDP) services.</li><li><strong>Flow and Error Control:</strong> Ensures data is delivered reliably and in order (for TCP).</li></ul><h3>Core Protocols:</h3><ul><li>TCP (Transmission Control Protocol), UDP (User Datagram Protocol).</li></ul>",
                        "image": "https://images.unsplash.com/photo-1580833246815-c172a15c26e2?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Layer 4: Application Layer",
                        "content": "<p>The Application layer is where users and applications interact with the network. It provides the protocols that allow software to send and receive information and present meaningful data to users.</p><h3>Key Responsibilities:</h3><ul><li><strong>Service Interface:</strong> Provides a high-level interface for applications to use network services (e.g., a web browser using HTTP).</li><li><strong>Data Representation:</strong> Handles data formatting, encoding, and encryption so that different systems can understand each other.</li><li><strong>Session Management:</strong> Establishes, manages, and terminates sessions between applications.</li></ul><h3>Common Protocols:</h3><ul><li>HTTP, HTTPS, FTP, SMTP, DNS, DHCP, SNMP.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1516321497487-e288fb19713f?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Mapping Protocols to Layers",
                        "language": "text",
                        "code": "Application Layer   -> HTTP, DNS, SMTP, FTP\nTransport Layer     -> TCP, UDP\nInternet Layer      -> IP, ICMP, ARP\nNetwork Access Layer -> Ethernet, Wi-Fi"
                    },
                    {
                        "title": "Wireshark Filter to Isolate a TCP Conversation",
                        "language": "text",
                        "code": "# This filter shows all packets for a web browsing session (port 80) over TCP.\n# It helps visualize the interaction between the Application, Transport, and Internet layers.\n\ntcp.port == 80"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "Which protocol is responsible for logical addressing and routing at the Internet layer?",
                        "options": ["TCP", "Ethernet", "IP", "HTTP"],
                        "correct": 2,
                        "explanation": "The Internet Protocol (IP) is the core protocol of the Internet layer, responsible for assigning logical addresses to hosts and routing packets between them."
                    },
                    {
                        "id": 2,
                        "question": "Port numbers are used at which layer of the TCP/IP model to identify specific applications?",
                        "options": ["Application", "Transport", "Internet", "Network Access"],
                        "correct": 1,
                        "explanation": "The Transport layer, using TCP and UDP, uses port numbers to direct data to the correct application process running on a host."
                    },
                    {
                        "id": 3,
                        "question": "MAC addresses are used at which layer?",
                        "options": ["Application", "Transport", "Internet", "Network Access"],
                        "correct": 3,
                        "explanation": "MAC addresses are physical addresses used for device-to-device communication on a local network segment, which is the responsibility of the Network Access layer."
                    },
                    {
                        "id": 4,
                        "question": "Which two are the primary protocols of the Transport Layer?",
                        "options": ["IP and ICMP", "HTTP and DNS", "TCP and UDP", "Ethernet and Wi-Fi"],
                        "correct": 2,
                        "explanation": "TCP provides reliable, connection-oriented communication, while UDP provides unreliable, connectionless communication. Both are the main protocols at the Transport Layer."
                    },
                    {
                        "id": 5,
                        "question": "A web browser uses which Application Layer protocol to request a webpage?",
                        "options": ["SMTP", "FTP", "DNS", "HTTP"],
                        "correct": 3,
                        "explanation": "The HyperText Transfer Protocol (HTTP) is the fundamental protocol used by web browsers to request and retrieve web page content from web servers."
                    }
                ]
            }
        },
        {
            "id": "lesson-3",
            "title": "IP Addressing (IPv4, IPv6, Subnetting)",
            "duration": "120 min",
            "objectives": [
                "Understand the structure and format of IPv4 and IPv6 addresses.",
                "Differentiate between public and private IP addresses.",
                "Learn how to subnet a network into smaller, manageable broadcast domains.",
                "Grasp the concept of CIDR notation for efficient address allocation."
            ],
            "content": {
                "overview": "IP addresses are the foundation of the Internet layer, providing a unique logical address for every device. This lesson covers the details of both IPv4 and its successor, IPv6. We will dive deep into the crucial skill of subnetting, which allows network administrators to partition large networks and manage traffic efficiently.",
                "sections": [
                    {
                        "title": "IPv4 Addressing",
                        "content": "<p>An IPv4 address is a 32-bit number, typically written as four decimal numbers (octets) separated by periods, e.g., <code>192.168.1.1</code>. Each octet can range from 0 to 255.</p><p>An IP address is split into two parts: the <strong>Network ID</strong> and the <strong>Host ID</strong>. The <strong>subnet mask</strong> is a separate 32-bit number that determines which part is which. For example, with a subnet mask of <code>255.255.255.0</code>, the first three octets are the Network ID and the last octet is the Host ID.</p><h3>Private IP Address Ranges:</h3><p>Certain address ranges are reserved for use in private networks and are not routable on the public internet. This allows organizations to use the same internal addresses.</p><ul><li><strong>Class A:</strong> 10.0.0.0 to 10.255.255.255</li><li><strong>Class B:</strong> 172.16.0.0 to 172.31.255.255</li><li><strong>Class C:</strong> 192.168.0.0 to 192.168.255.255</li></ul>",
                        "image": "https://images.unsplash.com/photo-1558522195-e12713519528?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Subnetting and CIDR Notation",
                        "content": "<p><strong>Subnetting</strong> is the process of dividing a single large network into multiple smaller networks (subnets). This is done by 'borrowing' bits from the Host ID part of the address to create a Subnet ID. Subnetting reduces broadcast traffic, improves security, and allows for more efficient use of IP addresses.</p><p><strong>Classless Inter-Domain Routing (CIDR)</strong> notation is the modern way to represent a subnet mask. It is a slash followed by a number that represents the count of consecutive '1' bits in the subnet mask. For example:</p><ul><li><code>255.255.255.0</code> is a 24-bit mask, so it's written as <code>/24</code>.</li><li><code>255.255.0.0</code> is a 16-bit mask, written as <code>/16</code>.</li><li><code>192.168.1.0/24</code> represents the network where all addresses from 192.168.1.0 to 192.168.1.255 belong.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1504868584819-f8e8b4b6d7e3?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "IPv6 Addressing",
                        "content": "<p>Due to the exhaustion of IPv4 addresses, IPv6 was developed. An IPv6 address is a 128-bit number, providing a vastly larger address space (2<sup>128</sup> addresses).</p><h3>IPv6 Notation:</h3><p>It is written as eight groups of four hexadecimal digits, separated by colons. Example: <code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code>.</p><h3>Abbreviation Rules:</h3><ol><li>Leading zeros in any group can be omitted: <code>0db8</code> becomes <code>db8</code>.</li><li>One consecutive sequence of all-zero groups can be replaced with a double colon (<code>::</code>). This can only be done once per address.</li></ol><p>The example above can be abbreviated to: <code>2001:db8:85a3::8a2e:370:7334</code>.</p><p>IPv6 uses a <code>/64</code> prefix for most standard LANs, providing 64 bits for the network portion and 64 bits for the host portion.</p>",
                        "image": "https://images.unsplash.com/photo-1614063217255-911b55c82245?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Viewing IP Configuration in Linux",
                        "language": "bash",
                        "code": "# Show details for all network interfaces, including IPv4 and IPv6 addresses\nip addr show\n\n# Or, for a specific interface like eth0\nip addr show eth0"
                    },
                    {
                        "title": "Viewing IP Configuration in Windows",
                        "language": "bash",
                        "code": "# Show basic IP configuration for all adapters\nipconfig\n\n# Show full details, including MAC address, DHCP server, etc.\nipconfig /all"
                    },
                    {
                        "title": "Subnetting Example Calculation",
                        "language": "text",
                        "code": "Given the network 192.168.10.0/24, we want to create 4 subnets.\n\n1. We need to borrow bits from the host portion. To get 4 subnets, we need 2 bits (2^2 = 4).\n\n2. The new subnet mask will be /26 (24 + 2 = 26).\n   In decimal, this is 255.255.255.192.\n\n3. The subnets will be:\n   - 192.168.10.0/26   (Hosts .1 to .62)\n   - 192.168.10.64/26  (Hosts .65 to .126)\n   - 192.168.10.128/26 (Hosts .129 to .190)\n   - 192.168.10.192/26 (Hosts .193 to .254)"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "Which of the following is a private IPv4 address?",
                        "options": ["172.32.10.5", "10.1.1.254", "8.8.8.8", "192.169.1.1"],
                        "correct": 1,
                        "explanation": "The 10.0.0.0/8 range (from 10.0.0.0 to 10.255.255.255) is one of the designated private IP address ranges."
                    },
                    {
                        "id": 2,
                        "question": "What does the `/24` in the CIDR notation `198.51.100.0/24` represent?",
                        "options": ["The first 24 IP addresses are usable", "There are 24 hosts in the network", "The network has 24 subnets", "The first 24 bits of the address are the network portion"],
                        "correct": 3,
                        "explanation": "The CIDR suffix represents the number of bits in the network portion of the address, which defines the subnet mask (in this case, 255.255.255.0)."
                    },
                    {
                        "id": 3,
                        "question": "How many bits are in an IPv6 address?",
                        "options": ["32", "48", "64", "128"],
                        "correct": 3,
                        "explanation": "An IPv6 address is 128 bits long, providing a massive address space to accommodate the growing number of internet-connected devices."
                    },
                    {
                        "id": 4,
                        "question": "What is the primary purpose of subnetting?",
                        "options": ["To increase the speed of the network", "To divide a large network into smaller, more manageable broadcast domains", "To connect different types of networks together", "To assign MAC addresses to hosts"],
                        "correct": 1,
                        "explanation": "Subnetting allows a network administrator to break down a large network, which improves performance by limiting broadcast traffic and enhances security by segmenting the network."
                    },
                    {
                        "id": 5,
                        "question": "What is the correct abbreviation for the IPv6 address `2001:0db8:0000:0000:1234:00ab:0000:cdef`?",
                        "options": ["2001:db8::1234:ab::cdef", "2001:db8:0:0:1234:ab:0:cdef", "2001:db8::1234:ab:0:cdef", "2001:db8:1234:ab:cdef"],
                        "correct": 2,
                        "explanation": "Leading zeros can be removed from each block, and the longest consecutive block of zeros (`0000:0000`) can be replaced with `::`. The single `0000` after `ab` cannot be replaced with `::` again, but it can be shortened to `0`."
                    }
                ]
            }
        },
        {
            "id": "lesson-4",
            "title": "ARP & RARP",
            "duration": "60 min",
            "objectives": [
                "Understand the purpose of the Address Resolution Protocol (ARP).",
                "Analyze the ARP request and reply process.",
                "Inspect the ARP cache on a host.",
                "Recognize the security threat of ARP cache poisoning."
            ],
            "content": {
                "overview": "When a host needs to send a packet to another host on the same local network, it knows the destination IP address but needs the physical MAC address to create the Ethernet frame. This lesson explores the Address Resolution Protocol (ARP), the critical utility that translates Layer 3 IP addresses to Layer 2 MAC addresses, and its historical counterpart, RARP.",
                "sections": [
                    {
                        "title": "The Purpose of ARP",
                        "content": "<p>ARP is the bridge between the Internet layer and the Network Access layer. Imagine Host A (IP 192.168.1.10) wants to send data to Host B (IP 192.168.1.20) on the same Ethernet network.</p><ul><li>Host A knows the destination IP address (Layer 3).</li><li>To create the Ethernet frame for local delivery, it needs Host B's MAC address (Layer 2).</li><li>ARP is the protocol used to discover this MAC address.</li></ul><p>Without ARP, local network communication would not be possible in IPv4 networks.</p>",
                        "image": "https://images.unsplash.com/photo-1573497161211-a55e3742b4b4?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The ARP Process: Request and Reply",
                        "content": "<p>The process is a simple two-step exchange:</p><ol><li><strong>ARP Request:</strong> Host A broadcasts a special ARP Request packet to every device on the local network. The message essentially asks, \"Who has the IP address 192.168.1.20? Please tell me your MAC address.\" This request packet contains Host A's own IP and MAC address.</li><li><strong>ARP Reply:</strong> Host B recognizes its own IP address in the request. It then sends an ARP Reply packet directly back to Host A (unicast). This reply contains Host B's MAC address. All other hosts on the network silently discard the ARP request.</li></ol>",
                        "image": "https://images.unsplash.com/photo-1544198365-f5d60b6d8190?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The ARP Cache",
                        "content": "<p>To avoid sending an ARP request for every single packet, hosts maintain an <strong>ARP cache</strong> (or ARP table), which is a temporary in-memory map of recently resolved IP addresses to their corresponding MAC addresses.</p><p>When Host A wants to send another packet to Host B, it first checks its ARP cache. If an entry for 192.168.1.20 exists, it uses the cached MAC address directly, skipping the broadcast/reply process entirely. These entries expire after a short time to ensure the information stays current.</p>",
                        "image": "https://images.unsplash.com/photo-1581291518857-4e27b48ff24e?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "ARP Cache Poisoning (Spoofing)",
                        "content": "<p>Since ARP is a stateless and trusting protocol, it is vulnerable to attack. In an <strong>ARP cache poisoning</strong> attack, a malicious actor sends forged ARP replies onto the network. For example, the attacker could send an ARP reply to Host A claiming that their own MAC address corresponds to the IP address of the default gateway (the router).</p><p>Host A would then update its ARP cache and unknowingly send all its internet-bound traffic to the attacker instead of the real router. This allows the attacker to perform a 'Man-in-the-Middle' attack, eavesdropping on or modifying the traffic.</p><div class=\"info-box warning\"><div class=\"info-box-header\"><i class=\"fas fa-exclamation-triangle\"></i><strong>Security Note</strong></div><p>Tools like Ettercap and Cain & Abel can be used to perform ARP spoofing. In a lab environment, this is a powerful way to learn, but using them on a live network without permission is illegal.</p></div>",
                        "image": "https://images.unsplash.com/photo-1563206767-5b18f218e8de?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Viewing the ARP Cache in Linux",
                        "language": "bash",
                        "code": "# Show the kernel's IPv4 neighbor cache (ARP table)\nip neighbour show\n\n# A more traditional command that also works\narp -a"
                    },
                    {
                        "title": "Viewing the ARP Cache in Windows",
                        "language": "bash",
                        "code": "# Show the current ARP entries\narp -a"
                    },
                    {
                        "title": "Wireshark Filter for ARP Traffic",
                        "language": "text",
                        "code": "# In Wireshark, this display filter will show only ARP request and reply packets, \n# making it easy to analyze the resolution process.\n\narp"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary function of ARP?",
                        "options": ["To assign IP addresses to hosts", "To route packets between different networks", "To resolve an IP address to a MAC address", "To resolve a domain name to an IP address"],
                        "correct": 2,
                        "explanation": "ARP's main purpose is to find the physical (MAC) address of a host on the local network when you only know its logical (IP) address."
                    },
                    {
                        "id": 2,
                        "question": "An ARP Request is sent as a ________ packet, and an ARP Reply is sent as a ________ packet.",
                        "options": ["unicast, unicast", "broadcast, broadcast", "unicast, broadcast", "broadcast, unicast"],
                        "correct": 3,
                        "explanation": "The ARP Request must be broadcast to all devices on the local network because the sender doesn't know who has the target IP. The ARP Reply is sent directly (unicast) back to the original requester."
                    },
                    {
                        "id": 3,
                        "question": "What is an ARP cache?",
                        "options": ["A file that stores all MAC addresses on the internet", "A physical hardware device for storing IP addresses", "A temporary table in memory that maps IP addresses to MAC addresses", "A log of all ARP requests and replies"],
                        "correct": 2,
                        "explanation": "The ARP cache is a temporary list of resolved IP-to-MAC address mappings stored by a host to avoid having to perform an ARP request for every single packet."
                    },
                    {
                        "id": 4,
                        "question": "ARP cache poisoning is a type of what kind of attack?",
                        "options": ["Denial of Service (DoS)", "Man-in-the-Middle (MITM)", "Phishing", "Brute Force"],
                        "correct": 1,
                        "explanation": "By tricking a host into sending traffic to the attacker's machine instead of the legitimate destination (like the router), ARP poisoning allows the attacker to place themselves in the 'middle' of the communication."
                    },
                    {
                        "id": 5,
                        "question": "Does IPv6 use ARP?",
                        "options": ["Yes, it uses an updated version of ARP", "No, it uses a different protocol called NDP", "Yes, it uses the exact same ARP protocol as IPv4", "No, IPv6 does not need to resolve addresses"],
                        "correct": 1,
                        "explanation": "IPv6 does not use ARP. It replaces its functionality with the Neighbor Discovery Protocol (NDP), which uses ICMPv6 messages to perform similar address resolution tasks."
                    }
                ]
            }
        },
        {
            "id": "lesson-5",
            "title": "ICMP (Ping, Traceroute)",
            "duration": "75 min",
            "objectives": [
                "Understand the role of the Internet Control Message Protocol (ICMP) for diagnostics.",
                "Analyze the mechanics of the `ping` command (Echo Request/Reply).",
                "Learn how `traceroute` uses ICMP and Time-To-Live (TTL) to map network paths.",
                "Identify common ICMP error messages."
            ],
            "content": {
                "overview": "ICMP is the diagnostic backbone of the Internet Protocol. It's not used for user data, but for sending error messages and operational information. This lesson explores how essential tools like `ping` and `traceroute` leverage ICMP to test connectivity, measure latency, and discover the path your packets take across the internet.",
                "sections": [
                    {
                        "title": "The Role of ICMP",
                        "content": "<p>The Internet Protocol (IP) itself has no built-in mechanism for sending error and control messages. If a router can't deliver a packet or if something goes wrong, it needs a way to report that back to the source. This is the job of ICMP.</p><p>ICMP messages are encapsulated within IP packets, just like TCP or UDP data. They are used by network devices, like routers, to communicate with the source IP address about issues with packet delivery.</p>",
                        "image": "https://images.unsplash.com/photo-1517420704952-d9f39e95b43e?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "`ping` and Echo Request/Reply",
                        "content": "<p>The most famous use of ICMP is the <code>ping</code> utility. It's the simplest way to test basic connectivity between two hosts.</p><h3>How it Works:</h3><ol><li>When you run <code>ping google.com</code>, your computer sends an <strong>ICMP Type 8 (Echo Request)</strong> message to the IP address of google.com.</li><li>If the server at google.com is reachable and not configured to block pings, it will respond with an <strong>ICMP Type 0 (Echo Reply)</strong> message.</li></ol><p>The output of ping shows you the round-trip time (RTT) for each packet and reports if any packets were lost, giving you a quick measure of network latency and reliability.</p>",
                        "image": "https://images.unsplash.com/photo-1550751827-4bd374c3f58b?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "`traceroute` and Time-To-Live (TTL)",
                        "content": "<p>The <code>traceroute</code> (or <code>tracert</code> on Windows) command is a brilliant utility that maps the path a packet takes through the network to reach a destination.</p><h3>How it Works:</h3><p>It cleverly manipulates the <strong>Time-To-Live (TTL)</strong> field in the IP header. TTL is a number that is decremented by every router that forwards the packet. If the TTL reaches zero, the router discards the packet and sends an <strong>ICMP Type 11 (Time Exceeded)</strong> message back to the source.</p><ol><li>Traceroute sends a packet with a TTL of 1. The first router decrements it to 0, discards it, and sends an ICMP error back. The source now knows the IP of the first router.</li><li>It then sends a packet with a TTL of 2. It passes the first router, but the second router decrements it to 0 and sends an error back. The source now knows the IP of the second router.</li><li>This process repeats until the packet reaches the final destination, which responds with a different ICMP message, ending the trace.</li></ol>",
                        "image": "https://images.unsplash.com/photo-1484589065579-248a07195b07?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Common ICMP Error Messages",
                        "content": "<p>Besides the messages used by ping and traceroute, ICMP is used to report various errors:</p><ul><li><strong>Type 3: Destination Unreachable:</strong> A generic error sent by a router when it cannot deliver a packet. It comes with different codes, such as:<ul><li><em>Code 0: Network Unreachable</em></li><li><em>Code 1: Host Unreachable</em></li><li><em>Code 3: Port Unreachable</em> (sent by the destination host if the target port is closed)</li></ul></li><li><strong>Type 5: Redirect:</strong> Sent by a router to inform a host of a better route to a destination.</li></ul><p>Analyzing these messages in Wireshark can be extremely helpful for troubleshooting complex network issues.</p>",
                        "image": "https://images.unsplash.com/photo-1544256718-3bcf237f3974?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Using `ping`",
                        "language": "bash",
                        "code": "# Ping a host until stopped (Ctrl+C)\nping google.com\n\n# Ping a host only 4 times (standard behavior on Windows)\nping -c 4 google.com\n\n# Ping with a larger packet size (e.g., 1024 bytes)\nping -s 1024 google.com"
                    },
                    {
                        "title": "Using `traceroute`",
                        "language": "bash",
                        "code": "# Trace the route to google.com (on Linux)\ntraceroute google.com\n\n# Trace the route to google.com (on Windows)\ntracert google.com"
                    },
                    {
                        "title": "Wireshark Filter for ICMP",
                        "language": "text",
                        "code": "# This filter will show all ICMP traffic, including echo requests/replies\n# and any error messages like 'Destination Unreachable'.\n\nicmp\n\n# To see only Time Exceeded messages generated by traceroute:\nicmp.type == 11"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary purpose of ICMP?",
                        "options": ["To transfer user data reliably", "To provide error reporting and network diagnostics for IP", "To manage sessions between applications", "To download files from a server"],
                        "correct": 1,
                        "explanation": "ICMP is a control protocol used by network devices to send messages regarding the state of the network and the delivery of IP packets, but it does not carry application data."
                    },
                    {
                        "id": 2,
                        "question": "The `ping` command sends an ICMP ________ message and expects an ICMP ________ message in return.",
                        "options": ["Echo Request, Echo Reply", "Time Exceeded, Port Unreachable", "Echo Reply, Echo Request", "Ping, Pong"],
                        "correct": 0,
                        "explanation": "A successful ping consists of an ICMP Type 8 (Echo Request) sent from the source and a corresponding ICMP Type 0 (Echo Reply) received from the destination."
                    },
                    {
                        "id": 3,
                        "question": "The `traceroute` command relies on which IP header field and which ICMP message type?",
                        "options": ["Sequence Number and ICMP Echo Reply", "Port Number and ICMP Port Unreachable", "TTL and ICMP Time Exceeded", "Checksum and ICMP Redirect"],
                        "correct": 2,
                        "explanation": "`traceroute` works by sending packets with incrementally increasing TTL values and listening for the ICMP Type 11 (Time Exceeded) messages returned by each router along the path."
                    },
                    {
                        "id": 4,
                        "question": "If you try to connect to a server on a port that is not open, what ICMP message might you receive?",
                        "options": ["Host Unreachable", "Time Exceeded", "Redirect", "Port Unreachable"],
                        "correct": 3,
                        "explanation": "The destination host's operating system will send an ICMP Type 3, Code 3 (Port Unreachable) message to indicate that while the host is up, the specific application port is not listening."
                    },
                    {
                        "id": 5,
                        "question": "Why might a `ping` to a known working server fail?",
                        "options": ["The server is too busy", "Your DNS server is down", "A firewall is blocking ICMP traffic", "All of the above"],
                        "correct": 3,
                        "explanation": "All of these are valid reasons. A busy server might not respond (unlikely), a failed DNS lookup would prevent your computer from getting the IP address, and many network administrators block ICMP at the firewall for security reasons."
                    }
                ]
            }
        },
        {
            "id": "lesson-6",
            "title": "UDP",
            "duration": "60 min",
            "objectives": [
                "Understand the characteristics of the User Datagram Protocol (UDP).",
                "Analyze the structure of a UDP header.",
                "Identify common use cases for connectionless communication.",
                "Recognize the trade-offs of using UDP over TCP."
            ],
            "content": {
                "overview": "UDP is the second major protocol of the Transport Layer. In stark contrast to TCP, UDP is a simple, lightweight, connectionless protocol that offers no reliability, ordering, or flow control. This lesson explores why this 'fire-and-forget' mechanism is not a flaw, but a feature that makes it perfect for speed-sensitive applications.",
                "sections": [
                    {
                        "title": "Characteristics of UDP",
                        "content": "<p>The User Datagram Protocol (UDP) is defined by what it <em>doesn't</em> do. It provides the bare minimum features for a transport protocol.</p><ul><li><strong>Connectionless:</strong> No handshake is required before sending data. A host can send a UDP datagram to a destination at any time.</li><li><strong>Unreliable:</strong> There is no acknowledgment of receipt. Datagrams may be lost, duplicated, or arrive out of order, and UDP will not try to correct it.</li><li><strong>Low Overhead:</strong> The UDP header is very small (8 bytes), compared to TCP's header (20+ bytes). This makes it fast and efficient.</li><li><strong>Datagram-Oriented:</strong> UDP sends discrete messages (datagrams). There is no concept of a continuous stream of bytes.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1593432832969-a862b2f69894?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The UDP Header",
                        "content": "<p>The simplicity of UDP is reflected in its header, which has only four fields:</p><ul><li><strong>Source Port (16 bits):</strong> Identifies the port of the sending application. This is optional and can be set to zero if no reply is needed.</li><li><strong>Destination Port (16 bits):</strong> Identifies the port of the receiving application. This is mandatory.</li><li><strong>Length (16 bits):</strong> The length in bytes of the UDP header and the encapsulated data.</li><li><strong>Checksum (16 bits):</strong> An optional field used for error checking of the header and data. If an error is detected, the datagram is typically discarded.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1555949963-aa79dcee981c?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Common Use Cases for UDP",
                        "content": "<p>UDP is the protocol of choice when speed is more important than perfect reliability. If a packet is lost, it's often better to just send the next one rather than wait for a retransmission.</p><h3>Examples:</h3><ul><li><strong>Streaming Media:</strong> In a live video or audio stream, losing a single frame or a millisecond of audio is usually unnoticeable. The delay caused by TCP retransmissions would be far more disruptive.</li><li><strong>Online Gaming:</strong> Real-time games need to send player position updates as quickly as possible. Old data is useless, so waiting for a lost packet is counterproductive.</li><li><strong>DNS (Domain Name System):</strong> A DNS query is a simple, small request-reply exchange. Using UDP is much faster than the overhead of setting up and tearing down a TCP connection.</li><li><strong>VoIP (Voice over IP):</strong> Similar to streaming, real-time voice conversations prioritize low latency over perfect data integrity.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1542751371-adc38448a05e?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Simple Python UDP Server",
                        "language": "python",
                        "code": "import socket\n\n# Create a UDP socket\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\n# Bind the socket to an IP and port\nserver_address = ('localhost', 10000)\nserver_socket.bind(server_address)\n\nprint('UDP server is up and listening')\n\nwhile True:\n    # Wait to receive a datagram\n    data, address = server_socket.recvfrom(4096)\n    print(f'Received {len(data)} bytes from {address}')\n    print(f'Data: {data.decode()}')\n\n    # Echo the data back to the client\n    server_socket.sendto(data, address)"
                    },
                    {
                        "title": "Simple Python UDP Client",
                        "language": "python",
                        "code": "import socket\n\n# Create a UDP socket\nclient_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\nserver_address = ('localhost', 10000)\nmessage = b'This is a test message from the client.'\n\ntry:\n    # Send data - no connection needed\n    print(f'Sending: {message.decode()}')\n    client_socket.sendto(message, server_address)\n\n    # Look for a response\n    data, server = client_socket.recvfrom(4096)\n    print(f'Received: {data.decode()}')\n\nfinally:\n    print('Closing socket')\n    client_socket.close()"
                    },
                    {
                        "title": "Wireshark Filter for UDP",
                        "language": "text",
                        "code": "# Show only UDP traffic\nudp\n\n# Filter for DNS traffic (which typically uses UDP port 53)\nudp.port == 53"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "Which of the following is a key characteristic of UDP?",
                        "options": ["Connection-oriented", "Reliable delivery", "Low overhead", "Guaranteed packet ordering"],
                        "correct": 2,
                        "explanation": "UDP's primary advantages are its speed and low overhead, achieved by omitting the reliability and session management features of TCP."
                    },
                    {
                        "id": 2,
                        "question": "Which of these applications is most likely to use UDP?",
                        "options": ["Email (SMTP)", "File transfer (FTP)", "Web browsing (HTTP)", "Live video streaming"],
                        "correct": 3,
                        "explanation": "Live video streaming prioritizes speed and low latency. Losing a single frame is less disruptive than pausing the entire stream to wait for a retransmission, making UDP the ideal choice."
                    },
                    {
                        "id": 3,
                        "question": "Does UDP use a handshake to establish a connection before sending data?",
                        "options": ["Yes, it uses a 3-way handshake", "Yes, but it's a simpler 2-way handshake", "No, it is a connectionless protocol", "Only when the checksum is used"],
                        "correct": 2,
                        "explanation": "UDP is connectionless, meaning no prior connection or handshake is established. Data is simply sent to the destination port."
                    },
                    {
                        "id": 4,
                        "question": "How many bytes are in a standard UDP header?",
                        "options": ["8 bytes", "16 bytes", "20 bytes", "32 bytes"],
                        "correct": 0,
                        "explanation": "The UDP header is very simple and lightweight, consisting of only four 16-bit fields, for a total of 8 bytes."
                    },
                    {
                        "id": 5,
                        "question": "If a UDP datagram arrives with a checksum error, what typically happens?",
                        "options": ["The receiver requests a retransmission", "The receiver attempts to fix the error", "The receiver silently discards the datagram", "The receiver sends an ICMP error message"],
                        "correct": 2,
                        "explanation": "UDP itself has no mechanism for retransmission. If the checksum (which is used for error detection) fails, the receiving host's operating system will typically discard the corrupted datagram."
                    }
                ]
            }
        },
        {
            "id": "lesson-7",
            "title": "TCP",
            "duration": "120 min",
            "objectives": [
                "Understand the core features of the Transmission Control Protocol (TCP).",
                "Analyze the TCP 3-way handshake process (SYN, SYN-ACK, ACK).",
                "Learn about sequence and acknowledgment numbers for reliability.",
                "Grasp the concepts of flow control and congestion control."
            ],
            "content": {
                "overview": "TCP is the reliable workhorse of the Transport Layer and the internet. It provides a connection-oriented, ordered, and error-checked stream of data between applications. This lesson delves into the sophisticated mechanisms that TCP uses to guarantee delivery, from the famous 3-way handshake to its methods for managing data flow and network congestion.",
                "sections": [
                    {
                        "title": "Core Features of TCP",
                        "content": "<p>The Transmission Control Protocol (TCP) is designed for reliability, not speed. It ensures that every byte of data sent is received correctly and in the right order.</p><ul><li><strong>Connection-Oriented:</strong> A connection must be established via a handshake process before any data can be sent.</li><li><strong>Reliable:</strong> TCP uses sequence numbers and acknowledgments (ACKs) to ensure every segment is received. Lost segments are retransmitted.</li><li><strong>Ordered:</strong> TCP guarantees that the data is delivered to the application in the same order it was sent.</li><li><strong>Flow Control:</strong> A 'sliding window' mechanism prevents a fast sender from overwhelming a slow receiver.</li><li><strong>Congestion Control:</strong> TCP has algorithms to slow down data transmission when it detects that the network is congested, helping to prevent network collapse.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1593432832969-a862b2f69894?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The TCP 3-Way Handshake",
                        "content": "<p>Before data can be exchanged, a client and server must establish a connection using a three-step process called the 3-way handshake. This process synchronizes the sequence numbers between the two hosts.</p><ol><li><strong>SYN:</strong> The client sends a TCP segment with the SYN (Synchronize) flag set to the server. This packet includes an initial sequence number (ISN).</li><li><strong>SYN-ACK:</strong> The server receives the SYN, allocates resources for the connection, and responds with a segment that has both the SYN and ACK (Acknowledgment) flags set. It acknowledges the client's ISN and provides its own ISN.</li><li><strong>ACK:</strong> The client receives the SYN-ACK and sends a final ACK segment back to the server, acknowledging the server's ISN.</li></ol><p>At this point, the connection is established, and data transfer can begin.</p>",
                        "image": "https://images.unsplash.com/photo-1544198365-f5d60b6d8190?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Sequence and Acknowledgment Numbers",
                        "content": "<p>Reliability is achieved through the use of sequence and acknowledgment numbers. When a host sends a TCP segment, it includes a sequence number that indicates the position of the data in the overall byte stream. When the other host receives the data, it sends back a segment with an acknowledgment number. This acknowledgment number is the sequence number of the *next* byte it expects to receive.</p><p>For example, if a host sends a segment with 100 bytes of data and a sequence number of 500, the receiver, upon successful receipt, will send back an acknowledgment number of 600 (500 + 100). If the sender doesn't receive this ACK within a certain time, it assumes the segment was lost and retransmits it.</p>",
                        "image": "https://images.unsplash.com/photo-1555949963-aa79dcee981c?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Flow and Congestion Control",
                        "content": "<p>TCP manages the rate of data transfer to protect both the receiver and the network itself.</p><ul><li><strong>Flow Control (Sliding Window):</strong> The receiver advertises a 'receive window' size in its acknowledgment packets. This tells the sender how much buffer space it has available. The sender can transmit up to this amount of data before it must wait for another acknowledgment, preventing it from overwhelming the receiver.</li><li><strong>Congestion Control:</strong> TCP assumes that packet loss is caused by network congestion. When a packet is lost, it dramatically slows down its sending rate. It then slowly increases the rate again ('slow start') until it detects more loss, constantly probing for the optimal transmission speed the network can handle.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1504868584819-f8e8b4b6d7e3?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "TCP Flags in Wireshark",
                        "language": "text",
                        "code": "# SYN Flag: Set during the start of a connection.\n# Filter: tcp.flags.syn == 1 && tcp.flags.ack == 0\n\n# SYN-ACK Flag: The server's response during the handshake.\n# Filter: tcp.flags.syn == 1 && tcp.flags.ack == 1\n\n# ACK Flag: Acknowledging received data.\n# Filter: tcp.flags.ack == 1\n\n# FIN Flag: Set to terminate a connection.\n# Filter: tcp.flags.fin == 1\n\n# RST Flag: Set to abruptly reset a connection.\n# Filter: tcp.flags.reset == 1"
                    },
                    {
                        "title": "Wireshark Filter for the 3-Way Handshake",
                        "language": "text",
                        "code": "# This filter will isolate the SYN, SYN-ACK, and ACK packets that begin a TCP session.\n# Replace '192.168.1.10' with your client IP and '54.239.28.85' with a server IP.\n\n(ip.addr == 192.168.1.10 && ip.addr == 54.239.28.85) && (tcp.flags.syn == 1 || tcp.flags.ack == 1)"
                    },
                    {
                        "title": "Using `netstat` or `ss` to View TCP Connections",
                        "language": "bash",
                        "code": "# Show all active TCP connections (Linux)\nss -t\n\n# Show all listening TCP ports and the processes using them (Linux)\nsudo ss -tlp\n\n# Show active TCP connections (Windows / older Linux)\nnetstat -an | findstr TCP"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What are the three steps of the TCP 3-way handshake in the correct order?",
                        "options": ["SYN, ACK, SYN-ACK", "SYN, FIN, ACK", "SYN, SYN-ACK, ACK", "ACK, SYN, FIN"],
                        "correct": 2,
                        "explanation": "The client initiates with a SYN, the server responds with a SYN-ACK, and the client completes the connection by sending an ACK."
                    },
                    {
                        "id": 2,
                        "question": "Which TCP mechanism prevents a fast sender from overwhelming a slow receiver?",
                        "options": ["Congestion Control", "Sequence Numbers", "Flow Control (Sliding Window)", "3-Way Handshake"],
                        "correct": 2,
                        "explanation": "Flow control uses the receiver's advertised 'receive window' to ensure the sender does not send more data than the receiver can buffer."
                    },
                    {
                        "id": 3,
                        "question": "If a TCP segment is lost in transit, what happens?",
                        "options": ["The connection is immediately reset", "The data is lost permanently", "The sender's timeout expires, and it retransmits the lost segment", "The receiver sends a NACK (Negative Acknowledgment)"],
                        "correct": 2,
                        "explanation": "TCP's reliability is based on positive acknowledgment. If an acknowledgment for a segment is not received within a certain time, the sender assumes it was lost and sends it again."
                    },
                    {
                        "id": 4,
                        "question": "What is the primary purpose of TCP sequence numbers?",
                        "options": ["To count the number of connections", "To identify the source and destination ports", "To track the order of bytes in the data stream and acknowledge them", "To set the priority of the packet"],
                        "correct": 2,
                        "explanation": "Sequence numbers track every byte of data, allowing the receiver to reassemble the data in the correct order and to specifically acknowledge which data has been received."
                    },
                    {
                        "id": 5,
                        "question": "Which of the following applications absolutely requires the reliability of TCP?",
                        "options": ["Live video conference", "Online gaming", "DNS lookup", "Downloading a software executable"],
                        "correct": 3,
                        "explanation": "When downloading a file like a program, every single bit must be correct and in order. Any corruption would render the file unusable. This requires the guaranteed delivery provided by TCP."
                    }
                ]
            }
        },
        {
            "id": "lesson-8",
            "title": "TCP vs UDP",
            "duration": "60 min",
            "objectives": [
                "Clearly articulate the key differences between TCP and UDP.",
                "Analyze the performance and reliability trade-offs.",
                "Identify appropriate use cases for each protocol.",
                "Understand how some applications use both protocols."
            ],
            "content": {
                "overview": "The choice between TCP and UDP is a fundamental decision in application design that balances reliability against speed. This lesson provides a direct comparison of the two Transport Layer giants, exploring their headers, features, and ideal applications, so you can understand why one is chosen over the other.",
                "sections": [
                    {
                        "title": "Head-to-Head Comparison",
                        "content": "<p>This table summarizes the core differences between TCP and UDP:</p><table class=\"comparison-table\"><thead><tr><th>Feature</th><th>TCP (Transmission Control Protocol)</th><th>UDP (User Datagram Protocol)</th></tr></thead><tbody><tr><td><strong>Connection</strong></td><td>Connection-Oriented (handshake required)</td><td>Connectionless (no handshake)</td></tr><tr><td><strong>Reliability</strong></td><td>Reliable (acknowledgments, retransmissions)</td><td>Unreliable (fire-and-forget)</td></tr><tr><td><strong>Ordering</strong></td><td>Ordered (segments are reassembled)</td><td>Unordered (datagrams may arrive out of order)</td></tr><tr><td><strong>Speed</strong></td><td>Slower due to overhead</td><td>Faster due to simplicity</td></tr><tr><td><strong>Header Size</strong></td><td>20 bytes (plus options)</td><td>8 bytes</td></tr><tr><td><strong>Flow Control</strong></td><td>Yes (sliding window)</td><td>No</td></tr><tr><td><strong>Use Cases</strong></td><td>Web, Email, File Transfer</td><td>Streaming, Gaming, DNS, VoIP</td></tr></tbody></table>",
                        "image": "https://images.unsplash.com/photo-1544198365-f5d60b6d8190?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Choosing the Right Protocol: A Use Case Analysis",
                        "content": "<p>The decision to use TCP or UDP depends entirely on the application's requirements.</p><h3>When to use TCP:</h3><p>Choose TCP when the integrity of the data is paramount. Every single byte must arrive, and it must be in the correct order. The built-in error checking and retransmission mechanisms make it ideal for:</p><ul><li><strong>File Transfers (FTP, SFTP):</strong> A corrupted file is useless.</li><li><strong>Web Browsing (HTTP/S):</strong> Web pages need to load completely and correctly to be rendered properly.</li><li><strong>Email (SMTP, IMAP):</strong> You cannot afford to have parts of an email missing or out of order.</li></ul><h3>When to use UDP:</h3><p>Choose UDP when speed and low latency are more important than 100% reliability. Applications that use UDP often have their own methods for handling packet loss if needed.</p><ul><li><strong>Live Streaming (RTP):</strong> A lost packet might cause a momentary glitch in the video, which is better than pausing the whole stream to wait for a retransmission.</li><li><strong>DNS Queries:</strong> The request/response is small and simple. If a packet is lost, the application can just send the query again. The overhead of a TCP connection isn't worth it.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1516321497487-e288fb19713f?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "QUIC: The Best of Both Worlds?",
                        "content": "<p>Modern protocols are starting to blur the lines. <strong>QUIC (Quick UDP Internet Connections)</strong> is a new transport protocol developed by Google, which is now an IETF standard. It runs on top of UDP but is designed to provide TCP-like features such as reliability, ordering, and congestion control, but with much lower latency.</p><p>For example, it combines the transport and cryptographic handshakes into a single round trip. It is the underlying protocol for HTTP/3 and aims to provide a faster, more efficient web experience. This shows the ongoing evolution of transport protocols to meet modern demands.</p>",
                        "image": "https://images.unsplash.com/photo-1618477388954-7852f32655ec?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Wireshark Filter to Compare Streams",
                        "language": "text",
                        "code": "# Show only TCP traffic\ntcp\n\n# Show only UDP traffic\nudp\n\n# By capturing both and switching between these filters, you can clearly see\n# the handshake and acknowledgments in TCP that are absent in UDP."
                    },
                    {
                        "title": "Conceptual Performance Comparison",
                        "language": "text",
                        "code": "# File Transfer (TCP is better)\n# Application needs to know all data was received correctly.\n# TCP's reliability ensures the file is not corrupted.\n\n# Voice Call (UDP is better)\n# Application needs low latency for real-time conversation.\n# A lost packet (minor audio glitch) is preferable to a long pause (TCP retransmission)."
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary advantage of UDP over TCP?",
                        "options": ["Reliability", "Guaranteed order", "Speed and low overhead", "Flow control"],
                        "correct": 2,
                        "explanation": "UDP's main selling point is its simplicity, which results in a smaller header and no connection setup delay, making it significantly faster than TCP."
                    },
                    {
                        "id": 2,
                        "question": "An application that transfers a large financial database would use which protocol?",
                        "options": ["TCP, because data integrity is critical", "UDP, because the transfer needs to be fast", "Either, it doesn't matter", "ARP, because it's a database"],
                        "correct": 0,
                        "explanation": "For financial data, every single byte must be accurate. The reliability, error-checking, and guaranteed delivery of TCP are absolutely essential."
                    },
                    {
                        "id": 3,
                        "question": "The Domain Name System (DNS) protocol typically uses UDP for its queries. Why?",
                        "options": ["DNS queries are highly secure and UDP is encrypted", "The request and response are small, making the speed of UDP more efficient", "DNS needs to maintain a constant connection", "UDP can handle larger packets than TCP"],
                        "correct": 1,
                        "explanation": "A DNS query is a small, transactional request. The overhead of a TCP 3-way handshake and connection teardown would add unnecessary latency. If a DNS query packet is lost, the client simply re-sends it."
                    },
                    {
                        "id": 4,
                        "question": "Which of the following features is present in TCP but NOT in UDP?",
                        "options": ["Port Numbers", "Checksum for error detection", "Connection-oriented session setup", "Encapsulation within an IP packet"],
                        "correct": 2,
                        "explanation": "Both TCP and UDP use port numbers and have an optional checksum. However, only TCP is connection-oriented and performs a handshake before data transfer."
                    },
                    {
                        "id": 5,
                        "question": "The QUIC protocol is built on top of which other protocol?",
                        "options": ["TCP", "IP", "UDP", "ICMP"],
                        "correct": 2,
                        "explanation": "QUIC is a newer protocol that runs over UDP but implements its own reliability and congestion control mechanisms, aiming to combine the speed of UDP with the features of TCP."
                    }
                ]
            }
        },
        {
            "id": "lesson-9",
            "title": "Routing Basics",
            "duration": "75 min",
            "objectives": [
                "Understand the function of a router in a network.",
                "Learn the concept of a routing table.",
                "Differentiate between static and dynamic routing.",
                "Analyze and interpret a simple routing table."
            ],
            "content": {
                "overview": "Routing is the core function of the Internet layer. It's the process of selecting a path for traffic to travel from a source to a destination across multiple networks. This lesson introduces the basics of how routers make these decisions using routing tables and explores the two main approaches: static and dynamic routing.",
                "sections": [
                    {
                        "title": "The Role of the Router",
                        "content": "<p>A router is a Layer 3 device that connects two or more different IP networks. Its primary job is to forward packets between these networks. When a router receives a packet, it examines the destination IP address in the packet's header. It then consults its internal <strong>routing table</strong> to decide which of its network interfaces is the best path to send the packet out on to get it closer to its final destination.</p><p>Unlike a switch, which operates on MAC addresses within a single network, a router operates on IP addresses and makes decisions about paths between networks.</p>",
                        "image": "https://images.unsplash.com/photo-1563206767-5b18f218e8de?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The Routing Table",
                        "content": "<p>A routing table is a set of rules, stored in a router or a networked computer, that specifies how packets traveling to a particular network destination should be forwarded. Each entry in the table typically contains:</p><ul><li><strong>Destination Network:</strong> The IP address of the destination network.</li><li><strong>Subnet Mask:</strong> The subnet mask for the destination network.</li><li><strong>Next Hop / Gateway:</strong> The IP address of the next router to send the packet to.</li><li><strong>Interface:</strong> The local network interface (e.g., eth0, eth1) to send the packet out of.</li><li><strong>Metric:</strong> A value indicating the 'cost' of the route. Lower is better.</li></ul><p>The most important entry is often the <strong>default route</strong> (destination 0.0.0.0/0), which tells the router where to send a packet if it doesn't have a more specific matching route in its table. This is usually the path to the internet.</p>",
                        "image": "https://images.unsplash.com/photo-1581291518857-4e27b48ff24e?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Static vs. Dynamic Routing",
                        "content": "<p>There are two main ways a routing table is populated:</p><h3>Static Routing:</h3><p>A network administrator manually configures each route in the routing table. This is simple, secure, and predictable.</p><ul><li><strong>Pros:</strong> No overhead from routing protocols, very secure (no advertised routes), easy to implement in small networks.</li><li><strong>Cons:</strong> Does not scale. If a link goes down, the router cannot adapt. Any network change requires manual reconfiguration.</li></ul><h3>Dynamic Routing:</h3><p>Routers use special routing protocols to automatically learn about other networks from neighboring routers. They build and maintain their routing tables dynamically.</p><ul><li><strong>Pros:</strong> Scales to very large networks, automatically adapts to network topology changes (e.g., link failures), less administrative overhead.</li><li><strong>Cons:</strong> More complex, consumes some CPU and bandwidth, can be less secure if not configured properly.</li><li><strong>Examples of Protocols:</strong> OSPF, EIGRP, BGP.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1507925921958-8a62f3d1a50d?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Viewing the Routing Table in Linux",
                        "language": "bash",
                        "code": "# Show the kernel IP routing table\nip route show\n\n# A more traditional command that also works\nnetstat -r"
                    },
                    {
                        "title": "Viewing the Routing Table in Windows",
                        "language": "bash",
                        "code": "# Show the routing table\nroute print"
                    },
                    {
                        "title": "Adding a Static Route in Linux",
                        "language": "bash",
                        "code": "# This command tells the system that to reach the 10.0.2.0/24 network,\n# it should send packets to the router at 192.168.1.254 via the eth0 interface.\n\nsudo ip route add 10.0.2.0/24 via 192.168.1.254 dev eth0"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary function of a router?",
                        "options": ["To forward frames based on MAC addresses within a LAN", "To assign IP addresses to hosts", "To forward packets based on IP addresses between different networks", "To resolve domain names to IP addresses"],
                        "correct": 2,
                        "explanation": "A router operates at Layer 3 and its main job is to make intelligent forwarding decisions for IP packets to move them from one network to another."
                    },
                    {
                        "id": 2,
                        "question": "What is the 'default route' in a routing table used for?",
                        "options": ["It's the route with the lowest metric", "It's a backup route that is normally inactive", "It's the path for traffic to the local network", "It's the path used when there is no more specific route for a destination"],
                        "correct": 3,
                        "explanation": "The default route (0.0.0.0/0) is the gateway of last resort. If the router doesn't know where a specific network is, it sends the packet to the default route, which typically points to the next-hop router towards the internet."
                    },
                    {
                        "id": 3,
                        "question": "What is a major disadvantage of static routing?",
                        "options": ["It is very complex to configure", "It uses a lot of router CPU and memory", "It cannot automatically adapt to network changes, like a failed link", "It is not secure"],
                        "correct": 2,
                        "explanation": "Static routes are fixed. If the path a static route points to becomes unavailable, the router will continue trying to send traffic there until an administrator manually changes the route. Dynamic routing solves this problem."
                    },
                    {
                        "id": 4,
                        "question": "OSPF and BGP are examples of what?",
                        "options": ["Transport layer protocols", "Dynamic routing protocols", "Static routing protocols", "Data link layer protocols"],
                        "correct": 1,
                        "explanation": "Open Shortest Path First (OSPF) and Border Gateway Protocol (BGP) are two of the most common dynamic routing protocols used to automatically build and maintain routing tables in large networks."
                    },
                    {
                        "id": 5,
                        "question": "Which command is used to view the routing table on a modern Linux system?",
                        "options": ["ipconfig", "route -a", "ip route show", "ifconfig -r"],
                        "correct": 2,
                        "explanation": "`ip route show` is the command from the modern `iproute2` suite used to display the kernel's routing table. `netstat -r` is an older, but still functional, alternative."
                    }
                ]
            }
        },
        {
            "id": "lesson-10",
            "title": "DNS",
            "duration": "90 min",
            "objectives": [
                "Understand the purpose of the Domain Name System (DNS) as the 'phonebook of the internet'.",
                "Differentiate between recursive and iterative DNS queries.",
                "Identify common DNS record types (A, AAAA, CNAME, MX, TXT).",
                "Use `nslookup` and `dig` to perform DNS lookups."
            ],
            "content": {
                "overview": "Humans remember names, but computers communicate with numbers. The Domain Name System (DNS) is the critical Application Layer protocol that translates human-readable domain names (like www.google.com) into the IP addresses (like 142.250.190.78) that computers need to connect to each other. This lesson explores how this massive, distributed database works.",
                "sections": [
                    {
                        "title": "The DNS Hierarchy",
                        "content": "<p>DNS is a hierarchical and decentralized naming system. It's structured like an inverted tree.</p><ul><li><strong>Root Servers:</strong> At the very top are 13 clusters of root servers (represented by a '.'). They know the locations of the TLD servers.</li><li><strong>Top-Level Domain (TLD) Servers:</strong> These servers manage the last part of a domain name, like <code>.com</code>, <code>.org</code>, <code>.net</code>, and country codes like <code>.uk</code> or <code>.de</code>. They know the locations of the authoritative nameservers for their domains.</li><li><strong>Authoritative Nameservers:</strong> These are the servers that hold the actual DNS records for a specific domain (e.g., the servers for <code>google.com</code>). They provide the definitive answer (the IP address).</li></ul>",
                        "image": "https://images.unsplash.com/photo-1585224328157-234f4f783149?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Recursive vs. Iterative Queries",
                        "content": "<p>The process of finding an IP address involves two types of queries:</p><h3>Recursive Query:</h3><p>This is the query your computer (the 'stub resolver') sends to its configured DNS server (your 'recursive resolver', often provided by your ISP). In this query, your computer asks the server, \"Please find the IP address for www.google.com and give me the final answer.\" The recursive resolver is obligated to do all the work.</p><h3>Iterative Queries:</h3><p>This is the process the recursive resolver uses to find the answer. It performs a series of iterative, or non-recursive, queries:</p><ol><li>It asks a root server, \"Where can I find the <code>.com</code> TLD servers?\" The root server refers it to the TLD servers.</li><li>It asks a <code>.com</code> TLD server, \"Where can I find the authoritative nameservers for <code>google.com</code>?\" The TLD server refers it to Google's nameservers.</li><li>It asks one of Google's authoritative nameservers, \"What is the IP address for <code>www.google.com</code>?\" The authoritative server gives the final answer.</li><li>The recursive resolver then caches this answer and returns it to your computer.</li></ol>",
                        "image": "https://images.unsplash.com/photo-1542621334-a254cf47733d?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Common DNS Record Types",
                        "content": "<p>Authoritative nameservers store different types of records for a domain:</p><ul><li><strong>A Record (Address):</strong> Maps a hostname to an IPv4 address. (e.g., <code>www.example.com</code> -> <code>93.184.216.34</code>)</li><li><strong>AAAA Record (Quad-A):</strong> Maps a hostname to an IPv6 address.</li><li><strong>CNAME Record (Canonical Name):</strong> Creates an alias, pointing one hostname to another. (e.g., <code>ftp.example.com</code> -> <code>www.example.com</code>)</li><li><strong>MX Record (Mail Exchange):</strong> Specifies the mail server responsible for accepting email for the domain.</li><li><strong>TXT Record (Text):</strong> Used to store arbitrary text information, often for verification purposes (like SPF for email security).</li></ul>",
                        "image": "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Using `nslookup`",
                        "language": "bash",
                        "code": "# Perform a basic lookup for an A record\nnslookup google.com\n\n# Query for a specific record type, like MX\nnslookup -type=mx google.com"
                    },
                    {
                        "title": "Using `dig` (Domain Information Groper)",
                        "language": "bash",
                        "code": "# dig provides more detailed output than nslookup\ndig google.com\n\n# Query for a specific record type\ndig google.com mx\n\n# Perform a 'trace' to see the full iterative query process\ndig +trace google.com"
                    },
                    {
                        "title": "Wireshark Filter for DNS",
                        "language": "text",
                        "code": "# DNS typically uses UDP port 53. This filter will capture DNS queries and responses.\ndns"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary function of DNS?",
                        "options": ["To route packets across the internet", "To translate domain names into IP addresses", "To assign IP addresses to devices", "To transfer files securely"],
                        "correct": 1,
                        "explanation": "DNS acts as the internet's phonebook, allowing users to access websites using memorable domain names instead of numerical IP addresses."
                    },
                    {
                        "id": 2,
                        "question": "Which type of DNS query does your personal computer typically send to your ISP's DNS server?",
                        "options": ["Iterative", "Authoritative", "Recursive", "Root"],
                        "correct": 2,
                        "explanation": "Your computer (the client) sends a recursive query, asking the server to perform the complete resolution process and return a single, final answer."
                    },
                    {
                        "id": 3,
                        "question": "Which DNS record type is used to map a hostname to an IPv4 address?",
                        "options": ["AAAA Record", "MX Record", "CNAME Record", "A Record"],
                        "correct": 3,
                        "explanation": "The 'A' or 'Address' record is the fundamental record type for mapping a name to a 32-bit IPv4 address. AAAA is used for 128-bit IPv6 addresses."
                    },
                    {
                        "id": 4,
                        "question": "You need to find the mail servers for a specific domain. Which command would you use?",
                        "options": ["ping -mx example.com", "traceroute mail.example.com", "dig example.com mx", "arp -a example.com"],
                        "correct": 2,
                        "explanation": "`dig` is a powerful DNS lookup tool. Specifying the domain and the `mx` record type will query for the Mail Exchange records for that domain."
                    },
                    {
                        "id": 5,
                        "question": "What is an authoritative nameserver?",
                        "options": ["A server that holds the master copy of DNS records for a specific domain", "A server that sits between a user and the internet to filter DNS", "The main DNS server for an entire country", "One of the 13 root servers"],
                        "correct": 0,
                        "explanation": "The authoritative nameserver is the server that has the final, definitive records for a particular domain. It's the ultimate source of truth for that domain's DNS information."
                    }
                ]
            }
        },
        {
            "id": "lesson-11",
            "title": "DHCP",
            "duration": "75 min",
            "objectives": [
                "Understand the need for dynamic IP address allocation.",
                "Learn the four steps of the DHCP lease process (DORA).",
                "Analyze the roles of a DHCP client and server.",
                "Recognize the security implications of rogue DHCP servers."
            ],
            "content": {
                "overview": "Manually configuring the IP address, subnet mask, default gateway, and DNS server on every single device in a network is tedious and prone to error. The Dynamic Host Configuration Protocol (DHCP) automates this entire process, allowing devices to join a network and get configured automatically. This lesson breaks down the four-step DORA process that makes it all work.",
                "sections": [
                    {
                        "title": "The Purpose of DHCP",
                        "content": "<p>DHCP is an Application Layer client-server protocol. Its primary purpose is to automate the assignment of IP addressing information to devices (clients) as they connect to a network. The information provided by a DHCP server typically includes:</p><ul><li><strong>IP Address:</strong> A unique IP address from a pre-defined pool.</li><li><strong>Subnet Mask:</strong> To define the local network.</li><li><strong>Default Gateway (Router):</strong> The address of the router to use for internet access.</li><li><strong>DNS Servers:</strong> The addresses of DNS servers for name resolution.</li></ul><p>DHCP allows for efficient and centralized management of IP addresses, which are assigned for a specific period of time, known as a 'lease'.</p>",
                        "image": "https://images.unsplash.com/photo-1573497161211-a55e3742b4b4?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The DORA Process",
                        "content": "<p>The DHCP lease process is a four-step negotiation between a client and a server, known by the acronym DORA:</p><ol><li><strong>Discover:</strong> When a client device boots up or joins a new network, it has no IP address. It broadcasts a <strong>DHCPDISCOVER</strong> message to the entire local network, asking \"Is there a DHCP server available?\"</li><li><strong>Offer:</strong> Any DHCP server on the network that receives the discover message can respond with a <strong>DHCPOFFER</strong> message. This message is a unicast back to the client's MAC address and contains a proposed IP address and other configuration details.</li><li><strong>Request:</strong> The client receives one or more offers. It chooses one (usually the first one it receives) and then broadcasts a <strong>DHCPREQUEST</strong> message to the network. This message tells all servers, \"I would like to accept the offer made by server X.\" This broadcast informs any other offering servers that their offers were declined.</li><li><strong>Acknowledge (Ack):</strong> The server whose offer was chosen finalizes the lease. It logs the IP address assignment and sends a final <strong>DHCPACK</strong> message to the client, confirming the lease. The client can now use the IP address.</li></ol>",
                        "image": "https://images.unsplash.com/photo-1544198365-f5d60b6d8190?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "DHCP Lease Renewal",
                        "content": "<p>DHCP leases are not permanent. When a lease is 50% expired (the T1 timer), the client will attempt to renew its lease with the original DHCP server by sending a unicast DHCPREQUEST. If the server is available, it will respond with a DHCPACK, and the lease timer is reset.</p><p>If the client gets no response and the lease reaches 87.5% expiration (the T2 timer), it will start broadcasting a DHCPREQUEST, trying to get a lease from any available DHCP server. If the lease expires completely, the client must stop using the IP address and start the DORA process from the beginning.</p>",
                        "image": "https://images.unsplash.com/photo-1516116216624-53e697320964?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Releasing and Renewing a DHCP Lease in Windows",
                        "language": "bash",
                        "code": "# Release the current IP address configuration\nipconfig /release\n\n# Request a new IP address configuration from the DHCP server\nipconfig /renew"
                    },
                    {
                        "title": "Releasing and Renewing a DHCP Lease in Linux",
                        "language": "bash",
                        "code": "# Release the lease for interface eth0\nsudo dhclient -r eth0\n\n# Request a new lease for interface eth0\nsudo dhclient eth0"
                    },
                    {
                        "title": "Wireshark Filter for DHCP",
                        "language": "text",
                        "code": "# DHCP uses UDP ports 67 (server) and 68 (client). \n# The 'bootp' filter is a legacy name that Wireshark uses for DHCP.\n\nbootp"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the correct order of the four main messages in the DHCP lease process?",
                        "options": ["Request, Offer, Discover, Acknowledge", "Discover, Request, Offer, Acknowledge", "Discover, Offer, Request, Acknowledge", "Offer, Discover, Acknowledge, Request"],
                        "correct": 2,
                        "explanation": "The process is known by the acronym DORA: The client Discovers, the server Offers, the client Requests, and the server Acknowledges."
                    },
                    {
                        "id": 2,
                        "question": "The initial DHCPDISCOVER message from a new client is sent as a:",
                        "options": ["Unicast to the router", "Multicast to all servers", "Unicast to a known DHCP server", "Broadcast to the entire local network"],
                        "correct": 3,
                        "explanation": "Since the new client does not know the IP address of a DHCP server, it must send a broadcast message (to MAC address FF:FF:FF:FF:FF:FF) that will be received by all devices on the local network segment."
                    },
                    {
                        "id": 3,
                        "question": "Besides an IP address, which of the following is also commonly provided by a DHCP server?",
                        "options": ["MAC Address", "Username and Password", "Default Gateway and DNS Server addresses", "A software license"],
                        "correct": 2,
                        "explanation": "A DHCP server provides a complete IP configuration, which includes the subnet mask, the default gateway (router) for internet access, and DNS servers for name resolution."
                    },
                    {
                        "id": 4,
                        "question": "What is a 'DHCP lease'?",
                        "options": ["A permanent assignment of an IP address", "A security certificate for the client", "A contract for purchasing an IP address", "A temporary assignment of an IP address for a specific period"],
                        "correct": 3,
                        "explanation": "DHCP assigns IP addresses temporarily. The duration of this assignment is called the lease time. This allows IP addresses to be reclaimed and reused efficiently."
                    },
                    {
                        "id": 5,
                        "question": "What happens in the 'Offer' stage of the DORA process?",
                        "options": ["The client offers to join the network", "The server offers a potential IP address and configuration to the client", "The client offers its MAC address to the server", "The server offers a list of other available servers"],
                        "correct": 1,
                        "explanation": "After receiving a Discover message, a DHCP server responds with a DHCPOFFER, which contains a proposed IP address that the client can then choose to request."
                    }
                ]
            }
        },
        {
            "id": "lesson-12",
            "title": "HTTP/HTTPS",
            "duration": "90 min",
            "objectives": [
                "Understand the role of HTTP as the foundation of the World Wide Web.",
                "Identify common HTTP request methods (GET, POST) and status codes (200, 404, 500).",
                "Recognize the function of HTTP headers and cookies.",
                "Understand how HTTPS uses TLS to provide a secure, encrypted connection."
            ],
            "content": {
                "overview": "The HyperText Transfer Protocol (HTTP) is the Application Layer protocol that powers the web. It defines how web browsers and web servers communicate to exchange documents, images, and other resources. This lesson covers the mechanics of HTTP requests and responses, and explains how its secure counterpart, HTTPS, uses encryption to protect your data.",
                "sections": [
                    {
                        "title": "HTTP: A Request-Response Protocol",
                        "content": "<p>HTTP is a stateless, client-server, request-response protocol. This means:</p><ul><li><strong>Client-Server:</strong> The client (your web browser) initiates a request to a server.</li><li><strong>Request-Response:</strong> The server processes the request and sends back a response.</li><li><strong>Stateless:</strong> Each request is independent. The server does not remember anything about previous requests from the same client. (This limitation is overcome using cookies).</li></ul><p>When you type a URL into your browser, it sends an HTTP request to the corresponding server, which then returns the HTML, CSS, and JavaScript files needed to render the page.</p>",
                        "image": "https://images.unsplash.com/photo-1542831371-29b0f74f9713?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "HTTP Requests and Responses",
                        "content": "<h3>Request Methods:</h3><p>The request specifies the action to be performed. The most common are:</p><ul><li><strong>GET:</strong> Requests a representation of the specified resource. This is used for retrieving data (e.g., loading a webpage).</li><li><strong>POST:</strong> Submits data to be processed to a specified resource. This is used for submitting forms (e.g., a login form).</li></ul><h3>Response Status Codes:</h3><p>The server's response begins with a status code indicating the outcome.</p><ul><li><strong>2xx (Success):</strong> <code>200 OK</code> - The request was successful.</li><li><strong>3xx (Redirection):</strong> <code>301 Moved Permanently</code> - The resource has been moved.</li><li><strong>4xx (Client Error):</strong> <code>404 Not Found</code> - The server could not find the requested resource. <code>403 Forbidden</code> - You don't have permission to access the resource.</li><li><strong>5xx (Server Error):</strong> <code>500 Internal Server Error</code> - A generic error indicating a problem on the server.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1555949963-aa79dcee981c?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Headers and Cookies",
                        "content": "<p>Both requests and responses contain <strong>HTTP headers</strong>, which are key-value pairs that provide additional information.</p><ul><li><strong>Request Headers:</strong> Include information like <code>User-Agent</code> (your browser type), <code>Accept-Language</code> (your preferred language).</li><li><strong>Response Headers:</strong> Include information like <code>Content-Type</code> (e.g., 'text/html'), <code>Content-Length</code> (the size of the response).</li></ul><p><strong>Cookies</strong> are a special header used to overcome HTTP's statelessness. The server can send a <code>Set-Cookie</code> header in a response. The browser then stores this small piece of data and includes it in subsequent requests to the same server, allowing the server to 'remember' the client (e.g., for a login session).</p>",
                        "image": "https://images.unsplash.com/photo-1550751827-4bd374c3f58b?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "HTTPS: Secure HTTP",
                        "content": "<p>HTTP sends all data in plaintext, which is insecure and can be intercepted. <strong>HTTPS (HTTP Secure)</strong> solves this by layering HTTP on top of an encryption protocol, either SSL (Secure Sockets Layer) or its modern successor, <strong>TLS (Transport Layer Security)</strong>.</p><h3>The TLS Handshake:</h3><p>Before any HTTP data is sent, the browser and server perform a TLS handshake to:</p><ol><li>Verify the server's identity using its SSL/TLS certificate.</li><li>Negotiate a cipher suite (the set of cryptographic algorithms they will use).</li><li>Securely exchange a symmetric session key that will be used to encrypt all subsequent HTTP traffic.</li></ol><p>This ensures confidentiality (no one can read the data), integrity (no one can modify the data), and authentication (you are talking to the correct server).</p>",
                        "image": "https://images.unsplash.com/photo-1526374965328-5f61d4dc18c5?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Using `curl` to Make an HTTP GET Request",
                        "language": "bash",
                        "code": "# Fetch the content of a webpage\ncurl http://example.com\n\n# Fetch only the headers to see the status code and content type\ncurl -I http://example.com"
                    },
                    {
                        "title": "Using `curl` to Make an HTTP POST Request",
                        "language": "bash",
                        "code": "# Send form data to an API endpoint\ncurl -X POST -d \"username=test&password=123\" http://api.example.com/login"
                    },
                    {
                        "title": "Wireshark Filter for HTTP/HTTPS",
                        "language": "text",
                        "code": "# Filter for plaintext HTTP traffic (port 80)\nhttp\n\n# Filter for the TLS handshake traffic used by HTTPS (port 443)\n# Note: You cannot see the encrypted HTTP data itself, only the handshake.\ntls.handshake"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "Which HTTP request method is typically used by a browser to retrieve the content of a webpage?",
                        "options": ["POST", "GET", "UPDATE", "CONNECT"],
                        "correct": 1,
                        "explanation": "The GET method is used to request data from a specified resource. When you type a URL in your browser, it sends a GET request to that URL."
                    },
                    {
                        "id": 2,
                        "question": "You try to access a webpage and receive a `404` status code. What does this mean?",
                        "options": ["The request was successful", "You are not authorized to view the page", "The server could not find the requested resource", "The server encountered an internal error"],
                        "correct": 2,
                        "explanation": "`404 Not Found` is a standard client-side error code indicating that the URL or resource does not exist on the server."
                    },
                    {
                        "id": 3,
                        "question": "What is the primary purpose of HTTPS?",
                        "options": ["To make websites load faster", "To compress web content", "To provide a secure, encrypted communication channel for HTTP", "To manage user sessions with cookies"],
                        "correct": 2,
                        "explanation": "HTTPS uses TLS/SSL to encrypt the HTTP request and response, protecting the data from eavesdropping and modification."
                    },
                    {
                        "id": 4,
                        "question": "How do websites 'remember' that you are logged in across multiple requests?",
                        "options": ["By using your IP address", "By using HTTP headers called Cookies", "By using the GET method", "By using HTTPS"],
                        "correct": 1,
                        "explanation": "Since HTTP is stateless, servers use cookies. The server sends a cookie with a session identifier, and the browser includes that cookie in future requests, allowing the server to identify the user."
                    },
                    {
                        "id": 5,
                        "question": "The process of verifying a server's certificate and establishing an encrypted key is called the:",
                        "options": ["TCP Handshake", "HTTP Handshake", "DNS Handshake", "TLS Handshake"],
                        "correct": 3,
                        "explanation": "The TLS Handshake is the negotiation that happens before any HTTPS data is exchanged. It authenticates the server and creates a secure session key for encryption."
                    }
                ]
            }
        },
        {
            "id": "lesson-13",
            "title": "FTP, SFTP, TFTP",
            "duration": "75 min",
            "objectives": [
                "Understand the purpose and operation of the File Transfer Protocol (FTP).",
                "Recognize the security flaws of FTP and the need for secure alternatives.",
                "Differentiate between SFTP (SSH File Transfer Protocol) and FTPS (FTP over SSL).",
                "Identify the specific use case for TFTP (Trivial File Transfer Protocol)."
            ],
            "content": {
                "overview": "Transferring files across a network is a fundamental task. This lesson explores the original File Transfer Protocol (FTP), highlighting its functionality and significant security weaknesses. We will then cover its modern, secure replacements, SFTP and FTPS, and the simple but effective TFTP.",
                "sections": [
                    {
                        "title": "FTP (File Transfer Protocol)",
                        "content": "<p>FTP is one of the oldest Application Layer protocols, designed to transfer files between a client and a server. It is unique because it uses two separate TCP connections:</p><ul><li><strong>Control Connection (Port 21):</strong> Used to send commands (like login, list files, get file) and receive responses. This connection stays open for the entire session.</li><li><strong>Data Connection (Port 20 in Active Mode):</strong> A separate connection is opened for the actual file transfer. A new data connection is made for every file transferred.</li></ul><h3>The Critical Flaw:</h3><p>The biggest problem with FTP is that both the control connection (including username and password) and the data connection are <strong>unencrypted</strong>. Anyone with a packet sniffer on the network can easily capture login credentials and the contents of the files being transferred. For this reason, plain FTP is considered obsolete and insecure for use over the internet.</p>",
                        "image": "https://images.unsplash.com/photo-1563330394-2396e9f698b6?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Secure Alternatives: SFTP and FTPS",
                        "content": "<p>To address the insecurity of FTP, two secure alternatives were developed.</p><h3>SFTP (SSH File Transfer Protocol):</h3><p>This is not FTP over SSH. It is a completely different protocol that was designed from the ground up as part of the SSH suite. It runs over a standard SSH connection (typically on port 22).</p><ul><li><strong>How it works:</strong> It uses a single, encrypted SSH connection for all communicationcommands and data.</li><li><strong>Advantage:</strong> It's very secure, firewall-friendly (only one port needed), and is part of the standard SSH toolset found on nearly all Linux systems. This is the most common secure file transfer method today.</li></ul><h3>FTPS (FTP over SSL/TLS):</h3><p>This is the original FTP protocol with SSL/TLS encryption layered on top, similar to how HTTPS secures HTTP.</p><ul><li><strong>How it works:</strong> It still uses separate control and data connections, but it encrypts them with TLS.</li><li><strong>Disadvantage:</strong> It can be complex to configure and problematic with firewalls due to the need for multiple ports.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1526374965328-5f61d4dc18c5?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "TFTP (Trivial File Transfer Protocol)",
                        "content": "<p>TFTP is a very simple, lightweight file transfer protocol. It uses UDP (on port 69) instead of TCP.</p><h3>Key Characteristics:</h3><ul><li><strong>Simple:</strong> It can only read or write files. There is no directory listing or user authentication.</li><li><strong>Unreliable:</strong> Because it uses UDP, there is no guarantee of delivery.</li><li><strong>Use Case:</strong> TFTP is primarily used in controlled environments for network booting (e.g., a new router downloading its configuration file from a server on the same LAN) or backing up network device configurations. It is not suitable for use over the internet.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1587397845756-230954736914?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Connecting with a Command-Line FTP Client",
                        "language": "bash",
                        "code": "# (Warning: For demonstration in a lab only. Do not use over the internet.)\n\nftp ftp.example.com\n# Enter username and password when prompted\n# Commands inside FTP client:\n# ls        - list files\n# get file.txt - download a file\n# put data.zip - upload a file\n# bye       - disconnect"
                    },
                    {
                        "title": "Connecting with a Command-Line SFTP Client",
                        "language": "bash",
                        "code": "# Connect using your SSH credentials\nsftp user@sftp.example.com\n\n# The commands inside the SFTP client are very similar to FTP:\n# ls, get, put, bye"
                    },
                    {
                        "title": "Wireshark Filter to Capture Plaintext FTP Credentials",
                        "language": "text",
                        "code": "# This filter will show the control channel traffic for an FTP session.\n# You can then right-click a packet and select 'Follow > TCP Stream'\n# to easily see the plaintext username and password.\n\ntcp.port == 21"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the most significant security weakness of the original FTP protocol?",
                        "options": ["It is too slow", "It uses two connections, which is inefficient", "It transmits credentials and data in plaintext (unencrypted)", "It can only transfer text files"],
                        "correct": 2,
                        "explanation": "The lack of encryption is the fatal flaw of FTP, as it allows anyone on the network to easily capture sensitive information like usernames, passwords, and the files being transferred."
                    },
                    {
                        "id": 2,
                        "question": "Which secure file transfer protocol runs over a standard SSH connection and is part of the SSH suite?",
                        "options": ["FTPS", "TFTP", "SFTP", "HTTPS"],
                        "correct": 2,
                        "explanation": "SFTP (SSH File Transfer Protocol) is a modern protocol that uses an encrypted SSH tunnel for both commands and data transfer. It is functionally separate from the old FTP protocol."
                    },
                    {
                        "id": 3,
                        "question": "Why is TFTP considered 'trivial'?",
                        "options": ["It can only be used on Windows systems", "It is very simple, with no authentication or directory listing, and uses UDP", "It is an older version of FTP", "It can only transfer very small files"],
                        "correct": 1,
                        "explanation": "TFTP has a minimal feature set (just reading and writing files) and uses the unreliable UDP protocol, making it 'trivial' compared to the more complex, stateful FTP."
                    },
                    {
                        "id": 4,
                        "question": "FTP is unique because it uses two separate connections. What are they for?",
                        "options": ["One for sending and one for receiving", "A control connection for commands and a data connection for file transfers", "One for IPv4 and one for IPv6", "A primary and a backup connection"],
                        "correct": 1,
                        "explanation": "FTP establishes a persistent control connection on port 21 for the entire session, and then opens a new, temporary data connection for each file that is transferred."
                    },
                    {
                        "id": 5,
                        "question": "Which protocol is the best choice for securely transferring files over the internet in a modern environment?",
                        "options": ["FTP", "TFTP", "Telnet", "SFTP"],
                        "correct": 3,
                        "explanation": "SFTP is the modern standard for secure file transfers. It is encrypted, firewall-friendly (using only the SSH port), and widely available on servers."
                    }
                ]
            }
        },
        {
            "id": "lesson-14",
            "title": "SMTP, POP3, IMAP",
            "duration": "75 min",
            "objectives": [
                "Understand the roles of the three main email protocols.",
                "Describe the workflow of sending an email with SMTP.",
                "Differentiate between POP3 and IMAP for retrieving email.",
                "Recognize the standard ports used by each protocol."
            ],
            "content": {
                "overview": "Email is one of the oldest and most critical internet applications. Its operation relies on a set of cooperating protocols. This lesson explains the roles of SMTP for sending mail, and POP3 and IMAP for retrieving mail, giving you a clear picture of what happens when you click 'send'.",
                "sections": [
                    {
                        "title": "SMTP (Simple Mail Transfer Protocol)",
                        "content": "<p>SMTP is the protocol used for <strong>sending</strong> email. When you send an email from your client (like Outlook or Gmail), it talks to an outgoing mail server (an SMTP server). That server then uses SMTP to relay the message to the recipient's mail server. SMTP is a 'push' protocol.</p><h3>Key Points:</h3><ul><li><strong>Port 25:</strong> The original standard port for server-to-server email relay.</li><li><strong>Port 587:</strong> The modern standard port for email clients to submit mail to a server. It typically requires authentication and uses encryption (STARTTLS).</li><li><strong>Port 465:</strong> An older, deprecated port for secure submission (SMTPS).</li></ul>",
                        "image": "https://images.unsplash.com/photo-1587691592099-24045742c589?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "POP3 (Post Office Protocol version 3)",
                        "content": "<p>POP3 is a simple protocol used for <strong>retrieving</strong> email from a mail server. It works like a physical post office.</p><h3>How it Works:</h3><ol><li>Your email client connects to the server.</li><li>It downloads all new messages from your inbox to your local computer.</li><li>By default, it then <strong>deletes</strong> the messages from the server.</li></ol><p>This 'download and delete' model was designed for a time when users had one computer and intermittent internet access. It's less common today because it makes it difficult to access your email from multiple devices.</p><h3>Ports:</h3><ul><li><strong>Port 110:</strong> Standard, unencrypted POP3.</li><li><strong>Port 995:</strong> Secure POP3 over SSL/TLS (POP3S).</li></ul>",
                        "image": "https://images.unsplash.com/photo-1557853504-2195d171d349?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "IMAP (Internet Message Access Protocol)",
                        "content": "<p>IMAP is the modern protocol for <strong>retrieving</strong> email. It was designed to solve the multi-device problem.</p><h3>How it Works:</h3><p>IMAP works by keeping the emails <strong>on the server</strong> and synchronizing them across all your devices. When you read, delete, or move an email on your phone, that change is reflected on the server and on your laptop. It allows for complex folder structures and a consistent view of your mailbox everywhere.</p><p>This 'server-based' model is how services like Gmail, Outlook.com, and iCloud Mail work by default.</p><h3>Ports:</h3><ul><li><strong>Port 143:</strong> Standard, unencrypted IMAP. Often uses STARTTLS to upgrade to a secure connection.</li><li><strong>Port 993:</strong> Secure IMAP over SSL/TLS (IMAPS).</li></ul>",
                        "image": "https://images.unsplash.com/photo-1596526131033-03f2a8932523?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Simulating an SMTP Conversation with Telnet",
                        "language": "bash",
                        "code": "# Connect to a mail server on the submission port\ntelnet mail.example.com 587\n\n# --- After connecting, type these commands ---\nEHLO client.example.com\nMAIL FROM:<you@example.com>\nRCPT TO:<recipient@example.com>\nDATA\nSubject: Test Email\n\nThis is a test.\n.\nQUIT"
                    },
                    {
                        "title": "Key Differences: POP3 vs IMAP",
                        "language": "text",
                        "code": "POP3:\n- Downloads email to a single client.\n- Deletes messages from the server by default.\n- Good for single-device access and offline storage.\n\nIMAP:\n- Synchronizes email across multiple clients.\n- Keeps messages on the server.\n- Good for multi-device access and server-side organization."
                    },
                    {
                        "title": "Wireshark Filters for Email Protocols",
                        "language": "text",
                        "code": "# Filter for unencrypted SMTP traffic\nsmtp\n\n# Filter for unencrypted POP3 traffic\npop\n\n# Filter for unencrypted IMAP traffic\nimap"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "Which protocol is used to send email from your client to your mail server?",
                        "options": ["POP3", "IMAP", "SMTP", "HTTP"],
                        "correct": 2,
                        "explanation": "SMTP (Simple Mail Transfer Protocol) is the standard 'push' protocol used for sending and relaying email messages."
                    },
                    {
                        "id": 2,
                        "question": "You want to access your email from your phone, laptop, and tablet, and have all your folders and read/unread status synchronized. Which protocol should you use?",
                        "options": ["POP3", "IMAP", "SMTP", "TFTP"],
                        "correct": 1,
                        "explanation": "IMAP is designed specifically for this purpose. It keeps the email on the server and synchronizes the state (read, unread, moved) across all connected clients."
                    },
                    {
                        "id": 3,
                        "question": "What is the default behavior of the POP3 protocol after it successfully downloads new messages?",
                        "options": ["It leaves them on the server", "It marks them as read", "It archives them on the server", "It deletes them from the server"],
                        "correct": 3,
                        "explanation": "The original design of POP3 was to move mail from the server to a single local client, so the default action is to delete the messages from the server's inbox after download."
                    },
                    {
                        "id": 4,
                        "question": "Which port is commonly used for secure IMAP (IMAPS)?",
                        "options": ["110", "143", "993", "995"],
                        "correct": 2,
                        "explanation": "Port 993 is the standard port for IMAP over SSL/TLS, providing an encrypted connection from the start."
                    },
                    {
                        "id": 5,
                        "question": "What is the function of SMTP port 587?",
                        "options": ["Server-to-server mail relay", "Secure email retrieval", "Unencrypted client email submission", "Authenticated client email submission with encryption (STARTTLS)"],
                        "correct": 3,
                        "explanation": "Port 587, often called the 'submission' port, is the modern standard for email clients to submit outgoing mail to their server. It requires authentication and typically uses STARTTLS for encryption."
                    }
                ]
            }
        },
        {
            "id": "lesson-15",
            "title": "SNMP",
            "duration": "60 min",
            "objectives": [
                "Understand the purpose of SNMP for network management.",
                "Learn the roles of SNMP Manager, Agent, and MIB.",
                "Differentiate between SNMP versions (v1, v2c, v3).",
                "Recognize the function of OIDs and traps."
            ],
            "content": {
                "overview": "Managing a network with dozens or hundreds of devices requires an automated way to monitor their health and performance. The Simple Network Management Protocol (SNMP) is an Application Layer protocol designed for this purpose. It provides a standard way for a central management station to query and configure network devices like routers, switches, and servers.",
                "sections": [
                    {
                        "title": "SNMP Architecture",
                        "content": "<p>The SNMP framework consists of several key components:</p><ul><li><strong>SNMP Manager (NMS):</strong> A centralized software platform (like Nagios, Zabbix, or SolarWinds) that runs on a server. It polls agents, receives notifications, and provides a dashboard for network administrators.</li><li><strong>SNMP Agent:</strong> A piece of software that runs on each managed device (e.g., a router, switch, or server). It collects device-specific information and makes it available to the manager.</li><li><strong>Managed Device:</strong> The network device itself that the agent runs on.</li><li><strong>Management Information Base (MIB):</strong> A hierarchical database structure that defines every piece of information that can be collected from a device. Each piece of data is identified by an OID.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "OIDs and MIBs",
                        "content": "<p>The <strong>Management Information Base (MIB)</strong> is a formal description of all the manageable network objects on a particular device. It's structured as a tree.</p><p>An <strong>Object Identifier (OID)</strong> is a unique address used to pinpoint a specific object within the MIB tree. It's represented as a long sequence of numbers separated by dots.</p><p>For example, the OID <code>1.3.6.1.2.1.1.1.0</code> universally refers to a device's system description (its make, model, and OS version). The SNMP manager uses OIDs to ask the agent for specific pieces of data, like \"What is the value of OID 1.3.6.1.2.1.2.2.1.8.1?\" (which might be the operational status of the first network interface).</p>",
                        "image": "https://images.unsplash.com/photo-1504868584819-f8e8b4b6d7e3?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "SNMP Operations and Traps",
                        "content": "<h3>Polling (Manager-initiated):</h3><ul><li><strong>GET Request:</strong> The manager requests the value of a specific OID from an agent.</li><li><strong>GETNEXT Request:</strong> The manager requests the value of the next OID in the MIB tree, allowing it to 'walk' the tree.</li><li><strong>SET Request:</strong> The manager requests to change the value of a writable OID on an agent (used for configuration).</li></ul><h3>Traps (Agent-initiated):</h3><p>Polling is inefficient for monitoring critical, infrequent events. A <strong>Trap</strong> (or Inform in newer versions) is an unsolicited, asynchronous message sent from an agent to the manager to report a significant event, such as a network interface going down, a device rebooting, or a fan failure. This provides immediate notification without waiting for the next poll.</p>",
                        "image": "https://images.unsplash.com/photo-1544256718-3bcf237f3974?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "SNMP Versions and Security",
                        "content": "<p>There are three major versions of SNMP, with significant differences in security:</p><ul><li><strong>SNMPv1:</strong> The original version. It uses a simple plaintext password called a 'community string'. It is fundamentally insecure and should not be used.</li><li><strong>SNMPv2c:</strong> The most widely used version. It adds some protocol enhancements but still uses the same insecure plaintext community string as v1.</li><li><strong>SNMPv3:</strong> The modern, secure version. It provides strong authentication (verifying the source of the message), encryption (protecting the data from eavesdropping), and message integrity. <strong>SNMPv3 is the only version that should be used in a production environment.</strong></li></ul>",
                        "image": "https://images.unsplash.com/photo-1526374965328-5f61d4dc18c5?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Querying a Device with `snmpwalk` (Linux)",
                        "language": "bash",
                        "code": "# This command 'walks' a device's MIB using SNMPv2c and a community string.\n# It will dump a huge amount of information about the device.\n# (Requires net-snmp-utils package)\n\nsnmpwalk -v 2c -c public 192.168.1.1"
                    },
                    {
                        "title": "Querying a Specific OID with `snmpget`",
                        "language": "bash",
                        "code": "# Get the system uptime from a device\nsnmpget -v 2c -c public 192.168.1.1 1.3.6.1.2.1.1.3.0\n\n# Get the system description\nsnmpget -v 2c -c public 192.168.1.1 1.3.6.1.2.1.1.1.0"
                    },
                    {
                        "title": "Wireshark Filter for SNMP",
                        "language": "text",
                        "code": "# SNMP uses UDP ports 161 (requests) and 162 (traps).\n# This filter will capture all SNMP traffic.\n\nsnmp"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary purpose of SNMP?",
                        "options": ["To transfer files between network devices", "To provide secure remote shell access", "To monitor and manage network devices", "To automatically assign IP addresses"],
                        "correct": 2,
                        "explanation": "SNMP provides a standardized framework for collecting data from and sending configuration changes to network devices like routers, switches, and servers."
                    },
                    {
                        "id": 2,
                        "question": "In the SNMP architecture, what is a MIB?",
                        "options": ["A type of network cable", "A secure password", "A hierarchical database that defines the data that can be collected from a device", "The central monitoring server"],
                        "correct": 2,
                        "explanation": "The Management Information Base (MIB) acts as a dictionary or schema, defining all the manageable objects on a device with their unique Object Identifiers (OIDs)."
                    },
                    {
                        "id": 3,
                        "question": "Which version of SNMP is considered secure because it provides authentication and encryption?",
                        "options": ["SNMPv1", "SNMPv2c", "SNMPv3", "All versions are secure"],
                        "correct": 2,
                        "explanation": "SNMPv3 is the only version that addresses the major security flaws of its predecessors by adding robust authentication and encryption capabilities. v1 and v2c send the community string in plaintext."
                    },
                    {
                        "id": 4,
                        "question": "An SNMP agent sends an unsolicited message to the manager to report an urgent event. What is this message called?",
                        "options": ["A GET Request", "A SET Request", "A Poll", "A Trap"],
                        "correct": 3,
                        "explanation": "A Trap is an asynchronous notification sent from the agent to the manager, used to report significant events immediately without waiting for the manager to poll for the information."
                    },
                    {
                        "id": 5,
                        "question": "What is an OID?",
                        "options": ["A unique, numeric address for a specific piece of data in a MIB", "A type of SNMP password", "The IP address of the SNMP manager", "A network performance metric"],
                        "correct": 0,
                        "explanation": "An Object Identifier (OID) is a dot-separated series of numbers that uniquely identifies a manageable object within the hierarchical MIB structure."
                    }
                ]
            }
        },
        {
            "id": "lesson-16",
            "title": "VPN Protocols",
            "duration": "90 min",
            "objectives": [
                "Understand the purpose of a Virtual Private Network (VPN).",
                "Learn the basic concepts of tunneling and encryption.",
                "Differentiate between common VPN protocols like IPSec, OpenVPN, and WireGuard.",
                "Recognize the two modes of IPSec: transport and tunnel."
            ],
            "content": {
                "overview": "A VPN creates a secure, encrypted 'tunnel' over an unsecured public network like the internet. This allows for the secure transmission of private data, as if the connected devices were on the same private network. This lesson explores the core technologies behind VPNs and compares the most popular protocols used to build them.",
                "sections": [
                    {
                        "title": "What is a VPN? Tunneling and Encryption",
                        "content": "<p>A Virtual Private Network (VPN) extends a private network across a public network. The core technology is <strong>tunneling</strong>. The original data packet (the 'inner packet') is encapsulated inside another packet (the 'outer packet'). This outer packet is what travels across the public network.</p><p>Crucially, the inner packet and its payload are <strong>encrypted</strong> before being encapsulated. This means that even if someone intercepts the outer packet on the internet, they cannot read the original data. When the packet reaches the VPN endpoint, it is de-encapsulated and decrypted, and the original packet is sent on to its final destination on the private network.</p>",
                        "image": "https://images.unsplash.com/photo-1526374965328-5f61d4dc18c5?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "IPSec (Internet Protocol Security)",
                        "content": "<p>IPSec is a suite of protocols that operates at the Internet Layer (Layer 3) to secure IP communications. It is a very robust and widely adopted standard, often used for site-to-site VPNs connecting two corporate offices.</p><h3>IPSec Modes:</h3><ul><li><strong>Transport Mode:</strong> Only the payload (the data from the Transport Layer, e.g., a TCP segment) of the IP packet is encrypted. The original IP header is kept. This is typically used for end-to-end communication between two hosts.</li><li><strong>Tunnel Mode:</strong> The entire original IP packet (header and payload) is encrypted and encapsulated inside a new IP packet with a new header. This is the mode used for creating VPN gateways between networks.</li></ul><h3>Core Protocols:</h3><ul><li><strong>AH (Authentication Header):</strong> Provides data integrity and authentication, but no confidentiality (no encryption).</li><li><strong>ESP (Encapsulating Security Payload):</strong> Provides confidentiality (encryption) and optionally integrity and authentication. ESP is almost always used.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1558522195-e12713519528?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "SSL/TLS VPNs and OpenVPN",
                        "content": "<p>SSL/TLS VPNs use the same encryption technology that secures HTTPS websites. They typically operate at the Application Layer, making them very flexible and able to bypass most firewalls (since they use TCP port 443, which is almost always open).</p><p><strong>OpenVPN</strong> is the most popular open-source software that uses SSL/TLS to create VPNs. It is highly configurable, secure, and available on nearly every platform. Most commercial VPN providers (like NordVPN, ExpressVPN) use OpenVPN as one of their core protocols.</p>",
                        "image": "https://images.unsplash.com/photo-1618477388954-7852f32655ec?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Modern Protocols: WireGuard",
                        "content": "<p><strong>WireGuard</strong> is a relatively new VPN protocol that has gained enormous popularity due to its simplicity and performance. It is designed to be much faster and have a much smaller codebase than older protocols like IPSec and OpenVPN, which makes it easier to audit and potentially more secure.</p><h3>Key Features:</h3><ul><li><strong>State-of-the-art cryptography.</strong></li><li><strong>Minimalist design:</strong> ~4,000 lines of code compared to ~100,000+ for competitors.</li><li><strong>High performance:</strong> Often provides higher throughput and lower latency.</li><li><strong>Runs over UDP.</strong></li><p>WireGuard is now included directly in the Linux kernel and is seen by many as the future of VPN technology.</p>",
                        "image": "https://images.unsplash.com/photo-1614063217255-911b55c82245?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Conceptual IPSec Tunnel Mode Packet",
                        "language": "text",
                        "code": "Original Packet: [ Orig IP Hdr | TCP Hdr | Data ]\n\nEncapsulated:    [ New IP Hdr | ESP Hdr | Encrypted [ Orig IP Hdr | TCP Hdr | Data ] | ESP Trlr ]"
                    },
                    {
                        "title": "Checking OpenVPN Status (Linux)",
                        "language": "bash",
                        "code": "# Assuming an OpenVPN connection is managed by systemd\nsystemctl status openvpn-client@myconfig.service"
                    },
                    {
                        "title": "Checking WireGuard Status (Linux)",
                        "language": "bash",
                        "code": "# Show the status of WireGuard interfaces\nsudo wg show"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the core process of a VPN that involves wrapping one packet inside another?",
                        "options": ["Encryption", "Authentication", "Tunneling", "Routing"],
                        "correct": 2,
                        "explanation": "Tunneling is the fundamental process of encapsulating a private network packet within a public network packet to traverse the public internet."
                    },
                    {
                        "id": 2,
                        "question": "Which IPSec mode encrypts the entire original IP packet and is typically used for site-to-site VPNs?",
                        "options": ["Transport Mode", "Tunnel Mode", "ESP Mode", "AH Mode"],
                        "correct": 1,
                        "explanation": "Tunnel Mode protects the entire inner packet, including its routing information, by wrapping it in a new IP header. This is ideal for connecting two private networks via a VPN gateway."
                    },
                    {
                        "id": 3,
                        "question": "OpenVPN is a popular VPN solution based on which underlying encryption protocol?",
                        "options": ["IPSec", "ICMP", "SSH", "SSL/TLS"],
                        "correct": 3,
                        "explanation": "OpenVPN leverages the proven security of the SSL/TLS protocol suite, the same technology that secures HTTPS websites."
                    },
                    {
                        "id": 4,
                        "question": "What are the main advantages of the new WireGuard protocol?",
                        "options": ["It is the oldest and most tested protocol", "It has the most configuration options", "It is very complex, which makes it secure", "It has high performance and a very small, simple codebase"],
                        "correct": 3,
                        "explanation": "WireGuard's key design goals were speed, simplicity, and ease of use, resulting in a lean and fast protocol that is easier to audit and secure."
                    },
                    {
                        "id": 5,
                        "question": "What is the difference between the AH and ESP protocols within IPSec?",
                        "options": ["AH provides encryption, ESP provides authentication", "AH provides authentication and integrity, ESP provides encryption", "AH is for Tunnel Mode, ESP is for Transport Mode", "AH is for IPv4, ESP is for IPv6"],
                        "correct": 1,
                        "explanation": "Authentication Header (AH) provides authentication and integrity but no confidentiality. Encapsulating Security Payload (ESP) is the component that provides confidentiality (encryption) and can also provide authentication and integrity."
                    }
                ]
            }
        },
        {
            "id": "lesson-17",
            "title": "Firewalls and Ports",
            "duration": "75 min",
            "objectives": [
                "Understand the role of a firewall in network security.",
                "Differentiate between stateless and stateful firewalls.",
                "Recognize the concept of well-known, registered, and dynamic ports.",
                "Learn how to create basic firewall rules with iptables."
            ],
            "content": {
                "overview": "A firewall is a network security device that monitors incoming and outgoing network traffic and decides whether to allow or block specific traffic based on a defined set of security rules. This lesson explains the fundamental types of firewalls and how they use ports, protocols, and addresses to protect a network.",
                "sections": [
                    {
                        "title": "The Role of a Firewall",
                        "content": "<p>A firewall acts as a barrier between a trusted internal network and an untrusted external network, such as the internet. Its primary goal is to control access, preventing unauthorized traffic from entering the private network and, in some cases, preventing unauthorized traffic from leaving it.</p><p>Firewalls can be hardware appliances (like a device from Cisco or Palo Alto Networks) or software running on a host (like Windows Firewall or `iptables` on Linux).</p>",
                        "image": "https://images.unsplash.com/photo-1604758765572-c51a14a7940a?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Stateless vs. Stateful Firewalls",
                        "content": "<h3>Stateless Firewall (Packet Filtering):</h3><p>This is the simplest type of firewall. It examines each packet individually and makes a decision based on static information in the packet's header: source IP, destination IP, source port, and destination port. It has no memory of past packets. For example, you could write a rule to 'block all traffic from IP address X'.</p><h3>Stateful Firewall (Stateful Packet Inspection):</h3><p>This is a more advanced firewall that maintains a 'state table' of all active connections. It understands the context of the traffic. For example, if you make an outbound request to a website, the stateful firewall knows that a response from that website is expected. It will automatically allow the return traffic for that specific connection without needing a separate inbound rule. This is much more secure and is the standard for modern firewalls.</p>",
                        "image": "https://images.unsplash.com/photo-1544198365-f5d60b6d8190?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Ports and Services",
                        "content": "<p>Firewall rules are heavily based on port numbers, which are used to identify specific services. Port numbers are divided into three ranges:</p><ul><li><strong>Well-Known Ports (0-1023):</strong> Assigned to common, universally used services. You need administrative privileges to run a service on these ports. Examples:<ul><li>80: HTTP</li><li>443: HTTPS</li><li>22: SSH</li><li>25: SMTP</li></ul></li><li><strong>Registered Ports (1024-49151):</strong> Registered with IANA for specific applications (e.g., 3306 for MySQL).</li><li><strong>Dynamic/Private Ports (49152-65535):</strong> Used for ephemeral (temporary) client-side connections. When you connect to a web server, your browser is assigned a random port from this range for the session.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1550751827-4bd374c3f58b?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Basic `iptables` Rules (Linux)",
                        "language": "bash",
                        "code": "# View current firewall rules in the INPUT chain\nsudo iptables -L INPUT\n\n# Set a default policy to DROP all incoming traffic (IMPORTANT: do not run if connected via SSH unless you have an allow rule!)\nsudo iptables -P INPUT DROP\n\n# Allow established, related incoming traffic (for a stateful firewall)\nsudo iptables -A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT\n\n# Allow incoming SSH connections on port 22\nsudo iptables -A INPUT -p tcp --dport 22 -j ACCEPT\n\n# Block all traffic from a specific malicious IP address\nsudo iptables -A INPUT -s 123.45.67.89 -j DROP"
                    },
                    {
                        "title": "Checking Listening Ports with `ss`",
                        "language": "bash",
                        "code": "# Show all listening TCP and UDP ports and the programs using them\nsudo ss -tulpn"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary function of a network firewall?",
                        "options": ["To speed up network traffic", "To monitor and control incoming and outgoing network traffic based on security rules", "To assign IP addresses to devices", "To translate domain names to IP addresses"],
                        "correct": 1,
                        "explanation": "A firewall acts as a security barrier, filtering traffic to protect a network from unauthorized access and other threats."
                    },
                    {
                        "id": 2,
                        "question": "What is the key difference between a stateful and a stateless firewall?",
                        "options": ["Stateful firewalls are hardware, stateless are software", "Stateless firewalls are faster", "Stateful firewalls track active connections, while stateless firewalls inspect packets individually", "Stateless firewalls can't block ports"],
                        "correct": 2,
                        "explanation": "The 'state' in stateful firewall refers to its ability to maintain a state table of active connections, allowing it to make more intelligent decisions about which packets belong to a legitimate, established conversation."
                    },
                    {
                        "id": 3,
                        "question": "The port number for HTTPS is:",
                        "options": ["80", "22", "443", "53"],
                        "correct": 2,
                        "explanation": "Port 443 is the well-known port for HTTPS (HTTP Secure) traffic."
                    },
                    {
                        "id": 4,
                        "question": "You make a web request from your laptop to a server. Your laptop's source port for this connection will likely be:",
                        "options": ["Port 80", "A random port from the well-known range (0-1023)", "A random port from the dynamic/private range (49152-65535)", "The same as the destination port"],
                        "correct": 2,
                        "explanation": "The client side of a connection uses an ephemeral or dynamic port, chosen randomly from the high-numbered port range for that specific session."
                    },
                    {
                        "id": 5,
                        "question": "What does the `iptables` rule ` -A INPUT -p tcp --dport 22 -j ACCEPT` do?",
                        "options": ["It drops all TCP traffic", "It accepts all incoming traffic on all ports", "It accepts incoming TCP traffic destined for port 22 (SSH)", "It blocks outgoing SSH traffic"],
                        "correct": 2,
                        "explanation": "`-A INPUT` adds a rule to the INPUT chain. `-p tcp` specifies the TCP protocol. `--dport 22` specifies the destination port 22. `-j ACCEPT` defines the action, which is to accept the packet."
                    }
                ]
            }
        },
        {
            "id": "lesson-18",
            "title": "Packet Analysis with Wireshark",
            "duration": "120 min",
            "objectives": [
                "Understand the purpose and interface of Wireshark.",
                "Learn to capture live network traffic.",
                "Master the use of display filters to isolate specific traffic.",
                "Analyze a TCP stream to reconstruct a conversation."
            ],
            "content": {
                "overview": "Wireshark is the world's foremost and widely-used network protocol analyzer. It lets you see whats happening on your network at a microscopic level. This practical lesson introduces the essential skills for capturing, filtering, and analyzing network traffic to troubleshoot problems, analyze protocols, and detect security issues.",
                "sections": [
                    {
                        "title": "Introduction to Wireshark",
                        "content": "<p>Wireshark is a packet sniffer and protocol analyzer. It captures copies of the raw data packets flowing over a network interface (like Ethernet or Wi-Fi) and presents them in a readable, structured format. It can dissect hundreds of protocols, showing you the contents of each header at every layer of the protocol stack.</p><h3>The Main Interface:</h3><ul><li><strong>Packet List Pane:</strong> A list of all captured packets, with columns for packet number, time, source/destination addresses, protocol, etc.</li><li><strong>Packet Details Pane:</strong> Shows the dissected protocol stack for the selected packet (e.g., Frame, Ethernet, IP, TCP, HTTP).</li><li><strong>Packet Bytes Pane:</strong> Displays the raw data of the selected packet in hexadecimal and ASCII.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1614063217255-911b55c82245?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Capturing Traffic",
                        "content": "<p>To start using Wireshark, you must first capture some traffic. On startup, Wireshark presents a list of available network interfaces. You simply select the one you want to monitor (e.g., 'Wi-Fi' or 'Ethernet') and start the capture.</p><h3>Capture Filters vs. Display Filters:</h3><p>It's important to understand the difference between the two types of filters:</p><ul><li><strong>Capture Filter (BPF syntax):</strong> This filter is applied *before* the capture starts. It tells Wireshark's capture engine which packets to save, discarding everything else. This is useful for reducing the size of the capture file on very busy networks. Example: <code>host 192.168.1.50</code> or <code>port 80</code>.</li><li><strong>Display Filter:</strong> This filter is applied *after* the capture is complete. It doesn't delete any packets from the capture; it only hides them from view, allowing you to focus on what's important. This is the most common and flexible way to analyze traffic. You can change display filters on the fly. Example: <code>ip.addr == 192.168.1.50</code> or <code>tcp.port == 80</code>.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1573497161211-a55e3742b4b4?w=800&h=400&fit=crop"
                    },
                 {
  "title": "Using Display Filters",
  "content": "<p>Mastering display filters is the key to becoming proficient with Wireshark. The filter bar at the top of the window allows you to enter complex expressions to narrow down the traffic.</p><h3>Common Filter Examples:</h3><ul><li><code>ip.addr == 1.1.1.1</code>: Show all packets with source or destination IP 1.1.1.1.</li><li><code>ip.src == 192.168.1.100</code>: Show packets only from a specific source IP.</li><li><code>tcp.port == 443</code>: Show all TCP traffic on port 443 (HTTPS).</li><li><code>dns</code>: Show only DNS queries and responses.</li><li><code>http.request.method == \\\"POST\\\"</code>: Show only HTTP POST requests.</li></ul><p>You can combine filters with logical operators like <code>&&</code> (and), <code>||</code> (or), and <code>!</code> (not).</p>",
  "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
},
                    {
                        "title": "Following TCP Streams",
                        "content": "<p>While looking at individual packets is useful, sometimes you need to see the full conversation. Wireshark's 'Follow TCP Stream' feature is incredibly powerful for this. If you right-click on any TCP packet that is part of a conversation (like an HTTP request) and select 'Follow > TCP Stream', Wireshark will open a new window.</p><p>This window reconstructs the entire conversation, stripping away all the headers and showing you the application-layer data exactly as the programs saw it. This is the easiest way to find credentials in a plaintext FTP session, read an unencrypted email, or see the HTML content of a webpage.</p>",
                        "image": "https://images.unsplash.com/photo-1504639725590-771ab665e141?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Useful Display Filter Combinations",
                        "language": "text",
                        "code": "# Show HTTP or DNS traffic\nhttp || dns\n\n# Show all TCP traffic to or from a specific host, excluding SSH traffic\n(ip.addr == 192.168.1.50) && (tcp && !(tcp.port == 22))\n\n# Show TCP resets, which can indicate connection problems\ntcp.flags.reset == 1"
                    },
                    {
                        "title": "Command-Line Packet Capture with `tcpdump`",
                        "language": "bash",
                        "code": "# tcpdump is a powerful command-line packet analyzer for Linux.\n\n# Capture 100 packets on the eth0 interface\nsudo tcpdump -i eth0 -c 100\n\n# Capture all traffic for a specific host and write to a file\nsudo tcpdump -i any host 8.8.8.8 -w google_dns.pcap\n\n# Read a capture file\ntcpdump -r google_dns.pcap"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary function of Wireshark?",
                        "options": ["To block malicious network traffic", "To capture and analyze network packets in detail", "To configure a network router", "To test network speed"],
                        "correct": 1,
                        "explanation": "Wireshark is a network protocol analyzer. Its purpose is to capture packet data and dissect it, allowing for in-depth analysis of network communications."
                    },
                    {
                        "id": 2,
                        "question": "You want to reduce the size of your capture file by only saving DNS traffic. Which type of filter should you use?",
                        "options": ["Display Filter", "Capture Filter", "Post-capture Filter", "Protocol Filter"],
                        "correct": 1,
                        "explanation": "A capture filter is applied before the capture begins and instructs the capture engine to discard any packets that don't match the filter, thus saving disk space. A display filter only hides packets after they've already been captured."
                    },
                    {
                        "id": 3,
                        "question": "Which Wireshark display filter would show all traffic to or from the IP address 10.0.0.5?",
                        "options": ["ip.src == 10.0.0.5", "ip.dest == 10.0.0.5", "ip.addr == 10.0.0.5", "host 10.0.0.5"],
                        "correct": 2,
                        "explanation": "`ip.addr` matches on either the source or destination IP address field. `host` is syntax for a capture filter, not a display filter."
                    },
                    {
                        "id": 4,
                        "question": "What is the easiest way to view the full, reconstructed data of a plaintext conversation, like an FTP login?",
                        "options": ["Read the bytes pane for every packet", "Use the 'Follow TCP Stream' feature", "Apply the 'ftp' display filter", "Export the packets to a text file"],
                        "correct": 1,
                        "explanation": "The 'Follow TCP Stream' feature automatically reassembles the payload from all segments in a TCP conversation and presents it in a single, readable window, making it ideal for analyzing application-layer data."
                    },
                    {
                        "id": 5,
                        "question": "You see `tcp.flags.reset == 1` in your Wireshark filter. What does this indicate?",
                        "options": ["A successful connection start", "The normal termination of a connection", "An abrupt or unexpected termination of a connection", "A request to retransmit a packet"],
                        "correct": 2,
                        "explanation": "A TCP Reset (RST) flag is sent to immediately tear down a connection, often in response to an error, a connection attempt to a closed port, or a system crash."
                    }
                ]
            }
        },
        {
            "id": "lesson-19",
            "title": "Common TCP/IP Attacks",
            "duration": "90 min",
            "objectives": [
                "Understand the principles of a Denial of Service (DoS) attack.",
                "Analyze how a SYN flood attack works.",
                "Learn about DNS poisoning and its impact.",
                "Recognize other common attacks that exploit TCP/IP protocols."
            ],
            "content": {
                "overview": "Understanding how TCP/IP works also means understanding how it can be abused. This lesson explores some of the most common attacks that exploit the fundamental mechanics of TCP/IP protocols. By learning the principles behind these attacks, you can better understand the need for defensive measures like firewalls, intrusion detection systems, and secure protocol configurations.",
                "sections": [
                    {
                        "title": "Denial of Service (DoS) and DDoS",
                        "content": "<p>A Denial of Service (DoS) attack aims to make a machine or network resource unavailable to its intended users. This is often done by overwhelming the target with a flood of traffic or malformed requests. A <strong>Distributed Denial of Service (DDoS)</strong> attack is a DoS attack launched from a large number of compromised computers (a 'botnet'), making it much harder to block.</p>",
                        "image": "https://images.unsplash.com/photo-1563206767-5b18f218e8de?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "SYN Flood Attack",
                        "content": "<p>A SYN flood is a classic DoS attack that exploits the TCP 3-way handshake.</p><h3>How it Works:</h3><ol><li>The attacker sends a huge number of TCP SYN packets to the target server, often with spoofed (fake) source IP addresses.</li><li>The server receives the SYN packets, allocates resources (memory, CPU) for each potential connection, and sends back SYN-ACK packets to the spoofed addresses.</li><li>The server then waits for the final ACK from the client to complete the handshake. Because the source IPs were fake, this final ACK never arrives.</li><li>The server's connection table fills up with 'half-open' connections. Eventually, it runs out of resources and cannot accept any new, legitimate connections, effectively denying service to real users.</li></ol><p>Modern operating systems have defenses against SYN floods (like SYN cookies), but they can still be effective, especially in large-scale DDoS attacks.</p>",
                        "image": "https://images.unsplash.com/photo-1614063217255-911b55c82245?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "DNS Poisoning (Spoofing)",
                        "content": "<p>DNS poisoning, or DNS cache spoofing, is an attack that introduces forged DNS data into a DNS resolver's cache. This causes the server to return an incorrect (and malicious) IP address to users who make a request.</p><h3>How it Works:</h3><p>An attacker can exploit vulnerabilities in DNS software or race to answer a recursive resolver's iterative query faster than the legitimate authoritative server. If successful, the attacker can redirect users to a malicious website.</p><p>For example, an attacker could poison the cache for `www.mybank.com` to point to their own phishing server. When a user tries to go to their bank's website, the compromised DNS resolver will send them to the fake site, which can be used to steal their login credentials. DNSSEC (DNS Security Extensions) is a technology designed to prevent this by adding digital signatures to DNS data.</p>",
                        "image": "https://images.unsplash.com/photo-1585224328157-234f4f783149?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Other Common Attacks",
                        "content": "<ul><li><strong>ARP Poisoning:</strong> A Layer 2 attack where an attacker sends forged ARP messages to link their MAC address with the IP address of a legitimate host, allowing for Man-in-the-Middle attacks on a local network.</li><li><strong>ICMP (Ping) Flood:</strong> A simple DoS attack where the attacker overwhelms a target with ICMP Echo Request packets. The target's network becomes saturated with trying to process and respond to these pings.</li><li><strong>Smurf Attack:</strong> A DDoS amplification attack that uses ICMP. The attacker sends a large number of ICMP Echo Requests to a network's broadcast address, but spoofs the source IP to be the victim's IP. All the devices on the broadcast network then reply to the victim, flooding it with traffic.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1593349319931-06c15c89a940?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Simulating a SYN Flood with `hping3` (For Lab Use Only!)",
                        "language": "bash",
                        "code": "# WARNING: Only ever run this against a machine you own in an isolated lab environment.\n# Running this against a public server is illegal.\n\n# -S sets the SYN flag\n# -p 80 targets port 80\n# --flood sends packets as fast as possible\n# --rand-source uses random source IP addresses\n\nsudo hping3 -S -p 80 --flood --rand-source 192.168.1.100"
                    },
                    {
                        "title": "Wireshark Filter to Detect a Potential SYN Flood",
                        "language": "text",
                        "code": "# A high number of SYN packets without corresponding ACKs can indicate a SYN flood.\n# This filter shows only the initial SYN packets.\n\ntcp.flags.syn == 1 and tcp.flags.ack == 0"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the goal of a SYN flood attack?",
                        "options": ["To steal data from the server", "To exhaust the server's resources for managing new connections, denying service to legitimate users", "To guess the server's password", "To encrypt the server's files"],
                        "correct": 1,
                        "explanation": "A SYN flood specifically targets the TCP connection table, filling it with 'half-open' connections to prevent new, legitimate connections from being established."
                    },
                    {
                        "id": 2,
                        "question": "DNS poisoning is an attack designed to:",
                        "options": ["Overload a DNS server with traffic", "Corrupt a DNS resolver's cache to redirect users to malicious sites", "Steal the domain name from its owner", "Shut down the root DNS servers"],
                        "correct": 1,
                        "explanation": "The objective of DNS poisoning is to feed a DNS server false information, causing it to direct users who request a legitimate domain to an attacker-controlled, malicious IP address."
                    },
                    {
                        "id": 3,
                        "question": "What is a DDoS attack?",
                        "options": ["A Denial of Service attack from a single source", "An attack that distributes data to many clients", "A Denial of Service attack launched from many compromised computers (a botnet)", "An attack that targets DNS servers exclusively"],
                        "correct": 2,
                        "explanation": "The 'Distributed' in DDoS means the attack traffic comes from a multitude of sources at once, making it much more powerful and harder to defend against than a regular DoS attack."
                    },
                    {
                        "id": 4,
                        "question": "ARP poisoning is a Man-in-the-Middle attack that works by manipulating the mapping between which two addresses?",
                        "options": ["IP addresses and Hostnames", "Port numbers and IP addresses", "MAC addresses and IP addresses", "MAC addresses and Port numbers"],
                        "correct": 2,
                        "explanation": "ARP poisoning works by sending forged ARP replies to convince hosts on a local network that the attacker's MAC address belongs to the IP address of a legitimate device, like the default gateway."
                    },
                    {
                        "id": 5,
                        "question": "Which technology is designed to protect against DNS poisoning?",
                        "options": ["HTTPS", "DNSSEC", "SFTP", "DHCP Snooping"],
                        "correct": 1,
                        "explanation": "DNSSEC (DNS Security Extensions) adds cryptographic signatures to DNS records, allowing a resolver to verify that the data it receives is authentic and has not been tampered with."
                    }
                ]
            }
        },
        {
            "id": "lesson-20",
            "title": "Troubleshooting TCP/IP",
            "duration": "120 min",
            "objectives": [
                "Develop a systematic approach to network troubleshooting.",
                "Utilize core command-line tools like `ping`, `traceroute`, `ss`/`netstat`, and `dig` to diagnose problems.",
                "Apply the protocol knowledge gained to identify issues at different layers.",
                "Analyze a given network problem and determine the likely cause."
            ],
            "content": {
                "overview": "This final lesson is a capstone that brings together everything you have learned. Effective troubleshooting is a process of elimination. By understanding how the TCP/IP stack works, you can systematically test each layer to isolate and identify the root cause of a network problem. We will review the key diagnostic tools and apply them to common scenarios.",
                "sections": [
                    {
                        "title": "A Layered Troubleshooting Approach",
                        "content": "<p>When faced with a network problem, it's best to work your way up or down the OSI/TCP/IP model. A common approach is to start from the bottom (Physical) and work your way up.</p><ol><li><strong>Layer 1 (Physical/Network Access):</strong> Is the cable plugged in? Is the Wi-Fi connected? Are the link lights on the switch and network card on?</li><li><strong>Layer 2/3 (Data Link/Internet):</strong> Do I have an IP address? (Use <code>ipconfig</code> or <code>ip addr</code>). Can I ping my default gateway? Can I ping an external IP address like <code>8.8.8.8</code>? This tests your local connectivity and basic internet routing.</li><li><strong>Layer 3/4 (Internet/Transport):</strong> Is something blocking the port? (Use <code>telnet</code> or <code>nmap</code> to test port connectivity). Is a firewall on the client or server blocking the connection?</li><li><strong>Layer 4/5 (Application):</strong> Is DNS working? (Use <code>nslookup</code> or <code>dig</code>). If I can ping <code>8.8.8.8</code> but not <code>google.com</code>, it's almost certainly a DNS issue. Is the application or service on the server running correctly?</li></ol>",
                        "image": "https://images.unsplash.com/photo-1591799264318-7e6cb8dd785b?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The Core Troubleshooting Toolkit",
                        "content": "<p>Your command line provides the most essential tools for network diagnosis.</p><ul><li><strong>`ping` (ICMP):</strong> Tests basic reachability and latency to an IP address. The first tool to use.</li><li><strong>`traceroute`/`tracert` (ICMP/UDP):</strong> Maps the route your packets are taking, showing you every 'hop' (router) along the path. Useful for identifying where a connection is failing.</li><li><strong>`ipconfig`/`ip addr` (IP):</strong> Checks your own host's IP configuration.</li><li><strong>`arp -a` (ARP):</strong> Checks the local ARP cache to verify Layer 2 to Layer 3 mapping.</li><li><strong>`nslookup`/`dig` (DNS):</strong> Tests DNS resolution to see if you can correctly translate names to IP addresses.</li><li><strong>`ss`/`netstat` (TCP/UDP):</strong> Checks which ports are listening on your local or a remote machine and what connections are currently established.</li><li><strong>`curl`/`telnet` (Application):</strong> Can be used to test connectivity to a specific port on a remote server. E.g., <code>telnet google.com 80</code> tests if the web server is listening on the HTTP port.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1554415707-6e8cfc93fe23?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Common Scenarios",
                        "content": "<h3>Scenario 1: \"I can't access a specific website, but others work.\"</h3><ol><li><strong>Test DNS:</strong> <code>dig thatwebsite.com</code>. Do you get a valid IP?</li><li><strong>Test Reachability:</strong> <code>ping</code> the IP address you got from dig. If it works, the server is reachable.</li><li><strong>Test Path:</strong> <code>traceroute</code> to the IP. Does it fail somewhere along the way?</li><li><strong>Test Port:</strong> <code>telnet thatwebsite.com 80</code>. Does it connect? If ping works but this fails, a firewall is likely blocking the web port.</li></ol><h3>Scenario 2: \"The internet is down completely.\"</h3><ol><li><strong>Check Local Config:</strong> <code>ip addr</code>. Do you have a valid IP address (not 169.254.x.x)?</li><li><strong>Ping Gateway:</strong> Find your default gateway with <code>ip route</code> and ping it. If this fails, the problem is on your local network (e.g., your router is down).</li><li><strong>Ping External IP:</strong> <code>ping 8.8.8.8</code>. If the gateway ping works but this fails, the problem is with your ISP's connection.</li><li><strong>Ping External Hostname:</strong> <code>ping google.com</code>. If the ping to 8.8.8.8 works but this fails, your DNS server is the problem.</li></ol>",
                        "image": "https://images.unsplash.com/photo-1517420704952-d9f39e95b43e?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Troubleshooting Workflow Commands",
                        "language": "bash",
                        "code": "# 1. Check your own IP configuration\nip addr show\n\n# 2. Check your routing table for a default gateway\nip route show\n\n# 3. Ping your default gateway (e.g., 192.168.1.1)\nping 192.168.1.1\n\n# 4. Ping an external IP to test internet connectivity\nping 8.8.8.8\n\n# 5. Ping a domain name to test DNS\nping google.com\n\n# 6. Use dig to get more detailed DNS info\ndig google.com"
                    },
                    {
                        "title": "Testing Port Connectivity",
                        "language": "bash",
                        "code": "# Telnet is a simple way to see if a TCP port is open.\n# A successful connection will show 'Connected'. A failure will time out.\n# This tests if the web server at example.com is listening on port 80.\ntelnet example.com 80\n\n# You may need to install telnet first: sudo apt install telnet"
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "You can ping an external IP address like 1.1.1.1, but you cannot browse to any websites like `google.com`. What is the most likely cause of the problem?",
                        "options": ["Your IP address is incorrect", "Your default gateway is down", "Your DNS resolver is not working", "Your network cable is unplugged"],
                        "correct": 2,
                        "explanation": "Being able to ping an external IP proves you have full network connectivity from Layer 1 through Layer 3 (Internet). The failure to resolve a hostname points directly to a DNS issue."
                    },
                    {
                        "id": 2,
                        "question": "You are troubleshooting a connection issue. You run `traceroute` and see that the packets stop at a specific router and the rest of the output is just asterisks (`* * *`). What does this indicate?",
                        "options": ["Your computer is not connected to the network", "The destination server is down", "A router along the path is down or is configured to not send ICMP 'Time Exceeded' messages", "Your DNS server is misconfigured"],
                        "correct": 2,
                        "explanation": "When traceroute times out (showing asterisks), it means it did not receive an ICMP Time Exceeded reply from that hop. This usually means the router is either down or, more commonly, a firewall is blocking the ICMP messages."
                    },
                    {
                        "id": 3,
                        "question": "Which command on Linux is used to check your own computer's IP address, subnet mask, and other interface details?",
                        "options": ["ping", "netstat -i", "ip addr show", "ipconfig"],
                        "correct": 2,
                        "explanation": "`ip addr show` (or `ip a`) is the modern command for viewing detailed network interface configuration on Linux. `ipconfig` is the equivalent command for Windows."
                    },
                    {
                        "id": 4,
                        "question": "You suspect a firewall is blocking your access to a web server on port 80. Which command could you use to test if a TCP connection can be established to that specific port?",
                        "options": ["ping server.com -p 80", "arp -a server.com", "telnet server.com 80", "dig server.com 80"],
                        "correct": 2,
                        "explanation": "`telnet <host> <port>` is a classic and simple tool for testing raw TCP connectivity. If it connects, the port is open and reachable. If it times out, the port is likely blocked by a firewall or the service is not running."
                    },
                    {
                        "id": 5,
                        "question": "Your computer has an IP address of 169.254.10.20. What does this likely indicate?",
                        "options": ["You have a valid, public IP address", "This is a standard private IP address for a home network", "Your computer is configured for IPv6 only", "Your computer failed to get an IP address from a DHCP server"],
                        "correct": 3,
                        "explanation": "The 169.254.0.0/16 range is used for Automatic Private IP Addressing (APIPA). A device assigns itself an address from this range when it is configured for DHCP but is unable to contact a DHCP server."
             }
            ]
        }
    }

    ]
};  // =====================================================
      // GLOBAL VARIABLES
      // =====================================================
      let currentUser = null;
      let currentLessonIndex = 0;
      let courseProgress = {};
      let userStats = {};
      let quizState = {
        currentQuestion: 0,
        answers: [],
        score: 0,
        isComplete: false,
      };

      // Enhanced session tracking
      let courseSession = {
        startTime: null,
        totalStudyTime: 0,
        lessonsStarted: 0,
        lessonsCompleted: 0,
        pageLoadTime: new Date(),
        interactionCount: 0,
        lastActivityTime: new Date(),
      };

      // Music Player Variables
      let audioPlayer = new Audio();

      // Achievement notification system
      let notificationQueue = [];
      let isShowingNotification = false;

      // =====================================================
      // INITIALIZATION
      // =====================================================
      document.addEventListener("DOMContentLoaded", async () => {
        try {
          showLoadingScreen();
          await checkAuth();

          if (currentUser) {
            // Initialize session tracking
            startCourseSession();

            // Load course data and progress
            await loadCourseData();
            await loadUserProfile();
            await loadProgress();

            // Initialize UI
            initializeEventListeners();
            renderSidebar();
            loadLesson(currentLessonIndex);

            // Initialize additional features
            initMusicPlayer();
            addMusicIndicator();
            initializeActivityTracking();

            hideLoadingScreen();
          } else {
            openAuthModal();
          }
        } catch (error) {
          console.error("Error initializing course:", error);
          hideLoadingScreen();
          showToast("Failed to initialize course system", "error");
        }
      });

      // =====================================================
      // AUTHENTICATION SYSTEM
      // =====================================================
      async function checkAuth() {
        try {
          const {
            data: { session },
            error,
          } = await supabase.auth.getSession();

          if (error) {
            console.error("Auth error:", error);
            currentUser = null;
            openAuthModal();
            return;
          }

          if (!session) {
            currentUser = null;
            openAuthModal();
            return;
          }

          currentUser = session.user;
          updateUIWithUser();
        } catch (error) {
          console.error("Error checking auth:", error);
          currentUser = null;
          openAuthModal();
        }
      }

      function updateUIWithUser() {
        if (!currentUser) return;

        const name =
          currentUser.user_metadata?.full_name ||
          currentUser.email.split("@")[0];
        const userElements = document.querySelectorAll("[data-user-name]");
        userElements.forEach((el) => (el.textContent = name));
      }

      // =====================================================
      // USER PROFILE & STATS MANAGEMENT
      // =====================================================
      async function loadUserProfile() {
        try {
          //  Step 1: Try to fetch existing profile
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("*")
            .eq("id", currentUser.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (!profile) {
            //  Step 2: Create new profile if missing
            await createUserProfile();
          } else {
            //  Step 3: Use existing profile
            userStats = profile;
            await updateLastActivity();
          }
        } catch (error) {
          console.error(" Error loading user profile:", error);
          showToast("Failed to load user profile", "error");
        }
      }
      async function createUserProfile() {
        try {
          const newProfile = {
            id: currentUser.id,
            full_name: currentUser.user_metadata?.full_name || "",
            email: currentUser.email,
            level: "Script Kiddie",
            total_points: 0,
            completed_courses: 0,
            current_streak: 0,
            total_certificates: 0,
            total_achievements: 0,
            sections_visited: 0,
            bonus_points: 0,
            in_progress_courses: 0,
            settings_changed: 0,
            midnight_sessions: 0,
            early_sessions: 0,
            weekend_sessions: 0,
            last_activity: new Date().toISOString(),
            created_at: new Date().toISOString(),
          };

          const { error } = await supabase
            .from("profiles")
            .insert([newProfile]);

          if (!error) {
            userStats = newProfile;
            // Award first login achievement
            setTimeout(() => checkAndUnlockAchievement("first_login"), 1000);
          }
        } catch (error) {
          console.error("Error creating user profile:", error);
        }
      }

      async function updateLastActivity() {
        try {
          const now = new Date();

          // Update activity tracking
          courseSession.lastActivityTime = now;

          // Update database
          await supabase
            .from("profiles")
            .update({
              last_activity: now.toISOString(),
            })
            .eq("id", currentUser.id);

          // Check time-based achievements
          await checkTimeBasedAchievements(now);
        } catch (error) {
          console.error("Error updating last activity:", error);
        }
      }

      // =====================================================
      // COURSE SESSION MANAGEMENT
      // =====================================================
      function startCourseSession() {
        courseSession.startTime = new Date();
        courseSession.pageLoadTime = new Date();

        logUserActivity("course_session_start", {
          course_id: COURSE_DATA.id,
          course_title: COURSE_DATA.title,
          user_agent: navigator.userAgent,
          screen_resolution: `${screen.width}x${screen.height}`,
        });

        // Check daily streak
        checkDailyStreak();
      }

      function initializeActivityTracking() {
        // Track page focus/blur for accurate study time
        document.addEventListener("visibilitychange", handleVisibilityChange);

        // Track user interactions
        ["click", "keydown", "scroll", "mousemove"].forEach((event) => {
          document.addEventListener(event, trackUserInteraction, {
            passive: true,
          });
        });

        // Periodic activity updates
        setInterval(updateStudyTime, 60000); // Every minute

        // Save session data before page unload
        window.addEventListener("beforeunload", saveSessionData);
      }

      function handleVisibilityChange() {
        if (document.hidden) {
          courseSession.lastActivityTime = new Date();
        } else {
          // Page became visible again - update activity
          updateLastActivity();
        }
      }

      function trackUserInteraction() {
        courseSession.interactionCount++;
        courseSession.lastActivityTime = new Date();

        // Throttle activity updates
        if (courseSession.interactionCount % 50 === 0) {
          updateLastActivity();
        }
      }

      function updateStudyTime() {
        if (!courseSession.startTime || document.hidden) return;

        const now = new Date();
        const sessionDuration = now - courseSession.startTime;
        courseSession.totalStudyTime = Math.floor(sessionDuration / 1000 / 60); // in minutes

        // Update progress with study time
        saveProgress();
      }

      function saveSessionData() {
        if (!currentUser || !courseSession.startTime) return;

        const sessionData = {
          user_id: currentUser.id,
          course_id: COURSE_DATA.id,
          session_duration: courseSession.totalStudyTime,
          lessons_viewed: courseSession.lessonsStarted,
          lessons_completed: courseSession.lessonsCompleted,
          interactions: courseSession.interactionCount,
          session_date: courseSession.startTime.toISOString().split("T")[0],
        };

        // Store in localStorage as backup
        localStorage.setItem(
          "course_session_backup",
          JSON.stringify(sessionData)
        );

        // Try to save to database
        logUserActivity("course_session_end", sessionData);
      }

      // =====================================================
      // COURSE DATA & PROGRESS MANAGEMENT
      // =====================================================
      async function loadCourseData() {
        try {
          // Update course info in UI
          document.getElementById("courseTitle").textContent =
            COURSE_DATA.title;
          document.getElementById("totalLessons").textContent =
            COURSE_DATA.lessons.length;

          // Log course access
          logUserActivity("course_access", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
          });
        } catch (error) {
          console.error("Error loading course data:", error);
        }
      }

      async function loadProgress() {
        try {
          // Get existing progress from database
          const { data, error } = await supabase
            .from("course_progress")
            .select("*")
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (data) {
            courseProgress = JSON.parse(data.lesson_progress || "{}");
            currentLessonIndex = data.current_lesson || 0;

            // Update session tracking
            courseSession.lessonsStarted = Object.keys(courseProgress).length;
            courseSession.lessonsCompleted = Object.values(
              courseProgress
            ).filter((p) => p.completed).length;
          } else {
            // Initialize new progress
            courseProgress = {};
            currentLessonIndex = 0;
            await saveProgress();

            // Award first course start achievement
            await checkAndUnlockAchievement("first_course_start");
          }

          updateProgressDisplay();
        } catch (error) {
          console.error("Error loading progress:", error);
          showToast("Failed to load progress", "error");
        }
      }

      async function saveProgress() {
        try {
          if (!currentUser) return;

          const now = new Date();
          const progressData = {
            user_id: currentUser.id,
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            current_lesson: currentLessonIndex,
            lesson_progress: JSON.stringify(courseProgress),
            progress: calculateOverallProgress(),
            lessons_completed: getCompletedLessonsCount(),
            lessons_started: Object.keys(courseProgress).length,
            study_time_minutes: courseSession.totalStudyTime,
            last_accessed: now.toISOString(),
            updated_at: now.toISOString(),
          };

          // Upsert progress
          const { error } = await supabase
            .from("course_progress")
            .upsert([progressData]);

          if (error) throw error;

          // Update user stats
          await updateUserStats();

          updateProgressDisplay();
        } catch (error) {
          console.error("Error saving progress:", error);
          showToast("Failed to save progress", "error");
        }
      }

      async function updateUserStats() {
        try {
          // Get all course progress for this user
          const { data: allProgress, error } = await supabase
            .from("course_progress")
            .select("progress, course_id, study_time_minutes")
            .eq("user_id", currentUser.id);

          if (error) throw error;

          // Calculate stats
          const completedCourses =
            allProgress?.filter((p) => p.progress >= 100).length || 0;
          const inProgressCourses =
            allProgress?.filter((p) => p.progress > 0 && p.progress < 100)
              .length || 0;
          const totalStudyTime =
            allProgress?.reduce(
              (sum, p) => sum + (p.study_time_minutes || 0),
              0
            ) || 0;

          // Calculate points (500 per completed course + achievement points)
          const coursePoints = completedCourses * 500;
          const bonusPoints = userStats.bonus_points || 0;
          const totalPoints = coursePoints + bonusPoints;

          // Update profile
          const updateData = {
            completed_courses: completedCourses,
            in_progress_courses: inProgressCourses,
            total_points: totalPoints,
            total_study_time: totalStudyTime,
            last_activity: new Date().toISOString(),
          };

          const { error: updateError } = await supabase
            .from("profiles")
            .update(updateData)
            .eq("id", currentUser.id);

          if (updateError) throw updateError;

          // Update local stats
          Object.assign(userStats, updateData);
        } catch (error) {
          console.error("Error updating user stats:", error);
        }
      }

      function calculateOverallProgress() {
        const completedLessons = getCompletedLessonsCount();
        return Math.round(
          (completedLessons / COURSE_DATA.lessons.length) * 100
        );
      }

      function getCompletedLessonsCount() {
        return Object.values(courseProgress).filter(
          (lesson) => lesson.completed
        ).length;
      }

      function updateProgressDisplay() {
        const completedCount = getCompletedLessonsCount();
        const progressPercent = calculateOverallProgress();

        // Update UI elements
        const elements = {
          completedLessons: completedCount,
          courseProgressPercent: `${progressPercent}%`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });

        // Update progress bar
        const progressBar = document.getElementById("courseProgressFill");
        if (progressBar) progressBar.style.width = `${progressPercent}%`;
      }

      // =====================================================
      // LESSON MANAGEMENT
      // =====================================================
      function loadLesson(index) {
        if (index < 0 || index >= COURSE_DATA.lessons.length) return;

        const lesson = COURSE_DATA.lessons[index];
        currentLessonIndex = index;

        // Mark lesson as started and track activity
        if (!courseProgress[lesson.id]) {
          courseProgress[lesson.id] = {
            started: true,
            completed: false,
            startedAt: new Date().toISOString(),
            timeSpent: 0,
          };

          courseSession.lessonsStarted++;
          saveProgress();

          // Log lesson start
          logUserActivity("lesson_start", {
            lesson_id: lesson.id,
            lesson_title: lesson.title,
            lesson_index: index,
          });
        }

        // Update lesson start time for time tracking
        courseProgress[lesson.id].currentSessionStart = new Date();

        // Update sidebar and navigation
        renderSidebar();
        updateNavigationButtons();

        // Update header info
        updateLessonHeader(lesson, index);

        // Render lesson content
        renderLessonContent(lesson);

        // Smooth scroll and animations
        window.scrollTo({ top: 0, behavior: "smooth" });
        document.getElementById("contentBody").scrollTop = 0;

        const contentBody = document.getElementById("contentBody");
        contentBody.classList.add("fade-in");
        setTimeout(() => contentBody.classList.remove("fade-in"), 500);

        // Check lesson-based achievements
        checkLessonAchievements(index + 1);
      }

      function updateLessonHeader(lesson, index) {
        const elements = {
          currentLessonNumber: index + 1,
          currentLessonTitle: lesson.title,
          navInfo: `Lesson ${index + 1} of ${COURSE_DATA.lessons.length}`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });
      }

      function renderSidebar() {
        const lessonNav = document.getElementById("lessonNav");
        if (!lessonNav) return;

        lessonNav.innerHTML = "";

        COURSE_DATA.lessons.forEach((lesson, index) => {
          const lessonItem = document.createElement("div");
          lessonItem.className = "lesson-item";

          // Determine lesson status
          const lessonProgress = courseProgress[lesson.id];
          const isCompleted = lessonProgress?.completed || false;
          const isInProgress = lessonProgress?.started || false;
          const isLocked = !isCompleted && !canAccessLesson(index);
          const isActive = index === currentLessonIndex;

          // Apply status classes
          if (isCompleted) lessonItem.classList.add("completed");
          if (isLocked) lessonItem.classList.add("locked");
          if (isActive) lessonItem.classList.add("active");

          // Determine status display
          let statusClass = "not-started";
          let statusIcon = index + 1;

          if (isCompleted) {
            statusClass = "completed";
            statusIcon = "";
          } else if (isInProgress) {
            statusClass = "in-progress";
            statusIcon = "";
          }

          // Create lesson item HTML
          lessonItem.innerHTML = `
            <div class="lesson-status ${statusClass}">${statusIcon}</div>
            <div class="lesson-info">
                <div class="lesson-title">${lesson.title}</div>
                <div class="lesson-meta">
                    ${
                      isCompleted
                        ? "Completed"
                        : isInProgress
                        ? "In Progress"
                        : isLocked
                        ? "Locked"
                        : "Not Started"
                    }
                </div>
            </div>
            <div class="lesson-duration">${lesson.duration}</div>
        `;

          // Add click handler if not locked
          if (!isLocked) {
            lessonItem.addEventListener("click", () => {
              if (index !== currentLessonIndex) {
                // Track lesson time before switching
                trackLessonTime();

                currentLessonIndex = index;
                loadLesson(index);
                closeSidebar();
              }
            });
          }

          lessonNav.appendChild(lessonItem);
        });
      }

      function canAccessLesson(index) {
        if (index === 0) return true; // First lesson always accessible

        // Can access if previous lesson is completed
        const previousLessonId = COURSE_DATA.lessons[index - 1].id;
        return courseProgress[previousLessonId]?.completed || false;
      }

      function trackLessonTime() {
        const currentLesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonProgress = courseProgress[currentLesson.id];

        if (lessonProgress?.currentSessionStart) {
          const sessionTime = Math.floor(
            (new Date() - new Date(lessonProgress.currentSessionStart)) /
              1000 /
              60
          );
          lessonProgress.timeSpent =
            (lessonProgress.timeSpent || 0) + sessionTime;
          delete lessonProgress.currentSessionStart;
        }
      }

      // =====================================================
      // LESSON CONTENT RENDERING
      // =====================================================
      function renderLessonContent(lesson) {
        const contentContainer = document.getElementById("lessonContent");
        if (!contentContainer) return;

        let contentHTML = `
        <div class="content-section">
            <h2>Learning Objectives</h2>
            <ul>
                ${lesson.objectives.map((obj) => `<li>${obj}</li>`).join("")}
            </ul>
        </div>
        
        <div class="content-section">
            <h2>Overview</h2>
            <p>${lesson.content.overview}</p>
        </div>
    `;

        // Render content sections
        lesson.content.sections.forEach((section) => {
          contentHTML += `
            <div class="content-section">
                <h2>${section.title}</h2>
                ${section.content}
                ${
                  section.image
                    ? `<img src="${section.image}" alt="${section.title}" class="content-image" loading="lazy">`
                    : ""
                }
            </div>
        `;
        });

        // Render code examples
        if (
          lesson.content.codeExamples &&
          lesson.content.codeExamples.length > 0
        ) {
          contentHTML += `<div class="content-section"><h2>Code Examples</h2></div>`;

          lesson.content.codeExamples.forEach((example, index) => {
            const codeId = `code-${lesson.id}-${index}`;
            contentHTML += `
                <div class="code-section">
                    <div class="code-header">
                        <span class="code-title">${example.title}</span>
                        <button class="copy-btn" onclick="copyCode('${codeId}')">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <pre class="code-block"><code id="${codeId}" class="language-${
              example.language
            }">${escapeHtml(example.code)}</code></pre>
                </div>
            `;
          });
        }

        // Render quiz
        contentHTML += renderQuiz(lesson.quiz);

        contentContainer.innerHTML = contentHTML;

        // Highlight code syntax if Prism is available
        setTimeout(() => {
          if (window.Prism) {
            Prism.highlightAll();
          }
        }, 100);
      }

      // =====================================================
      // QUIZ SYSTEM
      // =====================================================
      function renderQuiz(quiz) {
        const currentLessonProgress =
          courseProgress[COURSE_DATA.lessons[currentLessonIndex].id];
        const isCompleted = currentLessonProgress?.completed || false;

        let quizHTML = `
        <div class="quiz-section" id="quizSection">
            <div class="quiz-header">
                <h2 class="quiz-title">
                    <i class="fas fa-clipboard-check"></i>
                    Knowledge Check
                </h2>
                <p class="quiz-info">
                    Complete this quiz with ${quiz.passingScore}% or higher to unlock the next lesson.
                </p>
            </div>
    `;

        if (isCompleted) {
          const savedScore = currentLessonProgress.quizScore || 0;
          quizHTML += `
            <div class="quiz-results show">
                <div class="quiz-score pass">${savedScore}%</div>
                <div class="quiz-message">
                    <strong>Lesson Completed!</strong><br>
                    You've successfully passed this lesson's quiz.
                </div>
            </div>
        `;
        } else {
          // Render quiz questions
          quiz.questions.forEach((question, qIndex) => {
            quizHTML += `
                <div class="quiz-question ${
                  qIndex === 0 ? "active" : ""
                }" data-question="${qIndex}">
                    <div class="question-header">
                        <span class="question-number">Question ${
                          qIndex + 1
                        }</span>
                        <span class="question-progress">${qIndex + 1}/${
              quiz.questions.length
            }</span>
                    </div>
                    <div class="question-text">${question.question}</div>
                    <div class="question-options">
                        ${question.options
                          .map(
                            (option, oIndex) => `
                            <div class="option" data-option="${oIndex}" onclick="selectOption(${qIndex}, ${oIndex})">
                                <span class="option-letter">${String.fromCharCode(
                                  65 + oIndex
                                )}</span>
                                <span class="option-text">${option}</span>
                            </div>
                        `
                          )
                          .join("")}
                    </div>
                </div>
            `;
          });

          quizHTML += `
            <div class="quiz-controls">
                <button class="btn btn-secondary" id="prevQuestionBtn" onclick="previousQuestion()" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <div>
                    <button class="btn btn-secondary" id="nextQuestionBtn" onclick="nextQuestion()" disabled>
                        Next
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <button class="btn btn-primary" id="submitQuizBtn" onclick="submitQuiz()" style="display: none;">
                        <i class="fas fa-check"></i>
                        Submit Quiz
                    </button>
                </div>
            </div>

            <div class="quiz-results" id="quizResults">
                <div class="quiz-score" id="quizScore">0%</div>
                <div class="quiz-message" id="quizMessage"></div>
                <div class="quiz-actions">
                    <button class="btn btn-primary" id="continueBtn" onclick="completeLesson()" style="display: none;">
                        <i class="fas fa-arrow-right"></i>
                        Continue to Next Lesson
                    </button>
                    <button class="btn btn-secondary" onclick="retakeQuiz()">
                        <i class="fas fa-redo"></i>
                        Retake Quiz
                    </button>
                </div>
            </div>
        `;
        }

        quizHTML += "</div>";
        return quizHTML;
      }

      // Quiz interaction functions
      function selectOption(questionIndex, optionIndex) {
        // Clear previous selections
        document
          .querySelectorAll(`[data-question="${questionIndex}"] .option`)
          .forEach((opt) => {
            opt.classList.remove("selected");
          });

        // Select current option
        const selectedOption = document.querySelector(
          `[data-question="${questionIndex}"] [data-option="${optionIndex}"]`
        );
        selectedOption.classList.add("selected");

        // Store answer
        quizState.answers[questionIndex] = optionIndex;

        // Update navigation
        const isLastQuestion =
          questionIndex ===
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length - 1;
        if (isLastQuestion) {
          document.getElementById("submitQuizBtn").style.display =
            "inline-flex";
          document.getElementById("nextQuestionBtn").style.display = "none";
        } else {
          document.getElementById("nextQuestionBtn").disabled = false;
        }
      }

      function nextQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const nextQuestionEl = currentQuestionEl.nextElementSibling;

        if (
          nextQuestionEl &&
          nextQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          nextQuestionEl.classList.add("active");
          quizState.currentQuestion++;
          updateQuizNavigation();
        }
      }

      function previousQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const prevQuestionEl = currentQuestionEl.previousElementSibling;

        if (
          prevQuestionEl &&
          prevQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          prevQuestionEl.classList.add("active");
          quizState.currentQuestion--;
          updateQuizNavigation();
        }
      }

      function updateQuizNavigation() {
        const totalQuestions =
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length;
        const prevBtn = document.getElementById("prevQuestionBtn");
        const nextBtn = document.getElementById("nextQuestionBtn");
        const submitBtn = document.getElementById("submitQuizBtn");

        prevBtn.disabled = quizState.currentQuestion === 0;

        const hasAnswer =
          quizState.answers[quizState.currentQuestion] !== undefined;
        const isLastQuestion = quizState.currentQuestion === totalQuestions - 1;

        if (isLastQuestion) {
          nextBtn.style.display = "none";
          submitBtn.style.display = hasAnswer ? "inline-flex" : "none";
        } else {
          nextBtn.style.display = "inline-flex";
          nextBtn.disabled = !hasAnswer;
          submitBtn.style.display = "none";
        }
      }

      async function submitQuiz() {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const quiz = lesson.quiz;
        let correctAnswers = 0;

        // Hide questions and controls
        document
          .querySelectorAll(".quiz-question")
          .forEach((q) => (q.style.display = "none"));
        document.querySelector(".quiz-controls").style.display = "none";

        // Calculate score and highlight answers
        quiz.questions.forEach((question, index) => {
          const userAnswer = quizState.answers[index];
          const correctAnswer = question.correct;
          const isCorrect = userAnswer === correctAnswer;

          if (isCorrect) correctAnswers++;

          // Highlight answers
          const questionEl = document.querySelector(
            `[data-question="${index}"]`
          );
          const options = questionEl.querySelectorAll(".option");

          options[correctAnswer].classList.add("correct");
          if (userAnswer !== correctAnswer && userAnswer !== undefined) {
            options[userAnswer].classList.add("incorrect");
          }
        });

        const score = Math.round(
          (correctAnswers / quiz.questions.length) * 100
        );
        const passed = score >= quiz.passingScore;

        // Update quiz results UI
        const quizScore = document.getElementById("quizScore");
        const quizMessage = document.getElementById("quizMessage");
        const quizActions = document.querySelector(".quiz-actions");

        quizScore.textContent = `${score}%`;
        quizScore.className = `quiz-score ${passed ? "pass" : "fail"}`;

        if (passed) {
          quizMessage.innerHTML = `
            <strong>Congratulations!</strong><br>
            You passed with ${score}%. You can now proceed to the next lesson.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-primary" onclick="completeLesson()">
                <i class="fas fa-arrow-right"></i>
                Continue to Next Lesson
            </button>
        `;

          // Mark lesson as completed
          await markLessonComplete(score);
        } else {
          quizMessage.innerHTML = `
            <strong>Not quite there yet.</strong><br>
            You scored ${score}%. You need ${quiz.passingScore}% to pass. Review the material and try again.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-secondary" onclick="retakeQuiz()">
                <i class="fas fa-redo"></i>
                Retake Quiz
            </button>
        `;
        }

        document.getElementById("quizResults").classList.add("show");

        // Log quiz completion
        logUserActivity("quiz_completed", {
          lesson_id: lesson.id,
          lesson_title: lesson.title,
          score: score,
          passed: passed,
          attempts: (courseProgress[lesson.id]?.quizAttempts || 0) + 1,
        });

        // Scroll to results
        document
          .getElementById("quizResults")
          .scrollIntoView({ behavior: "smooth" });
      }

      function retakeQuiz() {
        // Reset quiz state
        quizState = {
          currentQuestion: 0,
          answers: [],
          score: 0,
          isComplete: false,
        };

        // Track quiz retry
        const lessonId = COURSE_DATA.lessons[currentLessonIndex].id;
        if (!courseProgress[lessonId]) courseProgress[lessonId] = {};
        courseProgress[lessonId].quizAttempts =
          (courseProgress[lessonId].quizAttempts || 0) + 1;

        // Reload lesson content
        loadLesson(currentLessonIndex);

        // Scroll to quiz
        setTimeout(() => {
          document
            .getElementById("quizSection")
            .scrollIntoView({ behavior: "smooth" });
        }, 500);
      }

      async function markLessonComplete(score) {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonId = lesson.id;

        // Track lesson completion time
        trackLessonTime();

        // Update lesson progress
        courseProgress[lessonId] = {
          ...courseProgress[lessonId],
          completed: true,
          quizScore: score,
          completedAt: new Date().toISOString(),
          finalScore: score,
        };

        // Update session tracking
        courseSession.lessonsCompleted++;

        // Save progress to database
        await saveProgress();

        // Update UI
        renderSidebar();
        updateNavigationButtons();

        // Check various achievements
        await checkLessonCompletionAchievements();
        await checkPerfectScoreAchievements(score);
        await checkStudyTimeAchievements();

        // Log lesson completion
        logUserActivity("lesson_completed", {
          lesson_id: lessonId,
          lesson_title: lesson.title,
          final_score: score,
          time_spent: courseProgress[lessonId].timeSpent || 0,
          lesson_number: currentLessonIndex + 1,
        });

        showToast("Lesson completed successfully!", "success");
      }

      async function completeLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          // Move to next lesson
          currentLessonIndex++;
          loadLesson(currentLessonIndex);
        } else {
          // Course completion
          await completeCourse();
        }
      }

      async function completeCourse() {
        try {
          const completionTime = courseSession.totalStudyTime;

          // Update course progress to 100% completed
          await supabase
            .from("course_progress")
            .update({
              progress: 100,
              completed_at: new Date().toISOString(),
              completion_time_minutes: completionTime,
            })
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Award course completion achievements
          await checkAndUnlockAchievement("course_completion_1");
          await checkSpeedCompletionAchievements(completionTime);
          await checkCourseStreakAchievements();

          // Update user stats
          await updateUserStats();

          // Show completion message
          showToast(
            "Congratulations! Course completed successfully!",
            "certificate"
          );

          // Log course completion
          logUserActivity("course_completed", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            completion_time_minutes: completionTime,
            total_lessons: COURSE_DATA.lessons.length,
            average_quiz_score: calculateAverageQuizScore(),
          });

          // Redirect to dashboard after delay
          setTimeout(() => {
            window.location.href = "/dashboard";
          }, 3000);
        } catch (error) {
          console.error("Error completing course:", error);
          showToast("Error marking course as complete", "error");
        }
      }

      // =====================================================
      // ACHIEVEMENT INTEGRATION SYSTEM
      // =====================================================
      async function checkAndUnlockAchievement(
        achievementId,
        skipNotification = false
      ) {
        try {
          // Prevent duplicate checks
          const cacheKey = `achievement_${achievementId}_${currentUser.id}`;
          if (sessionStorage.getItem(cacheKey)) return false;

          // Check if already unlocked
          const { data: existing, error } = await supabase
            .from("user_achievements")
            .select("id")
            .eq("user_id", currentUser.id)
            .eq("achievement_id", achievementId)
            .single();

          if (existing) {
            sessionStorage.setItem(cacheKey, "true");
            return false;
          }

          // Award achievement
          const achievementData = {
            user_id: currentUser.id,
            achievement_id: achievementId,
            unlocked_at: new Date().toISOString(),
            points_awarded: getAchievementPoints(achievementId),
            context: "course_system",
          };

          const { data, error: insertError } = await supabase
            .from("user_achievements")
            .insert([achievementData])
            .select()
            .single();

          if (insertError) {
            if (insertError.code === "23505") return false; // Already exists
            throw insertError;
          }

          // Update user points
          await supabase.rpc('increment_user_stats', {
  user_id_param: currentUser.id,
  points_to_add: achievementData.points_awarded,
  achievements_to_add: 1
});

          // Cache and queue notification
          sessionStorage.setItem(cacheKey, "true");

          if (!skipNotification) {
            queueAchievementNotification({
              id: achievementId,
              name: getAchievementName(achievementId),
              description: getAchievementDescription(achievementId),
              points: achievementData.points_awarded,
              rarity: getAchievementRarity(achievementId),
              icon: getAchievementIcon(achievementId),
            });
          }

          return true;
        } catch (error) {
          console.error("Error unlocking achievement:", error);
          return false;
        }
      }

      // Helper functions for achievement data (replace with your actual achievement definitions)
      function getAchievementPoints(id) {
        const pointsMap = {
          first_course_start: 75,
          first_lesson: 100,
          course_completion_1: 500,
          perfect_score: 250,
          speed_demon: 750,
          marathon_learner: 500,
          night_owl: 200,
          early_bird: 200,
          weekend_warrior: 150,
          // Add more as needed
        };
        return pointsMap[id] || 100;
      }

      function getAchievementName(id) {
        const nameMap = {
          first_course_start: "Learning Initiated",
          first_lesson: "First Steps",
          course_completion_1: "Course Conqueror",
          perfect_score: "Perfectionist",
          speed_demon: "Speed Demon",
          // Add more as needed
        };
        return nameMap[id] || "Achievement Unlocked";
      }

      function getAchievementDescription(id) {
        const descMap = {
          first_course_start: "Start your first cybersecurity course",
          first_lesson: "Complete your first lesson",
          course_completion_1: "Complete your first course",
          perfect_score: "Score 100% on any quiz",
          speed_demon: "Complete a course in under 2 hours",
          // Add more as needed
        };
        return descMap[id] || "Achievement description";
      }

      function getAchievementRarity(id) {
        const rarityMap = {
          first_course_start: "common",
          first_lesson: "bronze",
          course_completion_1: "silver",
          perfect_score: "gold",
          speed_demon: "legendary",
          // Add more as needed
        };
        return rarityMap[id] || "common";
      }

      function getAchievementIcon(id) {
        const iconMap = {
          first_course_start: "fas fa-play",
          first_lesson: "fas fa-baby",
          course_completion_1: "fas fa-trophy",
          perfect_score: "fas fa-star",
          speed_demon: "fas fa-rocket",
          // Add more as needed
        };
        return iconMap[id] || "fas fa-award";
      }

      async function checkLessonAchievements(lessonNumber) {
        if (lessonNumber === 1) {
          await checkAndUnlockAchievement("first_lesson");
        }

        // Check if user has completed multiple lessons in one day
        const today = new Date().toISOString().split("T")[0];
        const todayCompletions = Object.values(courseProgress).filter(
          (p) => p.completed && p.completedAt?.startsWith(today)
        ).length;

        if (todayCompletions >= 3) {
          await checkAndUnlockAchievement("lesson_marathon");
        }
      }

      async function checkLessonCompletionAchievements() {
        const completedCount = getCompletedLessonsCount();

        // Lesson-based achievements
        const lessonMilestones = [1, 5, 10, 25, 50, 100];
        for (const milestone of lessonMilestones) {
          if (completedCount >= milestone) {
            await checkAndUnlockAchievement(`lessons_${milestone}`);
          }
        }

        // Course completion achievements
        if (completedCount === COURSE_DATA.lessons.length) {
          await checkAndUnlockAchievement("course_completion_1");

          // Check for additional course completion achievements
          const { data: allCourses } = await supabase
            .from("course_progress")
            .select("course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100);

          const totalCompleted = allCourses?.length || 0;

          const courseMilestones = [1, 5, 10, 25];
          for (const milestone of courseMilestones) {
            if (totalCompleted >= milestone) {
              await checkAndUnlockAchievement(`course_completion_${milestone}`);
            }
          }
        }
      }

      async function checkPerfectScoreAchievements(score) {
        if (score === 100) {
          await checkAndUnlockAchievement("perfect_score");

          // Check for consecutive perfect scores
          const recentScores = Object.values(courseProgress)
            .filter((p) => p.completed && p.quizScore)
            .slice(-5) // Last 5 completed
            .map((p) => p.quizScore);

          if (
            recentScores.length >= 3 &&
            recentScores.every((s) => s === 100)
          ) {
            await checkAndUnlockAchievement("perfectionist_streak");
          }
        }
      }

      async function checkSpeedCompletionAchievements(completionTime) {
        // Speed demon: Complete course in under 2 hours (120 minutes)
        if (completionTime <= 120) {
          await checkAndUnlockAchievement("speed_demon");
        }

        // Quick learner: Complete course in under 4 hours (240 minutes)
        if (completionTime <= 240) {
          await checkAndUnlockAchievement("quick_learner");
        }
      }

      async function checkStudyTimeAchievements() {
        const totalTime = courseSession.totalStudyTime;

        // Marathon learner: Study for 8+ hours in a course session
        if (totalTime >= 480) {
          // 8 hours
          await checkAndUnlockAchievement("marathon_learner");
        }

        // Dedicated learner: Study for 4+ hours
        if (totalTime >= 240) {
          // 4 hours
          await checkAndUnlockAchievement("dedicated_learner");
        }
      }

      async function checkCourseStreakAchievements() {
        try {
          // Check for consecutive course completions
          const { data: recentCourses, error } = await supabase
            .from("course_progress")
            .select("completed_at, course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100)
            .order("completed_at", { ascending: false })
            .limit(10);

          if (error || !recentCourses) return;

          // Check for courses completed on consecutive days
          let consecutiveDays = 1;
          for (let i = 1; i < recentCourses.length; i++) {
            const prevDate = new Date(
              recentCourses[i - 1].completed_at
            ).toDateString();
            const currentDate = new Date(
              recentCourses[i].completed_at
            ).toDateString();
            const dayDiff =
              Math.abs(new Date(prevDate) - new Date(currentDate)) /
              (1000 * 60 * 60 * 24);

            if (dayDiff <= 1) {
              consecutiveDays++;
            } else {
              break;
            }
          }

          if (consecutiveDays >= 3) {
            await checkAndUnlockAchievement("learning_streak");
          }
        } catch (error) {
          console.error("Error checking course streak achievements:", error);
        }
      }

      // =====================================================
      // TIME-BASED ACHIEVEMENTS
      // =====================================================
      async function checkTimeBasedAchievements(timestamp) {
        const hour = timestamp.getHours();
        const dayOfWeek = timestamp.getDay();

        // Night owl (after midnight, before 6 AM)
        if (hour >= 0 && hour < 6) {
          await incrementTimeBasedCounter("midnight_sessions", "night_owl");
        }

        // Early bird (4 AM to 6 AM)
        if (hour >= 4 && hour < 6) {
          await incrementTimeBasedCounter("early_sessions", "early_bird");
        }

        // Weekend warrior (Saturday = 6, Sunday = 0)
        if (dayOfWeek === 0 || dayOfWeek === 6) {
          await incrementTimeBasedCounter(
            "weekend_sessions",
            "weekend_warrior"
          );
        }
      }

      async function incrementTimeBasedCounter(counterType, achievementId) {
        try {
          const dateStr = new Date().toISOString().split("T")[0];
          const cacheKey = `${counterType}_${currentUser.id}_${dateStr}`;

          // Prevent multiple increments per day
          if (sessionStorage.getItem(cacheKey)) return;

          // Update counter
      await supabase.rpc('increment_profile_counter', {
  user_id_param: currentUser.id,
  counter_field: counterType,
  increment_value: 1
});
          // Cache to prevent double counting
          sessionStorage.setItem(cacheKey, "true");

          // Check related achievement
          if (achievementId) {
            await checkAndUnlockAchievement(achievementId, true);
          }
        } catch (error) {
          console.error(`Error incrementing ${counterType}:`, error);
        }
      }

      async function checkDailyStreak() {
        try {
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("last_activity, current_streak, last_streak_date")
            .eq("id", currentUser.id)
            .single();

          if (error) throw error;

          const now = new Date();
          const today = now.toDateString();
          const lastActivity = profile.last_activity
            ? new Date(profile.last_activity)
            : null;
          const lastStreakDate = profile.last_streak_date
            ? new Date(profile.last_streak_date).toDateString()
            : null;

          let newStreak = profile.current_streak || 0;
          let shouldUpdateStreak = false;

          if (!lastActivity) {
            // First time user
            newStreak = 1;
            shouldUpdateStreak = true;
          } else {
            const daysSinceLastActivity = Math.floor(
              (now - lastActivity) / (1000 * 60 * 60 * 24)
            );

            if (lastStreakDate === today) {
              // Already counted today's streak
              return newStreak;
            } else if (
              daysSinceLastActivity === 1 ||
              (daysSinceLastActivity === 0 && lastStreakDate !== today)
            ) {
              // Consecutive day or same day but not counted yet
              newStreak += 1;
              shouldUpdateStreak = true;
            } else if (daysSinceLastActivity > 1) {
              // Streak broken
              newStreak = 1;
              shouldUpdateStreak = true;
            }
          }

          if (shouldUpdateStreak) {
            await supabase
              .from("profiles")
              .update({
                current_streak: newStreak,
                last_activity: now.toISOString(),
                last_streak_date: now.toISOString(),
              })
              .eq("id", currentUser.id);

            userStats.current_streak = newStreak;

            showToast(`Daily streak: ${newStreak} days!`, "success");
            await checkStreakAchievements(newStreak);
          }

          return newStreak;
        } catch (error) {
          console.error("Error checking daily streak:", error);
          return 0;
        }
      }

      async function checkStreakAchievements(currentStreak) {
        const streakMilestones = [3, 7, 14, 30, 100, 365];

        for (const milestone of streakMilestones) {
          if (currentStreak >= milestone) {
            await checkAndUnlockAchievement(`streak_${milestone}`);
          }
        }
      }

      // =====================================================
      // USER ACTIVITY LOGGING
      // =====================================================
      async function logUserActivity(activityType, metadata = {}) {
        try {
          const now = new Date();

          const activityData = {
            user_id: currentUser.id,
            activity_type: activityType,
            timestamp: now.toISOString(),
            course_id: COURSE_DATA.id,
            lesson_index: currentLessonIndex,
            session_duration: courseSession.totalStudyTime,
            metadata: JSON.stringify(metadata),
            created_at: now.toISOString(),
          };

          // Try to log to activities table
          const { error } = await supabase
            .from("user_activities")
            .insert([activityData]);

          if (error && error.code !== "42P01") {
            console.warn("Activity logging failed:", error.message);
          }

          // Always update last activity in profile
          await supabase
            .from("profiles")
            .update({ last_activity: now.toISOString() })
            .eq("id", currentUser.id);
        } catch (error) {
          console.error("Error logging user activity:", error);
        }
      }

      // =====================================================
      // NAVIGATION SYSTEM
      // =====================================================
      function updateNavigationButtons() {
        const prevBtn = document.getElementById("prevLessonBtn");
        const nextBtn = document.getElementById("nextLessonBtn");

        if (!prevBtn || !nextBtn) return;

        // Previous button
        prevBtn.disabled = currentLessonIndex === 0;

        // Next button logic
        const isLastLesson =
          currentLessonIndex === COURSE_DATA.lessons.length - 1;
        const canGoNext =
          currentLessonIndex < COURSE_DATA.lessons.length - 1 &&
          canAccessLesson(currentLessonIndex + 1);

        if (isLastLesson) {
          const isCurrentCompleted =
            courseProgress[COURSE_DATA.lessons[currentLessonIndex].id]
              ?.completed;
          nextBtn.disabled = !isCurrentCompleted;
          nextBtn.innerHTML = '<i class="fas fa-trophy"></i> Complete Course';
        } else {
          nextBtn.disabled = !canGoNext;
          nextBtn.innerHTML = 'Next <i class="fas fa-chevron-right"></i>';
        }
      }

      // Navigation button event handlers
      function goToPreviousLesson() {
        if (currentLessonIndex > 0) {
          trackLessonTime(); // Track time spent on current lesson
          currentLessonIndex--;
          loadLesson(currentLessonIndex);
        }
      }

      function goToNextLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          const canGoNext = canAccessLesson(currentLessonIndex + 1);
          if (canGoNext) {
            trackLessonTime();
            currentLessonIndex++;
            loadLesson(currentLessonIndex);
          } else {
            showToast("Complete the current lesson quiz to proceed", "warning");
          }
        } else {
          // Complete course
          completeCourse();
        }
      }

      // =====================================================
      // SIDEBAR FUNCTIONS
      // =====================================================
      function toggleSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.toggle("open");
        if (overlay) overlay.classList.toggle("active");
      }

      function closeSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.remove("open");
        if (overlay) overlay.classList.remove("active");
      }

      // =====================================================
      // ACHIEVEMENT NOTIFICATION SYSTEM
      // =====================================================
      function queueAchievementNotification(achievement) {
        notificationQueue.push(achievement);
        processNotificationQueue();
      }

      function processNotificationQueue() {
        if (isShowingNotification || notificationQueue.length === 0) return;

        isShowingNotification = true;
        const achievement = notificationQueue.shift();
        showAchievementNotification(achievement);

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          isShowingNotification = false;
          processNotificationQueue();
        }, duration + 500);
      }

      function showAchievementNotification(achievement) {
        const notification = document.getElementById("achievementNotification");
        if (!notification) return;

        const icon = document.getElementById("notificationIcon");
        const title = document.getElementById("notificationTitle");
        const description = document.getElementById("notificationDescription");
        const points = document.getElementById("notificationPoints");

        if (icon) {
          icon.innerHTML = `<i class="${achievement.icon}"></i>`;
          icon.className = `notification-icon ${achievement.rarity}`;
        }
        if (title) title.textContent = achievement.name;
        if (description) description.textContent = achievement.description;
        if (points) points.textContent = `+${achievement.points} Points`;

        notification.className = `achievement-notification ${achievement.rarity}`;
        notification.classList.add("show");

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          notification.classList.remove("show");
        }, duration);
      }

      // =====================================================
      // UTILITY FUNCTIONS
      // =====================================================
      function calculateAverageQuizScore() {
        const scores = Object.values(courseProgress)
          .filter((p) => p.completed && p.quizScore)
          .map((p) => p.quizScore);

        if (scores.length === 0) return 0;
        return Math.round(
          scores.reduce((sum, score) => sum + score, 0) / scores.length
        );
      }

      async function resetProgress() {
        if (
          !confirm(
            "Are you sure you want to reset your progress? This action cannot be undone."
          )
        ) {
          return;
        }

        try {
          // Track lesson time before reset
          trackLessonTime();

          // Reset local state
          courseProgress = {};
          currentLessonIndex = 0;
          courseSession = {
            startTime: new Date(),
            totalStudyTime: 0,
            lessonsStarted: 0,
            lessonsCompleted: 0,
            pageLoadTime: new Date(),
            interactionCount: 0,
            lastActivityTime: new Date(),
          };

          // Delete from database
          await supabase
            .from("course_progress")
            .delete()
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Log reset activity
          logUserActivity("progress_reset", {
            course_id: COURSE_DATA.id,
            reset_reason: "manual",
          });

          // Reinitialize
          await saveProgress();
          renderSidebar();
          loadLesson(0);

          showToast("Progress reset successfully", "success");
        } catch (error) {
          console.error("Error resetting progress:", error);
          showToast("Failed to reset progress", "error");
        }
      }

      function copyCode(codeId) {
        const codeElement = document.getElementById(codeId);
        if (!codeElement) return;

        const text = codeElement.textContent;

        navigator.clipboard
          .writeText(text)
          .then(() => {
            showToast("Code copied to clipboard!", "success");

            // Track code copy for achievements
            logUserActivity("code_copied", {
              code_section: codeId,
              lesson_id: COURSE_DATA.lessons[currentLessonIndex].id,
            });
          })
          .catch((err) => {
            console.error("Failed to copy code:", err);
            showToast("Failed to copy code", "error");

            // Fallback for older browsers
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            try {
              document.execCommand("copy");
              showToast("Code copied to clipboard!", "success");
            } catch (fallbackError) {
              showToast(
                "Copy failed - please select and copy manually",
                "error"
              );
            }
            document.body.removeChild(textArea);
          });
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // =====================================================
      // UI FEEDBACK SYSTEMS
      // =====================================================
      function showToast(message, type = "success") {
        const toast = document.getElementById("toast");
        const messageEl = document.getElementById("toastMessage");

        if (!toast || !messageEl) {
          console.log(`Toast: ${message} (${type})`);
          return;
        }

        messageEl.textContent = message;
        toast.className = `toast ${type} show`;

        setTimeout(() => {
          toast.classList.remove("show");
        }, 4000);
      }

      function showLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) loadingScreen.classList.remove("hidden");
      }

      function hideLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) {
          setTimeout(() => {
            loadingScreen.classList.add("hidden");
          }, 1000);
        }
      }

      // =====================================================
      // MUSIC PLAYER INTEGRATION
      // =====================================================
      function initMusicPlayer() {
        const btnText = document.getElementById("music-button-text");
        const icon = document.getElementById("music-icon");
        const dropdown = document.getElementById("music-dropdown-content");

        if (!btnText || !icon || !dropdown) return;

        function setUI(state) {
          btnText.textContent =
            state === "Playing" ? "PAUSE MUSIC" : "STUDY MUSIC";
          icon.className =
            state === "Playing"
              ? "fa-solid fa-circle-pause"
              : "fa-solid fa-music";
        }

        // Load saved music state
        const savedSrc = localStorage.getItem("cybersec_music_src");
        const savedTime = parseFloat(
          localStorage.getItem("cybersec_music_time") || 0
        );

        if (savedSrc) {
          audioPlayer.src = savedSrc;
          audioPlayer.currentTime = savedTime;
          audioPlayer
            .play()
            .then(() => setUI("Playing"))
            .catch(() => setUI("Stopped"));
        }

        // Music button click handler
        document
          .getElementById("music-dropdown")
          .querySelector("button")
          .addEventListener("click", (e) => {
            e.stopPropagation();
            dropdown.style.display =
              dropdown.style.display === "block" ? "none" : "block";

            if (audioPlayer.src && !audioPlayer.paused) {
              audioPlayer.pause();
              setUI("Stopped");
            } else if (audioPlayer.src) {
              audioPlayer.play().then(() => setUI("Playing"));
            }
          });

        // Music selection handlers
        dropdown.querySelectorAll("a[data-src]").forEach((link) => {
          link.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.src = link.dataset.src;
            audioPlayer.play().then(() => setUI("Playing"));
            localStorage.setItem("cybersec_music_src", link.dataset.src);
            dropdown.style.display = "none";
          });
        });

        // Stop music handler
        const stopLink = document.getElementById("stop-music-link");
        if (stopLink) {
          stopLink.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            audioPlayer.removeAttribute("src");
            setUI("Stopped");
            localStorage.removeItem("cybersec_music_src");
            localStorage.removeItem("cybersec_music_time");
            dropdown.style.display = "none";
          });
        }

        // Save music state before page unload
        window.addEventListener("beforeunload", () => {
          if (!audioPlayer.paused && audioPlayer.src) {
            localStorage.setItem("cybersec_music_src", audioPlayer.src);
            localStorage.setItem(
              "cybersec_music_time",
              audioPlayer.currentTime
            );
          }
        });

        // Close dropdown when clicking outside
        window.addEventListener("click", (e) => {
          if (!e.target.closest("#music-dropdown")) {
            dropdown.style.display = "none";
          }
        });
      }

      // Show initial music indicator
      function addMusicIndicator() {
        const musicBtn = document.querySelector("#music-dropdown");
        if (musicBtn) {
          const indicator = document.createElement("div");
          indicator.className = "music-indicator";
          indicator.innerHTML = `<i class="fa-solid fa-music"></i> Try Study Music!`;

          musicBtn.style.position = "relative";
          musicBtn.appendChild(indicator);

          setTimeout(() => indicator.remove(), 3000);
        }
      }

      // Initialize Event Listeners
      function initializeEventListeners() {
        // Navigation buttons
        document
          .getElementById("prevLessonBtn")
          ?.addEventListener("click", goToPreviousLesson);
        document
          .getElementById("nextLessonBtn")
          ?.addEventListener("click", goToNextLesson);

        // Reset progress button
        document
          .getElementById("resetProgressBtn")
          ?.addEventListener("click", resetProgress);

        // Mobile menu toggle
        document
          .getElementById("menuToggle")
          ?.addEventListener("click", toggleSidebar);
        document
          .getElementById("sidebarOverlay")
          ?.addEventListener("click", closeSidebar);

        // Keyboard shortcuts
        document.addEventListener("keydown", handleKeyboardShortcuts);

        // Window resize handler
        window.addEventListener("resize", handleWindowResize);

        // Content interaction tracking
        document.getElementById("contentBody")?.addEventListener(
          "scroll",
          debounce(() => {
            trackUserInteraction();
          }, 1000)
        );
      }

      // Keyboard Shortcuts
      function handleKeyboardShortcuts(e) {
        if (document.querySelector(".quiz-question.active")) return;

        if (e.key === "ArrowLeft" && e.ctrlKey) {
          e.preventDefault();
          goToPreviousLesson();
        } else if (e.key === "ArrowRight" && e.ctrlKey) {
          e.preventDefault();
          goToNextLesson();
        }
      }

      // Window Resize Handler
      function handleWindowResize() {
        if (window.innerWidth > 768) {
          closeSidebar();
        }
      }

      // Debounce Helper
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Initialize responsive behavior
      if (window.innerWidth <= 768) {
        document.getElementById("menuToggle").style.display = "inline-flex";
      }

      // Auto-save progress periodically
      setInterval(async () => {
        if (currentUser && Object.keys(courseProgress).length > 0) {
          await saveProgress();
        }
      }, 60000); // Save every minute

      // System initialization logging
      console.log("CyberSec Academy Course System Initialized");
      console.log("Current Course:", COURSE_DATA.title);
      console.log("Total Lessons:", COURSE_DATA.lessons.length);

      // Google OAuth Integration
      const googleBtn = document.querySelector(".btn-google");
      if (googleBtn) {
        googleBtn.addEventListener("click", async () => {
          const { data, error } = await supabase.auth.signInWithOAuth({
            provider: "google",
            options: {
              redirectTo: window.location.origin + "/courses/tcp-ip-protocols-deep-dive",
            },
          });

          if (error) {
            console.error("Google login error:", error.message);
            showToast("Google login failed: " + error.message, "error");
          }
        });
      }

      // Check for existing session
      supabase.auth.getSession().then(({ data }) => {
        if (data.session) {
          console.log("User already logged in:", data.session.user);
          currentUser = data.session.user;
          startCourseSession();
        }
      });

      // Add missing auth modal functions
      function openAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "flex";
        }
      }

      function closeAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Add auth tab switching functionality
      document.getElementById("tabSignIn")?.addEventListener("click", () => {
        document.getElementById("tabSignIn").classList.add("active");
        document.getElementById("tabSignUp").classList.remove("active");
        document.getElementById("signInForm").style.display = "block";
        document.getElementById("signUpForm").style.display = "none";
      });

      document.getElementById("tabSignUp")?.addEventListener("click", () => {
        document.getElementById("tabSignUp").classList.add("active");
        document.getElementById("tabSignIn").classList.remove("active");
        document.getElementById("signUpForm").style.display = "block";
        document.getElementById("signInForm").style.display = "none";
      });

      document
        .getElementById("closeAuthModal")
        ?.addEventListener("click", closeAuthModal);

      // Improved error handling for auth session
      supabase.auth.onAuthStateChange((event, session) => {
        if (event === "SIGNED_IN") {
          currentUser = session.user;
          closeAuthModal();
          startCourseSession();
        } else if (event === "SIGNED_OUT") {
          currentUser = null;
          openAuthModal();
        }
      });

      // Add form submission handlers
      document
        .getElementById("emailSignInForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signInEmail").value;
          const password = document.getElementById("signInPassword").value;

          try {
            const { data, error } = await supabase.auth.signInWithPassword({
              email,
              password,
            });

            if (error) throw error;

            closeAuthModal();
          } catch (error) {
            showToast(error.message, "error");
          }
        });

      document
        .getElementById("emailSignUpForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signUpEmail").value;
          const password = document.getElementById("signUpPassword").value;
          const name = document.getElementById("signUpName").value;

          try {
            const { data, error } = await supabase.auth.signUp({
              email,
              password,
              options: {
                data: {
                  full_name: name,
                },
              },
            });

            if (error) throw error;

            showToast(
              "Account created successfully! Please check your email.",
              "success"
            );
          } catch (error) {
            showToast(error.message, "error");
          }
        });
    </script>
  </body>
</html>

