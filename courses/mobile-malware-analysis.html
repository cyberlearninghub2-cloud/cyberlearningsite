




<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Exo+2:wght@700;800;900&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css"
    />
    <link rel="stylesheet" href="assets/css/coursepages.css">
    
    <!-- ========== Start: SEO & Schema Enhancement ========== -->
    <title>Mobile Malware Analysis - Complete Course | CipherHall</title>
    <meta name="description" content="Enroll in our expert-led Mobile Malware Analysis course. Master static and dynamic analysis of Android/iOS malware, advanced reverse engineering, and threat intelligence.">

    
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png" />
    <link rel="shortcut icon" href="/favicon.png" type="image/x-icon" />
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png" />
    <link rel="canonical" href="https://www.cipherhall.com/courses/mobile-malware-analysis.html" />

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Course",
      "name": "Mobile Malware Analysis - Complete Course",
      "description": "An exhaustive, 50-lesson deep dive into the art and science of mobile malware. This course takes you from the core principles of mobile OS security to mastering advanced exploitation, network forensics, and reverse engineering of sophisticated Android and iOS malware.",
      "provider": {
        "@type": "Organization",
        "name": "CipherHall",
        "sameAs": "https://www.cipherhall.com"
      },
      "hasCourseInstance": {
        "@type": "CourseInstance",
        "courseMode": "Online",
        "instructor": {
          "@type": "Person",
          "name": "Dr. 'Frida' Chen"
        }
      }
    }
    </script>
    <!-- ========== End: SEO & Schema Enhancement ========== -->
</head>
  <body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
      <div class="loader-icon">
        <i class="fas fa-graduation-cap"></i>
      </div>
      <div class="loader-text">Loading Course Content...</div>
    </div>

    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- Music Player (fixed at top right) -->
    <div class="header-controls">
      <div class="music-dropdown" id="music-dropdown">
        <button class="btn btn-secondary">
          <span id="music-button-text">STUDY MUSIC</span>
          <i id="music-icon" class="fa-solid fa-music"></i>
        </button>
        <div class="music-dropdown-content" id="music-dropdown-content">
          <a
            href="#"
            data-src="https://www.learningcontainer.com/wp-content/uploads/2020/02/Kalimba.mp3"
            >1. Coffee Shop Vibes</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3"
            >2. City Lights Lofi</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-15.mp3"
            >3. Mellow Thoughts</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-13.mp3"
            >4. Rainy Mood</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3"
            >5. Time Alone</a
          >
          <a href="#" id="stop-music-link"
            ><i class="fa-solid fa-stop-circle"></i> Stop Music</a
          >
        </div>
      </div>

      <button class="btn btn-secondary" id="resetProgressBtn">
        <i class="fas fa-redo"></i>
        Reset Progress
      </button>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal" style="display: none">
      <div class="modal-overlay"></div>
      <div class="modal-content">
        <span class="close" id="closeAuthModal">&times;</span>
        <div class="auth-tabs">
          <button id="tabSignIn" class="auth-tab active">Sign In</button>
          <button id="tabSignUp" class="auth-tab">Sign Up</button>
        </div>
        <div
          id="authLoader"
          style="display: none; text-align: center; padding: 2rem"
        >
          <i
            class="fas fa-spinner fa-spin fa-2x"
            style="color: var(--color-green)"
          ></i>
          <p style="margin-top: 0.5rem">Authenticating...</p>
        </div>
        <div id="signInForm" class="auth-form">
          <h2>Sign In to CipherHall</h2>
          <button id="googleSignIn" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignInForm">
            <input
              type="email"
              id="signInEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signInPassword"
              placeholder="Password"
              required
            />
            <button type="submit" class="btn btn-primary">Sign In</button>
          </form>
        </div>
        <div id="signUpForm" class="auth-form" style="display: none">
          <h2>Join CipherHall</h2>
          <button id="googleSignUp" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignUpForm">
            <input
              type="text"
              id="signUpName"
              placeholder="Full Name"
              required
            />
            <input
              type="email"
              id="signUpEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signUpPassword"
              placeholder="Password (min. 8 characters)"
              required
            />
            <button type="submit" class="btn btn-secondary">
              Create Account
            </button>
          </form>
        </div>
        <div id="authMessage"></div>
      </div>
    </div>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="course-info">
          <h1 class="course-title" id="courseTitle">Loading...</h1>
          <div class="course-progress">
            <div class="progress-header">
              <span class="progress-label">Course Progress</span>
              <span class="progress-percentage" id="courseProgressPercent"
                >0%</span
              >
            </div>
            <div class="progress-bar">
              <div
                class="progress-fill"
                id="courseProgressFill"
                style="width: 0%"
              ></div>
            </div>
            <div class="progress-stats">
              <span id="completedLessons">0</span>
              <span id="totalLessons">0</span>
            </div>
          </div>
          <a href="/dashboard.html" class="back-to-dashboard">
            <i class="fas fa-arrow-left"></i>
            Back to Dashboard
          </a>
        </div>
      </div>

      <nav class="lesson-nav" id="lessonNav">
        <!-- Lessons will be loaded dynamically -->
      </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <header class="content-header">
        <div class="lesson-header">
          <div class="lesson-header-left">
            <span class="lesson-number" id="currentLessonNumber">1</span>
            <h1 class="lesson-header-title" id="currentLessonTitle">
              Loading...
            </h1>
          </div>
          <div class="lesson-actions">
            <button class="mbtn btn-primary" id="menuToggle">
              <i class="fas fa-bars"></i>
            </button>
          </div>
        </div>
      </header>

      <div class="content-body" id="contentBody">
        <div class="lesson-content" id="lessonContent">
          <!-- Lesson content will be loaded dynamically -->
        </div>
      </div>

      <footer class="lesson-navigation">
        <div class="nav-info" id="navInfo">Lesson 1 of 10</div>
        <div class="nav-controls">
          <button class="btn btn-secondary" id="prevLessonBtn" disabled>
            <i class="fas fa-chevron-left"></i>
            Previous
          </button>
          <button class="btn btn-primary" id="nextLessonBtn" disabled>
            Next
            <i class="fas fa-chevron-right"></i>
          </button>
        </div>
      </footer>
    </main>

    <!-- Achievement Notification -->
    <div id="achievementNotification" class="achievement-notification">
      <div class="notification-header">
        <div class="notification-icon" id="notificationIcon">
          <i class="fas fa-trophy"></i>
        </div>
        <div class="notification-content">
          <h3 id="notificationTitle">Achievement Unlocked!</h3>
          <p id="notificationDescription">Description here...</p>
        </div>
      </div>
      <div class="notification-reward" id="notificationReward">
        <i class="fas fa-coins"></i>
        <span id="notificationPoints">+100 Points</span>
      </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast">
      <span id="toastMessage"></span>
    </div>

    <script>
      // =====================================================
      // SYNCHRONIZED COURSE SYSTEM WITH DASHBOARD INTEGRATION
      // =====================================================

      // Supabase Configuration - Replace with your config
      const supabaseUrl = "https://lzcmzulemfubjaksoqor.supabase.co";
      const supabaseKey =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx6Y216dWxlbWZ1Ympha3NvcW9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzMzM5MDgsImV4cCI6MjA3MDkwOTkwOH0.crhPH4YWtRsr1BJTpAQcmPbWSpwIWRbzoI4sRb2_fPI";
      const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

      // =====================================================
      // COURSE DATA STRUCTURE - REPLACE WITH YOUR COURSE JSON
      // =====================================================
      const COURSE_DATA = {
        "id": "mobile-malware-analysis",
        "title": "Mobile Malware Analysis: From Foundations to Advanced Reverse Engineering",
        "description": "An exhaustive, 50-lesson deep dive into the art and science of mobile malware. This course takes you from the core principles of mobile OS security to mastering advanced exploitation, network forensics, and reverse engineering of sophisticated Android and iOS malware.",
        "category": "malware-analysis",
        "difficulty": "Intermediate to Expert",
        "duration": "100 hours",
        "instructor": "Dr. 'Frida' Chen",
        "lessons": [
            {
                "id": "lesson-1-mobile-malware-landscape",
                "title": "Lesson 1: Mobile Malware Landscape",
                "duration": "120 min",
                "objectives": [
                    "Define the scope and scale of the mobile threat landscape",
                    "Understand the fundamental architectural differences that make Android a more common malware target than iOS",
                    "Analyze the evolution of mobile attack vectors from simple SMS scams to sophisticated supply chain attacks",
                    "Categorize threat actor motivations, from financial gain to nation-state espionage"
                ],
                "content": {
                    "overview": "This foundational lesson sets the stage for the entire course. We will explore the modern mobile threat landscape, understanding why mobile devices are such a high-value target for attackers. You will learn the key differences between the Android and iOS ecosystems that dictate the types of malware we see, and analyze the motivations driving the adversaries behind these attacks.",
                    "sections": [
                        {
                            "title": "Android vs. iOS Malware Differences",
                            "content": "<p>While both platforms are targeted, the volume and variety of malware are vastly different due to core architectural philosophies.</p><h3>Why Android is the Primary Target:</h3><ul><li><strong>Open Ecosystem & Sideloading:</strong> Android's primary strength is its openness. However, this also means users can easily install applications from untrusted, third-party app stores or directly from the web ('sideloading'). This is the #1 infection vector for Android malware.</li><li><strong>Platform Fragmentation:</strong> With thousands of different devices from hundreds of manufacturers, many Android devices do not receive timely security updates, leaving them vulnerable to known exploits.</li></ul><h3>iOS Malware: Rare but High-Impact</h3><ul><li><strong>Closed Ecosystem ('Walled Garden'):</strong> iOS is a tightly controlled platform. By default, users can only install apps from the official App Store, where Apple performs a security review. This makes widespread malware infections very difficult.</li><li><strong>Primary Vectors:</strong> iOS malware typically relies on very high-end, targeted attacks (e.g., zero-day exploits that can cost millions of dollars) or abuses enterprise certificates to sideload apps onto non-jailbroken devices in a corporate environment.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1607252650355-f7fd0460ccdb?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Threat Actor Motivations",
                            "content": "<p>Understanding the 'why' behind an attack is crucial for analysis. Motivations range from simple to highly sophisticated.</p><ul><li><strong>Financial Gain:</strong> The most common motivation. This drives banking trojans (e.g., Anubis, Cerberus), ransomware, and premium SMS fraud.</li><li><strong>Information Theft & Espionage:</strong> Stealing personal data, contacts, location, and corporate secrets. This can be done by commercial spyware or nation-state actors (e.g., Pegasus spyware).</li><li><strong>Resource Abuse:</strong> Using the compromised device's CPU for cryptocurrency mining or its network for DDoS attacks as part of a botnet (e.g., Mirai).</li></ul>",
                            "image": "https://images.unsplash.com/photo-1548092372-6a7e3206a5a2?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary infection vector for most Android malware?", "options": ["Through the official Google Play Store", "Via malicious SMS messages", "Users installing applications from third-party app stores or the web (sideloading)", "Bluetooth vulnerabilities"], "correct": 2, "explanation": "The ability to easily install apps from untrusted sources is the single biggest factor contributing to the high volume of Android malware." },
                        { "id": 2, "question": "iOS malware is much rarer than Android malware primarily due to what?", "options": ["iPhones are not connected to the internet", "Apple's 'walled garden' approach, where users can only install apps from the heavily curated official App Store", "There are no valuable targets using iPhones", "The iOS kernel is bug-free"], "correct": 1, "explanation": "This closed, centrally-controlled ecosystem makes widespread, commodity malware infections extremely difficult on non-jailbroken devices." }
                    ]
                }
            },
            {
                "id": "lesson-2-mobile-os-internals",
                "title": "Lesson 2: Mobile Operating System Internals",
                "duration": "120 min",
                "objectives": [
                    "Compare and contrast the Android and iOS security architectures",
                    "Understand the security implications of the Android Activity/Service/Receiver/Provider component model",
                    "Deconstruct the iOS Secure Boot Chain and Application Sandbox",
                    "Analyze the differences in Inter-Process Communication (IPC) mechanisms"
                ],
                "content": {
                    "overview": "To understand how malware compromises a system, you must first understand the system's defenses. This lesson provides a comparative deep dive into the security architectures of both Android and iOS, highlighting the core components that malware seeks to abuse or bypass.",
                    "sections": [
                        {
                            "title": "Android Security Architecture",
                            "content": "<p>Android is built on a Linux kernel. Key concepts for a malware analyst include:</p><ul><li><strong>Application Sandbox:</strong> Each app runs as its own user (UID). The analyst's goal is often to find ways to break out of this sandbox.</li><li><strong>The Four Components:</strong> Malware often abuses the component model. It might register a malicious Broadcast Receiver to listen for a system event, or it might create a background Service for its persistent command-and-control communication.</li><li><strong>Exported Components:</strong> An exported component can be accessed by other apps. Malware often looks for and tries to exploit exported components in legitimate, installed applications.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1629654297299-c8506221ca97?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "iOS Security Architecture",
                            "content": "<p>iOS has a fundamentally more restrictive architecture.</p><ul><li><strong>Secure Boot Chain:</strong> Ensures the integrity of the OS from the hardware up.</li><li><strong>Mandatory Code Signing:</strong> No unsigned code can be executed on a stock device.</li><li><strong>Application Sandbox:</strong> Even stricter than Android's. An app is given a private container and is chroot-jailed into it, with very limited access to the rest of the file system.</li><li><strong>Hardware Security:</strong> The Secure Enclave provides a hardware-backed root of trust for cryptographic keys.</li></ul><p>Because of these controls, iOS malware often has to rely on finding and exploiting a 0-day vulnerability in the operating system itself to achieve its goals.</p>",
                            "image": "https://images.unsplash.com/photo-1593110022831-292911b3b194?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "The security control that ensures every application runs as its own Linux user is the:", "options": ["Permission System", "SELinux", "Application Sandbox", "Secure Boot Chain"], "correct": 2, "explanation": "The UID-based sandbox is the foundational isolation mechanism in Android." },
                        { "id": 2, "question": "The security control that ensures only Apple-signed code is loaded during the boot process of an iPhone is the:", "options": ["Application Sandbox", "Permission System", "Secure Enclave", "Secure Boot Chain"], "correct": 3, "explanation": "The Secure Boot Chain is the hardware-rooted chain of trust that guarantees the integrity of the operating system itself." }
                    ]
                }
            },
            {
                "id": "lesson-3-malware-analysis-env-setup",
                "title": "Lesson 3: Malware Analysis Environment Setup",
                "duration": "180 min",
                "objectives": [
                    "Set up a dedicated, isolated virtual machine for malware analysis",
                    "Configure Android emulators for safe dynamic analysis of malware",
                    "Implement network isolation and traffic monitoring for the lab",
                    "Install and configure essential static and dynamic analysis tools"
                ],
                "content": {
                    "overview": "A malware analyst must **never** perform analysis on their primary work machine. A dedicated, isolated laboratory environment is non-negotiable. This is a critical, hands-on lesson that guides you through the complete setup of a professional and safe mobile malware analysis lab.",
                    "sections": [
                        {
                            "title": "The Isolated Analysis VM",
                            "content": "<p>Your primary analysis environment will be a virtual machine (e.g., using VMware or VirtualBox). This provides a snapshotting capability, allowing you to instantly revert to a clean state after analyzing a piece of malware.</p><h3>VM Network Configuration:</h3><ul><li>The VM's network adapter should be set to 'Host-only' or a custom, isolated virtual network.</li><li>This VM must **not** have direct access to the internet or your corporate network.</li><li>For controlled internet access, you can configure this VM to route its traffic through a second, separate 'gateway' VM that runs your traffic analysis tools (like Burp Suite) and can be firewalled appropriately.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1510511233900-1982d92bd835?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "The Android Emulator for Dynamic Analysis",
                            "content": "<p>You will install Android Studio inside your analysis VM. You can then create Android Virtual Devices (AVDs) for different Android versions. These emulators will run within your isolated VM, providing a safe, doubly-sandboxed environment to execute and observe the malware's behavior without risk of it affecting your host machine or your network.</p>",
                            "image": "https://images.unsplash.com/photo-1607252650355-f7fd0460ccdb?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Create a new Android Emulator (AVD) from Command Line",
                        "language": "bash",
                        "code": "# List available system images\nsdkmanager --list | grep system-images\n\n# Create a new AVD. The 'google_apis' image includes Google Play Services.\n# We are using an older version of Android (e.g., API 28 for Android 9) as it is often\n# easier for certain dynamic analysis tasks.\n\navdmanager create avd -n MalwareLab-API28 -k \"system-images;android-28;google_apis;x86\" -d \"pixel\""
                    },
                    {
                        "title": "Launch the Emulator with a Writable System Partition",
                        "language": "bash",
                        "code": "# The `-writable-system` flag is crucial. It allows you to remount the system\n# partition as read-write, which is necessary to install Frida's server or a\n# custom CA certificate for Burp.\nemulator -avd MalwareLab-API28 -writable-system -no-snapshot-load"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Why is network isolation so critical for a malware analysis lab?", "options": ["To get a faster internet connection", "To prevent the malware sample from connecting to its C2 server or attacking other machines on your local network", "It is not important", "To make the virtual machine easier to configure"], "correct": 1, "explanation": "A malware lab must be a completely contained environment to prevent any accidental spread of the malicious code or unwanted outbound connections." },
                        { "id": 2, "question": "The snapshotting capability of a virtual machine is useful in malware analysis because it:", "options": ["Allows you to instantly revert the analysis environment to a clean, pre-infection state", "Makes the analysis run faster", "Encrypts the malware sample", "Sends the analysis report automatically"], "correct": 0, "explanation": "Snapshots are the key to lab efficiency and safety, providing a quick and reliable way to 'sterilize' your environment after each sample detonation." }
                    ]
                }
            },
            {
                "id": "lesson-4-sample-acquisition-handling",
                "title": "Lesson 4: Sample Acquisition and Handling",
                "duration": "120 min",
                "objectives": [
                    "Identify reputable sources for acquiring malware samples for research",
                    "Follow safe handling procedures to prevent accidental infection",
                    "Calculate and use cryptographic hashes to uniquely identify samples",
                    "Understand how to triage and classify new samples"
                ],
                "content": {
                    "overview": "A malware analyst is nothing without samples to analyze. This lesson covers where to find malware samples, and more importantly, how to handle them in a safe and forensically sound manner. One mistake here can compromise your entire lab, or worse, your real machine.",
                    "sections": [
                        {
                            "title": "Malware Sample Sources",
                            "content": "<p>There are many places to acquire samples for research and education. These include:</p><ul><li><strong>VirusTotal:</strong> The premier source. With an academic or enterprise account, you can download samples that have been submitted to the platform.</li><li><strong>MalwareBazaar:</strong> An open project from abuse.ch that provides a repository of malware samples.</li><li><strong>Academic Datasets:</strong> Datasets like AndroZoo provide access to millions of APKs for research.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1563905788977-62b714f520b2?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Safe Handling Procedures",
                            "content": "<p>A strict protocol is necessary to prevent accidents.</p><ol><li>**Never handle samples outside your isolated VM.**</li><li>Rename samples with a `.bin` or `.malware` extension to prevent your host OS from accidentally trying to interpret or run them.</li><li>Password-protect ZIP archives containing samples when transferring them (`infected` is a common password).</li><li>**Calculate hashes for everything.** As soon as you acquire a sample, calculate its MD5, SHA1, and SHA256 hashes. These hashes are the sample's unique fingerprint and are used to track it, query threat intelligence platforms, and ensure its integrity.</li></ol>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Why is it important to calculate the cryptographic hash of a malware sample as soon as you acquire it?", "options": ["To make the file smaller", "The hash acts as a unique fingerprint for the sample, used for tracking, querying threat intelligence, and verifying integrity", "To encrypt the file", "To delete the file"], "correct": 1, "explanation": "The hash is the primary identifier for any piece of malware. A security report or threat intelligence feed will almost always use the SHA256 hash as the primary key for a sample." }
                    ]
                }
            },
            {
                "id": "lesson-5-android-malware-types",
                "title": "Lesson 5: Android Malware Types",
                "duration": "120 min",
                "objectives": [
                    "Classify common types of Android malware based on their primary function",
                    "Understand the technical mechanisms of Trojans, Adware, Banking Malware, and Ransomware",
                    "Analyze the evolution of different malware families"
                ],
                "content": {
                    "overview": "Not all malware is created equal. This lesson provides a taxonomy of the major categories of Android malware you will encounter. Understanding a sample's classification helps you to form a hypothesis about its goals and what to look for during your analysis.",
                    "sections": [
                        {
                            "title": "Common Malware Categories",
                            "content": "<ul><li><strong>Trojan:</strong> Malware that disguises itself as a legitimate application to trick the user into installing it. Most other malware types are also Trojans.</li><li><strong>Adware:</strong> Aggressively displays unwanted advertisements.</li><li><strong>Potentially Unwanted Program (PUP):</strong> Not strictly malicious, but exhibits shady behavior, like collecting excessive telemetry or changing browser settings.</li><li><strong>Banking Malware:</strong> Designed specifically to steal banking credentials, often using overlay attacks.</li><li><strong>Ransomware:</strong> Either encrypts the user's files (crypto-ransomware) or simply locks the device's screen (locker).</li><li><strong>Spyware/Stalkerware:</strong> Covertly collects and exfiltrates the user's private data (messages, location, contacts).</li><li><strong>Botnet/Dropper:</strong> The malware's primary purpose is to act as a foothold to download and install other, more malicious payloads.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1547756536-cde55c3f2c65?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Malware that disguises itself as a legitimate game but then secretly sends premium SMS messages in the background is a:", "options": ["Ransomware", "Trojan", "Adware", "PUP"], "correct": 1, "explanation": "A Trojan is a malicious program that masquerades as something benign to deceive the user into installing it. This is a very common technique." }
                    ]
                }
            },
            {
                "id": "lesson-6-apk-static-analysis",
                "title": "Lesson 6: APK Static Analysis",
                "duration": "150 min",
                "objectives": [
                    "Perform a thorough, manual static analysis of a disassembled APK",
                    "Analyze the `AndroidManifest.xml` to identify the application's attack surface and permissions",
                    "Inspect Smali code to find hard-coded secrets and suspicious API calls",
                    "Recognize common code obfuscation techniques used by malware"
                ],
                "content": {
                    "overview": "Static analysis is the first step in reverse engineering any sample. This lesson is a hands-on deep dive into the static analysis workflow. You will use `apktool` to disassemble a real malware sample and begin analyzing its manifest, resources, and Smali code to understand its structure and capabilities before ever running it.",
                    "sections": [
                        {
                            "title": "Manifest Analysis",
                            "content": "<p>The manifest file provides immediate clues about the malware's intent.</p><h3>What to Look For:</h3><ul><li><strong>Suspicious Permissions:</strong> A simple calculator app asking for `READ_SMS`, `SEND_SMS`, and `READ_CONTACTS` is an immediate red flag.</li><li><strong>Exported Components:</strong> Are there any broadcast receivers that could be triggered by other apps or system events?</li><li><strong>Device Administrator:</strong> Does the app request device administrator privileges? This is a common tactic for ransomware and lockers to make themselves harder to uninstall.</li><li><strong>Accessibility Service:</strong> Does the app request the 'bind accessibility service' permission? This is a hallmark of modern banking trojans.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1517694712202-14261e80e3a5?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Smali Code Analysis",
                            "content": "<p>While time-consuming, analyzing the Smali code is where you find the ground truth. You can `grep` through the Smali files for interesting strings and API calls.</p><h3>What to Search For:</h3><ul><li><strong>Strings:</strong> IP addresses, URLs, encryption keys, messages to the user.</li><li><strong>API Calls:</strong> Look for the use of privacy-sensitive APIs (`TelephonyManager->getDeviceId()`), networking APIs (`java.net.URL->openConnection()`), or cryptography APIs (`javax.crypto.Cipher`).</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "You are analyzing the manifest of a puzzle game and see it requests permission to use the Accessibility Service. What does this suggest?", "options": ["This is normal for a puzzle game", "This is a very strong indicator that the application is malicious, likely a banking trojan", "The game has good accessibility features", "The manifest is corrupted"], "correct": 1, "explanation": "The Accessibility Service is extremely powerful and has very few legitimate use cases. Its presence in a simple game app is a massive red flag and a primary indicator of a potential banking trojan or spyware." }
                    ]
                }
            },
            {
                "id": "lesson-7-android-malware-behavior-analysis",
                "title": "Lesson 7: Android Malware Behavior Analysis (Dynamic)",
                "duration": "180 min",
                "objectives": [
                    "Safely execute a malware sample in an isolated emulator environment",
                    "Monitor system behavior, including file system access, API calls, and process creation",
                    "Intercept and analyze the malware's network communications with a proxy",
                    "Correlate static and dynamic findings to build a complete picture of the malware"
                ],
                "content": {
                    "overview": "This is where we detonate the malware. This lesson covers the hands-on process of running a malware sample in your secure, isolated lab. The goal is to observe what the malware *actually does* when it runs, from the files it creates to the network connections it makes, to confirm the hypotheses you formed during static analysis.",
                    "sections": [
                        {
                            "title": "The Dynamic Analysis Workflow",
                            "content": "<h3>A typical analysis session involves:</h3><ol><li>Take a clean snapshot of your emulator.</li><li>Start all your monitoring tools (Logcat, Burp Suite, ProcMon-equivalent).</li><li>Install and run the malware sample (`adb install sample.apk`).</li><li>Interact with the malware as a user might (e.g., grant its requested permissions).</li><li>Observe and document all the behavior: file system changes, processes spawned, and especially, the network traffic in Burp Suite.</li><li>Stop the analysis and revert the emulator to the clean snapshot.</li><li>Analyze your captured logs and traffic.</li></ol>",
                            "image": "https://images.unsplash.com/photo-1614064548237-02f8f17374b2?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Why is it absolutely critical to revert your emulator to a clean snapshot after analyzing each malware sample?", "options": ["To save disk space", "To ensure that artifacts and changes from one sample do not contaminate or influence the analysis of the next sample", "It is not important", "To make the emulator run faster"], "correct": 1, "explanation": "This ensures a clean, repeatable analysis environment for every single sample, which is a core tenet of a sound scientific and forensic process." }
                    ]
                }
            },
            {
                "id": "lesson-8-android-persistence-mechanisms",
                "title": "Lesson 8: Android Persistence Mechanisms",
                "duration": "120 min",
                "objectives": [
                    "Identify how malware uses Broadcast Receivers to achieve persistence after a reboot",
                    "Analyze how malicious services are used to maintain a long-running presence",
                    "Understand how Device Administrator privileges are abused to prevent uninstallation"
                ],
                "content": {
                    "overview": "A key goal for malware is to achieve persistenceâ€”to ensure that it will run again even if the user reboots their phone. This lesson covers the common techniques Android malware uses to persist, and how to find them both statically and dynamically.",
                    "sections": [
                        {
                            "title": "Boot Persistence",
                            "content": "<p>The most common persistence technique is to register a Broadcast Receiver in the manifest that listens for the `android.intent.action.BOOT_COMPLETED` broadcast. This is a system message that is sent every time the device finishes booting up. The malware's receiver will wake up upon receiving this message and can then start its malicious background service. Analyzing the manifest for a receiver with this intent filter is a primary goal of static analysis.</p>",
                            "image": "https://images.unsplash.com/photo-1498050108023-c5249f4df085?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Device Administrator Abuse",
                            "content": "<p>Ransomware and other highly malicious apps will often trick the user into granting them Device Administrator privileges. Once an app is a device admin, it cannot be easily uninstalled by the user. The user must first go into the system settings and revoke the administrator privileges. Many users do not know how to do this, effectively making the malware permanent.</p>",
                            "image": "https://images.unsplash.com/photo-1547756536-cde55c3f2c65?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the most common technique malware uses to start itself after the phone reboots?", "options": ["It modifies the kernel", "It registers a Broadcast Receiver for the `BOOT_COMPLETED` action", "It cannot survive a reboot", "It uses a hardware exploit"], "correct": 1, "explanation": "This is a standard and very effective Android feature that is widely abused by malware for persistence." },
                        { "id": 2, "question": "Why does ransomware often trick users into granting it Device Administrator privileges?", "options": ["To make the device run faster", "To make the malware application difficult or impossible for a normal user to uninstall", "To gain access to the camera", "To encrypt the user's files"], "correct": 1, "explanation": "Abusing the Device Admin API is a key persistence and anti-removal technique." }
                    ]
                }
            },
            {
                "id": "lesson-9-ios-malware-overview",
                "title": "Lesson 9: iOS Malware Overview",
                "duration": "120 min",
                "objectives": [
                    "Understand why iOS malware is fundamentally different and rarer than Android malware",
                    "Analyze case studies of malware that requires a jailbroken device",
                    "Explore how enterprise certificates and sideloading can be abused to infect non-jailbroken devices",
                    "Recognize the high value and targeted nature of iOS exploits"
                ],
                "content": {
                    "overview": "This lesson transitions to the much rarer but highly sophisticated world of iOS malware. We will explore why the 'walled garden' makes commodity malware nearly impossible and cover the primary attack vectors that advanced adversaries use to target the iOS platform.",
                    "sections": [
                        {
                            "title": "Enterprise Certificate Abuse",
                            "content": "<p>This is the most common way that widespread malware campaigns have targeted non-jailbroken devices. An attacker gets their hands on an Apple Developer Enterprise certificate. They can then sign their malicious app with this certificate. The app can then be distributed outside the App Store (e.g., from a webpage). A user who is tricked into trusting this certificate and installing the app will be infected. Apple has become much more aggressive in revoking these abused certificates.</p>",
                            "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Targeted 0-Day Exploits",
                            "content": "<p>Highly sophisticated, nation-state level spyware (like Pegasus) does not rely on sideloading. It uses a chain of previously unknown (0-day) vulnerabilities to achieve a 'zero-click' infection. For example, a victim might just receive a specially crafted message that exploits a bug in a messaging app's parser, leading to code execution that then exploits a kernel vulnerability to gain full control of the device without any user interaction. These are extremely rare and valuable exploits.</p>",
                            "image": "https://images.unsplash.com/photo-1614064548237-02f8f17374b2?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the most common attack vector used by malware to infect a large number of *non-jailbroken* iOS devices?", "options": ["The official App Store", "The abuse of a leaked or stolen enterprise signing certificate", "Via SMS messages", "Through a hardware vulnerability"], "correct": 1, "explanation": "Abusing the enterprise program allows an attacker to bypass the App Store and get users to install their app, making it the most common vector for broader infections." }
                    ]
                }
            },
            {
                "id": "lesson-10-ios-app-analysis",
                "title": "Lesson 10: iOS Application Static Analysis",
                "duration": "120 min",
                "objectives": [
                    "Perform static analysis of a decrypted IPA file",
                    "Analyze the Mach-O binary format and its key sections",
                    "Verify an application's code signature and analyze its entitlements for suspicious privileges",
                    "Look for hard-coded secrets and other common flaws in the binary"
                ],
                "content": {
                    "overview": "The static analysis process for an iOS application is similar to Android, but the file formats and tools are different. This lesson covers the initial static analysis workflow for an iOS malware sample.",
                    "sections": [
                        {
                            "title": "Analyzing Entitlements",
                            "content": "<p>After unpacking the IPA, a key first step is to check the app's entitlements. Entitlements are special privileges granted to an app, like the ability to use push notifications, share data with a specific app group, or access the Keychain. An analyst would look for any unusual or overly permissive entitlements that the malware might abuse.</p>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "In an iOS static analysis, what does an analyst check to see what special privileges (like Keychain access) an app has been granted?", "options": ["The application's icon", "The `Info.plist`", "The application's entitlements, which are part of its code signature", "The app's size"], "correct": 2, "explanation": "Entitlements are a critical security boundary, and analyzing them is a key part of understanding an app's capabilities and attack surface." }
                    ]
                }
            },
            {
                "id": "lesson-11-ios-dynamic-analysis",
                "title": "Lesson 11: iOS Dynamic Analysis with Frida",
                "duration": "120 min",
                "objectives": [
                    "Use Frida for runtime manipulation of iOS malware on a jailbroken device",
                    "Hook Objective-C and Swift methods to trace the malware's behavior",
                    "Monitor system calls and API usage in real time",
                    "Analyze Keychain access and other sensitive resource interactions"
                ],
                "content": {
                    "overview": "Just like with Android, Frida is the king of iOS dynamic analysis. This lesson focuses on using Frida to instrument and analyze a running iOS malware sample on a jailbroken device to understand its behavior and bypass its defenses.",
                    "sections": [
                        {
                            "title": "The Dynamic Analysis Workflow for iOS",
                            "content": "<p>The workflow is very similar to Android, but the targets are different.</p><ol><li><strong>Setup:</strong> Get the decrypted IPA onto your jailbroken device.</li><li><strong>Hypothesis:</strong> Based on your static analysis, form a hypothesis (e.g., 'I believe this app is stealing contact information'). Find the relevant classes and methods using `class-dump`.</li><li><strong>Hooking:</strong> Write a Frida script to hook the `Contacts` framework APIs.</li><li><strong>Execution:</strong> Launch the malware with your Frida script injected.</li><li><strong>Observation:</strong> Monitor your Frida console to see if the malware ever calls the hooked contact-accessing functions.</li></ol>",
                            "image": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "To understand which sensitive data an iOS malware sample is storing in the Keychain, an analyst would use Frida to hook what?", "options": ["The file system APIs", "The networking APIs", "The Keychain Services APIs (like `SecItemCopyMatching` and `SecItemAdd`)", "The user interface APIs"], "correct": 2, "explanation": "Hooking these specific functions allows you to intercept the malware's interactions with the secure Keychain in real time, revealing what it is storing and retrieving." }
                    ]
                }
            },
            {
                "id": "lesson-12-ios-privilege-escalation",
                "title": "Lesson 12: iOS Privilege Escalation",
                "duration": "120 min",
                "objectives": [
                    "Understand how malware chains vulnerabilities to escalate privileges",
                    "Analyze real-world examples of iOS kernel exploits used in jailbreaks",
                    "Recognize sandbox escape techniques",
                    "Inspect how malware might install a root certificate to bypass TLS validation"
                ],
                "content": {
                    "overview": "For iOS malware to achieve its goals, it often must escalate its privileges beyond the restrictive application sandbox. This lesson covers the advanced topic of privilege escalation on iOS, focusing on how malware exploits kernel vulnerabilities to gain root access.",
                    "sections": [
                        {
                            "title": "Sandbox Escape",
                            "content": "<p>A sandbox escape is an exploit that allows code running in a sandboxed process to break out and execute code in a less restrictive context. On iOS, this almost always requires a vulnerability in the kernel or a high-privilege system service that can be reached from within the sandbox. Analysis of this kind of malware involves advanced reverse engineering of both the application's binary and parts of the iOS operating system itself.</p>",
                            "image": "https://images.unsplash.com/photo-1629654297299-c8506221ca97?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "To break out of the highly restrictive application sandbox on iOS, malware must typically exploit a vulnerability in what?", "options": ["Another third-party application", "The user's password", "The iOS kernel or a privileged system service", "The App Store"], "correct": 2, "explanation": "The kernel is the ultimate arbiter of security on the device. A vulnerability here is the key to a full system compromise and is the primary goal of jailbreaks and sophisticated spyware." }
                    ]
                }
            },
            {
                "id": "lesson-13-native-code-analysis",
                "title": "Lesson 13: Native Code Analysis",
                "duration": "120 min",
                "objectives": [
                    "Understand how to analyze ARM assembly code",
                    "Use Ghidra or IDA Pro to reverse engineer native libraries (`.so` files)",
                    "Analyze the Java Native Interface (JNI) for security vulnerabilities"
                ],
                "content": {
                    "overview": "This advanced lesson moves to the lowest level of the code. We will cover the fundamentals of reverse engineering the compiled ARM assembly code found in native libraries. This is a critical skill for analyzing sophisticated malware and for finding memory corruption vulnerabilities.",
                    "sections": [
                        {
                            "title": "JNI Security",
                            "content": "<p>The Java Native Interface (JNI) is the bridge between the Java/Kotlin code and the native C/C++ code. A common vulnerability pattern is for the Java code to pass data to a native function that then processes that data insecurely (e.g., with a `strcpy`, leading to a buffer overflow). Analyzing this boundary is key.</p>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary purpose of the Java Native Interface (JNI)?", "options": ["To run Java code", "To act as a bridge, allowing Java code to call functions in native C/C++ libraries", "To secure the application", "To manage user permissions"], "correct": 1, "explanation": "The JNI is the key interoperability layer, but it is also a complex and common source of security vulnerabilities if not used carefully." }
                    ]
                }
            },
            {
                "id": "lesson-14-anti-analysis",
                "title": "Lesson 14: Anti-Analysis Techniques",
                "duration": "120 min",
                "objectives": [
                    "Understand and reverse common code obfuscation techniques",
                    "Analyze packed and encrypted malware payloads",
                    "Recognize and bypass anti-debugging and anti-emulation checks"
                ],
                "content": {
                    "overview": "Malware authors know their creations will be analyzed. This lesson covers the 'anti-analysis' techniques they use to make a researcher's job harder, from obfuscating their code to actively detecting and evading analysis environments.",
                    "sections": [
                        {
                            "title": "Packing",
                            "content": "<p>'Packing' is a technique where the main malicious payload (the `classes.dex` file) is encrypted and hidden inside the APK. The main application code is just a small 'loader' or 'stub'. When the app is first run, this loader decrypts the real payload in memory and then dynamically loads it. This defeats static analysis tools, as they can only see the loader, not the real malicious code. An analyst must dynamically run the app and use a tool like Frida to hook the class loader and dump the decrypted payload from memory.</p>",
                            "image": "https://images.unsplash.com/photo-1555099962-4199c345e541?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the goal of a malware 'packer'?", "options": ["To make the malware bigger", "To encrypt the main malicious payload and hide it from static analysis tools", "To make the malware easier to analyze", "To add new features to the malware"], "correct": 1, "explanation": "Packing is a very common anti-analysis technique that forces the researcher to perform dynamic analysis to recover the true malicious payload." }
                    ]
                }
            },
            {
                "id": "lesson-15-crypto-analysis",
                "title": "Lesson 15: Cryptographic Analysis",
                "duration": "120 min",
                "objectives": [
                    "Reverse engineer custom encryption algorithms used by malware",
                    "Use dynamic instrumentation to intercept encryption keys and plaintext data",
                    "Understand how malware bypasses certificate pinning to communicate securely"
                ],
                "content": {
                    "overview": "Malware often uses custom or non-standard cryptography to hide its communications and data. This lesson covers how to analyze and break these custom implementations.",
                    "sections": [
                        {
                            "title": "Intercepting Keys with Frida",
                            "content": "<p>Even if the malware uses a standard encryption algorithm like AES, it still needs to use a key. A common technique is to use Frida to hook the standard crypto APIs (like `javax.crypto.Cipher` in Android). The hook can then be used to intercept and log the encryption key and the Initialization Vector (IV) that the malware passes to the function. With the key, IV, and the captured network traffic, an analyst can then decrypt the entire C2 communication offline.</p>",
                            "image": "https://images.unsplash.com/photo-1599373922312-5b9340d8a5a5?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the most effective way to decrypt malware's C2 traffic even if it's using strong encryption like AES?", "options": ["Brute-forcing the AES key", "Using Frida to hook the cryptographic functions in the running malware to steal the encryption key from memory", "Looking for the key on the C2 server", "It cannot be decrypted"], "correct": 1, "explanation": "The key must exist in memory at some point for the malware to use it. Dynamic instrumentation allows you to intercept it at that exact moment, which is the standard technique for this problem." }
                    ]
                }
            },
            {
                "id": "lesson-16-network-protocol-analysis",
                "title": "Lesson 16: Network Protocol Analysis",
                "duration": "120 min",
                "objectives": [
                    "Reverse engineer custom C2 communication protocols",
                    "Detect the use of DNS tunneling and other covert channels",
                    "Analyze patterns in network traffic to identify beaconing and other malicious behaviors"
                ],
                "content": {
                    "overview": "This advanced lesson focuses on the malware's communication. You will learn how to go beyond simply looking at HTTP traffic to reverse engineer custom, binary protocols that malware uses to communicate with its C2 server.",
                    "sections": [
                        {
                            "title": "Protocol Reverse Engineering",
                            "content": "<p>This is a manual process of looking at the captured network traffic (e.g., in Burp or Wireshark) and trying to understand its structure. By changing actions in the malware and observing how the outbound traffic changes, you can start to map out the protocol. For example, you might find that the first 4 bytes are a magic number, the next 2 are a command ID, and the rest is an encrypted payload. This is a key skill for a malware reverse engineer.</p>",
                            "image": "https://images.unsplash.com/photo-1544890225-2fde1e46f71b?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "When a piece of malware is not using standard HTTP for its C2 communication, an analyst must perform what?", "options": ["Give up", "Network protocol reverse engineering", "A static analysis", "A database query"], "correct": 1, "explanation": "This is a painstaking but essential process for fully understanding the malware's capabilities and commands." }
                    ]
                }
            },
            {
                "id": "lesson-17-banking-trojan-analysis",
                "title": "Lesson 17: Banking Trojan Analysis",
                "duration": "120 min",
                "objectives": [
                    "Perform a deep dive into the TTPs of modern Android banking trojans",
                    "Reverse engineer overlay attack mechanisms",
                    "Analyze how Trojans intercept SMS messages and abuse Accessibility Services"
                ],
                "content": {
                    "overview": "This lesson provides a dedicated deep dive into one of the most sophisticated and prevalent categories of mobile malware. We will reverse engineer a real banking trojan to understand its core techniques.",
                    "sections": [
                        {
                            "title": "Overlay Attacks",
                            "content": "<p>The primary credential theft technique. The malware monitors the running processes on the device. When it sees the user open their legitimate banking app, the malware instantly draws a fake 'WebView' login window *over* the real app. The user, thinking they are on the real login screen, enters their username and password into the fake window, and the credentials are sent to the attacker. To the user, this is almost undetectable.</p>",
                            "image": "https://images.unsplash.com/photo-1556741533-4020f1b29a28?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Abuse of Accessibility Services",
                            "content": "<p>The Accessibility Service in Android is a powerful API designed to assist users with disabilities by allowing an app to read the screen content and simulate user clicks. Banking Trojans trick the user into granting them Accessibility Service permissions. The malware can then use this permission to read OTP codes from authenticator apps directly off the screen, automatically click 'allow' on permission pop-ups, and perform a wide range of highly privileged actions.</p>",
                            "image": "https://images.unsplash.com/photo-1614064548237-02f8f17374b2?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is an overlay attack?", "options": ["An attack that deletes data", "An attack where a banking trojan draws a fake login window over the top of the legitimate banking app to steal credentials", "An attack on the network", "A denial-of-service attack"], "correct": 1, "explanation": "Overlay attacks are the signature technique of modern Android banking Trojans." },
                        { "id": 2, "question": "Why is tricking a user into granting 'Accessibility Service' permissions so dangerous?", "options": ["It is not dangerous", "It gives the malware the ability to read the content of the screen and programmatically click buttons, allowing it to defeat many security controls", "It lets the malware change the phone's wallpaper", "It allows the malware to send one SMS message"], "correct": 1, "explanation": "The Accessibility Service is one of the most powerful and privileged APIs on Android, and its abuse is a hallmark of sophisticated malware." }
                    ]
                }
            },
            {
                "id": "lesson-18-spyware-surveillance",
                "title": "Lesson 18: Spyware and Surveillance Tools",
                "duration": "120 min",
                "objectives": [
                    "Analyze the techniques used by spyware and stalkerware to exfiltrate user data",
                    "Use Frida to trace calls to privacy-sensitive APIs like location and contacts",
                    "Understand the C2 infrastructure behind commercial spyware"
                ],
                "content": {
                    "overview": "This lesson covers the insidious categories of spyware and stalkerwareâ€”applications whose sole purpose is to covertly monitor a user and exfiltrate their private data to a remote attacker. Analysis of these samples often focuses on data exfiltration channels and C2 communication.",
                    "sections": [
                        {
                            "title": "Data Exfiltration Channels",
                            "content": "<p>Analysis focuses on identifying what data is being collected and how it is being sent. Spyware will typically collect contacts, SMS messages, call logs, photos, and GPS location data. It will then package this data (e.g., into a JSON file), compress and encrypt it, and upload it periodically to a remote C2 server via an HTTP POST request.</p>",
                            "image": "https://images.unsplash.com/photo-1599373922312-5b9340d8a5a5?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Spyware is primarily designed to do what?", "options": ["Encrypt a user's files", "Show advertisements", "Covertly collect and exfiltrate a user's private data", "Mine cryptocurrency"], "correct": 2, "explanation": "Spyware's goal is espionage and the theft of personal information." }
                    ]
                }
            },
            {
                "id": "lesson-19-ransomware-analysis",
                "title": "Lesson 19: Ransomware Analysis",
                "duration": "120 min",
                "objectives": [
                    "Reverse engineer the file encryption mechanisms used by Android ransomware",
                    "Analyze screen locking techniques and develop bypasses",
                    "Assess the possibility of data recovery by looking for flaws in the crypto implementation"
                ],
                "content": {
                    "overview": "Ransomware is not just a problem for PCs. This lesson covers the two main types of ransomware seen on Android: crypto-ransomware that encrypts files, and screen lockers that simply prevent the user from accessing their device. The analysis often focuses on the cryptographic implementation, looking for weaknesses.",
                    "sections": [
                        {
                            "title": "File Encryption Analysis",
                            "content": "<p>A key part of the analysis is to determine *how* the ransomware encrypts files. A sophisticated sample will use a strong algorithm like AES and securely generate a random key for each file. However, less sophisticated samples often make mistakes:</p><ul><li>**Hard-coded Key:** They might use a single, hard-coded key for all files. If an analyst can find this key by reversing the app, they can write a decryptor.</li><li>**Weak Key Generation:** They might generate a key based on a predictable value, like the device's IMEI.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1614064548237-02f8f17374b2?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "A malware analyst reversing a ransomware sample would be most interested in finding what?", "options": ["The malware's icon", "The C2 server's location", "A flaw in the encryption implementation, such as a hard-coded key, that would allow for decryption of the files without paying", "The author of the malware"], "correct": 2, "explanation": "The primary goal of ransomware analysis is to find a way to recover the user's data, and this almost always involves finding a weakness in the cryptography." }
                    ]
                }
            },
            {
                "id": "lesson-20-adware-click-fraud",
                "title": "Lesson 20: Adware and Click Fraud",
                "duration": "120 min",
                "objectives": [
                    "Analyze the techniques used by adware to aggressively inject advertisements",
                    "Understand how click fraud malware simulates user clicks to generate revenue",
                    "Differentiate between legitimate ad libraries and malicious adware behavior"
                ],
                "content": {
                    "overview": "While often less destructive than ransomware, adware is a widespread and highly annoying category of malware. This lesson covers the analysis of adware and its more malicious cousin, click fraud malware.",
                    "sections": [
                        {
                            "title": "Click Fraud Techniques",
                            "content": "<p>Click fraud malware goes beyond just showing ads. It simulates user clicks on those ads to generate fraudulent revenue for the attacker. Analysis of these samples often involves using Frida to hook into the ad library's APIs to see how the malware is programmatically triggering the 'click' events, often in a hidden WebView in the background without the user's knowledge.</p>",
                            "image": "https://images.unsplash.com/photo-1555949963-aa79dcee981c?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is click fraud malware?", "options": ["Malware that steals passwords", "Malware that automatically and fraudulently clicks on online advertisements to generate revenue for the attacker", "Malware that shows ads", "Malware that encrypts files"], "correct": 1, "explanation": "Click fraud is a specific type of ad-related malware that moves from simply showing ads to actively defrauding the advertising networks." }
                    ]
                }
            },
            {
                "id": "lesson-21-apt-mobile-campaigns",
                "title": "Lesson 21: APT Mobile Campaigns",
                "duration": "120 min",
                "objectives": [
                    "Analyze the Tactics, Techniques, and Procedures (TTPs) of nation-state mobile malware",
                    "Understand how sophisticated actors chain exploits for targeted attacks",
                    "Explore the methodologies used for attribution in mobile APT campaigns"
                ],
                "content": {
                    "overview": "This is an advanced lesson on the most sophisticated category of mobile threats: malware developed by Advanced Persistent Threat (APT) groups, typically nation-state actors. The analysis of these campaigns focuses on understanding the adversary's TTPs and strategic goals.",
                    "sections": [
                        {
                            "title": "Pegasus: A Case Study",
                            "content": "<p>The Pegasus spyware, attributed to the NSO Group, is the canonical example of APT mobile malware. It is known for using 0-day, zero-click exploits in common applications (like iMessage or WhatsApp) to gain initial access. Once on the device, it uses another 0-day kernel exploit to jailbreak the device in memory and gain root access. It then has the ability to exfiltrate nearly all data from the device. Analyzing this type of threat requires the most advanced reverse engineering skills.</p>",
                            "image": "https://images.unsplash.com/photo-1614064548237-02f8f17374b2?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "The use of a 'zero-click' 0-day exploit is a hallmark of what kind of threat actor?", "options": ["A common adware author", "A sophisticated, nation-state level APT group", "A low-skilled attacker", "A hacktivist"], "correct": 1, "explanation": "These types of exploits are extremely rare, valuable, and difficult to develop, and their use is typically reserved for the highest-value targets by the most well-resourced adversaries." }
                    ]
                }
            },
            {
                "id": "lesson-22-zero-day-exploit-analysis",
                "title": "Lesson 22: Zero-Day Exploit Analysis",
                "duration": "180 min",
                "objectives": [
                    "Understand the methodologies of vulnerability research for finding 0-day flaws",
                    "Analyze the components of an exploit chain (e.g., remote code execution + local privilege escalation)",
                    "Explore the integration of browser exploits in mobile malware"
                ],
                "content": {
                    "overview": "This expert-level lesson provides a high-level overview of the highly specialized field of mobile vulnerability research and exploit development. We will deconstruct how researchers find and chain vulnerabilities to achieve a full device compromise.",
                    "sections": [
                        {
                            "title": "The Exploit Chain",
                            "content": "<p>A full, remote compromise of a modern mobile device is almost never a single exploit. It is a 'chain' of multiple exploits used in sequence.</p><h3>A Common Chain:</h3><ol><li><strong>Remote Code Execution (RCE) in a sandboxed process:</strong> This is the initial entry point. An attacker finds a memory corruption bug in the browser's rendering engine or a media parsing library. They trigger this bug with a specially crafted webpage or file, allowing them to run their code, but only within the very restrictive sandbox of that process.</li><li><strong>Local Privilege Escalation (LPE) to kernel:</strong> The initial RCE payload then executes a *second* exploit, this one targeting a vulnerability in the operating system's kernel. A successful kernel exploit allows the attacker to break out of the sandbox and gain full root/kernel level privileges, giving them complete control of the device.</li></ol>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "To remotely compromise a fully patched, modern mobile device, an attacker typically needs what?", "options": ["The user's password", "Physical access to the device", "A single, powerful exploit", "A chain of multiple, undiscovered (0-day) vulnerabilities"], "correct": 3, "explanation": "The defense-in-depth of modern mobile OSes means that a single bug is usually not enough. Attackers need to chain together a remote code execution bug with a privilege escalation bug to achieve a full compromise." }
                    ]
                }
            },
            {
                "id": "lesson-23-supply-chain-attacks",
                "title": "Lesson 23: Mobile Supply Chain Attacks",
                "duration": "120 min",
                "objectives": [
                    "Analyze how a compromised third-party SDK can lead to a widespread infection",
                    "Understand the risks of a compromised developer toolchain (e.g., XcodeGhost)",
                    "Assess the security of an application's update mechanism"
                ],
                "content": {
                    "overview": "In a supply chain attack, the adversary doesn't attack you directly; they attack one of your trusted vendors or components. This lesson explores how these attacks manifest in the mobile ecosystem, where a single compromised developer tool or SDK can infect thousands of legitimate apps.",
                    "sections": [
                        {
                            "title": "SDK Trojanization and XcodeGhost",
                            "content": "<ul><li><strong>Trojanized SDK:</strong> A common attack vector. An attacker creates or compromises a popular third-party library or Software Development Kit (SDK) (e.g., an advertising SDK). Legitimate developers unknowingly include this malicious SDK in their own apps. When these apps are published to the official app stores, they now contain the attacker's backdoor.</li><li><strong>XcodeGhost Case Study:</strong> A famous real-world example. Attackers created a trojanized version of Apple's Xcode (the official developer tool) and uploaded it to third-party file-sharing sites. Developers in China, seeking a faster download, used this malicious version of Xcode. The trojanized tool secretly injected malicious code into every app that was compiled with it. This led to hundreds of legitimate, popular apps in the App Store being infected with malware.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1518770660439-4636190af475?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What was the XcodeGhost attack?", "options": ["An attack on Apple's servers", "An attack where developers were tricked into using a malicious version of Xcode, which then injected malware into their legitimate applications", "A vulnerability in the Swift language", "A new type of iPhone"], "correct": 1, "explanation": "XcodeGhost is the canonical example of a developer toolchain supply chain attack, highlighting the importance of verifying the integrity of your development tools." }
                    ]
                }
            },
            {
                "id": "lesson-24-rootkit-bootkit",
                "title": "Lesson 24: Rootkit and Bootkit Analysis",
                "duration": "180 min",
                "objectives": [
                    "Understand the mechanics of mobile rootkits that hook the OS kernel",
                    "Analyze how a bootkit can compromise the bootloader for ultimate persistence",
                    "Recognize the difficulty of detecting and removing firmware-level infections"
                ],
                "content": {
                    "overview": "This expert-level lesson covers the most persistent and stealthy categories of malware. A rootkit modifies the core of the operating system to hide its presence, while a bootkit infects the earliest stages of the boot process to survive even a factory reset. Analysis of these threats requires the deepest reverse engineering skills.",
                    "sections": [
                        {
                            "title": "Kernel-mode Rootkits",
                            "content": "<p>A user-mode process can be easily seen by tools like `ps`. A kernel-mode rootkit, however, operates at the same privilege level as the OS itself. It can hook low-level system functions. For example, it can hook the function that lists processes. When another process calls this function, the rootkit's code runs first, filters out its own process name from the list, and then passes the sanitized list back to the caller. From the user's perspective, the malicious process is completely invisible. Detecting these requires memory forensics or an analysis of the kernel itself.</p>",
                            "image": "https://images.unsplash.com/photo-1629654297299-c8506221ca97?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary function of a kernel-mode rootkit?", "options": ["To steal passwords", "To modify the core of the operating system to hide the malware's presence (its files, processes, and network connections)", "To encrypt files", "To show advertisements"], "correct": 1, "explanation": "The goal of a rootkit is stealth and persistence. By hooking the kernel, it can lie to the user and to other security tools, making itself invisible." }
                    ]
                }
            },
            {
                "id": "lesson-25-dynamic-instrumentation",
                "title": "Lesson 25: Dynamic Instrumentation with Frida - Advanced",
                "duration": "120 min",
                "objectives": [
                    "Master advanced Frida techniques for deep application analysis",
                    "Trace specific threads and understand their behavior",
                    "Manipulate object instances on the heap",
                    "Directly call an application's internal methods from the Frida REPL"
                ],
                "content": {
                    "overview": "This lesson goes beyond simple hooking to explore the advanced capabilities of Frida. You will learn how to interact with an application in even more powerful ways, such as creating new object instances and calling methods on them directly, effectively turning the Frida console into a powerful development and testing tool for the target application.",
                    "sections": [
                        {
                            "title": "Direct Method Invocation",
                            "content": "<p>Frida allows you to not only hook existing methods, but to get a handle on a class and call its methods directly from your script. This is incredibly powerful for testing internal logic that might not be exposed through the UI.</p>",
                            "image": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Calling an Internal Method with Frida",
                        "language": "javascript",
                        "code": "// This script gets a reference to the 'CryptoUtil' class, creates a new instance of it,\n// and then directly calls its 'decryptData:' method with our own data.\n\nJava.perform(function() {\n    const CryptoUtil = Java.use('com.example.app.CryptoUtil');\n    const instance = CryptoUtil.$new();\n    const dataToDecrypt = ...; // The encrypted data we captured\n    \n    const plaintext = instance.decryptData(dataToDecrypt);\n    console.log(\"[+] Decrypted data: \" + plaintext);\n});"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Frida's ability to create new class instances and call their methods directly is useful for what?", "options": ["Deleting the application", "Testing internal, non-UI-exposed application logic and accessing functions that a normal user cannot", "Making the application larger", "Improving the application's performance"], "correct": 1, "explanation": "This allows a tester to go beyond just the user-facing functionality and perform a deep, white-box style assessment of the application's internal APIs and logic at runtime." }
                    ]
                }
            },
            {
                "id": "lesson-26-api-monitoring",
                "title": "Lesson 26: API Monitoring and Hooking",
                "duration": "120 min",
                "objectives": [
                    "Systematically trace all calls to privacy-sensitive system APIs",
                    "Monitor framework-level API calls to understand an application's behavior",
                    "Develop custom API hooks to extract contextual data during analysis",
                    "Recognize behavioral patterns based on sequences of API calls"
                ],
                "content": {
                    "overview": "Every action an application takes, from sending a network request to reading a contact, involves calling a system or framework API. This lesson focuses on the systematic monitoring and hooking of these API calls to build a high-fidelity picture of the malware's behavior.",
                    "sections": [
                        {
                            "title": "System API Call Tracing",
                            "content": "<p>A key analysis technique is to use Frida to trace every call to a specific, privacy-sensitive API. This allows you to confirm if and when malware is accessing sensitive data.</p><h3>Example Use Case: Contact Theft</h3><p>Static analysis of a malware sample's manifest might show that it requests the `READ_CONTACTS` permission. To confirm if it actually uses this permission, you can write a Frida script to hook the `ContentResolver.query()` method, which is the standard API used to access the contacts database. Your script can log a message every time this method is called, along with the arguments it was called with. This provides definitive proof that the malware is actively stealing contact information.</p>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Frida Script to Trace Contact Queries",
                        "language": "javascript",
                        "code": "/* This script hooks the ContentResolver's query method and specifically looks for queries made to the contacts content provider URI. */\n\nJava.perform(function() {\n    const ContentResolver = Java.use('android.content.ContentResolver');\n    ContentResolver.query.overload('android.net.Uri', '[Ljava.lang.String;', 'java.lang.String', '[Ljava.lang.String;', 'java.lang.String').implementation = function(uri, projection, selection, selectionArgs, sortOrder) {\n        \n        const uriString = uri.toString();\n        if (uriString.startsWith('content://com.android.contacts')) {\n            console.log(`[+] DETECTED CONTACTS QUERY! URI: ${uriString}`);\n            // You can also log the projection, selection, etc. here\n        }\n\n        // Call the original method to avoid breaking the app\n        return this.query(uri, projection, selection, selectionArgs, sortOrder);\n    };\n});"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary benefit of hooking system APIs during dynamic malware analysis?", "options": ["It makes the malware run faster", "It provides a definitive, ground-truth observation of exactly what sensitive data and features the malware is accessing", "It fixes the vulnerabilities in the malware", "It is not a useful technique"], "correct": 1, "explanation": "While static analysis can show that a permission is requested, only dynamic analysis and API hooking can prove that the malicious functionality is actually being used by the running code." }
                    ]
                }
            },
            {
                "id": "lesson-27-memory-analysis",
                "title": "Lesson 27: Memory Analysis Techniques",
                "duration": "180 min",
                "objectives": [
                    "Understand how to acquire a memory dump of an application process or the full OS",
                    "Use tools like Fridump to dump an app's process memory",
                    "Analyze a memory dump to extract strings, encryption keys, and other artifacts",
                    "Recognize the importance of memory analysis for packed malware"
                ],
                "content": {
                    "overview": "Sometimes, the most critical evidence exists only in the application's memory. This advanced lesson covers the techniques for acquiring and analyzing a memory dump from a running Android process. This is particularly important for dealing with malware that uses packing or other in-memory-only techniques.",
                    "sections": [
                        {
                            "title": "Memory Dumping and String Extraction",
                            "content": "<p>You can use a tool like Fridump to attach to a running process on a rooted device and dump its entire memory space to a set of files on your analysis machine. One of the simplest and most effective next steps is to run the `strings` command-line utility against these memory dumps. This will extract all human-readable text. It's a surprisingly effective way to find sensitive information that was briefly in memory, such as decrypted C2 communication, configuration data, or even encryption keys.</p>",
                            "image": "https://images.unsplash.com/photo-1555099962-4199c345e541?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Finding Unpacked Payloads",
                            "content": "<p>For packed malware, the real DEX payload is decrypted and loaded in memory. After running the malware for a few seconds to let it unpack, you can dump its memory. You can then search through the memory dump for the DEX file header (`dex.035`). If you find it, you can carve out the unpacked DEX file from the memory dump, and then run your static analysis tools (like `dex2jar` and `Jadx`) on this clean, unpacked version. This is the standard workflow for defeating packers.</p>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "For a packed malware sample, where does the real malicious code reside?", "options": ["In the manifest file", "Encrypted in the original APK and then decrypted and loaded into memory at runtime", "It is downloaded from the internet after installation", "In the resources directory"], "correct": 1, "explanation": "Packing is an anti-analysis technique specifically designed to defeat static analysis. The analyst must run the malware and dump the unpacked payload from the process's memory to analyze it." }
                    ]
                }
            },
            {
                "id": "lesson-28-automated-behavior-analysis",
                "title": "Lesson 28: Automated Behavior Analysis",
                "duration": "120 min",
                "objectives": [
                    "Understand the architecture of an automated mobile sandbox",
                    "Create an environment for automated analysis (e.g., using MobSF or a custom setup)",
                    "Automatically execute and collect behavioral indicators from malware",
                    "Understand the role of ML in classifying malware behavior"
                ],
                "content": {
                    "overview": "Manual dynamic analysis is thorough but slow. An automated sandbox allows an analyst to detonate and get a high-level behavioral report on a sample in minutes. This lesson covers the architecture and use of automated sandbox environments for rapid malware triage.",
                    "sections": [
                        {
                            "title": "Sandbox Architecture",
                            "content": "<p>A mobile analysis sandbox is an automated system that:</p><ol><li>Takes an APK as input.</li><li>Spins up a clean, instrumented emulator instance.</li><li>Installs and runs the APK.</li><li>Simulates user interaction (clicking buttons, entering text) to try and trigger malicious behavior.</li><li>Monitors everything the app does: network traffic, file system access, API calls, etc.</li><li>Collects all these logs and generates a comprehensive report.</li><li>Destroys the emulator instance.</li></ol><p>The Dynamic Analyzer in MobSF provides this functionality in an open-source package.</p>",
                            "image": "https://images.unsplash.com/photo-1498050108023-c5249f4df085?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary benefit of using an automated sandbox for malware analysis?", "options": ["It provides the most in-depth analysis possible", "It allows for the rapid, automated triage of a large number of samples to get a high-level summary of their behavior", "It is the best tool for analyzing obfuscated code", "It is only used for static analysis"], "correct": 1, "explanation": "Automation is key for handling the sheer volume of malware. A sandbox provides the initial, fast analysis, allowing a human analyst to then focus their deep-dive efforts on the most interesting and sophisticated samples." }
                    ]
                }
            },
            {
                "id": "lesson-29-c2-analysis",
                "title": "Lesson 29: Command and Control Analysis",
                "duration": "150 min",
                "objectives": [
                    "Identify the malware's Command and Control (C2) servers from network traffic and code",
                    "Reverse engineer custom C2 communication protocols",
                    "Analyze Domain Generation Algorithms (DGAs)",
                    "Use threat intelligence to enrich findings about C2 infrastructure"
                ],
                "content": {
                    "overview": "Almost all sophisticated malware relies on a Command and Control (C2) server to receive instructions and exfiltrate data. This advanced lesson is a deep dive into the analysis of this C2 communication, which is often the key to understanding and defeating a malware campaign.",
                    "sections": [
                        {
                            "title": "Domain Generation Algorithms (DGAs)",
                            "content": "<p>Instead of hard-coding a single C2 domain (which can be easily blocked), some malware uses a Domain Generation Algorithm (DGA). The DGA is a piece of code that generates thousands of different, pseudo-random domain names every day based on a shared secret (the 'seed') and the current date. The attacker only has to register one of these thousands of domains for the malware to be able to connect. Analyzing network traffic from a host that is making DNS requests for hundreds of different, long, random-looking domains that are all NXDOMAIN (non-existent) is a high-fidelity indicator of a DGA in action.</p>",
                            "image": "https://images.unsplash.com/photo-1585149420381-f13a0429a1b4?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Protocol Reverse Engineering",
                            "content": "<p>Malware often uses a custom binary protocol to communicate with its C2 server. An analyst must reverse engineer this protocol. This is a painstaking process of:</p><ol><li>Capturing the traffic with a tool like Wireshark.</li><li>Analyzing the malware's networking code in a decompiler to understand how the messages are constructed.</li><li>Slowly mapping out the different fields in the protocol (e.g., 'the first 4 bytes are the length, the next byte is the command ID').</li><li>Once the protocol is understood, you can write your own client to interact with the C2 server, or write a network signature to detect it.</li></ol>",
                            "image": "https://images.unsplash.com/photo-1544890225-2fde1e46f71b?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the purpose of a Domain Generation Algorithm (DGA)?", "options": ["To make DNS requests faster", "To make the C2 infrastructure resilient to take-downs by generating a huge number of potential domains each day", "To register new domains for the attacker", "To steal user data"], "correct": 1, "explanation": "DGAs are a common technique used by botnets to make it very difficult for defenders to block their command and control communications by simply blacklisting a single domain." }
                    ]
                }
            },
            {
                "id": "lesson-30-data-exfiltration",
                "title": "Lesson 30: Data Exfiltration Analysis",
                "duration": "120 min",
                "objectives": [
                    "Identify common and covert data exfiltration channels",
                    "Analyze how malware uses encoding, compression, and steganography to hide stolen data",
                    "Use dynamic analysis to determine exactly what data is being stolen"
                ],
                "content": {
                    "overview": "Once spyware has collected sensitive data, it needs to send it back to the attacker. This lesson focuses on the various techniques that malware uses to exfiltrate this stolen data and how an analyst can detect and decode it.",
                    "sections": [
                        {
                            "title": "Exfiltration Channels",
                            "content": "<ul><li><strong>HTTP/S POST:</strong> The most common method. The malware packages the stolen data (e.g., as a JSON or XML file), compresses it, encrypts it, and then sends it to the C2 server in the body of an HTTP POST request.</li><li><strong>DNS Tunneling:</strong> A very stealthy technique. The malware Base64-encodes a chunk of the stolen data and places it as a subdomain in a DNS query to a domain controlled by the attacker (e.g., `[encoded_data].attacker.com`). This is hard to detect because DNS traffic is allowed out of almost every network.</li><li><strong>Steganography:</strong> The malware might hide the stolen data within a seemingly legitimate image file that it uploads to a public image sharing website.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1599373922312-5b9340d8a5a5?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Why would malware use a technique like DNS tunneling for data exfiltration?", "options": ["It is the fastest way to send data", "Because DNS traffic is almost never blocked, making it a very effective and stealthy covert channel for bypassing firewall egress rules", "It can only send a small amount of data", "DNS is unencrypted"], "correct": 1, "explanation": "Exploiting commonly allowed protocols like DNS is a classic technique for building a covert channel in a highly restricted network environment." }
                    ]
                }
            },
            {
                "id": "lesson-31-sms-call-interception",
                "title": "Lesson 31: SMS and Call Interception Analysis",
                "duration": "120 min",
                "objectives": [
                    "Reverse engineer malware that can intercept incoming SMS messages",
                    "Analyze call recording and call forwarding malware",
                    "Understand how malware abuses USSD codes for financial fraud"
                ],
                "content": {
                    "overview": "Banking trojans and spyware often need to intercept SMS messages to defeat two-factor authentication based on one-time passwords. This lesson covers how to analyze the specific techniques malware uses to hijack a user's communications.",
                    "sections": [
                        {
                            "title": "SMS Hijacking",
                            "content": "<p>An Android app with the `RECEIVE_SMS` permission can register a Broadcast Receiver with a high priority. When an SMS arrives, the malware's receiver gets it first. It can read the contents (looking for OTPs), send the OTP to its C2 server, and then even 'abort' the broadcast, preventing the legitimate SMS app from ever seeing the message at all. Analyzing the manifest for this receiver and the code for the abort broadcast call is key.</p>",
                            "image": "https://images.unsplash.com/photo-1584433144853-6d3c470876d2?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary motivation for a banking trojan to intercept a user's SMS messages?", "options": ["To read their personal conversations", "To steal the two-factor authentication One-Time Passwords (OTPs) that are sent via SMS", "To send spam", "To delete the messages"], "correct": 1, "explanation": "SMS interception is a key part of the attack chain for defeating 2FA and successfully completing a fraudulent transaction." }
                    ]
                }
            },
            {
                "id": "lesson-32-bluetooth-wifi",
                "title": "Lesson 32: Bluetooth and WiFi Exploitation Analysis",
                "duration": "120 min",
                "objectives": [
                    "Understand how malware can abuse Bluetooth and Wi-Fi protocols",
                    "Analyze malware that performs proximity-based attacks",
                    "Recognize the risks of insecure wireless communication"
                ],
                "content": {
                    "overview": "This lesson explores the attack surface of the wireless radios on a mobile device, covering how malware can abuse Bluetooth and Wi-Fi for C2, data exfiltration, and proximity attacks.",
                    "sections": [
                        {
                            "title": "Proximity-based Attacks",
                            "content": "<p>Sophisticated malware could use Bluetooth Low Energy (BLE) to scan for other nearby infected devices and create a mesh network for communication, or to exfiltrate data to a nearby attacker's laptop. It could also force the device to connect to a malicious Wi-Fi access point controlled by an attacker to facilitate a man-in-the-middle attack. Analysis involves hooking the relevant Bluetooth and Wi-Fi APIs to understand how the malware is interacting with these radios.</p>",
                            "image": "https://images.unsplash.com/photo-1544228943-8588824f19b2?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary risk of malware that can control a device's Wi-Fi connection?", "options": ["It can drain the battery", "It can force the device to connect to a rogue, attacker-controlled Wi-Fi access point, enabling a man-in-the-middle attack", "It can increase the Wi-Fi speed", "It is not a risk"], "correct": 1, "explanation": "Controlling the device's network connection is a powerful capability that allows an attacker to direct all traffic through their own malicious infrastructure for sniffing or manipulation." }
                    ]
                }
            },
            {
                "id": "lesson-33-enterprise-malware-analysis",
                "title": "Lesson 33: Enterprise Malware Analysis",
                "duration": "120 min",
                "objectives": [
                    "Analyze malware that specifically targets enterprise users",
                    "Test for MDM bypass and policy evasion techniques",
                    "Understand how malware exploits compromised VPN and email clients to pivot into the corporate network"
                ],
                "content": {
                    "overview": "This lesson focuses on the analysis of malware that specifically targets enterprise users and environments. The goals of this malware are often different, focusing on corporate espionage and lateral movement rather than simple financial fraud.",
                    "sections": [
                        {
                            "title": "Pivoting via VPN",
                            "content": "<p>A key target for enterprise malware is the corporate VPN client. If the malware can run on the device while the user is connected to the corporate VPN, the malware now has a foothold inside the corporate network perimeter. It can begin scanning and attacking internal servers that are not exposed to the public internet. Analysis of this malware involves using Frida to inspect its network calls to see if it is attempting to connect to internal, non-routable IP address ranges.</p>",
                            "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary goal of enterprise-focused mobile malware?", "options": ["To steal personal photos", "To act as a beachhead to gain access into the trusted corporate network", "To show advertisements", "To mine cryptocurrency"], "correct": 1, "explanation": "A compromised mobile device, especially one with a VPN connection, can be a powerful pivot point for an attacker to launch attacks against the internal enterprise network." }
                    ]
                }
            },
            {
                "id": "lesson-34-byod-threats",
                "title": "Lesson 34: BYOD Security Threats",
                "duration": "120 min",
                "objectives": [
                    "Analyze threats that attempt to steal corporate data from BYOD devices",
                    "Understand and test for bypasses of containerization ('app wrapping') solutions",
                    "Detect 'shadow IT' and unauthorized applications on enterprise devices"
                ],
                "content": {
                    "overview": "Bring Your Own Device (BYOD) environments create a unique and challenging threat model. This lesson covers the analysis of threats designed to operate in this hybrid environment, focusing on techniques used to steal corporate data by breaking out of the work container.",
                    "sections": [
                        {
                            "title": "Container Bypass",
                            "content": "<p>A sophisticated piece of malware running in the 'personal' profile of a BYOD device might try to find a vulnerability that allows it to bypass the containerization and access data inside the 'work' profile. This could be a vulnerability in the Android OS itself or in the specific MDM client that creates and manages the container. Analyzing these threats requires a deep understanding of the underlying IPC and data sharing mechanisms of the work profile implementation.</p>",
                            "image": "https://images.unsplash.com/photo-1544228943-8588824f19b2?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "The primary goal of malware in a BYOD environment is often to:", "options": ["Make the phone run better", "Find a way to bypass the containerization controls and leak sensitive corporate data from the work profile", "Delete all personal photos", "Install new apps in the personal profile"], "correct": 1, "explanation": "The corporate data inside the work profile is the high-value target for any attacker who has compromised the personal side of a BYOD device." }
                    ]
                }
            },
            {
                "id": "lesson-35-certificate-trust",
                "title": "Lesson 35: Certificate and Trust Abuse",
                "duration": "120 min",
                "objectives": [
                    "Understand how malware can manipulate a device's trust store",
                    "Analyze malware that installs a rogue root CA certificate",
                    "Detect and respond to large-scale man-in-the-middle attacks"
                ],
                "content": {
                    "overview": "This lesson covers a very powerful technique that some advanced malware uses: compromising the device's root of trust for network connections by installing a rogue root CA certificate. This allows the attacker to transparently man-in-the-middle all TLS traffic from the device.",
                    "sections": [
                        {
                            "title": "Root Certificate Installation",
                            "content": "<p>If malware can trick a user into installing a malicious root CA certificate (often through a social engineering lure), the device will now trust *any* certificate that has been signed by that rogue CA. This means an attacker can intercept all HTTPS traffic from the device's browser and other applications without triggering any certificate warnings. The 'lock' icon will still appear. Analyzing a device's trusted certificate store for any non-standard, third-party root CAs is a critical step in a forensic investigation.</p>",
                            "image": "https://images.unsplash.com/photo-1599373922312-5b9340d8a5a5?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary impact of an attacker tricking a user into installing a malicious root CA certificate?", "options": ["It has no impact", "The attacker can now perform a man-in-the-middle attack on all HTTPS traffic from the device without the user receiving any security warnings", "It encrypts the device", "It makes the device faster"], "correct": 1, "explanation": "Compromising the root trust store fundamentally breaks the entire security model of TLS/HTTPS for that device." }
                    ]
                }
            },
            {
                "id": "lesson-36-mobile-payment-fraud",
                "title": "Lesson 36: Mobile Payment Fraud",
                "duration": "120 min",
                "objectives": [
                    "Analyze malware that abuses mobile payment systems",
                    "Understand the security risks of NFC and contactless payments",
                    "Investigate compromises of digital wallets and cryptocurrency apps"
                ],
                "content": {
                    "overview": "As mobile phones become our primary wallets, they also become a major target for financial fraud. This lesson covers the analysis of malware that specifically targets mobile payment systems.",
                    "sections": [
                        {
                            "title": "NFC Attack Techniques",
                            "content": "<p>Near-Field Communication (NFC) is the technology behind tap-to-pay. While the underlying protocols are secure, malware could potentially try to abuse NFC functionality, for example by trying to initiate a payment transaction without the user's consent if the phone is unlocked. More commonly, the threat is at the Point of Sale (POS) terminal. If the POS terminal itself is compromised, it could potentially try to exploit a vulnerability in the phone's NFC stack.</p>",
                            "image": "https://images.unsplash.com/photo-1556741533-4020f1b29a28?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "A primary focus for analyzing mobile payment malware is:", "options": ["The application's icon", "The security of how cryptographic keys and tokens are stored and used", "The speed of the transaction", "The brand of the phone"], "correct": 1, "explanation": "The security of these systems almost always comes down to the secure, hardware-backed storage of the cryptographic secrets used to authorize payments." }
                    ]
                }
            },
            {
                "id": "lesson-37-iot-malware-analysis",
                "title": "Lesson 37: IoT Malware Analysis",
                "duration": "120 min",
                "objectives": [
                    "Analyze malware designed to compromise embedded and IoT devices",
                    "Understand how mobile devices can be used as a vector to attack IoT devices",
                    "Reverse engineer firmware to find malware"
                ],
                "content": {
                    "overview": "The world of IoT (Internet of Things) is the new wild west of security. Many of these devices are Linux-based, and this lesson explores how they are targeted by malware, often with the goal of adding them to a massive botnet.",
                    "sections": [
                        {
                            "title": "The Mirai Botnet: A Case Study",
                            "content": "<p>Mirai is a famous piece of IoT malware that works by constantly scanning the internet for IoT devices (like routers and cameras) that are still using their factory-default username and password. When it finds one, it logs in, infects the device, and adds it to its botnet. These millions of compromised devices can then be used to launch some of the largest DDoS attacks ever seen. Analyzing this malware involves understanding its scanning techniques and its C2 protocol.</p>",
                            "image": "https://images.unsplash.com/photo-1544890225-2fde1e46f71b?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "The Mirai malware primarily infects IoT devices by:", "options": ["Using a 0-day exploit", "Brute-forcing their Telnet/SSH passwords, with a focus on common default credentials", "A phishing email", "A hardware vulnerability"], "correct": 1, "explanation": "Mirai's incredible success was due to the simple and widespread failure of users and manufacturers to change default credentials, a classic security misconfiguration." }
                    ]
                }
            },
            {
                "id": "lesson-38-wearable-malware",
                "title": "Lesson 38: Wearable Device Threats",
                "duration": "120 min",
                "objectives": [
                    "Analyze malware targeting smartwatches and other wearable devices",
                    "Understand the privacy risks of health and fitness data theft",
                    "Assess the security of biometric data collected by wearables"
                ],
                "content": {
                    "overview": "Wearable devices collect some of our most personal and intimate data. This lesson covers the analysis of malware that specifically targets these devices, often with the goal of stealing this highly sensitive health and biometric information.",
                    "sections": [
                        {
                            "title": "Health Data Theft",
                            "content": "<p>Malware on a paired phone might try to find a vulnerability that allows it to abuse the synchronization process with a wearable to steal the health and location data stored on it. Analysis involves monitoring the Bluetooth traffic between the phone and the watch, and reversing the companion app on the phone to see how it stores and processes the wearable's data.</p>",
                            "image": "https://images.unsplash.com/photo-1538692125883-909953930b5e?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary target for an attacker compromising a fitness tracker?", "options": ["The device's CPU", "The user's personal health and location data", "The device's battery", "The ability to change the watch face"], "correct": 1, "explanation": "This sensitive, personal data is highly valuable and protected by regulations like HIPAA in many contexts." }
                    ]
                }
            },
            {
                "id": "lesson-39-automotive-threats",
                "title": "Lesson 39: Automotive Mobile Threats",
                "duration": "120 min",
                "objectives": [
                    "Analyze malware that can interact with a connected car's systems",
                    "Understand how a compromised mobile phone can be a vector for attacking a car",
                    "Reverse engineer the APIs used by a car's mobile companion app"
                ],
                "content": {
                    "overview": "Modern cars are deeply integrated with our mobile phones. This lesson explores the threat model where a compromised mobile device is used to attack a connected vehicle. The focus is often on the car's official mobile companion app.",
                    "sections": [
                        {
                            "title": "Companion App Analysis",
                            "content": "<p>Many cars have an app that lets you remotely lock/unlock the doors, start the car, and see its location. Analyzing the security of this app is critical. An attacker who can find a vulnerability in this app, or who can compromise the user's account for this app, could potentially steal the car or track its movements. The analysis focuses on the security of the APIs that the companion app uses to communicate with the car manufacturer's backend servers.</p>",
                            "image": "https://images.unsplash.com/photo-1549399542-7e692a716530?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is a primary attack vector for a remote attack on a modern connected car?", "options": ["The car's tires", "The mobile companion app and the backend APIs it communicates with", "The car's radio antenna", "The windshield wipers"], "correct": 1, "explanation": "The companion app and its APIs provide a direct, remote interface to the car's systems, making them a critical and high-value target for a security assessment." }
                    ]
                }
            },
            {
                "id": "lesson-40-smart-home-threats",
                "title": "Lesson 40: Smart Home Integration Threats",
                "duration": "120 min",
                "objectives": [
                    "Analyze malware that targets smart home hubs and devices",
                    "Understand how a compromised phone can be used to attack smart locks, cameras, and microphones",
                    "Assess the security of the mobile apps used to manage smart home devices"
                ],
                "content": {
                    "overview": "This lesson covers the analysis of malware that targets the smart home, where a compromised mobile phone can become the master key to a person's entire physical environment.",
                    "sections": [
                        {
                            "title": "The Mobile Hub",
                            "content": "<p>A user's mobile phone is often the central 'hub' for managing all their smart home devices. It contains the apps and credentials to control their smart locks, view their security cameras, and listen to their smart speakers. Malware that compromises the phone and can gain access to the data from these smart home companion apps can lead to a catastrophic invasion of privacy and even a physical security risk. Analysis involves testing these companion apps for insecure data storage and other common mobile vulnerabilities.</p>",
                            "image": "https://images.unsplash.com/photo-1593784959329-3a36c8da6375?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "From a security perspective, a mobile phone that is used to control a person's smart lock is a:", "options": ["A low-risk device", "A critical, high-value target", "A device that cannot be secured", "A device with no sensitive data"], "correct": 1, "explanation": "The phone effectively becomes the key to the person's house, making the security of both the phone and the smart lock's companion app absolutely critical." }
                    ]
                }
            },
            {
                "id": "lesson-41-mobile-forensics",
                "title": "Lesson 41: Mobile Forensic Acquisition",
                "duration": "120 min",
                "objectives": [
                    "Perform logical and physical acquisitions of mobile devices",
                    "Use forensic tools to bypass passcodes and extract data",
                    "Recover deleted data from mobile file systems",
                    "Understand the legal and technical challenges of cloud data recovery"
                ],
                "content": {
                    "overview": "This lesson provides an introduction to the highly specialized field of mobile forensics. We will cover the techniques used by law enforcement and incident responders to extract data from mobile devices as part of an investigation.",
                    "sections": [
                        {
                            "title": "Logical vs. Physical Acquisition",
                            "content": "<ul><li><strong>Logical Acquisition:</strong> This is an acquisition of the files and data that are accessible through the normal OS APIs. A simple iTunes backup of an iPhone is a form of logical acquisition. It gets a lot of data, but it misses deleted files and other low-level artifacts.</li><li><strong>Physical Acquisition:</strong> This is a bit-for-bit copy of the device's raw flash memory. This is the gold standard as it allows for the recovery of deleted files and provides the most complete set of evidence. However, performing a physical acquisition on a modern, encrypted smartphone is extremely difficult and often requires specialized and expensive forensic tools that can exploit hardware-level vulnerabilities.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1593110022831-292911b3b194?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "To recover deleted SMS messages from a mobile device, a forensic investigator would need to perform what type of acquisition?", "options": ["A logical acquisition", "A physical acquisition", "Neither, it is impossible", "A screenshot of the screen"], "correct": 1, "explanation": "A physical acquisition is the only method that provides access to the unallocated space in the device's file system where the remnants of deleted data may reside." }
                    ]
                }
            },
            {
                "id": "lesson-42-timeline-reconstruction",
                "title": "Lesson 42: Forensic Timeline Reconstruction",
                "duration": "120 min",
                "objectives": [
                    "Use mobile forensic tools to build a detailed event timeline",
                    "Correlate artifacts from different sources (logs, files, databases) to reconstruct user activity",
                    "Identify the infection vector and the initial point of compromise"
                ],
                "content": {
                    "overview": "With all the evidence extracted, the next step is to tell the story. This lesson covers how to use the timestamps from all the different artifacts on a mobile device to build a comprehensive, second-by-second timeline of the malware's activity and the user's actions.",
                    "sections": [
                        {
                            "title": "Correlating Artifacts",
                            "content": "<p>A forensic suite (like Cellebrite or Magnet AXIOM) will automatically parse all the different artifacts from an acquisitionâ€”SMS messages, call logs, browser history, application databases, location dataâ€”and combine them into a single, searchable, chronological timeline. An analyst can then filter and search this timeline to answer key questions and reconstruct the incident from start to finish.</p>",
                            "image": "https://images.unsplash.com/photo-1542438408-abb2021e1837?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary purpose of timeline reconstruction in a mobile forensic investigation?", "options": ["To check the device's time", "To arrange all the disparate pieces of evidence into a single chronological narrative to understand the sequence of events", "To delete the evidence", "To find the user's password"], "correct": 1, "explanation": "The timeline is the primary tool an investigator uses to tell the story of what happened on the device." }
                    ]
                }
            },
            {
                "id": "lesson-43-attribution-threat-intel",
                "title": "Lesson 43: Attribution and Threat Intelligence",
                "duration": "120 min",
                "objectives": [
                    "Use code similarity analysis and infrastructure correlation to help attribute malware",
                    "Understand the challenges and limitations of malware attribution",
                    "Leverage threat intelligence to connect a sample to a known threat actor"
                ],
                "content": {
                    "overview": "This advanced lesson explores the challenging but important process of attributionâ€”the attempt to link a piece of malware to a specific threat actor or group. We will focus on the technical indicators that can provide clues about a malware's origin.",
                    "sections": [
                        {
                            "title": "Attribution Techniques",
                            "content": "<p>Attribution is rarely based on a single data point. It is a conclusion based on a preponderance of evidence.</p><ul><li><strong>Code Similarity:</strong> Does the malware reuse code or share a similar structure to other known malware samples from a specific group?</li><li><strong>Infrastructure Overlap:</strong> Does the C2 server's IP address or domain registration information overlap with infrastructure used in past campaigns by a known actor?</li><li><strong>TTPs:</strong> Do the Tactics, Techniques, and Procedures (TTPs) used by the malware align with the known playbook of a specific APT group?</li></ul>",
                            "image": "https://images.unsplash.com/photo-1563905788977-62b714f520b2?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Is attribution an exact science?", "options": ["Yes, it is always 100% certain", "No, it is a complex process of building a case based on multiple pieces of technical evidence, and it often only leads to a 'low' or 'medium' confidence assessment"], "correct": 1, "explanation": "Attribution is one of the hardest problems in threat intelligence. Sophisticated actors often use false flags and misdirection to deliberately thwart it." }
                    ]
                }
            },
            {
                "id": "lesson-44-legal-compliance",
                "title": "Lesson 44: Legal and Compliance Considerations",
                "duration": "120 min",
                "objectives": [
                    "Follow forensically sound evidence handling procedures",
                    "Maintain a meticulous chain of custody for all evidence",
                    "Understand the legal standards for evidence admissibility in court"
                ],
                "content": {
                    "overview": "A malware analysis that is part of a criminal or corporate investigation must be conducted in a way that is legally defensible. This lesson revisits the core forensic principles of evidence handling and the chain of custody in the context of mobile malware analysis.",
                    "sections": [
                        {
                            "title": "Chain of Custody",
                            "content": "<p>The chain of custody is the single most important document for any forensic work. It is a formal record that shows the complete, unbroken history of the evidence, from the moment it was collected to the moment it is presented. A broken chain of custody can make all of your technical work inadmissible in a legal proceeding.</p>",
                            "image": "https://images.unsplash.com/photo-1589216532372-1c2a3679003a?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary purpose of a chain of custody document?", "options": ["To track the time spent on an analysis", "To provide a verifiable, legal record of who had control over a piece of evidence at all times, proving its integrity", "To store the password for the evidence locker", "To document the malware's functions"], "correct": 1, "explanation": "This is a foundational concept. The chain of custody is what gives your evidence legal standing." }
                    ]
                }
            },
            {
                "id": "lesson-45-mobile-malware-detection",
                "title": "Lesson 45: Mobile Malware Detection",
                "duration": "120 min",
                "objectives": [
                    "Understand how signature-based and heuristic-based antivirus engines work",
                    "Explore how behavioral detection can find previously unknown malware",
                    "Discuss the role of machine learning in modern mobile threat defense"
                ],
                "content": {
                    "overview": "This lesson switches to a defensive perspective, exploring the technologies used by mobile antivirus and mobile threat defense (MTD) solutions to detect the kinds of threats we've been analyzing.",
                    "sections": [
                        {
                            "title": "Detection Methods",
                            "content": "<ul><li><strong>Signature-Based:</strong> The classic approach. The scanner has a database of known malware file hashes. It is fast but cannot detect new, unknown malware.</li><li><strong>Heuristic Analysis:</strong> Looks for suspicious characteristics or code patterns (e.g., the use of reflection to hide API calls) that are common in malware.</li><li><strong>Behavioral Detection:</strong> The most modern approach. An on-device agent (or a cloud service) monitors the behavior of applications in real time and looks for anomalous activity (e.g., an app suddenly trying to contact hundreds of IP addresses). This can detect 0-day malware.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1614064548237-02f8f17374b2?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Which detection method is most effective at finding new, previously unknown (0-day) malware?", "options": ["Signature-based detection", "Heuristic analysis", "Behavioral detection and anomaly analysis", "Manual analysis"], "correct": 2, "explanation": "Behavioral detection focuses on what the malware *does*, not what it *is*. Since new malware often still uses the same underlying malicious behaviors (like hooking, code injection, or data exfiltration), a behavioral engine can detect it without a pre-existing signature." }
                    ]
                }
            },
            {
                "id": "lesson-46-security-solution-testing",
                "title": "Lesson 46: Mobile Security Solution Testing",
                "duration": "120 min",
                "objectives": [
                    "Evaluate the effectiveness of mobile antivirus and MTD solutions",
                    "Test for bypasses in enterprise EMM/MDM security controls",
                    "Understand the methodologies for evaluating security tool efficacy"
                ],
                "content": {
                    "overview": "How do you know if the security solutions you've deployed are actually working? This lesson covers the methodologies for testing and evaluating the effectiveness of mobile security products, from antivirus to MDM.",
                    "sections": [
                        {
                            "title": "Efficacy Testing",
                            "content": "<p>You can use your lab environment to test a security solution. Install the antivirus or MTD agent in your emulator. Then, try to infect the emulator with a range of known malware samples (both old and new). Do you get an alert? How quickly? Does the product successfully block the installation or quarantine the malware? For an MDM, you would try to perform actions that the policy should block (like copying data from a managed app) to see if the control can be bypassed. This is an evidence-based approach to selecting and validating security tools.</p>",
                            "image": "https://images.unsplash.com/photo-1542626991-cbc4e32524cc?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "The primary goal of efficacy testing for a mobile security tool is to:", "options": ["Validate the vendor's marketing claims and ensure the tool works as expected in your environment", "Find 0-day vulnerabilities in the tool", "Get a discount on the tool", "Write a positive review"], "correct": 0, "explanation": "You must test your security controls to ensure they are providing the protection you expect. Efficacy testing is a core part of any security tool evaluation process." }
                    ]
                }
            },
            {
                "id": "lesson-47-mobile-incident-response",
                "title": "Lesson 47: Incident Response for Mobile Threats",
                "duration": "120 min",
                "objectives": [
                    "Develop an incident response plan specific to mobile threats",
                    "Use MDM/EMM for rapid device isolation and evidence preservation",
                    "Implement remediation and recovery procedures for a mobile fleet"
                ],
                "content": {
                    "overview": "This lesson adapts the classic incident response lifecycle to the unique challenges of mobile. We will cover how to respond to a widespread mobile malware incident in an enterprise environment, with a focus on using your EMM platform as the primary response tool.",
                    "sections": [
                        {
                            "title": "The Mobile IR Lifecycle",
                            "content": "<ul><li><strong>Detection:</strong> An alert comes from your Mobile Threat Defense solution.</li><li><strong>Analysis:</strong> A malware analyst performs a rapid analysis of the sample.</li><li><strong>Containment:</strong> The primary containment step is to use the EMM platform to 'quarantine' the infected devices, potentially by applying a policy that blocks all network access except to the EMM server itself.</li><li><strong>Eradication:</strong> Once the malware is understood, you can use the EMM to push a command to remotely uninstall the malicious application from all affected devices.</li><li><strong>Recovery:</strong> Monitor the fleet to ensure the eradication was successful.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1517048676732-d65bc937f952?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "In a large enterprise, what is the primary tool used for containment and eradication during a mobile malware incident?", "options": ["Asking each user to uninstall the app", "The EMM/MDM platform", "The company's firewall", "The legal department"], "correct": 1, "explanation": "The EMM is the central command-and-control platform for the mobile fleet, making it the essential tool for large-scale, remote incident response actions." }
                    ]
                }
            },
            {
                "id": "lesson-48-threat-hunting-mobile",
                "title": "Lesson 48: Threat Hunting on Mobile Platforms",
                "duration": "120 min",
                "objectives": [
                    "Apply the threat hunting mindset to mobile environments",
                    "Develop hunting hypotheses based on mobile TTPs",
                    "Use logs from an MTD solution to proactively hunt for threats"
                ],
                "content": {
                    "overview": "Threat hunting isn't just for traditional endpoints. This lesson covers how to apply the proactive threat hunting lifecycle to a fleet of mobile devices, using the rich telemetry from a Mobile Threat Defense solution to hunt for threats that have evaded automated detections.",
                    "sections": [
                        {
                            "title": "Mobile Threat Hunting",
                            "content": "<p>A Mobile Threat Defense (MTD) solution collects a massive amount of telemetry from each device (network connections, process activity, etc.). An analyst can use this data to hunt. For example, an analyst might form a hypothesis: 'An attacker might be trying to exfiltrate my company's contact list via DNS'. The hunter can then query the MTD's data lake to look for any devices that are making an unusually high number of DNS requests to a rare domain, which could be an indicator of DNS tunneling.</p>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the key enabler for threat hunting on mobile platforms?", "options": ["Having a fast device", "Access to a rich set of centralized telemetry from the mobile fleet, typically from an MTD or EMM solution", "Knowing how to program in Swift", "Having a good antivirus"], "correct": 1, "explanation": "Threat hunting is fundamentally a data analysis problem. Without the data, you cannot hunt." }
                    ]
                }
            },
            {
                "id": "lesson-49-advanced-research",
                "title": "Lesson 49: Advanced Research Project",
                "duration": "180 min",
                "objectives": [
                    "Conduct original research on a novel mobile malware technique or a 0-day vulnerability",
                    "Develop a new, custom analysis tool or Frida script",
                    "Write a professional-quality white paper or conference-level presentation on your research"
                ],
                "content": {
                    "overview": "This pre-capstone project allows you to specialize and go deep on a specific area of mobile malware that interests you. You will conduct your own original research and produce a tool or a paper that contributes to the field.",
                    "sections": [
                        {
                            "title": "Project Options",
                            "content": "<p>You will choose one of the following:</p><ul><li><strong>Vulnerability Research:</strong> Pick a lesser-known but widely used open-source Android library and perform a deep code review and dynamic analysis to try and find a 0-day vulnerability.</li><li><strong>Tool Development:</strong> Create a new Frida script to automate the bypass of a specific, complex anti-analysis technique, or write a Python tool to parse a custom, encrypted C2 protocol.</li><li><strong>Malware Research:</strong> Perform a deep-dive, reverse engineering analysis of a new, emerging malware family and write a detailed technical report on its TTPs.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1507413245164-6160d8298b31?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 100,
                    "questions": [
                        { "id": 1, "question": "The advanced research project is designed to assess your ability to:", "options": ["Follow instructions", "Go beyond the standard curriculum to conduct original, independent work in a specialized area of interest", "Run an automated scanner", "Write a report"], "correct": 1, "explanation": "This project is about demonstrating deep expertise and the ability to create new knowledge, not just consume it." }
                    ]
                }
            },
            {
                "id": "lesson-50-final-capstone-project",
                "title": "Lesson 50: Final Capstone Project",
                "duration": "240 min",
                "objectives": [
                    "Conduct a comprehensive, multi-stage malware analysis of a sophisticated, unknown sample",
                    "Perform static analysis, reverse engineering, and advanced dynamic analysis with instrumentation",
                    "Produce a professional-grade, enterprise-ready malware analysis report with actionable intelligence"
                ],
                "content": {
                    "overview": "The final capstone is a comprehensive, master's level assessment that requires you to synthesize every skill learned in this program. You will be given a sophisticated, unknown mobile malware sample. Your mission is to perform a full reverse engineering and behavioral analysis, extract all relevant IOCs, and produce a professional report suitable for a major enterprise or threat intelligence vendor.",
                    "sections": [
                        {
                            "title": "The Master's Level Analysis",
                            "content": "<p><strong>The Task:</strong> You are the lead malware analyst at a major security firm. A new Android malware sample has been discovered. It appears to be a banking trojan that uses a packer and has several layers of anti-analysis defenses.</p><h3>Your Mission:</h3><ol><li><strong>Static Analysis & De-obfuscation:</strong> Perform an initial static analysis to understand the loader.</li><li><strong>Dynamic Analysis:</strong> Run the sample in your lab to defeat the packer, dump the unpacked payload from memory, and get a clean version for analysis.</li><li><strong>Deep Dive Reversing:</strong> Reverse engineer the unpacked payload to fully understand its functionality: its persistence mechanism, its overlay attack targets, its C2 protocol, and its SMS interception logic. You will need to use Frida to bypass its root detection and anti-debugging checks.</li><li><strong>Reporting:</strong> Produce a single, comprehensive malware analysis report. The report must include a high-level executive summary and a detailed technical analysis section with all the extracted IOCs (hashes, C2 domains, mutexes, etc.) and a full breakdown of the malware's capabilities, mapped to the MITRE ATT&CK framework.</li></ol>",
                            "image": "https://images.unsplash.com/photo-1498050108023-c5249f4df085?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 100,
                    "questions": [
                        { "id": 1, "question": "The capstone project assesses your ability to:", "options": ["Run a single automated scan", "Answer multiple choice questions", "Synthesize knowledge from the entire course to conduct a comprehensive, professional-grade malware analysis engagement from start to finish", "Write a simple 'hello world' application"], "correct": 2, "explanation": "This project is the ultimate test of your practical skills, requiring you to apply your full knowledge base to solve a complex, multi-stage malware reverse engineering challenge, just as you would in a real-world professional analysis." }
                    ]
                }
            }
        ]
    }

      // =====================================================
      // GLOBAL VARIABLES
      // =====================================================
      let currentUser = null;
      let currentLessonIndex = 0;
      let courseProgress = {};
      let userStats = {};
      let quizState = {
        currentQuestion: 0,
        answers: [],
        score: 0,
        isComplete: false,
      };

      // Enhanced session tracking
      let courseSession = {
        startTime: null,
        totalStudyTime: 0,
        lessonsStarted: 0,
        lessonsCompleted: 0,
        pageLoadTime: new Date(),
        interactionCount: 0,
        lastActivityTime: new Date(),
      };

      // Music Player Variables
      let audioPlayer = new Audio();

      // Achievement notification system
      let notificationQueue = [];
      let isShowingNotification = false;

      // =====================================================
      // INITIALIZATION
      // =====================================================
      document.addEventListener("DOMContentLoaded", async () => {
        try {
          showLoadingScreen();
          await checkAuth();

          if (currentUser) {
            // Initialize session tracking
            startCourseSession();

            // Load course data and progress
            await loadCourseData();
            await loadUserProfile();
            await loadProgress();

            // Initialize UI
            initializeEventListeners();
            renderSidebar();
            loadLesson(currentLessonIndex);

            // Initialize additional features
            initMusicPlayer();
            addMusicIndicator();
            initializeActivityTracking();

            hideLoadingScreen();
          } else {
            openAuthModal();
          }
        } catch (error) {
          console.error("Error initializing course:", error);
          hideLoadingScreen();
          showToast("Failed to initialize course system", "error");
        }
      });

      // =====================================================
      // AUTHENTICATION SYSTEM
      // =====================================================
      async function checkAuth() {
        try {
          const {
            data: { session },
            error,
          } = await supabase.auth.getSession();

          if (error) {
            console.error("Auth error:", error);
            currentUser = null;
            openAuthModal();
            return;
          }

          if (!session) {
            currentUser = null;
            openAuthModal();
            return;
          }

          currentUser = session.user;
          updateUIWithUser();
        } catch (error) {
          console.error("Error checking auth:", error);
          currentUser = null;
          openAuthModal();
        }
      }

      function updateUIWithUser() {
        if (!currentUser) return;

        const name =
          currentUser.user_metadata?.full_name ||
          currentUser.email.split("@")[0];
        const userElements = document.querySelectorAll("[data-user-name]");
        userElements.forEach((el) => (el.textContent = name));
      }

      // =====================================================
      // USER PROFILE & STATS MANAGEMENT
      // =====================================================
      async function loadUserProfile() {
        try {
          // ðŸ” Step 1: Try to fetch existing profile
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("*")
            .eq("id", currentUser.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (!profile) {
            // ðŸ†• Step 2: Create new profile if missing
            await createUserProfile();
          } else {
            // âœ… Step 3: Use existing profile
            userStats = profile;
            await updateLastActivity();
          }
        } catch (error) {
          console.error("âŒ Error loading user profile:", error);
          showToast("Failed to load user profile", "error");
        }
      }
      async function createUserProfile() {
        try {
          const newProfile = {
            id: currentUser.id,
            full_name: currentUser.user_metadata?.full_name || "",
            email: currentUser.email,
            level: "Script Kiddie",
            total_points: 0,
            completed_courses: 0,
            current_streak: 0,
            total_certificates: 0,
            total_achievements: 0,
            sections_visited: 0,
            bonus_points: 0,
            in_progress_courses: 0,
            settings_changed: 0,
            midnight_sessions: 0,
            early_sessions: 0,
            weekend_sessions: 0,
            last_activity: new Date().toISOString(),
            created_at: new Date().toISOString(),
          };

          const { error } = await supabase
            .from("profiles")
            .insert([newProfile]);

          if (!error) {
            userStats = newProfile;
            // Award first login achievement
            setTimeout(() => checkAndUnlockAchievement("first_login"), 1000);
          }
        } catch (error) {
          console.error("Error creating user profile:", error);
        }
      }

      async function updateLastActivity() {
        try {
          const now = new Date();

          // Update activity tracking
          courseSession.lastActivityTime = now;

          // Update database
          await supabase
            .from("profiles")
            .update({
              last_activity: now.toISOString(),
            })
            .eq("id", currentUser.id);

          // Check time-based achievements
          await checkTimeBasedAchievements(now);
        } catch (error) {
          console.error("Error updating last activity:", error);
        }
      }

      // =====================================================
      // COURSE SESSION MANAGEMENT
      // =====================================================
      function startCourseSession() {
        courseSession.startTime = new Date();
        courseSession.pageLoadTime = new Date();

        logUserActivity("course_session_start", {
          course_id: COURSE_DATA.id,
          course_title: COURSE_DATA.title,
          user_agent: navigator.userAgent,
          screen_resolution: `${screen.width}x${screen.height}`,
        });

        // Check daily streak
        checkDailyStreak();
      }

      function initializeActivityTracking() {
        // Track page focus/blur for accurate study time
        document.addEventListener("visibilitychange", handleVisibilityChange);

        // Track user interactions
        ["click", "keydown", "scroll", "mousemove"].forEach((event) => {
          document.addEventListener(event, trackUserInteraction, {
            passive: true,
          });
        });

        // Periodic activity updates
        setInterval(updateStudyTime, 60000); // Every minute

        // Save session data before page unload
        window.addEventListener("beforeunload", saveSessionData);
      }

      function handleVisibilityChange() {
        if (document.hidden) {
          courseSession.lastActivityTime = new Date();
        } else {
          // Page became visible again - update activity
          updateLastActivity();
        }
      }

      function trackUserInteraction() {
        courseSession.interactionCount++;
        courseSession.lastActivityTime = new Date();

        // Throttle activity updates
        if (courseSession.interactionCount % 50 === 0) {
          updateLastActivity();
        }
      }

      function updateStudyTime() {
        if (!courseSession.startTime || document.hidden) return;

        const now = new Date();
        const sessionDuration = now - courseSession.startTime;
        courseSession.totalStudyTime = Math.floor(sessionDuration / 1000 / 60); // in minutes

        // Update progress with study time
        saveProgress();
      }

      function saveSessionData() {
        if (!currentUser || !courseSession.startTime) return;

        const sessionData = {
          user_id: currentUser.id,
          course_id: COURSE_DATA.id,
          session_duration: courseSession.totalStudyTime,
          lessons_viewed: courseSession.lessonsStarted,
          lessons_completed: courseSession.lessonsCompleted,
          interactions: courseSession.interactionCount,
          session_date: courseSession.startTime.toISOString().split("T")[0],
        };

        // Store in localStorage as backup
        localStorage.setItem(
          "course_session_backup",
          JSON.stringify(sessionData)
        );

        // Try to save to database
        logUserActivity("course_session_end", sessionData);
      }

      // =====================================================
      // COURSE DATA & PROGRESS MANAGEMENT
      // =====================================================
      async function loadCourseData() {
        try {
          // Update course info in UI
          document.getElementById("courseTitle").textContent =
            COURSE_DATA.title;
          document.getElementById("totalLessons").textContent =
            COURSE_DATA.lessons.length;

          // Log course access
          logUserActivity("course_access", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
          });
        } catch (error) {
          console.error("Error loading course data:", error);
        }
      }

      async function loadProgress() {
        try {
          // Get existing progress from database
          const { data, error } = await supabase
            .from("course_progress")
            .select("*")
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (data) {
            courseProgress = JSON.parse(data.lesson_progress || "{}");
            currentLessonIndex = data.current_lesson || 0;

            // Update session tracking
            courseSession.lessonsStarted = Object.keys(courseProgress).length;
            courseSession.lessonsCompleted = Object.values(
              courseProgress
            ).filter((p) => p.completed).length;
          } else {
            // Initialize new progress
            courseProgress = {};
            currentLessonIndex = 0;
            await saveProgress();

            // Award first course start achievement
            await checkAndUnlockAchievement("first_course_start");
          }

          updateProgressDisplay();
        } catch (error) {
          console.error("Error loading progress:", error);
          showToast("Failed to load progress", "error");
        }
      }

      async function saveProgress() {
        try {
          if (!currentUser) return;

          const now = new Date();
          const progressData = {
            user_id: currentUser.id,
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            current_lesson: currentLessonIndex,
            lesson_progress: JSON.stringify(courseProgress),
            progress: calculateOverallProgress(),
            lessons_completed: getCompletedLessonsCount(),
            lessons_started: Object.keys(courseProgress).length,
            study_time_minutes: courseSession.totalStudyTime,
            last_accessed: now.toISOString(),
            updated_at: now.toISOString(),
          };

          // Upsert progress
          const { error } = await supabase
            .from("course_progress")
            .upsert([progressData]);

          if (error) throw error;

          // Update user stats
          await updateUserStats();

          updateProgressDisplay();
        } catch (error) {
          console.error("Error saving progress:", error);
          showToast("Failed to save progress", "error");
        }
      }

      async function updateUserStats() {
        try {
          // Get all course progress for this user
          const { data: allProgress, error } = await supabase
            .from("course_progress")
            .select("progress, course_id, study_time_minutes")
            .eq("user_id", currentUser.id);

          if (error) throw error;

          // Calculate stats
          const completedCourses =
            allProgress?.filter((p) => p.progress >= 100).length || 0;
          const inProgressCourses =
            allProgress?.filter((p) => p.progress > 0 && p.progress < 100)
              .length || 0;
          const totalStudyTime =
            allProgress?.reduce(
              (sum, p) => sum + (p.study_time_minutes || 0),
              0
            ) || 0;

          // Calculate points (500 per completed course + achievement points)
          const coursePoints = completedCourses * 500;
          const bonusPoints = userStats.bonus_points || 0;
          const totalPoints = coursePoints + bonusPoints;

          // Update profile
          const updateData = {
            completed_courses: completedCourses,
            in_progress_courses: inProgressCourses,
            total_points: totalPoints,
            total_study_time: totalStudyTime,
            last_activity: new Date().toISOString(),
          };

          const { error: updateError } = await supabase
            .from("profiles")
            .update(updateData)
            .eq("id", currentUser.id);

          if (updateError) throw updateError;

          // Update local stats
          Object.assign(userStats, updateData);
        } catch (error) {
          console.error("Error updating user stats:", error);
        }
      }

      function calculateOverallProgress() {
        const completedLessons = getCompletedLessonsCount();
        return Math.round(
          (completedLessons / COURSE_DATA.lessons.length) * 100
        );
      }

      function getCompletedLessonsCount() {
        return Object.values(courseProgress).filter(
          (lesson) => lesson.completed
        ).length;
      }

      function updateProgressDisplay() {
        const completedCount = getCompletedLessonsCount();
        const progressPercent = calculateOverallProgress();

        // Update UI elements
        const elements = {
          completedLessons: completedCount,
          courseProgressPercent: `${progressPercent}%`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });

        // Update progress bar
        const progressBar = document.getElementById("courseProgressFill");
        if (progressBar) progressBar.style.width = `${progressPercent}%`;
      }

      // =====================================================
      // LESSON MANAGEMENT
      // =====================================================
      function loadLesson(index) {
        if (index < 0 || index >= COURSE_DATA.lessons.length) return;

        const lesson = COURSE_DATA.lessons[index];
        currentLessonIndex = index;

        // Mark lesson as started and track activity
        if (!courseProgress[lesson.id]) {
          courseProgress[lesson.id] = {
            started: true,
            completed: false,
            startedAt: new Date().toISOString(),
            timeSpent: 0,
          };

          courseSession.lessonsStarted++;
          saveProgress();

          // Log lesson start
          logUserActivity("lesson_start", {
            lesson_id: lesson.id,
            lesson_title: lesson.title,
            lesson_index: index,
          });
        }

        // Update lesson start time for time tracking
        courseProgress[lesson.id].currentSessionStart = new Date();

        // Update sidebar and navigation
        renderSidebar();
        updateNavigationButtons();

        // Update header info
        updateLessonHeader(lesson, index);

        // Render lesson content
        renderLessonContent(lesson);

        // Smooth scroll and animations
        window.scrollTo({ top: 0, behavior: "smooth" });
        document.getElementById("contentBody").scrollTop = 0;

        const contentBody = document.getElementById("contentBody");
        contentBody.classList.add("fade-in");
        setTimeout(() => contentBody.classList.remove("fade-in"), 500);

        // Check lesson-based achievements
        checkLessonAchievements(index + 1);
      }

      function updateLessonHeader(lesson, index) {
        const elements = {
          currentLessonNumber: index + 1,
          currentLessonTitle: lesson.title,
          navInfo: `Lesson ${index + 1} of ${COURSE_DATA.lessons.length}`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });
      }

      function renderSidebar() {
        const lessonNav = document.getElementById("lessonNav");
        if (!lessonNav) return;

        lessonNav.innerHTML = "";

        COURSE_DATA.lessons.forEach((lesson, index) => {
          const lessonItem = document.createElement("div");
          lessonItem.className = "lesson-item";

          // Determine lesson status
          const lessonProgress = courseProgress[lesson.id];
          const isCompleted = lessonProgress?.completed || false;
          const isInProgress = lessonProgress?.started || false;
          const isLocked = !isCompleted && !canAccessLesson(index);
          const isActive = index === currentLessonIndex;

          // Apply status classes
          if (isCompleted) lessonItem.classList.add("completed");
          if (isLocked) lessonItem.classList.add("locked");
          if (isActive) lessonItem.classList.add("active");

          // Determine status display
          let statusClass = "not-started";
          let statusIcon = index + 1;

          if (isCompleted) {
            statusClass = "completed";
            statusIcon = "âœ“";
          } else if (isInProgress) {
            statusClass = "in-progress";
            statusIcon = "â—";
          }

          // Create lesson item HTML
          lessonItem.innerHTML = `
            <div class="lesson-status ${statusClass}">${statusIcon}</div>
            <div class="lesson-info">
                <div class="lesson-title">${lesson.title}</div>
                <div class="lesson-meta">
                    ${
                      isCompleted
                        ? "Completed"
                        : isInProgress
                        ? "In Progress"
                        : isLocked
                        ? "Locked"
                        : "Not Started"
                    }
                </div>
            </div>
            <div class="lesson-duration">${lesson.duration}</div>
        `;

          // Add click handler if not locked
          if (!isLocked) {
            lessonItem.addEventListener("click", () => {
              if (index !== currentLessonIndex) {
                // Track lesson time before switching
                trackLessonTime();

                currentLessonIndex = index;
                loadLesson(index);
                closeSidebar();
              }
            });
          }

          lessonNav.appendChild(lessonItem);
        });
      }

      function canAccessLesson(index) {
        if (index === 0) return true; // First lesson always accessible

        // Can access if previous lesson is completed
        const previousLessonId = COURSE_DATA.lessons[index - 1].id;
        return courseProgress[previousLessonId]?.completed || false;
      }

      function trackLessonTime() {
        const currentLesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonProgress = courseProgress[currentLesson.id];

        if (lessonProgress?.currentSessionStart) {
          const sessionTime = Math.floor(
            (new Date() - new Date(lessonProgress.currentSessionStart)) /
              1000 /
              60
          );
          lessonProgress.timeSpent =
            (lessonProgress.timeSpent || 0) + sessionTime;
          delete lessonProgress.currentSessionStart;
        }
      }

      // =====================================================
      // LESSON CONTENT RENDERING
      // =====================================================
      function renderLessonContent(lesson) {
        const contentContainer = document.getElementById("lessonContent");
        if (!contentContainer) return;

        let contentHTML = `
        <div class="content-section">
            <h2>Learning Objectives</h2>
            <ul>
                ${lesson.objectives.map((obj) => `<li>${obj}</li>`).join("")}
            </ul>
        </div>
        
        <div class="content-section">
            <h2>Overview</h2>
            <p>${lesson.content.overview}</p>
        </div>
    `;

        // Render content sections
        lesson.content.sections.forEach((section) => {
          contentHTML += `
            <div class="content-section">
                <h2>${section.title}</h2>
                ${section.content}
                ${
                  section.image
                    ? `<img src="${section.image}" alt="${section.title}" class="content-image" loading="lazy">`
                    : ""
                }
            </div>
        `;
        });

        // Render code examples
        if (
          lesson.content.codeExamples &&
          lesson.content.codeExamples.length > 0
        ) {
          contentHTML += `<div class="content-section"><h2>Code Examples</h2></div>`;

          lesson.content.codeExamples.forEach((example, index) => {
            const codeId = `code-${lesson.id}-${index}`;
            contentHTML += `
                <div class="code-section">
                    <div class="code-header">
                        <span class="code-title">${example.title}</span>
                        <button class="copy-btn" onclick="copyCode('${codeId}')">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <pre class="code-block"><code id="${codeId}" class="language-${
              example.language
            }">${escapeHtml(example.code)}</code></pre>
                </div>
            `;
          });
        }

        // Render quiz
        contentHTML += renderQuiz(lesson.quiz);

        contentContainer.innerHTML = contentHTML;

        // Highlight code syntax if Prism is available
        setTimeout(() => {
          if (window.Prism) {
            Prism.highlightAll();
          }
        }, 100);
      }

      // =====================================================
      // QUIZ SYSTEM
      // =====================================================
      function renderQuiz(quiz) {
        const currentLessonProgress =
          courseProgress[COURSE_DATA.lessons[currentLessonIndex].id];
        const isCompleted = currentLessonProgress?.completed || false;

        let quizHTML = `
        <div class="quiz-section" id="quizSection">
            <div class="quiz-header">
                <h2 class="quiz-title">
                    <i class="fas fa-clipboard-check"></i>
                    Knowledge Check
                </h2>
                <p class="quiz-info">
                    Complete this quiz with ${quiz.passingScore}% or higher to unlock the next lesson.
                </p>
            </div>
    `;

        if (isCompleted) {
          const savedScore = currentLessonProgress.quizScore || 0;
          quizHTML += `
            <div class="quiz-results show">
                <div class="quiz-score pass">${savedScore}%</div>
                <div class="quiz-message">
                    <strong>Lesson Completed!</strong><br>
                    You've successfully passed this lesson's quiz.
                </div>
            </div>
        `;
        } else {
          // Render quiz questions
          quiz.questions.forEach((question, qIndex) => {
            quizHTML += `
                <div class="quiz-question ${
                  qIndex === 0 ? "active" : ""
                }" data-question="${qIndex}">
                    <div class="question-header">
                        <span class="question-number">Question ${
                          qIndex + 1
                        }</span>
                        <span class="question-progress">${qIndex + 1}/${
              quiz.questions.length
            }</span>
                    </div>
                    <div class="question-text">${question.question}</div>
                    <div class="question-options">
                        ${question.options
                          .map(
                            (option, oIndex) => `
                            <div class="option" data-option="${oIndex}" onclick="selectOption(${qIndex}, ${oIndex})">
                                <span class="option-letter">${String.fromCharCode(
                                  65 + oIndex
                                )}</span>
                                <span class="option-text">${option}</span>
                            </div>
                        `
                          )
                          .join("")}
                    </div>
                </div>
            `;
          });

          quizHTML += `
            <div class="quiz-controls">
                <button class="btn btn-secondary" id="prevQuestionBtn" onclick="previousQuestion()" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <div>
                    <button class="btn btn-secondary" id="nextQuestionBtn" onclick="nextQuestion()" disabled>
                        Next
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <button class="btn btn-primary" id="submitQuizBtn" onclick="submitQuiz()" style="display: none;">
                        <i class="fas fa-check"></i>
                        Submit Quiz
                    </button>
                </div>
            </div>

            <div class="quiz-results" id="quizResults">
                <div class="quiz-score" id="quizScore">0%</div>
                <div class="quiz-message" id="quizMessage"></div>
                <div class="quiz-actions">
                    <button class="btn btn-primary" id="continueBtn" onclick="completeLesson()" style="display: none;">
                        <i class="fas fa-arrow-right"></i>
                        Continue to Next Lesson
                    </button>
                    <button class="btn btn-secondary" onclick="retakeQuiz()">
                        <i class="fas fa-redo"></i>
                        Retake Quiz
                    </button>
                </div>
            </div>
        `;
        }

        quizHTML += "</div>";
        return quizHTML;
      }

      // Quiz interaction functions
      function selectOption(questionIndex, optionIndex) {
        // Clear previous selections
        document
          .querySelectorAll(`[data-question="${questionIndex}"] .option`)
          .forEach((opt) => {
            opt.classList.remove("selected");
          });

        // Select current option
        const selectedOption = document.querySelector(
          `[data-question="${questionIndex}"] [data-option="${optionIndex}"]`
        );
        selectedOption.classList.add("selected");

        // Store answer
        quizState.answers[questionIndex] = optionIndex;

        // Update navigation
        const isLastQuestion =
          questionIndex ===
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length - 1;
        if (isLastQuestion) {
          document.getElementById("submitQuizBtn").style.display =
            "inline-flex";
          document.getElementById("nextQuestionBtn").style.display = "none";
        } else {
          document.getElementById("nextQuestionBtn").disabled = false;
        }
      }

      function nextQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const nextQuestionEl = currentQuestionEl.nextElementSibling;

        if (
          nextQuestionEl &&
          nextQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          nextQuestionEl.classList.add("active");
          quizState.currentQuestion++;
          updateQuizNavigation();
        }
      }

      function previousQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const prevQuestionEl = currentQuestionEl.previousElementSibling;

        if (
          prevQuestionEl &&
          prevQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          prevQuestionEl.classList.add("active");
          quizState.currentQuestion--;
          updateQuizNavigation();
        }
      }

      function updateQuizNavigation() {
        const totalQuestions =
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length;
        const prevBtn = document.getElementById("prevQuestionBtn");
        const nextBtn = document.getElementById("nextQuestionBtn");
        const submitBtn = document.getElementById("submitQuizBtn");

        prevBtn.disabled = quizState.currentQuestion === 0;

        const hasAnswer =
          quizState.answers[quizState.currentQuestion] !== undefined;
        const isLastQuestion = quizState.currentQuestion === totalQuestions - 1;

        if (isLastQuestion) {
          nextBtn.style.display = "none";
          submitBtn.style.display = hasAnswer ? "inline-flex" : "none";
        } else {
          nextBtn.style.display = "inline-flex";
          nextBtn.disabled = !hasAnswer;
          submitBtn.style.display = "none";
        }
      }

      async function submitQuiz() {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const quiz = lesson.quiz;
        let correctAnswers = 0;

        // Hide questions and controls
        document
          .querySelectorAll(".quiz-question")
          .forEach((q) => (q.style.display = "none"));
        document.querySelector(".quiz-controls").style.display = "none";

        // Calculate score and highlight answers
        quiz.questions.forEach((question, index) => {
          const userAnswer = quizState.answers[index];
          const correctAnswer = question.correct;
          const isCorrect = userAnswer === correctAnswer;

          if (isCorrect) correctAnswers++;

          // Highlight answers
          const questionEl = document.querySelector(
            `[data-question="${index}"]`
          );
          const options = questionEl.querySelectorAll(".option");

          options[correctAnswer].classList.add("correct");
          if (userAnswer !== correctAnswer && userAnswer !== undefined) {
            options[userAnswer].classList.add("incorrect");
          }
        });

        const score = Math.round(
          (correctAnswers / quiz.questions.length) * 100
        );
        const passed = score >= quiz.passingScore;

        // Update quiz results UI
        const quizScore = document.getElementById("quizScore");
        const quizMessage = document.getElementById("quizMessage");
        const quizActions = document.querySelector(".quiz-actions");

        quizScore.textContent = `${score}%`;
        quizScore.className = `quiz-score ${passed ? "pass" : "fail"}`;

        if (passed) {
          quizMessage.innerHTML = `
            <strong>Congratulations!</strong><br>
            You passed with ${score}%. You can now proceed to the next lesson.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-primary" onclick="completeLesson()">
                <i class="fas fa-arrow-right"></i>
                Continue to Next Lesson
            </button>
        `;

          // Mark lesson as completed
          await markLessonComplete(score);
        } else {
          quizMessage.innerHTML = `
            <strong>Not quite there yet.</strong><br>
            You scored ${score}%. You need ${quiz.passingScore}% to pass. Review the material and try again.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-secondary" onclick="retakeQuiz()">
                <i class="fas fa-redo"></i>
                Retake Quiz
            </button>
        `;
        }

        document.getElementById("quizResults").classList.add("show");

        // Log quiz completion
        logUserActivity("quiz_completed", {
          lesson_id: lesson.id,
          lesson_title: lesson.title,
          score: score,
          passed: passed,
          attempts: (courseProgress[lesson.id]?.quizAttempts || 0) + 1,
        });

        // Scroll to results
        document
          .getElementById("quizResults")
          .scrollIntoView({ behavior: "smooth" });
      }

      function retakeQuiz() {
        // Reset quiz state
        quizState = {
          currentQuestion: 0,
          answers: [],
          score: 0,
          isComplete: false,
        };

        // Track quiz retry
        const lessonId = COURSE_DATA.lessons[currentLessonIndex].id;
        if (!courseProgress[lessonId]) courseProgress[lessonId] = {};
        courseProgress[lessonId].quizAttempts =
          (courseProgress[lessonId].quizAttempts || 0) + 1;

        // Reload lesson content
        loadLesson(currentLessonIndex);

        // Scroll to quiz
        setTimeout(() => {
          document
            .getElementById("quizSection")
            .scrollIntoView({ behavior: "smooth" });
        }, 500);
      }

      async function markLessonComplete(score) {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonId = lesson.id;

        // Track lesson completion time
        trackLessonTime();

        // Update lesson progress
        courseProgress[lessonId] = {
          ...courseProgress[lessonId],
          completed: true,
          quizScore: score,
          completedAt: new Date().toISOString(),
          finalScore: score,
        };

        // Update session tracking
        courseSession.lessonsCompleted++;

        // Save progress to database
        await saveProgress();

        // Update UI
        renderSidebar();
        updateNavigationButtons();

        // Check various achievements
        await checkLessonCompletionAchievements();
        await checkPerfectScoreAchievements(score);
        await checkStudyTimeAchievements();

        // Log lesson completion
        logUserActivity("lesson_completed", {
          lesson_id: lessonId,
          lesson_title: lesson.title,
          final_score: score,
          time_spent: courseProgress[lessonId].timeSpent || 0,
          lesson_number: currentLessonIndex + 1,
        });

        showToast("Lesson completed successfully!", "success");
      }

      async function completeLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          // Move to next lesson
          currentLessonIndex++;
          loadLesson(currentLessonIndex);
        } else {
          // Course completion
          await completeCourse();
        }
      }

      async function completeCourse() {
        try {
          const completionTime = courseSession.totalStudyTime;

          // Update course progress to 100% completed
          await supabase
            .from("course_progress")
            .update({
              progress: 100,
              completed_at: new Date().toISOString(),
              completion_time_minutes: completionTime,
            })
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Award course completion achievements
          await checkAndUnlockAchievement("course_completion_1");
          await checkSpeedCompletionAchievements(completionTime);
          await checkCourseStreakAchievements();

          // Update user stats
          await updateUserStats();

          // Show completion message
          showToast(
            "Congratulations! Course completed successfully!",
            "certificate"
          );

          // Log course completion
          logUserActivity("course_completed", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            completion_time_minutes: completionTime,
            total_lessons: COURSE_DATA.lessons.length,
            average_quiz_score: calculateAverageQuizScore(),
          });

          // Redirect to dashboard after delay
          setTimeout(() => {
            window.location.href = "/dashboard.html";
          }, 3000);
        } catch (error) {
          console.error("Error completing course:", error);
          showToast("Error marking course as complete", "error");
        }
      }

      // =====================================================
      // ACHIEVEMENT INTEGRATION SYSTEM
      // =====================================================
      async function checkAndUnlockAchievement(
        achievementId,
        skipNotification = false
      ) {
        try {
          // Prevent duplicate checks
          const cacheKey = `achievement_${achievementId}_${currentUser.id}`;
          if (sessionStorage.getItem(cacheKey)) return false;

          // Check if already unlocked
          const { data: existing, error } = await supabase
            .from("user_achievements")
            .select("id")
            .eq("user_id", currentUser.id)
            .eq("achievement_id", achievementId)
            .single();

          if (existing) {
            sessionStorage.setItem(cacheKey, "true");
            return false;
          }

          // Award achievement
          const achievementData = {
            user_id: currentUser.id,
            achievement_id: achievementId,
            unlocked_at: new Date().toISOString(),
            points_awarded: getAchievementPoints(achievementId),
            context: "course_system",
          };

          const { data, error: insertError } = await supabase
            .from("user_achievements")
            .insert([achievementData])
            .select()
            .single();

          if (insertError) {
            if (insertError.code === "23505") return false; // Already exists
            throw insertError;
          }

          // Update user points
         await supabase.rpc('increment_user_stats', {
  user_id_param: currentUser.id,
  points_to_add: achievementData.points_awarded,
  achievements_to_add: 1
});

          // Cache and queue notification
          sessionStorage.setItem(cacheKey, "true");

          if (!skipNotification) {
            queueAchievementNotification({
              id: achievementId,
              name: getAchievementName(achievementId),
              description: getAchievementDescription(achievementId),
              points: achievementData.points_awarded,
              rarity: getAchievementRarity(achievementId),
              icon: getAchievementIcon(achievementId),
            });
          }

          return true;
        } catch (error) {
          console.error("Error unlocking achievement:", error);
          return false;
        }
      }

      // Helper functions for achievement data (replace with your actual achievement definitions)
      function getAchievementPoints(id) {
        const pointsMap = {
          first_course_start: 75,
          first_lesson: 100,
          course_completion_1: 500,
          perfect_score: 250,
          speed_demon: 750,
          marathon_learner: 500,
          night_owl: 200,
          early_bird: 200,
          weekend_warrior: 150,
          // Add more as needed
        };
        return pointsMap[id] || 100;
      }

      function getAchievementName(id) {
        const nameMap = {
          first_course_start: "Learning Initiated",
          first_lesson: "First Steps",
          course_completion_1: "Course Conqueror",
          perfect_score: "Perfectionist",
          speed_demon: "Speed Demon",
          // Add more as needed
        };
        return nameMap[id] || "Achievement Unlocked";
      }

      function getAchievementDescription(id) {
        const descMap = {
          first_course_start: "Start your first cybersecurity course",
          first_lesson: "Complete your first lesson",
          course_completion_1: "Complete your first course",
          perfect_score: "Score 100% on any quiz",
          speed_demon: "Complete a course in under 2 hours",
          // Add more as needed
        };
        return descMap[id] || "Achievement description";
      }

      function getAchievementRarity(id) {
        const rarityMap = {
          first_course_start: "common",
          first_lesson: "bronze",
          course_completion_1: "silver",
          perfect_score: "gold",
          speed_demon: "legendary",
          // Add more as needed
        };
        return rarityMap[id] || "common";
      }

      function getAchievementIcon(id) {
        const iconMap = {
          first_course_start: "fas fa-play",
          first_lesson: "fas fa-baby",
          course_completion_1: "fas fa-trophy",
          perfect_score: "fas fa-star",
          speed_demon: "fas fa-rocket",
          // Add more as needed
        };
        return iconMap[id] || "fas fa-award";
      }

      async function checkLessonAchievements(lessonNumber) {
        if (lessonNumber === 1) {
          await checkAndUnlockAchievement("first_lesson");
        }

        // Check if user has completed multiple lessons in one day
        const today = new Date().toISOString().split("T")[0];
        const todayCompletions = Object.values(courseProgress).filter(
          (p) => p.completed && p.completedAt?.startsWith(today)
        ).length;

        if (todayCompletions >= 3) {
          await checkAndUnlockAchievement("lesson_marathon");
        }
      }

      async function checkLessonCompletionAchievements() {
        const completedCount = getCompletedLessonsCount();

        // Lesson-based achievements
        const lessonMilestones = [1, 5, 10, 25, 50, 100];
        for (const milestone of lessonMilestones) {
          if (completedCount >= milestone) {
            await checkAndUnlockAchievement(`lessons_${milestone}`);
          }
        }

        // Course completion achievements
        if (completedCount === COURSE_DATA.lessons.length) {
          await checkAndUnlockAchievement("course_completion_1");

          // Check for additional course completion achievements
          const { data: allCourses } = await supabase
            .from("course_progress")
            .select("course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100);

          const totalCompleted = allCourses?.length || 0;

          const courseMilestones = [1, 5, 10, 25];
          for (const milestone of courseMilestones) {
            if (totalCompleted >= milestone) {
              await checkAndUnlockAchievement(`course_completion_${milestone}`);
            }
          }
        }
      }

      async function checkPerfectScoreAchievements(score) {
        if (score === 100) {
          await checkAndUnlockAchievement("perfect_score");

          // Check for consecutive perfect scores
          const recentScores = Object.values(courseProgress)
            .filter((p) => p.completed && p.quizScore)
            .slice(-5) // Last 5 completed
            .map((p) => p.quizScore);

          if (
            recentScores.length >= 3 &&
            recentScores.every((s) => s === 100)
          ) {
            await checkAndUnlockAchievement("perfectionist_streak");
          }
        }
      }

      async function checkSpeedCompletionAchievements(completionTime) {
        // Speed demon: Complete course in under 2 hours (120 minutes)
        if (completionTime <= 120) {
          await checkAndUnlockAchievement("speed_demon");
        }

        // Quick learner: Complete course in under 4 hours (240 minutes)
        if (completionTime <= 240) {
          await checkAndUnlockAchievement("quick_learner");
        }
      }

      async function checkStudyTimeAchievements() {
        const totalTime = courseSession.totalStudyTime;

        // Marathon learner: Study for 8+ hours in a course session
        if (totalTime >= 480) {
          // 8 hours
          await checkAndUnlockAchievement("marathon_learner");
        }

        // Dedicated learner: Study for 4+ hours
        if (totalTime >= 240) {
          // 4 hours
          await checkAndUnlockAchievement("dedicated_learner");
        }
      }

      async function checkCourseStreakAchievements() {
        try {
          // Check for consecutive course completions
          const { data: recentCourses, error } = await supabase
            .from("course_progress")
            .select("completed_at, course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100)
            .order("completed_at", { ascending: false })
            .limit(10);

          if (error || !recentCourses) return;

          // Check for courses completed on consecutive days
          let consecutiveDays = 1;
          for (let i = 1; i < recentCourses.length; i++) {
            const prevDate = new Date(
              recentCourses[i - 1].completed_at
            ).toDateString();
            const currentDate = new Date(
              recentCourses[i].completed_at
            ).toDateString();
            const dayDiff =
              Math.abs(new Date(prevDate) - new Date(currentDate)) /
              (1000 * 60 * 60 * 24);

            if (dayDiff <= 1) {
              consecutiveDays++;
            } else {
              break;
            }
          }

          if (consecutiveDays >= 3) {
            await checkAndUnlockAchievement("learning_streak");
          }
        } catch (error) {
          console.error("Error checking course streak achievements:", error);
        }
      }

      // =====================================================
      // TIME-BASED ACHIEVEMENTS
      // =====================================================
      async function checkTimeBasedAchievements(timestamp) {
        const hour = timestamp.getHours();
        const dayOfWeek = timestamp.getDay();

        // Night owl (after midnight, before 6 AM)
        if (hour >= 0 && hour < 6) {
          await incrementTimeBasedCounter("midnight_sessions", "night_owl");
        }

        // Early bird (4 AM to 6 AM)
        if (hour >= 4 && hour < 6) {
          await incrementTimeBasedCounter("early_sessions", "early_bird");
        }

        // Weekend warrior (Saturday = 6, Sunday = 0)
        if (dayOfWeek === 0 || dayOfWeek === 6) {
          await incrementTimeBasedCounter(
            "weekend_sessions",
            "weekend_warrior"
          );
        }
      }

      async function incrementTimeBasedCounter(counterType, achievementId) {
        try {
          const dateStr = new Date().toISOString().split("T")[0];
          const cacheKey = `${counterType}_${currentUser.id}_${dateStr}`;

          // Prevent multiple increments per day
          if (sessionStorage.getItem(cacheKey)) return;

          // Update counter
          await supabase
            .from("profiles")
            .update({
              [counterType]: supabase.sql`${counterType} + 1`,
            })
            .eq("id", currentUser.id);

          // Cache to prevent double counting
          sessionStorage.setItem(cacheKey, "true");

          // Check related achievement
          if (achievementId) {
            await checkAndUnlockAchievement(achievementId, true);
          }
        } catch (error) {
          console.error(`Error incrementing ${counterType}:`, error);
        }
      }

      async function checkDailyStreak() {
        try {
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("last_activity, current_streak, last_streak_date")
            .eq("id", currentUser.id)
            .single();

          if (error) throw error;

          const now = new Date();
          const today = now.toDateString();
          const lastActivity = profile.last_activity
            ? new Date(profile.last_activity)
            : null;
          const lastStreakDate = profile.last_streak_date
            ? new Date(profile.last_streak_date).toDateString()
            : null;

          let newStreak = profile.current_streak || 0;
          let shouldUpdateStreak = false;

          if (!lastActivity) {
            // First time user
            newStreak = 1;
            shouldUpdateStreak = true;
          } else {
            const daysSinceLastActivity = Math.floor(
              (now - lastActivity) / (1000 * 60 * 60 * 24)
            );

            if (lastStreakDate === today) {
              // Already counted today's streak
              return newStreak;
            } else if (
              daysSinceLastActivity === 1 ||
              (daysSinceLastActivity === 0 && lastStreakDate !== today)
            ) {
              // Consecutive day or same day but not counted yet
              newStreak += 1;
              shouldUpdateStreak = true;
            } else if (daysSinceLastActivity > 1) {
              // Streak broken
              newStreak = 1;
              shouldUpdateStreak = true;
            }
          }

          if (shouldUpdateStreak) {
            await supabase
              .from("profiles")
              .update({
                current_streak: newStreak,
                last_activity: now.toISOString(),
                last_streak_date: now.toISOString(),
              })
              .eq("id", currentUser.id);

            userStats.current_streak = newStreak;

            showToast(`Daily streak: ${newStreak} days!`, "success");
            await checkStreakAchievements(newStreak);
          }

          return newStreak;
        } catch (error) {
          console.error("Error checking daily streak:", error);
          return 0;
        }
      }

      async function checkStreakAchievements(currentStreak) {
        const streakMilestones = [3, 7, 14, 30, 100, 365];

        for (const milestone of streakMilestones) {
          if (currentStreak >= milestone) {
            await checkAndUnlockAchievement(`streak_${milestone}`);
          }
        }
      }

      // =====================================================
      // USER ACTIVITY LOGGING
      // =====================================================
      async function logUserActivity(activityType, metadata = {}) {
        try {
          const now = new Date();

          const activityData = {
            user_id: currentUser.id,
            activity_type: activityType,
            timestamp: now.toISOString(),
            course_id: COURSE_DATA.id,
            lesson_index: currentLessonIndex,
            session_duration: courseSession.totalStudyTime,
            metadata: JSON.stringify(metadata),
            created_at: now.toISOString(),
          };

          // Try to log to activities table
          const { error } = await supabase
            .from("user_activities")
            .insert([activityData]);

          if (error && error.code !== "42P01") {
            console.warn("Activity logging failed:", error.message);
          }

          // Always update last activity in profile
          await supabase
            .from("profiles")
            .update({ last_activity: now.toISOString() })
            .eq("id", currentUser.id);
        } catch (error) {
          console.error("Error logging user activity:", error);
        }
      }

      // =====================================================
      // NAVIGATION SYSTEM
      // =====================================================
      function updateNavigationButtons() {
        const prevBtn = document.getElementById("prevLessonBtn");
        const nextBtn = document.getElementById("nextLessonBtn");

        if (!prevBtn || !nextBtn) return;

        // Previous button
        prevBtn.disabled = currentLessonIndex === 0;

        // Next button logic
        const isLastLesson =
          currentLessonIndex === COURSE_DATA.lessons.length - 1;
        const canGoNext =
          currentLessonIndex < COURSE_DATA.lessons.length - 1 &&
          canAccessLesson(currentLessonIndex + 1);

        if (isLastLesson) {
          const isCurrentCompleted =
            courseProgress[COURSE_DATA.lessons[currentLessonIndex].id]
              ?.completed;
          nextBtn.disabled = !isCurrentCompleted;
          nextBtn.innerHTML = '<i class="fas fa-trophy"></i> Complete Course';
        } else {
          nextBtn.disabled = !canGoNext;
          nextBtn.innerHTML = 'Next <i class="fas fa-chevron-right"></i>';
        }
      }

      // Navigation button event handlers
      function goToPreviousLesson() {
        if (currentLessonIndex > 0) {
          trackLessonTime(); // Track time spent on current lesson
          currentLessonIndex--;
          loadLesson(currentLessonIndex);
        }
      }

      function goToNextLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          const canGoNext = canAccessLesson(currentLessonIndex + 1);
          if (canGoNext) {
            trackLessonTime();
            currentLessonIndex++;
            loadLesson(currentLessonIndex);
          } else {
            showToast("Complete the current lesson quiz to proceed", "warning");
          }
        } else {
          // Complete course
          completeCourse();
        }
      }

      // =====================================================
      // SIDEBAR FUNCTIONS
      // =====================================================
      function toggleSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.toggle("open");
        if (overlay) overlay.classList.toggle("active");
      }

      function closeSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.remove("open");
        if (overlay) overlay.classList.remove("active");
      }

      // =====================================================
      // ACHIEVEMENT NOTIFICATION SYSTEM
      // =====================================================
      function queueAchievementNotification(achievement) {
        notificationQueue.push(achievement);
        processNotificationQueue();
      }

      function processNotificationQueue() {
        if (isShowingNotification || notificationQueue.length === 0) return;

        isShowingNotification = true;
        const achievement = notificationQueue.shift();
        showAchievementNotification(achievement);

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          isShowingNotification = false;
          processNotificationQueue();
        }, duration + 500);
      }

      function showAchievementNotification(achievement) {
        const notification = document.getElementById("achievementNotification");
        if (!notification) return;

        const icon = document.getElementById("notificationIcon");
        const title = document.getElementById("notificationTitle");
        const description = document.getElementById("notificationDescription");
        const points = document.getElementById("notificationPoints");

        if (icon) {
          icon.innerHTML = `<i class="${achievement.icon}"></i>`;
          icon.className = `notification-icon ${achievement.rarity}`;
        }
        if (title) title.textContent = achievement.name;
        if (description) description.textContent = achievement.description;
        if (points) points.textContent = `+${achievement.points} Points`;

        notification.className = `achievement-notification ${achievement.rarity}`;
        notification.classList.add("show");

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          notification.classList.remove("show");
        }, duration);
      }

      // =====================================================
      // UTILITY FUNCTIONS
      // =====================================================
      function calculateAverageQuizScore() {
        const scores = Object.values(courseProgress)
          .filter((p) => p.completed && p.quizScore)
          .map((p) => p.quizScore);

        if (scores.length === 0) return 0;
        return Math.round(
          scores.reduce((sum, score) => sum + score, 0) / scores.length
        );
      }

      async function resetProgress() {
        if (
          !confirm(
            "Are you sure you want to reset your progress? This action cannot be undone."
          )
        ) {
          return;
        }

        try {
          // Track lesson time before reset
          trackLessonTime();

          // Reset local state
          courseProgress = {};
          currentLessonIndex = 0;
          courseSession = {
            startTime: new Date(),
            totalStudyTime: 0,
            lessonsStarted: 0,
            lessonsCompleted: 0,
            pageLoadTime: new Date(),
            interactionCount: 0,
            lastActivityTime: new Date(),
          };

          // Delete from database
          await supabase
            .from("course_progress")
            .delete()
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Log reset activity
          logUserActivity("progress_reset", {
            course_id: COURSE_DATA.id,
            reset_reason: "manual",
          });

          // Reinitialize
          await saveProgress();
          renderSidebar();
          loadLesson(0);

          showToast("Progress reset successfully", "success");
        } catch (error) {
          console.error("Error resetting progress:", error);
          showToast("Failed to reset progress", "error");
        }
      }

      function copyCode(codeId) {
        const codeElement = document.getElementById(codeId);
        if (!codeElement) return;

        const text = codeElement.textContent;

        navigator.clipboard
          .writeText(text)
          .then(() => {
            showToast("Code copied to clipboard!", "success");

            // Track code copy for achievements
            logUserActivity("code_copied", {
              code_section: codeId,
              lesson_id: COURSE_DATA.lessons[currentLessonIndex].id,
            });
          })
          .catch((err) => {
            console.error("Failed to copy code:", err);
            showToast("Failed to copy code", "error");

            // Fallback for older browsers
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            try {
              document.execCommand("copy");
              showToast("Code copied to clipboard!", "success");
            } catch (fallbackError) {
              showToast(
                "Copy failed - please select and copy manually",
                "error"
              );
            }
            document.body.removeChild(textArea);
          });
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // =====================================================
      // UI FEEDBACK SYSTEMS
      // =====================================================
      function showToast(message, type = "success") {
        const toast = document.getElementById("toast");
        const messageEl = document.getElementById("toastMessage");

        if (!toast || !messageEl) {
          console.log(`Toast: ${message} (${type})`);
          return;
        }

        messageEl.textContent = message;
        toast.className = `toast ${type} show`;

        setTimeout(() => {
          toast.classList.remove("show");
        }, 4000);
      }

      function showLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) loadingScreen.classList.remove("hidden");
      }

      function hideLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) {
          setTimeout(() => {
            loadingScreen.classList.add("hidden");
          }, 1000);
        }
      }

      // =====================================================
      // MUSIC PLAYER INTEGRATION
      // =====================================================
      function initMusicPlayer() {
        const btnText = document.getElementById("music-button-text");
        const icon = document.getElementById("music-icon");
        const dropdown = document.getElementById("music-dropdown-content");

        if (!btnText || !icon || !dropdown) return;

        function setUI(state) {
          btnText.textContent =
            state === "Playing" ? "PAUSE MUSIC" : "STUDY MUSIC";
          icon.className =
            state === "Playing"
              ? "fa-solid fa-circle-pause"
              : "fa-solid fa-music";
        }

        // Load saved music state
        const savedSrc = localStorage.getItem("cybersec_music_src");
        const savedTime = parseFloat(
          localStorage.getItem("cybersec_music_time") || 0
        );

        if (savedSrc) {
          audioPlayer.src = savedSrc;
          audioPlayer.currentTime = savedTime;
          audioPlayer
            .play()
            .then(() => setUI("Playing"))
            .catch(() => setUI("Stopped"));
        }

        // Music button click handler
        document
          .getElementById("music-dropdown")
          .querySelector("button")
          .addEventListener("click", (e) => {
            e.stopPropagation();
            dropdown.style.display =
              dropdown.style.display === "block" ? "none" : "block";

            if (audioPlayer.src && !audioPlayer.paused) {
              audioPlayer.pause();
              setUI("Stopped");
            } else if (audioPlayer.src) {
              audioPlayer.play().then(() => setUI("Playing"));
            }
          });

        // Music selection handlers
        dropdown.querySelectorAll("a[data-src]").forEach((link) => {
          link.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.src = link.dataset.src;
            audioPlayer.play().then(() => setUI("Playing"));
            localStorage.setItem("cybersec_music_src", link.dataset.src);
            dropdown.style.display = "none";
          });
        });

        // Stop music handler
        const stopLink = document.getElementById("stop-music-link");
        if (stopLink) {
          stopLink.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            audioPlayer.removeAttribute("src");
            setUI("Stopped");
            localStorage.removeItem("cybersec_music_src");
            localStorage.removeItem("cybersec_music_time");
            dropdown.style.display = "none";
          });
        }

        // Save music state before page unload
        window.addEventListener("beforeunload", () => {
          if (!audioPlayer.paused && audioPlayer.src) {
            localStorage.setItem("cybersec_music_src", audioPlayer.src);
            localStorage.setItem(
              "cybersec_music_time",
              audioPlayer.currentTime
            );
          }
        });

        // Close dropdown when clicking outside
        window.addEventListener("click", (e) => {
          if (!e.target.closest("#music-dropdown")) {
            dropdown.style.display = "none";
          }
        });
      }

      // Show initial music indicator
      function addMusicIndicator() {
        const musicBtn = document.querySelector("#music-dropdown");
        if (musicBtn) {
          const indicator = document.createElement("div");
          indicator.className = "music-indicator";
          indicator.innerHTML = `<i class="fa-solid fa-music"></i> Try Study Music!`;

          musicBtn.style.position = "relative";
          musicBtn.appendChild(indicator);

          setTimeout(() => indicator.remove(), 3000);
        }
      }

      // Initialize Event Listeners
      function initializeEventListeners() {
        // Navigation buttons
        document
          .getElementById("prevLessonBtn")
          ?.addEventListener("click", goToPreviousLesson);
        document
          .getElementById("nextLessonBtn")
          ?.addEventListener("click", goToNextLesson);

        // Reset progress button
        document
          .getElementById("resetProgressBtn")
          ?.addEventListener("click", resetProgress);

        // Mobile menu toggle
        document
          .getElementById("menuToggle")
          ?.addEventListener("click", toggleSidebar);
        document
          .getElementById("sidebarOverlay")
          ?.addEventListener("click", closeSidebar);

        // Keyboard shortcuts
        document.addEventListener("keydown", handleKeyboardShortcuts);

        // Window resize handler
        window.addEventListener("resize", handleWindowResize);

        // Content interaction tracking
        document.getElementById("contentBody")?.addEventListener(
          "scroll",
          debounce(() => {
            trackUserInteraction();
          }, 1000)
        );
      }

      // Keyboard Shortcuts
      function handleKeyboardShortcuts(e) {
        if (document.querySelector(".quiz-question.active")) return;

        if (e.key === "ArrowLeft" && e.ctrlKey) {
          e.preventDefault();
          goToPreviousLesson();
        } else if (e.key === "ArrowRight" && e.ctrlKey) {
          e.preventDefault();
          goToNextLesson();
        }
      }

      // Window Resize Handler
      function handleWindowResize() {
        if (window.innerWidth > 768) {
          closeSidebar();
        }
      }

      // Debounce Helper
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Initialize responsive behavior
      if (window.innerWidth <= 768) {
        document.getElementById("menuToggle").style.display = "inline-flex";
      }

      // Auto-save progress periodically
      setInterval(async () => {
        if (currentUser && Object.keys(courseProgress).length > 0) {
          await saveProgress();
        }
      }, 60000); // Save every minute

      // System initialization logging
      console.log("CyberSec Academy Course System Initialized");
      console.log("Current Course:", COURSE_DATA.title);
      console.log("Total Lessons:", COURSE_DATA.lessons.length);

      // Google OAuth Integration
      const googleBtn = document.querySelector(".btn-google");
      if (googleBtn) {
        googleBtn.addEventListener("click", async () => {
          const { data, error } = await supabase.auth.signInWithOAuth({
            provider: "google",
            options: {
              redirectTo:
                window.location.origin +
                "/courses/mobile-malware-analysis.html",
            },
          });

          if (error) {
            console.error("Google login error:", error.message);
            showToast("Google login failed: " + error.message, "error");
          }
        });
      }

      // Check for existing session
      supabase.auth.getSession().then(({ data }) => {
        if (data.session) {
          console.log("User already logged in:", data.session.user);
          currentUser = data.session.user;
          startCourseSession();
        }
      });

      // Add missing auth modal functions
      function openAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "flex";
        }
      }

      function closeAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Add auth tab switching functionality
      document.getElementById("tabSignIn")?.addEventListener("click", () => {
        document.getElementById("tabSignIn").classList.add("active");
        document.getElementById("tabSignUp").classList.remove("active");
        document.getElementById("signInForm").style.display = "block";
        document.getElementById("signUpForm").style.display = "none";
      });

      document.getElementById("tabSignUp")?.addEventListener("click", () => {
        document.getElementById("tabSignUp").classList.add("active");
        document.getElementById("tabSignIn").classList.remove("active");
        document.getElementById("signUpForm").style.display = "block";
        document.getElementById("signInForm").style.display = "none";
      });

      document
        .getElementById("closeAuthModal")
        ?.addEventListener("click", closeAuthModal);

      // Improved error handling for auth session
      supabase.auth.onAuthStateChange((event, session) => {
        if (event === "SIGNED_IN") {
          currentUser = session.user;
          closeAuthModal();
          startCourseSession();
        } else if (event === "SIGNED_OUT") {
          currentUser = null;
          openAuthModal();
        }
      });

      // Add form submission handlers
      document
        .getElementById("emailSignInForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signInEmail").value;
          const password = document.getElementById("signInPassword").value;

          try {
            const { data, error } = await supabase.auth.signInWithPassword({
              email,
              password,
            });

            if (error) throw error;

            closeAuthModal();
          } catch (error) {
            showToast(error.message, "error");
          }
        });

      document
        .getElementById("emailSignUpForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signUpEmail").value;
          const password = document.getElementById("signUpPassword").value;
          const name = document.getElementById("signUpName").value;

          try {
            const { data, error } = await supabase.auth.signUp({
              email,
              password,
              options: {
                data: {
                  full_name: name,
                },
              },
            });

            if (error) throw error;

            showToast(
              "Account created successfully! Please check your email.",
              "success"
            );
          } catch (error) {
            showToast(error.message, "error");
          }
        });
    </script>
  </body>
</html>

