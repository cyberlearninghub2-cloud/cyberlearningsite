



<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- ========== Start: SEO & Schema Enhancement ========== -->
    <title>Advanced Firewalling | CipherHall</title>
    <meta name="description" content="Enroll in our free beginner's course on computer networking. Learn protocols, devices, the OSI model, IP addressing, and troubleshooting." />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png" />
    <link rel="shortcut icon" href="/favicon.png" type="image/x-icon" />
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png" />
    <link rel="canonical" href="https://www.cipherhall.com/courses/advanced-firewalling" />

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Course",
      "name": "Computer Networking Basics",
      "description": "Understand how computer networks work, protocols, devices, and practical troubleshooting.",
      "provider": {
        "@type": "Organization",
        "name": "CipherHall",
        "sameAs": "https://www.cipherhall.com"
      },
      "hasCourseInstance": {
        "@type": "CourseInstance",
        "courseMode": "Online",
        "instructor": {
          "@type": "Person",
          "name": "Prof. Michael Rodriguez"
        }
      }
    }
    </script>
    <!-- ========== End: SEO & Schema Enhancement ========== -->

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Exo+2:wght@700;800;900&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css"
    />
    <link rel="icon" type="image/x-icon" href="assets/favicon.ico" />

    <link rel="stylesheet" href="assets/css/coursepages.css" />
</head>
<body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
        <div class="loader-icon">
            <i class="fas fa-graduation-cap"></i>
        </div>
        <div class="loader-text">Loading Course Content...</div>
    </div>
    
    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>
    
    <!-- Music Player (fixed at top right) -->
    <div class="header-controls">
        <div class="music-dropdown" id="music-dropdown">
            <button class="btn btn-secondary">
                <span id="music-button-text">STUDY MUSIC</span>
                <i id="music-icon" class="fa-solid fa-music"></i>
            </button>
            <div class="music-dropdown-content" id="music-dropdown-content">
                <a href="#" data-src="https://www.learningcontainer.com/wp-content/uploads/2020/02/Kalimba.mp3">1. Coffee Shop Vibes</a>
                <a href="#" data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3">2. City Lights Lofi</a>
                <a href="#" data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-15.mp3">3. Mellow Thoughts</a>
                <a href="#" data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-13.mp3">4. Rainy Mood</a>
                <a href="#" data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3">5. Time Alone</a>
                <a href="#" id="stop-music-link"><i class="fa-solid fa-stop-circle"></i> Stop Music</a>
            </div>
        </div>
        
        <button class="btn btn-secondary" id="resetProgressBtn">
            <i class="fas fa-redo"></i>
            Reset Progress
        </button>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal" style="display: none">
        <div class="modal-overlay"></div>
        <div class="modal-content">
            <span class="close" id="closeAuthModal">&times;</span>
            <div class="auth-tabs">
                <button id="tabSignIn" class="auth-tab active">Sign In</button>
                <button id="tabSignUp" class="auth-tab">Sign Up</button>
            </div>
            <div id="authLoader" style="display: none; text-align: center; padding: 2rem">
                <i class="fas fa-spinner fa-spin fa-2x" style="color: var(--color-green)"></i>
                <p style="margin-top: 0.5rem">Authenticating...</p>
            </div>
            <div id="signInForm" class="auth-form">
                <h2>Sign In to CipherHall</h2>
                <button id="googleSignIn" class="btn btn-google">
                    <i class="fab fa-google"></i> Continue with Google
                </button>
                <div class="divider"><span>or</span></div>
                <form id="emailSignInForm">
                    <input type="email" id="signInEmail" placeholder="Email Address" required>
                    <input type="password" id="signInPassword" placeholder="Password" required>
                    <button type="submit" class="btn btn-primary">Sign In</button>
                </form>
            </div>
            <div id="signUpForm" class="auth-form" style="display: none">
                <h2>Join CipherHall</h2>
                <button id="googleSignUp" class="btn btn-google">
                    <i class="fab fa-google"></i> Continue with Google
                </button>
                <div class="divider"><span>or</span></div>
                <form id="emailSignUpForm">
                    <input type="text" id="signUpName" placeholder="Full Name" required>
                    <input type="email" id="signUpEmail" placeholder="Email Address" required>
                    <input type="password" id="signUpPassword" placeholder="Password (min. 8 characters)" required>
                    <button type="submit" class="btn btn-secondary">Create Account</button>
                </form>
            </div>
            <div id="authMessage"></div>
        </div>
    </div>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <div class="course-info">
                <h1 class="course-title" id="courseTitle">Loading...</h1>
                <div class="course-progress">
                    <div class="progress-header">
                        <span class="progress-label">Course Progress</span>
                        <span class="progress-percentage" id="courseProgressPercent">0%</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="courseProgressFill" style="width: 0%"></div>
                    </div>
                    <div class="progress-stats">
                        <span id="completedLessons">0</span>
                        <span id="totalLessons">0</span>
                    </div>
                </div>
                <a href="/dashboard" class="back-to-dashboard">
                    <i class="fas fa-arrow-left"></i>
                    Back to Dashboard
                </a>
            </div>
        </div>

        <nav class="lesson-nav" id="lessonNav">
            <!-- Lessons will be loaded dynamically -->
        </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
        <header class="content-header">
            <div class="lesson-header">
                <div class="lesson-header-left">
                    <span class="lesson-number" id="currentLessonNumber">1</span>
                    <h1 class="lesson-header-title" id="currentLessonTitle">Loading...</h1>
                </div>
                <div class="lesson-actions">
                    <button class="mbtn btn-primary" id="menuToggle">
                        <i class="fas fa-bars"></i>
                       
                    </button>
                </div>
            </div>
        </header>

        <div class="content-body" id="contentBody">
            <div class="lesson-content" id="lessonContent">
                <!-- Lesson content will be loaded dynamically -->
            </div>
        </div>

        <footer class="lesson-navigation">
            <div class="nav-info" id="navInfo">
                Lesson 1 of 10
            </div>
            <div class="nav-controls">
                <button class="btn btn-secondary" id="prevLessonBtn" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <button class="btn btn-primary" id="nextLessonBtn" disabled>
                    Next
                    <i class="fas fa-chevron-right"></i>
                </button>
            </div>
        </footer>
    </main>

    <!-- Achievement Notification -->
    <div id="achievementNotification" class="achievement-notification">
        <div class="notification-header">
            <div class="notification-icon" id="notificationIcon">
                <i class="fas fa-trophy"></i>
            </div>
            <div class="notification-content">
                <h3 id="notificationTitle">Achievement Unlocked!</h3>
                <p id="notificationDescription">Description here...</p>
            </div>
        </div>
        <div class="notification-reward" id="notificationReward">
            <i class="fas fa-coins"></i>
            <span id="notificationPoints">+100 Points</span>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast">
        <span id="toastMessage"></span>
    </div>

    <script>
       // =====================================================
// SYNCHRONIZED COURSE SYSTEM WITH DASHBOARD INTEGRATION
// =====================================================

// Supabase Configuration - Replace with your config
const supabaseUrl = 'https://lzcmzulemfubjaksoqor.supabase.co';
const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx6Y216dWxlbWZ1Ympha3NvcW9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzMzM5MDgsImV4cCI6MjA3MDkwOTkwOH0.crhPH4YWtRsr1BJTpAQcmPbWSpwIWRbzoI4sRb2_fPI';
const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

// =====================================================
// COURSE DATA STRUCTURE - REPLACE WITH YOUR COURSE JSON
// =====================================================
  const COURSE_DATA = 
{
    "id": "advanced-firewalling",
    "title": "Advanced Firewalling",
    "description": "This course provides a comprehensive journey into network security, starting with foundational concepts and progressively moving to complex, real-world firewall implementations. Students will master Next-Generation Firewall (NGFW) features, threat prevention, VPN configuration, high-availability, and automation.",
    "category": "networking-security",
    "difficulty": "Intermediate to Advanced",
    "duration": "75 hours",
    "instructor": "Prof. Anya Sharma",
    "lessons": [
        {
            "id": "lesson-1",
            "title": "Beyond Stateless Packet Filtering",
            "duration": "90 min",
            "objectives": [
                "Review the OSI model and its relation to firewall operations",
                "Understand the critical limitations of stateless packet filters",
                "Define Stateful Packet Inspection (SPI) and its mechanism",
                "Implement a basic stateful rule to track connections"
            ],
            "content": {
                "overview": "This foundational lesson revisits the basics of network communication to reveal why early firewalls were insufficient. We will explore the limitations of stateless filtering and introduce Stateful Packet Inspection (SPI), the technology that revolutionized firewalling by understanding the context of network conversations.",
                "sections": [
                    {
                        "title": "OSI Layers and Firewall Evolution",
                        "content": "<p>A firewall's capabilities are often described by the OSI layer at which it operates. Traditional firewalls were limited to Layer 3 (IP addresses) and Layer 4 (TCP/UDP ports).</p><h3>The Problem with Statelessness:</h3><p>A stateless firewall treats every packet as an isolated event. It has no memory of past packets. This means to allow the return traffic for a web request, you would need a dangerously permissive inbound rule, as the firewall wouldn't know the incoming packet is a response to a legitimate outgoing request.</p>",
                        "image": "https://images.unsplash.com/photo-1563986768609-322da13575f3?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The Power of Stateful Packet Inspection (SPI)",
                        "content": "<p>Stateful Packet Inspection (SPI) was the first major leap in firewall technology. A stateful firewall maintains a 'state table' that tracks active connections.</p><h3>How it Works:</h3><ol><li>When a user inside the network initiates a connection to an outside server (e.g., a web server), the firewall sees the outgoing SYN packet.</li><li>It creates an entry in its state table for this new connection, noting the source/destination IPs and ports.</li><li>It allows the packet out based on an outbound policy.</li><li>When the web server sends a SYN/ACK response, the firewall checks its state table. It sees that this incoming packet is part of an already-approved, established connection.</li><li>The firewall allows the return packet in, without needing a generic 'allow all inbound on high ports' rule.</li></ol><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Beyond TCP</strong></div><p>SPI also works for connectionless protocols like UDP and ICMP by tracking traffic patterns and using timeouts to approximate a connection's state.</p></div>",
                        "image": "https://images.unsplash.com/photo-1544197150-b2c4c64e91c2?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "iptables - Stateful Connection",
                        "language": "bash",
                        "code": "# Flush existing rules for a clean slate\niptables -F\n\n# Default deny on incoming traffic\niptables -P INPUT DROP\n\n# Allow all outgoing connections\niptables -P OUTPUT ACCEPT\n\n# Allow incoming traffic only for established or related connections\niptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT\n\n# Allow loopback traffic (important for services on the host)\niptables -A INPUT -i lo -j ACCEPT"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary limitation of a stateless firewall?",
                        "options": [
                            "It cannot filter based on IP addresses.",
                            "It has no memory of past packets and cannot track a connection's state.",
                            "It is too slow for modern networks.",
                            "It only operates at Layer 7."
                        ],
                        "correct": 1,
                        "explanation": "A stateless firewall inspects every packet in isolation, meaning it doesn't know if an incoming packet is a legitimate response to an outgoing request, forcing administrators to write overly permissive rules."
                    },
                    {
                        "id": 2,
                        "question": "What is the core component of Stateful Packet Inspection (SPI)?",
                        "options": [
                            "A list of blocked applications.",
                            "An antivirus signature database.",
                            "A state table to track active connections.",
                            "A user identity database."
                        ],
                        "correct": 2,
                        "explanation": "The state table is the 'memory' of the firewall, allowing it to understand the context of a packet within a larger conversation (e.g., a TCP handshake)."
                    },
                    {
                        "id": 3,
                        "question": "In an `iptables` stateful rule, which state indicates a packet is part of an existing, tracked connection?",
                        "options": [
                            "NEW",
                            "INVALID",
                            "ESTABLISHED",
                            "FORWARD"
                        ],
                        "correct": 2,
                        "explanation": "The `ESTABLISHED` state is used to identify packets that belong to a connection that has already been approved and recorded in the state table."
                    }
                ]
            }
        },
        {
            "id": "lesson-2",
            "title": "Introduction to NGFW and UTM",
            "duration": "90 min",
            "objectives": [
                "Define a Next-Generation Firewall (NGFW)",
                "Define Unified Threat Management (UTM)",
                "Identify the key differences between a traditional stateful firewall and an NGFW",
                "Understand the benefits of consolidating security services"
            ],
            "content": {
                "overview": "The network threat landscape has evolved, and so have firewalls. This lesson introduces the modern security appliances that go far beyond stateful inspection. We'll define Next-Generation Firewall (NGFW) and Unified Threat Management (UTM) and explore how they provide deeper visibility and control by integrating multiple security functions into a single platform.",
                "sections": [
                    {
                        "title": "Defining Next-Generation Firewall (NGFW)",
                        "content": "<p>An NGFW is an evolution of the traditional firewall that adds context and awareness to its decision-making process. While a stateful firewall understands connections, an NGFW understands applications, users, and threats.</p><h3>Core Features of an NGFW:</h3><ul><li><strong>Stateful Packet Inspection:</strong> The foundation of all modern firewalls.</li><li><strong>Application Awareness:</strong> Identifies and controls applications, regardless of the port or protocol used.</li><li><strong>Integrated Intrusion Prevention (IPS):</strong> Scans for and blocks known exploits within allowed traffic.</li><li><strong>User/Group-Based Control:</strong> Integrates with directory services like Active Directory to enforce policies based on user identity, not just IP address.</li><li><strong>Threat Intelligence Integration:</strong> Can use external feeds of malicious IPs, domains, and files to block emerging threats.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1614064548237-02f0d1a2b733?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Understanding Unified Threat Management (UTM)",
                        "content": "<p>A Unified Threat Management (UTM) appliance is a single device that combines multiple security and networking features. The line between NGFW and UTM has blurred significantly, but UTMs are often associated with providing an all-in-one solution for small-to-medium businesses (SMBs).</p><h3>Common UTM Features (in addition to NGFW capabilities):</h3><ul><li>Antivirus Gateway</li><li>Web/URL Filtering</li><li>Spam Filtering</li><li>VPN (IPsec and SSL)</li><li>Data Loss Prevention (DLP)</li><li>Routing and other networking functions</li></ul><div class='info-box tip'><div class='info-box-header'><i class='fas fa-lightbulb'></i><strong>Benefit of Consolidation</strong></div><p>The primary driver for both NGFW and UTM is the simplification of security management. Instead of deploying and managing half a dozen different security products, an administrator can manage them all from a single interface with a unified policy structure.</p></div>",
                        "image": "https://images.unsplash.com/photo-1510511459019-5dda7724fd87?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "NGFW Policy Logic (Conceptual)",
                        "language": "pseudocode",
                        "code": "# This is a conceptual rule, not literal code.\n# It demonstrates a policy that is impossible on a traditional firewall.\n\nRULE ID=101\n  NAME='Allow Marketing access to Facebook'\n  SOURCE_ZONE=LAN\n  DESTINATION_ZONE=WAN\n  \n  # Traditional firewall stops here (IPs and Ports)\n  SOURCE_IP=ANY\n  DESTINATION_IP=ANY\n  SERVICE=ANY\n\n  # NGFW adds this context\n  USER_GROUP='Marketing Dept'\n  APPLICATION='Facebook'\n  ACTION=ALLOW\n  THREAT_PROFILE='Strict'\n  LOGGING=ENABLE"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "Which feature is a key differentiator between a traditional stateful firewall and an NGFW?",
                        "options": [
                            "The ability to block IP addresses.",
                            "The ability to filter by TCP/UDP ports.",
                            "The ability to identify and control applications regardless of the port they use.",
                            "The ability to perform Network Address Translation (NAT)."
                        ],
                        "correct": 2,
                        "explanation": "Application awareness (Layer 7 visibility) is a hallmark of NGFWs, allowing them to identify traffic based on its content and behavior, not just its port number."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary appeal of a Unified Threat Management (UTM) device?",
                        "options": [
                            "It is the fastest type of firewall available.",
                            "It consolidates multiple security functions into a single appliance, simplifying management.",
                            "It does not require any configuration.",
                            "It is designed only for cloud environments."
                        ],
                        "correct": 1,
                        "explanation": "UTMs are popular because they offer a cost-effective, all-in-one solution that reduces the complexity of deploying and managing separate devices for firewalling, VPN, AV, and web filtering."
                    },
                    {
                        "id": 3,
                        "question": "Integrating a firewall with Active Directory allows for what kind of policy creation?",
                        "options": [
                            "Port-based policies.",
                            "Application-based policies.",
                            "User identity-based policies.",
                            "Time-based policies."
                        ],
                        "correct": 2,
                        "explanation": "By integrating with a directory service, an NGFW can enforce rules based on user roles and group memberships (e.g., 'Allow Engineering to access SSH') rather than relying on easily-spoofed IP addresses."
                    }
                ]
            }
        },
        {
            "id": "lesson-3",
            "title": "Application Awareness (Layer 7 Visibility)",
            "duration": "120 min",
            "objectives": [
                "Explain how NGFWs identify applications",
                "Understand the difference between protocol detection and application signatures",
                "Describe why SSL/TLS inspection is critical for application visibility",
                "Configure a policy to block an evasive application"
            ],
            "content": {
                "overview": "Simply blocking port 80 is no longer sufficient to control web traffic. Modern applications are designed to be evasive, tunneling their traffic over standard ports to bypass traditional firewalls. This lesson dives into Layer 7 visibility, the technology that allows NGFWs to precisely identify and control applications based on their unique characteristics, and discusses the critical challenge of encrypted traffic.",
                "sections": [
                    {
                        "title": "Identifying Applications Beyond Ports",
                        "content": "<p>NGFWs use a hierarchy of techniques to identify applications.</p><h3>Identification Methods:</h3><ul><li><strong>Protocol Decoders:</strong> The firewall first decodes the protocol (e.g., HTTP, SSL). This provides initial context.</li><li><strong>Application Signatures:</strong> The firewall then looks for unique patterns within the decoded traffic. These signatures, developed by the firewall vendor, can identify specific applications (e.g., YouTube) or sub-applications (e.g., YouTube video streaming vs. YouTube commenting).</li><li><strong>Heuristics/Behavioral Analysis:</strong> For unknown or custom applications, the firewall can analyze traffic patterns and behavior to make an educated guess about the application's identity.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1521185496955-15097b20c5fe?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The Challenge: SSL/TLS Encryption",
                        "content": "<p>An ever-increasing amount of web traffic is encrypted with SSL/TLS. When traffic is encrypted, the firewall's DPI engine cannot see the payload. It can see the source and destination IPs, but the application-identifying data inside the encrypted tunnel is invisible.</p><h3>The Solution: Decryption</h3><p>To gain visibility, the firewall must perform SSL/TLS inspection (decryption). It effectively acts as a 'man-in-the-middle', decrypting traffic from the client, inspecting it, and then re-encrypting it before sending it to the server. This allows the signature engine to analyze the plaintext application data.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Privacy and Trust</strong></div><p>SSL/TLS inspection requires the firewall to have a trusted certificate that it uses to re-sign the traffic. Client devices on the network must be configured to trust this certificate. This process has significant performance and privacy implications and must be managed carefully.</p></div>",
                        "image": "https://images.unsplash.com/photo-1526374965328-5f61d25c16c6?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Blocking an Evasive App (Conceptual)",
                        "language": "pseudocode",
                        "code": "# This rule blocks applications in the 'File-Sharing' category,\n# regardless of the port they attempt to use.\n\nRULE ID=102\n  NAME='Block all P2P File Sharing'\n  SOURCE_ZONE=LAN\n  DESTINATION_ZONE=WAN\n  \n  # We don't care about the destination IP or port.\n  DESTINATION_IP=ANY\n  SERVICE=ANY\n  \n  # We block based on the application signature.\n  APPLICATION_GROUP='File-Sharing'\n  ACTION=BLOCK\n  MESSAGE='File sharing is a violation of company policy.'\n  LOGGING=ENABLE"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "Why is it ineffective to block an application like BitTorrent by just blocking its default port?",
                        "options": [
                            "BitTorrent does not use ports.",
                            "The application can be configured to run on any port, such as port 80 (HTTP), to evade port-based rules.",
                            "BitTorrent traffic is always encrypted.",
                            "Firewalls cannot see BitTorrent traffic."
                        ],
                        "correct": 1,
                        "explanation": "Many modern applications, especially P2P apps, are designed to be port-agile. Layer 7 application awareness is needed to identify them based on their unique traffic signatures, not their port."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary challenge that SSL/TLS encryption poses to an NGFW?",
                        "options": [
                            "It slows down the network.",
                            "It uses too much CPU on the firewall.",
                            "It makes the firewall's application signatures ineffective by hiding the payload from the DPI engine.",
                            "It is not compatible with stateful inspection."
                        ],
                        "correct": 2,
                        "explanation": "Deep Packet Inspection requires access to the packet's payload. Encryption renders the payload unreadable, blinding the firewall to the application running inside the tunnel."
                    },
                    {
                        "id": 3,
                        "question": "What must a firewall do to identify the specific application running inside an HTTPS session?",
                        "options": [
                            "Guess based on the destination IP address.",
                            "Perform SSL/TLS decryption to inspect the plaintext traffic.",
                            "Ask the end-user what application they are running.",
                            "It is impossible to identify applications inside HTTPS."
                        ],
                        "correct": 1,
                        "explanation": "To apply application signatures and perform deep inspection, the firewall must decrypt the traffic, inspect it in plaintext, and then re-encrypt it. This is a resource-intensive but necessary process for full visibility."
                    }
                ]
            }
        },
        {
            "id": "lesson-4",
            "title": "User Identity Integration",
            "duration": "100 min",
            "objectives": [
                "Explain the benefits of user-based rules over IP-based rules",
                "Describe how firewalls integrate with directory services like Active Directory",
                "Understand the concept of Role-Based Access Control (RBAC) in firewall policies",
                "Design a policy that grants access based on a user's group membership"
            ],
            "content": {
                "overview": "Who is on your network is just as important as where they are coming from. Relying on IP addresses for security is unreliable in dynamic environments with DHCP and shared workstations. This lesson explores how NGFWs integrate with user directories to create identity-based policies, enabling true Role-Based Access Control (RBAC) at the network edge.",
                "sections": [
                    {
                        "title": "From IP Addresses to Usernames",
                        "content": "<p>Traditional firewall rules are based on IP addresses. This model breaks down in modern networks.</p><h3>Problems with IP-Based Rules:</h3><ul><li><strong>Dynamic IPs (DHCP):</strong> A user's IP address can change daily.</li><li><strong>Shared Devices:</strong> Multiple users might use the same computer (and IP address) at different times.</li><li><strong>IP Spoofing:</strong> IP addresses can be forged by malicious actors.</li><li><strong>Lack of Context:</strong> An IP address tells you nothing about the user's role, department, or access needs.</li></ul><p>By mapping users to their network activity, firewalls can create much more granular and meaningful security policies.</p>",
                        "image": "https://images.unsplash.com/photo-1554469384-e58fac166870?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Integration with Directory Services",
                        "content": "<p>NGFWs don't store user accounts themselves. Instead, they integrate with existing identity stores like Microsoft Active Directory (AD), LDAP, or RADIUS.</p><h3>How it Works:</h3><ol><li><strong>Directory Integration:</strong> The firewall is configured with read-only credentials to the directory server. It queries the server to learn about usernames and their group memberships (e.g., 'Engineering', 'Sales', 'IT-Admins').</li><li><strong>User-to-IP Mapping:</strong> The firewall needs a way to know which user is at which IP address. This is often done via an agent installed on the domain controller that monitors login events, or by integrating with network access control (NAC) solutions. When a user logs in, the firewall is notified of their username and current IP.</li><li><strong>Policy Enforcement:</strong> When traffic from that IP arrives at the firewall, the firewall checks its user-to-IP mapping table. It sees that the traffic belongs to 'John Doe', who is a member of the 'Engineering' group. It then applies the rules specifically created for the 'Engineering' group.</li></ol>",
                        "image": "https://images.unsplash.com/photo-1585223730162-3431b903e659?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Role-Based Access Control (RBAC)",
                        "content": "<p>User identity integration is the key to implementing RBAC on the network. Access is granted based on a user's role in the organization, not their network location.</p><div class='info-box tip'><div class='info-box-header'><i class='fas fa-lightbulb'></i><strong>Example RBAC Policy</strong></div><p>Instead of a rule saying 'Allow 10.1.10.55 to SSH to the server farm', an RBAC rule would say 'Allow members of the IT-Admins group to use the SSH application to access the Servers security zone'. This rule is more secure, more readable, and automatically applies to new admins without any changes.</p></div>",
                        "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Role-Based Rule (Conceptual)",
                        "language": "pseudocode",
                        "code": "# This rule grants the Engineering group access to GitHub.\n# It is independent of their IP addresses.\n\nRULE ID=103\n  NAME='Engineering Access to GitHub'\n  SOURCE_ZONE=LAN\n  DESTINATION_ZONE=WAN\n  \n  # The source is defined by user group, not IP.\n  SOURCE_USER_GROUP='Engineering'\n  \n  # Policy can still use application and destination context.\n  DESTINATION_HOST='github.com'\n  APPLICATION='git, ssh, https'\n  \n  ACTION=ALLOW\n  LOGGING=ENABLE"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is a major disadvantage of using only IP addresses for firewall rules?",
                        "options": [
                            "IP addresses are too long and difficult to type.",
                            "They are static and never change.",
                            "They provide no context about the user's identity or role, and they are not stable in DHCP environments.",
                            "IP-based rules are more resource-intensive for the firewall."
                        ],
                        "correct": 2,
                        "explanation": "IP addresses are not a reliable indicator of identity. User-based policies are more secure and manageable because they tie access rights to a person's role, which is more stable than their network address."
                    },
                    {
                        "id": 2,
                        "question": "How does an NGFW typically learn which user is associated with which IP address?",
                        "options": [
                            "By asking the user to log into the firewall every time they access the internet.",
                            "By integrating with a directory service like Active Directory and monitoring user login events.",
                            "By using the MAC address to look up the user's name.",
                            "It guesses based on traffic patterns."
                        ],
                        "correct": 1,
                        "explanation": "The most common method is for an agent or service to monitor login events on a domain controller and then feed the user-to-IP mappings to the firewall in real-time."
                    },
                    {
                        "id": 3,
                        "question": "A rule stating 'Allow members of the Finance group to access the accounting-services application' is an example of what principle?",
                        "options": [
                            "Stateless Packet Filtering",
                            "Network Address Translation (NAT)",
                            "Role-Based Access Control (RBAC)",
                            "Deep Packet Inspection (DPI)"
                        ],
                        "correct": 2,
                        "explanation": "RBAC is the practice of granting access to resources based on a user's role within an organization. This policy is a perfect example, as it links a user group ('Finance') to a resource ('accounting-services')."
                    }
                ]
            }
        },
        {
            "id": "lesson-5",
            "title": "Understanding Security Zones and Policies",
            "duration": "120 min",
            "objectives": [
                "Understand the purpose of network segmentation using security zones",
                "Design a network with common zones like LAN, WAN, DMZ, and Guest",
                "Apply the principle of least privilege to firewall policies",
                "Differentiate between 'default deny' and 'default allow' security postures"
            ],
            "content": {
                "overview": "A firewall's power comes from its ability to enforce policy between different parts of the network. This lesson covers the fundamental design concept of security zones—grouping network interfaces with similar trust levels. We'll learn how to design a segmented network and write policies that enforce the principle of least privilege.",
                "sections": [
                    {
                        "title": "The Need for Segmentation",
                        "content": "<p>A flat network, where all devices are in the same broadcast domain, is a security nightmare. If one device is compromised, the attacker has a clear path to every other device on the network. Network segmentation divides a network into smaller, isolated segments, and a firewall is placed at the boundary to control traffic flow between them.</p><h3>What is a Security Zone?</h3><p>A zone is a logical grouping of one or more physical or virtual network interfaces. Instead of writing rules between specific interfaces (eth0 -> eth1), we write rules between zones (LAN -> WAN). This makes policies more abstract, readable, and scalable.</p>",
                        "image": "https://images.unsplash.com/photo-1587573089734-09cb69c0f2b4?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Common Security Zones",
                        "content": "<ul><li><strong>LAN (Local Area Network):</strong> The trusted internal network where employees and company resources reside. Often referred to as the 'Trust' zone.</li><li><strong>WAN (Wide Area Network):</strong> The untrusted internet. Often referred to as the 'Untrust' zone.</li><li><strong>DMZ (Demilitarized Zone):</strong> A semi-trusted network that houses public-facing servers like web servers and email servers. Devices in the DMZ can be accessed from the internet, but they should not be able to freely initiate connections to the LAN.</li><li><strong>Guest:</strong> An isolated zone for guest users, providing internet access but blocking any access to internal corporate zones like the LAN or DMZ.</li><li><strong>WiFi:</strong> A dedicated zone for corporate wireless devices, which may have different security policies than the wired LAN.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1461749280684-dccba630e2f6?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The Principle of Least Privilege",
                        "content": "<p>This is the most important concept in firewall policy design. It states that any entity (user, device, application) should only be given the bare minimum permissions necessary to perform its function.</p><h3>Default Deny vs. Default Allow</h3><ul><li><strong>Default Deny:</strong> This is the recommended security posture. All traffic is blocked by default. The firewall administrator must create explicit 'allow' rules for traffic that is required for business purposes. Anything not explicitly allowed is denied.</li><li><strong>Default Allow:</strong> A very insecure posture where all traffic is allowed by default. The administrator creates 'deny' rules to block known bad traffic. This is dangerous because it's impossible to know and block all potential threats.</li></ul><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Implicit Deny</strong></div><p>Most firewalls have an implicit 'deny all' rule at the very end of their policy list. If a packet does not match any of the administrator-defined rules above it, it will be dropped by this final, invisible rule.</p></div>",
                        "image": "https://images.unsplash.com/photo-1555949963-aa79dcee981c?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "DMZ Access Rule (Conceptual)",
                        "language": "pseudocode",
                        "code": "# Allow web traffic from the Internet to a specific web server in the DMZ.\n# This follows the principle of least privilege.\n\nRULE ID=104\n  NAME='Allow Inbound Web to DMZ Web Server'\n  \n  # From anywhere on the internet...\n  SOURCE_ZONE=WAN\n  SOURCE_IP=ANY\n  \n  # ...to our specific web server in the DMZ...\n  DESTINATION_ZONE=DMZ\n  DESTINATION_IP='192.168.100.10' # Web Server IP\n  \n  # ...for only the required services.\n  SERVICE='HTTP, HTTPS' # (Ports 80, 443)\n  \n  ACTION=ALLOW"
                    },
                    {
                        "title": "LAN to DMZ Rule (Conceptual)",
                        "language": "pseudocode",
                        "code": "# A separate rule is needed to allow internal users to manage the web server.\n\nRULE ID=105\n  NAME='Allow Admin Access from LAN to DMZ'\n  \n  SOURCE_ZONE=LAN\n  SOURCE_USER_GROUP='IT-Admins'\n  \n  DESTINATION_ZONE=DMZ\n  DESTINATION_IP='192.168.100.10'\n  \n  # Only allow SSH, not all traffic.\n  APPLICATION='ssh'\n  \n  ACTION=ALLOW"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary purpose of creating security zones on a firewall?",
                        "options": [
                            "To make the firewall run faster.",
                            "To logically group interfaces with similar trust levels, simplifying policy creation.",
                            "To assign IP addresses to devices.",
                            "To automatically block all traffic."
                        ],
                        "correct": 1,
                        "explanation": "Zones allow you to write abstract and scalable rules (e.g., LAN -> WAN) instead of tying rules to physical interfaces. This makes policies easier to read, manage, and adapt as the network grows."
                    },
                    {
                        "id": 2,
                        "question": "Which zone is designed to host public-facing servers that need to be accessible from the internet but should be isolated from the internal LAN?",
                        "options": [
                            "LAN (Trust)",
                            "WAN (Untrust)",
                            "DMZ (Demilitarized Zone)",
                            "Guest"
                        ],
                        "correct": 2,
                        "explanation": "The DMZ is a buffer zone. It allows the internet to access specific services (like a web server) while protecting the trusted internal LAN, as there should be no rules allowing traffic to be initiated from the DMZ to the LAN."
                    },
                    {
                        "id": 3,
                        "question": "The 'default deny' security posture means that...",
                        "options": [
                            "All traffic is allowed unless there is a specific rule to block it.",
                            "All traffic is blocked unless there is a specific rule to allow it.",
                            "Only HTTP traffic is allowed by default.",
                            "The firewall denies its own existence."
                        ],
                        "correct": 1,
                        "explanation": "'Default deny' is a core tenet of the principle of least privilege. It forces the administrator to justify and explicitly permit every type of traffic, which is a much more secure approach than trying to block all possible bad traffic."
                    }
                ]
            }
        },
        {
            "id": "lesson-6",
            "title": "Deep Packet Inspection (DPI) In-Depth",
            "duration": "100 min",
            "objectives": [
                "Explain how a DPI engine functions",
                "Differentiate between signature-based and protocol-analysis-based DPI",
                "Understand the performance impact of enabling DPI",
                "Recognize the limitations of DPI"
            ],
            "content": {
                "overview": "Deep Packet Inspection (DPI) is the core technology that powers most NGFW and UTM features, including IPS, application awareness, and content filtering. This lesson goes beyond the surface to explore how DPI engines actually work, the different methods they use to analyze traffic, and the performance trade-offs involved.",
                "sections": [
                    {
                        "title": "How DPI Engines Work",
                        "content": "<p>Unlike stateful inspection, which only looks at headers (Layers 3 and 4), DPI examines the actual data payload of a packet (Layer 7). The firewall first reassembles the packets into a coherent stream of application data and then passes this stream to the DPI engine for analysis.</p><h3>Key Functions:</h3><ul><li><strong>Protocol Decoding:</strong> The engine must first understand the protocol being used (e.g., HTTP, SMB, SMTP) to parse the data stream correctly.</li><li><strong>Pattern Matching:</strong> It then searches for specific patterns or 'signatures' within the data.</li><li><strong>Policy Action:</strong> Based on what it finds, the engine instructs the firewall to take an action: allow, block, reset, or log the connection.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1573495627361-d9b87960b12d?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Signature Matching vs. Protocol Analysis",
                        "content": "<ul><li><strong>Signature Matching:</strong> This is the most common form of DPI. The engine has a database of thousands of signatures, which are strings of bytes or regular expressions that correspond to known applications, exploits, or malware. It's very fast and effective for known threats.</li><li><strong>Protocol Analysis (or Protocol Anomaly Detection):</strong> This method focuses on the protocol's specifications (RFCs). The DPI engine checks if the traffic conforms to the rules of the protocol. For example, it can detect an HTTP response that is malformed in a way that indicates an attack, even if no specific malware signature is matched. This is better for detecting unknown or 'zero-day' attacks.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1504639725590-34d0984388bd?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Performance Considerations",
                        "content": "<p>DPI is an extremely resource-intensive process. Inspecting the payload of every packet requires significant CPU cycles and memory.</p><h3>Impact on Throughput:</h3><p>Firewall vendors often advertise two throughput numbers: a high number for basic stateful filtering, and a much lower number for 'threat protection' or 'DPI' throughput. Enabling features like IPS, AV, and application control can reduce a firewall's maximum throughput by 50-80% or more. Sizing a firewall correctly means choosing a model based on its DPI performance, not its stateful performance.</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Hardware Acceleration</strong></div><p>To combat the performance hit, many vendors use specialized hardware like ASICs (Application-Specific Integrated Circuits) to offload the pattern-matching process from the main CPU, resulting in much higher DPI throughput.</p></div>",
                        "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Conceptual DPI Logic Flow",
                        "language": "pseudocode",
                        "code": "function inspect_packet_stream(stream) {\n    // 1. Reassemble packets into a data stream\n    data = reassemble(stream);\n\n    // 2. Decode the protocol\n    protocol = decode_protocol(data);\n    if (protocol == 'HTTP') {\n        // 3. Apply signatures for the detected protocol\n        if (matches_signature(data, 'SQL_Injection_Pattern')) {\n            return ACTION.BLOCK;\n        } else if (matches_signature(data, 'YouTube_Video_Pattern')) {\n            return ACTION.ALLOW_AND_LOG;\n        }\n    }\n\n    // 4. Check for protocol anomalies\n    if (is_protocol_anomaly(data, protocol)) {\n        return ACTION.BLOCK;\n    }\n\n    // 5. If no threat found, allow\n    return ACTION.ALLOW;\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary difference between Stateful Packet Inspection (SPI) and Deep Packet Inspection (DPI)?",
                        "options": [
                            "SPI is faster than DPI.",
                            "SPI only looks at packet headers (Layers 3-4), while DPI examines the actual data payload (Layer 7).",
                            "Only DPI can be used to block IP addresses.",
                            "SPI is used for IPv6, while DPI is used for IPv4."
                        ],
                        "correct": 1,
                        "explanation": "Stateful inspection tracks connections based on header information. Deep Packet Inspection goes deeper to read the content of the traffic, which is necessary for application identification and threat prevention."
                    },
                    {
                        "id": 2,
                        "question": "What is a major consequence of enabling DPI and its related security features on a firewall?",
                        "options": [
                            "It simplifies the firewall rulebase.",
                            "It significantly reduces the maximum throughput of the firewall.",
                            "It makes the firewall compatible with more network types.",
                            "It disables the need for logging."
                        ],
                        "correct": 1,
                        "explanation": "DPI is very CPU and memory intensive. Enabling it will always result in a lower maximum data transfer rate compared to simple stateful filtering. It's a crucial factor when sizing and purchasing a firewall."
                    },
                    {
                        "id": 3,
                        "question": "Protocol anomaly detection is better at detecting zero-day attacks than signature matching because...",
                        "options": [
                            "It is much faster than signature matching.",
                            "It doesn't rely on a pre-existing pattern of a known threat, but instead looks for deviations from normal protocol behavior.",
                            "It is updated more frequently.",
                            "It can inspect encrypted traffic without decryption."
                        ],
                        "correct": 1,
                        "explanation": "Signatures can only detect threats that have been seen, analyzed, and had a signature written for them. Anomaly detection can flag malicious activity that uses a new, unknown exploit by recognizing that it violates the rules of the protocol."
                    }
                ]
            }
        },
        {
            "id": "lesson-7",
            "title": "Intrusion Detection and Prevention Systems (IDS/IPS)",
            "duration": "100 min",
            "objectives": [
                "Define the role of an Intrusion Detection System (IDS)",
                "Define the role of an Intrusion Prevention System (IPS)",
                "Differentiate between in-line and passive deployment models",
                "Understand how an IPS integrated into an NGFW enforces policy"
            ],
            "content": {
                "overview": "An allowed connection is not necessarily a safe connection. An Intrusion Prevention System (IPS) acts as a second layer of defense, inspecting the content of allowed traffic for known exploits and malicious activity. This lesson clarifies the critical difference between detection (IDS) and prevention (IPS) and explains how modern NGFWs use an in-line IPS to actively block threats in real-time.",
                "sections": [
                    {
                        "title": "IDS: The Watchful Sentry",
                        "content": "<p>An Intrusion Detection System (IDS) is a passive monitoring system. It analyzes a copy of the network traffic and looks for suspicious activity. </p><h3>Key Characteristics:</h3><ul><li><strong>Passive Deployment:</strong> It is not in the direct path of traffic. It usually receives data from a SPAN or mirror port on a switch.</li><li><strong>Action:</strong> When it detects a potential threat, its only action is to generate an alert. It cannot block the traffic.</li><li><strong>Purpose:</strong> An IDS is a visibility tool, used for logging, incident response, and security analysis. It tells you that an attack happened, but cannot stop it from happening.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1580179709226-a599275dc858?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "IPS: The Active Guard",
                        "content": "<p>An Intrusion Prevention System (IPS) is an active, in-line security device. All traffic must pass through it before reaching its destination.</p><h3>Key Characteristics:</h3><ul><li><strong>In-line Deployment:</strong> It sits directly in the path of network traffic. An IPS integrated into an NGFW is by definition in-line.</li><li><strong>Action:</strong> When it detects a threat based on its signature database, it can take immediate, active measures. It can drop the malicious packet, block the source IP address, and reset the TCP connection.</li><li><strong>Purpose:</strong> An IPS is an enforcement tool designed to actively prevent exploits from succeeding.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1611928549863-9b63a939f403?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Integrated IPS in NGFWs",
                        "content": "<p>Modern NGFWs have a fully integrated IPS engine. This is a significant advantage over deploying a separate, stand-alone IPS device.</p><h3>Benefits of Integration:</h3><ul><li><strong>Single Pass Architecture:</strong> The firewall can perform stateful inspection, application ID, and IPS inspection on a packet in a single pass, which is more efficient.</li><li><strong>Context-Awareness:</strong> The IPS is part of the overall policy. You can apply different IPS profiles to different rules. For example, you might apply a very strict IPS profile to traffic going to your critical DMZ servers, and a more lenient one for general user web browsing.</li><li><strong>Simplified Management:</strong> One device to manage, one set of logs, one policy interface.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "NGFW Rule with IPS Profile (Conceptual)",
                        "language": "pseudocode",
                        "code": "# This rule allows web traffic to the DMZ and applies a strict IPS profile.\n\nRULE ID=201\n  NAME='Inbound Web with Strict IPS'\n  SOURCE_ZONE=WAN\n  DESTINATION_ZONE=DMZ\n  DESTINATION_IP='192.168.100.10'\n  SERVICE='HTTP, HTTPS'\n  ACTION=ALLOW\n\n  # The integrated IPS is applied to the allowed traffic.\n  # The 'Strict_Web_Server' profile contains signatures for web-specific attacks.\n  THREAT_PROFILE='Strict_Web_Server'"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the key difference in the action an IDS can take versus an IPS?",
                        "options": [
                            "An IDS can block traffic, but an IPS can only send alerts.",
                            "An IDS can only detect web traffic, while an IPS can detect all traffic types.",
                            "An IDS can only send an alert, while an IPS can actively block the malicious traffic.",
                            "There is no difference in their actions."
                        ],
                        "correct": 2,
                        "explanation": "Detection vs. Prevention. An IDS is a passive device that detects and alerts. An IPS is an active, in-line device that can prevent the attack by dropping the packets."
                    },
                    {
                        "id": 2,
                        "question": "An IPS must be deployed 'in-line'. What does this mean?",
                        "options": [
                            "It must be configured using the command line.",
                            "It analyzes a copy of the traffic and is not in the primary data path.",
                            "All network traffic must pass directly through the device for it to function.",
                            "It must be physically located in the same rack as the core switch."
                        ],
                        "correct": 2,
                        "explanation": "To be able to 'prevent' an attack by dropping packets, the IPS must be directly in the path of the traffic. If it were analyzing a copy (passive deployment), it would see the attack but be powerless to stop it."
                    },
                    {
                        "id": 3,
                        "question": "What is a major advantage of having an IPS integrated into an NGFW?",
                        "options": [
                            "It makes the firewall's logging features unnecessary.",
                            "It allows the administrator to apply context-aware IPS policies to specific firewall rules.",
                            "It makes the firewall physically smaller.",
                            "It removes the need for SSL decryption."
                        ],
                        "correct": 1,
                        "explanation": "Integration allows for greater granularity. Instead of applying one IPS policy to all traffic, an NGFW can have different levels of inspection for different types of traffic (e.g., stricter for servers, more lenient for guest users)."
                    }
                ]
            }
        },
        {
            "id": "lesson-8",
            "title": "Writing and Managing IPS Signatures",
            "duration": "120 min",
            "objectives": [
                "Understand the basic anatomy of an IPS signature",
                "Learn the fundamental syntax of Snort/Suricata rules",
                "Define false positives and false negatives",
                "Develop strategies for managing and tuning an IPS"
            ],
            "content": {
                "overview": "While most organizations rely on vendor-supplied signatures, understanding how they are constructed is crucial for effective IPS management. This lesson dissects the anatomy of an IPS rule using the popular open-source Snort syntax as a model. We'll learn how to read rules and, more importantly, how to manage the inevitable false alarms.",
                "sections": [
                    {
                        "title": "Anatomy of a Signature",
                        "content": "<p>An IPS signature, or rule, is a set of conditions that, if met, identify specific traffic as malicious. It has two main parts: the rule header and the rule options.</p><h3>Snort Rule Structure:</h3><p><code>[Action] [Protocol] [Src IP] [Src Port] -> [Dst IP] [Dst Port] ( [Rule Options] )</code></p><ul><li><strong>Header:</strong> Defines the action (e.g., `alert`, `drop`), protocol, and source/destination addresses and ports.</li><li><strong>Options:</strong> This is the heart of the rule. It contains the specific keywords that the DPI engine uses to inspect the packet payload, such as `content` to search for a string, `msg` for the alert message, and `sid` for the unique signature ID.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1542903660-eedba2cda473?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Managing False Positives and Negatives",
                        "content": "<p>Tuning an IPS is a constant balancing act between two types of errors:</p><ul><li><strong>False Positive:</strong> The IPS blocks legitimate traffic because it incorrectly matched a signature. For example, a rule looking for the word 'admin' might trigger on a normal email conversation. False positives are disruptive and erode trust in the security system.</li><li><strong>False Negative:</strong> The IPS fails to block an actual attack because no signature matched, or the signature was too specific. This is a silent failure and the more dangerous of the two.</li></ul><h3>Tuning Strategies:</h3><ul><li>Start by running the IPS in detection-only (IDS) mode to see what alerts are generated without blocking traffic.</li><li>Analyze frequent alerts to determine if they are false positives.</li><li>Create exceptions or tune the specific signature to be more precise (e.g., by adding more conditions) to avoid blocking legitimate traffic.</li><li>Regularly update signature databases to minimize false negatives for new threats.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Snort Rule for SQL Injection",
                        "language": "c",
                        "code": "# Alert on common SQL injection attempts in web traffic\n\nalert tcp any any -> $HTTP_SERVERS $HTTP_PORTS (\n  msg:\"ET WEB_SPECIFIC_APPS SQL Injection Attempt (UNION SELECT)\";\n  flow:to_server,established;\n  content:\"UNION\"; nocase;\n  content:\"SELECT\"; nocase; distance:0;\n  pcre:\"/UNION\\s+SELECT/i\";\n  sid:2001219;\n  rev:7;\n)"
                    },
                    {
                        "title": "Snort Rule Breakdown",
                        "language": "text",
                        "code": "alert tcp any any -> $HTTP_SERVERS $HTTP_PORTS (...)\n\n- alert: Action (just log, don't drop).\n- tcp: Protocol.\n- any any: Source IP and port (any).\n- ->: Directional operator.\n- $HTTP_SERVERS $HTTP_PORTS: Destination (pre-defined variables).\n- flow:to_server,established: Look only at established flows going to the server.\n- content:\"UNION\";: Look for the string \"UNION\" in the payload.\n- nocase;: Make the content match case-insensitive.\n- distance:0;: Look for the next content match immediately after the previous one.\n- sid:2001219;: The unique Signature ID."
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "In a Snort rule, what is the purpose of the 'content' keyword?",
                        "options": [
                            "To define the protocol being inspected.",
                            "To specify the alert message that should be generated.",
                            "To search for a specific string or pattern within the packet's payload.",
                            "To set the source IP address."
                        ],
                        "correct": 2,
                        "explanation": "The 'content' keyword is one of the primary tools for DPI, instructing the engine to look for a specific sequence of bytes in the traffic stream."
                    },
                    {
                        "id": 2,
                        "question": "An IPS blocks an employee from accessing a critical internal application because their traffic accidentally contained a string that matched a malware signature. This is an example of a:",
                        "options": [
                            "False Positive",
                            "False Negative",
                            "True Positive",
                            "True Negative"
                        ],
                        "correct": 0,
                        "explanation": "A false positive occurs when the system incorrectly identifies legitimate activity as malicious. It's a 'false alarm' that results in blocking good traffic."
                    },
                    {
                        "id": 3,
                        "question": "What is the more dangerous type of IPS error from a security perspective?",
                        "options": [
                            "False Positive",
                            "False Negative",
                            "They are equally dangerous.",
                            "Neither is dangerous."
                        ],
                        "correct": 1,
                        "explanation": "A false negative is a failure to detect a real attack. This is the most dangerous scenario because it gives a false sense of security while allowing a threat to enter the network undetected."
                    }
                ]
            }
        },
        {
            "id": "lesson-9",
            "title": "Anomaly-Based Threat Detection",
            "duration": "90 min",
            "objectives": [
                "Understand the limitations of signature-based detection",
                "Define anomaly-based detection and its mechanism",
                "Explain the importance of establishing a network baseline",
                "Recognize the role of AI/ML in modern threat detection"
            ],
            "content": {
                "overview": "Signatures are great for known threats, but what about brand new, 'zero-day' attacks for which no signature exists? This lesson introduces anomaly-based threat detection, a more advanced approach that works by learning what's 'normal' for your network and then flagging any significant deviations, with a look at how AI and Machine Learning are enhancing these capabilities.",
                "sections": [
                    {
                        "title": "Beyond Signatures",
                        "content": "<p>Signature-based detection is fundamentally reactive. A threat must be discovered, analyzed, and have a signature created for it before it can be blocked. This leaves a window of vulnerability for new attacks.</p><h3>The Problem with Zero-Days:</h3><p>A zero-day attack is one that exploits a previously unknown vulnerability. By definition, no signature exists for it on the day it's first used. Anomaly-based detection aims to close this gap.</p>",
                        "image": "https://images.unsplash.com/photo-1504868584819-f8e8b4b6d7e3?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Establishing a Baseline",
                        "content": "<p>Anomaly-based detection systems work by first creating a baseline of normal network activity. The system spends a period of time (days or weeks) in a learning mode, observing:</p><ul><li>What protocols are commonly used?</li><li>Which hosts talk to which other hosts?</li><li>How much bandwidth is typically consumed?</li><li>What are the normal operating hours?</li></ul><p>This statistical model of 'normal' becomes the baseline for future comparisons.</p>",
                        "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Detecting Deviations",
                        "content": "<p>Once the baseline is established, the system monitors traffic in real-time and compares it against the learned model. It looks for anomalies, such as:</p><ul><li>A user's workstation suddenly starting to use the IRC protocol.</li><li>A server in the DMZ initiating an SSH connection to a host in the LAN.</li><li>A massive amount of data being exfiltrated to an unknown external IP address at 3 AM.</li></ul><p>These deviations from the norm generate alerts for the security team to investigate.</p><div class='info-box tip'><div class='info-box-header'><i class='fas fa-lightbulb'></i><strong>The Role of AI/ML</strong></div><p>Modern anomaly detection systems heavily leverage Artificial Intelligence (AI) and Machine Learning (ML) to build more accurate and adaptive baselines. ML algorithms can process vast amounts of data to identify subtle patterns and reduce the number of false positives that plagued earlier, simpler statistical systems.</p></div>",
                        "image": "https://images.unsplash.com/photo-1620712943543-95fc6962c2f7?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Conceptual Anomaly Detection Logic",
                        "language": "pseudocode",
                        "code": "// This is a simplified conceptual flow, not real code.\n\n// 1. Learning Phase\nbaseline = new NetworkBaseline();\nfor (day = 1; day <= 14; day++) {\n    traffic_today = capture_traffic();\n    baseline.learn(traffic_today);\n}\n\n// 2. Detection Phase\nwhile (true) {\n    current_traffic = capture_traffic();\n    deviation_score = baseline.compare(current_traffic);\n\n    if (deviation_score > THRESHOLD) {\n        generate_alert(\"Significant network anomaly detected!\", current_traffic);\n    }\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary advantage of anomaly-based detection over signature-based detection?",
                        "options": [
                            "It uses less CPU and memory.",
                            "It has the potential to detect new, zero-day attacks for which no signature exists.",
                            "It never generates false positives.",
                            "It is easier to configure."
                        ],
                        "correct": 1,
                        "explanation": "Because anomaly detection looks for deviations from a 'normal' baseline rather than specific known-bad patterns, it can flag suspicious activity even if it has never been seen before."
                    },
                    {
                        "id": 2,
                        "question": "What is the first and most critical step in deploying an anomaly-based detection system?",
                        "options": [
                            "Writing custom signatures.",
                            "Blocking all traffic.",
                            "Allowing the system to operate in a learning mode to establish a baseline of normal activity.",
                            "Integrating it with Active Directory."
                        ],
                        "correct": 2,
                        "explanation": "The system cannot detect anomalies until it understands what is normal. The initial learning period to build the baseline is a fundamental requirement for the system to function correctly."
                    },
                    {
                        "id": 3,
                        "question": "A server that normally only uses HTTPS starts sending a large amount of data using the DNS protocol to an external host. Why would an anomaly detection system flag this?",
                        "options": [
                            "Because DNS is an insecure protocol.",
                            "Because the traffic is going to an external host.",
                            "Because this is a significant deviation from the server's established baseline behavior.",
                            "Because the amount of data is too large."
                        ],
                        "correct": 2,
                        "explanation": "The system knows from the baseline that this server's 'normal' is HTTPS. The sudden use of a different protocol for high-volume data transfer is a major anomaly that could indicate a DNS tunneling attack for data exfiltration."
                    }
                ]
            }
        },
        {
            "id": "lesson-10",
            "title": "Evasion Techniques and Countermeasures",
            "duration": "100 min",
            "objectives": [
                "Understand common methods attackers use to evade IPS detection",
                "Explain how fragmentation attacks work",
                "Describe how firewalls normalize traffic to defeat evasion",
                "Recognize the importance of protocol compliance"
            ],
            "content": {
                "overview": "Security is a cat-and-mouse game. As soon as defenders deploy a new technology like IPS, attackers begin developing techniques to evade it. This lesson explores common IPS evasion techniques, such as fragmentation and obfuscation, and the countermeasures modern firewalls employ to defeat them by normalizing traffic before inspection.",
                "sections": [
                    {
                        "title": "Attacker's Goal: Hiding the Signature",
                        "content": "<p>The goal of most evasion techniques is to present the network traffic to the IPS in a way that the malicious signature is not visible, but to have the end-host reassemble the traffic in a way that the exploit is successful.</p><h3>Common Evasion Techniques:</h3><ul><li><strong>Fragmentation:</strong> The attacker splits the malicious payload across multiple, tiny IP fragments. If the IPS doesn't reassemble the fragments properly, it might not see the complete signature in any single packet.</li><li><strong>Obfuscation:</strong> The attacker uses different encoding (e.g., Unicode, URL encoding) within a protocol like HTTP to hide the malicious string from the IPS. The end-host's web browser, however, will correctly decode it.</li><li><strong>Encryption:</strong> Encrypting the traffic is the ultimate evasion technique, as it makes DPI impossible without decryption.</li><li><strong>Protocol Manipulation:</strong> Sending packets that slightly deviate from the RFC standard in a way that confuses the IPS, but that the target system's more lenient TCP/IP stack will still accept.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1547637581-8173514978a3?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Countermeasure: Traffic Normalization",
                        "content": "<p>Modern firewalls and IPSs don't just inspect traffic as-is. They first run it through a 'normalizer' to reconstruct the data stream exactly as the end-host will see it.</p><h3>Normalization Processes:</h3><ul><li><strong>IP Fragment Reassembly:</strong> The firewall reassembles all IP fragments into a complete packet before passing it to the DPI engine. This defeats fragmentation attacks.</li><li><strong>TCP Segment Reassembly:</strong> The firewall reassembles TCP segments into a coherent, in-order stream of application data. This ensures signatures are not missed due to out-of-order packets.</li><li><strong>Protocol Decoding:</strong> The normalizer decodes any protocol-specific encoding (like URL encoding in HTTP) back to its plain representation before inspection.</li></ul><p>By inspecting the normalized stream, the firewall sees what the target application will see, making signature matching far more reliable.</p>",
                        "image": "https://images.unsplash.com/photo-1510915228340-29c85a43dcfe?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Conceptual Fragmentation Attack",
                        "language": "text",
                        "code": "# Attacker wants to send the string \"UNION SELECT\"\n# A simple IPS signature looks for this exact string.\n\n# Evasion: Attacker splits the string across two packets.\nPacket 1 Payload: \"UNION SE\"\nPacket 2 Payload: \"LECT\"\n\n# A basic IPS might inspect each packet individually and miss the signature.\n# A robust IPS will reassemble the packets first, see the full\n# \"UNION SELECT\" string, and block the attack."
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary goal of an IPS evasion technique?",
                        "options": [
                            "To crash the firewall.",
                            "To modify the traffic so the malicious signature is not detected by the IPS, but the exploit still works on the target host.",
                            "To encrypt all network traffic.",
                            "To increase the speed of the network connection."
                        ],
                        "correct": 1,
                        "explanation": "Evasion is about creating a discrepancy between how the IPS sees the traffic and how the final destination host interprets it, allowing the malicious payload to slip through."
                    },
                    {
                        "id": 2,
                        "question": "How does a firewall's traffic normalizer defeat an IP fragmentation attack?",
                        "options": [
                            "By blocking all fragmented packets.",
                            "By reassembling all IP fragments into a complete packet before inspection.",
                            "By sending an alert but allowing the fragments through.",
                            "By slowing down the connection."
                        ],
                        "correct": 1,
                        "explanation": "The normalizer's job is to reconstruct the data stream as the end-host would. By performing full IP reassembly, it ensures the DPI engine sees the complete payload, regardless of how it was fragmented."
                    },
                    {
                        "id": 3,
                        "question": "Which of the following is the most effective evasion technique that requires a specific countermeasure?",
                        "options": [
                            "Fragmentation",
                            "Obfuscation",
                            "Using a non-standard port",
                            "SSL/TLS Encryption"
                        ],
                        "correct": 3,
                        "explanation": "Encryption completely hides the payload. The only countermeasure is for the firewall to perform active SSL/TLS decryption (a 'man-in-the-middle' operation)."
                    }
                ]
            }
        },
        {
            "id": "lesson-11",
            "title": "SSL/TLS Decryption (Man-in-the-Middle)",
            "duration": "120 min",
            "objectives": [
                "Explain why SSL/TLS decryption is necessary for modern security",
                "Describe how a firewall performs decryption as a trusted Man-in-the-Middle (MITM)",
                "Understand the role of the firewall's subordinate CA certificate",
                "Discuss the privacy and performance implications of decryption"
            ],
            "content": {
                "overview": "You can't inspect what you can't see. With the majority of web traffic now encrypted, performing SSL/TLS decryption is no longer optional—it's essential for any meaningful security inspection. This lesson demystifies the process of SSL/TLS decryption on a firewall, explaining how it works, the certificate management required, and the important ethical and performance considerations.",
                "sections": [
                    {
                        "title": "The Need to Inspect Encrypted Traffic",
                        "content": "<p>Encryption is a double-edged sword. It provides privacy and security for legitimate users, but it also creates a perfect hiding place for attackers.</p><h3>Threats Hidden by Encryption:</h3><ul><li>Malware downloads over HTTPS.</li><li>Command-and-control (C2) communication from infected hosts.</li><li>Data exfiltration over encrypted channels.</li><li>Users accessing prohibited applications that run over TLS.</li></ul><p>Without decryption, the firewall is blind to these threats, and features like IPS, Antivirus, and Application-ID are rendered ineffective.</p>",
                        "image": "https://images.unsplash.com/photo-1526374965328-5f61d25c16c6?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "How Firewall Decryption Works",
                        "content": "<p>The firewall performs a legitimate Man-in-the-Middle (MITM) interception of the TLS handshake.</p><h3>The Process:</h3><ol><li>A user on the LAN attempts to connect to an external HTTPS website (e.g., `google.com`).</li><li>The firewall intercepts this connection request.</li><li>The firewall establishes its own TLS session with the external website. It validates the site's real certificate just as a browser would.</li><li>Simultaneously, the firewall presents its own certificate to the user's browser. This certificate is a copy of the real site's certificate, but it is signed by the firewall's own special 'Subordinate CA' certificate.</li><li>The user's browser must be configured to trust the firewall's Subordinate CA. If it does, it establishes a TLS session with the firewall.</li><li>The firewall now sits in the middle of two encrypted sessions. It decrypts traffic from the user, inspects it, and if it's clean, re-encrypts it and sends it to the real website.</li></ol>",
                        "image": "https://images.unsplash.com/photo-1555949963-aa79dcee981c?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Certificate Management and Privacy",
                        "content": "<p>The entire process hinges on the client devices trusting the firewall's certificate.</p><h3>Implementation Steps:</h3><ul><li>The firewall administrator generates a Subordinate Certificate Authority (CA) certificate on the firewall.</li><li>This certificate must be deployed to all trusted client devices on the network via Group Policy (GPO), MDM, or manual installation. It is placed in the 'Trusted Root Certification Authorities' store.</li></ul><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Privacy and Policy</strong></div><p>SSL/TLS decryption gives the organization full visibility into encrypted traffic. This has major privacy implications. It is crucial to have a clear acceptable use policy and to create decryption exceptions for sensitive categories like healthcare, financial, and government websites to avoid legal and ethical issues.</p></div>",
                        "image": "https://images.unsplash.com/photo-1562911791-c9a94181822c?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Conceptual Decryption Policy",
                        "language": "pseudocode",
                        "code": "# Best practice is to NOT decrypt everything.\n# Create a policy that decrypts most traffic, but excludes sensitive categories.\n\nRULE ID=301\n  NAME='Decrypt General Web Traffic'\n  SOURCE_ZONE=LAN\n  DESTINATION_ZONE=WAN\n  SERVICE='HTTPS'\n  ACTION=ALLOW\n  SSL_DECRYPTION=ENABLE\n\nRULE ID=302\n  NAME='Bypass Decryption for Sensitive Sites'\n  SOURCE_ZONE=LAN\n  DESTINATION_ZONE=WAN\n  SERVICE='HTTPS'\n  URL_CATEGORY='Healthcare, Finance'\n  ACTION=ALLOW\n  SSL_DECRYPTION=DISABLE # Do not decrypt this traffic"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "Why is SSL/TLS decryption a critical feature for an NGFW?",
                        "options": [
                            "To make web browsing faster for users.",
                            "To allow security features like IPS and AV to inspect the content of encrypted traffic.",
                            "To block all HTTPS traffic.",
                            "To save the company money on bandwidth."
                        ],
                        "correct": 1,
                        "explanation": "Without decryption, the firewall is blind to the payload of encrypted traffic, allowing threats like malware and data exfiltration to pass through undetected."
                    },
                    {
                        "id": 2,
                        "question": "For firewall decryption to work without causing browser errors, what must be done?",
                        "options": [
                            "The user must click 'ignore' on the browser warning every time.",
                            "A special subordinate CA certificate from the firewall must be installed and trusted on all client devices.",
                            "The firewall must have a faster CPU.",
                            "All users must use a specific web browser."
                        ],
                        "correct": 1,
                        "explanation": "The process relies on the client's browser trusting the certificate presented by the firewall. This trust is established by pre-installing the firewall's signing certificate into the client's trusted root store."
                    },
                    {
                        "id": 3,
                        "question": "What is a major non-technical consideration when implementing SSL/TLS decryption?",
                        "options": [
                            "The color of the firewall.",
                            "The time of day.",
                            "User privacy, legal, and ethical implications of inspecting sensitive data.",
                            "The brand of the network switches."
                        ],
                        "correct": 2,
                        "explanation": "Decrypting traffic gives the organization the ability to see sensitive personal information (e.g., online banking, medical data). It is critical to have a clear policy and to exempt sensitive categories from decryption to avoid violating user privacy and laws."
                    }
                ]
            }
        },
        {
            "id": "lesson-12",
            "title": "Sandboxing for Zero-Day Malware",
            "duration": "90 min",
            "objectives": [
                "Define sandboxing in the context of network security",
                "Explain how a sandbox analyzes unknown files",
                "Describe how a firewall integrates with a sandbox",
                "Understand the difference between cloud and on-premise sandboxes"
            ],
            "content": {
                "overview": "Antivirus signatures can only stop known malware. A sandbox is a critical defense against unknown, zero-day malware. This lesson explains how firewalls use isolated sandbox environments to safely detonate and analyze suspicious files, protecting the network from previously unseen threats.",
                "sections": [
                    {
                        "title": "What is a Sandbox?",
                        "content": "<p>A network security sandbox is a controlled, isolated virtual environment (typically a virtual machine) designed to analyze the behavior of suspicious files. When a user tries to download a file that is unknown to the firewall's antivirus engine, the firewall can forward a copy of that file to the sandbox for analysis.</p>",
                        "image": "https://images.unsplash.com/photo-1547637581-8173514978a3?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Analyzing Files in Isolation",
                        "content": "<p>Inside the sandbox, the file is opened or executed to observe its behavior.</p><h3>The Sandbox Monitors for Malicious Indicators:</h3><ul><li>Does the file make suspicious network connections to known command-and-control servers?</li><li>Does it modify critical system files or registry keys?</li><li>Does it attempt to encrypt files (ransomware behavior)?</li><li>Does it try to exploit a known vulnerability in an application like Adobe Reader?</li></ul><p>Based on this behavioral analysis, the sandbox assigns a verdict: benign, grayware, or malicious.</p>",
                        "image": "https://images.unsplash.com/photo-1589987879922-263a23a854cb?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Firewall Integration",
                        "content": "<p>The sandbox's verdict is useless unless it can be acted upon.</p><h3>The Workflow:</h3><ol><li>A user downloads an unknown file. The firewall allows the download to complete so as not to impact user experience, but it also sends a copy of the file to the sandbox.</li><li>The sandbox analyzes the file and determines it is malicious.</li><li>The sandbox sends the verdict and identifying information (file hash, C2 domains) back to the firewall.</li><li>The firewall automatically creates a new, temporary signature for the now-identified malware. It blocks the file hash and any C2 domains associated with it.</li><li>The firewall can also scan its logs to see if any other users have downloaded the same file and identify the infected host for remediation.</li></ol><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Cloud vs. On-Premise</strong></div><p>Many vendors offer cloud-based sandboxing services, which are easy to set up. On-premise sandboxes offer more control and may be required for organizations that cannot send sensitive files to the cloud for analysis.</p></div>",
                        "image": "https://images.unsplash.com/photo-1518773553398-650c184e0bb3?w=800&h=400&fit=crop"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary purpose of a network security sandbox?",
                        "options": [
                            "To store backup copies of firewall configurations.",
                            "To provide a playground for network administrators to test new rules.",
                            "To safely execute and analyze unknown files to determine if they are malicious.",
                            "To filter web traffic based on URL categories."
                        ],
                        "correct": 2,
                        "explanation": "A sandbox is a secure, isolated environment where a potentially malicious file can be 'detonated' to observe its behavior without any risk to the production network."
                    },
                    {
                        "id": 2,
                        "question": "Sandboxing is most effective at detecting what type of threat?",
                        "options": [
                            "Known viruses with existing antivirus signatures.",
                            "Network port scans.",
                            "Unknown, zero-day malware.",
                            "Phishing emails."
                        ],
                        "correct": 2,
                        "explanation": "Since sandboxing analyzes behavior, not just static signatures, it can identify a file as malicious even if the specific malware has never been seen before."
                    },
                    {
                        "id": 3,
                        "question": "After a sandbox determines a file is malicious, what is the most important next step?",
                        "options": [
                            "Delete the sandbox virtual machine.",
                            "The sandbox sends the verdict back to the firewall so it can automatically create a signature and block the threat.",
                            "Email a report to the CEO.",
                            "Do nothing."
                        ],
                        "correct": 1,
                        "explanation": "The analysis is only useful if it leads to protection. The integration between the sandbox and the firewall allows for the automated creation of new protections based on the sandbox's findings."
                    }
                ]
            }
        },
        {
            "id": "lesson-13",
            "title": "Web and URL Filtering",
            "duration": "90 min",
            "objectives": [
                "Understand the purpose of URL filtering",
                "Explain how category-based filtering works",
                "Configure custom block and allow lists",
                "Integrate URL filtering into firewall policies"
            ],
            "content": {
                "overview": "Controlling access to the web is a fundamental security requirement for any organization. This lesson covers URL filtering, a feature that allows administrators to block access to malicious or inappropriate websites based on their category, reputation, and custom lists, enforcing corporate acceptable use policies.",
                "sections": [
                    {
                        "title": "Controlling Web Access",
                        "content": "<p>URL filtering moves beyond blocking IPs and ports to control access based on the website's identity (its URL) and category.</p><h3>Why it's Necessary:</h3><ul><li><strong>Security:</strong> Blocking access to known malicious websites that host malware, phishing pages, or command-and-control servers.</li><li><strong>Productivity:</strong> Limiting access to time-wasting categories like social media, streaming video, or online gaming during work hours.</li><li><strong>Compliance and HR Policy:</strong> Blocking access to illegal or inappropriate content, such as gambling, adult content, or hate speech.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1516321497487-e288fb19713f?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Category-Based Filtering",
                        "content": "<p>Manually blocking every bad website is impossible. URL filtering services, maintained by the firewall vendor, do the heavy lifting by categorizing millions of websites on the internet.</p><h3>How it Works:</h3><ul><li>The firewall vendor uses web crawlers and machine learning to analyze websites and place them into categories (e.g., 'news', 'social-networking', 'malware', 'finance', 'gambling').</li><li>The firewall downloads this massive database of categories.</li><li>The administrator creates a policy, for example: 'Block the categories: gambling, adult-content, malware'.</li><li>When a user tries to visit a website, the firewall looks up the URL in its local database or queries the vendor's cloud service to find its category. If the category is on the block list, the user is denied access and shown a block page.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1506157786151-b8491531f063?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Custom Lists and Policy",
                        "content": "<p>Category databases are not perfect. Administrators always need the ability to override the vendor's categorization.</p><h3>Common Overrides:</h3><ul><li><strong>Custom Block List (Blacklist):</strong> A list of specific URLs or domains that should always be blocked, regardless of their category.</li><li><strong>Custom Allow List (Whitelist):</strong> A list of specific URLs that should always be allowed, even if they fall into a blocked category. This is often used for business-critical websites that are miscategorized.</li></ul><div class='info-box tip'><div class='info-box-header'><i class='fas fa-lightbulb'></i><strong>Policy Integration</strong></div><p>URL filtering isn't an all-or-nothing setting. It's a profile that can be applied to firewall rules. This allows for granular control. For example, the 'Sales' user group could be blocked from 'social-networking', but the 'Marketing' group could be allowed.</p></div>",
                        "image": "https://images.unsplash.com/photo-1533709752211-118fcaf03312?w=800&h=400&fit=crop"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary function of URL filtering on an NGFW?",
                        "options": [
                            "To scan files for viruses.",
                            "To block access to websites based on their category, reputation, or a custom list.",
                            "To provide remote access to the network.",
                            "To detect network intrusions."
                        ],
                        "correct": 1,
                        "explanation": "URL filtering is specifically designed to control web access at the domain/URL level, enforcing both security and corporate acceptable use policies."
                    },
                    {
                        "id": 2,
                        "question": "How does a firewall's category-based filtering feature work?",
                        "options": [
                            "It asks the user to categorize every website they visit.",
                            "It uses a large, vendor-maintained database that classifies millions of websites into categories like 'malware', 'news', etc.",
                            "It blocks every website by default.",
                            "It only categorizes websites based on their IP address."
                        ],
                        "correct": 1,
                        "explanation": "The power of URL filtering comes from the vendor's cloud intelligence, which constantly crawls and categorizes the web, allowing administrators to create broad policies without having to manage individual URLs."
                    },
                    {
                        "id": 3,
                        "question": "An administrator wants to block all 'social-networking' sites, but needs to allow access to a specific business-related site that happens to be in that category. What should they do?",
                        "options": [
                            "Unblock the entire 'social-networking' category.",
                            "Manually block every other social networking site one by one.",
                            "Add the specific business site to a custom URL allow list (whitelist).",
                            "It is not possible to do this."
                        ],
                        "correct": 2,
                        "explanation": "Custom allow/block lists are used to override the main category database. Placing the site on the allow list will create an exception to the category block rule."
                    }
                ]
            }
        },
        {
            "id": "lesson-14",
            "title": "File and Content Filtering",
            "duration": "100 min",
            "objectives": [
                "Understand how firewalls can control file transfers based on type",
                "Define Data Loss Prevention (DLP) at the network gateway",
                "Explain how DLP uses patterns to detect sensitive data",
                "Configure a policy to block the transfer of executable files"
            ],
            "content": {
                "overview": "Beyond just controlling which websites users can visit, modern firewalls can inspect the content being transferred to and from those sites. This lesson covers how firewalls can block specific file types to prevent malware downloads and introduces Data Loss Prevention (DLP) for identifying and blocking the exfiltration of sensitive corporate data.",
                "sections": [
                    {
                        "title": "File Blocking by Type",
                        "content": "<p>One of the most common ways malware is delivered is through executable files downloaded from the web or attached to emails. Firewalls can identify and block files based on their actual type, not just their file extension.</p><h3>How it Works:</h3><p>The firewall inspects the file's header (the 'magic number') to determine its true type. This prevents simple evasion where an attacker renames `malware.exe` to `invoice.pdf`. The administrator can create policies like:</p><ul><li>Block all executable (`.exe`, `.dll`, `.msi`) files from being downloaded from any website categorized as 'high-risk'.</li><li>Allow `.pdf` files, but send any downloaded PDFs to the sandbox for inspection.</li><li>Block the transfer of `.zip` files that are password-protected, as their content cannot be inspected.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Introduction to Data Loss Prevention (DLP)",
                        "content": "<p>Data Loss Prevention (DLP) is a technology designed to stop sensitive data from leaving the corporate network. While full-featured DLP is a complex, dedicated product, many NGFWs offer a lightweight version that can inspect network traffic for specific data patterns.</p><h3>The Goal:</h3><p>To prevent the accidental or malicious exfiltration of confidential information, such as customer data, financial records, or intellectual property.</p>",
                        "image": "https://images.unsplash.com/photo-1556742502-ec7c0e9f34b1?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Pattern-Based Detection",
                        "content": "<p>Firewall DLP works by scanning outbound traffic (e.g., web uploads, emails) for data that matches pre-defined or custom patterns.</p><h3>Common Patterns:</h3><ul><li><strong>Credit Card Numbers:</strong> The engine looks for numbers that match the Luhn algorithm used to validate credit card numbers.</li><li><strong>Social Security Numbers (SSN):</strong> Looks for the pattern `###-##-####`.</li><li><strong>Financial Data:</strong> Keywords like 'confidential', 'financial statement', etc.</li><li><strong>Custom Patterns:</strong> Administrators can create their own regular expressions to look for company-specific data, like project codenames or customer ID formats.</li></ul><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Actionable Intelligence</strong></div><p>When a DLP rule is triggered, the action can be to simply log the event for auditing purposes, or to actively block the transfer and alert the security team.</p></div>",
                        "image": "https://images.unsplash.com/photo-1600195077909-46e573870d99?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "DLP Rule (Conceptual)",
                        "language": "pseudocode",
                        "code": "# This rule inspects all outbound traffic from the LAN for data matching\n# the 'Credit_Card_Data' profile.\n\nRULE ID=201\n  NAME='Prevent Credit Card Data Exfiltration'\n  SOURCE_ZONE=LAN\n  SOURCE_USER_GROUP=ANY\n  DESTINATION_ZONE=WAN\n  DESTINATION_IP=ANY\n  APPLICATION=ANY\n  \n  # Apply the DLP Profile\n  DLP_PROFILE='Credit_Card_Data_Profile'\n  \n  # Block the transfer and generate a high-priority alert\n  ACTION=BLOCK_AND_LOG"
                    },
                    {
                        "title": "File Blocking Rule (Conceptual)",
                        "language": "pseudocode",
                        "code": "# This rule blocks executable files for most users\n# but allows IT Admins to download them.\n\nRULE ID=202\n  NAME='Block Executable Downloads'\n  SOURCE_ZONE=LAN\n  SOURCE_USER_GROUP='All_Users' (Excluding IT-Admins)\n  DESTINATION_ZONE=WAN\n  FILE_TYPE='executable'\n  ACTION=BLOCK"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "How does a firewall accurately identify a file's type, even if an attacker has changed its extension?",
                        "options": [
                            "It asks the user to confirm the file type.",
                            "It guesses based on the file's size.",
                            "It inspects the file's header data (its 'magic number') to determine the true type.",
                            "It only trusts the file extension."
                        ],
                        "correct": 2,
                        "explanation": "Relying on file extensions is insecure. Modern firewalls perform true file-type identification by examining the binary content of the file's header to prevent simple evasion."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary goal of a Data Loss Prevention (DLP) system?",
                        "options": [
                            "To prevent malware from entering the network.",
                            "To provide VPN access for remote users.",
                            "To identify and block sensitive, confidential data from leaving the network.",
                            "To speed up internet access."
                        ],
                        "correct": 2,
                        "explanation": "DLP is focused on outbound traffic, with the goal of preventing data exfiltration, whether it's accidental (an employee emailing a customer list to their personal account) or malicious (an attacker stealing data)."
                    },
                    {
                        "id": 3,
                        "question": "A firewall's DLP engine is configured to look for numbers that fit the pattern `###-##-####`. What type of sensitive data is it most likely trying to detect?",
                        "options": [
                            "Credit Card Numbers",
                            "IP Addresses",
                            "Social Security Numbers (SSNs)",
                            "Phone Numbers"
                        ],
                        "correct": 2,
                        "explanation": "This specific numeric pattern is the standard format for U.S. Social Security Numbers, which is a common pre-defined pattern in many DLP systems."
                    }
                ]
            }
        },
        {
            "id": "lesson-15",
            "title": "Antivirus Gateway",
            "duration": "90 min",
            "objectives": [
                "Understand the role of a network antivirus gateway",
                "Differentiate between stream-based and proxy-based scanning",
                "Explain the importance of signature database updates",
                "Recognize the limitations of network-level antivirus"
            ],
            "content": {
                "overview": "While endpoint antivirus is essential, stopping malware at the network gateway provides a critical first line of defense. This lesson covers how firewall antivirus engines scan network traffic for known viruses and malware, the different scanning methods they employ, and why it serves as a complement to, not a replacement for, endpoint protection.",
                "sections": [
                    {
                        "title": "Scanning Traffic for Malware",
                        "content": "<p>A gateway antivirus (AV) engine is a component of a UTM or NGFW that scans network traffic for malware signatures. It can scan common protocols where malware is transferred, such as HTTP, FTP, SMTP, and POP3.</p><h3>The Workflow:</h3><ol><li>The firewall reassembles packets into a file or data stream.</li><li>This file is scanned against a database of known malware signatures.</li><li>If a signature is matched, the firewall blocks the file transfer and logs the event.</li><li>If no match is found, the file is allowed to proceed (though it might still be sent to a sandbox if it's unknown).</li></ul>",
                        "image": "https://images.unsplash.com/photo-1618498082410-b4aa22193b38?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Stream-Based vs. Proxy-Based Scanning",
                        "content": "<ul><li><strong>Stream-Based Scanning:</strong> This is a more modern, high-performance method. The firewall begins scanning the file as it is being streamed through the device. It can often detect the malware signature before the entire file has been transferred. If a threat is found, it can block the connection mid-stream. This results in lower latency for the user.</li><li><strong>Proxy-Based Scanning (Store-and-Forward):</strong> This is an older method. The firewall acts as a proxy, downloading the entire file into its own memory buffer first. Once the complete file is received, it scans it. Only after the scan is complete and the file is deemed safe is it then forwarded to the user. This method is more thorough but introduces noticeable latency, especially for large files.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1599507593498-52ed8a45e755?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Signatures and Limitations",
                        "content": "<p>Like any signature-based system, a gateway AV is only as good as its last update. Firewall vendors constantly release new signature packages to protect against newly discovered malware. It is critical that the firewall has an active subscription and is configured to check for and install these updates frequently.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Not a Replacement for Endpoint AV</strong></div><p>Gateway AV is a powerful layer of defense, but it is not foolproof. It cannot scan encrypted traffic (without decryption) and cannot protect against threats that come in through other means (like a malicious USB drive). A robust, up-to-date antivirus solution on every endpoint (computer, server) is still absolutely necessary.</p></div>",
                        "image": "https://images.unsplash.com/photo-1614064548237-02f0d1a2b733?w=800&h=400&fit=crop"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary function of an antivirus gateway on a firewall?",
                        "options": [
                            "To scan the hard drives of computers on the network.",
                            "To scan network traffic for known malware signatures as it passes through the firewall.",
                            "To provide a secure remote desktop connection.",
                            "To filter spam emails."
                        ],
                        "correct": 1,
                        "explanation": "A gateway AV operates at the network perimeter, inspecting files being transferred over protocols like HTTP and SMTP to stop malware before it ever reaches the endpoint."
                    },
                    {
                        "id": 2,
                        "question": "Which antivirus scanning method offers lower latency by inspecting files as they pass through the device, rather than waiting for the entire file to download first?",
                        "options": [
                            "Proxy-Based Scanning",
                            "Stream-Based Scanning",
                            "Offline Scanning",
                            "Endpoint Scanning"
                        ],
                        "correct": 1,
                        "explanation": "Stream-based scanning improves performance and user experience because it doesn't need to buffer the entire file, which can be very slow for large downloads."
                    },
                    {
                        "id": 3,
                        "question": "Why is a gateway antivirus not a complete replacement for endpoint antivirus software?",
                        "options": [
                            "Gateway AV is more expensive.",
                            "It cannot protect against threats that do not pass through the firewall, such as a malicious USB drive.",
                            "It cannot be updated.",
                            "Endpoint AV is easier to manage."
                        ],
                        "correct": 1,
                        "explanation": "The principle of defense-in-depth requires multiple layers of security. Gateway AV protects the perimeter, but endpoint AV is the last line of defense for threats that originate locally or bypass the firewall (e.g., inside encrypted traffic)."
                    }
                ]
            }
        },
        {
            "id": "lesson-16",
            "title": "Integrating Threat Intelligence Feeds",
            "duration": "100 min",
            "objectives": [
                "Define what a threat intelligence feed is",
                "Differentiate between open-source and commercial feeds",
                "Explain how a firewall automates protection using these feeds",
                "Recognize the importance of indicators of compromise (IoCs)"
            ],
            "content": {
                "overview": "The threat landscape changes by the minute. Manually updating block lists is an impossible task. This lesson covers how modern firewalls can subscribe to threat intelligence feeds—dynamic lists of known malicious indicators—to automate and proactively block emerging threats with minimal human intervention.",
                "sections": [
                    {
                        "title": "What is Threat Intelligence?",
                        "content": "<p>Threat intelligence is evidence-based knowledge about existing or emerging threats. In the context of a firewall, this knowledge is delivered in a machine-readable format and consists of lists of indicators of compromise (IoCs).</p><h3>Common IoCs in Feeds:</h3><ul><li><strong>IP Addresses:</strong> Known malware C2 servers, botnet controllers, scanners.</li><li><strong>Domains:</strong> Phishing sites, domains that host malware.</li><li><strong>URLs:</strong> The full path to a malicious file or page.</li><li><strong>File Hashes:</strong> Cryptographic hashes (MD5, SHA256) of known malware files.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1526374965328-5f61d25c16c6?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Consuming Threat Feeds",
                        "content": "<p>Firewalls can consume these feeds, which are essentially dynamic block lists, to enhance their security posture.</p><h3>How it Works:</h3><ol><li>The firewall is configured to subscribe to one or more threat feeds. These can be open-source feeds (like AlienVault OTX), commercial feeds from security vendors, or industry-specific feeds.</li><li>The firewall periodically (e.g., every hour) connects to the feed's server and downloads the latest list of IoCs.</li><li>These lists are automatically populated into special 'External Block Lists' or 'Dynamic Address Groups' on the firewall.</li><li>The administrator writes a single rule: 'Drop any traffic to or from any address in the External Block List'.</li></ol><p>This automates the process of blocking newly discovered malicious infrastructure around the world.</p>",
                        "image": "https://images.unsplash.com/photo-1510915228340-29c85a43dcfe?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Proactive Defense",
                        "content": "<p>Using threat intelligence feeds shifts the firewall from a purely reactive stance to a more proactive one. Instead of waiting to be attacked by a known bad IP, the firewall already knows the IP is bad and blocks the connection before it can even be established.</p><div class='info-box tip'><div class='info-box-header'><i class='fas fa-lightbulb'></i><strong>Beyond Blocking</strong></div><p>These feeds can also be used for detection. An administrator could set the rule to 'alert' instead of 'drop' for traffic involving an IoC. An alert for an internal host trying to connect *outbound* to a known botnet C2 server is a very strong indicator that the host is already compromised.</p></div>",
                        "image": "https://images.unsplash.com/photo-1563986768609-322da13575f3?w=800&h=400&fit=crop"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is a threat intelligence feed in the context of a firewall?",
                        "options": [
                            "A news report about recent cyber attacks.",
                            "A real-time video feed from a security operations center.",
                            "A machine-readable, dynamic list of indicators of compromise (IoCs) like malicious IP addresses and domains.",
                            "A software update for the firewall's firmware."
                        ],
                        "correct": 2,
                        "explanation": "A threat feed is a data source that provides actionable intelligence, allowing the firewall to automatically update its knowledge of malicious infrastructure on the internet."
                    },
                    {
                        "id": 2,
                        "question": "The IP address of a known botnet command-and-control server is an example of what?",
                        "options": [
                            "A firewall rule.",
                            "A user group.",
                            "An Indicator of Compromise (IoC).",
                            "A VPN tunnel."
                        ],
                        "correct": 2,
                        "explanation": "IoCs are the individual pieces of data (like IPs, hashes, or domains) that constitute a threat intelligence feed."
                    },
                    {
                        "id": 3,
                        "question": "What is the primary benefit of integrating a threat intelligence feed with a firewall?",
                        "options": [
                            "It makes the firewall's user interface look better.",
                            "It automates the process of blocking newly discovered malicious IPs and domains, providing proactive protection.",
                            "It reduces the firewall's CPU usage.",
                            "It is required for the firewall to be able to route traffic."
                        ],
                        "correct": 1,
                        "explanation": "Automation is the key benefit. It's impossible for a human administrator to keep up with the thousands of new malicious hosts that appear daily. Threat feeds automate this process."
                    }
                ]
            }
        },
        {
            "id": "lesson-17",
            "title": "DNS Filtering and Security",
            "duration": "90 min",
            "objectives": [
                "Understand the role of DNS in network communication",
                "Explain how DNS can be used as a security enforcement layer",
                "Define DNS Sinkholing",
                "Configure a firewall to block malicious DNS requests"
            ],
            "content": {
                "overview": "Nearly every network connection begins with a DNS query. This makes DNS a powerful and early point for security enforcement. This lesson covers how firewalls can apply security policies to DNS traffic, blocking requests for malicious domains and using a technique called 'sinkholing' to identify already-compromised clients on the internal network.",
                "sections": [
                    {
                        "title": "DNS as a Control Point",
                        "content": "<p>The Domain Name System (DNS) translates human-readable domain names (like `www.google.com`) into machine-readable IP addresses. If a client cannot resolve the IP address of a malicious site, it can never connect to it. This makes DNS filtering a highly efficient first line of defense.</p>",
                        "image": "https://images.unsplash.com/photo-1544197150-b2c4c64e91c2?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "DNS Filtering",
                        "content": "<p>Similar to URL filtering, DNS filtering uses a category database of domains. When a client sends a DNS query through the firewall, the firewall checks the requested domain against this database.</p><h3>Policy Actions:</h3><ul><li>If the domain is in a malicious category (e.g., 'malware', 'phishing', 'command-and-control'), the firewall can simply block the DNS response, preventing the client from ever learning the malicious IP.</li><li>Alternatively, the firewall can forge a response, replying with a 'domain not found' error or redirecting the user to a block page.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "DNS Sinkholing",
                        "content": "<p>DNS sinkholing is a powerful technique for identifying infected clients. When a firewall detects a DNS query for a known malicious domain, instead of just blocking it, it forges a reply and sends back the IP address of a 'sinkhole' server controlled by the administrator.</p><h3>The Workflow:</h3><ol><li>An already-compromised client on the LAN tries to 'phone home' by looking up the domain of its C2 server (e.g., `badguy-c2.com`).</li><li>The firewall's DNS security engine detects this malicious query.</li><li>Instead of blocking, the firewall replies with the IP address of the internal sinkhole server (e.g., `10.255.255.254`).</li><li>The infected client, now having 'resolved' the domain, attempts to start a connection to the sinkhole server's IP.</li><li>The firewall logs this connection attempt. The administrator now has a definitive log showing the IP address of the infected client (`Source IP`) that needs to be remediated.</li></ol>",
                        "image": "https://images.unsplash.com/photo-1600195077909-46e573870d99?w=800&h=400&fit=crop"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "Why is DNS an effective point for security enforcement?",
                        "options": [
                            "Because DNS traffic is always unencrypted.",
                            "Because nearly every network connection starts with a DNS query, allowing threats to be blocked before the connection is even attempted.",
                            "Because DNS servers are managed by security professionals.",
                            "Because DNS is the fastest protocol."
                        ],
                        "correct": 1,
                        "explanation": "Blocking a threat at the DNS level is highly efficient. If a client can't get the IP address of a malicious server, it can't connect, and no further inspection of IP packets is needed."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary goal of DNS Sinkholing?",
                        "options": [
                            "To make DNS resolution faster.",
                            "To block all DNS traffic from leaving the network.",
                            "To identify compromised clients inside the network by tricking them into connecting to a controlled server.",
                            "To provide a backup DNS server."
                        ],
                        "correct": 2,
                        "explanation": "The purpose of a sinkhole is to get an actionable log. By tricking the malware into revealing itself by connecting to the sinkhole server, administrators can pinpoint exactly which internal machine is infected."
                    },
                    {
                        "id": 3,
                        "question": "A firewall's DNS filter sees a request for a domain that is categorized as 'phishing'. What is the most likely action it will take?",
                        "options": [
                            "Allow the request and log it.",
                            "Forward the request to a different DNS server.",
                            "Block the DNS response or forge a reply to prevent the client from resolving the domain's IP address.",
                            "Shut down the client's network interface."
                        ],
                        "correct": 2,
                        "explanation": "The firewall's goal is to prevent the user from ever reaching the phishing site. The most effective way to do this is to interfere with the DNS resolution so the user's browser never gets the malicious IP address."
                    }
                ]
            }
        },
        {
            "id": "lesson-18",
            "title": "VPN Fundamentals",
            "duration": "90 min",
            "objectives": [
                "Define the purpose of a Virtual Private Network (VPN)",
                "Explain the core concepts of tunneling, encryption, and authentication",
                "Differentiate between Site-to-Site and Remote Access VPNs",
                "Recognize the role of a firewall as a VPN concentrator"
            ],
            "content": {
                "overview": "Businesses need to securely connect their networks and users over the untrusted internet. This is the primary role of a Virtual Private Network (VPN). This lesson introduces the fundamental concepts behind VPNs, explaining how they create a secure, private 'tunnel' across a public network and differentiating between the two main types: site-to-site and remote access.",
                "sections": [
                    {
                        "title": "Creating a Private Network over a Public One",
                        "content": "<p>A VPN extends a private network across a public network, like the internet. It enables users to send and receive data as if their devices were directly connected to the private network.</p><h3>The Three Pillars of VPNs:</h3><ul><li><strong>Tunneling:</strong> The process of encapsulating an entire network packet (including its private source and destination IPs) inside another packet, which has public IP addresses for routing over the internet.</li><li><strong>Encryption:</strong> The data inside the tunnel is encrypted. Anyone sniffing the packets on the internet can see the outer packet, but the inner, private data is unreadable.</li><li><strong>Authentication:</strong> The endpoints of the VPN tunnel (e.g., two firewalls, or a user's laptop and a firewall) must prove their identities to each other before the secure tunnel can be established. This is done using pre-shared keys or digital certificates.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Site-to-Site VPNs",
                        "content": "<p>A site-to-site VPN connects two entire networks together, typically between a headquarters and a branch office. The VPN tunnel is established between two firewalls or routers.</p><h3>Characteristics:</h3><ul><li>The process is transparent to users. A user in the branch office can access a server at headquarters using its private IP address, just as if it were on their local LAN.</li><li>The firewall at each end is responsible for encrypting and routing the traffic destined for the other site through the tunnel.</li><li>Also known as a LAN-to-LAN VPN.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Remote Access VPNs",
                        "content": "<p>A remote access VPN connects an individual device (e.g., a laptop of a remote employee) to the corporate network.</p><h3>Characteristics:</h3><ul><li>Requires a software client to be installed on the end-user's device.</li><li>The user initiates the connection and authenticates with a username and password (and often multi-factor authentication).</li><li>The VPN tunnel is established between the user's laptop and the corporate firewall (which acts as a VPN concentrator).</li><li>Once connected, the remote user's device is virtually on the corporate LAN and can access internal resources.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1587620962725-abab7fe55159?w=800&h=400&fit=crop"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the process of wrapping one network packet inside another for transmission over the internet called?",
                        "options": [
                            "Encryption",
                            "Authentication",
                            "Tunneling",
                            "Routing"
                        ],
                        "correct": 2,
                        "explanation": "Tunneling is the core concept where a private packet is encapsulated inside a public packet to traverse the internet. Encryption then protects the contents of that tunnel."
                    },
                    {
                        "id": 2,
                        "question": "A VPN that connects a branch office network to a headquarters network, with the connection being handled by firewalls at each end, is known as what type of VPN?",
                        "options": [
                            "Remote Access VPN",
                            "Client-to-Server VPN",
                            "Site-to-Site VPN",
                            "Host-to-Host VPN"
                        ],
                        "correct": 2,
                        "explanation": "A site-to-site (or LAN-to-LAN) VPN is used to connect two or more networks together in a way that is transparent to the end-users."
                    },
                    {
                        "id": 3,
                        "question": "A remote employee working from home uses a software client on their laptop to connect to the corporate network. What type of VPN is this?",
                        "options": [
                            "Site-to-Site VPN",
                            "Remote Access VPN",
                            "Network-to-Network VPN",
                            "Firewall-to-Firewall VPN"
                        ],
                        "correct": 1,
                        "explanation": "A remote access VPN is designed to connect an individual endpoint device (like a laptop or phone) to a central network, requiring a software client on the device."
                    }
                ]
            }
        },
        {
            "id": "lesson-19",
            "title": "IPsec VPNs",
            "duration": "120 min",
            "objectives": [
                "Describe the IPsec protocol suite",
                "Understand the two phases of an IPsec negotiation (IKE Phase 1 and Phase 2)",
                "Differentiate between ESP and AH",
                "Configure a basic site-to-site IPsec tunnel"
            ],
            "content": {
                "overview": "IPsec is the industry-standard protocol for creating secure and robust site-to-site VPNs. This lesson takes a deep dive into the IPsec protocol suite, breaking down the complex negotiation process into its two main phases and explaining the roles of its various components like IKE, ESP, and AH.",
                "sections": [
                    {
                        "title": "The IPsec Protocol Suite",
                        "content": "<p>IPsec is not a single protocol, but a framework of open standards working together to provide security.</p><h3>Key Components:</h3><ul><li><strong>Internet Key Exchange (IKE):</strong> The protocol used to negotiate the VPN tunnel. It handles authentication and the secure exchange of cryptographic keys. It comes in two versions, IKEv1 and IKEv2 (which is more modern and efficient).</li><li><strong>Encapsulating Security Payload (ESP):</strong> This protocol provides the confidentiality (encryption) and integrity (authentication) for the data being sent through the tunnel. It's the most common protocol used to carry the actual data.</li><li><strong>Authentication Header (AH):</strong> This protocol provides integrity and authentication but does NOT provide encryption. It is rarely used today as ESP provides both.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1542831371-d531d36971ad?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "IKE Phase 1: Building the Management Tunnel",
                        "content": "<p>The first phase of the negotiation builds a secure management channel, called the IKE Security Association (SA). Its only purpose is to protect the negotiations for the actual data tunnel.</p><h3>Key Steps:</h3><ol><li>The two firewalls (peers) authenticate each other, using either a pre-shared key (a shared secret) or digital certificates.</li><li>They agree on a set of cryptographic parameters: an encryption algorithm (e.g., AES-256), a hashing algorithm (e.g., SHA-256), and a Diffie-Hellman (DH) group for key exchange.</li><li>The result is a secure, authenticated IKE SA tunnel.</li></ol>",
                        "image": "https://images.unsplash.com/photo-1526374965328-5f61d25c16c6?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "IKE Phase 2: Building the Data Tunnel",
                        "content": "<p>With the protection of the Phase 1 tunnel, the peers now negotiate the parameters for the tunnel that will carry the actual user data. This is called the IPsec SA.</p><h3>Key Steps:</h3><ol><li>The peers negotiate the 'traffic selectors' or 'proxy IDs', which define what traffic is interesting and should be encrypted and sent through the tunnel (e.g., traffic from LAN A to LAN B).</li><li>They agree on a set of cryptographic parameters for the data itself, typically using ESP. These can be different from the Phase 1 parameters.</li><li>The result is one or more IPsec SA tunnels (one for each direction) ready to encrypt and transport user data.</li></ol>",
                        "image": "https://images.unsplash.com/photo-1461749280684-dccba630e2f6?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "strongSwan IPsec Config (Site-to-Site)",
                        "language": "ini",
                        "code": "# /etc/ipsec.conf - Basic Site-to-Site Connection using a pre-shared key\n\nconn site-to-site-vpn\n    # Phase 1 Parameters\n    keyexchange=ikev2\n    ike=aes256-sha256-modp2048!\n    authby=secret # Use a pre-shared key for authentication\n\n    # Phase 2 Parameters\n    esp=aes256-sha256!\n\n    # Local (Left) Peer Configuration\n    left=%defaultroute # Use the default route interface IP\n    leftid=@branch.example.com # ID for authentication\n    leftsubnet=192.168.10.0/24 # Traffic selector: local LAN\n\n    # Remote (Right) Peer Configuration\n    right=203.0.113.5 # Public IP of the remote firewall\n    rightid=@hq.example.com # Remote ID for authentication\n    rightsubnet=10.0.0.0/16 # Traffic selector: remote LAN\n\n    # General Options\n    auto=start # Automatically start the connection"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "In the IPsec suite, which protocol is responsible for negotiating the tunnel parameters and authenticating the peers?",
                        "options": [
                            "ESP (Encapsulating Security Payload)",
                            "AH (Authentication Header)",
                            "IKE (Internet Key Exchange)",
                            "TCP (Transmission Control Protocol)"
                        ],
                        "correct": 2,
                        "explanation": "IKE is the 'management' protocol of IPsec. Its job is to set up the secure channel by handling authentication and key exchange so that ESP can then transport the data."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary purpose of IKE Phase 1?",
                        "options": [
                            "To encrypt and transport the user's data.",
                            "To create a secure management tunnel to protect the negotiations for Phase 2.",
                            "To define which traffic should go through the VPN.",
                            "To compress the data before sending."
                        ],
                        "correct": 1,
                        "explanation": "Phase 1 is all about setting the stage. It creates a secure channel so that the details of the actual data tunnel (like traffic selectors) can be negotiated securely in Phase 2."
                    },
                    {
                        "id": 3,
                        "question": "Which IPsec protocol provides both confidentiality (encryption) and integrity for the user data traveling through the VPN tunnel?",
                        "options": [
                            "AH (Authentication Header)",
                            "IKEv2",
                            "ESP (Encapsulating Security Payload)",
                            "Diffie-Hellman"
                        ],
                        "correct": 2,
                        "explanation": "ESP is the workhorse of IPsec, responsible for actually encapsulating, encrypting, and authenticating the user data packets. AH only provides authentication and is rarely used alone."
                    }
                ]
            }
        },
        {
            "id": "lesson-20",
            "title": "SSL/TLS VPNs",
            "duration": "100 min",
            "objectives": [
                "Understand the advantages of SSL/TLS VPNs, particularly for remote access",
                "Differentiate between clientless (portal) and client-based SSL VPNs",
                "Explain how SSL VPNs can easily traverse NAT and restrictive firewalls",
                "Review a basic OpenVPN configuration"
            ],
            "content": {
                "overview": "While IPsec dominates the site-to-site world, SSL/TLS has become the protocol of choice for remote access VPNs. This lesson explores the advantages of using the same protocol that secures websites (HTTPS) for VPN access, covering the different deployment modes and explaining why it is often easier for remote users to connect with an SSL VPN.",
                "sections": [
                    {
                        "title": "Why Use SSL/TLS for VPNs?",
                        "content": "<p>SSL/TLS VPNs leverage the Transport Layer Security protocol, which is the foundation of all secure web traffic (HTTPS). This provides several key advantages.</p><h3>Primary Advantage: Traversing Firewalls</h3><p>IPsec uses protocols (ESP, AH) and ports (UDP 500, 4500) that are often blocked by restrictive firewalls in places like hotels, airports, and coffee shops. SSL/TLS VPN traffic, however, looks just like standard HTTPS traffic because it runs over TCP port 443. Since virtually no network blocks port 443, SSL VPNs are far more likely to connect successfully from any location.</p>",
                        "image": "https://images.unsplash.com/photo-1563986768609-322da13575f3?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Clientless (Portal-Based) SSL VPN",
                        "content": "<p>A clientless SSL VPN provides access to internal resources through a web browser, with no dedicated VPN software required on the user's device.</p><h3>How it Works:</h3><ul><li>The user navigates to a public URL (e.g., `https://vpn.mycompany.com`) and logs in.</li><li>The firewall presents a secure web portal with links to internal applications (e.g., webmail, intranet sites, remote desktop).</li><li>When the user clicks a link, the firewall proxies the connection for them.</li><li>This provides limited, application-level access and is ideal for low-privilege users or those on unmanaged devices.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1506157786151-b8491531f063?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Client-Based SSL VPN",
                        "content": "<p>A client-based SSL VPN requires a small software client (like OpenVPN or a vendor-specific client) to be installed on the user's computer. It provides full network-level access, similar to an IPsec remote access VPN.</p><h3>How it Works:</h3><ul><li>The user launches the client, authenticates, and establishes a secure tunnel to the firewall.</li><li>The firewall creates a virtual network interface (a 'TUN' adapter) on the user's computer and assigns it an IP address from the corporate network.</li><li>All (or a portion) of the user's traffic is now routed through this secure tunnel to the corporate firewall.</li><li>This provides full access to all network resources (servers, printers, etc.) as if the user were physically in the office.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1587620962725-abab7fe55159?w=800&h=400&fit=crop"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the main reason SSL/TLS VPNs are often more reliable for remote users than IPsec VPNs?",
                        "options": [
                            "They offer stronger encryption.",
                            "They run over standard ports like TCP 443, which are almost never blocked by other firewalls.",
                            "They do not require authentication.",
                            "They are a much older technology."
                        ],
                        "correct": 1,
                        "explanation": "The ability to masquerade as standard HTTPS traffic allows SSL VPNs to easily traverse restrictive NAT gateways and firewalls that might block the specific protocols and ports used by IPsec."
                    },
                    {
                        "id": 2,
                        "question": "A user connects to their company's network by logging into a web page that provides links to internal web applications. They did not have to install any special software. What type of VPN are they using?",
                        "options": [
                            "IPsec Site-to-Site VPN",
                            "Client-based SSL VPN",
                            "Clientless (Portal-Based) SSL VPN",
                            "DirectAccess"
                        ],
                        "correct": 2,
                        "explanation": "'Clientless' is the key. Access is provided entirely through the web browser, making it ideal for quick access to web-based apps without needing to install a full VPN client."
                    },
                    {
                        "id": 3,
                        "question": "Which type of VPN creates a virtual network interface on the user's computer and provides full network-level access to the corporate LAN?",
                        "options": [
                            "Clientless SSL VPN",
                            "Proxy Server",
                            "Client-based SSL VPN",
                            "Web Filter"
                        ],
                        "correct": 2,
                        "explanation": "A client-based (or 'full tunnel') VPN provides the most complete access by making the user's device a virtual member of the remote network, able to access resources beyond just web applications."
                    }
                ]
            }
        },
        {
            "id": "lesson-21",
            "title": "VPN Policies and Split Tunneling",
            "duration": "90 min",
            "objectives": [
                "Understand how VPN traffic is processed by firewall policies",
                "Define split tunneling",
                "Analyze the security risks and benefits of split tunneling",
                "Configure a firewall to enforce policy on VPN user traffic"
            ],
            "content": {
                "overview": "Simply connecting a VPN user to the network is not enough; their traffic must be controlled by security policies just like any other user. This lesson covers how to integrate VPN users into the firewall's zone and policy structure and explores the important concept of 'split tunneling'—a configuration that has significant security and performance trade-offs.",
                "sections": [
                    {
                        "title": "Integrating VPNs into Security Policies",
                        "content": "<p>Best practice is to terminate VPN users into their own dedicated security zone (e.g., a 'VPN' zone). This allows for the creation of specific firewall policies for VPN traffic.</p><h3>Policy Enforcement:</h3><p>By placing VPN users in their own zone, you can write granular rules that control their access:</p><ul><li>`RULE: FROM VPN_ZONE, USER_GROUP Engineering, TO LAN_ZONE, DESTINATION Server_Farm, ACTION ALLOW`</li><li>`RULE: FROM VPN_ZONE, USER_GROUP ANY, TO WAN_ZONE, ACTION ALLOW (with strict security profiles)`</li></ul><p>This ensures remote users are subject to the same IPS, AV, and filtering policies as on-premise users.</p>",
                        "image": "https://images.unsplash.com/photo-1555949963-aa79dcee981c?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Defining Split Tunneling",
                        "content": "<p>Split tunneling is a VPN configuration that determines which traffic from the remote user is sent through the VPN tunnel and which traffic goes directly to the internet from the user's local network.</p><ul><li><strong>Full Tunnel (Split Tunneling Disabled):</strong> 100% of the remote user's traffic is sent through the VPN tunnel to the corporate firewall. This includes traffic destined for internal servers AND traffic destined for the public internet. The corporate firewall inspects and filters all of their traffic.</li><li><strong>Split Tunnel (Split Tunneling Enabled):</strong> Only the traffic destined for the corporate network (e.g., to the `10.0.0.0/8` IP range) is sent through the VPN tunnel. All other traffic (e.g., to `google.com`) goes directly out of the user's home internet connection.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1546530691-1b9ee1161a35?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The Security Trade-Off",
                        "content": "<h3>Full Tunnel (More Secure):</h3><ul><li><strong>Pro:</strong> The organization has full visibility and control over all of the user's traffic, allowing it to enforce security policies (IPS, web filtering, logging) on their internet activity.</li><li><strong>Con:</strong> It consumes significant bandwidth and processing power on the corporate firewall, as it has to process internet traffic for all remote users.</li></ul><h3>Split Tunnel (More Performant):</h3><ul><li><strong>Pro:</strong> It conserves corporate bandwidth and reduces the load on the firewall. The user's experience for general web browsing may be faster.</li><li><strong>Con:</strong> It creates a major security blind spot. The organization has no visibility or control over the user's direct internet traffic. A user could get infected with malware from a website, and that malware could then try to attack the corporate network through the active VPN tunnel.</li></ul><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Recommendation</strong></div><p>For security-conscious organizations, a full tunnel is almost always the recommended approach, as it ensures that all traffic is inspected by the corporate security stack.</p></div>",
                        "image": "https://images.unsplash.com/photo-1611928549863-9b63a939f403?w=800&h=400&fit=crop"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the best practice for integrating remote VPN users into a firewall's policy structure?",
                        "options": [
                            "To place them in the WAN (Untrust) zone.",
                            "To not apply any firewall rules to them.",
                            "To terminate them into a dedicated 'VPN' security zone to allow for granular policy control.",
                            "To place them in the LAN (Trust) zone."
                        ],
                        "correct": 2,
                        "explanation": "A dedicated zone provides the most flexibility and control, allowing administrators to write specific rules that define what remote users can access, separate from the rules for on-premise LAN users."
                    },
                    {
                        "id": 2,
                        "question": "A remote user is configured for a VPN with split tunneling enabled. They open two websites: the company intranet site and `youtube.com`. Which statement is true?",
                        "options": [
                            "Both the intranet and YouTube traffic will go through the VPN tunnel.",
                            "Neither will go through the VPN tunnel.",
                            "The YouTube traffic will go directly to the internet, while the intranet traffic will go through the VPN tunnel.",
                            "The intranet traffic will go directly to the internet, while the YouTube traffic will go through the VPN tunnel."
                        ],
                        "correct": 2,
                        "explanation": "Split tunneling separates traffic. Traffic for the corporate network (the intranet) goes through the tunnel, while general internet traffic (YouTube) bypasses the tunnel and goes directly out the user's local connection."
                    },
                    {
                        "id": 3,
                        "question": "What is the primary security risk of enabling split tunneling?",
                        "options": [
                            "It uses too much corporate bandwidth.",
                            "It makes the user's internet connection slower.",
                            "The organization loses all visibility and security control over the user's direct internet traffic, creating a blind spot.",
                            "It is more difficult to configure."
                        ],
                        "correct": 2,
                        "explanation": "With split tunneling, the corporate firewall cannot inspect, filter, or log the user's direct internet activity. This means a user could get compromised from a malicious website and the organization would have no way of knowing or stopping it at the perimeter."
                    }
                ]
            }
        },
        {
            "id": "lesson-22",
            "title": "Introduction to Zero Trust Network Access (ZTNA)",
            "duration": "90 min",
            "objectives": [
                "Understand the core philosophy of Zero Trust: 'Never trust, always verify'",
                "Contrast the ZTNA model with the traditional VPN model",
                "Define micro-segmentation and its role in Zero Trust",
                "Recognize ZTNA as the evolution of secure remote access"
            ],
            "content": {
                "overview": "Traditional VPNs grant broad network-level access, creating a large attack surface. Zero Trust Network Access (ZTNA) is a modern approach that completely inverts this model. This lesson introduces the 'never trust, always verify' philosophy of Zero Trust and explains how ZTNA provides secure, application-level access that is more granular and secure than a traditional VPN.",
                "sections": [
                    {
                        "title": "The Problem with Traditional VPNs",
                        "content": "<p>A traditional remote access VPN operates like a castle with a moat. Once an authenticated user crosses the moat (connects to the VPN), they are considered 'trusted' and are placed on the internal network. This gives them broad access and allows for lateral movement if their machine is compromised.</p><h3>The VPN Model:</h3><ul><li><strong>Grants Network Access:</strong> Puts the user's device *on* the network.</li><li><strong>Large Attack Surface:</strong> A compromised device has access to many resources on the network.</li><li><strong>Implicit Trust:</strong> Once authenticated, the user is trusted.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1611928549863-9b63a939f403?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The Zero Trust Philosophy",
                        "content": "<p>Zero Trust assumes that there is no traditional network edge; networks can be local, in the cloud, or a combination. It assumes that no user or device is trusted by default, whether they are inside or outside the network.</p><h3>Core Principles:</h3><ul><li><strong>Never Trust, Always Verify:</strong> Every single access request must be authenticated and authorized.</li><li><strong>Enforce Least Privilege:</strong> Users are only given the absolute minimum access required to perform their job.</li><li><strong>Assume Breach:</strong> Design the network assuming that attackers are already inside. This leads to a focus on micro-segmentation to prevent lateral movement.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1548092372-68b6b3b231d3?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "How ZTNA Works",
                        "content": "<p>ZTNA, also known as a Software-Defined Perimeter (SDP), provides access to specific applications, not the entire network.</p><h3>The ZTNA Model:</h3><ul><li><strong>Grants Application Access:</strong> A user is not placed on the LAN. Instead, a secure, encrypted tunnel is created from their device directly to the specific application they are authorized to access, and nothing else.</li><li><strong>Micro-segmentation:</strong> Each application lives in its own isolated segment. A user authorized for App A has no network visibility or access to App B.</li><li><strong>Dynamic and Contextual:</strong> Access decisions are made continuously based on user identity, device security posture (is the AV up to date?), location, and other factors.</li></ul><p>ZTNA is the logical evolution of remote access, providing a more secure and granular alternative to traditional VPNs.</p>",
                        "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit=crop"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the core philosophy of a Zero Trust security model?",
                        "options": [
                            "Trust all users who are physically inside the building.",
                            "Never trust, always verify every access request, regardless of its origin.",
                            "Once a user connects to the VPN, they should be fully trusted.",
                            "Only trust devices that are owned by the company."
                        ],
                        "correct": 1,
                        "explanation": "Zero Trust fundamentally rejects the idea of a trusted internal network. It treats every user and device as potentially hostile and requires strict verification for every single request."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary difference between how a traditional VPN and ZTNA grant access?",
                        "options": [
                            "VPNs are faster than ZTNA.",
                            "VPNs grant broad network-level access, while ZTNA grants specific application-level access.",
                            "Only VPNs use encryption.",
                            "ZTNA does not require user authentication."
                        ],
                        "correct": 1,
                        "explanation": "A VPN puts the user 'on the network'. ZTNA keeps the user off the network and instead creates a direct, secure tunnel to only the application they are allowed to use, enforcing the principle of least privilege."
                    },
                    {
                        "id": 3,
                        "question": "The practice of isolating each application into its own small, secure network segment to prevent lateral movement is known as:",
                        "options": [
                            "Split Tunneling",
                            "Stateful Inspection",
                            "Micro-segmentation",
                            "Port Forwarding"
                        ],
                        "correct": 2,
                        "explanation": "Micro-segmentation is a key component of a Zero Trust strategy. By breaking the network into tiny, isolated segments (sometimes down to the individual workload), it makes it extremely difficult for an attacker who compromises one system to move laterally and attack another."
                    }
                ]
            }
        },
        {
            "id": "lesson-23",
            "title": "High Availability (HA)",
            "duration": "100 min",
            "objectives": [
                "Explain the need for firewall redundancy",
                "Define Active/Passive and Active/Active HA clustering",
                "Understand the role of a heartbeat link",
                "Describe how session synchronization enables stateful failover"
            ],
            "content": {
                "overview": "The firewall is a single point of failure for all network traffic. If it goes down, the entire organization loses connectivity. This lesson covers High Availability (HA), the critical technology that allows two firewalls to work together as a redundant cluster, ensuring network uptime even in the event of a hardware or software failure.",
                "sections": [
                    {
                        "title": "The Need for Redundancy",
                        "content": "<p>A firewall is a critical piece of infrastructure. Its failure can result in:</p><ul><li>Loss of internet connectivity.</li><li>Inability to access critical applications.</li><li>Failure of site-to-site VPNs.</li><li>A complete halt to business operations.</li></ul><p>A High Availability (HA) configuration involves deploying a pair of identical firewalls in a cluster to eliminate this single point of failure.</p>",
                        "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Active/Passive vs. Active/Active",
                        "content": "<h3>Active/Passive:</h3><p>This is the most common HA configuration.</p><ul><li>One firewall (the Active node) actively processes all network traffic.</li><li>The second firewall (the Passive node) is idle, but constantly monitors the health of the active one.</li><li>If the Active node fails, the Passive node detects the failure and immediately takes over its duties, becoming the new Active node. This process is called failover.</li></ul><h3>Active/Active:</h3><p>In this more complex configuration, both firewalls in the cluster are actively processing traffic at the same time, sharing the load.</p><ul><li>This can provide increased throughput, as the processing power of both devices is used.</li><li>If one node fails, the other node takes over processing all traffic.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1517048676732-d65bc937f952?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The Heartbeat and Session Sync",
                        "content": "<p>The HA cluster relies on dedicated links between the two firewalls to function.</p><ul><li><strong>Heartbeat Link (or Control Link):</strong> This is a dedicated link used by the two firewalls to exchange health status information ('heartbeats'), configuration updates, and other control plane data. If the passive node stops receiving heartbeats from the active one, it initiates a failover.</li><li><strong>Session Synchronization Link (or Data Link):</strong> For a failover to be seamless ('stateful'), the passive firewall needs to know about all the active connections. The active firewall uses this link to synchronize its connection state table with the passive node in real-time. Without this, all existing user sessions (e.g., downloads, SSH sessions) would be dropped during a failover and would have to be re-established.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1556740738-b6a63e27c4df?w=800&h=400&fit=crop"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary purpose of a High Availability (HA) firewall cluster?",
                        "options": [
                            "To increase the number of available ports.",
                            "To eliminate the firewall as a single point of failure and ensure network uptime.",
                            "To make firewall policies easier to write.",
                            "To filter spam email."
                        ],
                        "correct": 1,
                        "explanation": "HA is all about redundancy. By pairing two firewalls, the network can continue to operate even if one of the devices fails completely."
                    },
                    {
                        "id": 2,
                        "question": "In an Active/Passive HA configuration, what is the role of the Passive firewall?",
                        "options": [
                            "It processes 50% of the network traffic.",
                            "It is turned off to save power.",
                            "It actively filters traffic alongside the Active node.",
                            "It remains idle, monitoring the health of the Active node and ready to take over if it fails."
                        ],
                        "correct": 3,
                        "explanation": "In Active/Passive mode, only one firewall is processing traffic at any given time. The passive unit is a 'hot standby', ready to take over instantly upon failure of the primary."
                    },
                    {
                        "id": 3,
                        "question": "What is the function of the session synchronization link in an HA pair?",
                        "options": [
                            "To provide internet connectivity to the firewalls.",
                            "To allow administrators to manage the cluster.",
                            "To copy the connection state table from the Active node to the Passive node in real-time.",
                            "To carry user data traffic."
                        ],
                        "correct": 2,
                        "explanation": "Session synchronization is what enables 'stateful failover'. By ensuring the passive firewall has an up-to-date copy of the state table, it can take over without dropping existing user connections, making the failover seamless."
                    }
                ]
            }
        },
        {
            "id": "lesson-24",
            "title": "Performance Tuning and Optimization",
            "duration": "90 min",
            "objectives": [
                "Understand the factors that impact firewall performance",
                "Explain the role of hardware acceleration (ASICs)",
                "Analyze the performance trade-offs of enabling advanced security features",
                "Develop a strategy for properly sizing a firewall"
            ],
            "content": {
                "overview": "A firewall that can't keep up with the network's traffic becomes a bottleneck, frustrating users and impeding business. This lesson delves into the critical aspects of firewall performance, from the impact of advanced security features to the role of specialized hardware, providing the knowledge needed to tune and properly size a firewall for any environment.",
                "sections": [
                    {
                        "title": "What Impacts Performance?",
                        "content": "<p>A firewall's throughput is not a single number. It is affected by many factors:</p><ul><li><strong>Packet Size:</strong> Processing many small packets is more intensive than processing fewer large packets, even if the total bandwidth is the same. Performance is often measured in both Mbps (Megabits per second) and pps (packets per second).</li><li><strong>Number of Policies:</strong> A very large and complex rulebase can add a small amount of latency.</li><li><strong>Number of Concurrent Sessions:</strong> The size of the state table is limited by the firewall's RAM. Exceeding the session limit will cause new connections to be dropped.</li><li><strong>Enabled Security Services:</strong> This is the single biggest factor. Basic stateful filtering is fast. Enabling IPS, AV, SSL Decryption, and Sandboxing will dramatically decrease the maximum throughput.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Hardware Acceleration",
                        "content": "<p>To handle the intense processing demands of security services, firewall vendors use specialized hardware to offload tasks from the general-purpose CPU.</p><h3>ASICs and FPGAs:</h3><ul><li><strong>ASIC (Application-Specific Integrated Circuit):</strong> A chip designed to do one task extremely well and extremely fast. Many vendors use network processor ASICs to accelerate flow processing, stateful inspection, and even IPS pattern matching.</li><li><strong>FPGA (Field-Programmable Gate Array):</strong> A more flexible type of chip that can be reprogrammed after manufacturing.</li></ul><p>Firewalls that use hardware acceleration can deliver much higher threat protection throughput than those that rely solely on software running on a standard CPU.</p>",
                        "image": "https://images.unsplash.com/photo-1599667533358-bf522b103139?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Sizing a Firewall",
                        "content": "<p>Choosing the right firewall model is a critical design step. An undersized firewall will become a bottleneck, while an oversized one is a waste of money.</p><h3>Key Sizing Metrics:</h3><p>When reading a firewall datasheet, look for these key performance numbers:</p><ul><li><strong>Stateful Throughput:</strong> The 'hero' number, usually the highest. Not very useful for real-world sizing.</li><li><strong>Threat Protection Throughput:</strong> The most important number. This is the expected throughput with security services like IPS and Application Control enabled. This should match or exceed your internet circuit's speed.</li><li><strong>SSL Decryption Throughput:</strong> Decryption is very intensive. This number shows the performance when inspecting encrypted traffic.</li><li><strong>Concurrent Sessions:</strong> The maximum number of entries the state table can hold. This should be sufficient for your number of users and devices.</li><li><strong>New Sessions per Second:</strong> How quickly the firewall can create new entries in its state table. Important for networks with many short-lived connections.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1518773553398-650c184e0bb3?w=800&h=400&fit=crop"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "Which of the following has the most significant negative impact on a firewall's throughput?",
                        "options": [
                            "Having a large number of firewall policies.",
                            "High-bandwidth traffic with large packet sizes.",
                            "Enabling advanced security services like IPS and SSL Decryption.",
                            "Using a static IP address."
                        ],
                        "correct": 2,
                        "explanation": "Deep Packet Inspection and SSL Decryption are extremely CPU-intensive. Enabling these features will always result in a much lower maximum throughput than simple stateful packet filtering."
                    },
                    {
                        "id": 2,
                        "question": "What is the purpose of using ASICs in a firewall?",
                        "options": [
                            "To store firewall logs.",
                            "To provide a graphical user interface.",
                            "To act as a power supply unit.",
                            "To provide hardware acceleration for specific, repetitive tasks like packet processing, improving performance."
                        ],
                        "correct": 3,
                        "explanation": "ASICs are custom-built chips designed to perform a specific function (like pattern matching for IPS) much faster and more efficiently than a general-purpose CPU, leading to higher overall throughput."
                    },
                    {
                        "id": 3,
                        "question": "When sizing a new NGFW for a company with a 1 Gbps internet connection, which datasheet metric is the most important to consider?",
                        "options": [
                            "The Stateful Throughput (often 10 Gbps or higher).",
                            "The number of physical ports on the device.",
                            "The Threat Protection Throughput.",
                            "The firewall's physical dimensions."
                        ],
                        "correct": 2,
                        "explanation": "The 'Threat Protection Throughput' is the most realistic real-world performance metric. You should choose a firewall model where this number is greater than your 1 Gbps internet speed to ensure it doesn't become a bottleneck when security features are enabled."
                    }
                ]
            }
        },
        {
            "id": "lesson-25",
            "title": "Logging, Monitoring, and Reporting",
            "duration": "100 min",
            "objectives": [
                "Understand the critical importance of firewall logs",
                "Configure a firewall to send logs to a remote Syslog server",
                "Explain the role of a Security Information and Event Management (SIEM) system",
                "Identify key events to monitor for security incidents"
            ],
            "content": {
                "overview": "A firewall that isn't logging is just a black box. Logs provide the visibility needed to troubleshoot network problems, investigate security incidents, and demonstrate compliance. This lesson covers the fundamentals of firewall logging, the importance of centralized log collection with Syslog and SIEMs, and what to look for in the sea of data.",
                "sections": [
                    {
                        "title": "The Importance of Logs",
                        "content": "<p>Firewall logs are the primary record of all traffic passing through the network perimeter. They are essential for:</p><ul><li><strong>Security Incident Response:</strong> When an alert fires, logs provide the context needed to investigate. Who was the source? What was the destination? What port was used? How much data was transferred?</li><li><strong>Troubleshooting:</strong> When a user reports they can't access an application, logs are the first place to check to see if the firewall is dropping their traffic and why.</li><li><strong>Compliance:</strong> Many regulations (like PCI-DSS, HIPAA) have strict requirements for logging and log retention.</li><li><strong>Auditing:</strong> Logs provide an audit trail of network activity and administrative changes to the firewall itself.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1526374965328-5f61d25c16c6?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Centralized Logging with Syslog and SIEM",
                        "content": "<p>Storing logs only on the firewall itself is a bad practice. Local storage is limited and could be wiped if the device fails or is compromised. The standard practice is to send logs to a centralized server.</p><h3>Syslog:</h3><p>Syslog is a standard protocol for sending log messages. All enterprise-grade firewalls can be configured to stream their logs to a remote Syslog server in real-time.</p><h3>SIEM:</h3><p>A Security Information and Event Management (SIEM) system is a sophisticated log management platform. It does much more than just store logs. It can:</p><ul><li>Collect logs from many different sources (firewalls, servers, endpoints, applications).</li><li>Normalize the logs into a common format.</li><li>Correlate events from different sources to identify complex attacks.</li><li>Provide powerful search, analysis, and visualization tools.</li><li>Generate automated alerts based on correlation rules.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "What to Monitor",
                        "content": "<p>The volume of traffic logs can be overwhelming. It's important to focus on key events.</p><h3>Key Events to Watch:</h3><ul><li><strong>Denied Traffic:</strong> A high number of denied packets from a single source could indicate a network scan.</li><li><strong>IPS/AV/Malware Alerts:</strong> Any alert from the threat prevention engines should be treated as a high-priority event.</li><li><strong>Anomalous Outbound Connections:</strong> An internal host trying to connect to a known malicious IP or to a strange country at an odd time is a strong indicator of compromise.</li><li><strong>Administrative Logins:</strong> All logins (successful and failed) to the firewall's management interface should be monitored.</li><li><strong>Configuration Changes:</strong> Any change to the firewall's policy or configuration should be logged and audited.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1504868584819-f8e8b4b6d7e3?w=800&h=400&fit=crop"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "Why is it a bad practice to store logs only on the firewall itself?",
                        "options": [
                            "It uses too much electricity.",
                            "The local storage is limited, and the logs could be lost if the device fails or is compromised.",
                            "It violates international law.",
                            "Firewalls are not capable of storing logs."
                        ],
                        "correct": 1,
                        "explanation": "Centralized logging is crucial for log retention, security, and analysis. If an attacker compromises the firewall, one of their first actions will be to delete the logs to cover their tracks."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary function of a Security Information and Event Management (SIEM) system?",
                        "options": [
                            "To act as a firewall.",
                            "To provide VPN access.",
                            "To install antivirus software on endpoints.",
                            "To collect, correlate, and analyze logs from multiple sources to detect security threats."
                        ],
                        "correct": 3,
                        "explanation": "A SIEM's power comes from its ability to see the bigger picture. By correlating a firewall log with a server event log and an endpoint detection log, it can identify a sophisticated attack that would be invisible when looking at each log source in isolation."
                    },
                    {
                        "id": 3,
                        "question": "You see firewall logs showing an internal client computer attempting to connect to an IP address in a foreign country that is on a threat intelligence block list. What is this a strong indicator of?",
                        "options": [
                            "Normal web browsing.",
                            "The client computer is likely compromised and is trying to connect to a command-and-control server.",
                            "The firewall is not configured correctly.",
                            "A user is checking their email."
                        ],
                        "correct": 1,
                        "explanation": "Unsolicited outbound connections to known-bad destinations are a classic sign of a compromised host. The malware on the client is trying to 'phone home' to its operator."
                    }
                ]
            }
        },
        {
            "id": "lesson-26",
            "title": "Centralized Firewall Management",
            "duration": "90 min",
            "objectives": [
                "Understand the challenges of managing multiple firewalls individually",
                "Explain the role of a centralized management platform",
                "Describe the benefits of shared objects and consistent policies",
                "Recognize how templates can be used to speed up new firewall deployments"
            ],
            "content": {
                "overview": "Managing one firewall is straightforward. Managing dozens or hundreds of firewalls across a global enterprise is impossible without the right tools. This lesson introduces centralized firewall management systems, explaining how they enable administrators to maintain consistent security policies and streamline operations across a distributed fleet of firewalls.",
                "sections": [
                    {
                        "title": "The Challenge of Scale",
                        "content": "<p>As an organization grows and opens new branch offices, the number of firewalls to manage explodes. Managing each one individually leads to:</p><ul><li><strong>Policy Inconsistency:</strong> Different offices will have slightly different, and often outdated, rulebases, leading to security gaps.</li><li><strong>Repetitive Work:</strong> An administrator has to perform the same task (like adding a new rule or updating software) on every single firewall.</li><li><strong>Lack of Visibility:</strong> There is no single place to view the security posture of the entire organization.</li><li><strong>High Operational Overhead:</strong> It is slow, inefficient, and prone to human error.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The Centralized Management Platform",
                        "content": "<p>All major firewall vendors offer a centralized management platform (e.g., Palo Alto Networks Panorama, Fortinet FortiManager, Cisco FMC). This is a single 'pane of glass' from which an administrator can manage all of their firewalls.</p><h3>Core Functions:</h3><ul><li><strong>Device Management:</strong> Onboarding new firewalls, monitoring the health of all managed devices, and pushing software updates.</li><li><strong>Policy Management:</strong> Creating and editing firewall policies that can be applied to one, some, or all firewalls.</li><li><strong>Log Collection:</strong> It often serves as a central log collector for all managed firewalls, providing a holistic view of network-wide events.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Shared Objects and Consistent Policy",
                        "content": "<p>The key to consistency is the use of shared objects and policies.</p><ul><li><strong>Shared Objects:</strong> An administrator can create an address object (e.g., 'Corporate Web Servers') or a service object (e.g., 'Standard Web Ports') once in the central manager. This object can then be used in policies on any managed firewall. If a server's IP changes, the administrator only has to update the object in one place, and the change is automatically pushed to all relevant firewalls.</li><li><strong>Pre- and Post-Rules:</strong> Many systems use a hierarchical policy structure. An administrator can create a set of 'pre-rules' (e.g., 'Block all traffic from known malicious IPs') that are applied to *all* firewalls globally, ensuring a consistent security baseline. Local administrators can then add their own specific rules for their site.</li><li><strong>Templates:</strong> For deploying new sites, administrators can create a template with all the standard configuration settings (NTP, DNS, logging, basic zones, etc.). When a new firewall is deployed, they simply apply the template to get it 80% configured in seconds.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1556740758-90de374c12ad?w=800&h=400&fit=crop"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary problem that centralized firewall management systems are designed to solve?",
                        "options": [
                            "The high cost of individual firewalls.",
                            "The difficulty and inefficiency of managing a large number of firewalls individually.",
                            "Slow internet speeds at branch offices.",
                            "The lack of physical security for firewalls."
                        ],
                        "correct": 1,
                        "explanation": "Centralized management addresses the operational challenges of scale, making it feasible to maintain a consistent and secure policy across a large, distributed enterprise."
                    },
                    {
                        "id": 2,
                        "question": "An administrator defines an address object for 'Office365_IPs' once in the central manager and uses it in policies for 50 different firewalls. What is the benefit of this?",
                        "options": [
                            "It makes traffic to Office 365 faster.",
                            "It encrypts the address object.",
                            "If Microsoft changes an IP address, the administrator only has to update the object in one place to fix the policy for all 50 firewalls.",
                            "It reduces the CPU load on the firewalls."
                        ],
                        "correct": 2,
                        "explanation": "Using shared objects is a core benefit. It dramatically simplifies changes and ensures that all firewalls are using the same, correct information, reducing the chance of human error."
                    },
                    {
                        "id": 3,
                        "question": "A global security team wants to ensure that all firewalls in their organization, regardless of location, have a rule to block access to specific high-risk countries. What feature of a central manager would they use?",
                        "options": [
                            "A local policy specific to one firewall.",
                            "A global or pre-rule that is inherited by all managed firewalls.",
                            "A VPN tunnel.",
                            "A device template."
                        ],
                        "correct": 1,
                        "explanation": "Hierarchical policies allow for a global baseline of security to be enforced everywhere, while still allowing for local customization where needed. The pre-rules ensure that the most critical security controls can't be accidentally omitted by a local administrator."
                    }
                ]
            }
        },
        {
            "id": "lesson-27",
            "title": "Cloud Firewalling (FWaaS)",
            "duration": "100 min",
            "objectives": [
                "Understand the firewalling tools available in major cloud platforms (e.g., Security Groups)",
                "Define Firewall-as-a-Service (FWaaS)",
                "Explain the benefits of a cloud-delivered firewall model",
                "Recognize how FWaaS fits into a SASE architecture"
            ],
            "content": {
                "overview": "As organizations move their applications and data to the cloud, the traditional on-premise firewall is no longer sufficient. This lesson explores the world of cloud firewalling, from the basic tools provided by cloud vendors to the comprehensive security offered by Firewall-as-a-Service (FWaaS) platforms.",
                "sections": [
                    {
                        "title": "Firewalling in the Cloud",
                        "content": "<p>Major Infrastructure-as-a-Service (IaaS) providers like AWS, Azure, and GCP offer their own built-in firewalling capabilities.</p><h3>AWS Security Groups / Azure Network Security Groups (NSGs):</h3><ul><li>These act as basic, stateful packet filters that control traffic to and from cloud resources like virtual machines.</li><li>They are essentially host-based firewalls, enforcing policy at the virtual machine's network interface.</li><li>They are excellent for basic access control (e.g., 'Only allow SSH from my IP', 'Allow HTTPS from the internet'), but they are not NGFWs. They lack advanced features like application ID, IPS, and user ID.</li></ul><p>For more advanced security, organizations can deploy virtual NGFW appliances from vendors like Palo Alto, Fortinet, etc., directly into their cloud environment (VPC/VNet).</p>",
                        "image": "https://images.unsplash.com/photo-1523961131990-5ea7c61b2107?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Firewall-as-a-Service (FWaaS)",
                        "content": "<p>FWaaS is a cloud-delivered security service. Instead of an organization deploying and managing its own firewall appliances (physical or virtual), it routes its traffic to the service provider's cloud, where a full stack of security services is applied.</p><h3>How it Works:</h3><ol><li>An organization establishes a secure tunnel (e.g., IPsec) from its office, or installs a lightweight agent on its users' laptops.</li><li>All internet-bound traffic is sent to the FWaaS provider's nearest point of presence (POP).</li><li>The provider applies a full suite of NGFW and UTM security services in the cloud: Application ID, IPS, AV, Sandboxing, URL Filtering, etc.</li><li>Clean traffic is then sent on to its final destination on the internet.</li></ol>",
                        "image": "https://images.unsplash.com/photo-1510915228340-29c85a43dcfe?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Benefits of FWaaS",
                        "content": "<ul><li><strong>Simplified Management:</strong> No hardware to buy, patch, or manage. The provider handles all the infrastructure.</li><li><strong>Scalability:</strong> The cloud platform can scale to handle massive amounts of traffic, eliminating performance bottlenecks.</li><li><strong>Consistent Policy for All Users:</strong> It provides the same level of security and policy enforcement for users in the office, at home, or on the road, as all traffic is routed through the same cloud security stack.</li><li><strong>Part of SASE:</strong> FWaaS is a core component of a Secure Access Service Edge (SASE) architecture, which combines network and security services into a single, unified cloud platform.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1534972195531-d756b9bfa9f2?w=800&h=400&fit=crop"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "An AWS Security Group is best described as what type of firewall?",
                        "options": [
                            "A full Next-Generation Firewall (NGFW) with IPS and Application ID.",
                            "A stateless packet filter.",
                            "A basic, stateful packet filter that controls access to a specific cloud resource.",
                            "A web application firewall (WAF)."
                        ],
                        "correct": 2,
                        "explanation": "Security Groups and Azure NSGs are foundational tools for controlling traffic flow at Layers 3 and 4, but they do not have the advanced Layer 7 inspection capabilities of a true NGFW."
                    },
                    {
                        "id": 2,
                        "question": "What is Firewall-as-a-Service (FWaaS)?",
                        "options": [
                            "A piece of software that lets you build your own firewall.",
                            "A physical appliance that is delivered as a service.",
                            "A cloud-delivered service where an organization routes its traffic to a provider's cloud for security inspection.",
                            "The built-in firewall on a Windows server."
                        ],
                        "correct": 2,
                        "explanation": "FWaaS shifts the location of security enforcement from the on-premise appliance to the provider's distributed cloud network, providing security as a utility service."
                    },
                    {
                        "id": 3,
                        "question": "What is a key benefit of the FWaaS model for a company with a large remote workforce?",
                        "options": [
                            "It is always cheaper than an on-premise firewall.",
                            "It requires users to come into the office to be protected.",
                            "It provides a consistent security policy and level of protection for all users, regardless of their physical location.",
                            "It eliminates the need for user authentication."
                        ],
                        "correct": 2,
                        "explanation": "In a traditional model, remote users on VPN have their traffic backhauled to the office. With FWaaS, users at home and users in the office all have their traffic directed to the same cloud security platform, ensuring consistent policy enforcement for everyone."
                    }
                ]
            }
        },
        {
            "id": "lesson-28",
            "title": "Firewall Automation with APIs",
            "duration": "120 min",
            "objectives": [
                "Understand the benefits of automating firewall management",
                "Explain what a REST API is in the context of a firewall",
                "Use a simple script to interact with a firewall's API",
                "Identify use cases for API-driven automation"
            ],
            "content": {
                "overview": "Manually logging into a firewall's GUI to perform repetitive tasks is slow and error-prone. Modern firewalls are built with automation in mind, providing rich Application Programming Interfaces (APIs) that allow for programmatic control. This lesson introduces the concept of firewall APIs and shows how simple scripts can automate security workflows.",
                "sections": [
                    {
                        "title": "Why Automate?",
                        "content": "<p>As networks become more dynamic, the need for speed and consistency in security operations grows. Automation helps to:</p><ul><li><strong>Increase Speed:</strong> Programmatically block a malicious IP across 100 firewalls in seconds, a task that would take hours manually.</li><li><strong>Reduce Human Error:</strong> Scripts perform the same task perfectly every time, eliminating typos and misconfigurations.</li><li><strong>Enable Integration:</strong> APIs allow the firewall to be integrated into larger security orchestration workflows. For example, a SIEM could detect a threat and automatically call the firewall's API to block the offending IP.</li><li><strong>Scale Operations:</strong> Allows a small team to manage a very large number of devices.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Understanding REST APIs",
                        "content": "<p>Most modern firewalls provide a REST (REpresentational State Transfer) API. This is a standard way for computer systems to communicate over the web.</p><h3>How it Works:</h3><ul><li>The administrator's script acts as a client. The firewall acts as the server.</li><li>The script makes an HTTP request (like your browser does) to a specific URL on the firewall's management interface.</li><li>The request includes an API key for authentication, and parameters that specify the desired action (e.g., 'get configuration', 'set a rule').</li><li>The firewall processes the request and sends back a response, usually in a structured format like XML or JSON, indicating success or failure.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1555949963-aa79dcee981c?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Common Automation Use Cases",
                        "content": "<ul><li><strong>Threat Response:</strong> Automatically adding malicious IPs or domains from a threat feed or SIEM alert to a block list on the firewall.</li><li><strong>Provisioning:</strong> When a new web server is deployed by an orchestration tool like Kubernetes, it can call the firewall API to automatically create the necessary address objects and security rules for the new server.</li><li><strong>Auditing and Reporting:</strong> Writing a script to periodically query all firewalls for their policy configuration and compare it against a 'golden' template to detect unauthorized changes.</li><li><strong>Dynamic Address Groups:</strong> Updating the membership of a group used in policy based on external data, such as a list of Office 365 IPs.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1618498082410-b4aa22193b38?w=800&h=400&fit=crop"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is a primary benefit of using a firewall's API for management?",
                        "options": [
                            "It makes the firewall's GUI prettier.",
                            "It allows for programmatic control, enabling automation that increases speed and reduces human error.",
                            "It makes the firewall physically lighter.",
                            "It replaces the need for firewall policies."
                        ],
                        "correct": 1,
                        "explanation": "APIs are the foundation of automation. They allow administrators to move away from manual, repetitive clicking in a GUI and toward scripted, repeatable, and fast configuration changes."
                    },
                    {
                        "id": 2,
                        "question": "A SIEM system detects a brute-force login attack from a specific IP address. What is a likely automated response involving the firewall's API?",
                        "options": [
                            "The SIEM sends an email to the administrator.",
                            "The SIEM automatically makes an API call to the firewall to add the malicious IP address to a block list.",
                            "The SIEM shuts down the firewall.",
                            "The SIEM deletes its own logs."
                        ],
                        "correct": 1,
                        "explanation": "This is a classic SOAR (Security Orchestration, Automation, and Response) use case. The integration between the SIEM (detection) and the firewall (enforcement) via API allows for near-instant threat response."
                    },
                    {
                        "id": 3,
                        "question": "A REST API on a firewall typically uses which underlying protocol for communication?",
                        "options": [
                            "FTP",
                            "SSH",
                            "HTTP/HTTPS",
                            "SNMP"
                        ],
                        "correct": 2,
                        "explanation": "REST APIs are built on the same web standards as websites. Scripts interact with the firewall by sending authenticated HTTPS requests to specific API endpoints."
                    }
                ]
            }
        },
        {
            "id": "lesson-29",
            "title": "Infrastructure as Code (IaC) for Firewalls",
            "duration": "100 min",
            "objectives": [
                "Define Infrastructure as Code (IaC)",
                "Understand the benefits of managing firewall configurations as code",
                "Recognize the role of tools like Ansible and Terraform",
                "Explain how IaC enables version control and peer review for policy changes"
            ],
            "content": {
                "overview": "Taking automation a step further, Infrastructure as Code (IaC) is the practice of managing and provisioning infrastructure through machine-readable definition files. This lesson explores how this powerful DevOps methodology can be applied to firewalls, enabling version-controlled, peer-reviewed, and highly repeatable security policy management.",
                "sections": [
                    {
                        "title": "What is Infrastructure as Code?",
                        "content": "<p>Instead of manually configuring a device through a GUI or making imperative API calls, IaC involves writing a declarative configuration file that defines the *desired state* of the system. A tool then reads this file and makes the necessary API calls to make the live configuration match the desired state defined in the code.</p><h3>Key Benefits:</h3><ul><li><strong>Repeatability:</strong> The same configuration file can be used to deploy identical firewalls in development, testing, and production environments.</li><li><strong>Version Control:</strong> Firewall configurations can be stored in a source control system like Git. This provides a full history of every change, who made it, and when.</li><li><strong>Peer Review:</strong> Changes to the firewall policy can be submitted as a pull request, allowing other team members to review and approve the change before it is applied. This dramatically reduces configuration errors.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1542831371-d531d36971ad?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Tools of the Trade: Ansible and Terraform",
                        "content": "<ul><li><strong>Ansible:</strong> An automation tool that is often used for configuration management. It connects to devices (often via SSH or API) and pushes configuration changes. Its 'playbooks' are written in the simple YAML format. Ansible is great for managing the state of existing devices.</li><li><strong>Terraform:</strong> A tool focused on infrastructure provisioning. It is used to build, change, and version infrastructure safely and efficiently. It excels at managing the entire lifecycle of an object, including creation and deletion.</li></ul><p>Both tools have robust ecosystems with pre-built 'modules' or 'collections' for interacting with all major firewall vendors.</p>",
                        "image": "https://images.unsplash.com/photo-1618498082410-b4aa22193b38?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The IaC Workflow",
                        "content": "<ol><li>An administrator needs to add a new firewall rule. Instead of logging into the GUI, they edit a YAML (for Ansible) or HCL (for Terraform) file on their local machine.</li><li>They commit this change to a Git repository.</li><li>They open a pull request. Another engineer reviews the proposed change to ensure it follows security best practices.</li><li>Once approved, the change is merged into the main branch.</li><li>A CI/CD pipeline (like Jenkins or GitLab CI) automatically triggers, running the Ansible or Terraform tool.</li><li>The tool connects to the firewall's API and applies the change defined in the code.</li></ol><p>This workflow brings the same discipline and safety of software development to network security operations.</p>",
                        "image": "https://images.unsplash.com/photo-1556075798-4825dfaaf498?w=800&h=400&fit=crop"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the core principle of Infrastructure as Code (IaC)?",
                        "options": [
                            "To manually configure all devices via their graphical interface.",
                            "To manage and provision infrastructure by writing a declarative configuration file that defines the desired state.",
                            "To eliminate the need for firewalls entirely.",
                            "To write all firewall policies in Python."
                        ],
                        "correct": 1,
                        "explanation": "IaC shifts the source of truth from the live device's configuration to a code file. The tooling's job is to make the device's state match the code's declared state."
                    },
                    {
                        "id": 2,
                        "question": "Storing firewall configurations in a source control system like Git provides what major benefit?",
                        "options": [
                            "It makes the firewall run faster.",
                            "It provides a complete audit history of all changes and enables peer review of proposed policy changes.",
                            "It automatically blocks malicious IP addresses.",
                            "It is the only way to log into a firewall."
                        ],
                        "correct": 1,
                        "explanation": "Version control brings accountability and safety to infrastructure management. The ability to see every change, and to have a second pair of eyes review a change before it's implemented, is a massive improvement over manual changes."
                    },
                    {
                        "id": 3,
                        "question": "In an IaC model, if an administrator wants to change a firewall rule, what is the correct first step?",
                        "options": [
                            "Log directly into the firewall GUI and make the change.",
                            "Edit the machine-readable configuration file (e.g., a YAML or HCL file) that defines the firewall's state.",
                            "Send an email to the firewall vendor.",
                            "Restart the firewall."
                        ],
                        "correct": 1,
                        "explanation": "The code is the source of truth. Any manual ('out-of-band') changes made directly on the device will be overwritten the next time the automation runs. All changes must start by modifying the code."
                    }
                ]
            }
        },
        {
            "id": "lesson-30",
            "title": "The Future of Network Security",
            "duration": "90 min",
            "objectives": [
                "Define Secure Access Service Edge (SASE)",
                "Understand the convergence of networking and security",
                "Discuss the challenges and opportunities of AI in threat detection",
                "Grasp the concept of the 'disappearing perimeter'"
            ],
            "content": {
                "overview": "The network is no longer a static, centralized place. Users are remote, applications are in the cloud, and the traditional perimeter has dissolved. This final lesson looks to the future, exploring the emerging architectures and technologies like SASE and AI that are shaping the next generation of network security.",
                "sections": [
                    {
                        "title": "The Disappearing Perimeter",
                        "content": "<p>The traditional 'castle-and-moat' model of security was built around a clear perimeter, with a trusted internal network and an untrusted external one. This model is broken.</p><h3>The Drivers of Change:</h3><ul><li><strong>Remote Workforce:</strong> Users are everywhere, not just inside the office.</li><li><strong>Cloud Adoption (SaaS & IaaS):</strong> Applications and data are no longer in the on-premise data center. They are hosted in the cloud.</li><li><strong>Mobility (IoT):</strong> A massive influx of devices that need secure access.</li></ul><p>Security can no longer be tied to a physical location or a box in a data center. It must be a distributed, cloud-native service.</p>",
                        "image": "https://images.unsplash.com/photo-1534972195531-d756b9bfa9f2?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Secure Access Service Edge (SASE)",
                        "content": "<p>SASE (pronounced 'sassy') is an architectural model that converges networking and security services into a single, unified, cloud-delivered platform. It aims to provide secure and fast access for users to applications, regardless of their location.</p><h3>Core SASE Components:</h3><ul><li><strong>Networking (SD-WAN):</strong> Software-Defined WAN for optimized network routing.</li><li><strong>Security (The Security Service Edge - SSE):</strong> A bundle of cloud-native security services, including:</li><ul><li>Firewall-as-a-Service (FWaaS)</li><li>Zero Trust Network Access (ZTNA)</li><li>Cloud Access Security Broker (CASB)</li><li>Secure Web Gateway (SWG)</li></ul></ul><p>SASE delivers both networking and security as a single service from a provider's global network of POPs.</p>",
                        "image": "https://images.unsplash.com/photo-1510915228340-29c85a43dcfe?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "AI and the Future",
                        "content": "<p>As the volume and sophistication of threats grow, human analysts cannot keep up. Artificial Intelligence (AI) and Machine Learning (ML) are becoming essential tools.</p><h3>Future Applications:</h3><ul><li><strong>AI-Driven Threat Detection:</strong> ML models will become even better at anomaly detection, identifying sophisticated, low-and-slow attacks that are invisible to signatures.</li><li><strong>Automated Policy Generation:</strong> AI could analyze traffic flows and suggest optimal, least-privilege firewall policies, reducing human error.</li><li><strong>Encrypted Traffic Analysis:</strong> Researchers are developing techniques using ML to identify malicious activity inside encrypted traffic based on metadata and flow characteristics, without needing to perform full decryption.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1620712943543-95fc6962c2f7?w=800&h=400&fit=crop"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "The concept that users, data, and applications are no longer in a centralized, trusted location is often referred to as:",
                        "options": [
                            "The 'moat'",
                            "The 'disappearing perimeter'",
                            "The 'secure LAN'",
                            "The 'DMZ'"
                        ],
                        "correct": 1,
                        "explanation": "The 'disappearing perimeter' describes the shift away from the old model where security was focused on a physical firewall at the edge of the office network. Security must now follow the user and the application, wherever they are."
                    },
                    {
                        "id": 2,
                        "question": "What is Secure Access Service Edge (SASE)?",
                        "options": [
                            "A new type of physical firewall appliance.",
                            "A security philosophy that trusts all internal users.",
                            "A cloud architecture that converges networking (like SD-WAN) and security (like FWaaS and ZTNA) into a single, unified service.",
                            "A tool for managing firewall logs."
                        ],
                        "correct": 2,
                        "explanation": "SASE is a holistic, cloud-native model that combines network and security functions to provide secure access from any entity to any application, anywhere."
                    },
                    {
                        "id": 3,
                        "question": "Which of the following is a key role for AI/ML in the future of network security?",
                        "options": [
                            "Replacing the need for encryption.",
                            "Designing the physical layout of data centers.",
                            "Improving anomaly detection to identify sophisticated and unknown threats.",
                            "Negotiating contracts with internet service providers."
                        ],
                        "correct": 2,
                        "explanation": "AI/ML's strength is in processing massive datasets to find subtle patterns. This makes it perfectly suited for advanced threat detection, where it can identify abnormal behaviors that would be impossible for a human analyst or a static signature to find."
                    }
                ]
            }
        }
    ]
}
// =====================================================
// GLOBAL VARIABLES
// =====================================================
let currentUser = null;
let currentLessonIndex = 0;
let courseProgress = {};
let userStats = {};
let quizState = {
    currentQuestion: 0,
    answers: [],
    score: 0,
    isComplete: false
};

// Enhanced session tracking
let courseSession = {
    startTime: null,
    totalStudyTime: 0,
    lessonsStarted: 0,
    lessonsCompleted: 0,
    pageLoadTime: new Date(),
    interactionCount: 0,
    lastActivityTime: new Date()
};

// Music Player Variables
let audioPlayer = new Audio();

// Achievement notification system
let notificationQueue = [];
let isShowingNotification = false;

// =====================================================
// INITIALIZATION
// =====================================================
document.addEventListener('DOMContentLoaded', async () => {
    try {
        showLoadingScreen();
        await checkAuth();
        
        if (currentUser) {
            // Initialize session tracking
            startCourseSession();
            
            // Load course data and progress
            await loadCourseData();
            await loadUserProfile();
            await loadProgress();
            
            // Initialize UI
            initializeEventListeners();
            renderSidebar();
            loadLesson(currentLessonIndex);
            
            // Initialize additional features
            initMusicPlayer();
            addMusicIndicator();
            initializeActivityTracking();
            
            hideLoadingScreen();
        } else {
            openAuthModal();
        }
    } catch (error) {
        console.error('Error initializing course:', error);
        hideLoadingScreen();
        showToast('Failed to initialize course system', 'error');
    }
});

// =====================================================
// AUTHENTICATION SYSTEM
// =====================================================
async function checkAuth() {
    try {
        const { data: { session }, error } = await supabase.auth.getSession();
        
        if (error) {
            console.error('Auth error:', error);
            currentUser = null;
            openAuthModal();
            return;
        }

        if (!session) {
            currentUser = null;
            openAuthModal();
            return;
        }

        currentUser = session.user;
        updateUIWithUser();
    } catch (error) {
        console.error('Error checking auth:', error);
        currentUser = null;
        openAuthModal();
    }
}

function updateUIWithUser() {
    if (!currentUser) return;
    
    const name = currentUser.user_metadata?.full_name || currentUser.email.split('@')[0];
    const userElements = document.querySelectorAll('[data-user-name]');
    userElements.forEach(el => el.textContent = name);
}

// =====================================================
// USER PROFILE & STATS MANAGEMENT
// =====================================================
async function loadUserProfile() {
  try {
    // 🔍 Step 1: Try to fetch existing profile
    const { data: profile, error } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', currentUser.id)
      .single();

    if (error && error.code !== 'PGRST116') {
      throw error;
    }

    if (!profile) {
      // 🆕 Step 2: Create new profile if missing
      await createUserProfile();
    } else {
      // ✅ Step 3: Use existing profile
      userStats = profile;
      await updateLastActivity();
    }

  } catch (error) {
    console.error('❌ Error loading user profile:', error);
    showToast('Failed to load user profile', 'error');
  }
}
async function createUserProfile() {
    try {
        const newProfile = {
            id: currentUser.id,
            full_name: currentUser.user_metadata?.full_name || '',
            email: currentUser.email,
            level: 'Script Kiddie',
            total_points: 0,
            completed_courses: 0,
            current_streak: 0,
            total_certificates: 0,
            total_achievements: 0,
            sections_visited: 0,
            bonus_points: 0,
            in_progress_courses: 0,
            settings_changed: 0,
            midnight_sessions: 0,
            early_sessions: 0,
            weekend_sessions: 0,
            last_activity: new Date().toISOString(),
            created_at: new Date().toISOString()
        };

        const { error } = await supabase
            .from('profiles')
            .insert([newProfile]);

        if (!error) {
            userStats = newProfile;
            // Award first login achievement
            setTimeout(() => checkAndUnlockAchievement('first_login'), 1000);
        }
    } catch (error) {
        console.error('Error creating user profile:', error);
    }
}

async function updateLastActivity() {
    try {
        const now = new Date();
        
        // Update activity tracking
        courseSession.lastActivityTime = now;
        
        // Update database
        await supabase
            .from('profiles')
            .update({ 
                last_activity: now.toISOString()
            })
            .eq('id', currentUser.id);

        // Check time-based achievements
        await checkTimeBasedAchievements(now);
        
    } catch (error) {
        console.error('Error updating last activity:', error);
    }
}

// =====================================================
// COURSE SESSION MANAGEMENT
// =====================================================
function startCourseSession() {
    courseSession.startTime = new Date();
    courseSession.pageLoadTime = new Date();
    
    logUserActivity('course_session_start', {
        course_id: COURSE_DATA.id,
        course_title: COURSE_DATA.title,
        user_agent: navigator.userAgent,
        screen_resolution: `${screen.width}x${screen.height}`
    });
    
    // Check daily streak
    checkDailyStreak();
}

function initializeActivityTracking() {
    // Track page focus/blur for accurate study time
    document.addEventListener('visibilitychange', handleVisibilityChange);
    
    // Track user interactions
    ['click', 'keydown', 'scroll', 'mousemove'].forEach(event => {
        document.addEventListener(event, trackUserInteraction, { passive: true });
    });
    
    // Periodic activity updates
    setInterval(updateStudyTime, 60000); // Every minute
    
    // Save session data before page unload
    window.addEventListener('beforeunload', saveSessionData);
}

function handleVisibilityChange() {
    if (document.hidden) {
        courseSession.lastActivityTime = new Date();
    } else {
        // Page became visible again - update activity
        updateLastActivity();
    }
}

function trackUserInteraction() {
    courseSession.interactionCount++;
    courseSession.lastActivityTime = new Date();
    
    // Throttle activity updates
    if (courseSession.interactionCount % 50 === 0) {
        updateLastActivity();
    }
}

function updateStudyTime() {
    if (!courseSession.startTime || document.hidden) return;
    
    const now = new Date();
    const sessionDuration = now - courseSession.startTime;
    courseSession.totalStudyTime = Math.floor(sessionDuration / 1000 / 60); // in minutes
    
    // Update progress with study time
    saveProgress();
}

function saveSessionData() {
    if (!currentUser || !courseSession.startTime) return;
    
    const sessionData = {
        user_id: currentUser.id,
        course_id: COURSE_DATA.id,
        session_duration: courseSession.totalStudyTime,
        lessons_viewed: courseSession.lessonsStarted,
        lessons_completed: courseSession.lessonsCompleted,
        interactions: courseSession.interactionCount,
        session_date: courseSession.startTime.toISOString().split('T')[0]
    };
    
    // Store in localStorage as backup
    localStorage.setItem('course_session_backup', JSON.stringify(sessionData));
    
    // Try to save to database
    logUserActivity('course_session_end', sessionData);
}

// =====================================================
// COURSE DATA & PROGRESS MANAGEMENT
// =====================================================
async function loadCourseData() {
    try {
        // Update course info in UI
        document.getElementById('courseTitle').textContent = COURSE_DATA.title;
        document.getElementById('totalLessons').textContent = COURSE_DATA.lessons.length;
        
        // Log course access
        logUserActivity('course_access', {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title
        });
        
    } catch (error) {
        console.error('Error loading course data:', error);
    }
}

async function loadProgress() {
    try {
        // Get existing progress from database
        const { data, error } = await supabase
            .from('course_progress')
            .select('*')
            .eq('user_id', currentUser.id)
            .eq('course_id', COURSE_DATA.id)
            .single();

        if (error && error.code !== 'PGRST116') {
            throw error;
        }

        if (data) {
            courseProgress = JSON.parse(data.lesson_progress || '{}');
            currentLessonIndex = data.current_lesson || 0;
            
            // Update session tracking
            courseSession.lessonsStarted = Object.keys(courseProgress).length;
            courseSession.lessonsCompleted = Object.values(courseProgress).filter(p => p.completed).length;
        } else {
            // Initialize new progress
            courseProgress = {};
            currentLessonIndex = 0;
            await saveProgress();
            
            // Award first course start achievement
            await checkAndUnlockAchievement('first_course_start');
        }

        updateProgressDisplay();
        
    } catch (error) {
        console.error('Error loading progress:', error);
        showToast('Failed to load progress', 'error');
    }
}

async function saveProgress() {
    try {
        if (!currentUser) return;

        const now = new Date();
        const progressData = {
            user_id: currentUser.id,
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            current_lesson: currentLessonIndex,
            lesson_progress: JSON.stringify(courseProgress),
            progress: calculateOverallProgress(),
            lessons_completed: getCompletedLessonsCount(),
            lessons_started: Object.keys(courseProgress).length,
            study_time_minutes: courseSession.totalStudyTime,
            last_accessed: now.toISOString(),
            updated_at: now.toISOString()
        };

        // Upsert progress
        const { error } = await supabase
            .from('course_progress')
            .upsert([progressData]);

        if (error) throw error;

        // Update user stats
        await updateUserStats();
        
        updateProgressDisplay();

    } catch (error) {
        console.error('Error saving progress:', error);
        showToast('Failed to save progress', 'error');
    }
}

async function updateUserStats() {
    try {
        // Get all course progress for this user
        const { data: allProgress, error } = await supabase
            .from('course_progress')
            .select('progress, course_id, study_time_minutes')
            .eq('user_id', currentUser.id);

        if (error) throw error;

        // Calculate stats
        const completedCourses = allProgress?.filter(p => p.progress >= 100).length || 0;
        const inProgressCourses = allProgress?.filter(p => p.progress > 0 && p.progress < 100).length || 0;
        const totalStudyTime = allProgress?.reduce((sum, p) => sum + (p.study_time_minutes || 0), 0) || 0;

        // Calculate points (500 per completed course + achievement points)
        const coursePoints = completedCourses * 500;
        const bonusPoints = userStats.bonus_points || 0;
        const totalPoints = coursePoints + bonusPoints;

        // Update profile
        const updateData = {
            completed_courses: completedCourses,
            in_progress_courses: inProgressCourses,
            total_points: totalPoints,
            total_study_time: totalStudyTime,
            last_activity: new Date().toISOString()
        };

        const { error: updateError } = await supabase
            .from('profiles')
            .update(updateData)
            .eq('id', currentUser.id);

        if (updateError) throw updateError;

        // Update local stats
        Object.assign(userStats, updateData);

    } catch (error) {
        console.error('Error updating user stats:', error);
    }
}

function calculateOverallProgress() {
    const completedLessons = getCompletedLessonsCount();
    return Math.round((completedLessons / COURSE_DATA.lessons.length) * 100);
}

function getCompletedLessonsCount() {
    return Object.values(courseProgress).filter(lesson => lesson.completed).length;
}

function updateProgressDisplay() {
    const completedCount = getCompletedLessonsCount();
    const progressPercent = calculateOverallProgress();
    
    // Update UI elements
    const elements = {
        'completedLessons': completedCount,
        'courseProgressPercent': `${progressPercent}%`
    };
    
    Object.entries(elements).forEach(([id, value]) => {
        const element = document.getElementById(id);
        if (element) element.textContent = value;
    });
    
    // Update progress bar
    const progressBar = document.getElementById('courseProgressFill');
    if (progressBar) progressBar.style.width = `${progressPercent}%`;
}

// =====================================================
// LESSON MANAGEMENT
// =====================================================
function loadLesson(index) {
    if (index < 0 || index >= COURSE_DATA.lessons.length) return;

    const lesson = COURSE_DATA.lessons[index];
    currentLessonIndex = index;

    // Mark lesson as started and track activity
    if (!courseProgress[lesson.id]) {
        courseProgress[lesson.id] = { 
            started: true, 
            completed: false,
            startedAt: new Date().toISOString(),
            timeSpent: 0
        };
        
        courseSession.lessonsStarted++;
        saveProgress();
        
        // Log lesson start
        logUserActivity('lesson_start', {
            lesson_id: lesson.id,
            lesson_title: lesson.title,
            lesson_index: index
        });
    }

    // Update lesson start time for time tracking
    courseProgress[lesson.id].currentSessionStart = new Date();

    // Update sidebar and navigation
    renderSidebar();
    updateNavigationButtons();

    // Update header info
    updateLessonHeader(lesson, index);

    // Render lesson content
    renderLessonContent(lesson);

    // Smooth scroll and animations
    window.scrollTo({ top: 0, behavior: 'smooth' });
    document.getElementById('contentBody').scrollTop = 0;

    const contentBody = document.getElementById('contentBody');
    contentBody.classList.add('fade-in');
    setTimeout(() => contentBody.classList.remove('fade-in'), 500);
    
    // Check lesson-based achievements
    checkLessonAchievements(index + 1);
}

function updateLessonHeader(lesson, index) {
    const elements = {
        'currentLessonNumber': index + 1,
        'currentLessonTitle': lesson.title,
        'navInfo': `Lesson ${index + 1} of ${COURSE_DATA.lessons.length}`
    };
    
    Object.entries(elements).forEach(([id, value]) => {
        const element = document.getElementById(id);
        if (element) element.textContent = value;
    });
}

function renderSidebar() {
    const lessonNav = document.getElementById('lessonNav');
    if (!lessonNav) return;
    
    lessonNav.innerHTML = '';

    COURSE_DATA.lessons.forEach((lesson, index) => {
        const lessonItem = document.createElement('div');
        lessonItem.className = 'lesson-item';
        
        // Determine lesson status
        const lessonProgress = courseProgress[lesson.id];
        const isCompleted = lessonProgress?.completed || false;
        const isInProgress = lessonProgress?.started || false;
        const isLocked = !isCompleted && !canAccessLesson(index);
        const isActive = index === currentLessonIndex;

        // Apply status classes
        if (isCompleted) lessonItem.classList.add('completed');
        if (isLocked) lessonItem.classList.add('locked');
        if (isActive) lessonItem.classList.add('active');

        // Determine status display
        let statusClass = 'not-started';
        let statusIcon = index + 1;
        
        if (isCompleted) {
            statusClass = 'completed';
            statusIcon = '✓';
        } else if (isInProgress) {
            statusClass = 'in-progress';
            statusIcon = '◐';
        }

        // Create lesson item HTML
        lessonItem.innerHTML = `
            <div class="lesson-status ${statusClass}">${statusIcon}</div>
            <div class="lesson-info">
                <div class="lesson-title">${lesson.title}</div>
                <div class="lesson-meta">
                    ${isCompleted ? 'Completed' : 
                      isInProgress ? 'In Progress' : 
                      isLocked ? 'Locked' : 'Not Started'}
                </div>
            </div>
            <div class="lesson-duration">${lesson.duration}</div>
        `;

        // Add click handler if not locked
        if (!isLocked) {
            lessonItem.addEventListener('click', () => {
                if (index !== currentLessonIndex) {
                    // Track lesson time before switching
                    trackLessonTime();
                    
                    currentLessonIndex = index;
                    loadLesson(index);
                    closeSidebar();
                }
            });
        }

        lessonNav.appendChild(lessonItem);
    });
}

function canAccessLesson(index) {
    if (index === 0) return true; // First lesson always accessible
    
    // Can access if previous lesson is completed
    const previousLessonId = COURSE_DATA.lessons[index - 1].id;
    return courseProgress[previousLessonId]?.completed || false;
}

function trackLessonTime() {
    const currentLesson = COURSE_DATA.lessons[currentLessonIndex];
    const lessonProgress = courseProgress[currentLesson.id];
    
    if (lessonProgress?.currentSessionStart) {
        const sessionTime = Math.floor((new Date() - new Date(lessonProgress.currentSessionStart)) / 1000 / 60);
        lessonProgress.timeSpent = (lessonProgress.timeSpent || 0) + sessionTime;
        delete lessonProgress.currentSessionStart;
    }
}

// =====================================================
// LESSON CONTENT RENDERING
// =====================================================
function renderLessonContent(lesson) {
    const contentContainer = document.getElementById('lessonContent');
    if (!contentContainer) return;
    
    let contentHTML = `
        <div class="content-section">
            <h2>Learning Objectives</h2>
            <ul>
                ${lesson.objectives.map(obj => `<li>${obj}</li>`).join('')}
            </ul>
        </div>
        
        <div class="content-section">
            <h2>Overview</h2>
            <p>${lesson.content.overview}</p>
        </div>
    `;

    // Render content sections
    lesson.content.sections.forEach(section => {
        contentHTML += `
            <div class="content-section">
                <h2>${section.title}</h2>
                ${section.content}
                ${section.image ? `<img src="${section.image}" alt="${section.title}" class="content-image" loading="lazy">` : ''}
            </div>
        `;
    });

    // Render code examples
    if (lesson.content.codeExamples && lesson.content.codeExamples.length > 0) {
        contentHTML += `<div class="content-section"><h2>Code Examples</h2></div>`;
        
        lesson.content.codeExamples.forEach((example, index) => {
            const codeId = `code-${lesson.id}-${index}`;
            contentHTML += `
                <div class="code-section">
                    <div class="code-header">
                        <span class="code-title">${example.title}</span>
                        <button class="copy-btn" onclick="copyCode('${codeId}')">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <pre class="code-block"><code id="${codeId}" class="language-${example.language}">${escapeHtml(example.code)}</code></pre>
                </div>
            `;
        });
    }

    // Render quiz
    contentHTML += renderQuiz(lesson.quiz);

    contentContainer.innerHTML = contentHTML;

    // Highlight code syntax if Prism is available
    setTimeout(() => {
        if (window.Prism) {
            Prism.highlightAll();
        }
    }, 100);
}

// =====================================================
// QUIZ SYSTEM
// =====================================================
function renderQuiz(quiz) {
    const currentLessonProgress = courseProgress[COURSE_DATA.lessons[currentLessonIndex].id];
    const isCompleted = currentLessonProgress?.completed || false;
    
    let quizHTML = `
        <div class="quiz-section" id="quizSection">
            <div class="quiz-header">
                <h2 class="quiz-title">
                    <i class="fas fa-clipboard-check"></i>
                    Knowledge Check
                </h2>
                <p class="quiz-info">
                    Complete this quiz with ${quiz.passingScore}% or higher to unlock the next lesson.
                </p>
            </div>
    `;

    if (isCompleted) {
        const savedScore = currentLessonProgress.quizScore || 0;
        quizHTML += `
            <div class="quiz-results show">
                <div class="quiz-score pass">${savedScore}%</div>
                <div class="quiz-message">
                    <strong>Lesson Completed!</strong><br>
                    You've successfully passed this lesson's quiz.
                </div>
            </div>
        `;
    } else {
        // Render quiz questions
        quiz.questions.forEach((question, qIndex) => {
            quizHTML += `
                <div class="quiz-question ${qIndex === 0 ? 'active' : ''}" data-question="${qIndex}">
                    <div class="question-header">
                        <span class="question-number">Question ${qIndex + 1}</span>
                        <span class="question-progress">${qIndex + 1}/${quiz.questions.length}</span>
                    </div>
                    <div class="question-text">${question.question}</div>
                    <div class="question-options">
                        ${question.options.map((option, oIndex) => `
                            <div class="option" data-option="${oIndex}" onclick="selectOption(${qIndex}, ${oIndex})">
                                <span class="option-letter">${String.fromCharCode(65 + oIndex)}</span>
                                <span class="option-text">${option}</span>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        });

        quizHTML += `
            <div class="quiz-controls">
                <button class="btn btn-secondary" id="prevQuestionBtn" onclick="previousQuestion()" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <div>
                    <button class="btn btn-secondary" id="nextQuestionBtn" onclick="nextQuestion()" disabled>
                        Next
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <button class="btn btn-primary" id="submitQuizBtn" onclick="submitQuiz()" style="display: none;">
                        <i class="fas fa-check"></i>
                        Submit Quiz
                    </button>
                </div>
            </div>

            <div class="quiz-results" id="quizResults">
                <div class="quiz-score" id="quizScore">0%</div>
                <div class="quiz-message" id="quizMessage"></div>
                <div class="quiz-actions">
                    <button class="btn btn-primary" id="continueBtn" onclick="completeLesson()" style="display: none;">
                        <i class="fas fa-arrow-right"></i>
                        Continue to Next Lesson
                    </button>
                    <button class="btn btn-secondary" onclick="retakeQuiz()">
                        <i class="fas fa-redo"></i>
                        Retake Quiz
                    </button>
                </div>
            </div>
        `;
    }

    quizHTML += '</div>';
    return quizHTML;
}

// Quiz interaction functions
function selectOption(questionIndex, optionIndex) {
    // Clear previous selections
    document.querySelectorAll(`[data-question="${questionIndex}"] .option`).forEach(opt => {
        opt.classList.remove('selected');
    });

    // Select current option
    const selectedOption = document.querySelector(`[data-question="${questionIndex}"] [data-option="${optionIndex}"]`);
    selectedOption.classList.add('selected');

    // Store answer
    quizState.answers[questionIndex] = optionIndex;

    // Update navigation
    const isLastQuestion = questionIndex === COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length - 1;
    if (isLastQuestion) {
        document.getElementById('submitQuizBtn').style.display = 'inline-flex';
        document.getElementById('nextQuestionBtn').style.display = 'none';
    } else {
        document.getElementById('nextQuestionBtn').disabled = false;
    }
}

function nextQuestion() {
    const currentQuestionEl = document.querySelector('.quiz-question.active');
    const nextQuestionEl = currentQuestionEl.nextElementSibling;
    
    if (nextQuestionEl && nextQuestionEl.classList.contains('quiz-question')) {
        currentQuestionEl.classList.remove('active');
        nextQuestionEl.classList.add('active');
        quizState.currentQuestion++;
        updateQuizNavigation();
    }
}

function previousQuestion() {
    const currentQuestionEl = document.querySelector('.quiz-question.active');
    const prevQuestionEl = currentQuestionEl.previousElementSibling;
    
    if (prevQuestionEl && prevQuestionEl.classList.contains('quiz-question')) {
        currentQuestionEl.classList.remove('active');
        prevQuestionEl.classList.add('active');
        quizState.currentQuestion--;
        updateQuizNavigation();
    }
}

function updateQuizNavigation() {
    const totalQuestions = COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length;
    const prevBtn = document.getElementById('prevQuestionBtn');
    const nextBtn = document.getElementById('nextQuestionBtn');
    const submitBtn = document.getElementById('submitQuizBtn');

    prevBtn.disabled = quizState.currentQuestion === 0;
    
    const hasAnswer = quizState.answers[quizState.currentQuestion] !== undefined;
    const isLastQuestion = quizState.currentQuestion === totalQuestions - 1;
    
    if (isLastQuestion) {
        nextBtn.style.display = 'none';
        submitBtn.style.display = hasAnswer ? 'inline-flex' : 'none';
    } else {
        nextBtn.style.display = 'inline-flex';
        nextBtn.disabled = !hasAnswer;
        submitBtn.style.display = 'none';
    }
}

async function submitQuiz() {
    const lesson = COURSE_DATA.lessons[currentLessonIndex];
    const quiz = lesson.quiz;
    let correctAnswers = 0;

    // Hide questions and controls
    document.querySelectorAll('.quiz-question').forEach(q => q.style.display = 'none');
    document.querySelector('.quiz-controls').style.display = 'none';

    // Calculate score and highlight answers
    quiz.questions.forEach((question, index) => {
        const userAnswer = quizState.answers[index];
        const correctAnswer = question.correct;
        const isCorrect = userAnswer === correctAnswer;
        
        if (isCorrect) correctAnswers++;

        // Highlight answers
        const questionEl = document.querySelector(`[data-question="${index}"]`);
        const options = questionEl.querySelectorAll('.option');
        
        options[correctAnswer].classList.add('correct');
        if (userAnswer !== correctAnswer && userAnswer !== undefined) {
            options[userAnswer].classList.add('incorrect');
        }
    });

    const score = Math.round((correctAnswers / quiz.questions.length) * 100);
    const passed = score >= quiz.passingScore;

    // Update quiz results UI
    const quizScore = document.getElementById('quizScore');
    const quizMessage = document.getElementById('quizMessage');
    const quizActions = document.querySelector('.quiz-actions');

    quizScore.textContent = `${score}%`;
    quizScore.className = `quiz-score ${passed ? 'pass' : 'fail'}`;

    if (passed) {
        quizMessage.innerHTML = `
            <strong>Congratulations!</strong><br>
            You passed with ${score}%. You can now proceed to the next lesson.
        `;
        
        quizActions.innerHTML = `
            <button class="btn btn-primary" onclick="completeLesson()">
                <i class="fas fa-arrow-right"></i>
                Continue to Next Lesson
            </button>
        `;
        
        // Mark lesson as completed
        await markLessonComplete(score);
        
    } else {
        quizMessage.innerHTML = `
            <strong>Not quite there yet.</strong><br>
            You scored ${score}%. You need ${quiz.passingScore}% to pass. Review the material and try again.
        `;
        
        quizActions.innerHTML = `
            <button class="btn btn-secondary" onclick="retakeQuiz()">
                <i class="fas fa-redo"></i>
                Retake Quiz
            </button>
        `;
    }

    document.getElementById('quizResults').classList.add('show');
    
    // Log quiz completion
    logUserActivity('quiz_completed', {
        lesson_id: lesson.id,
        lesson_title: lesson.title,
        score: score,
        passed: passed,
        attempts: (courseProgress[lesson.id]?.quizAttempts || 0) + 1
    });

    // Scroll to results
    document.getElementById('quizResults').scrollIntoView({ behavior: 'smooth' });
}

function retakeQuiz() {
    // Reset quiz state
    quizState = {
        currentQuestion: 0,
        answers: [],
        score: 0,
        isComplete: false
    };

    // Track quiz retry
    const lessonId = COURSE_DATA.lessons[currentLessonIndex].id;
    if (!courseProgress[lessonId]) courseProgress[lessonId] = {};
    courseProgress[lessonId].quizAttempts = (courseProgress[lessonId].quizAttempts || 0) + 1;

    // Reload lesson content
    loadLesson(currentLessonIndex);
    
    // Scroll to quiz
    setTimeout(() => {
        document.getElementById('quizSection').scrollIntoView({ behavior: 'smooth' });
    }, 500);
}

async function markLessonComplete(score) {
    const lesson = COURSE_DATA.lessons[currentLessonIndex];
    const lessonId = lesson.id;
    
    // Track lesson completion time
    trackLessonTime();
    
    // Update lesson progress
    courseProgress[lessonId] = {
        ...courseProgress[lessonId],
        completed: true,
        quizScore: score,
        completedAt: new Date().toISOString(),
        finalScore: score
    };

    // Update session tracking
    courseSession.lessonsCompleted++;

    // Save progress to database
    await saveProgress();
    
    // Update UI
    renderSidebar();
    updateNavigationButtons();

    // Check various achievements
    await checkLessonCompletionAchievements();
    await checkPerfectScoreAchievements(score);
    await checkStudyTimeAchievements();
    
    // Log lesson completion
    logUserActivity('lesson_completed', {
        lesson_id: lessonId,
        lesson_title: lesson.title,
        final_score: score,
        time_spent: courseProgress[lessonId].timeSpent || 0,
        lesson_number: currentLessonIndex + 1
    });
    
    showToast('Lesson completed successfully!', 'success');
}

async function completeLesson() {
    if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
        // Move to next lesson
        currentLessonIndex++;
        loadLesson(currentLessonIndex);
        
    } else {
        // Course completion
        await completeCourse();
    }
}

async function completeCourse() {
    try {
        const completionTime = courseSession.totalStudyTime;
        
        // Update course progress to 100% completed
        await supabase
            .from('course_progress')
            .update({
                progress: 100,
                completed_at: new Date().toISOString(),
                completion_time_minutes: completionTime
            })
            .eq('user_id', currentUser.id)
            .eq('course_id', COURSE_DATA.id);

        // Award course completion achievements
        await checkAndUnlockAchievement('course_completion_1');
        await checkSpeedCompletionAchievements(completionTime);
        await checkCourseStreakAchievements();
        
        // Update user stats
        await updateUserStats();
        
        // Show completion message
        showToast('Congratulations! Course completed successfully!', 'certificate');
        
        // Log course completion
        logUserActivity('course_completed', {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            completion_time_minutes: completionTime,
            total_lessons: COURSE_DATA.lessons.length,
            average_quiz_score: calculateAverageQuizScore()
        });
        
        // Redirect to dashboard after delay
        setTimeout(() => {
            window.location.href = '/dashboard.html';
        }, 3000);
        
    } catch (error) {
        console.error('Error completing course:', error);
        showToast('Error marking course as complete', 'error');
    }
}

// =====================================================
// ACHIEVEMENT INTEGRATION SYSTEM
// =====================================================
async function checkAndUnlockAchievement(achievementId, skipNotification = false) {
    try {
        // Prevent duplicate checks
        const cacheKey = `achievement_${achievementId}_${currentUser.id}`;
        if (sessionStorage.getItem(cacheKey)) return false;

        // Check if already unlocked
        const { data: existing, error } = await supabase
            .from('user_achievements')
            .select('id')
            .eq('user_id', currentUser.id)
            .eq('achievement_id', achievementId)
            .single();

        if (existing) {
            sessionStorage.setItem(cacheKey, 'true');
            return false;
        }

        // Award achievement
        const achievementData = {
            user_id: currentUser.id,
            achievement_id: achievementId,
            unlocked_at: new Date().toISOString(),
            points_awarded: getAchievementPoints(achievementId),
            context: 'course_system'
        };

        const { data, error: insertError } = await supabase
            .from('user_achievements')
            .insert([achievementData])
            .select()
            .single();

        if (insertError) {
            if (insertError.code === '23505') return false; // Already exists
            throw insertError;
        }

        // Update user points
      await supabase.rpc('increment_user_stats', {
  user_id_param: currentUser.id,
  points_to_add: achievementData.points_awarded,
  achievements_to_add: 1
});

        // Cache and queue notification
        sessionStorage.setItem(cacheKey, 'true');
        
        if (!skipNotification) {
            queueAchievementNotification({
                id: achievementId,
                name: getAchievementName(achievementId),
                description: getAchievementDescription(achievementId),
                points: achievementData.points_awarded,
                rarity: getAchievementRarity(achievementId),
                icon: getAchievementIcon(achievementId)
            });
        }

        return true;

    } catch (error) {
        console.error('Error unlocking achievement:', error);
        return false;
    }
}

// Helper functions for achievement data (replace with your actual achievement definitions)
function getAchievementPoints(id) {
    const pointsMap = {
        'first_course_start': 75,
        'first_lesson': 100,
        'course_completion_1': 500,
        'perfect_score': 250,
        'speed_demon': 750,
        'marathon_learner': 500,
        'night_owl': 200,
        'early_bird': 200,
        'weekend_warrior': 150,
        // Add more as needed
    };
    return pointsMap[id] || 100;
}

function getAchievementName(id) {
    const nameMap = {
        'first_course_start': 'Learning Initiated',
        'first_lesson': 'First Steps',
        'course_completion_1': 'Course Conqueror',
        'perfect_score': 'Perfectionist',
        'speed_demon': 'Speed Demon',
        // Add more as needed
    };
    return nameMap[id] || 'Achievement Unlocked';
}

function getAchievementDescription(id) {
    const descMap = {
        'first_course_start': 'Start your first cybersecurity course',
        'first_lesson': 'Complete your first lesson',
        'course_completion_1': 'Complete your first course',
        'perfect_score': 'Score 100% on any quiz',
        'speed_demon': 'Complete a course in under 2 hours',
        // Add more as needed
    };
    return descMap[id] || 'Achievement description';
}

function getAchievementRarity(id) {
    const rarityMap = {
        'first_course_start': 'common',
        'first_lesson': 'bronze',
        'course_completion_1': 'silver',
        'perfect_score': 'gold',
        'speed_demon': 'legendary',
        // Add more as needed
    };
    return rarityMap[id] || 'common';
}

function getAchievementIcon(id) {
    const iconMap = {
        'first_course_start': 'fas fa-play',
        'first_lesson': 'fas fa-baby',
        'course_completion_1': 'fas fa-trophy',
        'perfect_score': 'fas fa-star',
        'speed_demon': 'fas fa-rocket',
        // Add more as needed
    };
    return iconMap[id] || 'fas fa-award';
}

async function checkLessonAchievements(lessonNumber) {
    if (lessonNumber === 1) {
        await checkAndUnlockAchievement('first_lesson');
    }
    
    // Check if user has completed multiple lessons in one day
    const today = new Date().toISOString().split('T')[0];
    const todayCompletions = Object.values(courseProgress).filter(p => 
        p.completed && p.completedAt?.startsWith(today)
    ).length;
    
    if (todayCompletions >= 3) {
        await checkAndUnlockAchievement('lesson_marathon');
    }
}

async function checkLessonCompletionAchievements() {
    const completedCount = getCompletedLessonsCount();
    
    // Lesson-based achievements
    const lessonMilestones = [1, 5, 10, 25, 50, 100];
    for (const milestone of lessonMilestones) {
        if (completedCount >= milestone) {
            await checkAndUnlockAchievement(`lessons_${milestone}`);
        }
    }
    
    // Course completion achievements
    if (completedCount === COURSE_DATA.lessons.length) {
        await checkAndUnlockAchievement('course_completion_1');
        
        // Check for additional course completion achievements
        const { data: allCourses } = await supabase
            .from('course_progress')
            .select('course_id')
            .eq('user_id', currentUser.id)
            .eq('progress', 100);
        
        const totalCompleted = allCourses?.length || 0;
        
        const courseMilestones = [1, 5, 10, 25];
        for (const milestone of courseMilestones) {
            if (totalCompleted >= milestone) {
                await checkAndUnlockAchievement(`course_completion_${milestone}`);
            }
        }
    }
}

async function checkPerfectScoreAchievements(score) {
    if (score === 100) {
        await checkAndUnlockAchievement('perfect_score');
        
        // Check for consecutive perfect scores
        const recentScores = Object.values(courseProgress)
            .filter(p => p.completed && p.quizScore)
            .slice(-5) // Last 5 completed
            .map(p => p.quizScore);
        
        if (recentScores.length >= 3 && recentScores.every(s => s === 100)) {
            await checkAndUnlockAchievement('perfectionist_streak');
        }
    }
}

async function checkSpeedCompletionAchievements(completionTime) {
    // Speed demon: Complete course in under 2 hours (120 minutes)
    if (completionTime <= 120) {
        await checkAndUnlockAchievement('speed_demon');
    }
    
    // Quick learner: Complete course in under 4 hours (240 minutes)
    if (completionTime <= 240) {
        await checkAndUnlockAchievement('quick_learner');
    }
}

async function checkStudyTimeAchievements() {
    const totalTime = courseSession.totalStudyTime;
    
    // Marathon learner: Study for 8+ hours in a course session
    if (totalTime >= 480) { // 8 hours
        await checkAndUnlockAchievement('marathon_learner');
    }
    
    // Dedicated learner: Study for 4+ hours
    if (totalTime >= 240) { // 4 hours
        await checkAndUnlockAchievement('dedicated_learner');
    }
}

async function checkCourseStreakAchievements() {
    try {
        // Check for consecutive course completions
        const { data: recentCourses, error } = await supabase
            .from('course_progress')
            .select('completed_at, course_id')
            .eq('user_id', currentUser.id)
            .eq('progress', 100)
            .order('completed_at', { ascending: false })
            .limit(10);

        if (error || !recentCourses) return;

        // Check for courses completed on consecutive days
        let consecutiveDays = 1;
        for (let i = 1; i < recentCourses.length; i++) {
            const prevDate = new Date(recentCourses[i-1].completed_at).toDateString();
            const currentDate = new Date(recentCourses[i].completed_at).toDateString();
            const dayDiff = Math.abs(new Date(prevDate) - new Date(currentDate)) / (1000 * 60 * 60 * 24);
            
            if (dayDiff <= 1) {
                consecutiveDays++;
            } else {
                break;
            }
        }

        if (consecutiveDays >= 3) {
            await checkAndUnlockAchievement('learning_streak');
        }

    } catch (error) {
        console.error('Error checking course streak achievements:', error);
    }
}

// =====================================================
// TIME-BASED ACHIEVEMENTS
// =====================================================
async function checkTimeBasedAchievements(timestamp) {
    const hour = timestamp.getHours();
    const dayOfWeek = timestamp.getDay();

    // Night owl (after midnight, before 6 AM)
    if (hour >= 0 && hour < 6) {
        await incrementTimeBasedCounter('midnight_sessions', 'night_owl');
    }

    // Early bird (4 AM to 6 AM)
    if (hour >= 4 && hour < 6) {
        await incrementTimeBasedCounter('early_sessions', 'early_bird');
    }

    // Weekend warrior (Saturday = 6, Sunday = 0)
    if (dayOfWeek === 0 || dayOfWeek === 6) {
        await incrementTimeBasedCounter('weekend_sessions', 'weekend_warrior');
    }
}

async function incrementTimeBasedCounter(counterType, achievementId) {
    try {
        const dateStr = new Date().toISOString().split('T')[0];
        const cacheKey = `${counterType}_${currentUser.id}_${dateStr}`;

        // Prevent multiple increments per day
        if (sessionStorage.getItem(cacheKey)) return;

        // Update counter
       await supabase.rpc('increment_profile_counter', {
  user_id_param: currentUser.id,
  counter_field: counterType,
  increment_value: 1
});

        // Cache to prevent double counting
        sessionStorage.setItem(cacheKey, 'true');

        // Check related achievement
        if (achievementId) {
            await checkAndUnlockAchievement(achievementId, true);
        }

    } catch (error) {
        console.error(`Error incrementing ${counterType}:`, error);
    }
}

async function checkDailyStreak() {
    try {
        const { data: profile, error } = await supabase
            .from('profiles')
            .select('last_activity, current_streak, last_streak_date')
            .eq('id', currentUser.id)
            .single();

        if (error) throw error;

        const now = new Date();
        const today = now.toDateString();
        const lastActivity = profile.last_activity ? new Date(profile.last_activity) : null;
        const lastStreakDate = profile.last_streak_date ? new Date(profile.last_streak_date).toDateString() : null;

        let newStreak = profile.current_streak || 0;
        let shouldUpdateStreak = false;

        if (!lastActivity) {
            // First time user
            newStreak = 1;
            shouldUpdateStreak = true;
        } else {
            const daysSinceLastActivity = Math.floor((now - lastActivity) / (1000 * 60 * 60 * 24));
            
            if (lastStreakDate === today) {
                // Already counted today's streak
                return newStreak;
            } else if (daysSinceLastActivity === 1 || (daysSinceLastActivity === 0 && lastStreakDate !== today)) {
                // Consecutive day or same day but not counted yet
                newStreak += 1;
                shouldUpdateStreak = true;
            } else if (daysSinceLastActivity > 1) {
                // Streak broken
                newStreak = 1;
                shouldUpdateStreak = true;
            }
        }

        if (shouldUpdateStreak) {
            await supabase
                .from('profiles')
                .update({
                    current_streak: newStreak,
                    last_activity: now.toISOString(),
                    last_streak_date: now.toISOString()
                })
                .eq('id', currentUser.id);

            userStats.current_streak = newStreak;
            
            showToast(`Daily streak: ${newStreak} days!`, 'success');
            await checkStreakAchievements(newStreak);
        }

        return newStreak;
        
    } catch (error) {
        console.error('Error checking daily streak:', error);
        return 0;
    }
}

async function checkStreakAchievements(currentStreak) {
    const streakMilestones = [3, 7, 14, 30, 100, 365];
    
    for (const milestone of streakMilestones) {
        if (currentStreak >= milestone) {
            await checkAndUnlockAchievement(`streak_${milestone}`);
        }
    }
}

// =====================================================
// USER ACTIVITY LOGGING
// =====================================================
async function logUserActivity(activityType, metadata = {}) {
    try {
        const now = new Date();
        
        const activityData = {
            user_id: currentUser.id,
            activity_type: activityType,
            timestamp: now.toISOString(),
            course_id: COURSE_DATA.id,
            lesson_index: currentLessonIndex,
            session_duration: courseSession.totalStudyTime,
            metadata: JSON.stringify(metadata),
            created_at: now.toISOString()
        };

        // Try to log to activities table
        const { error } = await supabase
            .from('user_activities')
            .insert([activityData]);

        if (error && error.code !== '42P01') {
            console.warn('Activity logging failed:', error.message);
        }

        // Always update last activity in profile
        await supabase
            .from('profiles')
            .update({ last_activity: now.toISOString() })
            .eq('id', currentUser.id);

    } catch (error) {
        console.error('Error logging user activity:', error);
    }
}

// =====================================================
// NAVIGATION SYSTEM
// =====================================================
function updateNavigationButtons() {
    const prevBtn = document.getElementById('prevLessonBtn');
    const nextBtn = document.getElementById('nextLessonBtn');
    
    if (!prevBtn || !nextBtn) return;

    // Previous button
    prevBtn.disabled = currentLessonIndex === 0;
    
    // Next button logic
    const isLastLesson = currentLessonIndex === COURSE_DATA.lessons.length - 1;
    const canGoNext = currentLessonIndex < COURSE_DATA.lessons.length - 1 && 
                     canAccessLesson(currentLessonIndex + 1);
    
    if (isLastLesson) {
        const isCurrentCompleted = courseProgress[COURSE_DATA.lessons[currentLessonIndex].id]?.completed;
        nextBtn.disabled = !isCurrentCompleted;
        nextBtn.innerHTML = '<i class="fas fa-trophy"></i> Complete Course';
    } else {
        nextBtn.disabled = !canGoNext;
        nextBtn.innerHTML = 'Next <i class="fas fa-chevron-right"></i>';
    }
}

// Navigation button event handlers
function goToPreviousLesson() {
    if (currentLessonIndex > 0) {
        trackLessonTime(); // Track time spent on current lesson
        currentLessonIndex--;
        loadLesson(currentLessonIndex);
    }
}

function goToNextLesson() {
    if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
        const canGoNext = canAccessLesson(currentLessonIndex + 1);
        if (canGoNext) {
            trackLessonTime();
            currentLessonIndex++;
            loadLesson(currentLessonIndex);
        } else {
            showToast('Complete the current lesson quiz to proceed', 'warning');
        }
    } else {
        // Complete course
        completeCourse();
    }
}

// =====================================================
// SIDEBAR FUNCTIONS
// =====================================================
function toggleSidebar() {
    const sidebar = document.getElementById('sidebar');
    const overlay = document.getElementById('sidebarOverlay');
    
    if (sidebar) sidebar.classList.toggle('open');
    if (overlay) overlay.classList.toggle('active');
}

function closeSidebar() {
    const sidebar = document.getElementById('sidebar');
    const overlay = document.getElementById('sidebarOverlay');
    
    if (sidebar) sidebar.classList.remove('open');
    if (overlay) overlay.classList.remove('active');
}

// =====================================================
// ACHIEVEMENT NOTIFICATION SYSTEM
// =====================================================
function queueAchievementNotification(achievement) {
    notificationQueue.push(achievement);
    processNotificationQueue();
}

function processNotificationQueue() {
    if (isShowingNotification || notificationQueue.length === 0) return;

    isShowingNotification = true;
    const achievement = notificationQueue.shift();
    showAchievementNotification(achievement);

    const duration = achievement.rarity === 'mythic' ? 8000 :
                     achievement.rarity === 'legendary' ? 7000 : 6000;

    setTimeout(() => {
        isShowingNotification = false;
        processNotificationQueue();
    }, duration + 500);
}

function showAchievementNotification(achievement) {
    const notification = document.getElementById('achievementNotification');
    if (!notification) return;

    const icon = document.getElementById('notificationIcon');
    const title = document.getElementById('notificationTitle');
    const description = document.getElementById('notificationDescription');
    const points = document.getElementById('notificationPoints');

    if (icon) {
        icon.innerHTML = `<i class="${achievement.icon}"></i>`;
        icon.className = `notification-icon ${achievement.rarity}`;
    }
    if (title) title.textContent = achievement.name;
    if (description) description.textContent = achievement.description;
    if (points) points.textContent = `+${achievement.points} Points`;

    notification.className = `achievement-notification ${achievement.rarity}`;
    notification.classList.add('show');

    const duration = achievement.rarity === 'mythic' ? 8000 :
                     achievement.rarity === 'legendary' ? 7000 : 6000;

    setTimeout(() => {
        notification.classList.remove('show');
    }, duration);
}

// =====================================================
// UTILITY FUNCTIONS
// =====================================================
function calculateAverageQuizScore() {
    const scores = Object.values(courseProgress)
        .filter(p => p.completed && p.quizScore)
        .map(p => p.quizScore);
    
    if (scores.length === 0) return 0;
    return Math.round(scores.reduce((sum, score) => sum + score, 0) / scores.length);
}

async function resetProgress() {
    if (!confirm('Are you sure you want to reset your progress? This action cannot be undone.')) {
        return;
    }

    try {
        // Track lesson time before reset
        trackLessonTime();
        
        // Reset local state
        courseProgress = {};
        currentLessonIndex = 0;
        courseSession = {
            startTime: new Date(),
            totalStudyTime: 0,
            lessonsStarted: 0,
            lessonsCompleted: 0,
            pageLoadTime: new Date(),
            interactionCount: 0,
            lastActivityTime: new Date()
        };
        
        // Delete from database
        await supabase
            .from('course_progress')
            .delete()
            .eq('user_id', currentUser.id)
            .eq('course_id', COURSE_DATA.id);

        // Log reset activity
        logUserActivity('progress_reset', {
            course_id: COURSE_DATA.id,
            reset_reason: 'manual'
        });

        // Reinitialize
        await saveProgress();
        renderSidebar();
        loadLesson(0);
        
        showToast('Progress reset successfully', 'success');
        
    } catch (error) {
        console.error('Error resetting progress:', error);
        showToast('Failed to reset progress', 'error');
    }
}

function copyCode(codeId) {
    const codeElement = document.getElementById(codeId);
    if (!codeElement) return;
    
    const text = codeElement.textContent;
    
    navigator.clipboard.writeText(text).then(() => {
        showToast('Code copied to clipboard!', 'success');
        
        // Track code copy for achievements
        logUserActivity('code_copied', {
            code_section: codeId,
            lesson_id: COURSE_DATA.lessons[currentLessonIndex].id
        });
        
    }).catch(err => {
        console.error('Failed to copy code:', err);
        showToast('Failed to copy code', 'error');
        
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.select();
        try {
            document.execCommand('copy');
            showToast('Code copied to clipboard!', 'success');
        } catch (fallbackError) {
            showToast('Copy failed - please select and copy manually', 'error');
        }
        document.body.removeChild(textArea);
    });
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// =====================================================
// UI FEEDBACK SYSTEMS
// =====================================================
function showToast(message, type = 'success') {
    const toast = document.getElementById('toast');
    const messageEl = document.getElementById('toastMessage');
    
    if (!toast || !messageEl) {
        console.log(`Toast: ${message} (${type})`);
        return;
    }
    
    messageEl.textContent = message;
    toast.className = `toast ${type} show`;

    setTimeout(() => {
        toast.classList.remove('show');
    }, 4000);
}

function showLoadingScreen() {
    const loadingScreen = document.getElementById('loadingScreen');
    if (loadingScreen) loadingScreen.classList.remove('hidden');
}

function hideLoadingScreen() {
    const loadingScreen = document.getElementById('loadingScreen');
    if (loadingScreen) {
        setTimeout(() => {
            loadingScreen.classList.add('hidden');
        }, 1000);
    }
}

// =====================================================
// MUSIC PLAYER INTEGRATION
// =====================================================
function initMusicPlayer() {
    const btnText = document.getElementById('music-button-text');
    const icon = document.getElementById('music-icon');
    const dropdown = document.getElementById('music-dropdown-content');
    
    if (!btnText || !icon || !dropdown) return;
    
    function setUI(state) {
        btnText.textContent = state === "Playing" ? "PAUSE MUSIC" : "STUDY MUSIC";
        icon.className = state === "Playing" ? "fa-solid fa-circle-pause" : "fa-solid fa-music";
    }

    // Load saved music state
    const savedSrc = localStorage.getItem("cybersec_music_src");
    const savedTime = parseFloat(localStorage.getItem("cybersec_music_time") || 0);
    
    if (savedSrc) {
        audioPlayer.src = savedSrc;
        audioPlayer.currentTime = savedTime;
        audioPlayer.play()
            .then(() => setUI("Playing"))
            .catch(() => setUI("Stopped"));
    }

    // Music button click handler
    document.getElementById('music-dropdown').querySelector('button').addEventListener('click', (e) => {
        e.stopPropagation();
        dropdown.style.display = dropdown.style.display === "block" ? "none" : "block";
        
        if (audioPlayer.src && !audioPlayer.paused) {
            audioPlayer.pause();
            setUI("Stopped");
        } else if (audioPlayer.src) {
            audioPlayer.play().then(() => setUI("Playing"));
        }
    });

    // Music selection handlers
    dropdown.querySelectorAll("a[data-src]").forEach((link) => {
        link.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.src = link.dataset.src;
            audioPlayer.play().then(() => setUI("Playing"));
            localStorage.setItem("cybersec_music_src", link.dataset.src);
            dropdown.style.display = "none";
        });
    });

    // Stop music handler
    const stopLink = document.getElementById("stop-music-link");
    if (stopLink) {
        stopLink.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            audioPlayer.removeAttribute("src");
            setUI("Stopped");
            localStorage.removeItem("cybersec_music_src");
            localStorage.removeItem("cybersec_music_time");
            dropdown.style.display = "none";
        });
    }

    // Save music state before page unload
    window.addEventListener("beforeunload", () => {
        if (!audioPlayer.paused && audioPlayer.src) {
            localStorage.setItem("cybersec_music_src", audioPlayer.src);
            localStorage.setItem(
                "cybersec_music_time",
                audioPlayer.currentTime
            );
        }
    });

    // Close dropdown when clicking outside
    window.addEventListener("click", (e) => {
        if (!e.target.closest("#music-dropdown")) {
            dropdown.style.display = "none";
        }
    });
}

// Show initial music indicator
function addMusicIndicator() {
    const musicBtn = document.querySelector("#music-dropdown");
    if (musicBtn) {
        const indicator = document.createElement("div");
        indicator.className = "music-indicator";
        indicator.innerHTML = `<i class="fa-solid fa-music"></i> Try Study Music!`;

        musicBtn.style.position = "relative";
        musicBtn.appendChild(indicator);

        setTimeout(() => indicator.remove(), 3000);
    }
}

// Initialize Event Listeners
function initializeEventListeners() {
    // Navigation buttons
    document.getElementById('prevLessonBtn')?.addEventListener('click', goToPreviousLesson);
    document.getElementById('nextLessonBtn')?.addEventListener('click', goToNextLesson);

    // Reset progress button
    document.getElementById('resetProgressBtn')?.addEventListener('click', resetProgress);

    // Mobile menu toggle
    document.getElementById('menuToggle')?.addEventListener('click', toggleSidebar);
    document.getElementById('sidebarOverlay')?.addEventListener('click', closeSidebar);

    // Keyboard shortcuts
    document.addEventListener('keydown', handleKeyboardShortcuts);

    // Window resize handler
    window.addEventListener('resize', handleWindowResize);

    // Content interaction tracking
    document.getElementById('contentBody')?.addEventListener('scroll', debounce(() => {
        trackUserInteraction();
    }, 1000));
}

// Keyboard Shortcuts
function handleKeyboardShortcuts(e) {
    if (document.querySelector('.quiz-question.active')) return;

    if (e.key === 'ArrowLeft' && e.ctrlKey) {
        e.preventDefault();
        goToPreviousLesson();
    } else if (e.key === 'ArrowRight' && e.ctrlKey) {
        e.preventDefault();
        goToNextLesson();
    }
}

// Window Resize Handler
function handleWindowResize() {
    if (window.innerWidth > 768) {
        closeSidebar();
    }
}

// Debounce Helper
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// Initialize responsive behavior
if (window.innerWidth <= 768) {
    document.getElementById('menuToggle').style.display = 'inline-flex';
}

// Auto-save progress periodically
setInterval(async () => {
    if (currentUser && Object.keys(courseProgress).length > 0) {
        await saveProgress();
    }
}, 60000); // Save every minute

// System initialization logging
console.log('CyberSec Academy Course System Initialized');
console.log('Current Course:', COURSE_DATA.title);
console.log('Total Lessons:', COURSE_DATA.lessons.length);

// Google OAuth Integration
const googleBtn = document.querySelector(".btn-google");
if (googleBtn) {
    googleBtn.addEventListener("click", async () => {
        const { data, error } = await supabase.auth.signInWithOAuth({
            provider: "google",
            options: {
                redirectTo: window.location.origin + "/courses/computer-networking-basics",
            },
        });

        if (error) {
            console.error("Google login error:", error.message);
            showToast("Google login failed: " + error.message, "error");
        }
    });
}

// Check for existing session
supabase.auth.getSession().then(({ data }) => {
    if (data.session) {
        console.log("User already logged in:", data.session.user);
        currentUser = data.session.user;
        startCourseSession();
    }
});


// Add missing auth modal functions
function openAuthModal() {
    const modal = document.getElementById('authModal');
    if (modal) {
        modal.style.display = 'flex';
    }
}

function closeAuthModal() {
    const modal = document.getElementById('authModal');
    if (modal) {
        modal.style.display = 'none';
    }
}

// Add auth tab switching functionality
document.getElementById('tabSignIn')?.addEventListener('click', () => {
    document.getElementById('tabSignIn').classList.add('active');
    document.getElementById('tabSignUp').classList.remove('active');
    document.getElementById('signInForm').style.display = 'block';
    document.getElementById('signUpForm').style.display = 'none';
});

document.getElementById('tabSignUp')?.addEventListener('click', () => {
    document.getElementById('tabSignUp').classList.add('active');
    document.getElementById('tabSignIn').classList.remove('active');
    document.getElementById('signUpForm').style.display = 'block';
    document.getElementById('signInForm').style.display = 'none';
});

document.getElementById('closeAuthModal')?.addEventListener('click', closeAuthModal);

// Improved error handling for auth session
supabase.auth.onAuthStateChange((event, session) => {
    if (event === 'SIGNED_IN') {
        currentUser = session.user;
        closeAuthModal();
        startCourseSession();
    } else if (event === 'SIGNED_OUT') {
        currentUser = null;
        openAuthModal();
    }
});

// Add form submission handlers
document.getElementById('emailSignInForm')?.addEventListener('submit', async (e) => {
    e.preventDefault();
    const email = document.getElementById('signInEmail').value;
    const password = document.getElementById('signInPassword').value;
    
    try {
        const { data, error } = await supabase.auth.signInWithPassword({
            email,
            password
        });
        
        if (error) throw error;
        
        closeAuthModal();
    } catch (error) {
        showToast(error.message, 'error');
    }
});

document.getElementById('emailSignUpForm')?.addEventListener('submit', async (e) => {
    e.preventDefault();
    const email = document.getElementById('signUpEmail').value;
    const password = document.getElementById('signUpPassword').value;
    const name = document.getElementById('signUpName').value;
    
    try {
        const { data, error } = await supabase.auth.signUp({
            email,
            password,
            options: {
                data: {
                    full_name: name
                }
            }
        });
        
        if (error) throw error;
        
        showToast('Account created successfully! Please check your email.', 'success');
    } catch (error) {
        showToast(error.message, 'error');
    }
});
    </script>
</body>

</html>