



<!DOCTYPE html>
<html lang="en">
 <head>




  
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    <!-- ========== Start: SEO & Schema Enhancement ========== -->
    <title>Advanced Threat Hunting Course | CipherHall</title>
    <meta name="description" content="Enroll in our expert-led Advanced Threat Hunting course. Learn to proactively hunt for threats using data analysis, MITRE ATT&CK, and automated playbooks.">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png" />
    <link rel="shortcut icon" href="/favicon.png" type="image/x-icon" />
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png" />
    <link rel="canonical" href="https://www.cipherhall.com/courses/advanced-threat-hunting-course.html" />

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Course",
      "name": "Advanced Threat Hunting: A Proactive Defense Strategy",
      "description": "A comprehensive 22-lesson course on the principles and practices of advanced threat hunting, moving beyond IOC searching to proactively detect sophisticated threats.",
      "provider": {
        "@type": "Organization",
        "name": "CipherHall",
        "sameAs": "https://www.cipherhall.com"
      },
      "hasCourseInstance": {
        "@type": "CourseInstance",
        "courseMode": "Online",
        "instructor": {
          "@type": "Person",
          "name": "Dr. Anya Sharma"
        }
      }
    }
    </script>
    <!-- ========== End: SEO & Schema Enhancement ========== -->

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Exo+2:wght@700;800;900&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css"
    />
    <link rel="stylesheet" href="assets/css/coursepages.css">
</head>
  <body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
      <div class="loader-icon">
        <i class="fas fa-graduation-cap"></i>
      </div>
      <div class="loader-text">Loading Course Content...</div>
    </div>

    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- Music Player (fixed at top right) -->
    <div class="header-controls">
      <div class="music-dropdown" id="music-dropdown">
        <button class="btn btn-secondary">
          <span id="music-button-text">STUDY MUSIC</span>
          <i id="music-icon" class="fa-solid fa-music"></i>
        </button>
        <div class="music-dropdown-content" id="music-dropdown-content">
          <a
            href="#"
            data-src="https://www.learningcontainer.com/wp-content/uploads/2020/02/Kalimba.mp3"
            >1. Coffee Shop Vibes</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3"
            >2. City Lights Lofi</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-15.mp3"
            >3. Mellow Thoughts</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-13.mp3"
            >4. Rainy Mood</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3"
            >5. Time Alone</a
          >
          <a href="#" id="stop-music-link"
            ><i class="fa-solid fa-stop-circle"></i> Stop Music</a
          >
        </div>
      </div>

      <button class="btn btn-secondary" id="resetProgressBtn">
        <i class="fas fa-redo"></i>
        Reset Progress
      </button>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal" style="display: none">
      <div class="modal-overlay"></div>
      <div class="modal-content">
        <span class="close" id="closeAuthModal">&times;</span>
        <div class="auth-tabs">
          <button id="tabSignIn" class="auth-tab active">Sign In</button>
          <button id="tabSignUp" class="auth-tab">Sign Up</button>
        </div>
        <div
          id="authLoader"
          style="display: none; text-align: center; padding: 2rem"
        >
          <i
            class="fas fa-spinner fa-spin fa-2x"
            style="color: var(--color-green)"
          ></i>
          <p style="margin-top: 0.5rem">Authenticating...</p>
        </div>
        <div id="signInForm" class="auth-form">
          <h2>Sign In to CipherHall</h2>
          <button id="googleSignIn" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignInForm">
            <input
              type="email"
              id="signInEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signInPassword"
              placeholder="Password"
              required
            />
            <button type="submit" class="btn btn-primary">Sign In</button>
          </form>
        </div>
        <div id="signUpForm" class="auth-form" style="display: none">
          <h2>Join CipherHall</h2>
          <button id="googleSignUp" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignUpForm">
            <input
              type="text"
              id="signUpName"
              placeholder="Full Name"
              required
            />
            <input
              type="email"
              id="signUpEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signUpPassword"
              placeholder="Password (min. 8 characters)"
              required
            />
            <button type="submit" class="btn btn-secondary">
              Create Account
            </button>
          </form>
        </div>
        <div id="authMessage"></div>
      </div>
    </div>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="course-info">
          <h1 class="course-title" id="courseTitle">Loading...</h1>
          <div class="course-progress">
            <div class="progress-header">
              <span class="progress-label">Course Progress</span>
              <span class="progress-percentage" id="courseProgressPercent"
                >0%</span
              >
            </div>
            <div class="progress-bar">
              <div
                class="progress-fill"
                id="courseProgressFill"
                style="width: 0%"
              ></div>
            </div>
            <div class="progress-stats">
              <span id="completedLessons">0</span>
              <span id="totalLessons">0</span>
            </div>
          </div>
          <a href="/dashboard.html" class="back-to-dashboard">
            <i class="fas fa-arrow-left"></i>
            Back to Dashboard
          </a>
        </div>
      </div>

      <nav class="lesson-nav" id="lessonNav">
        <!-- Lessons will be loaded dynamically -->
      </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <header class="content-header">
        <div class="lesson-header">
          <div class="lesson-header-left">
            <span class="lesson-number" id="currentLessonNumber">1</span>
            <h1 class="lesson-header-title" id="currentLessonTitle">
              Loading...
            </h1>
          </div>
          <div class="lesson-actions">
            <button class="mbtn btn-primary" id="menuToggle">
              <i class="fas fa-bars"></i>
            </button>
          </div>
        </div>
      </header>

      <div class="content-body" id="contentBody">
        <div class="lesson-content" id="lessonContent">
          <!-- Lesson content will be loaded dynamically -->
        </div>
      </div>

      <footer class="lesson-navigation">
        <div class="nav-info" id="navInfo">Lesson 1 of 10</div>
        <div class="nav-controls">
          <button class="btn btn-secondary" id="prevLessonBtn" disabled>
            <i class="fas fa-chevron-left"></i>
            Previous
          </button>
          <button class="btn btn-primary" id="nextLessonBtn" disabled>
            Next
            <i class="fas fa-chevron-right"></i>
          </button>
        </div>
      </footer>
    </main>

    <!-- Achievement Notification -->
    <div id="achievementNotification" class="achievement-notification">
      <div class="notification-header">
        <div class="notification-icon" id="notificationIcon">
          <i class="fas fa-trophy"></i>
        </div>
        <div class="notification-content">
          <h3 id="notificationTitle">Achievement Unlocked!</h3>
          <p id="notificationDescription">Description here...</p>
        </div>
      </div>
      <div class="notification-reward" id="notificationReward">
        <i class="fas fa-coins"></i>
        <span id="notificationPoints">+100 Points</span>
      </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast">
      <span id="toastMessage"></span>
    </div>

    <script>
      // =====================================================
      // SYNCHRONIZED COURSE SYSTEM WITH DASHBOARD INTEGRATION
      // =====================================================

      // Supabase Configuration - Replace with your config
      const supabaseUrl = "https://lzcmzulemfubjaksoqor.supabase.co";
      const supabaseKey =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx6Y216dWxlbWZ1Ympha3NvcW9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzMzM5MDgsImV4cCI6MjA3MDkwOTkwOH0.crhPH4YWtRsr1BJTpAQcmPbWSpwIWRbzoI4sRb2_fPI";
      const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

      // =====================================================
      // COURSE DATA STRUCTURE - REPLACE WITH YOUR COURSE JSON
      // =====================================================

      const COURSE_DATA = 

{
    "id": "advanced-threat-hunting",
    "title": "Advanced Threat Hunting: A Proactive Defense Strategy",
    "description": "A comprehensive 30-lesson course on the principles and practices of advanced threat hunting, moving beyond IOC searching to proactively detect sophisticated threats.",
    "category": "cybersecurity-defensive",
    "difficulty": "Advanced",
    "duration": "50 hours",
    "instructor": "Dr. Anya Sharma",
    "lessons": [
        {
            "id": "lesson-1",
            "title": "Beyond the SOC: Defining Advanced Threat Hunting",
            "duration": "60 min",
            "objectives": [
                "Differentiate threat hunting from SOC analysis and incident response",
                "Understand the proactive vs. reactive security mindset",
                "Learn the core hunting loop: Hypothesis -> Hunt -> Uncover -> Inform",
                "Analyze the Threat Hunting Maturity Model"
            ],
            "content": {
                "overview": "This foundational lesson defines the discipline of threat hunting. We will explore how it differs from traditional, alert-driven security operations, establish the proactive 'assume breach' mindset that is crucial for a hunter, and introduce the core iterative loop that drives all hunting activities.",
                "sections": [
                    {
                        "title": "Proactive vs. Reactive Security",
                        "content": "<p>Traditional Security Operations Centers (SOCs) are primarily <strong>reactive</strong>. A SOC Analyst's workflow begins when a security tool generates an alert. They investigate the alert to determine if it's a true positive and then escalate it to incident response if necessary.</p><p><strong>Threat Hunting</strong> is a <strong>proactive</strong> discipline. The hunter's workflow begins with the assumption that the automated defenses have already failed and a sophisticated adversary is present in the network. A hunter does not wait for an alert; they actively search through the organization's data to find the subtle traces of this adversary.</p>",
                        "image": "https://i.imgur.com/3Z4h7k2.png"
                    },
                    {
                        "title": "The Hunting Loop",
                        "content": "<p>Threat hunting is not a random search, but a structured, iterative process.</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>The Core Loop</strong></div><p><ol><li><strong>Hypothesis:</strong> The hunt begins with a clear, testable hypothesis about an adversary's behavior.</li><li><strong>Hunt:</strong> The hunter uses various tools and analytics to search through data, looking for evidence to prove or disprove the hypothesis.</li><li><strong>Uncover:</strong> Through the hunt, the hunter uncovers new adversary TTPs or malicious patterns.</li><li><strong>Inform:</strong> This is the most critical step. The hunter takes their findings and uses them to inform and improve the automated defenses. The logic from a successful hunt is used to create a new, high-fidelity detection rule.</li></ol></p></div>",
                        "image": "https://images.unsplash.com/photo-1573495627361-ab2d_50a_a86a?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "The Threat Hunting Maturity Model",
                        "language": "markdown",
                        "code": "# Threat Hunting Maturity Model (Simplified)\n\n- **Level 0 (Initial):** Primarily reactive. Relies on automated alerts. Little to no routine data collection.\n- **Level 1 (Minimal):** Incorporates threat intelligence (IOCs). Mostly automated searching for known-bad indicators.\n- **Level 2 (Procedural):** Follows analysis procedures created by others. Can perform basic hunts but relies on established playbooks.\n- **Level 3 (Innovative):** Can create new data analysis procedures. Develops new hypotheses based on threat reports. This is the goal for an advanced hunter.\n- **Level 4 (Leading):** Automates the majority of successful hunt procedures. The hunt process continuously improves the automated detection capabilities of the organization."
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the key difference between threat hunting and SOC analysis?",
                        "options": [
                            "There is no difference.",
                            "SOC analysis is proactive, while threat hunting is reactive.",
                            "Threat hunting is a proactive search for threats that have evaded automated defenses, while SOC analysis is primarily a reactive investigation of alerts.",
                            "Threat hunting does not require data."
                        ],
                        "correct": 2,
                        "explanation": "The core distinction is the starting point. A SOC analyst starts with an alert. A threat hunter starts with a hypothesis, assuming no alert has fired."
                    },
                    {
                        "id": 2,
                        "question": "The 'Assume Breach' mindset is central to threat hunting. What does it mean?",
                        "options": [
                            "That the hunt has already failed.",
                            "That the organization's defenses are perfect.",
                            "The hunter assumes that preventive controls have already failed and an adversary is active inside the network.",
                            "That a breach is impossible."
                        ],
                        "correct": 2,
                        "explanation": "This mindset shifts the focus from perimeter defense to internal detection. The hunter's job is to find the adversary who is already inside."
                    },
                    {
                        "id": 3,
                        "question": "What is the most critical final step in the hunting loop?",
                        "options": [
                            "Forming the hypothesis.",
                            "Writing the query.",
                            "Informing the automated defenses by using the hunt's findings to create a new detection rule.",
                            "Keeping the finding a secret."
                        ],
                        "correct": 2,
                        "explanation": "The ultimate goal of hunting is to make the automated defenses better. A successful hunt should result in a new, automated detection that can catch the same TTP in the future, freeing up the hunter to look for the next new threat."
                    }
                ]
            }
        },
        {
            "id": "lesson-2",
            "title": "Hypothesis-Driven Hunting: The Core Principle",
            "duration": "75 min",
            "objectives": [
                "Understand why a hypothesis is essential for a structured hunt",
                "Learn to source hypotheses from threat intelligence and environmental knowledge",
                "Practice using the ATT&CK framework to formulate a hypothesis",
                "Write several testable hunt hypotheses for different scenarios"
            ],
            "content": {
                "overview": "An effective hunt is a scientific process, and every scientific process starts with a hypothesis. This lesson covers the most important skill for a threat hunter: the ability to formulate a clear, concise, and testable hypothesis that will guide the entire investigation.",
                "sections": [
                    {
                        "title": "Moving Beyond 'Data Gazing'",
                        "content": "<p>An unstructured hunt, often called 'data gazing' or 'data dredging', is where an analyst simply looks through logs hoping to find something interesting. This is incredibly inefficient and rarely yields results.</p><p>A <strong>hypothesis-driven</strong> hunt is a focused investigation. The hypothesis provides the structure, telling the hunter what data to look at, what patterns to look for, and what success looks like. It turns a random search into a targeted mission.</p>",
                        "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Sources for a Hypothesis",
                        "content": "<p>Good hypotheses are based on knowledge and intelligence.</p><ul><li><strong>Threat Intelligence:</strong> A CISA alert describes a new technique where an attacker uses a specific LOLBin. Hypothesis: 'I believe an attacker might be using this new LOLBin in our network. I will hunt for any executions of this binary.'</li><li><strong>ATT&CK Research:</strong> A hunter is researching the 'Kerberoasting' technique. Hypothesis: 'I believe this technique would be effective in our environment. I will hunt for the signs of it in our Kerberos logs.'</li><li><strong>Environmental Knowledge:</strong> A hunter knows that the company has a legacy, un-monitored server. Hypothesis: 'I believe an attacker could use this legacy server as a staging ground. I will hunt for any unusual outbound network connections from this server.'</li></ul>",
                        "image": "https://i.imgur.com/k2H1z5F.png"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Threat_Hunt_Hypothesis_Template.md",
                        "language": "markdown",
                        "code": "# Threat Hunt Hypothesis\n\n**ID:** TH-001\n\n**Title:** Hunt for Lateral Movement via WMI\n\n**ATT&CK Technique:** T1047 - Windows Management Instrumentation\n\n**Threat Intel Source:** [Link to APT report]\n\n**Hypothesis:**\n> We believe a sophisticated adversary may attempt to move laterally by abusing the legitimate WMI service to execute commands on remote hosts. We can detect this by hunting for `WmiPrvSE.exe` processes that are spawned by the WMI service (`wmiprvse.exe`) on one host, which in turn spawn child processes on a *different* remote host.\n\n**Data Sources Required:**\n- EDR / Sysmon logs (Event ID 1: Process Creation)\n- Windows Authentication Logs (Event ID 4624, Logon Type 3)\n\n**Initial Query (Pseudocode):**\n```\nsearch process_creation\n | find parent_process = 'wmiprvse.exe'\n | join on transaction_id with authentication_logs\n | where logon_type = 3 AND source_host != destination_host\n```"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary benefit of a hypothesis-driven hunt?",
                        "options": [
                            "It makes the hunt take longer.",
                            "It provides a structured, testable framework for the investigation, making it more efficient and effective than random 'data gazing'.",
                            "It guarantees that you will find a threat.",
                            "It does not require any data."
                        ],
                        "correct": 1,
                        "explanation": "A hypothesis provides focus. It tells the hunter what to look for and in what data, turning a massive big data problem into a manageable and targeted investigation."
                    },
                    {
                        "id": 2,
                        "question": "Which of the following is the BEST source for a new hunt hypothesis?",
                        "options": [
                            "A random post on social media.",
                            "A detailed threat intelligence report about an adversary targeting your industry.",
                            "A list of all the servers in your network.",
                            "A gut feeling."
                        ],
                        "correct": 1,
                        "explanation": "Threat intelligence provides the most valuable and relevant starting points. It tells you what real-world adversaries are doing, which is the best guide for what you should be hunting for."
                    },
                    {
                        "id": 3,
                        "question": "The statement 'I believe an attacker is using PowerShell for persistence' is a weak hypothesis. Which of the following is a stronger, more testable version?",
                        "options": [
                            "PowerShell is a threat.",
                            "'I believe an attacker is creating persistence by using PowerShell to create a new WMI Event Consumer.'",
                            "Someone is using PowerShell.",
                            "We should block PowerShell."
                        ],
                        "correct": 1,
                        "explanation": "The stronger hypothesis is specific and testable. It points to a specific technique (WMI Event Consumers) and tells the hunter exactly what kind of event and log source they need to look for."
                    }
                ]
            }
        },
        {
            "id": "lesson-3",
            "title": "Mastering Data Sources for Advanced Hunting",
            "duration": "90 min",
            "objectives": [
                "Understand that a hunt's quality is limited by its data quality",
                "Perform a deep dive into essential endpoint telemetry (Sysmon)",
                "Explore rich network telemetry from tools like Zeek",
                "Analyze critical identity and cloud log sources",
                "Practice creating an advanced Sysmon configuration"
            ],
            "content": {
                "overview": "You cannot hunt what you cannot see. The foundation of any advanced threat hunting program is a rich, comprehensive set of security telemetry. This lesson provides a deep dive into the most critical data sources a hunter needs, with a special focus on Sysmon, the free tool that provides the deep endpoint visibility required to find sophisticated threats.",
                "sections": [
                    {
                        "title": "Endpoint Telemetry: Sysmon",
                        "content": "<p>The endpoint is where the attack executes, making it the most critical source of telemetry. <strong>System Monitor (Sysmon)</strong> is a free Microsoft tool that provides EDR-like visibility into a Windows host's activity.</p><h3>The Most Important Sysmon Events for a Hunter:</h3><ul><li><strong>Event ID 1 (Process Creation):</strong> The absolute foundation. Provides the process name, full command line, hash, and parent process.</li><li><strong>Event ID 3 (Network Connection):</strong> Shows which process made which outbound network connection.</li><li><strong>Event ID 10 (ProcessAccess):</strong> Crucial for detecting credential dumping. Shows when one process tries to access the memory of another.</li><li><strong>Event ID 13 (RegistryEvent):</strong> Shows modifications to the registry, essential for finding persistence.</li><li><strong>Event ID 22 (DNSEvent):</strong> Shows the DNS queries made by each process, essential for finding C2 channels.</li></ul>",
                        "image": "https://i.imgur.com/k2H1z5F.png"
                    },
                    {
                        "title": "Network Telemetry: Zeek",
                        "content": "<p>While the endpoint tells us *what* happened, the network tells us *how* the attacker moved. <strong>Zeek</strong> is an open-source Network Security Monitor that provides incredibly rich, structured logs for all network traffic.</p><p>Instead of just seeing a raw packet, Zeek parses the protocols and creates detailed logs like `dns.log`, `http.log`, and `ssl.log`. These logs allow a hunter to easily query for high-level concepts like 'show me all the websites that used a self-signed SSL certificate' or 'show me all the DNS queries with more than 5 subdomains'.</p>",
                        "image": "https://images.unsplash.com/photo-1544383835-bda2bc66a22d?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Identity and Cloud Logs",
                        "content": "<p>A complete picture requires identity and cloud data.</p><ul><li><strong>Identity Logs:</strong> Windows Security Event Logs (especially 4624, 4625, 4769) provide the ground truth for authentication. They are essential for hunting Kerberos-based attacks and lateral movement.</li><li><strong>Cloud Logs:</strong> CloudTrail (AWS) and Azure Monitor Activity Logs are the equivalent of Sysmon for the cloud control plane. They log every API call, which is how you can hunt for cloud-based attacks like IAM privilege escalation.</li></ul>",
                        "image": "https://i.imgur.com/fgS4fG3.png"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "Sysmon_Configuration_for_Maximum_Visibility.xml",
                    "language": "xml",
                    "code": "<!-- This Sysmon rule detects the specific ProcessAccess associated with Mimikatz LSASS dumping -->\n<Sysmon schemaversion=\"4.81\">\n  <RuleGroup name=\"\" groupRelation=\"or\">\n    <ProcessAccess onmatch=\"include\">\n      <TargetImage condition=\"is\">C:\\Windows\\system32\\lsass.exe</TargetImage>\n      <!-- Mimikatz requires these specific access rights to dump credentials -->\n      <GrantedAccess condition=\"is\">0x1410</GrantedAccess>\n      <CallTrace condition=\"contains\">dbgcore.dll</CallTrace>\n    </ProcessAccess>\n  </RuleGroup>\n</Sysmon>"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "Which Sysmon Event ID is considered the most fundamental and important for threat hunting?",
                        "options": [
                            "Event ID 11 (FileCreate)",
                            "Event ID 3 (NetworkConnection)",
                            "Event ID 1 (ProcessCreate)",
                            "Event ID 22 (DNSEvent)"
                        ],
                        "correct": 2,
                        "explanation": "Event ID 1, which logs process creation along with the full command line and parent process, is the single richest source of data for detecting the abuse of legitimate binaries and understanding attacker behavior on the endpoint."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary benefit of using Zeek for network analysis?",
                        "options": [
                            "It blocks malicious traffic like a firewall.",
                            "It provides rich, structured, high-fidelity logs for network protocols, making it easy to hunt for behavioral anomalies.",
                            "It only looks for known malware signatures.",
                            "It is a commercial, paid product."
                        ],
                        "correct": 1,
                        "explanation": "Zeek provides the deep semantic understanding of network protocols that is missing from raw packet captures or simple firewall logs. This rich metadata is the foundation for advanced network threat hunting."
                    },
                    {
                        "id": 3,
                        "question": "Which log source is most critical for hunting for Kerberoasting attacks in Active Directory?",
                        "options": [
                            "Sysmon logs",
                            "Zeek logs",
                            "Windows Security Event Logs, specifically Event ID 4769 (A Kerberos service ticket was requested).",
                            "Firewall logs."
                        ],
                        "correct": 2,
                        "explanation": "To hunt for a specific attack, you must have the log source that records that specific action. Kerberoasting is an abuse of the Kerberos ticket granting process, and Event ID 4769 is the log that captures that event."
                    }
                ]
            }
        },
        {
            "id": "lesson-4",
            "title": "Operationalizing MITRE ATT&CKÂ® for Hunting",
            "duration": "75 min",
            "objectives": [
                "Understand how to use ATT&CK as a 'hunting map'",
                "Move beyond just mapping detections to proactively developing hunts for specific techniques",
                "Learn how to deconstruct a technique into its core behaviors and data sources",
                "Use the ATT&CK Navigator to plan and track a hunt campaign"
            ],
            "content": {
                "overview": "The MITRE ATT&CK framework is more than just a reference; it's an operational tool. This lesson covers how to use ATT&CK as a practical guide for planning and executing threat hunts. We will learn how to deconstruct a technique, map it to our available data sources, and use the Navigator to track our hunt coverage.",
                "sections": [
                    {
                        "title": "Using ATT&CK as a Hunting Map",
                        "content": "<p>The ATT&CK matrix can be thought of as a map of the adversary's world. Each cell in the matrix is a potential place where we can set an ambush (a detection). A threat hunt is the process of actively patrolling a specific area of that map where we don't have an automated ambush set up yet.</p><p>Instead of a generic hypothesis like 'hunt for persistence', we can use ATT&CK to create a much more specific one: 'This week, we will hunt for T1547.001, persistence via Registry Run Keys'.</p>",
                        "image": "https://i.imgur.com/u7y7o9o.png"
                    },
                    {
                        "title": "Deconstructing a Technique",
                        "content": "<p>The ATT&CK website is a rich resource. For each technique, it provides:</p><ul><li>A detailed description of the technique.</li><li>Examples of procedures used by real threat actors.</li><li>The data sources needed to detect it.</li><li>Mitigation and detection guidance.</li></ul><p>A hunter's workflow involves reading the entry for their target technique and using this information to build their hunt plan. They will ask: 'Based on this description, what specific events would this technique generate in my environment, and in which of my log sources would those events appear?'</p>",
                        "image": "https://images.unsplash.com/photo-1573495627361-ab2d_50a_a86a?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Planning a Hunt Campaign with the Navigator",
                        "content": "<p>The ATT&CK Navigator is the perfect tool for planning a long-term hunt campaign.</p><div class='info-box tip'><div class='info-box-header'><i class='fas fa-lightbulb'></i><strong>Tracking Progress</strong></div><p>A hunt team can create a Navigator layer to track their progress. They can use different colors to represent the status of each technique:<ul><li><strong>White:</strong> Not yet hunted.</li><li><strong>Yellow:</strong> Hunt in progress.</li><li><strong>Orange:</strong> Hunt complete, findings being analyzed.</li><li><strong>Green:</strong> Hunt complete, and a new automated detection has been created as a result.</li></ul>This provides a clear, visual representation of the hunt team's work and its impact on the organization's detection coverage.</p></div>",
                        "image": "https://i.imgur.com/kYq3Q6k.png"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "ATT&CK Navigator Layer for a Hunt Campaign",
                    "language": "json",
                    "code": "{\n    \"name\": \"Q2 Hunt Campaign\",\n    \"version\": \"4.2\",\n    \"domain\": \"enterprise-attack\",\n    \"description\": \"Tracking our hunt progress for Q2\",\n    \"techniques\": [\n        {\n            \"techniqueID\": \"T1003.001\",\n            \"tactic\": \"credential-access\",\n            \"comment\": \"Hunt complete, new LSASS detection deployed.\",\n            \"enabled\": true,\n            \"color\": \"#2e8b57\" \n        },\n        {\n            \"techniqueID\": \"T1047\",\n            \"tactic\": \"execution\",\n            \"comment\": \"Hunt for WMI lateral movement is currently in progress.\",\n            \"enabled\": true,\n            \"color\": \"#ffd700\" \n        },\n        {\n            \"techniqueID\": \"T1071.004\",\n            \"tactic\": \"command-and-control\",\n            \"comment\": \"DNS Tunneling hunt is in the backlog for next sprint.\",\n            \"enabled\": true,\n            \"color\": \"#ffffff\"\n        }\n    ]\n}"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "How can the MITRE ATT&CK framework be used to structure a threat hunt?",
                        "options": [
                            "It cannot be used for hunting.",
                            "By providing a comprehensive map of adversary techniques that can be used to formulate specific, testable hunt hypotheses.",
                            "By automatically detecting all the techniques.",
                            "By blocking all the techniques."
                        ],
                        "correct": 1,
                        "explanation": "ATT&CK provides the structure. Instead of a vague goal, it allows a hunter to target a very specific behavior, such as 'T1003.001: OS Credential Dumping: LSASS Memory'."
                    },
                    {
                        "id": 2,
                        "question": "For a given technique, what crucial information does the MITRE ATT&CK website provide to a hunter?",
                        "options": [
                            "A list of all the companies that have been attacked with it.",
                            "A link to download the attack tool.",
                            "The specific data sources required to detect the technique.",
                            "The name of the person who discovered the technique."
                        ],
                        "correct": 2,
                        "explanation": "The 'Data Sources' section is one of the most valuable parts of the ATT&CK website for a defender. It tells you exactly what kind of telemetry you need to be collecting to even have a chance of seeing the technique."
                    },
                    {
                        "id": 3,
                        "question": "What is the primary benefit of using the ATT&CK Navigator to track a hunt campaign?",
                        "options": [
                            "It automates the hunt.",
                            "It provides a clear, visual heatmap of the hunt team's progress and the organization's current hunt coverage.",
                            "It is a SIEM.",
                            "It is a text editor."
                        ],
                        "correct": 1,
                        "explanation": "The Navigator is a strategic planning and communication tool. It helps the hunt team to organize their work and to clearly communicate their progress and the state of the organization's visibility to leadership."
                    }
                ]
            }
        },
        {
            "id": "lesson-5",
            "title": "Statistical Analysis and Frequency Stacking",
            "duration": "75 min",
            "objectives": [
                "Understand the principle of finding outliers through frequency analysis",
                "Learn the technique of 'stacking' or 'stack counting'",
                "Apply frequency analysis to find rare parent-child process relationships",
                "Analyze other use cases like finding the least common user-agent"
            ],
            "content": {
                "overview": "Attackers often try to blend in, but their actions are still, by definition, unusual. One of the most powerful and fundamental hunting techniques is frequency analysis, or 'stacking'. This lesson covers the art of finding evil by simply counting things and looking for the rarest occurrences.",
                "sections": [
                    {
                        "title": "The Power of Finding the Rarest Event",
                        "content": "<p>The core idea of frequency analysis is that malicious activity is often an outlier. While defenders and attackers both use `powershell.exe`, the way they use it is different. A hunter can find these differences by counting and analyzing the context.</p><p><strong>Stacking</strong> (or stack counting) is the process of counting the occurrences of a particular value in a large dataset and then sorting the results. The items at the top of the list are the most common ('the baseline'), and the items at the *bottom* of the list are the rarest and often the most interesting.</p>",
                        "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Hunting for Anomalous Parent-Child Processes",
                        "content": "<p>A classic application of stacking is to hunt for unusual parent-child process relationships. A hunter can ingest all of their process creation logs (Sysmon Event ID 1) for a month into their SIEM.</p><p>They can then group by the parent process name and the child process name and count the occurrences of each pair. The pairs at the top of the list, like `explorer.exe` spawning `chrome.exe`, are normal. The pairs at the very bottom of the list, with a count of only 1 or 2, are the anomalies. A process pair like `winword.exe` spawning `powershell.exe` that has only happened once in the entire organization is a prime candidate for a deep-dive investigation.</p>",
                        "image": "https://i.imgur.com/kYq3Q6k.png"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "PowerShell_Script_for_Frequency_Analysis_of_Process_Execution.ps1",
                    "language": "powershell",
                    "code": "# This PowerShell script demonstrates frequency analysis on Windows Event Logs.\n\n# Get the last 10,000 process creation events (Event ID 4688)\n$events = Get-WinEvent -FilterHashtable @{LogName='Security'; ID=4688} -MaxEvents 10000\n\n# Group the events by the name of the process that was created and count them\n$processCounts = $events | Group-Object -Property {$_.Properties[5].Value} | Sort-Object -Property Count\n\n# Display the 10 least frequently seen processes\nWrite-Host \"--- Rarest Processes ---\"\n$processCounts | Select-Object -First 10 | Format-Table -AutoSize\n\n# Display the 10 most frequently seen processes\nWrite-Host \"--- Most Common Processes ---\"\n$processCounts | Select-Object -Last 10 | Format-Table -AutoSize"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is 'stacking' or frequency analysis in the context of threat hunting?",
                        "options": [
                            "A type of malware.",
                            "The process of counting the occurrences of values in a dataset and sorting them to find the rarest events.",
                            "A method for bypassing a firewall.",
                            "A way to write a report."
                        ],
                        "correct": 1,
                        "explanation": "Stacking is a fundamental data analysis technique. By counting and sorting, a hunter can quickly separate the common, normal activity from the rare, anomalous activity that warrants investigation."
                    },
                    {
                        "id": 2,
                        "question": "When hunting for malicious activity, which part of a frequency analysis result is usually the most interesting?",
                        "options": [
                            "The middle of the list.",
                            "The top of the list (the most common events).",
                            "The bottom of the list (the least common events).",
                            "The total count of all events."
                        ],
                        "correct": 2,
                        "explanation": "The premise of this type of hunting is that 'rare is interesting'. Attackers often use tools or techniques that are unique and do not match the normal baseline of activity, causing them to appear at the bottom of a frequency count."
                    },
                    {
                        "id": 3,
                        "question": "Which of the following would be a good use case for frequency analysis?",
                        "options": [
                            "Finding a single, specific IP address.",
                            "Finding the least common User-Agent string seen in your web logs.",
                            "Getting a total count of all network connections.",
                            "Writing a firewall rule."
                        ],
                        "correct": 1,
                        "explanation": "Most browsers and legitimate tools have very common User-Agent strings. Malware C2 beacons often use unusual or unique User-Agents. By stacking all the User-Agents in your network, the malware is likely to appear as one of the rarest entries."
                    }
                ]
            }
        },
        {
            "id": "lesson-6",
            "title": "Data Stacking and Beacon Hunting",
            "duration": "75 min",
            "objectives": [
                "Understand the characteristics of C2 beaconing traffic",
                "Learn how to hunt for beacons by stacking network connection data",
                "Analyze connection intervals and data sizes to find regularity",
                "Explore how to hunt for unusual user-agents and JA3/JARM hashes"
            ],
            "content": {
                "overview": "Command and Control (C2) traffic is the lifeline of an adversary. Finding their beacon is one of the highest-value discoveries a hunter can make. This lesson focuses on the specific data stacking and frequency analysis techniques used to hunt for the subtle, machine-like patterns of C2 beacons in network traffic.",
                "sections": [
                    {
                        "title": "The Rhythmic Signal of a Beacon",
                        "content": "<p>A C2 beacon is a program. It is not a human. As such, its network behavior is often very regular and periodic. While attackers use jitter to add some randomness, the underlying pattern is often still detectable.</p><h3>Key Indicators of a Beacon:</h3><ul><li><strong>Regular Connection Intervals:</strong> A connection every 60 seconds, with a small amount of jitter.</li><li><strong>Consistent Data Sizes:</strong> The size of the check-in request and the response from the server are often very consistent.</li><li><strong>Long-Running Connections:</strong> The beacon will continue this activity 24/7 for days or weeks. A human user does not typically have a single connection to a web server that lasts for three weeks.</li></ul>",
                        "image": "https://i.imgur.com/k2H1z5F.png"
                    },
                    {
                        "title": "Hunting with Data Stacking",
                        "content": "<p>A hunter can use a SIEM to stack network connection logs (e.g., from Zeek's `conn.log`) to find these patterns.</p><div class='info-box tip'><div class='info-box-header'><i class='fas fa-lightbulb'></i><strong>The Hunt Workflow</strong></div><p><ol><li>Query all network connection logs for a 24-hour period.</li><li>Group the connections by source IP, destination IP, and destination port.</li><li>For each group, calculate the following statistics: the average time between connections, the standard deviation of the time between connections, the average bytes sent, and the standard deviation of the bytes sent.</li><li>Sort the results to find the groups with the *lowest* standard deviation. A very low standard deviation in both the timing and the data size is a strong indicator of a machine-like, beaconing behavior.</li></ol></p></div>",
                        "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Hunting with User-Agents and JA3/JARM",
                        "content": "<p>Other stacking techniques can be used on HTTP/S traffic.</p><ul><li><strong>Stacking User-Agents:</strong> A hunter can stack all the User-Agent strings in their proxy logs. The rarest User-Agents are often from malicious tools.</li><li><strong>Stacking JA3/JARM Hashes:</strong> A JA3 hash is a fingerprint of how a client initiates an SSL/TLS session. A JARM hash is a fingerprint of the server's response. These fingerprints are specific to the cryptographic libraries being used. Stacking these hashes can reveal malicious clients (like a Cobalt Strike beacon) or C2 servers that have a rare or unique fingerprint.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1573495627361-ab2d_50a_a86a?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "Zeek_Log_Analysis_to_Find_Repetitive_Network_Connections.py",
                    "language": "python",
                    "code": "# This is a conceptual pandas script for beacon hunting in Zeek's conn.log\nimport pandas as pd\n\n# Load the connection log into a pandas DataFrame\ndf = pd.read_csv('conn.log', sep='\\t')\n\n# Group by the 4-tuple (source/dest IP/port)\ndf_grouped = df.groupby(['id.orig_h', 'id.resp_h', 'id.resp_p'])\n\n# Calculate the statistics for each group\nbeacon_stats = df_grouped['ts'].agg(['count', 'min', 'max'])\nbeacon_stats['duration'] = beacon_stats['max'] - beacon_stats['min']\nbeacon_stats['avg_interval'] = beacon_stats['duration'] / beacon_stats['count']\n\n# A real hunt would also calculate standard deviation, but this shows the idea.\n\n# Find potential beacons: long duration, many connections, very regular interval\npotential_beacons = beacon_stats[\n    (beacon_stats['count'] > 100) & \n    (beacon_stats['duration'] > 3600) # Lasting more than an hour\n]\n\nprint(\"Potential Beacons:\")\nprint(potential_beacons.sort_values(by='avg_interval'))"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is a key characteristic of C2 beaconing traffic?",
                        "options": [
                            "It is very random and unpredictable.",
                            "It is often highly periodic, with a regular connection interval and consistent data sizes.",
                            "It only happens once.",
                            "It always uses the HTTP protocol."
                        ],
                        "correct": 1,
                        "explanation": "The machine-like regularity of a beacon is its biggest giveaway. While jitter can add some noise, the underlying pattern is often detectable with statistical analysis."
                    },
                    {
                        "id": 2,
                        "question": "When hunting for beacons by stacking network connections, which statistical measure is most useful for finding regularity?",
                        "options": [
                            "The total number of connections.",
                            "The average data size.",
                            "A low standard deviation of the time between connections.",
                            "The maximum duration."
                        ],
                        "correct": 2,
                        "explanation": "Standard deviation measures how spread out the data points are. A very low standard deviation in the connection interval means the connections are happening at almost exactly the same time apart, which is a strong sign of an automated, beaconing process."
                    },
                    {
                        "id": 3,
                        "question": "What is a JA3 hash?",
                        "options": [
                            "A hash of a file.",
                            "A fingerprint of a client's SSL/TLS implementation, which can be used to identify specific malware families.",
                            "A user's password hash.",
                            "A type of network connection."
                        ],
                        "correct": 1,
                        "explanation": "JA3 provides a way to fingerprint the client-side of an encrypted connection. Since different malware families often use the same cryptographic libraries, they will have the same JA3 hash. Hunting for the rarest JA3 hashes in your environment is a powerful technique."
                    }
                ]
            }
        },
        {
            "id": "lesson-7",
            "title": "Clustering and Anomaly Detection",
            "duration": "75 min",
            "objectives": [
                "Understand the basics of unsupervised machine learning for hunting",
                "Learn how clustering algorithms (like K-Means) can group similar behaviors",
                "Explore how to use clustering to find outliers and anomalies",
                "Apply clustering to a real-world problem like PowerShell command-line analysis"
            ],
            "content": {
                "overview": "Sometimes we don't know what an attack looks like, but we know it will look *different* from normal. This lesson introduces the use of unsupervised machine learning, specifically clustering, as a powerful technique for automatically discovering these unknown unknowns by grouping all the normal behavior together and finding the outliers that don't fit in.",
                "sections": [
                    {
                        "title": "Unsupervised Learning for Hunting",
                        "content": "<p>In unsupervised learning, we don't provide the model with any labels. We simply give it the data and ask it to find the inherent structure. <strong>Clustering</strong> is a technique that groups similar data points together. The assumption for hunting is that the vast majority of our data is benign, and it will form large, dense clusters. The malicious activity, being rare and different, will either form its own very small cluster, or it won't belong to any cluster at all (an outlier).</p>",
                        "image": "https://i.imgur.com/8a6R2aU.png"
                    },
                    {
                        "title": "Clustering for PowerShell Analysis",
                        "content": "<p>PowerShell command lines are a perfect use case for this. A hunter can take all the PowerShell commands executed in their network for a week. They can then use a technique (like TF-IDF) to convert each command line into a numerical vector. A clustering algorithm (like K-Means or DBSCAN) is then run on these vectors.</p><p>The algorithm will automatically find the large clusters of normal, administrative activity (e.g., the commands used by the SCCM client, the scripts used by the backup system). The commands that are left overâthe ones that don't fit into any of these common clustersâare the ones that are most likely to be malicious. This allows a hunter to automatically sift through millions of commands to find the few that warrant a closer look.</p>",
                        "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "Jupyter_Notebook_for_Clustering_User_Login_Behavior.ipynb",
                    "language": "python",
                    "code": "import pandas as pd\nfrom sklearn.cluster import DBSCAN\nfrom sklearn.preprocessing import StandardScaler\n\n# Assume 'df' is a DataFrame with user login data:\n# columns=['user', 'hour_of_day', 'day_of_week', 'source_country']\n\n# We need to convert categorical data to numerical data (one-hot encoding)\nfeatures = pd.get_dummies(df, columns=['user', 'source_country'])\n\n# Scale the features\nscaler = StandardScaler()\nscaled_features = scaler.fit_transform(features)\n\n# Use DBSCAN to find clusters of normal behavior.\n# DBSCAN is good at finding outliers (it labels them as -1).\nclustering = DBSCAN(eps=0.5, min_samples=10).fit(scaled_features)\n\n# Add the cluster labels back to the original dataframe\ndf['cluster'] = clustering.labels_\n\n# The most interesting data points for a hunter are the outliers\noutliers = df[df['cluster'] == -1]\n\nprint(\"Anomalous logins that don't fit any cluster:\")\nprint(outliers)"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary assumption when using clustering for threat hunting?",
                        "options": [
                            "All data is malicious.",
                            "Normal, benign activity will form large, dense clusters, while malicious activity will be rare and will appear as small clusters or outliers.",
                            "The data must be labeled.",
                            "The algorithm will always find exactly three clusters."
                        ],
                        "correct": 1,
                        "explanation": "This is the core premise. Clustering is an automated way of performing frequency analysis on high-dimensional data. It finds what is common so that we can focus our attention on what is rare."
                    },
                    {
                        "id": 2,
                        "question": "Clustering is a form of which type of machine learning?",
                        "options": [
                            "Supervised Learning",
                            "Reinforcement Learning",
                            "Unsupervised Learning",
                            "Semi-Supervised Learning"
                        ],
                        "correct": 2,
                        "explanation": "Clustering algorithms learn from unlabeled data, discovering the inherent structure and groupings within it without any prior guidance. This makes them 'unsupervised'."
                    },
                    {
                        "id": 3,
                        "question": "A hunter who uses clustering on PowerShell command lines is likely to find that the largest clusters represent what?",
                        "options": [
                            "Malicious activity from a widespread campaign.",
                            "The normal, repetitive commands executed by legitimate administrative tools and scripts.",
                            "The most dangerous attacks.",
                            "The activities of a single user."
                        ],
                        "correct": 1,
                        "explanation": "The largest clusters represent the baseline of normal activity. The hunt begins by filtering out this noise to find the rare and unique commands that are likely to be malicious."
                    }
                ]
            }
        },
        {
            "id": "lesson-8",
            "title": "Graph Analytics for Hunting",
            "duration": "75 min",
            "objectives": [
                "Understand the value of visualizing data as a graph",
                "Learn the basics of graph databases and query languages (e.g., Cypher)",
                "Explore how to use graphs to map process lineage and authentication chains",
                "Analyze the use of BloodHound for hunting AD attack paths"
            ],
            "content": {
                "overview": "Attackers think in graphs. They move from one system to another, creating a chain of relationships. To catch them, defenders must also think in graphs. This lesson covers the powerful technique of using graph analytics to visualize and query the relationships in security data, making it possible to uncover complex attack paths that are invisible in raw logs.",
                "sections": [
                    {
                        "title": "Visualizing Relationships",
                        "content": "<p>A <strong>graph</strong> is a data structure that consists of nodes (or vertices) and edges (or relationships). In security, the nodes can be users, computers, processes, or IP addresses. The edges are the actions that connect them, like 'logged into', 'spawned', or 'connected to'.</p><p>By transforming our log data into a graph, we can easily see and query for complex, multi-hop relationships that would be very difficult to find with a traditional query language. It allows us to ask questions like: 'Show me all users who logged into a server that then made a connection to a suspicious IP address'.</p>",
                        "image": "https://i.imgur.com/o3V8Z7j.png"
                    },
                    {
                        "title": "Hunting with BloodHound",
                        "content": "<p><strong>BloodHound</strong> is the quintessential threat hunting tool for Active Directory, and it is built entirely on graph theory. It takes all the complex data about users, groups, permissions, and sessions in AD and turns it into a graph.</p><p>A hunter can use the BloodHound GUI to visually explore these relationships. The most powerful feature is its ability to automatically find attack paths. A hunter can select a starting point (e.g., a compromised standard user) and an ending point (e.g., the Domain Admins group) and BloodHound will use a graph traversal algorithm to find the shortest sequence of privilege escalations and lateral movements to get from A to B. This is an incredibly powerful way to find and prioritize the most critical risks in an AD environment.</p>",
                        "image": "https://i.imgur.com/kYq3Q6k.png"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "Neo4j Cypher Query for Process Lineage",
                    "language": "cypher",
                    "code": "// Cypher is a graph query language used by the Neo4j graph database.\n// This query hunts for a suspicious process chain.\n\n// Find a node representing a Word process that spawned a PowerShell process,\n// which in turn made a network connection to an external IP.\n\nMATCH (p1:Process {name: 'winword.exe'})-[:SPAWNED]->(p2:Process {name: 'powershell.exe'})\nMATCH (p2)-[:CONNECTED_TO]->(ip:IPAddress)\n\n// Return the path we found\nRETURN p1, p2, ip"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "In the context of security, a graph database is primarily used for what purpose?",
                        "options": [
                            "To store log files.",
                            "To model and query the relationships between different entities (users, hosts, processes).",
                            "To create visualizations like pie charts and bar graphs.",
                            "To block network traffic."
                        ],
                        "correct": 1,
                        "explanation": "Graphs are all about relationships. A graph database is the ideal tool for finding complex, multi-hop attack paths that involve many different entities."
                    },
                    {
                        "id": 2,
                        "question": "The tool BloodHound is used for what?",
                        "options": [
                            "To dump credentials.",
                            "To visualize Active Directory as a graph and find attack paths.",
                            "To act as a SIEM.",
                            "To scan for vulnerabilities."
                        ],
                        "correct": 1,
                        "explanation": "BloodHound is a powerful graph-based threat hunting tool specifically for Active Directory. It automates the discovery of complex privilege escalation and lateral movement paths."
                    },
                    {
                        "id": 3,
                        "question": "A query like 'find a path from User A to the Domain Admins group' is a typical use case for what kind of analysis?",
                        "options": [
                            "Frequency analysis",
                            "Statistical analysis",
                            "Graph analytics",
                            "Malware analysis"
                        ],
                        "correct": 2,
                        "explanation": "This is a classic 'pathfinding' problem, which is what graph databases are designed to solve. It's the core analytic that BloodHound uses to find attack paths."
                    }
                ]
            }
        },
        {
            "id": "lesson-16",
            "title": "Identity-Based Detections",
            "duration": "75 min",
            "objectives": [
                "Understand why authentication logs are a critical data source",
                "Learn how to build detections for password spraying attacks",
                "Explore techniques for detecting Kerberoasting",
                "Analyze the patterns of brute-force and credential stuffing attacks",
                "Practice writing a KQL query to detect a password spray attack"
            ],
            "content": {
                "overview": "Identity is the new perimeter. Attackers are relentlessly targeting user credentials to gain initial access and escalate privileges. This lesson focuses on building detections using the rich data from authentication logs (like Active Directory and Azure AD) to find the common attacks against user identities.",
                "sections": [
                    {
                        "title": "Detecting Password Spraying",
                        "content": "<p>A <strong>password spraying</strong> attack is a stealthy brute-force technique where an attacker tries one or two common passwords (e.g., 'Winter2024') against a large number of different user accounts.</p><p>This is hard to detect from the perspective of a single user (who only sees one failed login), but it creates a very clear pattern when analyzed in aggregate. The detection logic is to look for a single source IP address that is generating a high count of failed logins across a high count of *distinct* usernames in a short period of time.</p>",
                        "image": "https://i.imgur.com/k2H1z5F.png"
                    },
                    {
                        "title": "Detecting Kerberoasting",
                        "content": "<p>As we learned in the offensive lessons, a <strong>Kerberoasting</strong> attack involves a user requesting a large number of service tickets (Kerberos Event ID 4769) to crack them offline.</p><p>This behavior is also highly anomalous. A normal user will only request a handful of service tickets during a normal workday. An attacker performing Kerberoasting will request dozens or hundreds in a few minutes. The detection logic is to baseline the normal number of 4769 events per user per hour and alert on any significant deviation from that baseline. A particularly high-fidelity signal is seeing a large number of these requests where the encryption type is RC4, which is weaker and easier to crack.</p>",
                        "image": "https://images.unsplash.com/photo-1599508704512-2f19efd1e_35f?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "KQL_Query_for_Password_Spraying_Detection.kql",
                        "language": "kusto",
                        "code": "// This KQL query detects a potential password spraying attack.\n\nSigninLogs // Start with the Azure AD sign-in logs table\n| where ResultType == 50126 // Filter for failed logins due to invalid credentials\n| summarize\n    // For each source IP, count the total failures and the number of unique users attacked\n    TotalFailedLogins = count(),\n    DistinctUsersAttacked = dcount(UserPrincipalName)\n    by IpAddress, bin(TimeGenerated, 10m) // Group by IP in 10-minute windows\n| where TotalFailedLogins > 20 and DistinctUsersAttacked > 10 // Set thresholds\n| project TimeGenerated, IpAddress, TotalFailedLogins, DistinctUsersAttacked"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the key pattern of a password spraying attack?",
                        "options": [
                            "Many failed logins for one user from many IPs.",
                            "One successful login.",
                            "Many failed logins for many different users, all coming from one source IP.",
                            "A single failed login."
                        ],
                        "correct": 2,
                        "explanation": "The key is the 'many-to-one' relationship: many users being targeted by one attacker. This creates a distinct statistical anomaly when the logs are aggregated by the source IP address."
                    },
                    {
                        "id": 2,
                        "question": "Which Windows Event ID is most relevant for detecting Kerberoasting?",
                        "options": [
                            "4624 (Successful Logon)",
                            "4625 (Failed Logon)",
                            "4769 (A Kerberos service ticket was requested)",
                            "4688 (Process Creation)"
                        ],
                        "correct": 2,
                        "explanation": "The Kerberoasting attack works by requesting service tickets. Event ID 4769 is the log that records this specific action, making it the primary data source for this detection."
                    },
                    {
                        "id": 3,
                        "question": "Why are authentication logs considered a critical data source for detection?",
                        "options": [
                            "They are not a critical source.",
                            "Because nearly all adversary actions, from initial access to lateral movement, require the use of credentials, which generates authentication events.",
                            "They are very small and easy to store.",
                            "They only show successful logins."
                        ],
                        "correct": 1,
                        "explanation": "Authentication is a fundamental part of almost every TTP. Having comprehensive authentication logs (both success and failure) provides visibility into a huge range of adversary behaviors."
                    }
                ]
            }
        },
        {
            "id": "lesson-17",
            "title": "Hunting for Remote Service and WMI Lateral Movement",
            "duration": "75 min",
            "objectives": [
                "Understand the importance of detecting lateral movement early",
                "Learn how to hunt for remote service creation (sc.exe, PsExec)",
                "Explore techniques for hunting for remote WMI and WinRM execution",
                "Analyze the endpoint and network artifacts of these techniques"
            ],
            "content": {
                "overview": "Detecting an attacker moving from host to host is a critical part of a mature detection program. This lesson focuses on hunting for the common 'Living off the Land' techniques used for lateral movement in Windows environments, such as the remote use of services, WMI, and PowerShell.",
                "sections": [
                    {
                        "title": "Hunting for Remote Service Creation",
                        "content": "<p>Tools like PsExec work by creating a temporary service on the remote machine. This leaves a very clear forensic trail in the logs.</p><p>A hunt can be built by monitoring the Windows System Event Log for <strong>Event ID 7045: 'A service was installed in the system'</strong>. A hunter can stack this data, looking for services with suspicious names or where the 'Service File Name' points to an unusual location (e.g., `C:\\Windows\\Temp\\psexesvc.exe`). Another key piece of context is correlating this with a preceding network logon (Event ID 4624, Logon Type 3) from the source machine.</p>",
                        "image": "https://i.imgur.com/k2H1z5F.png"
                    },
                    {
                        "title": "Hunting for Remote WMI Execution",
                        "content": "<p>Detecting remote WMI execution is more subtle. It involves correlating events across two machines.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Connecting the Dots</strong></div><p>The hunt involves looking for a chain of events: <ol><li>A network connection from a source machine to the target machine on the WMI port (TCP 135).</li><li>A process creation event on the *target machine* for `WmiPrvSE.exe`.</li><li>A child process being spawned by `WmiPrvSE.exe` on the target machine (this is the attacker's payload).</li></ol>Finding this specific chain of process ancestry and network connections is a high-fidelity way to hunt for this common lateral movement technique.</p></div>",
                        "image": "https://images.unsplash.com/photo-1573495627361-ab2d_50a_a86a?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "EDR_Query_for_Remote_Process_Creation_via_WMI.kql",
                    "language": "kusto",
                    "code": "// This KQL query hunts for processes created by the WMI provider service.\n\nDeviceProcessEvents\n| where InitiatingProcessFileName =~ \"WmiPrvSE.exe\"\n// Exclude common false positives and legitimate software management tools\n| where not(FileName in~ (\"SCCM_Client.exe\", \"ManagementAgent.exe\"))\n| project TimeGenerated, DeviceName, FileName, FolderPath, ProcessCommandLine"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "A Windows Event ID 7045 ('A service was installed') where the service executable is in `C:\\Windows\\Temp` is a strong indicator of what?",
                        "options": [
                            "A normal Windows update.",
                            "Lateral movement using a tool like PsExec.",
                            "A user logging in.",
                            "A file being downloaded."
                        ],
                        "correct": 1,
                        "explanation": "Legitimate services are almost always installed in `C:\\Program Files` or `C:\\Windows\\System32`. A service being created that runs from a temporary directory is a classic sign of a malicious remote administration tool."
                    },
                    {
                        "id": 2,
                        "question": "Which process on the target machine is responsible for executing remote WMI commands?",
                        "options": [
                            "explorer.exe",
                            "svchost.exe",
                            "WmiPrvSE.exe (WMI Provider Host)",
                            "lsass.exe"
                        ],
                        "correct": 2,
                        "explanation": "The `WmiPrvSE.exe` process is the worker process for WMI. Hunting for unusual child processes being spawned by it is a core technique for detecting remote WMI execution."
                    },
                    {
                        "id": 3,
                        "question": "Why is detecting lateral movement a critical goal for a hunt team?",
                        "options": [
                            "It is not an important goal.",
                            "Because it is a clear, unambiguous sign of a hands-on-keyboard attacker actively moving through the environment, and it represents a major escalation of an incident.",
                            "Because it is easy to detect.",
                            "Because it only involves one computer."
                        ],
                        "correct": 1,
                        "explanation": "Lateral movement is the bridge between an initial compromise and the attacker's final objective. Detecting it early is the key to stopping a breach before catastrophic damage is done."
                    }
                ]
            }
        },
        {
            "id": "lesson-18",
            "title": "Hunting in Cloud Environments: AWS",
            "duration": "75 min",
            "objectives": [
                "Understand the shift from host/network to the cloud control plane",
                "Learn how to hunt for IAM privilege escalation in AWS CloudTrail",
                "Explore techniques for finding suspicious API calls",
                "Practice using Stratus Red Team to simulate and hunt for cloud attacks"
            ],
            "content": {
                "overview": "As infrastructure moves to the cloud, so must the hunt. This lesson adapts our hunting philosophy to Infrastructure-as-a-Service (IaaS) environments like AWS. We will focus on hunting in CloudTrail logs to find the signs of an attacker abusing the cloud control plane.",
                "sections": [
                    {
                        "title": "Hunting the Control Plane with CloudTrail",
                        "content": "<p>The primary attack surface in the cloud is the <strong>control plane</strong>. Every actionâfrom starting a VM to creating a storage bucketâis an API call. In AWS, the log of all these API calls is <strong>CloudTrail</strong>.</p><p>Threat hunting in AWS is the process of searching through CloudTrail logs for suspicious or anomalous sequences of API calls. The goal is to find an attacker who has compromised a set of credentials and is using them to perform reconnaissance and privilege escalation within the AWS account.</p>",
                        "image": "https://i.imgur.com/fgS4fG3.png"
                    },
                    {
                        "title": "Hunting for IAM Privilege Escalation",
                        "content": "<p>Cloud privilege escalation often involves chaining together multiple IAM permissions. Hunting for this involves looking for that specific chain of API calls.</p><h3>Example Hunt: The `SetDefaultPolicyVersion` Escalation</h3><p>An attacker may abuse the `iam:CreatePolicyVersion` and `iam:SetDefaultPolicyVersion` permissions to add new, malicious permissions to an existing user or role. A hunt for this would be:<ul><li><strong>Hypothesis:</strong> An attacker may be escalating privileges by modifying an existing IAM policy.</li><li><strong>Query:</strong> Search CloudTrail for the sequence of events `CreatePolicyVersion` followed by `SetDefaultPolicyVersion`, performed by the same user in a short timeframe.</li><li><strong>Analysis:</strong> For any results, review the content of the new policy version to see if it added risky permissions like `iam:*`.</li></ul></p>",
                        "image": "https://images.unsplash.com/photo-1573495627361-ab2d_50a_a86a?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Testing with Stratus Red Team",
                        "content": "<p><strong>Stratus Red Team</strong> is an open-source tool for emulating cloud-based adversary techniques. It is the 'Atomic Red Team for the cloud'. It contains a library of atomic tests for specific cloud TTPs (e.g., 'Steal EC2 Instance Credentials'). A hunter can use Stratus Red Team to safely test and validate their cloud detection rules and hunt playbooks in a lab environment.</p>",
                        "image": "https://i.imgur.com/kYq3Q6k.png"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "Athena_Query_for_Anomalous_AWS_CloudTrail_API_Calls.sql",
                    "language": "sql",
                    "code": "-- This query for AWS Athena (a tool to query data in S3) hunts for a user\n-- running an unusual number of different EC2 discovery commands.\n\nSELECT useridentity.arn, COUNT(DISTINCT eventname) as distinct_ec2_actions\nFROM cloudtrail_logs\nWHERE eventsource = 'ec2.amazonaws.com'\n  -- 'Describe' calls are used for reconnaissance\n  AND eventname LIKE 'Describe%'\nGROUP BY useridentity.arn\n-- A normal user might run 1-2 describe calls. An attacker enumerating will run many.\nHAVING COUNT(DISTINCT eventname) > 10"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary data source for hunting for threats in an AWS environment?",
                        "options": [
                            "Sysmon logs.",
                            "AWS CloudTrail logs.",
                            "Firewall logs.",
                            "DNS logs."
                        ],
                        "correct": 1,
                        "explanation": "CloudTrail records every single API call made in the AWS account. It is the ground truth for all activity in the control plane and the most critical log source for cloud detection."
                    },
                    {
                        "id": 2,
                        "question": "Hunting for a sequence of API calls like `CreatePolicyVersion` followed by `SetDefaultPolicyVersion` is aimed at finding what type of threat?",
                        "options": [
                            "A phishing attack.",
                            "An IAM privilege escalation attack.",
                            "A ransomware attack.",
                            "A denial-of-service attack."
                        ],
                        "correct": 1,
                        "explanation": "This specific sequence is a known privilege escalation path in AWS. A good hunt will look for the entire chain of events, not just a single API call, to increase its fidelity."
                    },
                    {
                        "id": 3,
                        "question": "What is the purpose of the Stratus Red Team tool?",
                        "options": [
                            "It is a cloud SIEM.",
                            "It is an open-source tool for safely simulating and testing specific cloud adversary TTPs to validate detections.",
                            "It is an IAM management tool.",
                            "It is a cloud firewall."
                        ],
                        "correct": 1,
                        "explanation": "Stratus Red Team is the 'Atomic Red Team for the cloud'. It is an essential tool for any cloud detection engineer to test and validate their rules in a repeatable way."
                    }
                ]
            }
        },
        {
            "id": "lesson-19",
            "title": "Hunting in Cloud Environments: Azure/M365",
            "duration": "75 min",
            "objectives": [
                "Understand the key data sources in the Microsoft cloud ecosystem",
                "Learn how to hunt for illicit consent grant attacks in Azure AD",
                "Explore techniques for finding malicious inbox rules in the Unified Audit Log",
                "Analyze anomalous administrative activity and privilege escalation paths"
            ],
            "content": {
                "overview": "The Microsoft cloud ecosystem, encompassing Azure and Microsoft 365, has its own unique set of threat vectors. This lesson focuses on hunting for adversary behavior in this environment, using the rich telemetry from the Unified Audit Log to find threats like illicit consent grants and malicious email persistence.",
                "sections": [
                    {
                        "title": "The Unified Audit Log (UAL)",
                        "content": "<p>The <strong>Unified Audit Log (UAL)</strong> is the centralized log source for the entire Microsoft 365 ecosystem. It contains telemetry from Azure Active Directory, Exchange Online, SharePoint, Teams, and more. For a hunter, it is the primary source of truth for all user and admin activity.</p>",
                        "image": "https://i.imgur.com/fgS4fG3.png"
                    },
                    {
                        "title": "Hunting for Illicit Consent Grants",
                        "content": "<p>An <strong>illicit consent grant</strong> attack is a sophisticated phishing technique for the cloud. An attacker crafts a malicious, multi-tenant OAuth application in their own Azure tenant. They then trick a user into granting that application permissions to access their data (e.g., 'Read all your email').</p><p>Because the user is granting consent, this can bypass MFA and other controls. The attacker's application now has a permanent API token that it can use to access the user's data from the internet. A hunt for this involves searching the UAL for the 'Consent to application' event and looking for users granting consent to new, rare, or suspicious-looking applications.</p>",
                        "image": "https://images.unsplash.com/photo-1573495627361-ab2d_50a_a86a?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Hunting for Malicious Inbox Rules",
                        "content": "<p>A common persistence and collection technique after an attacker has compromised a user's mailbox is to create a malicious <strong>inbox rule</strong>.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Forwarding All Mail</strong></div><p>The attacker will create a rule in the user's Outlook that automatically forwards a copy of all incoming emails to an external, attacker-controlled email address. This is a very stealthy way to maintain long-term access to a victim's communications. A hunter can find this by querying the UAL for the `New-InboxRule` event and looking for any rule that forwards email to an external domain.</p></div>",
                        "image": "https://i.imgur.com/kYq3Q6k.png"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "KQL_Query_for_Illicit_OAuth_Consent_Grant_Attacks.kql",
                    "language": "kusto",
                    "code": "// This KQL query hunts for suspicious consent grants in the Unified Audit Log.\n\nCloudAppEvents\n| where ActionType == \"Consent to application.\"\n| extend AppDisplayName = tostring(RawEventData.AppDisplayName)\n| extend PublisherName = tostring(RawEventData.PublisherName)\n\n// Look for apps from unverified publishers, which is a major red flag\n| where PublisherName == \"unverified\"\n\n// Or stack the app names and look for the rarest ones\n// | summarize count() by AppDisplayName\n// | order by count_ asc"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary, centralized log source for the Microsoft 365 ecosystem?",
                        "options": [
                            "Windows Event Logs",
                            "Sysmon",
                            "The Unified Audit Log (UAL)",
                            "AWS CloudTrail"
                        ],
                        "correct": 2,
                        "explanation": "The UAL is the key data source for hunting in M365, as it consolidates audit events from Azure AD, Exchange, SharePoint, and other services into a single location."
                    },
                    {
                        "id": 2,
                        "question": "What is an illicit consent grant attack?",
                        "options": [
                            "A password spray attack.",
                            "An attack where a user is tricked into granting a malicious OAuth application permissions to access their data.",
                            "A vulnerability in Azure.",
                            "A type of malware."
                        ],
                        "correct": 1,
                        "explanation": "This is a cloud-native phishing attack. Instead of stealing the user's password, the attacker steals a long-lived API token for their malicious application, which can be used to bypass MFA."
                    },
                    {
                        "id": 3,
                        "question": "An attacker creating an Outlook rule to forward all of a user's emails to an external `gmail.com` address is an example of what?",
                        "options": [
                            "Initial Access",
                            "A persistence and collection technique.",
                            "Lateral Movement",
                            "A legitimate action."
                        ],
                        "correct": 1,
                        "explanation": "This is a classic technique. It gives the attacker persistent access to the victim's email communications and allows them to collect all incoming data, making it both a persistence and collection TTP."
                    }
                ]
            }
        },
        {
            "id": "lesson-20",
            "title": "Hunting in Containerized Environments (Docker/Kubernetes)",
            "duration": "75 min",
            "objectives": [
                "Understand the unique security challenges of containers",
                "Learn how to analyze container runtime logs for threats",
                "Explore techniques for hunting for container escapes",
                "Get an introduction to container security tools like Falco"
            ],
            "content": {
                "overview": "Modern cloud-native applications are built on containers and orchestrated with Kubernetes. These environments are dynamic and ephemeral, creating new challenges and opportunities for threat hunting. This lesson covers the core principles of hunting for threats in and around containers.",
                "sections": [
                    {
                        "title": "The Container Security Challenge",
                        "content": "<p>Containers are ephemeral; they can be created and destroyed in seconds. This means that traditional host-based forensic techniques are often useless. The key is to have a real-time, streaming security monitoring solution that can capture the activity as it happens.</p><p>The primary threat is a <strong>container escape</strong>, where an attacker who has compromised a single container is able to exploit a vulnerability to break out and gain access to the underlying host node, and from there, to the entire Kubernetes cluster.</p>",
                        "image": "https://images.unsplash.com/photo-1510915228340-29c85a43dcfe?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Container Runtime Security with Falco",
                        "content": "<p><strong>Falco</strong> is the de facto open-source standard for container runtime security. It hooks into the Linux kernel and observes every system call made by every process on the host. It then compares this stream of activity against a set of rules to find malicious or anomalous behavior.</p><h3>Example Falco Detections:</h3><ul><li>'A shell was run inside a container.' (Containers should not have interactive shells).</li><li>'A container is writing to a sensitive host directory like `/etc` or `/proc`.' (A sign of an escape attempt).</li><li>'A package manager (like `apt`) is run inside a container.' (Containers should be immutable; software should not be installed at runtime).</li><li>'A container makes an outbound network connection to a non-standard port.'</li></ul>",
                        "image": "https://i.imgur.com/kYq3Q6k.png"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "Falco Rule to Detect a Shell in a Container",
                    "language": "yaml",
                    "code": "- rule: Terminal shell in container\n  desc: A shell was spawned in a container, which is suspicious.\n  condition: >\n    spawned_process and container.id != host and proc.name in (bash, sh, zsh)\n  output: >\n    Shell spawned in a container (user=%user.name container_id=%container.id \n    proc_name=%proc.name parent=%proc.pname cmdline=%proc.cmdline)\n  priority: WARNING\n  tags: [container, shell]"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is a 'container escape'?",
                        "options": [
                            "A container running very fast.",
                            "An attack where an adversary exploits a vulnerability to break out of a container and gain access to the underlying host operating system.",
                            "A method for deleting a container.",
                            "A type of networking for containers."
                        ],
                        "correct": 1,
                        "explanation": "A container escape is the most critical threat in a containerized environment. It is a privilege escalation from the container to the host, which can lead to a full cluster compromise."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary function of a tool like Falco?",
                        "options": [
                            "To build container images.",
                            "To orchestrate containers like Kubernetes.",
                            "To perform container runtime security by monitoring system calls and alerting on anomalous behavior.",
                            "To scan container images for vulnerabilities."
                        ],
                        "correct": 2,
                        "explanation": "Falco is a runtime security tool. Its job is to watch what containers *do* while they are running and to detect any behavior that violates a defined security policy."
                    },
                    {
                        "id": 3,
                        "question": "Why is 'running a shell inside a container' often considered a suspicious event?",
                        "options": [
                            "It is not suspicious.",
                            "Because containers are designed to be immutable and run a single, specific application. An interactive shell is often a sign that an attacker has gained access and is performing manual reconnaissance.",
                            "Because shells are very slow.",
                            "Because containers cannot run shells."
                        ],
                        "correct": 1,
                        "explanation": "In a proper GitOps workflow, no one should ever be interactively 'shelling into' a production container. The presence of a shell is a major deviation from the expected behavior and a classic indicator of compromise."
                    }
                ]
            }
        },
        {
            "id": "lesson-21",
            "title": "Automating the Hunt",
            "duration": "60 min",
            "objectives": [
                "Understand the 'hunt-to-alert' pipeline",
                "Learn how to turn a successful manual hunt into an automated detection",
                "Explore the role of SOAR playbooks in automating hunt workflows",
                "Analyze the trade-offs between manual hunting and automation"
            ],
            "content": {
                "overview": "A manual hunt that finds a threat is a success, but the real value comes from turning that success into a durable, automated detection. This lesson covers the critical process of operationalizing a hunt by converting the manual query and analysis steps into an automated alert that can catch the same threat in the future.",
                "sections": [
                    {
                        "title": "The Hunt-to-Alert Pipeline",
                        "content": "<p>The goal of a mature hunt program is to make itself obsolete. Every time a hunter finds a new, previously unknown threat, they should ask: 'How can I build a machine to find this for me next time?'</p><p>This is the <strong>hunt-to-alert pipeline</strong>. The logic, queries, and analysis steps that the human hunter performed manually are codified into a new detection rule in the SIEM. This turns the reactive, manual hunt into a proactive, automated alert.</p>",
                        "image": "https://i.imgur.com/kYq3Q6k.png"
                    },
                    {
                        "title": "Automating with SOAR",
                        "content": "<p>Even the hunt itself can be partially automated. A SOAR platform can be used to run a hunt playbook on a regular schedule.</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Automated Hunting</strong></div><p>A playbook could be created that automatically runs a complex hunting query every morning at 3 AM. If the query returns any results, the playbook could then perform some initial enrichment (like getting the IP reputation) and then create a single ticket for the hunt team to review when they start their day. This automates the repetitive parts of the hunt, allowing the human hunter to focus on the more complex analysis.</p></div>",
                        "image": "https://images.unsplash.com/photo-1510915228340-29c85a43dcfe?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the 'hunt-to-alert' pipeline?",
                        "options": [
                            "A way to generate more alerts.",
                            "The process of turning the logic from a successful manual hunt into a new, automated detection rule.",
                            "A method for ignoring alerts.",
                            "A tool for threat hunting."
                        ],
                        "correct": 1,
                        "explanation": "This is the core feedback loop that matures a detection program. Human-led hunting finds new threats, and these findings are used to improve the automated defenses."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary benefit of automating a successful hunt?",
                        "options": [
                            "It makes the hunt less accurate.",
                            "It ensures the same threat can be detected automatically and in real-time in the future, freeing up the hunter to look for other new threats.",
                            "It generates more false positives.",
                            "It is not beneficial."
                        ],
                        "correct": 1,
                        "explanation": "Automation provides scale and speed. By operationalizing a hunt, you turn a one-time success into a continuous monitoring capability."
                    },
                    {
                        "id": 3,
                        "question": "How can a SOAR platform be used to assist in threat hunting?",
                        "options": [
                            "It cannot be used for hunting.",
                            "By automatically running scheduled hunting queries and performing initial enrichment on the results.",
                            "By replacing the need for a SIEM.",
                            "By providing the raw log data."
                        ],
                        "correct": 1,
                        "explanation": "A SOAR platform can automate the repetitive, data-gathering parts of a hunt, allowing the human analyst to focus their time on the creative, analytical parts of the investigation."
                    }
                ]
            }
        },
        {
            "id": "lesson-22",
            "title": "Creating a Hunt Playbook",
            "duration": "60 min",
            "objectives": [
                "Understand the importance of documenting hunts for repeatability",
                "Learn the key components of a standardized hunt playbook",
                "Practice creating a playbook for a specific hunt hypothesis",
                "Analyze how playbooks can be used for training and knowledge sharing"
            ],
            "content": {
                "overview": "A hunt that only exists in one person's head is not a scalable or repeatable process. A mature hunt program documents its procedures in standardized playbooks. This lesson covers the structure and components of a hunt playbook, a document that ensures your hunts are consistent, repeatable, and can be shared with the rest of the team.",
                "sections": [
                    {
                        "title": "The Purpose of a Playbook",
                        "content": "<p>A <strong>hunt playbook</strong> is a formal document that describes a specific threat hunt from start to finish. It is a recipe that another hunter can follow to achieve the same result.</p><h3>Benefits of Playbooks:</h3><ul><li><strong>Repeatability:</strong> It ensures that a hunt can be run consistently over time.</li><li><strong>Knowledge Sharing:</strong> It captures the knowledge of experienced hunters and makes it available to the rest of the team.</li><li><strong>Training:</strong> It's an excellent training tool for new analysts.</li><li><strong>Foundation for Automation:</strong> A well-documented playbook is the first step to automating a hunt with a SOAR platform.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Key Components of a Playbook",
                        "content": "<p>A good playbook should contain several key sections:</p><ul><li><strong>Title and ID:</strong> A unique name and identifier.</li><li><strong>ATT&CK Mapping:</strong> The specific TTP the hunt is looking for.</li><li><strong>Hypothesis:</strong> The clear, testable statement that the hunt is based on.</li><li><strong>Data Sources:</strong> The specific logs needed to perform the hunt.</li><li><strong>Queries:</strong> The exact SIEM queries to be run.</li><li><strong>Analysis Steps:</strong> A step-by-step guide for how to analyze the query results and identify true positives.</li><li><strong>Known False Positives:</strong> A list of benign activities that are known to trigger the query.</li></ul>",
                        "image": "https://i.imgur.com/kYq3Q6k.png"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "Hunt_Playbook_for_DNS_Tunneling.md",
                    "language": "markdown",
                    "code": "# Hunt Playbook: HP-007 - DNS Tunneling\n\n- **ATT&CK TTP:** T1071.004 - C2 over DNS\n\n- **Hypothesis:** An attacker may be exfiltrating data or communicating with a C2 via DNS queries. This can be detected by looking for an unusually high number of queries for unique subdomains of a single parent domain.\n\n- **Data Source:** Zeek `dns.log` or equivalent.\n\n- **Query:**\n  ```sql\n  SELECT parent_domain, COUNT(DISTINCT query) as unique_subdomains\n  FROM dns_logs\n  WHERE query_type = 'A' OR query_type = 'TXT'\n  GROUP BY parent_domain\n  HAVING unique_subdomains > 100\n  ORDER BY unique_subdomains DESC\n  ```\n\n- **Analysis Steps:**\n  1.  Run the query over the last 24 hours.\n  2.  For any parent domains with over 100 unique subdomains, investigate the domain's reputation using VirusTotal.\n  3.  Investigate the internal source host that is making the queries.\n  4.  Examine the subdomains themselves. Do they appear to be encoded data?"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is a hunt playbook?",
                        "options": [
                            "A tool for launching attacks.",
                            "A formal document that provides a step-by-step recipe for a specific threat hunt.",
                            "A SIEM query.",
                            "A list of threat actors."
                        ],
                        "correct": 1,
                        "explanation": "A playbook is a standardized document that ensures a hunt is repeatable, consistent, and can be shared with and understood by other members of the team."
                    },
                    {
                        "id": 2,
                        "question": "Which of the following is a key benefit of creating hunt playbooks?",
                        "options": [
                            "They make the hunt take longer.",
                            "They capture and share knowledge, ensuring that the team's procedures are consistent and repeatable.",
                            "They are only for managers.",
                            "They are difficult to write."
                        ],
                        "correct": 1,
                        "explanation": "Knowledge sharing is a primary benefit. A playbook allows a senior hunter to codify their expertise into a process that a more junior analyst can follow and learn from."
                    },
                    {
                        "id": 3,
                        "question": "A well-written hunt playbook is a direct prerequisite for what?",
                        "options": [
                            "Writing a firewall rule.",
                            "Automating the hunt with a SOAR platform.",
                            "Performing a penetration test.",
                            "Hiring a new analyst."
                        ],
                        "correct": 1,
                        "explanation": "Before you can automate a process, you must first have a clearly defined, step-by-step process. A good playbook provides the exact logic that is needed to build an automated workflow in a SOAR tool."
                    }
                ]
            }
        },
        {
            "id": "lesson-23",
            "title": "Integrating Threat Intelligence",
            "duration": "60 min",
            "objectives": [
                "Differentiate between strategic and tactical threat intelligence",
                "Learn how to use strategic intelligence to drive the direction of hunts",
                "Explore the role of threat intelligence platforms (TIPs) like OpenCTI",
                "Practice deconstructing an APT report into actionable hunt hypotheses"
            ],
            "content": {
                "overview": "Threat intelligence is the fuel for a threat hunting program. This lesson explores how to move beyond simple, tactical IOCs and leverage strategic threat intelligenceâdeep knowledge about adversary motivations and TTPsâto drive the entire direction of your hunt program.",
                "sections": [
                    {
                        "title": "Strategic vs. Tactical Intelligence",
                        "content": "<ul><li><strong>Tactical Threat Intelligence:</strong> This is data about specific, known-bad indicators. It is machine-readable and used for automated detection. Examples: A list of malicious IP addresses, file hashes, or domains. This is the bottom of the Pyramid of Pain.</li><li><strong>Strategic Threat Intelligence:</strong> This is high-level, narrative reporting about threat actors. It describes who the attackers are, what their motivations are, what industries they target, and, most importantly, the TTPs they use. This is the top of the Pyramid of Pain.</li></ul>",
                        "image": "https://i.imgur.com/8a6R2aU.png"
                    },
                    {
                        "title": "Driving Hunts with Strategic Intelligence",
                        "content": "<p>A mature hunt program is driven by strategic intelligence. The hunters will read a detailed report about a new APT group that is targeting their industry. They will deconstruct this report, mapping all of the described behaviors to the MITRE ATT&CK framework.</p><p>This provides a prioritized list of TTPs that are known to be used by a relevant adversary. This list becomes the basis for the team's hunt hypotheses for the next quarter. The goal is to answer the question: 'Could this specific adversary operate in our network without being detected?'</p>",
                        "image": "https://images.unsplash.com/photo-1588196749107-15d08b4be52a?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Threat Intelligence Platforms (TIPs)",
                        "content": "<p>A <strong>Threat Intelligence Platform (TIP)</strong> is a tool used to manage and analyze threat intelligence data. Tools like <strong>OpenCTI</strong> allow a team to ingest structured and unstructured intelligence, automatically extract relationships between threat actors, malware, and TTPs, and visualize this information as a graph. This helps the hunt team to see the bigger picture and understand the relationships between different campaigns.</p>",
                        "image": "https://i.imgur.com/kYq3Q6k.png"
                    }
                ]
            },
            "codeExamples": [],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "A list of 1,000 malicious IP addresses is an example of what kind of threat intelligence?",
                        "options": [
                            "Strategic Intelligence",
                            "Tactical Intelligence",
                            "Operational Intelligence",
                            "It is not threat intelligence."
                        ],
                        "correct": 1,
                        "explanation": "This is tactical, indicator-level intelligence. It is useful for automated blocking and alerting on known-bad infrastructure, but it is low on the Pyramid of Pain because the IPs are easy for an attacker to change."
                    },
                    {
                        "id": 2,
                        "question": "How does a threat hunter use a strategic threat intelligence report?",
                        "options": [
                            "They only look for the IOCs.",
                            "They deconstruct the report to understand the adversary's TTPs, and then use that information to create new hunt hypotheses.",
                            "They do not use these reports.",
                            "They forward it to their manager."
                        ],
                        "correct": 1,
                        "explanation": "Strategic reports provide the 'why' and the 'how' of an adversary's operations. This is the most valuable input for a hunter, as it allows them to hunt for the adversary's core behaviors, which are much harder to change than their tools or infrastructure."
                    },
                    {
                        "id": 3,
                        "question": "What is the primary purpose of a Threat Intelligence Platform (TIP)?",
                        "options": [
                            "To act as a SIEM.",
                            "To manage, analyze, and find relationships in a large volume of threat intelligence data from multiple sources.",
                            "To block attacks.",
                            "To perform threat hunting."
                        ],
                        "correct": 1,
                        "explanation": "A TIP is a specialized database and analytics tool for the intelligence team. It helps to aggregate and make sense of the massive amount of available threat data, turning it into actionable intelligence that can then be used to drive hunts."
                    }
                ]
            }
        },
        {
            "id": "lesson-24",
            "title": "Red and Blue Team Collaboration (Purple Teaming)",
            "duration": "75 min",
            "objectives": [
                "Understand the concept and goals of a Purple Team exercise",
                "Differentiate purple teaming from red and blue teaming",
                "Explore the collaborative process of testing and improving detections",
                "Learn how to create a TTP testing plan",
                "Analyze the feedback loop between attackers and defenders"
            ],
            "content": {
                "overview": "The ultimate goal of adversary simulation is to make the defenders better. A purple team exercise is a collaborative approach where the red team and the blue team work together to test, measure, and improve the organization's security controls in real-time. This lesson explores this powerful, collaborative security methodology.",
                "sections": [
                    {
                        "title": "What is a Purple Team?",
                        "content": "<p>A purple team is not a separate team, but a collaborative exercise. It's the process of bringing the red team (the attackers) and the blue team (the defenders) together in a single, open workshop.</p><p>Instead of the red team operating in secret, they will announce their actions. The red teamer will say, 'I am now going to execute TTP T1059.001, PowerShell, on this host'. The blue team then checks their monitoring tools. Did they see it? Did an alert fire? If not, the two teams work together to analyze why it was missed and to write a new detection rule. They then re-run the test to validate that the new detection works. This process is repeated for a list of specific TTPs.</p>",
                        "image": "https://i.imgur.com/o3V8Z7j.png"
                    },
                    {
                        "title": "Goals of a Purple Team Exercise",
                        "content": "<ul><li><strong>Improve Detections:</strong> The primary goal is to find gaps in the security monitoring and to write and validate new detection rules.</li><li><strong>Train the Blue Team:</strong> It's an incredible training opportunity for the blue team, as they get to see exactly what an attack looks like in their own tools and data.</li><li><strong>Foster Collaboration:</strong> It breaks down the silos between the offensive and defensive teams and encourages a more collaborative security culture.</li><li><strong>Measure Performance:</strong> It provides a data-driven way to measure the performance of specific security controls against specific threats.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "Purple_Team_Engagement_Plan.docx",
                    "language": "markdown",
                    "code": "# Purple Team Engagement Plan: Q1\n\n**Objective:** Test and improve detection coverage for the top 5 TTPs used by the FIN7 threat actor.\n\n**Scope:** Corporate user workstations.\n\n**Teams:**\n- Red Team: Alex Chen\n- Blue Team: Jane Doe (SOC), John Smith (Detection Engineering)\n\n**TTPs to Test:**\n1.  **T1566.001 - Spearphishing Attachment:** Red Team will send a test email. Blue Team will confirm it was blocked/alerted on by the email gateway.\n2.  **T1059.001 - PowerShell:** Red Team will execute a PowerShell download cradle. Blue/Detection team will verify the EDR alert and the SIEM rule.\n3.  **T1003.001 - LSASS Memory Dumping:** Red Team will execute a LotL LSASS dump. Blue/Detection team will verify the EDR alert.\n4.  **...**\n5.  **...**"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary characteristic of a purple team exercise?",
                        "options": [
                            "It is a secret, adversarial operation.",
                            "It is a collaborative exercise where the red and blue teams work together openly.",
                            "It is performed by a third-party team.",
                            "It only focuses on penetration testing."
                        ],
                        "correct": 1,
                        "explanation": "Purple teaming is about collaboration, not adversarial secrecy. The goal is to create a tight feedback loop between the attackers and defenders to improve security."
                    },
                    {
                        "id": 2,
                        "question": "What is a major goal of a purple team exercise?",
                        "options": [
                            "To achieve Domain Admin without being detected.",
                            "To test and improve the blue team's detection and response capabilities for specific TTPs.",
                            "To find as many vulnerabilities as possible.",
                            "To write a formal report for executives."
                        ],
                        "correct": 1,
                        "explanation": "A purple team exercise is a highly focused, data-driven effort to measure and improve detection coverage. The output is not a report, but better security controls."
                    },
                    {
                        "id": 3,
                        "question": "What happens during a purple team exercise if the blue team fails to detect a technique executed by the red team?",
                        "options": [
                            "The exercise ends.",
                            "The red team wins.",
                            "The two teams work together to figure out why it was missed and to build and validate a new detection rule.",
                            "The red team moves on to the next technique."
                        ],
                        "correct": 2,
                        "explanation": "This is the core of the purple team feedback loop. A missed detection is not a failure, but an opportunity to immediately improve the organization's defenses in a measurable way."
                    }
                ]
            }
        },
        {
            "id": "lesson-25",
            "title": "Measuring Hunt Program Effectiveness",
            "duration": "60 min",
            "objectives": [
                "Understand why measuring the hunt program is important",
                "Learn how to track metrics beyond just 'evil found'",
                "Explore KPIs like hypotheses tested, new detections created, and reduction in dwell time",
                "Practice creating a dashboard to report on hunt program ROI"
            ],
            "content": {
                "overview": "A threat hunting program is a significant investment. To justify its existence and to drive continuous improvement, a hunt team must measure its effectiveness. This lesson covers the key metrics and Key Performance Indicators (KPIs) that are used to demonstrate the value and Return on Investment (ROI) of a hunt program.",
                "sections": [
                    {
                        "title": "Moving Beyond 'Evil Found'",
                        "content": "<p>Simply counting the number of incidents found by the hunt team is a poor metric. A mature hunt team that is doing its job well will, over time, find *less* evil, because they will have turned all their successful hunts into automated detections.</p><p>A better way to measure success is to focus on the *outcomes* and *improvements* that the hunt program generates.</p>",
                        "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Key Hunt Program Metrics",
                        "content": "<ul><li><strong>Hypotheses Tested:</strong> How many hunts were formally conducted in a given period? This measures the team's activity and operational tempo.</li><li><strong>New Detections Created:</strong> This is the most important output metric. How many successful hunts were converted into new, automated detection rules? This directly measures the program's contribution to improving the organization's security posture.</li><li><strong>Visibility Gaps Identified:</strong> How many hunts failed because the necessary log data was not available? This provides a data-driven way to justify investments in new log sources.</li><li><strong>Reduction in Dwell Time:</strong> Over the long term, the success of the hunt program should be reflected in a reduction in the overall adversary dwell time, as calculated from real incident response data.</li></ul>",
                        "image": "https://i.imgur.com/kYq3Q6k.png"
                    }
                ]
            },
            "codeExamples": [],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "Why is 'number of incidents found' a potentially poor metric for a mature hunt team?",
                        "options": [
                            "Because hunt teams should not find any incidents.",
                            "Because a successful team's work leads to better automated detections, which means there should be fewer incidents for them to find manually over time.",
                            "Because it is too easy to measure.",
                            "Because managers do not care about this metric."
                        ],
                        "correct": 1,
                        "explanation": "This is a key paradox. A hunt team's success can make their own job harder. This is why it's so important to measure their contribution to automation, not just their manual finds."
                    },
                    {
                        "id": 2,
                        "question": "What is the single most important *output* metric for a hunt program?",
                        "options": [
                            "The number of hypotheses they test.",
                            "The number of new, automated detection rules that are created as a result of their hunts.",
                            "The number of logs they analyze.",
                            "The number of people on the team."
                        ],
                        "correct": 1,
                        "explanation": "This metric directly measures the hunt team's contribution to the organization's long-term security. It shows how the proactive, manual work is being used to improve the scalable, automated defenses."
                    },
                    {
                        "id": 3,
                        "question": "A hunt that fails because the required logs do not exist should be considered what?",
                        "options": [
                            "A failure on the part of the hunter.",
                            "A successful outcome, because it has identified a critical visibility gap that needs to be fixed.",
                            "A waste of time.",
                            "An anomaly."
                        ],
                        "correct": 1,
                        "explanation": "Even a 'failed' hunt provides value. Discovering that you are blind to a specific ATT&CK technique is a critical finding that can be used to justify the investment in new log sources or security tools."
                    }
                ]
            }
        },
        {
            "id": "lesson-26",
            "title": "Communicating Findings and Driving Change",
            "duration": "60 min",
            "objectives": [
                "Understand the importance of effective communication",
                "Learn how to translate complex technical findings into business risk",
                "Explore the structure of a hunt finding report",
                "Practice writing a compelling executive summary for a hunt finding"
            ],
            "content": {
                "overview": "A brilliant technical finding that no one understands or acts upon is useless. The final step of any hunt is to communicate the findings in a clear, concise, and compelling way that drives change. This lesson covers the art of translating deep technical analysis into a narrative that resonates with leadership and other teams.",
                "sections": [
                    {
                        "title": "Translating Technical Findings into Business Risk",
                        "content": "<p>A SOC analyst needs to know that a specific command was run. A CISO needs to know what the *business impact* of that command is. A key skill for a hunter is to be able to bridge this gap.</p><p>Instead of saying 'We found evidence of a Pass-the-Hash attack', a hunter should say 'We found evidence of an attack that would allow an adversary to bypass our password policies and access any server in our environment, including the finance database'. The second statement connects the technical finding to a clear business risk ('access to the finance database').</p>",
                        "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The Hunt Finding Report",
                        "content": "<p>Each major finding from a hunt should be documented in a short, formal report. This report serves two audiences:</p><ul><li><strong>The Executive Summary:</strong> A one-paragraph summary written in plain language for a non-technical audience. It should state the finding, the business risk, and the primary recommendation.</li><li><strong>The Technical Details:</strong> A detailed, evidence-based account of the hunt for the technical audience (like the detection engineering team). It should include the queries used, the data analyzed, and the specific evidence that was found.</li></ul>",
                        "image": "https://i.imgur.com/kYq3Q6k.png"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "Hunt_Finding_Executive_Summary_Template.pptx",
                    "language": "markdown",
                    "code": "# Hunt Finding: HF-007 - Unmonitored Lateral Movement Vector\n\n## Executive Summary\n\nA recent threat hunt discovered that attackers can move between servers in our environment using the Windows Remote Management (WinRM) protocol. Our current detection capabilities are blind to this activity. This represents a critical risk, as an attacker who has compromised a single workstation could use this technique to move laterally and gain access to business-critical servers, such as those hosting customer data. **We recommend immediately enabling and ingesting detailed PowerShell and WinRM logs into the SIEM to close this visibility gap.**"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary goal of communicating a hunt finding to leadership?",
                        "options": [
                            "To show off your technical skills.",
                            "To translate the technical finding into a clear business risk that justifies action and investment.",
                            "To provide a detailed log of every command you ran.",
                            "To get a bigger budget."
                        ],
                        "correct": 1,
                        "explanation": "Effective communication is key. Leadership makes decisions based on business risk, so a hunter must be able to explain *why* their technical finding matters to the business."
                    },
                    {
                        "id": 2,
                        "question": "The executive summary of a hunt report should be...",
                        "options": [
                            "Very long and technical.",
                            "Written for the SOC analysts.",
                            "A short, high-level summary written in plain language for a non-technical audience.",
                            "A copy of the SIEM query."
                        ],
                        "correct": 2,
                        "explanation": "The executive summary is the most important part of the report for getting leadership buy-in. It must be concise, clear, and focused on business impact."
                    },
                    {
                        "id": 3,
                        "question": "What is the key to 'driving change' with a hunt finding?",
                        "options": [
                            "Finding something interesting.",
                            "Writing the report.",
                            "Providing a clear, actionable recommendation that tells the organization exactly what they need to do to fix the problem.",
                            "Blaming another team for the gap."
                        ],
                        "correct": 2,
                        "explanation": "A finding without a recommendation is just a complaint. A good hunt report provides a solution, not just a problem, which is what allows it to drive real improvement in the security posture."
                    }
                ]
            }
        },
        {
            "id": "lesson-27",
            "title": "Hunting for Insider Threats",
            "duration": "75 min",
            "objectives": [
                "Understand the unique challenges of detecting insider threats",
                "Apply hunting techniques to find malicious or unintentional insider activity",
                "Explore how to hunt for data hoarding and unusual access patterns",
                "Analyze the role of UEBA platforms in surfacing insider threat leads"
            ],
            "content": {
                "overview": "An insider threatâa malicious or negligent employeeâis one of the most difficult threats to detect. They are a legitimate user with legitimate access. This lesson applies our hunting methodologies to the specific challenge of finding insider threats, where the signals are often subtle and buried in a sea of normal user behavior.",
                "sections": [
                    {
                        "title": "The Insider Threat Challenge",
                        "content": "<p>Detecting an insider is not about finding malware or a C2 beacon. The insider is using their own, valid credentials and the standard tools of their job. The only way to find them is to find anomalous *behavior*.</p><p>This is a perfect use case for threat hunting and User and Entity Behavior Analytics (UEBA). The hunt involves baselining what is normal for a user and then searching for significant deviations from that baseline.</p>",
                        "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Hunting for Data Hoarding",
                        "content": "<p>A common behavior for an employee who is planning to leave the company and take data with them is <strong>data hoarding</strong>. In the weeks before they resign, they will start accessing and downloading a large volume of files that they do not normally access, often from SharePoint, a file server, or a CRM system.</p><p>A hunt for this involves:<ul><li>Analyzing file access logs or DLP logs.</li><li>For each user, establishing a baseline of their normal daily file access and download volume.</li><li>Hunting for users whose activity is a significant statistical outlier (e.g., more than 3 standard deviations above their own personal average).</li></ul></p>",
                        "image": "https://i.imgur.com/kYq3Q6k.png"
                    },
                    {
                        "title": "The Role of UEBA",
                        "content": "<p>Modern <strong>UEBA</strong> platforms are designed to automate this type of hunting. They automatically build the complex, multi-faceted behavioral baselines for every user and will automatically surface the riskiest anomalies and users for the hunt team to investigate.</p><p>A hunter can use the UEBA platform as a starting point. Instead of starting with raw logs, they can start with the UEBA system's top 10 riskiest users and perform a deep-dive investigation on their activity to determine if it is malicious or just benignly anomalous.</p>",
                        "image": "https://images.unsplash.com/photo-1573495627361-ab2d_50a_a86a?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "Why is detecting an insider threat so challenging?",
                        "options": [
                            "Because they use custom malware.",
                            "Because they are a legitimate user with valid credentials, so their activity can easily blend in with normal business operations.",
                            "Because they only attack during business hours.",
                            "It is not challenging."
                        ],
                        "correct": 1,
                        "explanation": "The challenge is that the insider is not an 'other'. They are an authorized user. Therefore, detection must be based on finding subtle deviations in their behavior, not on finding a single, obviously malicious event."
                    },
                    {
                        "id": 2,
                        "question": "An employee suddenly downloading ten times their normal daily volume of files from SharePoint is an example of what?",
                        "options": [
                            "A malware infection.",
                            "A network outage.",
                            "Data hoarding, a potential indicator of an insider threat.",
                            "A normal activity."
                        ],
                        "correct": 2,
                        "explanation": "This is a classic insider threat pattern. A sudden, large increase in data access or downloads, especially for data outside the user's normal job function, is a major red flag that requires investigation."
                    },
                    {
                        "id": 3,
                        "question": "How do UEBA platforms assist in hunting for insider threats?",
                        "options": [
                            "They block the threat automatically.",
                            "They automatically build detailed behavioral baselines for each user and surface the most statistically significant anomalies for a human hunter to investigate.",
                            "They do not assist with insider threats.",
                            "They only look for malware."
                        ],
                        "correct": 1,
                        "explanation": "UEBA automates the first 80% of the hunt. It performs the large-scale data analysis to find the statistical outliers, which allows the human hunter to focus their time on the high-value work of investigating these pre-qualified leads."
                    }
                ]
            }
        },
        {
            "id": "lesson-28",
            "title": "Hunting with Deception Technology",
            "duration": "60 min",
            "objectives": [
                "Understand how deception technology can trigger a hunt",
                "Learn the concept of using honeypots, honeytokens, and canaries as tripwires",
                "Explore the high-fidelity nature of deception-based alerts",
                "Practice deploying a canary token and building a hunt around its potential usage"
            ],
            "content": {
                "overview": "Deception technology provides the ultimate high-fidelity signal for a threat hunter. An alert from a decoy asset is, by definition, interesting and almost never a false positive. This lesson covers how to use deception technology as a trigger for a proactive threat hunt.",
                "sections": [
                    {
                        "title": "Deception as a Tripwire",
                        "content": "<p>The core idea of deception technology is to create attractive, fake assets that no legitimate user should ever interact with. Any interaction with these decoys is an immediate, high-confidence signal of an attacker performing reconnaissance or lateral movement.</p><p>A threat hunter can use these alerts as the starting point for a new hunt. The alert is not the end of the investigation; it is the beginning. It tells the hunter exactly *where* the attacker is and *what* they are doing right now.</p>",
                        "image": "https://images.unsplash.com/photo-1588196749107-15d08b4be52a?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Hunting with Honeytokens and Canaries",
                        "content": "<p>When a deception alert fires, it provides a very strong lead for a hunt.</p><ul><li><strong>Canary File:</strong> An alert fires that the file `Finance\\2024_Salaries.xlsx` has been opened. The hunter can immediately pivot to the file access logs to see which user and which host accessed the file. The hunter now knows they have a compromised user or host and can begin a full investigation.</li><li><strong>Honeyuser:</strong> An alert fires that the fake AD user account `SQL-Admin-SVC` was used in a login attempt. The hunter knows an attacker is enumerating Active Directory. They can immediately look at the source of the login attempt to find the attacker's internal host and can begin looking for other signs of AD reconnaissance.</li></ul>",
                        "image": "https://i.imgur.com/kYq3Q6k.png"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "Deploying a Canary Token",
                    "language": "markdown",
                    "code": "# Canarytokens.org is a free service for creating honeytokens.\n\n1.  **Go to https://canarytokens.org**\n2.  **Select a token type:** Choose 'MS Word Document'.\n3.  **Enter your email address:** This is where the alert will be sent.\n4.  **Enter a reminder note:** 'Fake salary document on the finance share'.\n5.  **Download the token:** The site will generate a unique Word document.\n6.  **Deploy the token:** Rename the file to something enticing (e.g., `Executive_Bonuses_2024.docx`) and place it on a network file share.\n\n# --- The Alert ---\n# When an attacker opens this document, it will make a DNS request in the background.\n# The Canarytokens server will detect this and send you an immediate email alert,\n# including the IP address of the machine that opened the file. This is the starting\n# point for your hunt."
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary benefit of alerts from deception technology?",
                        "options": [
                            "They are very high-volume.",
                            "They are often very high-fidelity (low false positive rate).",
                            "They are easy to ignore.",
                            "They provide a lot of technical detail."
                        ],
                        "correct": 1,
                        "explanation": "Because legitimate users have no reason to interact with the decoy assets, almost every alert from a deception system is a true positive. This allows the SOC and hunt teams to respond with a high degree of confidence."
                    },
                    {
                        "id": 2,
                        "question": "A fake AWS access key that is intentionally placed in a public source code repository is an example of what?",
                        "options": [
                            "A honeypot",
                            "A canary file",
                            "A honeytoken",
                            "A misconfiguration"
                        ],
                        "correct": 2,
                        "explanation": "A honeytoken is a decoy piece of data, in this case, a credential. The detection is simple: alert if this key is ever used, because no one should ever be using it."
                    },
                    {
                        "id": 3,
                        "question": "How does a deception alert act as a trigger for a threat hunt?",
                        "options": [
                            "It provides the final conclusion of the investigation.",
                            "It provides a very strong starting point, telling the hunter exactly where an adversary is and what they are currently doing.",
                            "It automatically contains the threat.",
                            "It does not trigger a hunt."
                        ],
                        "correct": 1,
                        "explanation": "A deception alert is a high-confidence lead. It immediately focuses the hunter's attention on a specific host or user, allowing them to bypass the broad search phase and jump straight into a targeted investigation."
                    }
                ]
            }
        },
        {
            "id": "lesson-29",
            "title": "The Future of Threat Hunting",
            "duration": "60 min",
            "objectives": [
                "Discuss the impact of AI/ML on the future of hunting",
                "Learn about the rise of Open-Source security tools (OSDF)",
                "Explore the shift towards hunting in Infrastructure-as-Code (IaC)",
                "Analyze the long-term strategic challenges and opportunities for hunters"
            ],
            "content": {
                "overview": "The discipline of threat hunting is constantly evolving to keep pace with technology and the threat landscape. This lesson looks to the future, exploring the major trends that will shape the next generation of threat hunting, from the deep integration of AI to the new frontier of 'shifting left' to hunt in code before it's ever deployed.",
                "sections": [
                    {
                        "title": "The AI-Augmented Hunter",
                        "content": "<p>The future of hunting is a human-machine partnership. AI and machine learning will not replace the human hunter, but will act as a powerful force multiplier.</p><p>Future SIEM and EDR platforms will have increasingly sophisticated, built-in UEBA and anomaly detection capabilities. The AI will be responsible for sifting through the billions of events to find the most interesting statistical outliers. The human hunter's job will be to take these high-quality leads from the AI, apply their own creativity and contextual knowledge, and perform the final investigation.</p>",
                        "image": "https://images.unsplash.com/photo-1555949963-aa79dcee981c?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Hunting in Infrastructure-as-Code (IaC)",
                        "content": "<p>The most proactive form of hunting is to find a threat before it can even be exploited. In a modern cloud environment where infrastructure is defined as code (IaC) using tools like Terraform, we can hunt for vulnerabilities *in the code itself*.</p><p>The future of threat hunting involves 'shifting left'. A hunter can write queries to proactively scan all of the organization's Terraform code to look for misconfigurations, such as a public S3 bucket or an overly permissive IAM policy. Finding and fixing this bug in the code is far more effective than trying to detect its exploitation in production.</p>",
                        "image": "https://i.imgur.com/3Z4h7k2.png"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "IaC_Security_Scanning_with_Tfsec.sh",
                    "language": "bash",
                    "code": "# Tfsec is an open-source static analysis tool for Terraform code.\n# A hunter can use this tool to proactively hunt for misconfigurations in IaC.\n\n# Run tfsec on the current directory of Terraform files\ntfsec .\n\n# --- Sample Output ---\n# Result 1: AWS S3 bucket does not have logging enabled\n#   File: s3.tf, Lines: 10-15\n#   Severity: MEDIUM\n#\n# Result 2: AWS IAM policy allows all actions ('*') on all resources ('*').\n#   File: iam.tf, Lines: 5-12\n#   Severity: CRITICAL"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What does it mean to 'shift left' in the context of security?",
                        "options": [
                            "To move security later in the lifecycle.",
                            "To move security earlier in the lifecycle, such as into the development and deployment phases.",
                            "To focus only on network security.",
                            "To move all infrastructure to the left."
                        ],
                        "correct": 1,
                        "explanation": "'Shifting left' is a core principle of modern DevSecOps. It's about building security in from the beginning, rather than trying to bolt it on at the end. Hunting for misconfigurations in IaC code is a prime example."
                    },
                    {
                        "id": 2,
                        "question": "How will AI and machine learning likely impact the role of the threat hunter in the future?",
                        "options": [
                            "AI will replace the need for human hunters.",
                            "AI will act as a powerful assistant, automating the large-scale data analysis and allowing the human hunter to focus on the complex investigation of high-quality leads.",
                            "AI will have no impact on threat hunting.",
                            "AI will only be used for writing reports."
                        ],
                        "correct": 1,
                        "explanation": "The future is a human-machine partnership. AI will handle the 'big data' part of the problem, while humans will provide the creativity, intuition, and contextual understanding that machines lack."
                    },
                    {
                        "id": 3,
                        "question": "Hunting for a rule that creates a public S3 bucket in a company's Terraform code is an example of what?",
                        "options": [
                            "A reactive hunt.",
                            "A proactive, 'shift left' hunt for a cloud misconfiguration.",
                            "An endpoint-based hunt.",
                            "A network-based hunt."
                        ],
                        "correct": 1,
                        "explanation": "This is the ultimate proactive hunt. By finding the vulnerability in the code before it is deployed, the hunter prevents the misconfiguration from ever existing in the production environment, which is the most effective possible outcome."
                    }
                ]
            }
        },
        {
            "id": "lesson-30",
            "title": "Capstone: End-to-End Hunt Simulation",
            "duration": "120 min",
            "objectives": [
                "Apply the full hunt lifecycle to a practical scenario",
                "Research a given threat intelligence brief to form hypotheses",
                "Query and analyze a large dataset to find simulated adversary activity",
                "Document the hunt in a formal playbook",
                "Present the findings and the resulting new detection rule"
            ],
            "content": {
                "overview": "This final lesson is the capstone project, where you will bring together everything you have learned to perform a full, end-to-end threat hunt. You will be given a high-level intelligence brief and access to a large, realistic dataset from a simulated attack. Your mission is to independently hunt for, find, and report on the adversary's activity.",
                "sections": [
                    {
                        "title": "The Scenario",
                        "content": "<p>Students will be provided with a large dataset (e.g., several days of Sysmon, Zeek, and Windows Event Logs) from a simulated corporate network. They will also be given a high-level intelligence brief.</p><h3>Intelligence Brief:</h3><p><em>'Your organization has received a notification that a threat actor known as 'WIZARD SPIDER' may be targeting our industry. This actor is known to use the TrickBot malware, followed by Cobalt Strike for post-exploitation. They frequently use WMI for lateral movement.'</em></p>",
                        "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The Mission",
                        "content": "<p>Your mission is to assume that this adversary has already breached the network and to hunt for the evidence of their TTPs in the provided dataset. You must:</p><ol><li><strong>Formulate Hypotheses:</strong> Based on the intel, create at least three specific hunt hypotheses.</li><li><strong>Execute the Hunt:</strong> Use the SIEM in the lab environment to query the data and investigate your hypotheses.</li><li><strong>Uncover the Attack Chain:</strong> Find the adversary's activity and piece together their attack chain.</li><li><strong>Develop a New Detection:</strong> Create a new, high-fidelity Sigma rule that would have automatically detected this activity.</li><li><strong>Document:</strong> Create a formal hunt playbook for one of your successful hunts.</li></ol>",
                        "image": "https://i.imgur.com/kYq3Q6k.png"
                    },
                    {
                        "title": "Final Deliverable",
                        "content": "<p>The final deliverable is a presentation to the class that summarizes your findings. The presentation should act as a debrief to a SOC manager. It must include:</p><ul><li>A summary of your initial hypotheses.</li><li>The queries and analysis you performed.</li><li>The evidence of the adversary activity you discovered.</li><li>The new, automated detection rule you created.</li><li>An analysis of any visibility gaps you discovered during the hunt.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "Capstone_Project_Threat_Intel_Brief.md",
                    "language": "markdown",
                    "code": "# Capstone Project Brief\n\n**Threat Intelligence Source:** CISA Alert AA22-277A (File-Tainting and Proxy-Not-Shell)\n\n**Adversary:** Unnamed APT\n\n**TTP for Detection:**\nThe report notes that the adversary uses the `msdt.exe` (Microsoft Support Diagnostic Tool) binary to execute PowerShell code. The command line is `msdt.exe -tab -pcalua -diagcab %LOCALAPPDATA%\\Random.diagcab`.\n\n**Your Mission:**\n1.  Form a hypothesis for detecting this specific abuse of `msdt.exe`.\n2.  Write a Sigma rule for it.\n3.  Figure out how to simulate this behavior in the lab (Note: Atomic Red Team may not have this specific test, you may need to do manual research).\n4.  Test and document your rule.\n5.  Submit your detection package."
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary purpose of a capstone project in a course like this?",
                        "options": [
                            "To review the content of a single lesson.",
                            "To provide a large, hands-on project that allows a student to apply the knowledge and skills from the entire course to a realistic scenario.",
                            "To take a final exam.",
                            "To learn a new topic."
                        ],
                        "correct": 1,
                        "explanation": "A capstone project is a culminating experience that integrates all the concepts learned throughout the curriculum into a single, comprehensive, practical project."
                    },
                    {
                        "id": 2,
                        "question": "What is the first step in the capstone project?",
                        "options": [
                            "Writing the code.",
                            "Testing the rule.",
                            "Analyzing the provided threat intelligence report and forming a clear, testable hypothesis.",
                            "Deploying the rule."
                        ],
                        "correct": 2,
                        "explanation": "The entire lifecycle begins with a good hypothesis. The first step is always to thoroughly understand the adversary behavior you are trying to detect, based on the provided intelligence."
                    },
                    {
                        "id": 3,
                        "question": "What is a key deliverable of the capstone project, demonstrating that the hunt was successful?",
                        "options": [
                            "Just a list of suspicious events.",
                            "A presentation.",
                            "A new, well-documented, and tested detection rule that would have automatically caught the simulated attack.",
                            "A screenshot of the SIEM."
                        ],
                        "correct": 2,
                        "explanation": "The capstone project simulates the full hunt-to-alert pipeline. The ultimate goal is not just to find the threat, but to create a durable defense against it, which is embodied in the final, tested detection rule."
                    }
                ]
            }
        }
    ]
}
      // =====================================================
      // GLOBAL VARIABLES
      // =====================================================
      let currentUser = null;
      let currentLessonIndex = 0;
      let courseProgress = {};
      let userStats = {};
      let quizState = {
        currentQuestion: 0,
        answers: [],
        score: 0,
        isComplete: false,
        timeStarted: null,
        timeCompleted: null,
        currentQuestionIndex: 0,
      };

      // Enhanced session tracking
      let courseSession = {
        startTime: null,
        totalStudyTime: 0,
        lessonsStarted: 0,
        lessonsCompleted: 0,
        pageLoadTime: new Date(),
        lastActive: new Date(),
        interactions: 0,
        completedSections: [],
        totalTime: 0,
        interactionCount: 0,
        lastActivityTime: new Date(),
      };

      // Music Player Variables
      let audioPlayer = new Audio();

      // Achievement notification system
      let notificationQueue = [];
      let isShowingNotification = false;

      // =====================================================
      // INITIALIZATION
      // =====================================================
      document.addEventListener("DOMContentLoaded", async () => {
        try {
          showLoadingScreen();
          await checkAuth();

          if (currentUser) {
            // Initialize session tracking
            startCourseSession();

            // Load course data and progress
            await loadCourseData();
            await loadUserProfile();
            await loadProgress();

            // Initialize UI
            initializeEventListeners();
            renderSidebar();
            loadLesson(currentLessonIndex);

            // Initialize additional features
            initMusicPlayer();
            addMusicIndicator();
            initializeActivityTracking();

            hideLoadingScreen();
          } else {
            openAuthModal();
          }
        } catch (error) {
          console.error("Error initializing course:", error);
          hideLoadingScreen();
          showToast("Failed to initialize course system", "error");
        }
      });

      // =====================================================
      // AUTHENTICATION SYSTEM
      // =====================================================
      async function checkAuth() {
        try {
          const {
            data: { session },
            error,
          } = await supabase.auth.getSession();

          if (error) {
            console.error("Auth error:", error);
            currentUser = null;
            openAuthModal();
            return;
          }

          if (!session) {
            currentUser = null;
            openAuthModal();
            return;
          }

          currentUser = session.user;
          updateUIWithUser();
        } catch (error) {
          console.error("Error checking auth:", error);
          currentUser = null;
          openAuthModal();
        }
      }

      function updateUIWithUser() {
        if (!currentUser) return;

        const name =
          currentUser.user_metadata?.full_name ||
          currentUser.email.split("@")[0];
        const userElements = document.querySelectorAll("[data-user-name]");
        userElements.forEach((el) => (el.textContent = name));
      }

      // =====================================================
      // USER PROFILE & STATS MANAGEMENT
      // =====================================================
      async function loadUserProfile() {
        try {
          // ð Step 1: Try to fetch existing profile
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("*")
            .eq("id", currentUser.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (!profile) {
            // ð Step 2: Create new profile if missing
            await createUserProfile();
          } else {
            // â Step 3: Use existing profile
            userStats = profile;
            await updateLastActivity();
          }
        } catch (error) {
          console.error("â Error loading user profile:", error);
          showToast("Failed to load user profile", "error");
        }
      }
      async function createUserProfile() {
        try {
          const newProfile = {
            id: currentUser.id,
            full_name: currentUser.user_metadata?.full_name || "",
            email: currentUser.email,
            level: "Script Kiddie",
            total_points: 0,
            completed_courses: 0,
            current_streak: 0,
            total_certificates: 0,
            total_achievements: 0,
            sections_visited: 0,
            bonus_points: 0,
            in_progress_courses: 0,
            settings_changed: 0,
            midnight_sessions: 0,
            early_sessions: 0,
            weekend_sessions: 0,
            last_activity: new Date().toISOString(),
            created_at: new Date().toISOString(),
          };

          const { error } = await supabase
            .from("profiles")
            .insert([newProfile]);

          if (!error) {
            userStats = newProfile;
            // Award first login achievement
            setTimeout(() => checkAndUnlockAchievement("first_login"), 1000);
          }
        } catch (error) {
          console.error("Error creating user profile:", error);
        }
      }

      async function updateLastActivity() {
        try {
          const now = new Date();

          // Update activity tracking
          courseSession.lastActivityTime = now;

          // Update database
          await supabase
            .from("profiles")
            .update({
              last_activity: now.toISOString(),
            })
            .eq("id", currentUser.id);

          // Check time-based achievements
          await checkTimeBasedAchievements(now);
        } catch (error) {
          console.error("Error updating last activity:", error);
        }
      }

      // =====================================================
      // COURSE SESSION MANAGEMENT
      // =====================================================
      function startCourseSession() {
        courseSession.startTime = new Date();
        courseSession.pageLoadTime = new Date();

        logUserActivity("course_session_start", {
          course_id: COURSE_DATA.id,
          course_title: COURSE_DATA.title,
          user_agent: navigator.userAgent,
          screen_resolution: `${screen.width}x${screen.height}`,
        });

        // Check daily streak
        checkDailyStreak();
      }

      function initializeActivityTracking() {
        // Track page focus/blur for accurate study time
        document.addEventListener("visibilitychange", handleVisibilityChange);

        // Track user interactions
        ["click", "keydown", "scroll", "mousemove"].forEach((event) => {
          document.addEventListener(event, trackUserInteraction, {
            passive: true,
          });
        });

        // Periodic activity updates
        setInterval(updateStudyTime, 60000); // Every minute

        // Save session data before page unload
        window.addEventListener("beforeunload", saveSessionData);
      }

      function handleVisibilityChange() {
        if (document.hidden) {
          courseSession.lastActivityTime = new Date();
        } else {
          // Page became visible again - update activity
          updateLastActivity();
        }
      }

      function trackUserInteraction() {
        courseSession.interactionCount++;
        courseSession.lastActivityTime = new Date();

        // Throttle activity updates
        if (courseSession.interactionCount % 50 === 0) {
          updateLastActivity();
        }
      }

      function updateStudyTime() {
        if (!courseSession.startTime || document.hidden) return;

        const now = new Date();
        const sessionDuration = now - courseSession.startTime;
        courseSession.totalStudyTime = Math.floor(sessionDuration / 1000 / 60); // in minutes

        // Update progress with study time
        saveProgress();
      }

      function saveSessionData() {
        if (!currentUser || !courseSession.startTime) return;

        const sessionData = {
          user_id: currentUser.id,
          course_id: COURSE_DATA.id,
          session_duration: courseSession.totalStudyTime,
          lessons_viewed: courseSession.lessonsStarted,
          lessons_completed: courseSession.lessonsCompleted,
          interactions: courseSession.interactionCount,
          session_date: courseSession.startTime.toISOString().split("T")[0],
        };

        // Store in localStorage as backup
        localStorage.setItem(
          "course_session_backup",
          JSON.stringify(sessionData)
        );

        // Try to save to database
        logUserActivity("course_session_end", sessionData);
      }

      // =====================================================
      // COURSE DATA & PROGRESS MANAGEMENT
      // =====================================================
      async function loadCourseData() {
        try {
          // Update course info in UI
          document.getElementById("courseTitle").textContent =
            COURSE_DATA.title;
          document.getElementById("totalLessons").textContent =
            COURSE_DATA.lessons.length;

          // Log course access
          logUserActivity("course_access", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
          });
        } catch (error) {
          console.error("Error loading course data:", error);
        }
      }

      async function loadProgress() {
        try {
          // Get existing progress from database
          const { data, error } = await supabase
            .from("course_progress")
            .select("*")
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (data) {
            courseProgress = JSON.parse(data.lesson_progress || "{}");
            currentLessonIndex = data.current_lesson || 0;

            // Update session tracking
            courseSession.lessonsStarted = Object.keys(courseProgress).length;
            courseSession.lessonsCompleted = Object.values(
              courseProgress
            ).filter((p) => p.completed).length;
          } else {
            // Initialize new progress
            courseProgress = {};
            currentLessonIndex = 0;
            await saveProgress();

            // Award first course start achievement
            await checkAndUnlockAchievement("first_course_start");
          }

          updateProgressDisplay();
        } catch (error) {
          console.error("Error loading progress:", error);
          showToast("Failed to load progress", "error");
        }
      }

      async function saveProgress() {
        try {
          if (!currentUser) return;

          const now = new Date();
          const progressData = {
            user_id: currentUser.id,
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            current_lesson: currentLessonIndex,
            lesson_progress: JSON.stringify(courseProgress),
            progress: calculateOverallProgress(),
            lessons_completed: getCompletedLessonsCount(),
            lessons_started: Object.keys(courseProgress).length,
            study_time_minutes: courseSession.totalStudyTime,
            last_accessed: now.toISOString(),
            updated_at: now.toISOString(),
          };

          // Upsert progress
          const { error } = await supabase
            .from("course_progress")
            .upsert([progressData]);

          if (error) throw error;

          // Update user stats
          await updateUserStats();

          updateProgressDisplay();
        } catch (error) {
          console.error("Error saving progress:", error);
          showToast("Failed to save progress", "error");
        }
      }

      async function updateUserStats() {
        try {
          // Get all course progress for this user
          const { data: allProgress, error } = await supabase
            .from("course_progress")
            .select("progress, course_id, study_time_minutes")
            .eq("user_id", currentUser.id);

          if (error) throw error;

          // Calculate stats
          const completedCourses =
            allProgress?.filter((p) => p.progress >= 100).length || 0;
          const inProgressCourses =
            allProgress?.filter((p) => p.progress > 0 && p.progress < 100)
              .length || 0;
          const totalStudyTime =
            allProgress?.reduce(
              (sum, p) => sum + (p.study_time_minutes || 0),
              0
            ) || 0;

          // Calculate points (500 per completed course + achievement points)
          const coursePoints = completedCourses * 500;
          const bonusPoints = userStats.bonus_points || 0;
          const totalPoints = coursePoints + bonusPoints;

          // Update profile
          const updateData = {
            completed_courses: completedCourses,
            in_progress_courses: inProgressCourses,
            total_points: totalPoints,
            total_study_time: totalStudyTime,
            last_activity: new Date().toISOString(),
          };

          const { error: updateError } = await supabase
            .from("profiles")
            .update(updateData)
            .eq("id", currentUser.id);

          if (updateError) throw updateError;

          // Update local stats
          Object.assign(userStats, updateData);
        } catch (error) {
          console.error("Error updating user stats:", error);
        }
      }

      function calculateOverallProgress() {
        const completedLessons = getCompletedLessonsCount();
        return Math.round(
          (completedLessons / COURSE_DATA.lessons.length) * 100
        );
      }

      function getCompletedLessonsCount() {
        return Object.values(courseProgress).filter(
          (lesson) => lesson.completed
        ).length;
      }

      function updateProgressDisplay() {
        const completedCount = getCompletedLessonsCount();
        const progressPercent = calculateOverallProgress();

        // Update UI elements
        const elements = {
          completedLessons: completedCount,
          courseProgressPercent: `${progressPercent}%`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });

        // Update progress bar
        const progressBar = document.getElementById("courseProgressFill");
        if (progressBar) progressBar.style.width = `${progressPercent}%`;
      }

      // =====================================================
      // LESSON MANAGEMENT
      // =====================================================
      function loadLesson(index) {
        if (index < 0 || index >= COURSE_DATA.lessons.length) return;

        const lesson = COURSE_DATA.lessons[index];
        currentLessonIndex = index;

        // Mark lesson as started and track activity
        if (!courseProgress[lesson.id]) {
          courseProgress[lesson.id] = {
            started: true,
            completed: false,
            startedAt: new Date().toISOString(),
            timeSpent: 0,
          };

          courseSession.lessonsStarted++;
          saveProgress();

          // Log lesson start
          logUserActivity("lesson_start", {
            lesson_id: lesson.id,
            lesson_title: lesson.title,
            lesson_index: index,
          });
        }

        // Update lesson start time for time tracking
        courseProgress[lesson.id].currentSessionStart = new Date();

        // Update sidebar and navigation
        renderSidebar();
        updateNavigationButtons();

        // Update header info
        updateLessonHeader(lesson, index);

        // Render lesson content
        renderLessonContent(lesson);

        // Smooth scroll and animations
        window.scrollTo({ top: 0, behavior: "smooth" });
        document.getElementById("contentBody").scrollTop = 0;

        const contentBody = document.getElementById("contentBody");
        contentBody.classList.add("fade-in");
        setTimeout(() => contentBody.classList.remove("fade-in"), 500);

        // Check lesson-based achievements
        checkLessonAchievements(index + 1);
      }

      function updateLessonHeader(lesson, index) {
        const elements = {
          currentLessonNumber: index + 1,
          currentLessonTitle: lesson.title,
          navInfo: `Lesson ${index + 1} of ${COURSE_DATA.lessons.length}`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });
      }

      function renderSidebar() {
        const lessonNav = document.getElementById("lessonNav");
        if (!lessonNav) return;

        lessonNav.innerHTML = "";

        COURSE_DATA.lessons.forEach((lesson, index) => {
          const lessonItem = document.createElement("div");
          lessonItem.className = "lesson-item";

          // Determine lesson status
          const lessonProgress = courseProgress[lesson.id];
          const isCompleted = lessonProgress?.completed || false;
          const isInProgress = lessonProgress?.started || false;
          const isLocked = !isCompleted && !canAccessLesson(index);
          const isActive = index === currentLessonIndex;

          // Apply status classes
          if (isCompleted) lessonItem.classList.add("completed");
          if (isLocked) lessonItem.classList.add("locked");
          if (isActive) lessonItem.classList.add("active");

          // Determine status display
          let statusClass = "not-started";
          let statusIcon = index + 1;

          if (isCompleted) {
            statusClass = "completed";
            statusIcon = "â";
          } else if (isInProgress) {
            statusClass = "in-progress";
            statusIcon = "â";
          }

          // Create lesson item HTML
          lessonItem.innerHTML = `
            <div class="lesson-status ${statusClass}">${statusIcon}</div>
            <div class="lesson-info">
                <div class="lesson-title">${lesson.title}</div>
                <div class="lesson-meta">
                    ${
                      isCompleted
                        ? "Completed"
                        : isInProgress
                        ? "In Progress"
                        : isLocked
                        ? "Locked"
                        : "Not Started"
                    }
                </div>
            </div>
            <div class="lesson-duration">${lesson.duration}</div>
        `;

          // Add click handler if not locked
          if (!isLocked) {
            lessonItem.addEventListener("click", () => {
              if (index !== currentLessonIndex) {
                // Track lesson time before switching
                trackLessonTime();

                currentLessonIndex = index;
                loadLesson(index);
                closeSidebar();
              }
            });
          }

          lessonNav.appendChild(lessonItem);
        });
      }

      function canAccessLesson(index) {
        if (index === 0) return true; // First lesson always accessible

        // Can access if previous lesson is completed
        const previousLessonId = COURSE_DATA.lessons[index - 1].id;
        return courseProgress[previousLessonId]?.completed || false;
      }

      function trackLessonTime() {
        const currentLesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonProgress = courseProgress[currentLesson.id];

        if (lessonProgress?.currentSessionStart) {
          const sessionTime = Math.floor(
            (new Date() - new Date(lessonProgress.currentSessionStart)) /
              1000 /
              60
          );
          lessonProgress.timeSpent =
            (lessonProgress.timeSpent || 0) + sessionTime;
          delete lessonProgress.currentSessionStart;
        }
      }

      // =====================================================
      // LESSON CONTENT RENDERING
      // =====================================================
      function renderLessonContent(lesson) {
        const contentContainer = document.getElementById("lessonContent");
        if (!contentContainer) return;

        let contentHTML = `
        <div class="content-section">
            <h2>Learning Objectives</h2>
            <ul>
                ${lesson.objectives.map((obj) => `<li>${obj}</li>`).join("")}
            </ul>
        </div>
        
        <div class="content-section">
            <h2>Overview</h2>
            <p>${lesson.content.overview}</p>
        </div>
    `;

        // Render content sections
        lesson.content.sections.forEach((section) => {
          contentHTML += `
            <div class="content-section">
                <h2>${section.title}</h2>
                ${section.content}
                ${
                  section.image
                    ? `<img src="${section.image}" alt="${section.title}" class="content-image" loading="lazy">`
                    : ""
                }
            </div>
        `;
        });

        // Render code examples
        if (
          lesson.content.codeExamples &&
          lesson.content.codeExamples.length > 0
        ) {
          contentHTML += `<div class="content-section"><h2>Code Examples</h2></div>`;

          lesson.content.codeExamples.forEach((example, index) => {
            const codeId = `code-${lesson.id}-${index}`;
            contentHTML += `
                <div class="code-section">
                    <div class="code-header">
                        <span class="code-title">${example.title}</span>
                        <button class="copy-btn" onclick="copyCode('${codeId}')">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <pre class="code-block"><code id="${codeId}" class="language-${
              example.language
            }">${escapeHtml(example.code)}</code></pre>
                </div>
            `;
          });
        }

        // Render quiz
        contentHTML += renderQuiz(lesson.quiz);

        contentContainer.innerHTML = contentHTML;

        // Highlight code syntax if Prism is available
        setTimeout(() => {
          if (window.Prism) {
            Prism.highlightAll();
          }
        }, 100);
      }

      // =====================================================
      // QUIZ SYSTEM
      // =====================================================
      function renderQuiz(quiz) {
        const currentLessonProgress =
          courseProgress[COURSE_DATA.lessons[currentLessonIndex].id];
        const isCompleted = currentLessonProgress?.completed || false;

        let quizHTML = `
        <div class="quiz-section" id="quizSection">
            <div class="quiz-header">
                <h2 class="quiz-title">
                    <i class="fas fa-clipboard-check"></i>
                    Knowledge Check
                </h2>
                <p class="quiz-info">
                    Complete this quiz with ${quiz.passingScore}% or higher to unlock the next lesson.
                </p>
            </div>
    `;

        if (isCompleted) {
          const savedScore = currentLessonProgress.quizScore || 0;
          quizHTML += `
            <div class="quiz-results show">
                <div class="quiz-score pass">${savedScore}%</div>
                <div class="quiz-message">
                    <strong>Lesson Completed!</strong><br>
                    You've successfully passed this lesson's quiz.
                </div>
            </div>
        `;
        } else {
          // Render quiz questions
          quiz.questions.forEach((question, qIndex) => {
            quizHTML += `
                <div class="quiz-question ${
                  qIndex === 0 ? "active" : ""
                }" data-question="${qIndex}">
                    <div class="question-header">
                        <span class="question-number">Question ${
                          qIndex + 1
                        }</span>
                        <span class="question-progress">${qIndex + 1}/${
              quiz.questions.length
            }</span>
                    </div>
                    <div class="question-text">${question.question}</div>
                    <div class="question-options">
                        ${question.options
                          .map(
                            (option, oIndex) => `
                            <div class="option" data-option="${oIndex}" onclick="selectOption(${qIndex}, ${oIndex})">
                                <span class="option-letter">${String.fromCharCode(
                                  65 + oIndex
                                )}</span>
                                <span class="option-text">${option}</span>
                            </div>
                        `
                          )
                          .join("")}
                    </div>
                </div>
            `;
          });

          quizHTML += `
            <div class="quiz-controls">
                <button class="btn btn-secondary" id="prevQuestionBtn" onclick="previousQuestion()" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <div>
                    <button class="btn btn-secondary" id="nextQuestionBtn" onclick="nextQuestion()" disabled>
                        Next
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <button class="btn btn-primary" id="submitQuizBtn" onclick="submitQuiz()" style="display: none;">
                        <i class="fas fa-check"></i>
                        Submit Quiz
                    </button>
                </div>
            </div>

            <div class="quiz-results" id="quizResults">
                <div class="quiz-score" id="quizScore">0%</div>
                <div class="quiz-message" id="quizMessage"></div>
                <div class="quiz-actions">
                    <button class="btn btn-primary" id="continueBtn" onclick="completeLesson()" style="display: none;">
                        <i class="fas fa-arrow-right"></i>
                        Continue to Next Lesson
                    </button>
                    <button class="btn btn-secondary" onclick="retakeQuiz()">
                        <i class="fas fa-redo"></i>
                        Retake Quiz
                    </button>
                </div>
            </div>
        `;
        }

        quizHTML += "</div>";
        return quizHTML;
      }

      // Quiz interaction functions
      function selectOption(questionIndex, optionIndex) {
        // Clear previous selections
        document
          .querySelectorAll(`[data-question="${questionIndex}"] .option`)
          .forEach((opt) => {
            opt.classList.remove("selected");
          });

        // Select current option
        const selectedOption = document.querySelector(
          `[data-question="${questionIndex}"] [data-option="${optionIndex}"]`
        );
        selectedOption.classList.add("selected");

        // Store answer
        quizState.answers[questionIndex] = optionIndex;

        // Update navigation
        const isLastQuestion =
          questionIndex ===
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length - 1;
        if (isLastQuestion) {
          document.getElementById("submitQuizBtn").style.display =
            "inline-flex";
          document.getElementById("nextQuestionBtn").style.display = "none";
        } else {
          document.getElementById("nextQuestionBtn").disabled = false;
        }
      }

      function nextQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const nextQuestionEl = currentQuestionEl.nextElementSibling;

        if (
          nextQuestionEl &&
          nextQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          nextQuestionEl.classList.add("active");
          quizState.currentQuestion++;
          updateQuizNavigation();
        }
      }

      function previousQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const prevQuestionEl = currentQuestionEl.previousElementSibling;

        if (
          prevQuestionEl &&
          prevQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          prevQuestionEl.classList.add("active");
          quizState.currentQuestion--;
          updateQuizNavigation();
        }
      }

      function updateQuizNavigation() {
        const totalQuestions =
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length;
        const prevBtn = document.getElementById("prevQuestionBtn");
        const nextBtn = document.getElementById("nextQuestionBtn");
        const submitBtn = document.getElementById("submitQuizBtn");

        prevBtn.disabled = quizState.currentQuestion === 0;

        const hasAnswer =
          quizState.answers[quizState.currentQuestion] !== undefined;
        const isLastQuestion = quizState.currentQuestion === totalQuestions - 1;

        if (isLastQuestion) {
          nextBtn.style.display = "none";
          submitBtn.style.display = hasAnswer ? "inline-flex" : "none";
        } else {
          nextBtn.style.display = "inline-flex";
          nextBtn.disabled = !hasAnswer;
          submitBtn.style.display = "none";
        }
      }

      async function submitQuiz() {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const quiz = lesson.quiz;
        let correctAnswers = 0;

        // Hide questions and controls
        document
          .querySelectorAll(".quiz-question")
          .forEach((q) => (q.style.display = "none"));
        document.querySelector(".quiz-controls").style.display = "none";

        // Calculate score and highlight answers
        quiz.questions.forEach((question, index) => {
          const userAnswer = quizState.answers[index];
          const correctAnswer = question.correct;
          const isCorrect = userAnswer === correctAnswer;

          if (isCorrect) correctAnswers++;

          // Highlight answers
          const questionEl = document.querySelector(
            `[data-question="${index}"]`
          );
          const options = questionEl.querySelectorAll(".option");

          options[correctAnswer].classList.add("correct");
          if (userAnswer !== correctAnswer && userAnswer !== undefined) {
            options[userAnswer].classList.add("incorrect");
          }
        });

        const score = Math.round(
          (correctAnswers / quiz.questions.length) * 100
        );
        const passed = score >= quiz.passingScore;

        // Update quiz results UI
        const quizScore = document.getElementById("quizScore");
        const quizMessage = document.getElementById("quizMessage");
        const quizActions = document.querySelector(".quiz-actions");

        quizScore.textContent = `${score}%`;
        quizScore.className = `quiz-score ${passed ? "pass" : "fail"}`;

        if (passed) {
          quizMessage.innerHTML = `
            <strong>Congratulations!</strong><br>
            You passed with ${score}%. You can now proceed to the next lesson.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-primary" onclick="completeLesson()">
                <i class="fas fa-arrow-right"></i>
                Continue to Next Lesson
            </button>
        `;

          // Mark lesson as completed
          await markLessonComplete(score);
        } else {
          quizMessage.innerHTML = `
            <strong>Not quite there yet.</strong><br>
            You scored ${score}%. You need ${quiz.passingScore}% to pass. Review the material and try again.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-secondary" onclick="retakeQuiz()">
                <i class="fas fa-redo"></i>
                Retake Quiz
            </button>
        `;
        }

        document.getElementById("quizResults").classList.add("show");

        // Log quiz completion
        logUserActivity("quiz_completed", {
          lesson_id: lesson.id,
          lesson_title: lesson.title,
          score: score,
          passed: passed,
          attempts: (courseProgress[lesson.id]?.quizAttempts || 0) + 1,
        });

        // Scroll to results
        document
          .getElementById("quizResults")
          .scrollIntoView({ behavior: "smooth" });
      }

      function retakeQuiz() {
        // Reset quiz state
        quizState = {
          currentQuestion: 0,
          answers: [],
          score: 0,
          isComplete: false,
        };

        // Track quiz retry
        const lessonId = COURSE_DATA.lessons[currentLessonIndex].id;
        if (!courseProgress[lessonId]) courseProgress[lessonId] = {};
        courseProgress[lessonId].quizAttempts =
          (courseProgress[lessonId].quizAttempts || 0) + 1;

        // Reload lesson content
        loadLesson(currentLessonIndex);

        // Scroll to quiz
        setTimeout(() => {
          document
            .getElementById("quizSection")
            .scrollIntoView({ behavior: "smooth" });
        }, 500);
      }

      async function markLessonComplete(score) {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonId = lesson.id;

        // Track lesson completion time
        trackLessonTime();

        // Update lesson progress
        courseProgress[lessonId] = {
          ...courseProgress[lessonId],
          completed: true,
          quizScore: score,
          completedAt: new Date().toISOString(),
          finalScore: score,
        };

        // Update session tracking
        courseSession.lessonsCompleted++;

        // Save progress to database
        await saveProgress();

        // Update UI
        renderSidebar();
        updateNavigationButtons();

        // Check various achievements
        await checkLessonCompletionAchievements();
        await checkPerfectScoreAchievements(score);
        await checkStudyTimeAchievements();

        // Log lesson completion
        logUserActivity("lesson_completed", {
          lesson_id: lessonId,
          lesson_title: lesson.title,
          final_score: score,
          time_spent: courseProgress[lessonId].timeSpent || 0,
          lesson_number: currentLessonIndex + 1,
        });

        showToast("Lesson completed successfully!", "success");
      }

      async function completeLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          // Move to next lesson
          currentLessonIndex++;
          loadLesson(currentLessonIndex);
        } else {
          // Course completion
          await completeCourse();
        }
      }

      async function completeCourse() {
        try {
          const completionTime = courseSession.totalStudyTime;

          // Update course progress to 100% completed
          await supabase
            .from("course_progress")
            .update({
              progress: 100,
              completed_at: new Date().toISOString(),
              completion_time_minutes: completionTime,
            })
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Award course completion achievements
          await checkAndUnlockAchievement("course_completion_1");
          await checkSpeedCompletionAchievements(completionTime);
          await checkCourseStreakAchievements();

          // Update user stats
          await updateUserStats();

          // Show completion message
          showToast(
            "Congratulations! Course completed successfully!",
            "certificate"
          );

          // Log course completion
          logUserActivity("course_completed", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            completion_time_minutes: completionTime,
            total_lessons: COURSE_DATA.lessons.length,
            average_quiz_score: calculateAverageQuizScore(),
          });

          // Redirect to dashboard after delay
          setTimeout(() => {
            window.location.href = "/dashboard.html";
          }, 3000);
        } catch (error) {
          console.error("Error completing course:", error);
          showToast("Error marking course as complete", "error");
        }
      }

      // =====================================================
      // ACHIEVEMENT INTEGRATION SYSTEM
      // =====================================================
      async function checkAndUnlockAchievement(
        achievementId,
        skipNotification = false
      ) {
        try {
          // Prevent duplicate checks
          const cacheKey = `achievement_${achievementId}_${currentUser.id}`;
          if (sessionStorage.getItem(cacheKey)) return false;

          // Check if already unlocked
          const { data: existing, error } = await supabase
            .from("user_achievements")
            .select("id")
            .eq("user_id", currentUser.id)
            .eq("achievement_id", achievementId)
            .single();

          if (existing) {
            sessionStorage.setItem(cacheKey, "true");
            return false;
          }

          // Award achievement
          const achievementData = {
            user_id: currentUser.id,
            achievement_id: achievementId,
            unlocked_at: new Date().toISOString(),
            points_awarded: getAchievementPoints(achievementId),
            context: "course_system",
          };

          const { data, error: insertError } = await supabase
            .from("user_achievements")
            .insert([achievementData])
            .select()
            .single();

          if (insertError) {
            if (insertError.code === "23505") return false; // Already exists
            throw insertError;
          }

          // Update user points
 await supabase.rpc('increment_user_stats', {
  user_id_param: currentUser.id,
  points_to_add: achievementData.points_awarded,
  achievements_to_add: 1
});

          // Cache and queue notification
          sessionStorage.setItem(cacheKey, "true");

          if (!skipNotification) {
            queueAchievementNotification({
              id: achievementId,
              name: getAchievementName(achievementId),
              description: getAchievementDescription(achievementId),
              points: achievementData.points_awarded,
              rarity: getAchievementRarity(achievementId),
              icon: getAchievementIcon(achievementId),
            });
          }

          return true;
        } catch (error) {
          console.error("Error unlocking achievement:", error);
          return false;
        }
      }

      // Helper functions for achievement data (replace with your actual achievement definitions)
      function getAchievementPoints(id) {
        const pointsMap = {
          first_course_start: 75,
          first_lesson: 100,
          course_completion_1: 500,
          perfect_score: 250,
          speed_demon: 750,
          marathon_learner: 500,
          night_owl: 200,
          early_bird: 200,
          weekend_warrior: 150,
          // Add more as needed
        };
        return pointsMap[id] || 100;
      }

      function getAchievementName(id) {
        const nameMap = {
          first_course_start: "Learning Initiated",
          first_lesson: "First Steps",
          course_completion_1: "Course Conqueror",
          perfect_score: "Perfectionist",
          speed_demon: "Speed Demon",
          // Add more as needed
        };
        return nameMap[id] || "Achievement Unlocked";
      }

      function getAchievementDescription(id) {
        const descMap = {
          first_course_start: "Start your first cybersecurity course",
          first_lesson: "Complete your first lesson",
          course_completion_1: "Complete your first course",
          perfect_score: "Score 100% on any quiz",
          speed_demon: "Complete a course in under 2 hours",
          // Add more as needed
        };
        return descMap[id] || "Achievement description";
      }

      function getAchievementRarity(id) {
        const rarityMap = {
          first_course_start: "common",
          first_lesson: "bronze",
          course_completion_1: "silver",
          perfect_score: "gold",
          speed_demon: "legendary",
          // Add more as needed
        };
        return rarityMap[id] || "common";
      }

      function getAchievementIcon(id) {
        const iconMap = {
          first_course_start: "fas fa-play",
          first_lesson: "fas fa-baby",
          course_completion_1: "fas fa-trophy",
          perfect_score: "fas fa-star",
          speed_demon: "fas fa-rocket",
          // Add more as needed
        };
        return iconMap[id] || "fas fa-award";
      }

      async function checkLessonAchievements(lessonNumber) {
        if (lessonNumber === 1) {
          await checkAndUnlockAchievement("first_lesson");
        }

        // Check if user has completed multiple lessons in one day
        const today = new Date().toISOString().split("T")[0];
        const todayCompletions = Object.values(courseProgress).filter(
          (p) => p.completed && p.completedAt?.startsWith(today)
        ).length;

        if (todayCompletions >= 3) {
          await checkAndUnlockAchievement("lesson_marathon");
        }
      }

      async function checkLessonCompletionAchievements() {
        const completedCount = getCompletedLessonsCount();

        // Lesson-based achievements
        const lessonMilestones = [1, 5, 10, 25, 50, 100];
        for (const milestone of lessonMilestones) {
          if (completedCount >= milestone) {
            await checkAndUnlockAchievement(`lessons_${milestone}`);
          }
        }

        // Course completion achievements
        if (completedCount === COURSE_DATA.lessons.length) {
          await checkAndUnlockAchievement("course_completion_1");

          // Check for additional course completion achievements
          const { data: allCourses } = await supabase
            .from("course_progress")
            .select("course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100);

          const totalCompleted = allCourses?.length || 0;

          const courseMilestones = [1, 5, 10, 25];
          for (const milestone of courseMilestones) {
            if (totalCompleted >= milestone) {
              await checkAndUnlockAchievement(`course_completion_${milestone}`);
            }
          }
        }
      }

      async function checkPerfectScoreAchievements(score) {
        if (score === 100) {
          await checkAndUnlockAchievement("perfect_score");

          // Check for consecutive perfect scores
          const recentScores = Object.values(courseProgress)
            .filter((p) => p.completed && p.quizScore)
            .slice(-5) // Last 5 completed
            .map((p) => p.quizScore);

          if (
            recentScores.length >= 3 &&
            recentScores.every((s) => s === 100)
          ) {
            await checkAndUnlockAchievement("perfectionist_streak");
          }
        }
      }

      async function checkSpeedCompletionAchievements(completionTime) {
        // Speed demon: Complete course in under 2 hours (120 minutes)
        if (completionTime <= 120) {
          await checkAndUnlockAchievement("speed_demon");
        }

        // Quick learner: Complete course in under 4 hours (240 minutes)
        if (completionTime <= 240) {
          await checkAndUnlockAchievement("quick_learner");
        }
      }

      async function checkStudyTimeAchievements() {
        const totalTime = courseSession.totalStudyTime;

        // Marathon learner: Study for 8+ hours in a course session
        if (totalTime >= 480) {
          // 8 hours
          await checkAndUnlockAchievement("marathon_learner");
        }

        // Dedicated learner: Study for 4+ hours
        if (totalTime >= 240) {
          // 4 hours
          await checkAndUnlockAchievement("dedicated_learner");
        }
      }

      async function checkCourseStreakAchievements() {
        try {
          // Check for consecutive course completions
          const { data: recentCourses, error } = await supabase
            .from("course_progress")
            .select("completed_at, course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100)
            .order("completed_at", { ascending: false })
            .limit(10);

          if (error || !recentCourses) return;

          // Check for courses completed on consecutive days
          let consecutiveDays = 1;
          for (let i = 1; i < recentCourses.length; i++) {
            const prevDate = new Date(
              recentCourses[i - 1].completed_at
            ).toDateString();
            const currentDate = new Date(
              recentCourses[i].completed_at
            ).toDateString();
            const dayDiff =
              Math.abs(new Date(prevDate) - new Date(currentDate)) /
              (1000 * 60 * 60 * 24);

            if (dayDiff <= 1) {
              consecutiveDays++;
            } else {
              break;
            }
          }

          if (consecutiveDays >= 3) {
            await checkAndUnlockAchievement("learning_streak");
          }
        } catch (error) {
          console.error("Error checking course streak achievements:", error);
        }
      }

      // =====================================================
      // TIME-BASED ACHIEVEMENTS
      // =====================================================
      async function checkTimeBasedAchievements(timestamp) {
        const hour = timestamp.getHours();
        const dayOfWeek = timestamp.getDay();

        // Night owl (after midnight, before 6 AM)
        if (hour >= 0 && hour < 6) {
          await incrementTimeBasedCounter("midnight_sessions", "night_owl");
        }

        // Early bird (4 AM to 6 AM)
        if (hour >= 4 && hour < 6) {
          await incrementTimeBasedCounter("early_sessions", "early_bird");
        }

        // Weekend warrior (Saturday = 6, Sunday = 0)
        if (dayOfWeek === 0 || dayOfWeek === 6) {
          await incrementTimeBasedCounter(
            "weekend_sessions",
            "weekend_warrior"
          );
        }
      }

      async function incrementTimeBasedCounter(counterType, achievementId) {
        try {
          const dateStr = new Date().toISOString().split("T")[0];
          const cacheKey = `${counterType}_${currentUser.id}_${dateStr}`;

          // Prevent multiple increments per day
          if (sessionStorage.getItem(cacheKey)) return;

          // Update counter
         await supabase.rpc('increment_profile_counter', {
  user_id_param: currentUser.id,
  counter_field: counterType,
  increment_value: 1
});

          // Cache to prevent double counting
          sessionStorage.setItem(cacheKey, "true");

          // Check related achievement
          if (achievementId) {
            await checkAndUnlockAchievement(achievementId, true);
          }
        } catch (error) {
          console.error(`Error incrementing ${counterType}:`, error);
        }
      }

      async function checkDailyStreak() {
        try {
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("last_activity, current_streak, last_streak_date")
            .eq("id", currentUser.id)
            .single();

          if (error) throw error;

          const now = new Date();
          const today = now.toDateString();
          const lastActivity = profile.last_activity
            ? new Date(profile.last_activity)
            : null;
          const lastStreakDate = profile.last_streak_date
            ? new Date(profile.last_streak_date).toDateString()
            : null;

          let newStreak = profile.current_streak || 0;
          let shouldUpdateStreak = false;

          if (!lastActivity) {
            // First time user
            newStreak = 1;
            shouldUpdateStreak = true;
          } else {
            const daysSinceLastActivity = Math.floor(
              (now - lastActivity) / (1000 * 60 * 60 * 24)
            );

            if (lastStreakDate === today) {
              // Already counted today's streak
              return newStreak;
            } else if (
              daysSinceLastActivity === 1 ||
              (daysSinceLastActivity === 0 && lastStreakDate !== today)
            ) {
              // Consecutive day or same day but not counted yet
              newStreak += 1;
              shouldUpdateStreak = true;
            } else if (daysSinceLastActivity > 1) {
              // Streak broken
              newStreak = 1;
              shouldUpdateStreak = true;
            }
          }

          if (shouldUpdateStreak) {
            await supabase
              .from("profiles")
              .update({
                current_streak: newStreak,
                last_activity: now.toISOString(),
                last_streak_date: now.toISOString(),
              })
              .eq("id", currentUser.id);

            userStats.current_streak = newStreak;

            showToast(`Daily streak: ${newStreak} days!`, "success");
            await checkStreakAchievements(newStreak);
          }

          return newStreak;
        } catch (error) {
          console.error("Error checking daily streak:", error);
          return 0;
        }
      }

      async function checkStreakAchievements(currentStreak) {
        const streakMilestones = [3, 7, 14, 30, 100, 365];

        for (const milestone of streakMilestones) {
          if (currentStreak >= milestone) {
            await checkAndUnlockAchievement(`streak_${milestone}`);
          }
        }
      }

      // =====================================================
      // USER ACTIVITY LOGGING
      // =====================================================
      async function logUserActivity(activityType, metadata = {}) {
        try {
          const now = new Date();

          const activityData = {
            user_id: currentUser.id,
            activity_type: activityType,
            timestamp: now.toISOString(),
            course_id: COURSE_DATA.id,
            lesson_index: currentLessonIndex,
            session_duration: courseSession.totalStudyTime,
            metadata: JSON.stringify(metadata),
            created_at: now.toISOString(),
          };

          // Try to log to activities table
          const { error } = await supabase
            .from("user_activities")
            .insert([activityData]);

          if (error && error.code !== "42P01") {
            console.warn("Activity logging failed:", error.message);
          }

          // Always update last activity in profile
          await supabase
            .from("profiles")
            .update({ last_activity: now.toISOString() })
            .eq("id", currentUser.id);
        } catch (error) {
          console.error("Error logging user activity:", error);
        }
      }

      // =====================================================
      // NAVIGATION SYSTEM
      // =====================================================
      function updateNavigationButtons() {
        const prevBtn = document.getElementById("prevLessonBtn");
        const nextBtn = document.getElementById("nextLessonBtn");

        if (!prevBtn || !nextBtn) return;

        // Previous button
        prevBtn.disabled = currentLessonIndex === 0;

        // Next button logic
        const isLastLesson =
          currentLessonIndex === COURSE_DATA.lessons.length - 1;
        const canGoNext =
          currentLessonIndex < COURSE_DATA.lessons.length - 1 &&
          canAccessLesson(currentLessonIndex + 1);

        if (isLastLesson) {
          const isCurrentCompleted =
            courseProgress[COURSE_DATA.lessons[currentLessonIndex].id]
              ?.completed;
          nextBtn.disabled = !isCurrentCompleted;
          nextBtn.innerHTML = '<i class="fas fa-trophy"></i> Complete Course';
        } else {
          nextBtn.disabled = !canGoNext;
          nextBtn.innerHTML = 'Next <i class="fas fa-chevron-right"></i>';
        }
      }

      // Navigation button event handlers
      function goToPreviousLesson() {
        if (currentLessonIndex > 0) {
          trackLessonTime(); // Track time spent on current lesson
          currentLessonIndex--;
          loadLesson(currentLessonIndex);
        }
      }

      function goToNextLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          const canGoNext = canAccessLesson(currentLessonIndex + 1);
          if (canGoNext) {
            trackLessonTime();
            currentLessonIndex++;
            loadLesson(currentLessonIndex);
          } else {
            showToast("Complete the current lesson quiz to proceed", "warning");
          }
        } else {
          // Complete course
          completeCourse();
        }
      }

      // =====================================================
      // SIDEBAR FUNCTIONS
      // =====================================================
      function toggleSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.toggle("open");
        if (overlay) overlay.classList.toggle("active");
      }

      function closeSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.remove("open");
        if (overlay) overlay.classList.remove("active");
      }

      // =====================================================
      // ACHIEVEMENT NOTIFICATION SYSTEM
      // =====================================================
      function queueAchievementNotification(achievement) {
        notificationQueue.push(achievement);
        processNotificationQueue();
      }

      function processNotificationQueue() {
        if (isShowingNotification || notificationQueue.length === 0) return;

        isShowingNotification = true;
        const achievement = notificationQueue.shift();
        showAchievementNotification(achievement);

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          isShowingNotification = false;
          processNotificationQueue();
        }, duration + 500);
      }

      function showAchievementNotification(achievement) {
        const notification = document.getElementById("achievementNotification");
        if (!notification) return;

        const icon = document.getElementById("notificationIcon");
        const title = document.getElementById("notificationTitle");
        const description = document.getElementById("notificationDescription");
        const points = document.getElementById("notificationPoints");

        if (icon) {
          icon.innerHTML = `<i class="${achievement.icon}"></i>`;
          icon.className = `notification-icon ${achievement.rarity}`;
        }
        if (title) title.textContent = achievement.name;
        if (description) description.textContent = achievement.description;
        if (points) points.textContent = `+${achievement.points} Points`;

        notification.className = `achievement-notification ${achievement.rarity}`;
        notification.classList.add("show");

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          notification.classList.remove("show");
        }, duration);
      }

      // =====================================================
      // UTILITY FUNCTIONS
      // =====================================================
      function calculateAverageQuizScore() {
        const scores = Object.values(courseProgress)
          .filter((p) => p.completed && p.quizScore)
          .map((p) => p.quizScore);

        if (scores.length === 0) return 0;
        return Math.round(
          scores.reduce((sum, score) => sum + score, 0) / scores.length
        );
      }

      async function resetProgress() {
        if (
          !confirm(
            "Are you sure you want to reset your progress? This action cannot be undone."
          )
        ) {
          return;
        }

        try {
          // Track lesson time before reset
          trackLessonTime();

          // Reset local state
          courseProgress = {};
          currentLessonIndex = 0;
          courseSession = {
            startTime: new Date(),
            totalStudyTime: 0,
            lessonsStarted: 0,
            lessonsCompleted: 0,
            pageLoadTime: new Date(),
            interactionCount: 0,
            lastActivityTime: new Date(),
          };

          // Delete from database
          await supabase
            .from("course_progress")
            .delete()
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Log reset activity
          logUserActivity("progress_reset", {
            course_id: COURSE_DATA.id,
            reset_reason: "manual",
          });

          // Reinitialize
          await saveProgress();
          renderSidebar();
          loadLesson(0);

          showToast("Progress reset successfully", "success");
        } catch (error) {
          console.error("Error resetting progress:", error);
          showToast("Failed to reset progress", "error");
        }
      }

      function copyCode(codeId) {
        const codeElement = document.getElementById(codeId);
        if (!codeElement) return;

        const text = codeElement.textContent;

        navigator.clipboard
          .writeText(text)
          .then(() => {
            showToast("Code copied to clipboard!", "success");

            // Track code copy for achievements
            logUserActivity("code_copied", {
              code_section: codeId,
              lesson_id: COURSE_DATA.lessons[currentLessonIndex].id,
            });
          })
          .catch((err) => {
            console.error("Failed to copy code:", err);
            showToast("Failed to copy code", "error");

            // Fallback for older browsers
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            try {
              document.execCommand("copy");
              showToast("Code copied to clipboard!", "success");
            } catch (fallbackError) {
              showToast(
                "Copy failed - please select and copy manually",
                "error"
              );
            }
            document.body.removeChild(textArea);
          });
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // =====================================================
      // UI FEEDBACK SYSTEMS
      // =====================================================
      function showToast(message, type = "success") {
        const toast = document.getElementById("toast");
        const messageEl = document.getElementById("toastMessage");

        if (!toast || !messageEl) {
          console.log(`Toast: ${message} (${type})`);
          return;
        }

        messageEl.textContent = message;
        toast.className = `toast ${type} show`;

        setTimeout(() => {
          toast.classList.remove("show");
        }, 4000);
      }

      function showLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) loadingScreen.classList.remove("hidden");
      }

      function hideLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) {
          setTimeout(() => {
            loadingScreen.classList.add("hidden");
          }, 1000);
        }
      }

      // =====================================================
      // MUSIC PLAYER INTEGRATION
      // =====================================================
      function initMusicPlayer() {
        const btnText = document.getElementById("music-button-text");
        const icon = document.getElementById("music-icon");
        const dropdown = document.getElementById("music-dropdown-content");

        if (!btnText || !icon || !dropdown) return;

        function setUI(state) {
          btnText.textContent =
            state === "Playing" ? "PAUSE MUSIC" : "STUDY MUSIC";
          icon.className =
            state === "Playing"
              ? "fa-solid fa-circle-pause"
              : "fa-solid fa-music";
        }

        // Load saved music state
        const savedSrc = localStorage.getItem("cybersec_music_src");
        const savedTime = parseFloat(
          localStorage.getItem("cybersec_music_time") || 0
        );

        if (savedSrc) {
          audioPlayer.src = savedSrc;
          audioPlayer.currentTime = savedTime;
          audioPlayer
            .play()
            .then(() => setUI("Playing"))
            .catch(() => setUI("Stopped"));
        }

        // Music button click handler
        document
          .getElementById("music-dropdown")
          .querySelector("button")
          .addEventListener("click", (e) => {
            e.stopPropagation();
            dropdown.style.display =
              dropdown.style.display === "block" ? "none" : "block";

            if (audioPlayer.src && !audioPlayer.paused) {
              audioPlayer.pause();
              setUI("Stopped");
            } else if (audioPlayer.src) {
              audioPlayer.play().then(() => setUI("Playing"));
            }
          });

        // Music selection handlers
        dropdown.querySelectorAll("a[data-src]").forEach((link) => {
          link.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.src = link.dataset.src;
            audioPlayer.play().then(() => setUI("Playing"));
            localStorage.setItem("cybersec_music_src", link.dataset.src);
            dropdown.style.display = "none";
          });
        });

        // Stop music handler
        const stopLink = document.getElementById("stop-music-link");
        if (stopLink) {
          stopLink.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            audioPlayer.removeAttribute("src");
            setUI("Stopped");
            localStorage.removeItem("cybersec_music_src");
            localStorage.removeItem("cybersec_music_time");
            dropdown.style.display = "none";
          });
        }

        // Save music state before page unload
        window.addEventListener("beforeunload", () => {
          if (!audioPlayer.paused && audioPlayer.src) {
            localStorage.setItem("cybersec_music_src", audioPlayer.src);
            localStorage.setItem(
              "cybersec_music_time",
              audioPlayer.currentTime
            );
          }
        });

        // Close dropdown when clicking outside
        window.addEventListener("click", (e) => {
          if (!e.target.closest("#music-dropdown")) {
            dropdown.style.display = "none";
          }
        });
      }

      // Show initial music indicator
      function addMusicIndicator() {
        const musicBtn = document.querySelector("#music-dropdown");
        if (musicBtn) {
          const indicator = document.createElement("div");
          indicator.className = "music-indicator";
          indicator.innerHTML = `<i class="fa-solid fa-music"></i> Try Study Music!`;

          musicBtn.style.position = "relative";
          musicBtn.appendChild(indicator);

          setTimeout(() => indicator.remove(), 3000);
        }
      }

      // Initialize Event Listeners
      function initializeEventListeners() {
        // Navigation buttons
        document
          .getElementById("prevLessonBtn")
          ?.addEventListener("click", goToPreviousLesson);
        document
          .getElementById("nextLessonBtn")
          ?.addEventListener("click", goToNextLesson);

        // Reset progress button
        document
          .getElementById("resetProgressBtn")
          ?.addEventListener("click", resetProgress);

        // Mobile menu toggle
        document
          .getElementById("menuToggle")
          ?.addEventListener("click", toggleSidebar);
        document
          .getElementById("sidebarOverlay")
          ?.addEventListener("click", closeSidebar);

        // Keyboard shortcuts
        document.addEventListener("keydown", handleKeyboardShortcuts);

        // Window resize handler
        window.addEventListener("resize", handleWindowResize);

        // Content interaction tracking
        document.getElementById("contentBody")?.addEventListener(
          "scroll",
          debounce(() => {
            trackUserInteraction();
          }, 1000)
        );
      }

      // Keyboard Shortcuts
      function handleKeyboardShortcuts(e) {
        if (document.querySelector(".quiz-question.active")) return;

        if (e.key === "ArrowLeft" && e.ctrlKey) {
          e.preventDefault();
          goToPreviousLesson();
        } else if (e.key === "ArrowRight" && e.ctrlKey) {
          e.preventDefault();
          goToNextLesson();
        }
      }

      // Window Resize Handler
      function handleWindowResize() {
        if (window.innerWidth > 768) {
          closeSidebar();
        }
      }

      // Debounce Helper
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Initialize responsive behavior
      if (window.innerWidth <= 768) {
        document.getElementById("menuToggle").style.display = "inline-flex";
      }

      // Auto-save progress periodically
      setInterval(async () => {
        if (currentUser && Object.keys(courseProgress).length > 0) {
          await saveProgress();
        }
      }, 60000); // Save every minute

      // System initialization logging
      console.log("CyberSec Academy Course System Initialized");
      console.log("Current Course:", COURSE_DATA.title);
      console.log("Total Lessons:", COURSE_DATA.lessons.length);

      // Google OAuth Integration
      const googleBtn = document.querySelector(".btn-google");
      if (googleBtn) {
        googleBtn.addEventListener("click", async () => {
          const { data, error } = await supabase.auth.signInWithOAuth({
            provider: "google",
            options: {
              redirectTo:
                window.location.origin +
                "/courses/advanced-threat-hunting-course.html",
            },
          });

          if (error) {
            console.error("Google login error:", error.message);
            showToast("Google login failed: " + error.message, "error");
          }
        });
      }

      // Check for existing session
      supabase.auth.getSession().then(({ data }) => {
        if (data.session) {
          console.log("User already logged in:", data.session.user);
          currentUser = data.session.user;
          startCourseSession();
        }
      });

      // Add missing auth modal functions
      function openAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "flex";
        }
      }

      function closeAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Add auth tab switching functionality
      document.getElementById("tabSignIn")?.addEventListener("click", () => {
        document.getElementById("tabSignIn").classList.add("active");
        document.getElementById("tabSignUp").classList.remove("active");
        document.getElementById("signInForm").style.display = "block";
        document.getElementById("signUpForm").style.display = "none";
      });

      document.getElementById("tabSignUp")?.addEventListener("click", () => {
        document.getElementById("tabSignUp").classList.add("active");
        document.getElementById("tabSignIn").classList.remove("active");
        document.getElementById("signUpForm").style.display = "block";
        document.getElementById("signInForm").style.display = "none";
      });

      document
        .getElementById("closeAuthModal")
        ?.addEventListener("click", closeAuthModal);

      // Improved error handling for auth session
      supabase.auth.onAuthStateChange((event, session) => {
        if (event === "SIGNED_IN") {
          currentUser = session.user;
          closeAuthModal();
          startCourseSession();
        } else if (event === "SIGNED_OUT") {
          currentUser = null;
          openAuthModal();
        }
      });

      // Add form submission handlers
      document
        .getElementById("emailSignInForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signInEmail").value;
          const password = document.getElementById("signInPassword").value;

          try {
            const { data, error } = await supabase.auth.signInWithPassword({
              email,
              password,
            });

            if (error) throw error;

            closeAuthModal();
          } catch (error) {
            showToast(error.message, "error");
          }
        });

      document
        .getElementById("emailSignUpForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signUpEmail").value;
          const password = document.getElementById("signUpPassword").value;
          const name = document.getElementById("signUpName").value;

          try {
            const { data, error } = await supabase.auth.signUp({
              email,
              password,
              options: {
                data: {
                  full_name: name,
                },
              },
            });

            if (error) throw error;

            showToast(
              "Account created successfully! Please check your email.",
              "success"
            );
          } catch (error) {
            showToast(error.message, "error");
          }
        });
    </script>
  </body>
</html>

