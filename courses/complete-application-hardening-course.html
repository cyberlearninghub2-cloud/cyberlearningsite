



<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- ========== Start: SEO & Schema Enhancement ========== -->
    <title>Complete Application Hardening Course | CipherHall</title>
    <meta name="description" content="A 31-lesson masterclass on application hardening. Learn OS hardening, network security, memory protection, DevSecOps, and Zero Trust with hands-on labs.">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png" />
    <link rel="shortcut icon" href="/favicon.png" type="image/x-icon" />
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png" />
    <link rel="canonical" href="https://www.cipherhall.com/courses/complete-application-hardening-course.html" />
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Course",
      "name": "Complete Application Hardening Course",
      "description": "A practical, hands-on course for developers, system administrators, and security professionals on how to systematically reduce the attack surface of applications and their underlying infrastructure.",
      "provider": {
        "@type": "Organization",
        "name": "CipherHall",
        "sameAs": "https://www.cipherhall.com"
      },
      "hasCourseInstance": {
        "@type": "CourseInstance",
        "courseMode": "Online",
        "instructor": {
          "@type": "Person",
          "name": "Dr. David Chen"
        }
      }cyber
    }
    </script>
    <!-- ========== End: SEO & Schema Enhancement ========== -->

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Exo+2:wght@700;800;900&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css"
    />
    <link rel="stylesheet" href="assets/css/coursepages.css">
</head>
  <body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
      <div class="loader-icon">
        <i class="fas fa-graduation-cap"></i>
      </div>
      <div class="loader-text">Loading Course Content...</div>
    </div>

    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- Music Player (fixed at top right) -->
    <div class="header-controls">
      <div class="music-dropdown" id="music-dropdown">
        <button class="btn btn-secondary">
          <span id="music-button-text">STUDY MUSIC</span>
          <i id="music-icon" class="fa-solid fa-music"></i>
        </button>
        <div class="music-dropdown-content" id="music-dropdown-content">
          <a
            href="#"
            data-src="https://www.learningcontainer.com/wp-content/uploads/2020/02/Kalimba.mp3"
            >1. Coffee Shop Vibes</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3"
            >2. City Lights Lofi</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-15.mp3"
            >3. Mellow Thoughts</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-13.mp3"
            >4. Rainy Mood</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3"
            >5. Time Alone</a
          >
          <a href="#" id="stop-music-link"
            ><i class="fa-solid fa-stop-circle"></i> Stop Music</a
          >
        </div>
      </div>

      <button class="btn btn-secondary" id="resetProgressBtn">
        <i class="fas fa-redo"></i>
        Reset Progress
      </button>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal" style="display: none">
      <div class="modal-overlay"></div>
      <div class="modal-content">
        <span class="close" id="closeAuthModal">&times;</span>
        <div class="auth-tabs">
          <button id="tabSignIn" class="auth-tab active">Sign In</button>
          <button id="tabSignUp" class="auth-tab">Sign Up</button>
        </div>
        <div
          id="authLoader"
          style="display: none; text-align: center; padding: 2rem"
        >
          <i
            class="fas fa-spinner fa-spin fa-2x"
            style="color: var(--color-green)"
          ></i>
          <p style="margin-top: 0.5rem">Authenticating...</p>
        </div>
        <div id="signInForm" class="auth-form">
          <h2>Sign In to CipherHall</h2>
          <button id="googleSignIn" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignInForm">
            <input
              type="email"
              id="signInEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signInPassword"
              placeholder="Password"
              required
            />
            <button type="submit" class="btn btn-primary">Sign In</button>
          </form>
        </div>
        <div id="signUpForm" class="auth-form" style="display: none">
          <h2>Join ipherHall</h2>
          <button id="googleSignUp" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignUpForm">
            <input
              type="text"
              id="signUpName"
              placeholder="Full Name"
              required
            />
            <input
              type="email"
              id="signUpEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signUpPassword"
              placeholder="Password (min. 8 characters)"
              required
            />
            <button type="submit" class="btn btn-secondary">
              Create Account
            </button>
          </form>
        </div>
        <div id="authMessage"></div>
      </div>
    </div>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="course-info">
          <h1 class="course-title" id="courseTitle">Loading...</h1>
          <div class="course-progress">
            <div class="progress-header">
              <span class="progress-label">Course Progress</span>
              <span class="progress-percentage" id="courseProgressPercent"
                >0%</span
              >
            </div>
            <div class="progress-bar">
              <div
                class="progress-fill"
                id="courseProgressFill"
                style="width: 0%"
              ></div>
            </div>
            <div class="progress-stats">
              <span id="completedLessons">0</span>
              <span id="totalLessons">0</span>
            </div>
          </div>
          <a href="/dashboard.html" class="back-to-dashboard">
            <i class="fas fa-arrow-left"></i>
            Back to Dashboard
          </a>
        </div>
      </div>

      <nav class="lesson-nav" id="lessonNav">
        <!-- Lessons will be loaded dynamically -->
      </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <header class="content-header">
        <div class="lesson-header">
          <div class="lesson-header-left">
            <span class="lesson-number" id="currentLessonNumber">1</span>
            <h1 class="lesson-header-title" id="currentLessonTitle">
              Loading...
            </h1>
          </div>
          <div class="lesson-actions">
            <button class="mbtn btn-primary" id="menuToggle">
              <i class="fas fa-bars"></i>
            </button>
          </div>
        </div>
      </header>

      <div class="content-body" id="contentBody">
        <div class="lesson-content" id="lessonContent">
          <!-- Lesson content will be loaded dynamically -->
        </div>
      </div>

      <footer class="lesson-navigation">
        <div class="nav-info" id="navInfo">Lesson 1 of 10</div>
        <div class="nav-controls">
          <button class="btn btn-secondary" id="prevLessonBtn" disabled>
            <i class="fas fa-chevron-left"></i>
            Previous
          </button>
          <button class="btn btn-primary" id="nextLessonBtn" disabled>
            Next
            <i class="fas fa-chevron-right"></i>
          </button>
        </div>
      </footer>
    </main>

    <!-- Achievement Notification -->
    <div id="achievementNotification" class="achievement-notification">
      <div class="notification-header">
        <div class="notification-icon" id="notificationIcon">
          <i class="fas fa-trophy"></i>
        </div>
        <div class="notification-content">
          <h3 id="notificationTitle">Achievement Unlocked!</h3>
          <p id="notificationDescription">Description here...</p>
        </div>
      </div>
      <div class="notification-reward" id="notificationReward">
        <i class="fas fa-coins"></i>
        <span id="notificationPoints">+100 Points</span>
      </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast">
      <span id="toastMessage"></span>
    </div>

    <script>
      // =====================================================
      // SYNCHRONIZED COURSE SYSTEM WITH DASHBOARD INTEGRATION
      // =====================================================

      // Supabase Configuration - Replace with your config
      const supabaseUrl = "https://lzcmzulemfubjaksoqor.supabase.co";
      const supabaseKey =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx6Y216dWxlbWZ1Ympha3NvcW9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzMzM5MDgsImV4cCI6MjA3MDkwOTkwOH0.crhPH4YWtRsr1BJTpAQcmPbWSpwIWRbzoI4sRb2_fPI";
      const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

      // =====================================================
      // COURSE DATA STRUCTURE - REPLACE WITH YOUR COURSE JSON
      // =====================================================
      const COURSE_DATA = {
    "id": "application-hardening",
    "title": "Complete Application Hardening Course",
    "description": "A practical, hands-on course for developers, system administrators, and security professionals on how to systematically reduce the attack surface of applications and their underlying infrastructure.",
    "category": "cybersecurity",
    "difficulty": "Intermediate",
    "duration": "80 hours",
    "instructor": "Dr. David Chen",
    "lessons": [
        {
            "id": "lesson-1",
            "title": "Introduction to Application Hardening",
            "duration": "90 min",
            "objectives": [
                "Understand the core principles of application hardening.",
                "Learn to apply the Defense in Depth strategy.",
                "Grasp the methodology of attack surface reduction.",
                "Develop a business case for application hardening initiatives."
            ],
            "content": {
                "overview": "This foundational lesson introduces the concept of application hardening. We will explore the philosophy of proactive defense, focusing on making systems as resilient as possible by systematically identifying and eliminating potential weaknesses. The goal is to make applications a much more difficult target for attackers.",
                "sections": [
                    {
                        "title": "Application Hardening Fundamentals and Principles",
                        "content": "<p>Application hardening is the process of securing an application and its environment by reducing its attack surface. The core principle is to assume that an attacker will attempt to compromise your system and to proactively eliminate as many potential entry points and vulnerabilities as possible.</p><h3>Key Principles:</h3><ul><li><strong>Principle of Least Privilege:</strong> Grant only the bare minimum permissions necessary for a function.</li><li><strong>Defense in Depth:</strong> Implement multiple, layered security controls.</li><li><strong>Attack Surface Reduction:</strong> Systematically disable or remove all non-essential features, services, and ports.</li><li><strong>Fail Securely:</strong> Ensure that in the event of a failure, the system defaults to a secure state.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Attack Surface Reduction Methodologies",
                        "content": "<p>The attack surface is the sum of all the different points where an attacker can try to enter data or extract data from an environment.</p><h3>Areas to Reduce:</h3><ul><li><strong>Network:</strong> Close all unnecessary network ports.</li><li><strong>Operating System:</strong> Disable all non-essential services and uninstall all unneeded software.</li><li><strong>Application:</strong> Disable all non-essential features and API endpoints.</li><li><strong>Human:</strong> Reduce the number of users with privileged access.</li></ul><p>The smaller the attack surface, the fewer opportunities an attacker has to find a vulnerability.</p>",
                        "image": "https://images.unsplash.com/photo-1544256718-3b62ff04b356?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Business Case Development for Hardening",
                        "content": "<p>Hardening requires time and resources, so it's important to be able to justify the investment to the business. The business case is built on risk reduction and cost avoidance.</p><p>By investing in proactive hardening, the organization can avoid the much greater costs associated with a security breach, which include:</p><ul><li>Incident response and recovery costs.</li><li>Regulatory fines.</li><li>Reputational damage and loss of customer trust.</li><li>Business downtime.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1556740738-b6a63e27c4df?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 1: Application Attack Surface Assessment Tool",
                        "language": "markdown",
                        "code": "# Attack Surface Assessment for a Web Server\n\n**1. Network Attack Surface:**\n   - **Open Ports (nmap scan):** 22 (SSH), 80 (HTTP), 443 (HTTPS), 3306 (MySQL)\n   - **Finding:** Port 3306 should not be exposed to the internet. It should only be accessible from the application server over the private network.\n\n**2. OS Attack Surface:**\n   - **Running Services:** `sshd`, `nginx`, `mysqld`, `postfix` (email server)\n   - **Finding:** The `postfix` service is not needed for this web server and should be disabled and uninstalled.\n\n**3. Application Attack Surface:**\n   - **Enabled Features:** Web pages, Admin login, File upload feature.\n   - **Finding:** The file upload feature allows `.php` files, which could lead to remote code execution. This should be restricted."
                    },
                    {
                        "title": "Code Example 1: Security Posture Evaluation Framework",
                        "language": "json",
                        "code": "{\n  \"assetId\": \"web-server-01\",\n  \"hardeningScore\": 75,\n  \"checks\": [\n    {\n      \"checkId\": \"CIS-2.2.1.2\",\n      \"description\": \"Ensure chrony is configured\",\n      \"status\": \"PASSED\"\n    },\n    {\n      \"checkId\": \"CIS-3.4.2\",\n      \"description\": \"Ensure outbound connections are configured\",\n      \"status\": \"PASSED\"\n    },\n    {\n      \"checkId\": \"CIS-5.2.4\",\n      \"description\": \"Ensure SSH root login is disabled\",\n      \"status\": \"FAILED\",\n      \"remediation\": \"Set 'PermitRootLogin no' in /etc/ssh/sshd_config\"\n    }\n  ]\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary goal of application hardening?",
                        "options": [
                            "To add more features to the application.",
                            "To make the application run faster.",
                            "To reduce the application's attack surface and make it a more resilient target.",
                            "To make the application easier to use."
                        ],
                        "correct": 2,
                        "explanation": "Hardening is a proactive defense strategy. It's about systematically removing all non-essential services, permissions, and configurations to minimize the number of potential vulnerabilities an attacker could exploit."
                    },
                    {
                        "id": 2,
                        "question": "The strategy of using multiple, layered security controls (like a firewall, a hardened OS, and a secure application) is known as:",
                        "options": [
                            "Attack Surface Reduction",
                            "Defense in Depth",
                            "Least Privilege",
                            "Fail Securely"
                        ],
                        "correct": 1,
                        "explanation": "Defense in Depth is a core security principle. It ensures that the failure of any single control does not lead to a full system compromise."
                    },
                    {
                        "id": 3,
                        "question": "Disabling unneeded services on an operating system is an example of what hardening methodology?",
                        "options": [
                            "Attack Surface Reduction",
                            "Defense in Depth",
                            "Least Privilege",
                            "Fail Securely"
                        ],
                        "correct": 0,
                        "explanation": "Every running service is a potential entry point for an attacker. By disabling any service that is not strictly necessary for the application to function, you are directly reducing its attack surface."
                    },
                    {
                        "id": 4,
                        "question": "A firewall that is configured to deny all traffic by default and only has specific rules to allow necessary traffic is following which principle?",
                        "options": [
                            "Attack Surface Reduction",
                            "Defense in Depth",
                            "Least Privilege",
                            "Fail Securely (Default Deny)"
                        ],
                        "correct": 3,
                        "explanation": "The 'default deny' stance is a key part of the 'fail securely' principle. It ensures that only explicitly permitted traffic is allowed, rather than trying to block known bad traffic."
                    }
                ]
            }
        },
        {
            "id": "lesson-2",
            "title": "Operating System Hardening for Applications",
            "duration": "120 min",
            "objectives": [
                "Learn to apply industry-standard security baselines like CIS Benchmarks.",
                "Implement the principle of least privilege for file system permissions and user accounts.",
                "Design a strategy for service minimization and process isolation.",
                "Configure a secure system audit and logging policy."
            ],
            "content": {
                "overview": "The operating system is the foundation upon which your application runs. A vulnerability or misconfiguration at the OS level can undermine even the most secure application code. This lesson covers the practical, hands-on techniques for hardening common operating systems (Linux and Windows) to provide a secure foundation.",
                "sections": [
                    {
                        "title": "OS-Level Security Configuration",
                        "content": "<p>Instead of guessing at secure settings, the industry standard is to use a pre-defined hardening guideline, known as a security baseline.</p><h3>CIS Benchmarks:</h3><p>The Center for Internet Security (CIS) publishes detailed, step-by-step hardening guides for nearly every major operating system, database, and cloud provider. These benchmarks are the de facto standard for secure configuration.</p><h3>Automation:</h3><p>Manually applying hundreds of CIS controls is not scalable. The architectural approach is to use configuration management tools (like Ansible, Puppet, or Chef) to automate the application of the hardening baseline. This is 'Security Configuration as Code'.</p>",
                        "image": "https://images.unsplash.com/photo-1510915228340-29c85a43dcfe?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "File System Permissions and Access Controls",
                        "content": "<p>The principle of least privilege is critical for file permissions.</p><h3>Key Principles:</h3><ul><li><strong>Application Files:</strong> The user account that the application runs as (e.g., the `nginx` user) should have read-only access to the application's binary and configuration files. It should only have write access to specific directories that it needs, like a log or cache directory.</li><li><strong>System Files:</strong> Application service accounts should never have write access to critical system directories.</li><li><strong>User Data:</strong> Ensure that user-uploaded data is stored with permissions that prevent it from being executed by the web server.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Service Minimization and Disabling",
                        "content": "<p>This is a core part of attack surface reduction. A standard OS installation comes with many network services that are not needed for a typical web application.</p><p>As part of the hardening process, you must go through the list of all running services and disable any that are not strictly required. For example, a web server does not need an email server (like Postfix) or an FTP server running on it. Every disabled service is one less potential vulnerability.</p>",
                        "image": "https://images.unsplash.com/photo-1544256718-3b62ff04b356?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "System Audit and Logging Configuration",
                        "content": "<p>The OS must be configured to produce a detailed audit trail of security-relevant events. This provides the visibility needed for incident detection and response.</p><h3>What to Log:</h3><ul><li>Successful and failed user logins.</li><li>Use of privileged commands (e.g., `sudo`).</li><li>Changes to system security settings.</li><li>Access to critical files.</li></ul><p>These logs should not be stored locally on the server. They must be shipped in real-time to a centralized, secure log aggregator or SIEM to protect them from tampering.</p>",
                        "image": "https://images.unsplash.com/photo-1581291518857-4e27b48ff24e?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 2: Automated OS Hardening Assessment",
                        "language": "yaml",
                        "code": "# Example of an Ansible task to enforce a CIS Benchmark control\n\n- name: \"5.2.4 | Ensure SSH root login is disabled\"\n  lineinfile:\n    path: /etc/ssh/sshd_config\n    regexp: \"^#?PermitRootLogin\"\n    line: \"PermitRootLogin no\"\n    state: present\n  notify: restart sshd\n  tags:\n    - cis-benchmark-5.2.4\n    - security\n    - hardening"
                    },
                    {
                        "title": "Code Example 2: Cross-Platform OS Security Configuration Tool",
                        "language": "shell",
                        "code": "# Example of setting least privilege file permissions on Linux\n\n# Assume the web server runs as the 'www-data' user\nAPP_DIR=/var/www/my-app\nLOG_DIR=/var/log/my-app\n\n# The application code directory should be owned by root\n# and readable by the app user, but not writable.\nchown -R root:root $APP_DIR\nchmod -R 755 $APP_DIR\n\n# The log directory should be owned by the app user\n# and should be the only place it can write to.\nchown -R www-data:www-data $LOG_DIR\nchmod -R 750 $LOG_DIR"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "The industry-standard, detailed guides for the secure configuration of operating systems are known as:",
                        "options": [
                            "The OWASP Top 10",
                            "The CIS Benchmarks",
                            "The SANS Top 25",
                            "The MITRE ATT&CK Framework"
                        ],
                        "correct": 1,
                        "explanation": "The CIS Benchmarks are the de facto standard for secure configuration. They provide prescriptive, step-by-step guidance that can be used to harden systems and can be automated with configuration management tools."
                    },
                    {
                        "id": 2,
                        "question": "The practice of using a tool like Ansible or Puppet to automatically apply a secure baseline to servers is known as:",
                        "options": [
                            "Manual Hardening",
                            "Security Configuration as Code",
                            "Incident Response",
                            "Penetration Testing"
                        ],
                        "correct": 1,
                        "explanation": "Security Configuration as Code applies DevOps principles to system hardening. It ensures that hardening is an automated, repeatable, and version-controlled process, which is essential for managing security at scale."
                    },
                    {
                        "id": 3,
                        "question": "What is the primary reason to disable or uninstall non-essential services (like an email server) from a web server?",
                        "options": [
                            "To reduce the server's attack surface.",
                            "To make the server run slower.",
                            "To use more disk space.",
                            "It has no security benefit."
                        ],
                        "correct": 0,
                        "explanation": "This is a core principle of attack surface reduction. Every additional service is another piece of software that could have a vulnerability. By removing what is not needed, you eliminate potential entry points for an attacker."
                    },
                    {
                        "id": 4,
                        "question": "To protect system audit logs from being deleted by an attacker who has compromised a server, what architectural control should be in place?",
                        "options": [
                            "Store the logs in a text file on the same server.",
                            "Disable all logging to prevent attackers from seeing it.",
                            "Ship the logs in real-time to a centralized, secure, and tamper-resistant SIEM or log aggregator.",
                            "Print the logs out."
                        ],
                        "correct": 2,
                        "explanation": "Centralizing logs is a critical security control. It ensures the integrity and availability of the audit trail, which is essential for detecting and investigating an incident. An attacker's first move is often to delete local logs to cover their tracks."
                    }
                ]
            }
        },
        {
            "id": "lesson-3",
            "title": "Network Layer Application Hardening",
            "duration": "90 min",
            "objectives": [
                "Design a secure network architecture using segmentation.",
                "Implement a 'default deny' firewall configuration for an application.",
                "Understand the role of Network Access Control (NAC) and VPNs.",
                "Architect a secure DMZ for internet-facing services."
            ],
            "content": {
                "overview": "Network security is a fundamental layer of a defense-in-depth strategy. Even if an application has a vulnerability, strong network controls can prevent an attacker from ever reaching it or limit the damage they can do if they gain a foothold. This lesson covers the core principles of network hardening from an application perspective.",
                "sections": [
                    {
                        "title": "Network Segmentation for Application Security",
                        "content": "<p>Network segmentation is the practice of dividing a network into smaller, isolated sub-networks. This is the primary control for preventing an attacker's lateral movement.</p><h3>The Multi-Tier Architecture Pattern:</h3><p>A classic secure design pattern is to place different tiers of your application in different network segments (or VLANs/subnets).</p><ul><li><strong>Web Tier (Public Subnet):</strong> Contains the public-facing web servers. This is the only segment that can receive traffic from the internet.</li><li><strong>Application Tier (Private Subnet):</strong> Contains the application servers with the business logic. They can only receive traffic from the Web Tier.</li><li><strong>Database Tier (Restricted Subnet):</strong> Contains the database servers. They can only receive traffic from the Application Tier.</li></ul><p>If a web server is compromised, this segmentation prevents the attacker from directly accessing the database server.</p>",
                        "image": "https://images.unsplash.com/photo-1593441139884-faf2c88c7c97?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Firewall Configuration and Management",
                        "content": "<p>Firewalls are the enforcement points that control traffic between your network segments.</p><h3>The 'Default Deny' Principle:</h3><p>A firewall should be configured with a 'default deny' (or implicit deny) policy. This means that at the end of its ruleset, there is a rule that blocks all traffic. The only traffic that is allowed to pass is that which is explicitly permitted by a specific 'allow' rule.</p><h3>Least Privilege for Firewall Rules:</h3><p>Allow rules should be as specific as possible. Instead of 'allow all traffic from the web tier to the app tier', the rule should be 'allow traffic from the web servers' IP range to the app servers' IP range on TCP port 8080 only'.</p>",
                        "image": "https://images.unsplash.com/photo-1544890225-2fde0e66f255?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "DMZ and Perimeter Security Design",
                        "content": "<p>A Demilitarized Zone (DMZ) is a perimeter network that hosts an organization's external-facing services, like web servers and email servers. It is an extra layer of security that sits between the untrusted internet and the trusted internal corporate network.</p><p>All traffic from the internet is terminated in the DMZ. A separate firewall then strictly controls traffic between the DMZ and the internal network. This provides a strong, layered defense for the internal network.</p>",
                        "image": "https://images.unsplash.com/photo-1614064548237-02f0d1a2c39c?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 3: Network Security Architecture Workshop",
                        "language": "plaintext",
                        "code": "/* \n  Conceptual Firewall Rules for a 3-Tier Web Application\n\n  Firewall 1 (Internet to Web Tier):\n  - Rule 1: ALLOW src:ANY dst:WEB_SERVER_IPs port:443 (Allow HTTPS traffic)\n  - Rule 2: DENY src:ANY dst:ANY (Default Deny)\n\n  Firewall 2 (Web Tier to App Tier):\n  - Rule 1: ALLOW src:WEB_SERVER_IPs dst:APP_SERVER_IPs port:8080 (Allow App traffic)\n  - Rule 2: DENY src:ANY dst:ANY (Default Deny)\n\n  Firewall 3 (App Tier to DB Tier):\n  - Rule 1: ALLOW src:APP_SERVER_IPs dst:DB_SERVER_IPs port:3306 (Allow DB traffic)\n  - Rule 2: DENY src:ANY dst:ANY (Default Deny)\n\n  Result: A compromise of a web server does not give the attacker a direct network path\n  to the database server. They must first compromise an application server.\n*/"
                    },
                    {
                        "title": "Code Example 3: Network Security Configuration Automation Framework",
                        "language": "hcl",
                        "code": "# Example Terraform for an AWS Security Group (a stateful firewall)\n\nresource \"aws_security_group\" \"web_sg\" {\n  name        = \"web-server-sg\"\n  description = \"Allow HTTPS inbound traffic\"\n\n  # Ingress (inbound) rules\n  ingress {\n    description = \"HTTPS from anywhere\"\n    from_port   = 443\n    to_port     = 443\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  # Egress (outbound) rules\n  # By default, all outbound traffic is allowed.\n  # For hardening, we would add a rule to deny all and then only allow\n  # specific outbound connections (e.g., to the app tier).\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\" // All protocols\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "The practice of dividing a network into smaller, isolated zones to prevent an attacker's lateral movement is known as:",
                        "options": [
                            "Network Segmentation",
                            "Network Address Translation (NAT)",
                            "Load Balancing",
                            "DNS"
                        ],
                        "correct": 0,
                        "explanation": "Segmentation is the most effective network-level control for containing a breach. By creating firewalled boundaries between different parts of the network, you limit the damage an attacker can do if they compromise a single system."
                    },
                    {
                        "id": 2,
                        "question": "A firewall policy that blocks all traffic unless a specific rule allows it is following which principle?",
                        "options": [
                            "Default Allow",
                            "Default Deny",
                            "Allow Any",
                            "Trust All"
                        ],
                        "correct": 1,
                        "explanation": "Default Deny (or implicit deny) is a foundational security principle. It means your security posture is to deny by default and only explicitly permit what is necessary, which is far more secure than trying to block known bad traffic."
                    },
                    {
                        "id": 3,
                        "question": "In a secure 3-tier architecture, which tier is the ONLY one that should be directly accessible from the internet?",
                        "options": [
                            "The Database Tier",
                            "The Application Tier",
                            "The Web Tier",
                            "All tiers should be accessible from the internet."
                        ],
                        "correct": 2,
                        "explanation": "The web tier acts as the public-facing entry point. The application and database tiers should be in private, non-internet-routable subnets, protected by internal firewalls."
                    },
                    {
                        "id": 4,
                        "question": "A perimeter network that sits between the internet and the internal corporate network to host public-facing services is called a:",
                        "options": [
                            "Virtual Private Network (VPN)",
                            "Local Area Network (LAN)",
                            "Demilitarized Zone (DMZ)",
                            "Wide Area Network (WAN)"
                        ],
                        "correct": 2,
                        "explanation": "A DMZ provides a layered defense. A compromise of a server in the DMZ does not immediately grant an attacker access to the more sensitive internal network, as they still have to breach a second, internal firewall."
                    }
                ]
            }
        },
        {
            "id": "lesson-4",
            "title": "Application Runtime Environment Hardening",
            "duration": "90 min",
            "objectives": [
                "Learn to harden the configuration of common web and application servers.",
                "Implement a secure configuration for the database server that hosts an application.",
                "Understand how to harden virtual machine and container runtime environments.",
                "Develop a secure strategy for managing environment variables and secrets."
            ],
            "content": {
                "overview": "An application does not run in a vacuum. It runs on a stack of other software: a web server, an application server, and a database server, all running within a virtual machine or a container. Hardening the configuration of this entire runtime environment is a critical layer of a defense-in-depth strategy.",
                "sections": [
                    {
                        "title": "Web Server Security Configuration",
                        "content": "<p>Web servers like NGINX, Apache, and IIS have many security configuration options that must be set correctly.</p><h3>Key Hardening Steps:</h3><ul><li><strong>Run as a Non-Privileged User:</strong> The web server process must run as a dedicated, low-privilege user (e.g., `www-data`), not as root.</li><li><strong>Disable Unnecessary Modules:</strong> A standard installation comes with many modules that are not needed. Disable any module that your application does not use to reduce the attack surface.</li><li><strong>Configure Secure TLS:</strong> The server must be configured to use only strong TLS protocols (TLS 1.2, TLS 1.3) and modern, secure cipher suites.</li><li><strong>Implement Security Headers:</strong> Configure the web server to send key HTTP security headers (like CSP, HSTS, and X-Frame-Options) with every response.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1544890225-2fde0e66f255?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Database Server Hardening",
                        "content": "<p>The database server itself must be hardened, in addition to the security of the application's queries.</p><h3>Key Hardening Steps:</h3><ul><li><strong>Network Access:</strong> Configure the database to listen only on the internal network interface, not on all interfaces (0.0.0.0). Use the host-based firewall to restrict access to the database port from only the application servers.</li><li><strong>Disable Default Accounts:</strong> Change the password for the default administrative account (e.g., `sa`) and disable any other default or guest accounts.</li><li><strong>Enable Auditing:</strong> Configure the database's native audit logging to record all administrative actions, logins, and access to sensitive data.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Virtual Machine and Container Hardening",
                        "content": "<h3>For Virtual Machines:</h3><p>Start from a 'golden image' that has been hardened according to the CIS Benchmarks for that operating system.</p><h3>For Containers:</h3><p>The container runtime itself must be secured.</p><ul><li><strong>Use a Hardened Base Image:</strong> Build your application containers on top of a minimal, hardened base image.</li><li><strong>Don't Run as Root:</strong> The container process should not run as the root user.</li><li><strong>Read-Only Root Filesystem:</strong> If possible, run the container with a read-only root filesystem. This prevents an attacker who gains code execution from being able to write malicious files or modify the container.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1614064548237-02f0d1a2c39c?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Environment Variable Security Management",
                        "content": "<p>It is a common pattern to pass secrets like database passwords and API keys to an application via environment variables. While this is better than hard-coding them in source code, it still has risks.</p><p>On a multi-tenant system, other processes running as the same user can often read the environment variables of another process. The most secure approach is for the application to start up, authenticate to a secure secrets management vault, and retrieve its secrets directly into memory at runtime.</p>",
                        "image": "https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 4: Runtime Environment Security Assessment",
                        "language": "nginx",
                        "code": "# Example of a hardened NGINX TLS configuration\n\nssl_protocols TLSv1.2 TLSv1.3;\nssl_prefer_server_ciphers on;\nssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384;\n\n# Add the HSTS header to enforce HTTPS\nadd_header Strict-Transport-Security \"max-age=31536000; includeSubDomains\" always;"
                    },
                    {
                        "title": "Code Example 4: Multi-Platform Runtime Hardening Tool",
                        "language": "dockerfile",
                        "code": "# Example of hardening a Docker container\n\nFROM python:3.9-slim\n\n# 1. Create a dedicated, non-root user for the application\nRUN addgroup --system app && adduser --system --group app\n\nWORKDIR /app\nCOPY . .\n\n# 2. Switch to the non-root user\nUSER app\n\n# 3. The application will now run with the privileges of the 'app' user, not root.\nCMD [\"python\", \"app.py\"]"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "When hardening a web server, what is the best practice for the user account that the server process (e.g., NGINX, Apache) runs as?",
                        "options": [
                            "It should always run as the `root` user.",
                            "It should run as a dedicated, low-privilege user.",
                            "It should run as your personal user account.",
                            "It does not matter which user it runs as."
                        ],
                        "correct": 1,
                        "explanation": "This is a key application of the principle of least privilege. If a vulnerability is found in the web server software, an attacker will only gain the limited permissions of the service account, not full root access to the system."
                    },
                    {
                        "id": 2,
                        "question": "A container that is configured to prevent any changes to its own filesystem at runtime is known as a:",
                        "options": [
                            "Privileged container",
                            "Container with a read-only root filesystem",
                            "A vulnerable container",
                            "A development container"
                        ],
                        "correct": 1,
                        "explanation": "This is a powerful hardening technique. It prevents an attacker who has gained code execution from being able to write malicious tools or modify the container's configuration, significantly limiting their capabilities."
                    },
                    {
                        "id": 3,
                        "question": "The most secure way for an application to get a database password is to:",
                        "options": [
                            "Hard-code it in the source code.",
                            "Read it from a plaintext configuration file.",
                            "Read it from an environment variable.",
                            "Retrieve it at runtime from a secure secrets management vault."
                        ],
                        "correct": 3,
                        "explanation": "While environment variables are better than source code, the best practice is to use a dedicated secrets management system. This provides centralized control, auditing, and rotation for all secrets."
                    },
                    {
                        "id": 4,
                        "question": "What is the primary purpose of configuring a database server to only listen for connections on its internal network interface?",
                        "options": [
                            "To make it accessible from the internet.",
                            "To improve its performance.",
                            "To reduce its network attack surface by ensuring it cannot be reached directly from an external network.",
                            "To make it easier to manage."
                        ],
                        "correct": 2,
                        "explanation": "This is a fundamental network hardening control. The database should be in a private network segment, and the database process itself should be bound only to the private IP address, providing defense in depth."
                    }
                ]
            }
        },
        {
            "id": "lesson-15",
            "title": "Input Validation and Sanitization Hardening",
            "duration": "120 min",
            "objectives": [
                "Master the implementation of a positive validation (allow-list) security model.",
                "Learn to apply strong data type, format, and range validation.",
                "Implement contextual output encoding as a defense-in-depth control.",
                "Harden file upload functionality against common attack vectors."
            ],
            "content": {
                "overview": "This lesson provides a deep dive into hardening the most critical boundary of any application: the point where it accepts input from the untrusted world. We will move beyond the basics to cover advanced and robust strategies for input validation and output encoding to build a resilient defense against all forms of injection attacks.",
                "sections": [
                    {
                        "title": "Comprehensive Input Validation Strategies",
                        "content": "<p>The core principle of hardening input validation is to be as strict and specific as possible.</p><h3>The Allow-List Philosophy:</h3><p>Your default stance should be to reject any input that does not conform to a very strict, expected format. For example, if you are expecting a 5-digit US zip code, the validation should not just check that the input is a number; it should check that it is exactly 5 digits long and contains only the characters 0-9. The regular expression `^[0-9]{5}$` is a much stronger validation than a simple type check.</p>",
                        "image": "https://images.unsplash.com/photo-1555099962-4199c345e546?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Data Sanitization and Encoding",
                        "content": "<p>It's important to understand the difference.</p><ul><li><strong>Validation:</strong> The process of checking if input meets a set of criteria. The outcome is a simple yes/no.</li><li><strong>Sanitization:</strong> The process of modifying the input to make it 'safe' (e.g., by stripping out characters like `<` and `>`). Sanitization can be risky because a clever attacker might find a way to bypass an incomplete sanitizer. Validation is generally preferred.</li><li><strong>Encoding:</strong> The process of converting data into a safe format for a specific output context. This is not for input, but for output.</li></ul><p>A hardened application uses strong validation on the way in, and contextual encoding on the way out.</p>",
                        "image": "https.images.unsplash.com/photo-1517694712202-14dd9538aa97?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "File Upload Security Hardening",
                        "content": "<p>Hardening a file upload feature requires multiple, layered controls.</p><h3>Defense-in-Depth Checklist:</h3><ol><li><strong>Strict Type Validation:</strong> Use an allow-list of file extensions AND check the file's magic numbers to verify its true type.</li><li><strong>Strict Filename Sanitization:</strong> The user-supplied filename should be completely discarded. Generate a new, random, UUID-based filename.</li><li><strong>Content Scanning:</strong> Pass the file to a malware scanner. For higher security, you could also use a Content Disarm and Reconstruction (CDR) tool, which rebuilds the file from scratch to remove any potential embedded threats.</li><li><strong>Secure Storage:</strong> Store the file in an isolated, non-web-accessible location with read-only permissions for the application.</li></ol>",
                        "image": "https://images.unsplash.com/photo-1588665387928-a_d2a13f8373?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 5: Advanced Input Validation Framework",
                        "language": "java",
                        "code": "import org.owasp.esapi.ESAPI;\n\n// Using a well-vetted security library like OWASP ESAPI is a hardening best practice.\n\npublic class HardenedValidator {\n\n    public String getValidCreditCard(String input) {\n        // ESAPI's validator uses a strict, pre-defined allow-list pattern.\n        // It checks for type, format, length, and uses a Luhn checksum.\n        return ESAPI.validator().getValidCreditCard(\"CreditCardNumber\", input, false);\n    }\n\n    public String getValidFilename(String input) {\n        // This validator checks for path traversal and other malicious characters.\n        return ESAPI.validator().getValidFileName(\"FileName\", input, false);\n    }\n}"
                    },
                    {
                        "title": "Code Example 5: Universal Input Security Hardening Library",
                        "language": "python",
                        "code": "# Example of a hardened input processing flow\n\nfrom werkzeug.utils import secure_filename\n\ndef process_upload(file, user_input):\n    # 1. Hardened filename validation\n    # - Discard user's filename; generate a random one.\n    # - Only use the user's filename to get the extension.\n    safe_filename = secure_filename(file.filename)\n    extension = safe_filename.rsplit('.', 1)[1]\n    new_filename = f\"{uuid.uuid4()}.{extension}\"\n\n    # 2. Hardened content validation\n    # - Use a library to check the magic numbers, don't trust the extension.\n    file_type = magic.from_buffer(file.stream.read(2048), mime=True)\n    if file_type not in ['image/jpeg', 'image/png']:\n        raise ValidationError(\"Invalid file content.\")\n\n    # 3. Hardened data validation for other inputs\n    # - Use a schema validation library for all other inputs.\n    #   This checks for type, format, length, etc.\n    schema.validate(user_input)\n\n    # ... only after all checks pass, proceed with processing."
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "The most secure approach to input validation is:",
                        "options": [
                            "Blacklisting (denying known bad input).",
                            "Trusting all user input.",
                            "Sanitizing input by removing some bad characters.",
                            "Whitelisting (positive validation), where you define a strict format for what is allowed and reject everything else."
                        ],
                        "correct": 3,
                        "explanation": "Whitelisting is a 'default deny' approach to validation. It is far more secure than blacklisting because you don't have to guess every possible attack string an attacker might invent."
                    },
                    {
                        "id": 2,
                        "question": "Converting data into a safe format for a specific output context (e.g., HTML) is known as:",
                        "options": [
                            "Input Validation",
                            "Input Sanitization",
                            "Output Encoding",
                            "Input Filtering"
                        ],
                        "correct": 2,
                        "explanation": "Output encoding is the critical defense-in-depth control against injection attacks like XSS. It ensures that even if malicious data gets into your system, it is rendered harmlessly to the user."
                    },
                    {
                        "id": 3,
                        "question": "What is the most reliable way to harden file type validation for uploads?",
                        "options": [
                            "By checking the file extension.",
                            "By trusting the `Content-Type` header.",
                            "By checking the file's 'magic numbers' (its byte signature).",
                            "By asking the user what type of file it is."
                        ],
                        "correct": 2,
                        "explanation": "The file's actual content (its magic numbers) is the only reliable indicator of its true type. Both the filename and the Content-Type header are user-controlled and can be easily spoofed."
                    },
                    {
                        "id": 4,
                        "question": "A tool that rebuilds a file (like a PDF) from scratch to remove any potentially malicious active content is known as a:",
                        "options": [
                            "Antivirus Scanner",
                            "Content Disarm and Reconstruction (CDR) tool",
                            "Firewall",
                            "Web Server"
                        ],
                        "correct": 1,
                        "explanation": "CDR is an advanced hardening technique. Instead of looking for known 'bad' things, it assumes all content is potentially bad and rebuilds a new, clean version of the file containing only the safe, known-good elements."
                    }
                ]
            }
        },
        
        {
            "id": "lesson-16",
            "title": "Memory Protection and Buffer Overflow Prevention",
            "duration": "90 min",
            "objectives": [
                "Understand modern memory protection mechanisms provided by compilers and operating systems.",
                "Implement stack protection controls like Stack Canaries and ASLR.",
                "Learn strategies for hardening against heap-based overflows.",
                "Apply safe memory allocation and sanitization techniques in code."
            ],
            "content": {
                "overview": "While writing memory-safe code is the primary defense, a defense-in-depth strategy involves leveraging the powerful memory protection mechanisms built into modern compilers and operating systems. This lesson covers how to enable and verify these controls to harden an application against memory corruption attacks, even if a bug exists in the code.",
                "sections": [
                    {
                        "title": "Buffer Overflow Protection Mechanisms",
                        "content": "<p>Modern systems have several built-in defenses against buffer overflows that you must ensure are enabled during compilation and deployment.</p><h3>Key Protections:</h3><ul><li><strong>Stack Canaries:</strong> A compiler feature that places a secret, random value (the 'canary') on the stack before a function's local variables. Before the function returns, it checks if the canary value is still intact. A stack buffer overflow will overwrite the canary, and the check will fail, causing the program to terminate safely instead of allowing an attacker to hijack the execution flow.</li><li><strong>Address Space Layout Randomization (ASLR):</strong> An OS feature that randomizes the memory locations of key areas like the executable, libraries, and the stack. This makes it much harder for an attacker to know where to jump to in memory to execute their malicious code.</li><li><strong>Data Execution Prevention (DEP):</strong> An OS and hardware feature that marks certain areas of memory (like the stack) as non-executable. This prevents an attacker from executing malicious code they have injected into a buffer on the stack.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1517694712202-14dd9538aa97?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Heap Protection Strategies",
                        "content": "<p>Hardening the heap (where dynamically allocated memory lives) is also critical.</p><h3>Techniques:</h3><ul><li><strong>Heap Integrity Checks:</strong> Modern memory allocators in operating systems include internal checks (heap metadata) to detect corruption caused by heap-based overflows.</li><li><strong>Safe Memory Allocation:</strong> Ensure that all size calculations for memory allocation are checked for integer overflows.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1555099962-4199c345e546?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Memory Sanitization Techniques",
                        "content": "<p>When you are finished using a piece of memory that held sensitive data (like a password or an encryption key), you should explicitly overwrite it with zeros before freeing it. This is known as memory sanitization. It prevents a 'memory scraping' attack where an attacker with access to the system's memory could potentially find these secrets lingering in memory after they have been used.</p>",
                        "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 16: Memory Protection Implementation Lab",
                        "language": "shell",
                        "code": "# Compiling a C program with all standard memory protections enabled using GCC\n\n# -fstack-protector-all: Enables stack canaries for all functions.\n# -D_FORTIFY_SOURCE=2: Adds checks for buffer overflows in common library functions.\n# -Wl,-z,relro,-z,now: Hardens the binary's memory sections (RELRO).\n# The OS is responsible for enabling ASLR and DEP.\n\ngcc -fstack-protector-all -D_FORTIFY_SOURCE=2 -Wl,-z,relro,-z,now -o myapp myapp.c\n\n# Check if the resulting binary has the protections enabled\nchecksec --file=myapp"
                    },
                    {
                        "title": "Code Example 16: Memory Security Hardening Framework",
                        "language": "c",
                        "code": "// Example of memory sanitization\n\nvoid process_sensitive_data(char *password) {\n    char key[32];\n    // ... use the key and password for some operation ...\n\n    // Before the function exits, explicitly clear the sensitive data from memory.\n    // The 'volatile' keyword prevents the compiler from optimizing this away.\n    volatile char *p = key;\n    for (int i=0; i < sizeof(key); i++) {\n        p[i] = 0;\n    }\n    // ... same for password ...\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "A compiler-level protection that places a secret value on the stack to detect a buffer overflow is known as a:",
                        "options": [
                            "Stack Canary",
                            "Firewall",
                            "Heap",
                            "Address Space Layout Randomization (ASLR)"
                        ],
                        "correct": 0,
                        "explanation": "The stack canary acts as a tripwire. If a buffer overflow occurs and overwrites the canary, the program will detect the tampering and terminate safely."
                    },
                    {
                        "id": 2,
                        "question": "An operating system feature that randomizes the memory locations of key parts of a program to make it harder for an attacker to exploit a bug is called:",
                        "options": [
                            "Stack Canary",
                            "Data Execution Prevention (DEP)",
                            "Address Space Layout Randomization (ASLR)",
                            "A firewall"
                        ],
                        "correct": 2,
                        "explanation": "ASLR is a powerful defense that makes exploits less reliable. If the attacker doesn't know where their shellcode or their target functions are in memory, it's much harder to successfully hijack the program's execution flow."
                    },
                    {
                        "id": 3,
                        "question": "Data Execution Prevention (DEP) hardens an application by:",
                        "options": [
                            "Randomizing memory locations.",
                            "Marking certain areas of memory, like the stack, as non-executable.",
                            "Checking for integer overflows.",
                            "Encrypting memory."
                        ],
                        "correct": 1,
                        "explanation": "DEP prevents the most common form of shellcode execution. If an attacker injects their malicious code into a buffer on the stack, DEP ensures the CPU will refuse to execute it, stopping the attack."
                    },
                    {
                        "id": 4,
                        "question": "The practice of overwriting sensitive data in memory with zeros before it is deallocated is known as:",
                        "options": [
                            "Memory Sanitization",
                            "A memory leak",
                            "A buffer overflow",
                            "A use-after-free"
                        ],
                        "correct": 0,
                        "explanation": "Memory sanitization is a defense-in-depth measure that prevents sensitive secrets from lingering in memory where they could potentially be found by another process or a memory scraping attack."
                    }
                ]
            }
        },
        {
            "id": "lesson-17",
            "title": "Code Protection and Anti-Tampering",
            "duration": "90 min",
            "objectives": [
                "Understand the principles of code obfuscation.",
                "Learn to implement anti-debugging and anti-reverse engineering techniques.",
                "Explore the architecture of Runtime Application Self-Protection (RASP).",
                "Design a secure code signing and integrity verification system."
            ],
            "content": {
                "overview": "For some applications, especially mobile apps or client-side software, protecting the intellectual property of the code and preventing tampering are key requirements. This lesson covers advanced hardening techniques designed to make an application more resistant to reverse engineering, analysis, and modification by an attacker.",
                "sections": [
                    {
                        "title": "Code Obfuscation Techniques",
                        "content": "<p>Code obfuscation is the process of modifying an application's binary or bytecode to make it much harder for a human to understand, without changing its functionality. This is a key defense against reverse engineering.</p><h3>Common Techniques:</h3><ul><li><strong>Renaming:</strong> Renaming all meaningful class, method, and variable names to short, meaningless ones (e.g., `A`, `B`, `C`).</li><li><strong>Control Flow Obfuscation:</strong> Inserting confusing and opaque logic (like complex `GOTO` statements) that makes it very hard to follow the program's execution flow.</li><li><strong>String Encryption:</strong> Encrypting all the string literals in the binary and only decrypting them in memory right before they are used.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Anti-Debugging and Anti-Reverse Engineering",
                        "content": "<p>These are techniques where the application actively tries to detect if it is being run in a debugger or attached to a reverse engineering tool. If it detects that it is being analyzed, it can change its behavior or shut down.</p><h3>Examples:</h3><ul><li>The application can check for the presence of common debugger processes.</li><li>The application can check the timing of certain operations. If an operation takes much longer than usual, it may be because a debugger has set a breakpoint.</li></ul>",
                        "image": "https.images.unsplash.com/photo-1588665387928-a_d2a13f8373?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Runtime Application Self-Protection (RASP)",
                        "content": "<p>RASP is a security technology that is integrated directly into the application's runtime environment. It has deep visibility into the application's internal state and can detect and block attacks in real-time.</p><p>Unlike a WAF, which sits outside the application, a RASP agent runs inside it. If it sees an input that triggers a known insecure code path (like a SQL injection), it can terminate the request before it ever reaches the database. It provides a final, powerful layer of defense.</p>",
                        "image": "https://images.unsplash.com/photo-1573497175235-d3648a07b388?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Integrity Verification and Code Signing",
                        "content": "<p>This is a critical control, especially for mobile apps. The goal is to ensure that the application code has not been tampered with by an attacker.</p><h3>The Process:</h3><ol><li><strong>Signing:</strong> When the application is released, it is digitally signed with a private key held by the developer.</li><li><strong>Verification:</strong> The operating system (or app store) has the corresponding public key. Before running the app, the OS checks the signature to verify that the code is authentic and has not been modified since it was signed.</li></ol><p>This prevents an attacker from taking a legitimate app, injecting malware into it, and then redistributing it.</p>",
                        "image": "https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 17: Code Protection Workshop",
                        "language": "java",
                        "code": "// Example of using ProGuard (an obfuscation tool for Java)\n\n// Original, readable code:\npublic class UserProfile {\n    private String userName;\n    public String getUserName() { return this.userName; }\n}\n\n// After ProGuard obfuscation, the decompiled code might look like this:\npublic class A {\n    private String a;\n    public String a() { return this.a; }\n}\n\n// This is much harder for a human attacker to understand and reverse-engineer."
                    },
                    {
                        "title": "Code Example 17: Application Self-Protection Framework",
                        "language": "json",
                        "code": "{\n  \"event\": \"RASP_ATTACK_BLOCKED\",\n  \"application\": \"payment-api\",\n  \"attackType\": \"SQL_INJECTION\",\n  \"details\": {\n    \"description\": \"RASP agent detected a SQL injection pattern in the 'productId' parameter and terminated the request.\",\n    \"httpRequest\": \"GET /api/products?productId=1' OR 1=1 --\",\n    \"actionTaken\": \"REQUEST_BLOCKED\"\n  }\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "The process of modifying an application's code to make it much harder for a human to reverse-engineer is called:",
                        "options": [
                            "Code Signing",
                            "Code Obfuscation",
                            "Code Compilation",
                            "Code Commenting"
                        ],
                        "correct": 1,
                        "explanation": "Obfuscation is a hardening technique that acts as a deterrent, increasing the time and effort an attacker must spend to understand the inner workings of your application."
                    },
                    {
                        "id": 2,
                        "question": "A security technology that runs inside the application's runtime to detect and block attacks in real-time is known as:",
                        "options": [
                            "A Web Application Firewall (WAF)",
                            "A Static Analysis (SAST) tool",
                            "Runtime Application Self-Protection (RASP)",
                            "A firewall"
                        ],
                        "correct": 2,
                        "explanation": "RASP is a powerful, modern defense. Because it runs inside the application, it has deep context and can be much more accurate at detecting and blocking attacks than an external device like a WAF."
                    },
                    {
                        "id": 3,
                        "question": "Digitally signing a mobile application before releasing it primarily provides what security guarantee?",
                        "options": [
                            "Confidentiality",
                            "Availability",
                            "Performance",
                            "Integrity and Authenticity"
                        ],
                        "correct": 3,
                        "explanation": "Code signing provides integrity (the code has not been tampered with) and authenticity (it genuinely comes from the trusted developer who holds the private key). This is a critical control for preventing the distribution of malicious, trojanized applications."
                    },
                    {
                        "id": 4,
                        "question": "An application that can detect it is being run in a debugger and then change its behavior or shut down is an example of:",
                        "options": [
                            "Anti-Debugging",
                            "Code Obfuscation",
                            "RASP",
                            "A normal feature"
                        ],
                        "correct": 0,
                        "explanation": "Anti-debugging techniques are a form of active defense designed to frustrate and slow down an attacker who is trying to perform dynamic analysis and reverse engineering on the application."
                    }
                ]
            }
        },
        {
            "id": "lesson-18",
            "title": "Third-Party Component Hardening",
            "duration": "90 min",
            "objectives": [
                "Understand the security risks of the software supply chain.",
                "Implement a robust vulnerability management process for third-party libraries.",
                "Harden the configuration of third-party components like web servers and databases.",
                "Develop a strategy for isolating and sandboxing risky components."
            ],
            "content": {
                "overview": "Modern applications are built on a foundation of third-party components, from open-source libraries to commercial software like web servers and databases. Hardening the application requires hardening this entire ecosystem. This lesson covers the strategies for managing the security of your third-party dependencies and components.",
                "sections": [
                    {
                        "title": "Dependency Vulnerability Management",
                        "content": "<p>As covered in previous lessons, using Software Composition Analysis (SCA) to find and fix known vulnerabilities in your open-source libraries is a critical hardening activity.</p><h3>The Hardening Process:</h3><ol><li><strong>Scan Continuously:</strong> Integrate an SCA tool into your CI/CD pipeline to scan every build.</li><li><strong>Establish a Policy:</strong> Create a policy that defines what is acceptable. For example, 'The pipeline will fail if any new 'Critical' or 'High' severity vulnerability is introduced.'</li><li><strong>Update Promptly:</strong> When a vulnerability is found, use automated tools (like Dependabot) to create pull requests and remediate the issue quickly. Do not let your dependencies become stale and unpatched.</li></ol>",
                        "image": "https://images.unsplash.com/photo-1542382257-80deda0e5d99?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Vendor Security Requirements",
                        "content": "<p>When you use a commercial, off-the-shelf (COTS) software component, you are inheriting its security posture. Part of the hardening process is performing due diligence on your vendors.</p><p>Before you integrate a commercial component, you should review its security documentation, ask for its compliance certifications (like a SOC 2 report), and understand its process for handling and disclosing security vulnerabilities.</p>",
                        "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Component Isolation Strategies",
                        "content": "<p>If you must use a third-party component that you consider high-risk (e.g., a library for processing complex file formats that has a history of vulnerabilities), you can harden your application by isolating that component.</p><h3>The Sandboxing Pattern:</h3><p>Instead of running the risky library in the same process as your main application, you can run it in a separate, sandboxed process with very limited permissions. For example, you could run it in a container with a strict security profile that denies all network access and write access to the filesystem. If the library is compromised, the damage is contained within the sandbox.</p>",
                        "image": "https://images.unsplash.com/photo-1593441139884-faf2c88c7c97?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 18: Third-Party Security Hardening Platform",
                        "language": "yaml",
                        "code": "# Example of a CI/CD security gate policy for an SCA tool\n\n# This policy will be enforced on every pull request.\n\npolicy:\n  # Fail the build if any of these conditions are met:\n  fail_on:\n    - severity: 'critical'\n    - severity: 'high'\n      # ... but only if a fix is available.\n      fixable: true \n\n  # Ignore vulnerabilities below a certain severity\n  ignore_threshold:\n    severity: 'medium'"
                    },
                    {
                        "title": "Code Example 18: Component Security Management System",
                        "language": "json",
                        "code": "{\n  \"component\": \"apache-struts-2.3.20\",\n  \"type\": \"COTS\",\n  \"status\": \"UNSUPPORTED\",\n  \"hardening_plan\": {\n    \"short_term\": \"Place the application behind a WAF with a strict virtual patching policy for all known Struts vulnerabilities.\",\n    \"long_term\": \"This component is end-of-life and must be removed. The application must be migrated to a modern framework like Spring Boot.\",\n    \"risk_acceptance\": {\n      \"is_accepted\": true,\n      \"owner\": \"business_unit_vp\",\n      \"expiry\": \"2026-12-31\"\n    }\n  }\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "The process of automatically scanning an application's open-source libraries for known vulnerabilities is known as:",
                        "options": [
                            "Software Composition Analysis (SCA)",
                            "Static Application Security Testing (SAST)",
                            "Dynamic Application Security Testing (DAST)",
                            "Penetration Testing"
                        ],
                        "correct": 0,
                        "explanation": "SCA is the specific tool category that focuses on securing the third-party components that make up the software supply chain."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary goal of integrating an SCA tool into the CI/CD pipeline?",
                        "options": [
                            "To slow down the build.",
                            "To find vulnerabilities in your custom code.",
                            "To act as a security gate that prevents code with vulnerable dependencies from being merged and deployed.",
                            "To manage user accounts."
                        ],
                        "correct": 2,
                        "explanation": "Integrating SCA into the pipeline provides a continuous, automated check on the security of your software supply chain, providing fast feedback to developers and preventing known vulnerabilities from reaching production."
                    },
                    {
                        "id": 3,
                        "question": "A tool like GitHub's Dependabot hardens your application by:",
                        "options": [
                            "Scanning your code for bugs.",
                            "Automatically creating pull requests to update your dependencies to patched versions.",
                            "Monitoring your application in production.",
                            "Configuring your firewall."
                        ],
                        "correct": 1,
                        "explanation": "Automated dependency updating is a key hardening practice. It reduces the window of exposure by making it easy for developers to apply security patches to their third-party components."
                    },
                    {
                        "id": 4,
                        "question": "Running a risky file processing library in a separate, isolated container with no network access is a hardening technique known as:",
                        "options": [
                            "Sandboxing",
                            "Encryption",
                            "Authentication",
                            "Logging"
                        ],
                        "correct": 0,
                        "explanation": "Sandboxing is a powerful isolation technique. It is an application of the principle of least privilege, designed to contain the damage if a specific, high-risk component is compromised."
                    }
                ]
            }
        },
        {
            "id": "lesson-19",
            "title": "Configuration Management Hardening",
            "duration": "90 min",
            "objectives": [
                "Learn to create and enforce secure configuration baselines.",
                "Use Infrastructure as Code (IaC) to automate and harden configuration.",
                "Design a process for detecting and preventing configuration drift.",
                "Harden the security of the configuration management system itself."
            ],
            "content": {
                "overview": "An application's security depends heavily on the configuration of its environment. A misconfiguration can create a vulnerability just as easily as a bug in the code. This lesson covers how to harden the entire configuration management lifecycle, using automation to build, maintain, and verify a secure state.",
                "sections": [
                    {
                        "title": "Secure Configuration Baselines",
                        "content": "<p>A secure baseline is a standardized, documented, and hardened configuration for a particular type of system (e.g., a 'hardened Ubuntu 22.04' baseline or a 'secure NGINX' baseline). The goal is to ensure that all systems of the same type are built to the same, secure standard.</p><p>These baselines should be based on industry standards like the CIS Benchmarks and should be implemented as code using a configuration management tool.</p>",
                        "image": "https://images.unsplash.com/photo-1510915228340-29c85a43dcfe?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Infrastructure as Code (IaC) Security",
                        "content": "<p>IaC is the foundation of modern, hardened configuration management. By defining your infrastructure (servers, firewalls, databases) as code (e.g., in Ansible or Terraform), you gain several security benefits:</p><ul><li><strong>Repeatability:</strong> Every environment is built exactly the same way every time.</li><li><strong>Auditability:</strong> The code acts as a single source of truth for the configuration. Every change is captured in the version control history.</li><li><strong>Automated Testing:</strong> You can use IaC scanners in your CI/CD pipeline to automatically check your configuration code for security flaws before it is ever deployed.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Configuration Drift Prevention",
                        "content": "<p>Configuration drift is when a manual, out-of-band change is made to a system, causing its live configuration to 'drift' away from the desired state defined in the code. This is a major security risk as these manual changes bypass all the testing and reviews in the pipeline.</p><h3>Hardening Against Drift:</h3><ul><li><strong>Immutable Infrastructure:</strong> The best defense. In this model, servers are never modified after they are deployed. To make a change, you update the IaC code and deploy a brand new, replacement server.</li><li><strong>Continuous Enforcement:</strong> Run your configuration management tool (e.g., Ansible) on a regular schedule to re-apply the secure baseline and automatically correct any drift.</li><li><strong>Detection:</strong> Use a CSPM or other monitoring tool to continuously scan for and alert on any detected configuration drift.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1573497175235-d3648a07b388?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 19: Configuration Security Hardening Lab",
                        "language": "yaml",
                        "code": "# Example Ansible role to apply a secure baseline for SSH\n\n- name: Harden SSH Server\n  hosts: all\n  become: yes\n  \n  tasks:\n    - name: Ensure SSH protocol is 2\n      lineinfile:\n        path: /etc/ssh/sshd_config\n        regexp: \"^#?Protocol\"\n        line: \"Protocol 2\"\n\n    - name: Ensure root login is disabled\n      lineinfile:\n        path: /etc/ssh/sshd_config\n        regexp: \"^#?PermitRootLogin\"\n        line: \"PermitRootLogin no\"\n\n    - name: Ensure password authentication is disabled (only allow key-based auth)\n      lineinfile:\n        path: /etc/ssh/sshd_config\n        regexp: \"^#?PasswordAuthentication\"\n        line: \"PasswordAuthentication no\"\n      notify: restart sshd"
                    },
                    {
                        "title": "Code Example 19: Configuration Security Automation Framework",
                        "language": "hcl",
                        "code": "# Example of using Terraform to prevent drift\n\n# Terraform keeps a 'state file' that records the last known state of the infrastructure it manages.\n\n# When you run `terraform plan`, Terraform compares the desired state (your code)\n# with the last known state (the state file) AND the actual state (by querying the cloud provider's API).\n\n# If a manual change was made, the plan will show it as drift.\n# For example:\n\n# An execution plan has been generated and is shown below.\n# ~\n#   ~ aws_security_group.my_sg\n#       ingress {\n#         - cidr_blocks = [\"10.0.0.0/16\"]\n#         + cidr_blocks = [\"0.0.0.0/0\"] # Manual change detected!\n#       }\n\n# Running `terraform apply` will then revert this manual change, enforcing the secure state defined in the code."
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "A standardized, documented, and hardened configuration for a type of system (like a web server) is known as a:",
                        "options": [
                            "Secure Baseline",
                            "Vulnerability",
                            "Risk Assessment",
                            "Firewall"
                        ],
                        "correct": 0,
                        "explanation": "A secure baseline, often based on a standard like the CIS Benchmarks, is the foundation of a hardened configuration management program. It provides a repeatable, verifiable standard for all systems."
                    },
                    {
                        "id": 2,
                        "question": "The practice of defining and provisioning infrastructure using version-controlled, machine-readable files is known as:",
                        "options": [
                            "Infrastructure as Code (IaC)",
                            "Manual Configuration",
                            "Incident Response",
                            "Software Composition Analysis"
                        ],
                        "correct": 0,
                        "explanation": "IaC is a core DevOps and security practice. It allows infrastructure configuration to be treated with the same rigor as application code, including automated testing and peer review."
                    },
                    {
                        "id": 3,
                        "question": "When a production server's live configuration deviates from the state defined in its IaC code due to a manual change, this is known as:",
                        "options": [
                            "Configuration Drift",
                            "A successful deployment",
                            "A secure baseline",
                            "A feature"
                        ],
                        "correct": 0,
                        "explanation": "Configuration drift is a major risk because it represents an unaudited and untested change that has bypassed the secure pipeline. The best defense is an immutable infrastructure model."
                    },
                    {
                        "id": 4,
                        "question": "What is the best defense against configuration drift?",
                        "options": [
                            "Allowing all engineers to make manual changes in production.",
                            "Never updating the servers.",
                            "An 'immutable infrastructure' model, where servers are never changed in place but are replaced with new ones built from the updated IaC.",
                            "Disabling all monitoring."
                        ],
                        "correct": 2,
                        "explanation": "The immutable infrastructure pattern is the ultimate defense against drift. By treating servers as disposable and building fresh from the version-controlled code every time, you guarantee that the running state always matches the desired, tested state."
                    }
                ]
            }
        },
        {
            "id": "lesson-20",
            "title": "Logging and Monitoring Hardening",
            "duration": "90 min",
            "objectives": [
                "Understand the importance of comprehensive security logging.",
                "Design a hardened, centralized logging architecture.",
                "Implement log integrity and protection mechanisms.",
                "Optimize a SIEM for effective real-time monitoring and alerting."
            ],
            "content": {
                "overview": "Effective logging and monitoring are the foundation of incident detection and response. Hardening the logging and monitoring infrastructure is a critical task to ensure that you have a complete, accurate, and trustworthy record of events when an incident occurs. This lesson covers the architecture for building a resilient and secure monitoring program.",
                "sections": [
                    {
                        "title": "Comprehensive Security Logging",
                        "content": "<p>You can't detect an attack if you don't have the data. The first step of hardening is to ensure you are collecting the right logs from all critical sources.</p><h3>Key Sources:</h3><ul><li><strong>OS Logs:</strong> Authentication events, process creation, system errors.</li><li><strong>Application Logs:</strong> Application-level security events (e.g., authorization failures).</li><li><strong>Network Logs:</strong> Firewall accepts/denies, VPC Flow Logs.</li><li><strong>Cloud Audit Logs:</strong> All API calls and management actions.</li><li><strong>Database Logs:</strong> Audit logs of privileged access and access to sensitive data.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1581291518857-4e27b48ff24e?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Log Integrity and Protection",
                        "content": "<p>An attacker's first move after compromising a system is often to delete or modify the local logs to cover their tracks. The logging architecture must be hardened to prevent this.</p><h3>The Centralized Logging Pattern:</h3><ol><li><strong>Real-time Forwarding:</strong> Configure all systems to immediately forward their logs to a remote, centralized log aggregator or SIEM. Do not let logs sit on the local disk.</li><li><strong>Dedicated Logging Account:</strong> The central logging platform should be in its own, highly restricted network segment or cloud account.</li><li><strong>Append-Only Storage:</strong> The storage for the central logs should be configured to be append-only or immutable. This means that once a log is written, it cannot be modified or deleted, even by an administrator. This creates a secure, tamper-resistant audit trail.</li></ol>",
                        "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "SIEM Integration and Optimization",
                        "content": "<p>A SIEM (Security Information and Event Management) system is the brain of the monitoring program. It must be hardened and optimized.</p><h3>Hardening Steps:</h3><ul><li><strong>Secure the SIEM Itself:</strong> The SIEM is a critical, privileged system. Access to it must be tightly controlled with MFA and least privilege.</li><li><strong>Normalize the Data:</strong> Ensure that logs from all different sources are being correctly parsed and normalized into a common format. Without this, your correlation rules will not work.</li><li><strong>Tune the Rules:</strong> The biggest challenge with a SIEM is the noise from false positive alerts. Continuously tune the correlation rules to reduce false positives and ensure that the alerts being generated are high-fidelity and actionable.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 20: Security Monitoring Hardening Workshop",
                        "language": "json",
                        "code": "// Example of an AWS S3 Bucket Policy to create an append-only log store\n\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Sid\": \"Allow a specific logging service to write\",\n            \"Effect\": \"Allow\",\n            \"Principal\": {\"Service\": \"logging.amazonaws.com\"},\n            \"Action\": \"s3:PutObject\",\n            \"Resource\": \"arn:aws:s3:::secure-central-logs/*\"\n        },\n        {\n            \"Sid\": \"Explicitly deny all delete and modify actions\",\n            \"Effect\": \"Deny\",\n            \"Principal\": \"*\",\n            \"Action\": [\n                \"s3:DeleteObject\",\n                \"s3:PutBucketPolicy\" // Prevent changing this policy\n            ],\n            \"Resource\": \"arn:aws:s3:::secure-central-logs/*\"\n        }\n    ]\n}"
                    },
                    {
                        "title": "Code Example 20: Advanced Security Monitoring Platform",
                        "language": "plaintext",
                        "code": "/*\n  Reviewing a SIEM Correlation Rule for Tuning\n\n  Original Rule:\n  - 'Alert whenever a user has a failed login.'\n\n  Problem:\n  - This rule generates thousands of low-value, noisy alerts every day because users\n    frequently mistype their passwords.\n\n  Tuned, Hardened Rule:\n  - 'Alert ONLY IF a single user has more than 5 failed logins in 1 minute FROM a single source IP.'\n\n  Result:\n  - The new rule is much higher-fidelity. It no longer alerts on simple typos, but it will\n    still fire on a potential brute-force attack, which is the actual threat we care about.\n    This reduces analyst fatigue and allows them to focus on real incidents.\n*/"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary reason to ship logs in real-time to a centralized, remote server?",
                        "options": [
                            "To use more network bandwidth.",
                            "To make it easier for developers to debug.",
                            "To protect the integrity of the logs from an attacker who has compromised the source server and might try to delete them.",
                            "To save disk space on the source server."
                        ],
                        "correct": 2,
                        "explanation": "This is the most critical aspect of hardening a logging architecture. An attacker will almost always try to cover their tracks by tampering with local logs. Centralizing them makes this much more difficult."
                    },
                    {
                        "id": 2,
                        "question": "A storage location for logs that is configured so that data, once written, cannot be altered or deleted for a set period, even by an administrator, is known as:",
                        "options": [
                            "Append-only or immutable storage",
                            "A standard file share",
                            "A temporary directory",
                            "A database"
                        ],
                        "correct": 0,
                        "explanation": "Immutability provides the strongest guarantee of log integrity. It is a critical control for ensuring you have a trustworthy audit trail for compliance and forensic investigations."
                    },
                    {
                        "id": 3,
                        "question": "The process of tuning a SIEM's correlation rules is primarily focused on:",
                        "options": [
                            "Generating as many alerts as possible.",
                            "Reducing the number of low-value false positive alerts to allow analysts to focus on real threats.",
                            "Making the SIEM's user interface look better.",
                            "Collecting more logs."
                        ],
                        "correct": 1,
                        "explanation": "Alert fatigue is a major problem in security operations. A well-hardened and tuned SIEM is one that produces a low volume of high-fidelity, actionable alerts."
                    },
                    {
                        "id": 4,
                        "question": "The process of converting logs from many different formats into a single, standard format so that a correlation rule can be applied to them is known as:",
                        "options": [
                            "Log Deletion",
                            "Log Encryption",
                            "Log Normalization (or Parsing)",
                            "Log Storage"
                        ],
                        "correct": 2,
                        "explanation": "Normalization is the essential step that makes a SIEM work. It creates the common language that allows the correlation engine to find patterns across disparate data sources."
                    }
                ]
            }
        },
        {
            "id": "lesson-21",
            "title": "Backup and Recovery Security Hardening",
            "duration": "90 min",
            "objectives": [
                "Understand the critical role of backups in a ransomware defense strategy.",
                "Architect a hardened backup solution using the 3-2-1 rule.",
                "Implement backup encryption and integrity verification.",
                "Design a secure and testable disaster recovery and incident recovery plan."
            ],
            "content": {
                "overview": "In the age of ransomware, backups are no longer just for disaster recovery; they are a critical last line of security defense. If an attacker encrypts all of your production data, a secure and isolated backup may be the only thing that saves your business. This lesson covers how to harden the architecture of your backup and recovery systems.",
                "sections": [
                    {
                        "title": "Backup Security Implementation",
                        "content": "<p>The classic best practice for backups is the <strong>3-2-1 Rule</strong>, which is more relevant than ever.</p><ul><li>Have at least **3** copies of your data (1 production copy and 2 backup copies).</li><li>Store the copies on **2** different types of media (e.g., cloud object storage and physical tape).</li><li>Keep **1** copy completely **off-site and offline/air-gapped**.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1579532537598-459ecdaf39cc?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Backup Encryption and Protection",
                        "content": "<p>Ransomware is designed to find and encrypt backups. The backup system itself must be hardened against this.</p><h3>Key Hardening Techniques:</h3><ul><li><strong>Network Isolation:</strong> The backup server and storage should be in a separate, highly restricted network segment. The production environment should only be able to push backups to it; the backup system should not be able to initiate connections back to production.</li><li><strong>Immutable Backups:</strong> This is a critical modern control. Use a storage system (like AWS S3 with Object Lock) that can make your backups immutable. This means that once a backup is written, it cannot be encrypted, modified, or deleted for a set period, even by an account with administrator privileges.</li><li><strong>Encryption:</strong> All backups must be encrypted, both in transit to the backup storage and at rest within it. The keys for the backup encryption should be managed separately from the production keys.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Recovery Testing and Validation",
                        "content": "<p>A backup that has never been tested is not a backup. The hardening process must include regular, automated testing of the recovery process.</p><h3>The process:</h3><p>On a regular schedule (e.g., quarterly), an automated process should:</p><ol><li>Provision a new, isolated test environment.</li><li>Select a random set of servers or a full application from the latest backup.</li><li>Perform a full restore of that system into the isolated environment.</li><li>Run a set of automated tests to verify the integrity of the data and the functionality of the restored application.</li><li>Tear down the test environment.</li></ol><p>This provides continuous assurance that your backups are viable and your recovery process works.</p>",
                        "image": "https://images.unsplash.com/photo-1517245386807-bb43f82c33c4?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 21: Backup Security Hardening Implementation",
                        "language": "plaintext",
                        "code": "/*\n  Hardened Backup Architecture for Ransomware Resilience\n\n  1.  **Production Environment (VPC-Prod):**\n      - Production servers run here.\n      - A backup agent is installed on each server.\n\n  2.  **Backup Environment (VPC-Backup):**\n      - This VPC is completely separate from production.\n      - It contains the central backup server.\n      - The firewall rules only allow inbound connections on the backup port from VPC-Prod.\n      - No outbound connections are allowed from VPC-Backup to VPC-Prod.\n\n  3.  **Primary Backup Storage (in VPC-Backup):**\n      - The backup server writes backups to a local disk repository.\n\n  4.  **Off-site Immutable Copy (in a separate Cloud Account):**\n      - After the local backup completes, the backup server uses a one-way, least-privilege credential\n        to copy the backup data to an S3 bucket in a completely separate, isolated AWS account.\n      - This S3 bucket has 'Object Lock' (immutability) enabled.\n\n  Result: Even if an attacker gains full administrative control of the production environment\n  and the primary backup server, they cannot access, modify, or delete the immutable copies\n  of the backups stored in the separate account.\n*/"
                    },
                    {
                        "title": "Code Example 21: Secure Backup and Recovery Framework",
                        "language": "shell",
                        "code": "# Conceptual script for a recovery test\n\n# 1. Provision an isolated test network\nterraform apply ./terraform/recovery-test-env\n\n# 2. Restore the latest database backup into the test environment\n./backup-tool --restore --source latest --destination recovery-db-server\n\n# 3. Run a data integrity check\n./db-integrity-check --db recovery-db-server\n\n# 4. Run application health checks\n./app-health-check --app recovery-app-server\n\n# 5. Report results\n# ...\n\n# 6. Clean up the environment\nterraform destroy ./terraform/recovery-test-env"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "The 3-2-1 backup rule states that you should have at least 3 copies of your data, on 2 different media, with at least 1 copy being:",
                        "options": [
                            "On the same server",
                            "In the same building",
                            "Off-site and preferably offline/air-gapped",
                            "Unencrypted"
                        ],
                        "correct": 2,
                        "explanation": "The off-site, offline copy is the most important part of the rule. It protects your data from a site-wide disaster (like a fire or flood) and from a ransomware attack that encrypts all online systems."
                    },
                    {
                        "id": 2,
                        "question": "What is the most effective modern control for protecting backups from being encrypted by ransomware?",
                        "options": [
                            "Storing the backups on the same server as the production data.",
                            "Using immutable storage that makes the backups unchangeable for a set period.",
                            "Giving the ransomware administrator access to the backup server.",
                            "Not making any backups."
                        ],
                        "correct": 1,
                        "explanation": "Immutability is a critical defense. It leverages the storage system's own controls to create a write-once-read-many (WORM) state, which prevents even a compromised administrator account from deleting or encrypting the backups."
                    },
                    {
                        "id": 3,
                        "question": "What is the only way to be confident that your backups and your recovery plan will work in a real emergency?",
                        "options": [
                            "By hoping for the best.",
                            "By reading the backup software's manual.",
                            "By performing regular, automated recovery tests.",
                            "By trusting that the backups are probably fine."
                        ],
                        "correct": 2,
                        "explanation": "A backup that hasn't been tested is not a reliable backup. Regular testing is the only way to validate the entire recovery chain—the integrity of the data, the functionality of the restore process, and the correctness of the documented plan."
                    },
                    {
                        "id": 4,
                        "question": "From a network hardening perspective, the backup environment should be:",
                        "options": [
                            "In the same network segment as the production servers.",
                            "Open to the entire internet.",
                            "In a separate, highly isolated network segment with very restrictive firewall rules.",
                            "On the same server as the domain controller."
                        ],
                        "correct": 2,
                        "explanation": "Network isolation is a key hardening principle for backups. You want to make it as difficult as possible for an attacker who has compromised the production environment to move laterally and access the backup infrastructure."
                    }
                ]
            }
        },
        {
            "id": "lesson-22",
            "title": "Performance vs. Security Optimization",
            "duration": "90 min",
            "objectives": [
                "Understand the performance trade-offs of different hardening controls.",
                "Learn to optimize the performance of hardened applications.",
                "Analyze the security implications of performance-enhancing technologies like caching.",
                "Develop a risk-based framework for balancing security and performance requirements."
            ],
            "content": {
                "overview": "Hardening an application often involves adding security controls that can introduce performance overhead. It's a common concern that a 'hardened' application will be a 'slow' application. This lesson covers the strategies for implementing strong security while minimizing the performance impact, and how to make intelligent, risk-based decisions when a conflict arises.",
                "sections": [
                    {
                        "title": "Security Performance Impact Analysis",
                        "content": "<p>It's important to understand which controls have a significant impact and which do not.</p><h3>Performance Impact:</h3><ul><li><strong>Low Impact:</strong> Most configuration hardening (e.g., secure OS baselines, least privilege file permissions) has a negligible impact on performance.</li><li><strong>Variable Impact:</strong><ul><li><strong>Encryption:</strong> Modern CPUs with hardware acceleration (AES-NI) make encryption at rest very fast. TLS for data in transit adds a small amount of latency for the initial handshake.</li><li><strong>Logging:</strong> Verbose logging can impact performance if not implemented correctly (e.g., by writing to disk synchronously).</li></ul></li><li><strong>Potentially High Impact:</strong><ul><li><strong>Runtime Agents (RASP/EDR):</strong> These add a small but measurable overhead.</li><li><strong>Network Inspection (WAF/IDS):</strong> A poorly configured or undersized network security appliance can become a major bottleneck.</li></ul></li></ul>",
                        "image": "https://images.unsplash.com/photo-1542382257-80deda0e5d99?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Caching Security Considerations",
                        "content": "<p>Caching is one of the most effective ways to improve performance, but it can be a major security risk if not implemented carefully.</p><h3>The Risk:</h3><p>The primary risk is the caching of sensitive, user-specific data in a shared cache. This could lead to one user being served another user's private information.</p><h3>Hardening the Cache:</h3><ul><li><strong>Cache Public Data Only:</strong> The simplest and safest rule. Only cache data that is truly public and not specific to any user.</li><li><strong>Cache Keys:</strong> If you must cache user-specific data, ensure that the user's ID is part of the cache key, so there is no possibility of a collision.</li><li><strong>Cache-Control Headers:</strong> Use HTTP headers like `Cache-Control: private, no-store` to instruct browsers and downstream proxies not to cache sensitive responses.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1593441139884-faf2c88c7c97?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Scalability with Security Hardening",
                        "content": "<p>A hardened architecture must be a scalable architecture.</p><h3>Key Principles:</h3><ul><li><strong>Use Managed Services:</strong> Offload security functions to scalable, cloud-native managed services where possible (e.g., use AWS Shield instead of running your own DDoS protection).</li><li><strong>Horizontal Scaling:</strong> Ensure that all your security components (like virtual firewalls) can be deployed in a horizontally scalable cluster behind a load balancer.</li><li><strong>Performance Testing:</strong> Your performance testing process must be conducted on a fully hardened environment. Testing on an un-hardened 'dev' environment will not give you an accurate picture of your production performance.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 22: Performance-Security Optimization Lab",
                        "language": "plaintext",
                        "code": "/*\n  Performance Test Results: WAF Impact\n\n  Scenario: A load test was run against the application's login API endpoint.\n\n  Test 1: Without WAF enabled\n  - Average Response Time: 150ms\n  - Requests per Second: 1,200\n\n  Test 2: With WAF enabled (full OWASP Top 10 ruleset)\n  - Average Response Time: 185ms\n  - Requests per Second: 1,050\n\n  Analysis:\n  - The WAF adds approximately 35ms of latency (a 23% increase).\n  - The maximum throughput is reduced by 12.5%.\n\n  Decision:\n  - The performance impact is acceptable given the critical risk reduction provided by the WAF.\n  - The capacity plan for the production environment will be adjusted to account for the 12.5% throughput reduction.\n*/"
                    },
                    {
                        "title": "Code Example 22: Performance-Aware Security Hardening Tool",
                        "language": "http",
                        "code": "// HTTP Response Header to prevent caching of sensitive data\n\nHTTP/1.1 200 OK\n\n// This tells the browser and any intermediate caches that this response is private\n// to the user and should not be stored.\nCache-Control: no-cache, no-store, must-revalidate\nPragma: no-cache\nExpires: 0"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "Which of the following hardening controls typically has the most significant potential for performance impact?",
                        "options": [
                            "Setting a secure file permission.",
                            "Disabling an unused service.",
                            "A real-time network traffic inspection device like a WAF or an IDS.",
                            "Enforcing a strong password policy."
                        ],
                        "correct": 2,
                        "explanation": "In-line network security devices that have to inspect every single packet of a request and response can introduce latency. This is why it's critical to properly size and scale these components."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary security risk of an improperly configured application cache?",
                        "options": [
                            "The application might run too slowly.",
                            "Sensitive, user-specific data could be stored in the shared cache and served to other users.",
                            "The cache could use too much memory.",
                            "The application might run too quickly."
                        ],
                        "correct": 1,
                        "explanation": "This is a serious information disclosure vulnerability. The caching logic must be carefully designed to ensure that only public, non-sensitive data is ever cached."
                    },
                    {
                        "id": 3,
                        "question": "The best way to ensure your application meets its performance goals is to:",
                        "options": [
                            "Conduct performance tests on a developer's laptop with no security controls enabled.",
                            "Guess at the capacity needed.",
                            "Conduct performance tests in a staging environment that is a fully hardened, production-like replica.",
                            "Disable all security controls in production to make it faster."
                        ],
                        "correct": 2,
                        "explanation": "You must test what you fly. Performance testing must be done on an environment that is as close as possible to the final production environment, including all the security hardening and monitoring agents, to get an accurate result."
                    },
                    {
                        "id": 4,
                        "question": "The use of hardware acceleration (AES-NI) in modern CPUs means that the performance impact of enabling encryption at rest for a database is:",
                        "options": [
                            "Very high, often making it unusable.",
                            "Negligible for most workloads.",
                            "It makes the database faster.",
                            "It deletes the data in the database."
                        ],
                        "correct": 1,
                        "explanation": "AES-NI offloads the cryptographic work to dedicated hardware on the CPU, which makes the process extremely fast. The performance argument is no longer a valid reason not to encrypt data at rest."
                    }
                ]
            }
        },
        {
            "id": "lesson-23",
            "title": "Incident Response Integration",
            "duration": "90 min",
            "objectives": [
                "Understand how application hardening aids in incident detection and response.",
                "Design hardened systems that are forensically ready.",
                "Implement automated containment strategies based on hardening controls.",
                "Integrate lessons learned from incidents to continuously improve hardening."
            ],
            "content": {
                "overview": "Application hardening is a proactive defense, but it also plays a critical role in reactive defense. A well-hardened application is not only harder to compromise, but it is also easier to defend. It generates better telemetry and provides the tools for a fast and effective incident response. This lesson covers how to integrate hardening with your incident response program.",
                "sections": [
                    {
                        "title": "Incident Detection and Response Capabilities",
                        "content": "<p>A hardened application makes an attacker's job much harder and noisier, which improves your ability to detect them.</p><h3>How Hardening Helps Detection:</h3><ul><li><strong>Reduced Noise:</strong> A hardened system with minimal services and a locked-down configuration generates far less 'normal' log noise. This makes it much easier for a SIEM or an analyst to spot the anomalous signals of an attack.</li><li><strong>Better Audit Trails:</strong> A hardened logging configuration ensures that the right events are being recorded to provide a clear audit trail of an attacker's actions.</li><li><strong>Tamper Resistance:</strong> Hardened log protection prevents an attacker from deleting the evidence of their intrusion.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Forensics Data Preservation",
                        "content": "<p>A hardened system is 'forensically ready'. The configuration and tools are already in place to capture the evidence needed for an investigation.</p><h3>Architectural Enablers:</h3><ul><li><strong>Logging:</strong> Comprehensive logging is the most critical forensic resource.</li><li><strong>Endpoint Agents (EDR):</strong> The EDR agent on a hardened server provides the ability to remotely and safely acquire memory and disk images for forensic analysis.</li><li><strong>Snapshots:</strong> In a virtualized or cloud environment, the ability to take a snapshot of a running system provides a perfect, bit-for-bit copy of the evidence.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1454165804606-c3d57bc86b40?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Incident Containment Strategies",
                        "content": "<p>Hardening controls can be used to rapidly contain an incident and prevent it from spreading.</p><h3>Examples:</h3><ul><li><strong>Network Segmentation:</strong> A well-segmented network is the best containment control. If a web server is compromised, the firewall rules will prevent the attacker from immediately accessing the database.</li><li><strong>Least Privilege:</strong> If a compromised application is running with a least-privilege service account, the attacker's ability to do damage is severely limited.</li><li><strong>Automated Response:</strong> The controls on a hardened system can be triggered automatically by a SOAR platform. For example, the SOAR can call the host-based firewall on a compromised machine to automatically isolate it from the network.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 23: Incident Response Integration Workshop",
                        "language": "markdown",
                        "code": "# Incident Response Playbook: Compromised Web Server\n\n**Detection:** EDR alerts on a suspicious PowerShell command on `web-server-01`.\n\n**Containment Steps:**\n1.  **[Automated]** The SOAR platform triggers a playbook.\n2.  **[Leverages Hardening]** The playbook calls the EDR agent's API to isolate the host. The agent uses the host-based firewall to block all network connections except to the EDR console.\n3.  **[Leverages Hardening]** The playbook calls the cloud provider's API to take a forensic snapshot of the server's disk.\n\n**Investigation:**\n- The analyst reviews the comprehensive logs from the server (which were being centrally collected) to determine the attacker's actions.\n\n**Lessons Learned -> Improved Hardening:**\n- The root cause was a missing application patch. The patching SLA for critical web servers is changed from 30 days to 7 days."
                    },
                    {
                        "title": "Code Example 23: Automated Incident Response Framework",
                        "language": "python",
                        "code": "import edr_api\nimport siem_api\n\ndef contain_host(hostname, incident_id):\n    \"\"\"An automated playbook to contain a compromised host.\"\"\"\n\n    # 1. Use the EDR agent to isolate the host from the network.\n    # This is a key containment action that leverages a hardening control.\n    print(f\"Isolating host: {hostname}\")\n    edr_api.isolate_host(hostname)\n\n    # 2. Add details to the incident ticket.\n    siem_api.add_comment(\n        incident_id=incident_id,\n        comment=f\"Host {hostname} has been automatically isolated from the network.\"\n    )\n\n    return \"SUCCESS\""
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "How does a well-hardened system aid in incident detection?",
                        "options": [
                            "It generates more log noise, making it harder to find threats.",
                            "It reduces the amount of normal 'noise', making the anomalous signals of an attack easier to spot.",
                            "It has no impact on detection.",
                            "It disables all logging."
                        ],
                        "correct": 1,
                        "explanation": "A hardened system has fewer running services and a tighter configuration. This means its normal behavior is much more predictable, so any deviation from that baseline (i.e., an attacker's activity) stands out more clearly."
                    },
                    {
                        "id": 2,
                        "question": "Which hardening control is the most effective for containing an incident and preventing an attacker's lateral movement?",
                        "options": [
                            "Strong password policies.",
                            "File integrity monitoring.",
                            "Network segmentation.",
                            "Encrypting the hard drive."
                        ],
                        "correct": 2,
                        "explanation": "Network segmentation is the primary containment control. Even if an attacker compromises one machine, strong firewall rules can prevent them from ever reaching other, more sensitive parts of the network, effectively stopping the attack from spreading."
                    },
                    {
                        "id": 3,
                        "question": "A system that is configured with comprehensive logging and an EDR agent is known as being:",
                        "options": [
                            "Forensically ready",
                            "Unhardened",
                            "Vulnerable",
                            "Offline"
                        ],
                        "correct": 0,
                        "explanation": "Forensic readiness means that the system is pre-configured with the tools and data sources needed to perform an effective investigation. It's a key outcome of a good hardening program."
                    },
                    {
                        "id": 4,
                        "question": "The 'lessons learned' from an incident response should be used to do what?",
                        "options": [
                            "To blame the person who made a mistake.",
                            "To create a report that is never read again.",
                            "To drive specific improvements to the hardening baselines and security controls to prevent the same incident from happening again.",
                            "To justify a smaller security budget."
                        ],
                        "correct": 2,
                        "explanation": "This is the critical feedback loop. Every incident is a learning opportunity. The root cause of the incident should be used to create a concrete action item that improves the proactive hardening of the system."
                    }
                ]
            }
        },
        {
            "id": "lesson-24",
            "title": "Compliance and Regulatory Hardening",
            "duration": "90 min",
            "objectives": [
                "Understand how system hardening is a key control for meeting compliance requirements.",
                "Map specific hardening controls to regulations like PCI DSS and HIPAA.",
                "Automate the testing and evidence collection for hardening compliance.",
                "Use industry standards like CIS Benchmarks to achieve a compliant state."
            ],
            "content": {
                "overview": "For most organizations, a primary driver for hardening is the need to comply with industry regulations and standards. A well-hardened system is a compliant system. This lesson covers how to use hardening to meet specific compliance requirements and how to automate the process of proving that compliance to auditors.",
                "sections": [
                    {
                        "title": "Regulatory Compliance Mapping",
                        "content": "<p>System hardening is a foundational control that is required by nearly every major security framework and regulation.</p><h3>Example Mapping: PCI DSS</h3><ul><li><strong>Requirement 2:</strong> Do not use vendor-supplied defaults for system passwords and other security parameters. -> **Hardening Control:** A hardening baseline must include changing all default passwords.</li><li><strong>Requirement 2.2:</strong> Develop configuration standards... Harden systems by removing all unnecessary functionality. -> **Hardening Control:** This is the definition of attack surface reduction and applying a secure baseline.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1590102426319-c72115b5a832?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Industry-Specific Hardening",
                        "content": "<h3>HIPAA (Healthcare):</h3><p>The HIPAA Security Rule has specific technical safeguards that are met by hardening. For example, the requirement for 'Audit Controls' is met by hardening the OS logging configuration. The requirement for 'Person or Entity Authentication' is met by hardening the system to require strong passwords.</p><h3>CIS Benchmarks and Compliance:</h3><p>The CIS Benchmarks are so widely respected that they are explicitly referenced by many other frameworks. For example, PCI DSS states that a system's configuration must be hardened 'based on industry-accepted system hardening standards'. The CIS Benchmarks are the most common standard used to meet this requirement.</p>",
                        "image": "https://images.unsplash.com/photo-1533285809283-0a7c6177ac43?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Compliance Testing Automation",
                        "content": "<p>Manually checking hundreds of hardening controls on thousands of servers is impossible. Compliance testing must be automated. This is 'Compliance as Code'.</p><h3>The Tools:</h3><ul><li><strong>Configuration Management (e.g., Ansible):</strong> The same tool used to apply the hardening can also be used to check it. You can run the hardening playbook in a 'check mode' that reports on any deviations.</li><li><strong>Specialized Compliance Scanners:</strong> Tools like Nessus or OpenSCAP can perform an authenticated scan of a system and generate a detailed report showing its compliance status against a specific baseline, like the CIS Benchmarks.</li><li><strong>CSPM (for Cloud):</strong> A CSPM is essentially a compliance-as-code engine for the cloud environment itself.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1510915228340-29c85a43dcfe?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 24: Compliance Hardening Implementation",
                        "language": "ruby",
                        "code": "# Example of a Compliance as Code test using InSpec\n# This test automatically verifies a specific control from the CIS Benchmark for Linux.\n\ncontrol 'cis-benchmark-5.2.4' do\n  impact 1.0\n  title 'Ensure SSH root login is disabled'\n  desc 'Disabling root login via SSH is a key security control to prevent brute-force attacks against the most powerful user.'\n  \n  # The test checks the live configuration of the SSH daemon.\n  describe sshd_config do\n    its('PermitRootLogin') { should eq 'no' }\n  end\nend\n\n# This automated test provides a direct, verifiable piece of evidence for an auditor."
                    },
                    {
                        "title": "Code Example 24: Compliance Automation and Validation Platform",
                        "language": "json",
                        "code": "{\n  \"assetId\": \"prod-db-01\",\n  \"benchmark\": \"CIS Oracle MySQL Community Server 8.0 Benchmark v1.0.0\",\n  \"complianceScore\": \"88%\",\n  \"failedControls\": [\n    {\n      \"controlId\": \"2.1.2\",\n      \"severity\": \"High\",\n      \"description\": \"Ensure the 'validate_password' component is enabled.\",\n      \"status\": \"FAILED\"\n    }\n  ],\n  \"evidence\": {\n    \"report_link\": \"https://scanner.example.com/reports/12345.pdf\"\n  }\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "Which industry standard provides detailed, step-by-step guides for hardening a wide variety of operating systems and applications?",
                        "options": [
                            "The OWASP Top 10",
                            "The CIS Benchmarks",
                            "The MITRE ATT&CK Framework",
                            "The NIST Cybersecurity Framework"
                        ],
                        "correct": 1,
                        "explanation": "The CIS Benchmarks are the de facto industry standard for secure configuration. They provide prescriptive, actionable guidance that is widely used as the basis for hardening programs and compliance audits."
                    },
                    {
                        "id": 2,
                        "question": "PCI DSS Requirement 6, which mandates the development of secure applications and the removal of common vulnerabilities, is primarily addressed by what process?",
                        "options": [
                            "Network Hardening",
                            "A secure software development lifecycle (including code review and automated scanning).",
                            "Physical Security",
                            "Hiring more developers."
                        ],
                        "correct": 1,
                        "explanation": "PCI DSS is one of the few regulations that is very explicit about the need for a secure SDLC. Hardening the application code itself is a mandatory requirement."
                    },
                    {
                        "id": 3,
                        "question": "The practice of using a tool like Ansible or InSpec to write automated, version-controlled tests that check a system's configuration against a security baseline is known as:",
                        "options": [
                            "Manual Auditing",
                            "Compliance as Code",
                            "Penetration Testing",
                            "Incident Response"
                        ],
                        "correct": 1,
                        "explanation": "Compliance as Code transforms compliance from a manual, periodic activity into a continuous, automated process that is integrated into the DevOps lifecycle. It provides much higher assurance and dramatically reduces audit effort."
                    },
                    {
                        "id": 4,
                        "question": "How does a hardened logging and monitoring architecture support compliance?",
                        "options": [
                            "It has no impact on compliance.",
                            "It provides the necessary, immutable audit trail required by almost every regulation to prove that access controls and other security mechanisms are in place and working.",
                            "It makes it harder to provide evidence to auditors.",
                            "It deletes logs to hide evidence."
                        ],
                        "correct": 1,
                        "explanation": "Regulations like HIPAA, SOX, and PCI DSS all have strict requirements for audit logging. A hardened, centralized logging system is a direct and essential control for meeting these requirements."
                    }
                ]
            }
        },
        {
            "id": "lesson-25",
            "title": "Legacy Application Hardening",
            "duration": "90 min",
            "objectives": [
                "Develop a risk-based strategy for hardening legacy applications.",
                "Learn to apply 'wrapper-based' controls to protect applications that cannot be easily changed.",
                "Design a process for incremental hardening and modernization.",
                "Integrate legacy systems into modern security monitoring and assessment tools."
            ],
            "content": {
                "overview": "Hardening a modern, cloud-native application is one challenge; hardening a 10-year-old monolith with no tests and outdated dependencies is another. This lesson, previously covered in the Secure Software Development course, focuses on pragmatic, real-world strategies for reducing the risk of legacy applications when a full rewrite is not an option.",
                "sections": [
                    {
                        "title": "Risk-Based Hardening Prioritization",
                        "content": "<p>You cannot fix everything in a legacy application. The key is to prioritize your efforts on the highest risks.</p><h3>The Assessment Process:</h3><ol><li><strong>Start with Automated Scanning:</strong> Run DAST and SCA scanners against the application. This will give you a prioritized list of the most critical and exploitable vulnerabilities without touching the code.</li><li><strong>Focus on the Quick Wins:</strong> Often, the most critical findings are in outdated third-party libraries. Upgrading a single, vulnerable library can be a high-impact, relatively low-risk change.</li><li><strong>Analyze the Attack Surface:</strong> Manually review the application's attack surface. Are there old, unused admin interfaces that can be disabled? Are there unnecessary network ports open?</li></ol>",
                        "image": "https://images.unsplash.com/photo-1555099962-4199c345e546?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Wrapper-Based Security Approaches",
                        "content": "<p>This is the most powerful strategy for hardening a legacy application. If you can't fix the application from the inside, you protect it from the outside.</p><h3>The 'Security Wrapper':</h3><ul><li><strong>Web Application Firewall (WAF):</strong> Place the application behind a modern WAF. This can provide a 'virtual patch' that blocks exploits for common vulnerabilities like SQL Injection and XSS, even if the underlying code is still vulnerable.</li><li><strong>Authentication Offload:</strong> Use a reverse proxy or API gateway to handle authentication. The gateway can integrate with your modern, MFA-enabled IdP, and then pass a trusted header to the legacy application. This allows you to add MFA to an application that doesn't natively support it.</li><li><strong>Containerization and Micro-segmentation:</strong> Package the legacy app in a container and place it in a highly isolated network segment. This contains the 'blast radius' if the application is ever compromised.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1517694712202-14dd9538aa97?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Incremental Hardening Strategies",
                        "content": "<p>A legacy application's hardening should be treated as a long-term, incremental process.</p><p>By using a 'wrapper' and gradually improving the configuration of the underlying OS and runtime environment, you can significantly reduce the risk of the application over time, even without a major code rewrite. Each improvement should be documented and tracked as part of the application's technical debt reduction plan.</p>",
                        "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 25: Legacy System Hardening Workshop",
                        "language": "markdown",
                        "code": "# Hardening Plan for `Old-CRM-App`\n\n**Current State:** Critical risk. Runs on an unpatched OS, uses a vulnerable version of Apache Struts, and has a public login page with no MFA.\n\n**Phase 1 (Immediate Containment - 2 weeks):**\n- [ ] Migrate the application into a Docker container and deploy it in an isolated, micro-segmented network.\n- [ ] Place the application behind the corporate API Gateway.\n- [ ] Configure the API Gateway to enforce authentication via our central Okta IdP (which requires MFA).\n- [ ] Configure the API Gateway's WAF module with a virtual patch for the specific Struts vulnerability.\n\n**Phase 2 (Incremental Improvement - 3 months):**\n- [ ] Dedicate a development sprint to upgrading the Struts library to a patched version.\n- [ ] Use Ansible to create a hardened OS configuration for the container's base image."
                    },
                    {
                        "title": "Code Example 25: Legacy Application Security Wrapper Framework",
                        "language": "json",
                        "code": "// Conceptual WAF Custom Rule (Virtual Patch)\n\n{\n  \"ruleName\": \"Block-Struts-RCE-CVE-2017-5638\",\n  \"priority\": 100,\n  \"action\": \"BLOCK\",\n  \"match\": {\n    // The rule looks for the specific attack pattern in the Content-Type header\n    // that is used by the Struts vulnerability.\n    \"header\": \"Content-Type\",\n    \"pattern\": \"%{(#_='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)}\"\n  }\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "When faced with a large, legacy monolith, what is the most efficient and risk-based way to begin a hardening assessment?",
                        "options": [
                            "By reading all of its code line by line.",
                            "By running automated 'outside-in' tools like DAST and SCA to find the highest-risk, exploitable flaws first.",
                            "By assuming it is secure and doing nothing.",
                            "By immediately approving it for production use."
                        ],
                        "correct": 1,
                        "explanation": "The 'outside-in' approach is key for legacy systems. The automated scanners act as a reconnaissance tool, helping you to quickly find the biggest fires so you can focus your limited resources on the most critical risks."
                    },
                    {
                        "id": 2,
                        "question": "Placing a WAF in front of a legacy application to block known exploits for a vulnerability that cannot be patched in the code is a hardening technique known as:",
                        "options": [
                            "A virtual patch",
                            "A real patch",
                            "A configuration drift",
                            "A performance optimization"
                        ],
                        "correct": 0,
                        "explanation": "Virtual patching is a core concept of the 'wrapper' approach. It uses an external control to provide a compensating mitigation for a vulnerability that cannot be fixed directly in the application."
                    },
                    {
                        "id": 3,
                        "question": "Which of the following is NOT a benefit of containerizing a legacy application?",
                        "options": [
                            "It makes the application portable and easy to deploy.",
                            "It allows you to apply modern security controls like runtime monitoring and network policies.",
                            "It automatically fixes all of the security bugs in the application's source code.",
                            "It helps to isolate the application from the rest of the network."
                        ],
                        "correct": 2,
                        "explanation": "Containerization is a powerful 'wrapper' at the OS level, but it does not change the application's code. The code inside the container will still have the same vulnerabilities; the container just helps you to isolate it and monitor it more effectively."
                    },
                    {
                        "id": 4,
                        "question": "Using a reverse proxy to add MFA to a legacy application that doesn't natively support it is an example of:",
                        "options": [
                            "Authentication Offload",
                            "A data breach",
                            "A legacy feature",
                            "A denial of service attack"
                        ],
                        "correct": 0,
                        "explanation": "This is a common and effective wrapping pattern. The modern reverse proxy handles the strong authentication and then passes a trusted identity (e.g., in a header) to the legacy application, effectively adding modern security to an old system."
                    }
                ]
            }
        },
        {
            "id": "lesson-26",
            "title": "DevSecOps Integration for Hardening",
            "duration": "90 min",
            "objectives": [
                "Understand how to integrate hardening into the CI/CD pipeline.",
                "Automate the application of secure configuration baselines.",
                "Implement automated testing to validate hardening controls.",
                "Use the pipeline to prevent configuration drift."
            ],
            "content": {
                "overview": "Manual hardening is not scalable, repeatable, or auditable. In a modern DevSecOps environment, hardening is not a one-time event, but a continuous, automated process that is an integral part of the CI/CD pipeline. This lesson covers how to integrate and automate your hardening efforts.",
                "sections": [
                    {
                        "title": "CI/CD Pipeline Security Hardening",
                        "content": "<p>The pipeline itself must be hardened, as we've discussed. But the pipeline is also the primary tool for *enforcing* the hardening of your applications and infrastructure.</p><h3>Hardening as a Pipeline Stage:</h3><p>The pipeline should include specific stages or jobs that automatically apply and test your hardening standards.</p><ul><li><strong>Build Stage:</strong> The Dockerfile used to build a container should be based on a pre-hardened 'golden image'.</li><li><strong>Test Stage:</strong> The pipeline should run automated tests that validate the hardened state of the deployed environment.</li><li><strong>Deploy Stage:</strong> The pipeline should use a hardened configuration management tool (like Ansible) to deploy the application and enforce its secure configuration.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1542382257-80deda0e5d99?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Security Configuration Automation",
                        "content": "<p>This is where Infrastructure as Code (IaC) and Configuration as Code (CaC) are essential.</p><p>Your secure baselines (e.g., the CIS Benchmarks) should be implemented as a set of version-controlled, automated scripts or playbooks (e.g., in Ansible or Terraform). The CI/CD pipeline then uses these 'as-code' definitions as the single source of truth for building and configuring all environments. This ensures that every server and every environment is built to the exact same, secure standard every single time.</p>",
                        "image": "https://images.unsplash.com/photo-1510915228340-29c85a43dcfe?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Continuous Compliance Monitoring",
                        "content": "<p>The pipeline is also used to continuously test and validate the hardened state.</p><h3>The Feedback Loop:</h3><ol><li>A developer commits a change to an IaC file that accidentally violates a hardening standard (e.g., opening a firewall port).</li><li>The pipeline runs automatically.</li><li>A 'test' stage in the pipeline runs an IaC scanner or a compliance-as-code tool (like InSpec).</li><li>The tool detects the non-compliant configuration and fails the build.</li><li>The developer gets immediate feedback and must fix the hardening issue before their code can be merged.</li></ol><p>This provides a powerful, preventative guardrail that enforces your hardening standards automatically.</p>",
                        "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 26: DevSecOps Hardening Pipeline",
                        "language": "yaml",
                        "code": "# Conceptual CI/CD pipeline for building a hardened golden image\n\nstages:\n  - build\n  - harden\n  - test\n  - publish\n\nbuild-base-image:\n  stage: build\n  script:\n    # Start with a minimal base OS\n    - ./build_packer_image.sh ubuntu-22.04\n\nharden-image:\n  stage: harden\n  script:\n    # Use Ansible to apply the CIS Benchmark hardening baseline to the image\n    - ansible-playbook -i hosts cis-hardening.yml\n\ntest-compliance:\n  stage: test\n  script:\n    # Use InSpec to scan the hardened image and validate that it is compliant\n    - inspec exec cis-benchmark-profile --target ssh://...\n\npublish-golden-image:\n  stage: publish\n  script:\n    # If all tests pass, publish the hardened image to the central image repository\n    - ./publish_to_artifactory.sh\n  rules:\n    - if: $CI_COMMIT_BRANCH == 'main'"
                    },
                    {
                        "title": "Code Example 26: CI/CD Security Hardening Automation Platform",
                        "language": "hcl",
                        "code": "# Example of using a Terraform security scanner in a pipeline.\n# This check ensures that no EC2 instances are created without a hardened AMI.\n\nimport \"tfplan/v2\" as tfplan\n\n# A list of approved, hardened AMIs managed by the security team\napproved_amis = [\"ami-0123456789abcdef0\", \"ami-fedcba9876543210f\"]\n\n# The policy rule\nami_is_approved = rule {\n    all tfplan.resources.aws_instance as _, instance {\n        instance.applied.ami in approved_amis\n    }\n}\n\n# The main rule that the pipeline will enforce\nmain = rule {\n    ami_is_approved\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "In a DevSecOps model, how are secure configuration baselines (like CIS Benchmarks) typically implemented?",
                        "options": [
                            "Manually, by an administrator logging into each server.",
                            "They are not implemented.",
                            "As automated, version-controlled scripts or playbooks using a configuration management tool like Ansible.",
                            "By sending an email to the development team."
                        ],
                        "correct": 2,
                        "explanation": "This is the core of 'hardening as code'. By defining the secure baseline in code, you make the process automated, repeatable, and auditable, which is essential for managing security at scale."
                    },
                    {
                        "id": 2,
                        "question": "A CI/CD pipeline that automatically scans Terraform code for misconfigurations before deployment is an example of what?",
                        "options": [
                            "A preventative hardening control.",
                            "A detective hardening control.",
                            "A manual hardening control.",
                            "A network hardening control."
                        ],
                        "correct": 0,
                        "explanation": "This is a 'shift-left' preventative control. It prevents the insecure configuration from ever being deployed, which is far more effective than detecting it in production later."
                    },
                    {
                        "id": 3,
                        "question": "The best way to ensure that all new virtual machines created by an auto-scaling group are secure is to:",
                        "options": [
                            "Manually harden them after they launch.",
                            "Hope for the best.",
                            "Ensure the auto-scaling group is configured to use a pre-hardened 'golden image'.",
                            "Disable auto-scaling."
                        ],
                        "correct": 2,
                        "explanation": "In a dynamic, auto-scaling environment, there is no time for manual hardening. The 'golden image' pattern ensures that every instance is born in a known, secure, and hardened state."
                    },
                    {
                        "id": 4,
                        "question": "The primary purpose of integrating hardening into the DevSecOps pipeline is to:",
                        "options": [
                            "Make hardening a slow, manual, one-time event.",
                            "Make hardening a continuous, automated, and verifiable process that is an integral part of the software delivery lifecycle.",
                            "Make the pipeline more complex and slower.",
                            "Give developers more manual work to do."
                        ],
                        "correct": 1,
                        "explanation": "DevSecOps is all about transforming manual, siloed processes into automated, integrated ones. This applies to security configuration and hardening just as it does to testing and deployment."
                    }
                ]
            }
        },
        {
            "id": "lesson-27",
            "title": "Zero Trust Architecture Implementation",
            "duration": "90 min",
            "objectives": [
                "Understand how Zero Trust principles apply to application architecture.",
                "Learn to implement micro-segmentation to isolate application components.",
                "Design applications that use identity-centric, rather than network-centric, security controls.",
                "Implement a continuous verification model for application access."
            ],
            "content": {
                "overview": "Zero Trust is a strategic approach to security that is perfectly suited for modern, distributed applications. It eliminates the outdated idea of a trusted 'internal' network and hardens the application by requiring every request to be verified. This lesson, previously covered in the Multi-Cloud course, focuses on how to apply these principles to harden your application's architecture.",
                "sections": [
                    {
                        "title": "Zero Trust Principles for Applications",
                        "content": "<p>The core mantra is 'Never trust, always verify'.</p><h3>Key Principles for Hardening:</h3><ul><li><strong>Assume Breach:</strong> Design your application assuming an attacker is already on the network. There is no 'trusted' internal zone.</li><li><strong>Verify Explicitly:</strong> Every request to your application or between its microservices must be strongly authenticated and authorized.</li><li><strong>Least Privilege Access:</strong> Grant access to specific application resources on a per-request basis. Don't grant broad network access.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Micro-segmentation Implementation",
                        "content": "<p>Micro-segmentation is the key hardening tactic for implementing Zero Trust at the network layer. Instead of a large, flat 'application tier' network, you create a tiny network perimeter around each individual microservice or application component.</p><h3>How it's Implemented:</h3><ul><li><strong>In the Cloud:</strong> Using cloud-native firewalls (like AWS Security Groups) to create rules like 'Allow traffic only from the `order-service` to the `payment-service` on port 443'.</li><li><strong>In Kubernetes:</strong> Using Network Policies to define which pods are allowed to communicate with each other.</li></ul><p>This drastically reduces the 'blast radius' of a compromise. If one microservice is compromised, micro-segmentation prevents it from attacking any other service on the network.</p>",
                        "image": "https://images.unsplash.com/photo-1593441139884-faf2c88c7c97?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Identity-Centric Security Models",
                        "content": "<p>In a Zero Trust model, identity is the new perimeter. The hardening focus shifts from 'what network is the request from?' to 'what is the verified identity of the user and device making the request?'.</p><h3>Architectural Shift:</h3><p>Instead of a VPN that grants broad access to a network, a modern hardened application uses an **Identity-Aware Proxy (IAP)** or a **Software-Defined Perimeter (SDP)**. These tools act as an authenticating reverse proxy, ensuring that a user is strongly authenticated and authorized *before* their traffic is ever allowed to reach the application.</p>",
                        "image": "https://images.unsplash.com/photo-1550751827-4133d1a65c19?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 27: Zero Trust Application Architecture",
                        "language": "yaml",
                        "code": "# Example Kubernetes Network Policy for Micro-segmentation\n\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: payment-service-policy\nspec:\n  # This policy applies to the 'payment-service' pods\n  podSelector:\n    matchLabels:\n      app: payment-service\n  policyTypes:\n    - Ingress\n  # Ingress rules (inbound)\n  ingress:\n    - from:\n        # Only allow traffic from pods with the 'app: order-service' label\n        - podSelector:\n            matchLabels:\n              app: order-service\n      ports:\n        - protocol: TCP\n          port: 8443\n\n# Result: This hardens the payment-service by ensuring it can ONLY receive traffic\n# from the order-service on a specific port. All other traffic is blocked by default."
                    },
                    {
                        "title": "Code Example 27: Zero Trust Security Implementation Framework",
                        "language": "plaintext",
                        "code": "/*\n  Zero Trust Hardening Checklist for a New Application\n\n  [ ] 1. Identity: Does the application use the central IdP for authentication?\n  [ ] 2. Authentication: Is MFA enforced for all users?\n  [ ] 3. Network: Is the application deployed in a micro-segmented network with a default-deny policy?\n  [ ] 4. Authorization: Does the application code perform object-level authorization checks?\n  [ ] 5. Logging: Are all authentication and authorization events logged to the central SIEM?\n  [ ] 6. Workload Identity: Does the application use a short-lived, cryptographic identity (e.g., via OIDC) to access other services?\n  [ ] 7. Data: Is all data encrypted in transit and at rest?\n*/"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the central mantra of the Zero Trust security model?",
                        "options": [
                            "Trust but verify.",
                            "Trust all internal traffic.",
                            "Never trust, always verify.",
                            "Verify once at the perimeter."
                        ],
                        "correct": 2,
                        "explanation": "Zero Trust is a 'default deny' security model. It starts from the assumption that all users, devices, and networks are untrusted, and requires every access request to be strictly verified."
                    },
                    {
                        "id": 2,
                        "question": "The primary hardening technique for preventing lateral movement in a Zero Trust network is:",
                        "options": [
                            "Micro-segmentation",
                            "Encryption",
                            "Authentication",
                            "Logging"
                        ],
                        "correct": 0,
                        "explanation": "Micro-segmentation is a key Zero Trust tactic. By creating a tiny network perimeter around each workload, you can strictly control east-west traffic and contain a breach if one workload is compromised."
                    },
                    {
                        "id": 3,
                        "question": "In a Zero Trust architecture, access decisions are based primarily on what?",
                        "options": [
                            "The user's network location (IP address).",
                            "The verified identity of the user and the security posture of their device.",
                            "The time of day.",
                            "The user's job title."
                        ],
                        "correct": 1,
                        "explanation": "Identity becomes the new perimeter. Zero Trust is identity-centric, not network-centric. It doesn't matter where you are; it matters who you are and whether your device is secure."
                    },
                    {
                        "id": 4,
                        "question": "A technology that acts as an authenticating reverse proxy, allowing secure access to applications without a VPN, is known as an:",
                        "options": [
                            "Identity-Aware Proxy (IAP) or Software-Defined Perimeter (SDP)",
                            "A traditional firewall",
                            "A database",
                            "A load balancer"
                        ],
                        "correct": 0,
                        "explanation": "IAP and SDP are key enabling technologies for a Zero Trust architecture. They harden the application by ensuring that no unauthenticated traffic can ever reach it."
                    }
                ]
            }
        },
        {
            "id": "lesson-28",
            "title": "Threat Intelligence Integration",
            "duration": "90 min",
            "objectives": [
                "Understand how threat intelligence can be used to guide hardening efforts.",
                "Learn to integrate Indicators of Compromise (IoCs) into preventative controls.",
                "Use behavioral analysis and threat intelligence to hunt for weaknesses.",
                "Develop a proactive, intelligence-driven approach to application hardening."
            ],
            "content": {
                "overview": "Threat intelligence provides critical context about who the attackers are, what their motives are, and what techniques they are using. Integrating this intelligence into your hardening program allows you to move from a generic, compliance-based approach to a proactive, threat-informed defense. This lesson covers how to use threat intelligence to prioritize and focus your hardening efforts.",
                "sections": [
                    {
                        "title": "Threat Intelligence Feed Integration",
                        "content": "<p>Threat intelligence comes in many forms, from high-level reports to machine-readable feeds of Indicators of Compromise (IoCs).</p><h3>Using IoCs for Proactive Hardening:</h3><p>An IoC is an artifact observed on a network or in an operating system that, with high confidence, indicates a computer intrusion. Examples include malicious IP addresses, domain names, and file hashes.</p><p>A Threat Intelligence Platform (TIP) can be used to automatically push these IoCs to your preventative controls:</p><ul><li>A list of known malicious IP addresses can be automatically added as a 'deny' rule on your firewall.</li><li>A list of known phishing domains can be pushed to your web proxy to block users from accessing them.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1556155092-490a1ba16284?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Behavioral Analysis and Anomaly Detection",
                        "content": "<p>Threat intelligence is not just about known 'bad' things; it's also about understanding adversary behavior. The MITRE ATT&CK framework is a knowledge base of the Tactics, Techniques, and Procedures (TTPs) used by real-world attackers.</p><h3>Hardening Based on TTPs:</h3><p>You can use the ATT&CK framework to guide your hardening efforts. For example:</p><ul><li><strong>TTP:</strong> 'Credential Dumping: LSASS Memory' (T1003.001) is a common technique used by attackers to steal passwords from Windows machines.</li><li><strong>Hardening Control:</strong> You can harden your Windows servers by enabling Credential Guard, a virtualization-based security feature that isolates the LSASS process to prevent this specific technique.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1543286386-713bdd548da4?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Threat Hunting Capabilities",
                        "content": "<p>Threat intelligence can also be used to proactively hunt for weaknesses in your hardening.</p><h3>Example Hunt:</h3><ul><li><strong>Intelligence:</strong> You receive a report that a new malware variant is using a specific filename, `update.dll`.</li><li><strong>Hypothesis:</strong> 'Our application servers may have been compromised by this malware.'</li><li><strong>Hunt:</strong> You can use your EDR tool to run a query across your entire fleet of servers: 'Search for any host that has a file named `update.dll` in the `/tmp/` directory.'</li></ul><p>The results of this hunt can validate the effectiveness of your hardening or uncover a gap that needs to be fixed.</p>",
                        "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 28: Threat Intelligence Integration Lab",
                        "language": "python",
                        "code": "# Conceptual script to automate firewall blocking from a threat feed\n\nimport firewall_api\nimport threat_intel_api\n\ndef update_firewall_blocklist():\n    # 1. Get the latest list of known malicious IPs from the TIP\n    malicious_ips = threat_intel_api.get_malicious_ips()\n    \n    # 2. Get the current blocklist from the firewall\n    current_blocklist = firewall_api.get_ip_blocklist()\n    \n    # 3. Find any new IPs that need to be blocked\n    new_ips_to_block = set(malicious_ips) - set(current_blocklist)\n    \n    # 4. Add the new IPs to the firewall's blocklist via API\n    if new_ips_to_block:\n        firewall_api.add_to_blocklist(list(new_ips_to_block))\n        print(f\"Blocked {len(new_ips_to_block)} new malicious IPs.\")"
                    },
                    {
                        "title": "Code Example 28: Adaptive Threat Response Framework",
                        "language": "markdown",
                        "code": "# Hardening Strategy based on MITRE ATT&CK\n\n**Tactic:** TA0002 - Execution\n**Technique:** T1059.001 - PowerShell\n\n**Threat:** Attackers frequently use PowerShell for 'living off the land' and executing malicious code.\n\n**Hardening Controls:**\n1.  **[Least Privilege]** Configure server policies to only allow digitally signed PowerShell scripts to be executed.\n2.  **[Application Control]** Use a tool like AppLocker to restrict who can run PowerShell.exe.\n3.  **[Logging]** Enable PowerShell Module Logging, Script Block Logging, and Transcription to capture detailed logs of all PowerShell activity.\n4.  **[Detection]** Create SIEM rules to alert on suspicious PowerShell command-line arguments (e.g., `-EncodedCommand`, `-ExecutionPolicy Bypass`)."
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "A list of malicious IP addresses or file hashes used to feed blocklists or SIEM rules is known as:",
                        "options": [
                            "A hardening baseline",
                            "Indicators of Compromise (IoCs)",
                            "A penetration test",
                            "A firewall"
                        ],
                        "correct": 1,
                        "explanation": "IoCs are atomic pieces of threat intelligence that can be used to create automated, high-confidence detections and blocks."
                    },
                    {
                        "id": 2,
                        "question": "How does threat intelligence help to prioritize hardening efforts?",
                        "options": [
                            "It does not help with prioritization.",
                            "It tells you which vulnerabilities are being actively exploited by attackers in the wild, allowing you to focus on fixing those first.",
                            "It provides a list of all possible vulnerabilities.",
                            "It is only useful after an incident."
                        ],
                        "correct": 1,
                        "explanation": "Threat intelligence provides real-world context. A vulnerability that is actively being used in attack campaigns is a much higher priority to patch or harden against than a purely theoretical one."
                    },
                    {
                        "id": 3,
                        "question": "The MITRE ATT&CK framework is primarily a knowledge base of what?",
                        "options": [
                            "Software vulnerabilities (CVEs)",
                            "Compliance regulations",
                            "Adversary Tactics, Techniques, and Procedures (TTPs)",
                            "Secure coding guidelines"
                        ],
                        "correct": 2,
                        "explanation": "ATT&CK is focused on adversary *behavior*. It provides a common language for describing how attackers operate, which can be used to guide the development of specific hardening controls and detection rules."
                    },
                    {
                        "id": 4,
                        "question": "A proactive security process where an analyst uses threat intelligence to form a hypothesis and search for signs of an attacker in their environment is called:",
                        "options": [
                            "Patch management",
                            "Threat hunting",
                            "Vulnerability scanning",
                            "Incident response"
                        ],
                        "correct": 1,
                        "explanation": "Threat hunting is a key part of a threat-informed defense. It allows you to proactively validate your hardening controls and hunt for the specific TTPs that your threat intelligence tells you are most relevant."
                    }
                ]
            }
        },
        {
            "id": "lesson-29",
            "title": "Testing and Validation of Hardening",
            "duration": "90 min",
            "objectives": [
                "Understand the difference between vulnerability assessment and penetration testing.",
                "Learn how to use automated tools to continuously validate hardening.",
                "Explore the role of Red Team exercises in testing a hardened environment.",
                "Design a process for integrating testing feedback to improve hardening."
            ],
            "content": {
                "overview": "A hardening baseline is just a theory until it is tested. It's critical to have a robust testing and validation program to ensure that your hardening controls are implemented correctly and are actually effective at stopping attacks. This lesson covers the different types of security testing used to validate a hardened application.",
                "sections": [
                    {
                        "title": "Vulnerability Assessment Automation",
                        "content": "<p>A vulnerability assessment is a broad scan to find known weaknesses. This is a key part of validating your hardening.</p><h3>The Process:</h3><p>Use an authenticated vulnerability scanner (like Nessus or Qualys) to perform a deep scan of your hardened servers. This scan can:</p><ul><li>Verify that all required patches have been applied.</li><li>Check for thousands of common misconfigurations.</li><li>Validate that your hardening baseline has been applied correctly.</li></ul><p>This should be run on a continuous basis, and the results should be fed back into your vulnerability management program.</p>",
                        "image": "https://images.unsplash.com/photo-1542382257-80deda0e5d99?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Penetration Testing Integration",
                        "content": "<p>A penetration test is a goal-oriented, human-driven test that simulates a real attacker. It doesn't just find vulnerabilities; it attempts to exploit them to see how far an attacker could get.</p><p>A penetration test is an excellent way to validate your hardening. For example, the pen tester might find a vulnerability on a web server. But if your network segmentation (a hardening control) is effective, the tester's report might say, 'We compromised the web server, but we were unable to move laterally to any other part of the network.' This is a successful validation of your defense-in-depth strategy.</p>",
                        "image": "https://images.unsplash.com/photo-1555949963-aa79dcee981c?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Red Team Exercise Integration",
                        "content": "<p>A Red Team exercise is an even more advanced form of testing. The Red Team emulates a specific adversary group and attempts to achieve a goal (like exfiltrating data) while remaining undetected. The goal is not just to test the preventative hardening controls, but to test the organization's detection and response capabilities.</p><p>A successful Red Team exercise against a well-hardened environment might take weeks or months, and the feedback it provides is invaluable for improving both proactive hardening and reactive monitoring.</p>",
                        "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Continuous Security Validation",
                        "content": "<p>Point-in-time tests are useful, but the ideal state is continuous validation. This is where **Breach and Attack Simulation (BAS)** platforms come in.</p><p>A BAS platform automates the process of testing your controls. It has a library of thousands of safe, simulated attack techniques. On a continuous basis, it will automatically:</p><ol><li>Run a simulated attack (e.g., a fake credential dumping attack).</li><li>Check to see if your security controls (e.g., your EDR) actually detected and blocked it.</li></ol><p>This provides a continuous, data-driven dashboard showing exactly which of your hardening controls are working and which have gaps.</p>",
                        "image": "https://images.unsplash.com/photo-1556155092-490a1ba16284?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 29: Hardening Validation Workshop",
                        "language": "markdown",
                        "code": "# Penetration Test Finding vs. Hardening Control\n\n**Penetration Test Finding:**\n- 'An SQL Injection vulnerability was identified in the application's search feature.'\n\n**Hardening Validation Result:**\n- **Web Application Firewall (WAF):** The WAF's logs show that it successfully detected and blocked the pen tester's attempts to exploit the SQLi.\n- **Database Access Control:** The application was running with a least-privilege database account. Even if the SQLi had been successful, the attacker would have only been able to read data from the 'products' table and could not have accessed other sensitive tables.\n\n**Conclusion:**\n- The application code has a critical vulnerability that must be fixed.\n- However, the defense-in-depth hardening controls (WAF and least privilege) successfully contained the risk and prevented a full breach."
                    },
                    {
                        "title": "Code Example 29: Comprehensive Security Testing Framework",
                        "language": "json",
                        "code": "{\n  \"test_id\": \"bas-test-1138\",\n  \"attack_technique\": \"T1003.001: LSASS Memory Dumping\",\n  \"timestamp\": \"2025-09-29T14:00:00Z\",\n  \"target_host\": \"prod-dc-01\",\n  \"simulation_result\": \"SUCCESS\",\n  \"control_validation_results\": [\n    {\n      \"control\": \"EDR Agent\",\n      \"status\": \"DETECTED_AND_BLOCKED\",\n      \"evidence_link\": \"https://edr.example.com/alerts/123\"\n    },\n    {\n      \"control\": \"SIEM\",\n      \"status\": \"ALERT_GENERATED\",\n      \"evidence_link\": \"https://siem.example.com/events/456\"\n    }\n  ],\n  \"overall_status\": \"HARDENING_EFFECTIVE\"\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "An automated scan that checks a server for thousands of known misconfigurations and missing patches is known as a:",
                        "options": [
                            "Penetration Test",
                            "Vulnerability Assessment",
                            "Red Team Exercise",
                            "Manual Code Review"
                        ],
                        "correct": 1,
                        "explanation": "A vulnerability assessment is a broad, often automated, process designed to provide an inventory of known weaknesses. It is a key tool for validating a hardening baseline."
                    },
                    {
                        "id": 2,
                        "question": "A goal-oriented, human-driven test that attempts to exploit vulnerabilities to simulate a real attacker is a:",
                        "options": [
                            "Penetration Test",
                            "Vulnerability Assessment",
                            "Compliance Scan",
                            "Configuration Review"
                        ],
                        "correct": 0,
                        "explanation": "A penetration test goes a step beyond a vulnerability assessment. It doesn't just find the flaws; it actively tries to exploit them to demonstrate their real-world impact, which is a powerful way to validate your defenses."
                    },
                    {
                        "id": 3,
                        "question": "What is the primary goal of a Red Team exercise?",
                        "options": [
                            "To find as many vulnerabilities as possible.",
                            "To test the organization's detection and response capabilities against a simulated, stealthy adversary.",
                            "To patch all the servers.",
                            "To write a report."
                        ],
                        "correct": 1,
                        "explanation": "A Red Team exercise is a test of your monitoring and incident response (the 'Blue Team'). The goal is to see if your hardened environment and your security operations team can actually detect and respond to a sophisticated, real-world attack."
                    },
                    {
                        "id": 4,
                        "question": "A platform that can continuously and automatically test your security controls by running thousands of safe, simulated attacks is known as a:",
                        "options": [
                            "Breach and Attack Simulation (BAS) platform",
                            "SIEM",
                            "Firewall",
                            "Vulnerability Scanner"
                        ],
                        "correct": 0,
                        "explanation": "BAS is a modern approach to security validation. It provides continuous assurance that your hardening and detection controls are configured correctly and are working as expected, rather than relying on a point-in-time test."
                    }
                ]
            }
        },
        {
            "id": "lesson-30",
            "title": "Enterprise Hardening Program Management",
            "duration": "90 min",
            "objectives": [
                "Develop a long-term strategy and roadmap for an enterprise hardening program.",
                "Design a governance model to ensure policies and standards are followed.",
                "Define metrics and KPIs to measure the effectiveness and ROI of hardening.",
                "Foster a culture of continuous improvement for security hardening."
            ],
            "content": {
                "overview": "A one-time hardening project is not enough. To be effective, hardening must be a continuous, managed program that is embedded into the organization's culture and processes. This final lesson covers the strategic aspects of building and running a successful enterprise-wide application hardening program.",
                "sections": [
                    {
                        "title": "Enterprise Hardening Strategy Development",
                        "content": "<p>A successful program requires a long-term strategy and a roadmap.</p><h3>The Roadmap:</h3><ol><li><strong>Establish a Baseline:</strong> The first phase is to develop the initial secure configuration baselines for your key platforms.</li><li><strong>Automate Enforcement:</strong> The next phase is to automate the application and validation of these baselines using configuration management and CI/CD integration.</li><li><strong>Continuous Validation:</strong> The mature phase involves implementing continuous validation with tools like BAS and integrating the program with threat intelligence.</li></ol>",
                        "image": "https://images.unsplash.com/photo-1542626991-a2f5702b3c2b?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Governance and Oversight Models",
                        "content": "<p>A governance model is needed to ensure the hardening standards are being followed.</p><h3>The 'Paved Road' Approach:</h3><p>The central security or platform team is responsible for creating and maintaining the hardened 'golden images' and the automated 'hardening as code' playbooks. They provide these as a service to the development teams.</p><p>This makes it easy for developers to consume the hardened environment by default. Any exception or deviation from the standard hardened path must go through a formal risk acceptance process.</p>",
                        "image": "https://images.unsplash.com/photo-1552664730-d307ca884978?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Metrics and Measurement Frameworks",
                        "content": "<p>To prove the value of the hardening program, you must measure it.</p><h3>Key KPIs:</h3><ul><li><strong>Baseline Compliance Rate:</strong> The percentage of systems in the environment that are compliant with the secure configuration baseline. The goal is to drive this to 100%.</li><li><strong>Configuration Drift Rate:</strong> The number of systems that have drifted from their hardened state. A low number indicates that your preventative controls are working.</li><li><strong>Mean Time to Remediate (for Misconfigurations):</strong> How quickly are you fixing the drift that you find?</li></ul>",
                        "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Lab 30: Enterprise Hardening Program Design",
                        "language": "markdown",
                        "code": "# Enterprise Hardening Program - Quarterly Business Review\n\n**Goal:** Achieve a 95% compliance rate with the CIS Level 1 Benchmark for all production Linux servers.\n\n**Q3 Metrics:**\n- **Current Compliance Rate:** 88% (Up from 75% in Q2)\n- **Top Non-Compliant Controls:**\n  - 5.2.4 (SSH Root Login): 15% of servers non-compliant.\n  - 3.3.1 (IPv6 Disabled): 10% of servers non-compliant.\n- **Mean Time to Remediate Drift:** 4.2 Days (Target: < 3 Days)\n\n**Q4 Initiatives:**\n1.  **[Automation]** Prioritize the development of an Ansible playbook to automatically remediate the top two non-compliant controls.\n2.  **[Training]** Hold a workshop with the infrastructure team to review the importance of the hardening baseline.\n3.  **[Reporting]** Create an automated report that is sent weekly to each team showing the compliance status of their specific servers."
                    },
                    {
                        "title": "Code Example 30: Enterprise Security Hardening Management Platform",
                        "language": "json",
                        "code": "{\n  \"programName\": \"Enterprise Server Hardening Program\",\n  \"overallCompliance\": \"92%\",\n  \"baselines\": [\n    {\n      \"baselineName\": \"CIS Ubuntu Linux 22.04 LTS Benchmark v1.0.0\",\n      \"assetCount\": 1500,\n      \"complianceRate\": \"95%\"\n    },\n    {\n      \"baselineName\": \"CIS Windows Server 2022 Benchmark v1.0.0\",\n      \"assetCount\": 800,\n      \"complianceRate\": \"86%\"\n    }\n  ],\n  \"roi_analysis\": {\n    \"estimated_cost_of_breach_avoided\": 2500000,\n    \"program_cost\": 350000,\n    \"net_benefit\": 2150000\n  }\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "A central team that creates and maintains hardened 'golden images' and automated configuration playbooks for development teams to use is an example of what model?",
                        "options": [
                            "A manual hardening model",
                            "A 'Paved Road' or Platform model",
                            "An ad-hoc model",
                            "A decentralized model"
                        ],
                        "correct": 1,
                        "explanation": "The 'Paved Road' approach is a key scaling strategy for enterprise hardening. It makes the secure option the easy option, which drives adoption and consistency."
                    },
                    {
                        "id": 2,
                        "question": "The percentage of servers in your environment that are compliant with a secure baseline (like the CIS Benchmarks) is a key KPI for measuring what?",
                        "options": [
                            "The effectiveness and coverage of your hardening program.",
                            "The number of security incidents.",
                            "The speed of your network.",
                            "The number of developers in your company."
                        ],
                        "correct": 0,
                        "explanation": "The baseline compliance rate is one of the most important metrics for a hardening program. It is a direct, quantifiable measure of your organization's security posture at the configuration level."
                    },
                    {
                        "id": 3,
                        "question": "The most effective way to manage a hardening program at an enterprise scale is through:",
                        "options": [
                            "Manual processes and spreadsheets.",
                            "Hoping for the best.",
                            "A programmatic, automated, and data-driven approach.",
                            "Hiring a single person to manage everything."
                        ],
                        "correct": 2,
                        "explanation": "At scale, automation is non-negotiable. A successful program is built on 'hardening as code', automated testing, and data-driven metrics to measure and improve the process."
                    },
                    {
                        "id": 4,
                        "question": "The end goal of a mature hardening program is to:",
                        "options": [
                            "Perform a one-time hardening project and then be done.",
                            "Create a continuous cycle of improvement where the organization's defensive posture is constantly being measured, tested, and strengthened.",
                            "Make the application slower.",
                            "Write more documentation."
                        ],
                        "correct": 1,
                        "explanation": "Hardening is not a project; it is a continuous program. The threat landscape is always changing, and your defenses must be continuously improved to keep pace."
                    }
                ]
            }
        },
        {
            "id": "lesson-31",
            "title": "Final Capstone Project",
            "duration": "240 min",
            "objectives": [
                "Apply the principles of application hardening to a real-world scenario.",
                "Perform a comprehensive security assessment of an application and its environment.",
                "Develop a multi-layer hardening strategy and implementation roadmap.",
                "Create a business case and executive presentation for your hardening plan."
            ],
            "content": {
                "overview": "This final capstone project brings together all the concepts covered in the Complete Application Hardening Course. You will be given a scenario for a web application with a typical set of security weaknesses. Your task will be to act as a security architect, perform a full assessment, and design a comprehensive, multi-layered hardening plan to secure the application.",
                "sections": [
                    {
                        "title": "Scenario: 'LegacyRetail' E-commerce Application",
                        "content": "<p>You are the security architect for an e-commerce company. Your primary application, 'LegacyRetail', is a monolithic Java application running on-premises on a fleet of Ubuntu Linux servers. It connects to a PostgreSQL database.</p><h3>The Situation:</h3><p>The application has failed its recent PCI DSS audit. A penetration test found several critical vulnerabilities. The business is losing sales due to performance and reliability issues. You have been tasked with creating a comprehensive hardening plan to fix the security issues and improve the stability of the application.</p><h3>Assessment Findings:</h3><ul><li>The OS is running an old, unpatched version of Ubuntu.</li><li>The web servers are running as root.</li><li>The application is vulnerable to SQL Injection and XSS.</li><li>The database is accessible from the main corporate network.</li><li>There is no centralized logging or monitoring.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1556740738-b6a63e27c4df?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Project Task 1: Develop a Multi-Layer Hardening Strategy",
                        "content": "<p>Create a document that outlines your proposed hardening strategy. You must address each layer of the defense-in-depth model:</p><ol><li><strong>OS Hardening:</strong> What is your plan for the underlying servers?</li><li><strong>Network Hardening:</strong> How will you use segmentation and firewalls to protect the application?</li><li><strong>Runtime Environment Hardening:</strong> How will you harden the web server and database server configurations?</li><li><strong>Application Hardening:</strong> What 'wrapper-based' controls will you use to provide a virtual patch for the code-level vulnerabilities?</li><li><strong>Logging & Monitoring:</strong> What is your plan to implement a secure logging and monitoring architecture?</li></ol>",
                        "image": "https://images.unsplash.com/photo-1486312338219-ce68d2c6f44d?w=800&h=400&fit-crop"
                    },
                    {
                        "title": "Project Task 2: Create an Implementation Roadmap",
                        "content": "<p>Create a high-level, 6-month implementation roadmap for your hardening plan. The roadmap should be phased, prioritizing the actions that will provide the biggest risk reduction first (e.g., 'Phase 1: Containment', 'Phase 2: Remediation', 'Phase 3: Automation').</p>",
                        "image": "https://images.unsplash.com/photo-1542626991-a2f5702b3c2b?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Final Lab: End-to-End Application Hardening Transformation",
                        "language": "markdown",
                        "code": "# Capstone Project Submission Checklist\n\n1.  **Hardening Strategy Document (PDF):**\n    - A 3-5 page document outlining your strategy for each of the 5 required layers.\n    - Should include a simple 'before' and 'after' network architecture diagram.\n\n2.  **Implementation Roadmap (PNG/PDF):**\n    - A single-slide visual roadmap showing key initiatives over 6 months.\n\n3.  **Business Case Summary (PDF):**\n    - A 1-page summary explaining why this hardening plan is critical for the business, focusing on PCI DSS compliance and risk reduction.\n\n**Presentation:**\n- You will be expected to give a 15-minute presentation of your hardening plan to a panel acting as the company's leadership."
                    },
                    {
                        "title": "Final Code Project: Enterprise Application Hardening Platform",
                        "language": "plaintext",
                        "code": "/*\n  This final project is a design and strategy exercise. You will be evaluated on your ability\n  to apply the layered defense and proactive hardening principles taught throughout this course\n  to a realistic, high-risk scenario.\n*/"
                    }
                ]
            },
            "quiz": {
                "passingScore": 100,
                "questions": [
                    {
                        "id": 1,
                        "question": "This capstone project requires you to create a comprehensive, multi-layer hardening plan for a vulnerable legacy application. Are you ready to begin?",
                        "options": [
                            "Yes, I am ready to harden the 'LegacyRetail' application.",
                            "No, I would like to review some of the previous lessons."
                        ],
                        "correct": 0,
                        "explanation": "This question confirms your readiness to apply the comprehensive knowledge gained throughout the course to a final, practical architectural design project."
                    }
                ]
            }
        }
    ]
}
  
      // =====================================================
      // GLOBAL VARIABLES
      // =====================================================
      let currentUser = null;
      let currentLessonIndex = 0;
      let courseProgress = {};
      let userStats = {};
      let quizState = {
        currentQuestion: 0,
        answers: [],
        score: 0,
        isComplete: false,
      };

      // Enhanced session tracking
      let courseSession = {
        startTime: null,
        totalStudyTime: 0,
        lessonsStarted: 0,
        lessonsCompleted: 0,
        pageLoadTime: new Date(),
        interactionCount: 0,
        lastActivityTime: new Date(),
      };

      // Music Player Variables
      let audioPlayer = new Audio();

      // Achievement notification system
      let notificationQueue = [];
      let isShowingNotification = false;

      // =====================================================
      // INITIALIZATION
      // =====================================================
      document.addEventListener("DOMContentLoaded", async () => {
        try {
          showLoadingScreen();
          await checkAuth();

          if (currentUser) {
            // Initialize session tracking
            startCourseSession();

            // Load course data and progress
            await loadCourseData();
            await loadUserProfile();
            await loadProgress();

            // Initialize UI
            initializeEventListeners();
            renderSidebar();
            loadLesson(currentLessonIndex);

            // Initialize additional features
            initMusicPlayer();
            addMusicIndicator();
            initializeActivityTracking();

            hideLoadingScreen();
          } else {
            openAuthModal();
          }
        } catch (error) {
          console.error("Error initializing course:", error);
          hideLoadingScreen();
          showToast("Failed to initialize course system", "error");
        }
      });

      // =====================================================
      // AUTHENTICATION SYSTEM
      // =====================================================
      async function checkAuth() {
        try {
          const {
            data: { session },
            error,
          } = await supabase.auth.getSession();

          if (error) {
            console.error("Auth error:", error);
            currentUser = null;
            openAuthModal();
            return;
          }

          if (!session) {
            currentUser = null;
            openAuthModal();
            return;
          }

          currentUser = session.user;
          updateUIWithUser();
        } catch (error) {
          console.error("Error checking auth:", error);
          currentUser = null;
          openAuthModal();
        }
      }

      function updateUIWithUser() {
        if (!currentUser) return;

        const name =
          currentUser.user_metadata?.full_name ||
          currentUser.email.split("@")[0];
        const userElements = document.querySelectorAll("[data-user-name]");
        userElements.forEach((el) => (el.textContent = name));
      }

      // =====================================================
      // USER PROFILE & STATS MANAGEMENT
      // =====================================================
      async function loadUserProfile() {
        try {
          // 🔍 Step 1: Try to fetch existing profile
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("*")
            .eq("id", currentUser.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (!profile) {
            // 🆕 Step 2: Create new profile if missing
            await createUserProfile();
          } else {
            // ✅ Step 3: Use existing profile
            userStats = profile;
            await updateLastActivity();
          }
        } catch (error) {
          console.error("❌ Error loading user profile:", error);
          showToast("Failed to load user profile", "error");
        }
      }
      async function createUserProfile() {
        try {
          const newProfile = {
            id: currentUser.id,
            full_name: currentUser.user_metadata?.full_name || "",
            email: currentUser.email,
            level: "Script Kiddie",
            total_points: 0,
            completed_courses: 0,
            current_streak: 0,
            total_certificates: 0,
            total_achievements: 0,
            sections_visited: 0,
            bonus_points: 0,
            in_progress_courses: 0,
            settings_changed: 0,
            midnight_sessions: 0,
            early_sessions: 0,
            weekend_sessions: 0,
            last_activity: new Date().toISOString(),
            created_at: new Date().toISOString(),
          };

          const { error } = await supabase
            .from("profiles")
            .insert([newProfile]);

          if (!error) {
            userStats = newProfile;
            // Award first login achievement
            setTimeout(() => checkAndUnlockAchievement("first_login"), 1000);
          }
        } catch (error) {
          console.error("Error creating user profile:", error);
        }
      }

      async function updateLastActivity() {
        try {
          const now = new Date();

          // Update activity tracking
          courseSession.lastActivityTime = now;

          // Update database
          await supabase
            .from("profiles")
            .update({
              last_activity: now.toISOString(),
            })
            .eq("id", currentUser.id);

          // Check time-based achievements
          await checkTimeBasedAchievements(now);
        } catch (error) {
          console.error("Error updating last activity:", error);
        }
      }

      // =====================================================
      // COURSE SESSION MANAGEMENT
      // =====================================================
      function startCourseSession() {
        courseSession.startTime = new Date();
        courseSession.pageLoadTime = new Date();

        logUserActivity("course_session_start", {
          course_id: COURSE_DATA.id,
          course_title: COURSE_DATA.title,
          user_agent: navigator.userAgent,
          screen_resolution: `${screen.width}x${screen.height}`,
        });

        // Check daily streak
        checkDailyStreak();
      }

      function initializeActivityTracking() {
        // Track page focus/blur for accurate study time
        document.addEventListener("visibilitychange", handleVisibilityChange);

        // Track user interactions
        ["click", "keydown", "scroll", "mousemove"].forEach((event) => {
          document.addEventListener(event, trackUserInteraction, {
            passive: true,
          });
        });

        // Periodic activity updates
        setInterval(updateStudyTime, 60000); // Every minute

        // Save session data before page unload
        window.addEventListener("beforeunload", saveSessionData);
      }

      function handleVisibilityChange() {
        if (document.hidden) {
          courseSession.lastActivityTime = new Date();
        } else {
          // Page became visible again - update activity
          updateLastActivity();
        }
      }

      function trackUserInteraction() {
        courseSession.interactionCount++;
        courseSession.lastActivityTime = new Date();

        // Throttle activity updates
        if (courseSession.interactionCount % 50 === 0) {
          updateLastActivity();
        }
      }

      function updateStudyTime() {
        if (!courseSession.startTime || document.hidden) return;

        const now = new Date();
        const sessionDuration = now - courseSession.startTime;
        courseSession.totalStudyTime = Math.floor(sessionDuration / 1000 / 60); // in minutes

        // Update progress with study time
        saveProgress();
      }

      function saveSessionData() {
        if (!currentUser || !courseSession.startTime) return;

        const sessionData = {
          user_id: currentUser.id,
          course_id: COURSE_DATA.id,
          session_duration: courseSession.totalStudyTime,
          lessons_viewed: courseSession.lessonsStarted,
          lessons_completed: courseSession.lessonsCompleted,
          interactions: courseSession.interactionCount,
          session_date: courseSession.startTime.toISOString().split("T")[0],
        };

        // Store in localStorage as backup
        localStorage.setItem(
          "course_session_backup",
          JSON.stringify(sessionData)
        );

        // Try to save to database
        logUserActivity("course_session_end", sessionData);
      }

      // =====================================================
      // COURSE DATA & PROGRESS MANAGEMENT
      // =====================================================
      async function loadCourseData() {
        try {
          // Update course info in UI
          document.getElementById("courseTitle").textContent =
            COURSE_DATA.title;
          document.getElementById("totalLessons").textContent =
            COURSE_DATA.lessons.length;

          // Log course access
          logUserActivity("course_access", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
          });
        } catch (error) {
          console.error("Error loading course data:", error);
        }
      }

      async function loadProgress() {
        try {
          // Get existing progress from database
          const { data, error } = await supabase
            .from("course_progress")
            .select("*")
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (data) {
            courseProgress = JSON.parse(data.lesson_progress || "{}");
            currentLessonIndex = data.current_lesson || 0;

            // Update session tracking
            courseSession.lessonsStarted = Object.keys(courseProgress).length;
            courseSession.lessonsCompleted = Object.values(
              courseProgress
            ).filter((p) => p.completed).length;
          } else {
            // Initialize new progress
            courseProgress = {};
            currentLessonIndex = 0;
            await saveProgress();

            // Award first course start achievement
            await checkAndUnlockAchievement("first_course_start");
          }

          updateProgressDisplay();
        } catch (error) {
          console.error("Error loading progress:", error);
          showToast("Failed to load progress", "error");
        }
      }

      async function saveProgress() {
        try {
          if (!currentUser) return;

          const now = new Date();
          const progressData = {
            user_id: currentUser.id,
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            current_lesson: currentLessonIndex,
            lesson_progress: JSON.stringify(courseProgress),
            progress: calculateOverallProgress(),
            lessons_completed: getCompletedLessonsCount(),
            lessons_started: Object.keys(courseProgress).length,
            study_time_minutes: courseSession.totalStudyTime,
            last_accessed: now.toISOString(),
            updated_at: now.toISOString(),
          };

          // Upsert progress
          const { error } = await supabase
            .from("course_progress")
            .upsert([progressData]);

          if (error) throw error;

          // Update user stats
          await updateUserStats();

          updateProgressDisplay();
        } catch (error) {
          console.error("Error saving progress:", error);
          showToast("Failed to save progress", "error");
        }
      }

      async function updateUserStats() {
        try {
          // Get all course progress for this user
          const { data: allProgress, error } = await supabase
            .from("course_progress")
            .select("progress, course_id, study_time_minutes")
            .eq("user_id", currentUser.id);

          if (error) throw error;

          // Calculate stats
          const completedCourses =
            allProgress?.filter((p) => p.progress >= 100).length || 0;
          const inProgressCourses =
            allProgress?.filter((p) => p.progress > 0 && p.progress < 100)
              .length || 0;
          const totalStudyTime =
            allProgress?.reduce(
              (sum, p) => sum + (p.study_time_minutes || 0),
              0
            ) || 0;

          // Calculate points (500 per completed course + achievement points)
          const coursePoints = completedCourses * 500;
          const bonusPoints = userStats.bonus_points || 0;
          const totalPoints = coursePoints + bonusPoints;

          // Update profile
          const updateData = {
            completed_courses: completedCourses,
            in_progress_courses: inProgressCourses,
            total_points: totalPoints,
            total_study_time: totalStudyTime,
            last_activity: new Date().toISOString(),
          };

          const { error: updateError } = await supabase
            .from("profiles")
            .update(updateData)
            .eq("id", currentUser.id);

          if (updateError) throw updateError;

          // Update local stats
          Object.assign(userStats, updateData);
        } catch (error) {
          console.error("Error updating user stats:", error);
        }
      }

      function calculateOverallProgress() {
        const completedLessons = getCompletedLessonsCount();
        return Math.round(
          (completedLessons / COURSE_DATA.lessons.length) * 100
        );
      }

      function getCompletedLessonsCount() {
        return Object.values(courseProgress).filter(
          (lesson) => lesson.completed
        ).length;
      }

      function updateProgressDisplay() {
        const completedCount = getCompletedLessonsCount();
        const progressPercent = calculateOverallProgress();

        // Update UI elements
        const elements = {
          completedLessons: completedCount,
          courseProgressPercent: `${progressPercent}%`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });

        // Update progress bar
        const progressBar = document.getElementById("courseProgressFill");
        if (progressBar) progressBar.style.width = `${progressPercent}%`;
      }

      // =====================================================
      // LESSON MANAGEMENT
      // =====================================================
      function loadLesson(index) {
        if (index < 0 || index >= COURSE_DATA.lessons.length) return;

        const lesson = COURSE_DATA.lessons[index];
        currentLessonIndex = index;

        // Mark lesson as started and track activity
        if (!courseProgress[lesson.id]) {
          courseProgress[lesson.id] = {
            started: true,
            completed: false,
            startedAt: new Date().toISOString(),
            timeSpent: 0,
          };

          courseSession.lessonsStarted++;
          saveProgress();

          // Log lesson start
          logUserActivity("lesson_start", {
            lesson_id: lesson.id,
            lesson_title: lesson.title,
            lesson_index: index,
          });
        }

        // Update lesson start time for time tracking
        courseProgress[lesson.id].currentSessionStart = new Date();

        // Update sidebar and navigation
        renderSidebar();
        updateNavigationButtons();

        // Update header info
        updateLessonHeader(lesson, index);

        // Render lesson content
        renderLessonContent(lesson);

        // Smooth scroll and animations
        window.scrollTo({ top: 0, behavior: "smooth" });
        document.getElementById("contentBody").scrollTop = 0;

        const contentBody = document.getElementById("contentBody");
        contentBody.classList.add("fade-in");
        setTimeout(() => contentBody.classList.remove("fade-in"), 500);

        // Check lesson-based achievements
        checkLessonAchievements(index + 1);
      }

      function updateLessonHeader(lesson, index) {
        const elements = {
          currentLessonNumber: index + 1,
          currentLessonTitle: lesson.title,
          navInfo: `Lesson ${index + 1} of ${COURSE_DATA.lessons.length}`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });
      }

      function renderSidebar() {
        const lessonNav = document.getElementById("lessonNav");
        if (!lessonNav) return;

        lessonNav.innerHTML = "";

        COURSE_DATA.lessons.forEach((lesson, index) => {
          const lessonItem = document.createElement("div");
          lessonItem.className = "lesson-item";

          // Determine lesson status
          const lessonProgress = courseProgress[lesson.id];
          const isCompleted = lessonProgress?.completed || false;
          const isInProgress = lessonProgress?.started || false;
          const isLocked = !isCompleted && !canAccessLesson(index);
          const isActive = index === currentLessonIndex;

          // Apply status classes
          if (isCompleted) lessonItem.classList.add("completed");
          if (isLocked) lessonItem.classList.add("locked");
          if (isActive) lessonItem.classList.add("active");

          // Determine status display
          let statusClass = "not-started";
          let statusIcon = index + 1;

          if (isCompleted) {
            statusClass = "completed";
            statusIcon = "✓";
          } else if (isInProgress) {
            statusClass = "in-progress";
            statusIcon = "◐";
          }

          // Create lesson item HTML
          lessonItem.innerHTML = `
            <div class="lesson-status ${statusClass}">${statusIcon}</div>
            <div class="lesson-info">
                <div class="lesson-title">${lesson.title}</div>
                <div class="lesson-meta">
                    ${
                      isCompleted
                        ? "Completed"
                        : isInProgress
                        ? "In Progress"
                        : isLocked
                        ? "Locked"
                        : "Not Started"
                    }
                </div>
            </div>
            <div class="lesson-duration">${lesson.duration}</div>
        `;

          // Add click handler if not locked
          if (!isLocked) {
            lessonItem.addEventListener("click", () => {
              if (index !== currentLessonIndex) {
                // Track lesson time before switching
                trackLessonTime();

                currentLessonIndex = index;
                loadLesson(index);
                closeSidebar();
              }
            });
          }

          lessonNav.appendChild(lessonItem);
        });
      }

      function canAccessLesson(index) {
        if (index === 0) return true; // First lesson always accessible

        // Can access if previous lesson is completed
        const previousLessonId = COURSE_DATA.lessons[index - 1].id;
        return courseProgress[previousLessonId]?.completed || false;
      }

      function trackLessonTime() {
        const currentLesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonProgress = courseProgress[currentLesson.id];

        if (lessonProgress?.currentSessionStart) {
          const sessionTime = Math.floor(
            (new Date() - new Date(lessonProgress.currentSessionStart)) /
              1000 /
              60
          );
          lessonProgress.timeSpent =
            (lessonProgress.timeSpent || 0) + sessionTime;
          delete lessonProgress.currentSessionStart;
        }
      }

      // =====================================================
      // LESSON CONTENT RENDERING
      // =====================================================
      function renderLessonContent(lesson) {
        const contentContainer = document.getElementById("lessonContent");
        if (!contentContainer) return;

        let contentHTML = `
        <div class="content-section">
            <h2>Learning Objectives</h2>
            <ul>
                ${lesson.objectives.map((obj) => `<li>${obj}</li>`).join("")}
            </ul>
        </div>
        
        <div class="content-section">
            <h2>Overview</h2>
            <p>${lesson.content.overview}</p>
        </div>
    `;

        // Render content sections
        lesson.content.sections.forEach((section) => {
          contentHTML += `
            <div class="content-section">
                <h2>${section.title}</h2>
                ${section.content}
                ${
                  section.image
                    ? `<img src="${section.image}" alt="${section.title}" class="content-image" loading="lazy">`
                    : ""
                }
            </div>
        `;
        });

        // Render code examples
        if (
          lesson.content.codeExamples &&
          lesson.content.codeExamples.length > 0
        ) {
          contentHTML += `<div class="content-section"><h2>Code Examples</h2></div>`;

          lesson.content.codeExamples.forEach((example, index) => {
            const codeId = `code-${lesson.id}-${index}`;
            contentHTML += `
                <div class="code-section">
                    <div class="code-header">
                        <span class="code-title">${example.title}</span>
                        <button class="copy-btn" onclick="copyCode('${codeId}')">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <pre class="code-block"><code id="${codeId}" class="language-${
              example.language
            }">${escapeHtml(example.code)}</code></pre>
                </div>
            `;
          });
        }

        // Render quiz
        contentHTML += renderQuiz(lesson.quiz);

        contentContainer.innerHTML = contentHTML;

        // Highlight code syntax if Prism is available
        setTimeout(() => {
          if (window.Prism) {
            Prism.highlightAll();
          }
        }, 100);
      }

      // =====================================================
      // QUIZ SYSTEM
      // =====================================================
      function renderQuiz(quiz) {
        const currentLessonProgress =
          courseProgress[COURSE_DATA.lessons[currentLessonIndex].id];
        const isCompleted = currentLessonProgress?.completed || false;

        let quizHTML = `
        <div class="quiz-section" id="quizSection">
            <div class="quiz-header">
                <h2 class="quiz-title">
                    <i class="fas fa-clipboard-check"></i>
                    Knowledge Check
                </h2>
                <p class="quiz-info">
                    Complete this quiz with ${quiz.passingScore}% or higher to unlock the next lesson.
                </p>
            </div>
    `;

        if (isCompleted) {
          const savedScore = currentLessonProgress.quizScore || 0;
          quizHTML += `
            <div class="quiz-results show">
                <div class="quiz-score pass">${savedScore}%</div>
                <div class="quiz-message">
                    <strong>Lesson Completed!</strong><br>
                    You've successfully passed this lesson's quiz.
                </div>
            </div>
        `;
        } else {
          // Render quiz questions
          quiz.questions.forEach((question, qIndex) => {
            quizHTML += `
                <div class="quiz-question ${
                  qIndex === 0 ? "active" : ""
                }" data-question="${qIndex}">
                    <div class="question-header">
                        <span class="question-number">Question ${
                          qIndex + 1
                        }</span>
                        <span class="question-progress">${qIndex + 1}/${
              quiz.questions.length
            }</span>
                    </div>
                    <div class="question-text">${question.question}</div>
                    <div class="question-options">
                        ${question.options
                          .map(
                            (option, oIndex) => `
                            <div class="option" data-option="${oIndex}" onclick="selectOption(${qIndex}, ${oIndex})">
                                <span class="option-letter">${String.fromCharCode(
                                  65 + oIndex
                                )}</span>
                                <span class="option-text">${option}</span>
                            </div>
                        `
                          )
                          .join("")}
                    </div>
                </div>
            `;
          });

          quizHTML += `
            <div class="quiz-controls">
                <button class="btn btn-secondary" id="prevQuestionBtn" onclick="previousQuestion()" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <div>
                    <button class="btn btn-secondary" id="nextQuestionBtn" onclick="nextQuestion()" disabled>
                        Next
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <button class="btn btn-primary" id="submitQuizBtn" onclick="submitQuiz()" style="display: none;">
                        <i class="fas fa-check"></i>
                        Submit Quiz
                    </button>
                </div>
            </div>

            <div class="quiz-results" id="quizResults">
                <div class="quiz-score" id="quizScore">0%</div>
                <div class="quiz-message" id="quizMessage"></div>
                <div class="quiz-actions">
                    <button class="btn btn-primary" id="continueBtn" onclick="completeLesson()" style="display: none;">
                        <i class="fas fa-arrow-right"></i>
                        Continue to Next Lesson
                    </button>
                    <button class="btn btn-secondary" onclick="retakeQuiz()">
                        <i class="fas fa-redo"></i>
                        Retake Quiz
                    </button>
                </div>
            </div>
        `;
        }

        quizHTML += "</div>";
        return quizHTML;
      }

      // Quiz interaction functions
      function selectOption(questionIndex, optionIndex) {
        // Clear previous selections
        document
          .querySelectorAll(`[data-question="${questionIndex}"] .option`)
          .forEach((opt) => {
            opt.classList.remove("selected");
          });

        // Select current option
        const selectedOption = document.querySelector(
          `[data-question="${questionIndex}"] [data-option="${optionIndex}"]`
        );
        selectedOption.classList.add("selected");

        // Store answer
        quizState.answers[questionIndex] = optionIndex;

        // Update navigation
        const isLastQuestion =
          questionIndex ===
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length - 1;
        if (isLastQuestion) {
          document.getElementById("submitQuizBtn").style.display =
            "inline-flex";
          document.getElementById("nextQuestionBtn").style.display = "none";
        } else {
          document.getElementById("nextQuestionBtn").disabled = false;
        }
      }

      function nextQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const nextQuestionEl = currentQuestionEl.nextElementSibling;

        if (
          nextQuestionEl &&
          nextQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          nextQuestionEl.classList.add("active");
          quizState.currentQuestion++;
          updateQuizNavigation();
        }
      }

      function previousQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const prevQuestionEl = currentQuestionEl.previousElementSibling;

        if (
          prevQuestionEl &&
          prevQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          prevQuestionEl.classList.add("active");
          quizState.currentQuestion--;
          updateQuizNavigation();
        }
      }

      function updateQuizNavigation() {
        const totalQuestions =
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length;
        const prevBtn = document.getElementById("prevQuestionBtn");
        const nextBtn = document.getElementById("nextQuestionBtn");
        const submitBtn = document.getElementById("submitQuizBtn");

        prevBtn.disabled = quizState.currentQuestion === 0;

        const hasAnswer =
          quizState.answers[quizState.currentQuestion] !== undefined;
        const isLastQuestion = quizState.currentQuestion === totalQuestions - 1;

        if (isLastQuestion) {
          nextBtn.style.display = "none";
          submitBtn.style.display = hasAnswer ? "inline-flex" : "none";
        } else {
          nextBtn.style.display = "inline-flex";
          nextBtn.disabled = !hasAnswer;
          submitBtn.style.display = "none";
        }
      }

      async function submitQuiz() {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const quiz = lesson.quiz;
        let correctAnswers = 0;

        // Hide questions and controls
        document
          .querySelectorAll(".quiz-question")
          .forEach((q) => (q.style.display = "none"));
        document.querySelector(".quiz-controls").style.display = "none";

        // Calculate score and highlight answers
        quiz.questions.forEach((question, index) => {
          const userAnswer = quizState.answers[index];
          const correctAnswer = question.correct;
          const isCorrect = userAnswer === correctAnswer;

          if (isCorrect) correctAnswers++;

          // Highlight answers
          const questionEl = document.querySelector(
            `[data-question="${index}"]`
          );
          const options = questionEl.querySelectorAll(".option");

          options[correctAnswer].classList.add("correct");
          if (userAnswer !== correctAnswer && userAnswer !== undefined) {
            options[userAnswer].classList.add("incorrect");
          }
        });

        const score = Math.round(
          (correctAnswers / quiz.questions.length) * 100
        );
        const passed = score >= quiz.passingScore;

        // Update quiz results UI
        const quizScore = document.getElementById("quizScore");
        const quizMessage = document.getElementById("quizMessage");
        const quizActions = document.querySelector(".quiz-actions");

        quizScore.textContent = `${score}%`;
        quizScore.className = `quiz-score ${passed ? "pass" : "fail"}`;

        if (passed) {
          quizMessage.innerHTML = `
            <strong>Congratulations!</strong><br>
            You passed with ${score}%. You can now proceed to the next lesson.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-primary" onclick="completeLesson()">
                <i class="fas fa-arrow-right"></i>
                Continue to Next Lesson
            </button>
        `;

          // Mark lesson as completed
          await markLessonComplete(score);
        } else {
          quizMessage.innerHTML = `
            <strong>Not quite there yet.</strong><br>
            You scored ${score}%. You need ${quiz.passingScore}% to pass. Review the material and try again.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-secondary" onclick="retakeQuiz()">
                <i class="fas fa-redo"></i>
                Retake Quiz
            </button>
        `;
        }

        document.getElementById("quizResults").classList.add("show");

        // Log quiz completion
        logUserActivity("quiz_completed", {
          lesson_id: lesson.id,
          lesson_title: lesson.title,
          score: score,
          passed: passed,
          attempts: (courseProgress[lesson.id]?.quizAttempts || 0) + 1,
        });

        // Scroll to results
        document
          .getElementById("quizResults")
          .scrollIntoView({ behavior: "smooth" });
      }

      function retakeQuiz() {
        // Reset quiz state
        quizState = {
          currentQuestion: 0,
          answers: [],
          score: 0,
          isComplete: false,
        };

        // Track quiz retry
        const lessonId = COURSE_DATA.lessons[currentLessonIndex].id;
        if (!courseProgress[lessonId]) courseProgress[lessonId] = {};
        courseProgress[lessonId].quizAttempts =
          (courseProgress[lessonId].quizAttempts || 0) + 1;

        // Reload lesson content
        loadLesson(currentLessonIndex);

        // Scroll to quiz
        setTimeout(() => {
          document
            .getElementById("quizSection")
            .scrollIntoView({ behavior: "smooth" });
        }, 500);
      }

      async function markLessonComplete(score) {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonId = lesson.id;

        // Track lesson completion time
        trackLessonTime();

        // Update lesson progress
        courseProgress[lessonId] = {
          ...courseProgress[lessonId],
          completed: true,
          quizScore: score,
          completedAt: new Date().toISOString(),
          finalScore: score,
        };

        // Update session tracking
        courseSession.lessonsCompleted++;

        // Save progress to database
        await saveProgress();

        // Update UI
        renderSidebar();
        updateNavigationButtons();

        // Check various achievements
        await checkLessonCompletionAchievements();
        await checkPerfectScoreAchievements(score);
        await checkStudyTimeAchievements();

        // Log lesson completion
        logUserActivity("lesson_completed", {
          lesson_id: lessonId,
          lesson_title: lesson.title,
          final_score: score,
          time_spent: courseProgress[lessonId].timeSpent || 0,
          lesson_number: currentLessonIndex + 1,
        });

        showToast("Lesson completed successfully!", "success");
      }

      async function completeLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          // Move to next lesson
          currentLessonIndex++;
          loadLesson(currentLessonIndex);
        } else {
          // Course completion
          await completeCourse();
        }
      }

      async function completeCourse() {
        try {
          const completionTime = courseSession.totalStudyTime;

          // Update course progress to 100% completed
          await supabase
            .from("course_progress")
            .update({
              progress: 100,
              completed_at: new Date().toISOString(),
              completion_time_minutes: completionTime,
            })
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Award course completion achievements
          await checkAndUnlockAchievement("course_completion_1");
          await checkSpeedCompletionAchievements(completionTime);
          await checkCourseStreakAchievements();

          // Update user stats
          await updateUserStats();

          // Show completion message
          showToast(
            "Congratulations! Course completed successfully!",
            "certificate"
          );

          // Log course completion
          logUserActivity("course_completed", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            completion_time_minutes: completionTime,
            total_lessons: COURSE_DATA.lessons.length,
            average_quiz_score: calculateAverageQuizScore(),
          });

          // Redirect to dashboard after delay
          setTimeout(() => {
            window.location.href = "/dashboard.html";
          }, 3000);
        } catch (error) {
          console.error("Error completing course:", error);
          showToast("Error marking course as complete", "error");
        }
      }

      // =====================================================
      // ACHIEVEMENT INTEGRATION SYSTEM
      // =====================================================
      async function checkAndUnlockAchievement(
        achievementId,
        skipNotification = false
      ) {
        try {
          // Prevent duplicate checks
          const cacheKey = `achievement_${achievementId}_${currentUser.id}`;
          if (sessionStorage.getItem(cacheKey)) return false;

          // Check if already unlocked
          const { data: existing, error } = await supabase
            .from("user_achievements")
            .select("id")
            .eq("user_id", currentUser.id)
            .eq("achievement_id", achievementId)
            .single();

          if (existing) {
            sessionStorage.setItem(cacheKey, "true");
            return false;
          }

          // Award achievement
          const achievementData = {
            user_id: currentUser.id,
            achievement_id: achievementId,
            unlocked_at: new Date().toISOString(),
            points_awarded: getAchievementPoints(achievementId),
            context: "course_system",
          };

          const { data, error: insertError } = await supabase
            .from("user_achievements")
            .insert([achievementData])
            .select()
            .single();

          if (insertError) {
            if (insertError.code === "23505") return false; // Already exists
            throw insertError;
          }

          // Update user points
         await supabase.rpc('increment_user_stats', {
  user_id_param: currentUser.id,
  points_to_add: achievementData.points_awarded,
  achievements_to_add: 1
});

          // Cache and queue notification
          sessionStorage.setItem(cacheKey, "true");

          if (!skipNotification) {
            queueAchievementNotification({
              id: achievementId,
              name: getAchievementName(achievementId),
              description: getAchievementDescription(achievementId),
              points: achievementData.points_awarded,
              rarity: getAchievementRarity(achievementId),
              icon: getAchievementIcon(achievementId),
            });
          }

          return true;
        } catch (error) {
          console.error("Error unlocking achievement:", error);
          return false;
        }
      }

      // Helper functions for achievement data (replace with your actual achievement definitions)
      function getAchievementPoints(id) {
        const pointsMap = {
          first_course_start: 75,
          first_lesson: 100,
          course_completion_1: 500,
          perfect_score: 250,
          speed_demon: 750,
          marathon_learner: 500,
          night_owl: 200,
          early_bird: 200,
          weekend_warrior: 150,
          // Add more as needed
        };
        return pointsMap[id] || 100;
      }

      function getAchievementName(id) {
        const nameMap = {
          first_course_start: "Learning Initiated",
          first_lesson: "First Steps",
          course_completion_1: "Course Conqueror",
          perfect_score: "Perfectionist",
          speed_demon: "Speed Demon",
          // Add more as needed
        };
        return nameMap[id] || "Achievement Unlocked";
      }

      function getAchievementDescription(id) {
        const descMap = {
          first_course_start: "Start your first cybersecurity course",
          first_lesson: "Complete your first lesson",
          course_completion_1: "Complete your first course",
          perfect_score: "Score 100% on any quiz",
          speed_demon: "Complete a course in under 2 hours",
          // Add more as needed
        };
        return descMap[id] || "Achievement description";
      }

      function getAchievementRarity(id) {
        const rarityMap = {
          first_course_start: "common",
          first_lesson: "bronze",
          course_completion_1: "silver",
          perfect_score: "gold",
          speed_demon: "legendary",
          // Add more as needed
        };
        return rarityMap[id] || "common";
      }

      function getAchievementIcon(id) {
        const iconMap = {
          first_course_start: "fas fa-play",
          first_lesson: "fas fa-baby",
          course_completion_1: "fas fa-trophy",
          perfect_score: "fas fa-star",
          speed_demon: "fas fa-rocket",
          // Add more as needed
        };
        return iconMap[id] || "fas fa-award";
      }

      async function checkLessonAchievements(lessonNumber) {
        if (lessonNumber === 1) {
          await checkAndUnlockAchievement("first_lesson");
        }

        // Check if user has completed multiple lessons in one day
        const today = new Date().toISOString().split("T")[0];
        const todayCompletions = Object.values(courseProgress).filter(
          (p) => p.completed && p.completedAt?.startsWith(today)
        ).length;

        if (todayCompletions >= 3) {
          await checkAndUnlockAchievement("lesson_marathon");
        }
      }

      async function checkLessonCompletionAchievements() {
        const completedCount = getCompletedLessonsCount();

        // Lesson-based achievements
        const lessonMilestones = [1, 5, 10, 25, 50, 100];
        for (const milestone of lessonMilestones) {
          if (completedCount >= milestone) {
            await checkAndUnlockAchievement(`lessons_${milestone}`);
          }
        }

        // Course completion achievements
        if (completedCount === COURSE_DATA.lessons.length) {
          await checkAndUnlockAchievement("course_completion_1");

          // Check for additional course completion achievements
          const { data: allCourses } = await supabase
            .from("course_progress")
            .select("course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100);

          const totalCompleted = allCourses?.length || 0;

          const courseMilestones = [1, 5, 10, 25];
          for (const milestone of courseMilestones) {
            if (totalCompleted >= milestone) {
              await checkAndUnlockAchievement(`course_completion_${milestone}`);
            }
          }
        }
      }

      async function checkPerfectScoreAchievements(score) {
        if (score === 100) {
          await checkAndUnlockAchievement("perfect_score");

          // Check for consecutive perfect scores
          const recentScores = Object.values(courseProgress)
            .filter((p) => p.completed && p.quizScore)
            .slice(-5) // Last 5 completed
            .map((p) => p.quizScore);

          if (
            recentScores.length >= 3 &&
            recentScores.every((s) => s === 100)
          ) {
            await checkAndUnlockAchievement("perfectionist_streak");
          }
        }
      }

      async function checkSpeedCompletionAchievements(completionTime) {
        // Speed demon: Complete course in under 2 hours (120 minutes)
        if (completionTime <= 120) {
          await checkAndUnlockAchievement("speed_demon");
        }

        // Quick learner: Complete course in under 4 hours (240 minutes)
        if (completionTime <= 240) {
          await checkAndUnlockAchievement("quick_learner");
        }
      }

      async function checkStudyTimeAchievements() {
        const totalTime = courseSession.totalStudyTime;

        // Marathon learner: Study for 8+ hours in a course session
        if (totalTime >= 480) {
          // 8 hours
          await checkAndUnlockAchievement("marathon_learner");
        }

        // Dedicated learner: Study for 4+ hours
        if (totalTime >= 240) {
          // 4 hours
          await checkAndUnlockAchievement("dedicated_learner");
        }
      }

      async function checkCourseStreakAchievements() {
        try {
          // Check for consecutive course completions
          const { data: recentCourses, error } = await supabase
            .from("course_progress")
            .select("completed_at, course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100)
            .order("completed_at", { ascending: false })
            .limit(10);

          if (error || !recentCourses) return;

          // Check for courses completed on consecutive days
          let consecutiveDays = 1;
          for (let i = 1; i < recentCourses.length; i++) {
            const prevDate = new Date(
              recentCourses[i - 1].completed_at
            ).toDateString();
            const currentDate = new Date(
              recentCourses[i].completed_at
            ).toDateString();
            const dayDiff =
              Math.abs(new Date(prevDate) - new Date(currentDate)) /
              (1000 * 60 * 60 * 24);

            if (dayDiff <= 1) {
              consecutiveDays++;
            } else {
              break;
            }
          }

          if (consecutiveDays >= 3) {
            await checkAndUnlockAchievement("learning_streak");
          }
        } catch (error) {
          console.error("Error checking course streak achievements:", error);
        }
      }

      // =====================================================
      // TIME-BASED ACHIEVEMENTS
      // =====================================================
      async function checkTimeBasedAchievements(timestamp) {
        const hour = timestamp.getHours();
        const dayOfWeek = timestamp.getDay();

        // Night owl (after midnight, before 6 AM)
        if (hour >= 0 && hour < 6) {
          await incrementTimeBasedCounter("midnight_sessions", "night_owl");
        }

        // Early bird (4 AM to 6 AM)
        if (hour >= 4 && hour < 6) {
          await incrementTimeBasedCounter("early_sessions", "early_bird");
        }

        // Weekend warrior (Saturday = 6, Sunday = 0)
        if (dayOfWeek === 0 || dayOfWeek === 6) {
          await incrementTimeBasedCounter(
            "weekend_sessions",
            "weekend_warrior"
          );
        }
      }

      async function incrementTimeBasedCounter(counterType, achievementId) {
        try {
          const dateStr = new Date().toISOString().split("T")[0];
          const cacheKey = `${counterType}_${currentUser.id}_${dateStr}`;

          // Prevent multiple increments per day
          if (sessionStorage.getItem(cacheKey)) return;

          // Update counter
          await supabase
            .from("profiles")
            .update({
              [counterType]: supabase.sql`${counterType} + 1`,
            })
            .eq("id", currentUser.id);

          // Cache to prevent double counting
          sessionStorage.setItem(cacheKey, "true");

          // Check related achievement
          if (achievementId) {
            await checkAndUnlockAchievement(achievementId, true);
          }
        } catch (error) {
          console.error(`Error incrementing ${counterType}:`, error);
        }
      }

      async function checkDailyStreak() {
        try {
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("last_activity, current_streak, last_streak_date")
            .eq("id", currentUser.id)
            .single();

          if (error) throw error;

          const now = new Date();
          const today = now.toDateString();
          const lastActivity = profile.last_activity
            ? new Date(profile.last_activity)
            : null;
          const lastStreakDate = profile.last_streak_date
            ? new Date(profile.last_streak_date).toDateString()
            : null;

          let newStreak = profile.current_streak || 0;
          let shouldUpdateStreak = false;

          if (!lastActivity) {
            // First time user
            newStreak = 1;
            shouldUpdateStreak = true;
          } else {
            const daysSinceLastActivity = Math.floor(
              (now - lastActivity) / (1000 * 60 * 60 * 24)
            );

            if (lastStreakDate === today) {
              // Already counted today's streak
              return newStreak;
            } else if (
              daysSinceLastActivity === 1 ||
              (daysSinceLastActivity === 0 && lastStreakDate !== today)
            ) {
              // Consecutive day or same day but not counted yet
              newStreak += 1;
              shouldUpdateStreak = true;
            } else if (daysSinceLastActivity > 1) {
              // Streak broken
              newStreak = 1;
              shouldUpdateStreak = true;
            }
          }

          if (shouldUpdateStreak) {
            await supabase
              .from("profiles")
              .update({
                current_streak: newStreak,
                last_activity: now.toISOString(),
                last_streak_date: now.toISOString(),
              })
              .eq("id", currentUser.id);

            userStats.current_streak = newStreak;

            showToast(`Daily streak: ${newStreak} days!`, "success");
            await checkStreakAchievements(newStreak);
          }

          return newStreak;
        } catch (error) {
          console.error("Error checking daily streak:", error);
          return 0;
        }
      }

      async function checkStreakAchievements(currentStreak) {
        const streakMilestones = [3, 7, 14, 30, 100, 365];

        for (const milestone of streakMilestones) {
          if (currentStreak >= milestone) {
            await checkAndUnlockAchievement(`streak_${milestone}`);
          }
        }
      }

      // =====================================================
      // USER ACTIVITY LOGGING
      // =====================================================
      async function logUserActivity(activityType, metadata = {}) {
        try {
          const now = new Date();

          const activityData = {
            user_id: currentUser.id,
            activity_type: activityType,
            timestamp: now.toISOString(),
            course_id: COURSE_DATA.id,
            lesson_index: currentLessonIndex,
            session_duration: courseSession.totalStudyTime,
            metadata: JSON.stringify(metadata),
            created_at: now.toISOString(),
          };

          // Try to log to activities table
          const { error } = await supabase
            .from("user_activities")
            .insert([activityData]);

          if (error && error.code !== "42P01") {
            console.warn("Activity logging failed:", error.message);
          }

          // Always update last activity in profile
          await supabase
            .from("profiles")
            .update({ last_activity: now.toISOString() })
            .eq("id", currentUser.id);
        } catch (error) {
          console.error("Error logging user activity:", error);
        }
      }

      // =====================================================
      // NAVIGATION SYSTEM
      // =====================================================
      function updateNavigationButtons() {
        const prevBtn = document.getElementById("prevLessonBtn");
        const nextBtn = document.getElementById("nextLessonBtn");

        if (!prevBtn || !nextBtn) return;

        // Previous button
        prevBtn.disabled = currentLessonIndex === 0;

        // Next button logic
        const isLastLesson =
          currentLessonIndex === COURSE_DATA.lessons.length - 1;
        const canGoNext =
          currentLessonIndex < COURSE_DATA.lessons.length - 1 &&
          canAccessLesson(currentLessonIndex + 1);

        if (isLastLesson) {
          const isCurrentCompleted =
            courseProgress[COURSE_DATA.lessons[currentLessonIndex].id]
              ?.completed;
          nextBtn.disabled = !isCurrentCompleted;
          nextBtn.innerHTML = '<i class="fas fa-trophy"></i> Complete Course';
        } else {
          nextBtn.disabled = !canGoNext;
          nextBtn.innerHTML = 'Next <i class="fas fa-chevron-right"></i>';
        }
      }

      // Navigation button event handlers
      function goToPreviousLesson() {
        if (currentLessonIndex > 0) {
          trackLessonTime(); // Track time spent on current lesson
          currentLessonIndex--;
          loadLesson(currentLessonIndex);
        }
      }

      function goToNextLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          const canGoNext = canAccessLesson(currentLessonIndex + 1);
          if (canGoNext) {
            trackLessonTime();
            currentLessonIndex++;
            loadLesson(currentLessonIndex);
          } else {
            showToast("Complete the current lesson quiz to proceed", "warning");
          }
        } else {
          // Complete course
          completeCourse();
        }
      }

      // =====================================================
      // SIDEBAR FUNCTIONS
      // =====================================================
      function toggleSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.toggle("open");
        if (overlay) overlay.classList.toggle("active");
      }

      function closeSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.remove("open");
        if (overlay) overlay.classList.remove("active");
      }

      // =====================================================
      // ACHIEVEMENT NOTIFICATION SYSTEM
      // =====================================================
      function queueAchievementNotification(achievement) {
        notificationQueue.push(achievement);
        processNotificationQueue();
      }

      function processNotificationQueue() {
        if (isShowingNotification || notificationQueue.length === 0) return;

        isShowingNotification = true;
        const achievement = notificationQueue.shift();
        showAchievementNotification(achievement);

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          isShowingNotification = false;
          processNotificationQueue();
        }, duration + 500);
      }

      function showAchievementNotification(achievement) {
        const notification = document.getElementById("achievementNotification");
        if (!notification) return;

        const icon = document.getElementById("notificationIcon");
        const title = document.getElementById("notificationTitle");
        const description = document.getElementById("notificationDescription");
        const points = document.getElementById("notificationPoints");

        if (icon) {
          icon.innerHTML = `<i class="${achievement.icon}"></i>`;
          icon.className = `notification-icon ${achievement.rarity}`;
        }
        if (title) title.textContent = achievement.name;
        if (description) description.textContent = achievement.description;
        if (points) points.textContent = `+${achievement.points} Points`;

        notification.className = `achievement-notification ${achievement.rarity}`;
        notification.classList.add("show");

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          notification.classList.remove("show");
        }, duration);
      }

      // =====================================================
      // UTILITY FUNCTIONS
      // =====================================================
      function calculateAverageQuizScore() {
        const scores = Object.values(courseProgress)
          .filter((p) => p.completed && p.quizScore)
          .map((p) => p.quizScore);

        if (scores.length === 0) return 0;
        return Math.round(
          scores.reduce((sum, score) => sum + score, 0) / scores.length
        );
      }

      async function resetProgress() {
        if (
          !confirm(
            "Are you sure you want to reset your progress? This action cannot be undone."
          )
        ) {
          return;
        }

        try {
          // Track lesson time before reset
          trackLessonTime();

          // Reset local state
          courseProgress = {};
          currentLessonIndex = 0;
          courseSession = {
            startTime: new Date(),
            totalStudyTime: 0,
            lessonsStarted: 0,
            lessonsCompleted: 0,
            pageLoadTime: new Date(),
            interactionCount: 0,
            lastActivityTime: new Date(),
          };

          // Delete from database
          await supabase
            .from("course_progress")
            .delete()
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Log reset activity
          logUserActivity("progress_reset", {
            course_id: COURSE_DATA.id,
            reset_reason: "manual",
          });

          // Reinitialize
          await saveProgress();
          renderSidebar();
          loadLesson(0);

          showToast("Progress reset successfully", "success");
        } catch (error) {
          console.error("Error resetting progress:", error);
          showToast("Failed to reset progress", "error");
        }
      }

      function copyCode(codeId) {
        const codeElement = document.getElementById(codeId);
        if (!codeElement) return;

        const text = codeElement.textContent;

        navigator.clipboard
          .writeText(text)
          .then(() => {
            showToast("Code copied to clipboard!", "success");

            // Track code copy for achievements
            logUserActivity("code_copied", {
              code_section: codeId,
              lesson_id: COURSE_DATA.lessons[currentLessonIndex].id,
            });
          })
          .catch((err) => {
            console.error("Failed to copy code:", err);
            showToast("Failed to copy code", "error");

            // Fallback for older browsers
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            try {
              document.execCommand("copy");
              showToast("Code copied to clipboard!", "success");
            } catch (fallbackError) {
              showToast(
                "Copy failed - please select and copy manually",
                "error"
              );
            }
            document.body.removeChild(textArea);
          });
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // =====================================================
      // UI FEEDBACK SYSTEMS
      // =====================================================
      function showToast(message, type = "success") {
        const toast = document.getElementById("toast");
        const messageEl = document.getElementById("toastMessage");

        if (!toast || !messageEl) {
          console.log(`Toast: ${message} (${type})`);
          return;
        }

        messageEl.textContent = message;
        toast.className = `toast ${type} show`;

        setTimeout(() => {
          toast.classList.remove("show");
        }, 4000);
      }

      function showLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) loadingScreen.classList.remove("hidden");
      }

      function hideLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) {
          setTimeout(() => {
            loadingScreen.classList.add("hidden");
          }, 1000);
        }
      }

      // =====================================================
      // MUSIC PLAYER INTEGRATION
      // =====================================================
      function initMusicPlayer() {
        const btnText = document.getElementById("music-button-text");
        const icon = document.getElementById("music-icon");
        const dropdown = document.getElementById("music-dropdown-content");

        if (!btnText || !icon || !dropdown) return;

        function setUI(state) {
          btnText.textContent =
            state === "Playing" ? "PAUSE MUSIC" : "STUDY MUSIC";
          icon.className =
            state === "Playing"
              ? "fa-solid fa-circle-pause"
              : "fa-solid fa-music";
        }

        // Load saved music state
        const savedSrc = localStorage.getItem("cybersec_music_src");
        const savedTime = parseFloat(
          localStorage.getItem("cybersec_music_time") || 0
        );

        if (savedSrc) {
          audioPlayer.src = savedSrc;
          audioPlayer.currentTime = savedTime;
          audioPlayer
            .play()
            .then(() => setUI("Playing"))
            .catch(() => setUI("Stopped"));
        }

        // Music button click handler
        document
          .getElementById("music-dropdown")
          .querySelector("button")
          .addEventListener("click", (e) => {
            e.stopPropagation();
            dropdown.style.display =
              dropdown.style.display === "block" ? "none" : "block";

            if (audioPlayer.src && !audioPlayer.paused) {
              audioPlayer.pause();
              setUI("Stopped");
            } else if (audioPlayer.src) {
              audioPlayer.play().then(() => setUI("Playing"));
            }
          });

        // Music selection handlers
        dropdown.querySelectorAll("a[data-src]").forEach((link) => {
          link.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.src = link.dataset.src;
            audioPlayer.play().then(() => setUI("Playing"));
            localStorage.setItem("cybersec_music_src", link.dataset.src);
            dropdown.style.display = "none";
          });
        });

        // Stop music handler
        const stopLink = document.getElementById("stop-music-link");
        if (stopLink) {
          stopLink.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            audioPlayer.removeAttribute("src");
            setUI("Stopped");
            localStorage.removeItem("cybersec_music_src");
            localStorage.removeItem("cybersec_music_time");
            dropdown.style.display = "none";
          });
        }

        // Save music state before page unload
        window.addEventListener("beforeunload", () => {
          if (!audioPlayer.paused && audioPlayer.src) {
            localStorage.setItem("cybersec_music_src", audioPlayer.src);
            localStorage.setItem(
              "cybersec_music_time",
              audioPlayer.currentTime
            );
          }
        });

        // Close dropdown when clicking outside
        window.addEventListener("click", (e) => {
          if (!e.target.closest("#music-dropdown")) {
            dropdown.style.display = "none";
          }
        });
      }

      // Show initial music indicator
      function addMusicIndicator() {
        const musicBtn = document.querySelector("#music-dropdown");
        if (musicBtn) {
          const indicator = document.createElement("div");
          indicator.className = "music-indicator";
          indicator.innerHTML = `<i class="fa-solid fa-music"></i> Try Study Music!`;

          musicBtn.style.position = "relative";
          musicBtn.appendChild(indicator);

          setTimeout(() => indicator.remove(), 3000);
        }
      }

      // Initialize Event Listeners
      function initializeEventListeners() {
        // Navigation buttons
        document
          .getElementById("prevLessonBtn")
          ?.addEventListener("click", goToPreviousLesson);
        document
          .getElementById("nextLessonBtn")
          ?.addEventListener("click", goToNextLesson);

        // Reset progress button
        document
          .getElementById("resetProgressBtn")
          ?.addEventListener("click", resetProgress);

        // Mobile menu toggle
        document
          .getElementById("menuToggle")
          ?.addEventListener("click", toggleSidebar);
        document
          .getElementById("sidebarOverlay")
          ?.addEventListener("click", closeSidebar);

        // Keyboard shortcuts
        document.addEventListener("keydown", handleKeyboardShortcuts);

        // Window resize handler
        window.addEventListener("resize", handleWindowResize);

        // Content interaction tracking
        document.getElementById("contentBody")?.addEventListener(
          "scroll",
          debounce(() => {
            trackUserInteraction();
          }, 1000)
        );
      }

      // Keyboard Shortcuts
      function handleKeyboardShortcuts(e) {
        if (document.querySelector(".quiz-question.active")) return;

        if (e.key === "ArrowLeft" && e.ctrlKey) {
          e.preventDefault();
          goToPreviousLesson();
        } else if (e.key === "ArrowRight" && e.ctrlKey) {
          e.preventDefault();
          goToNextLesson();
        }
      }

      // Window Resize Handler
      function handleWindowResize() {
        if (window.innerWidth > 768) {
          closeSidebar();
        }
      }

      // Debounce Helper
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Initialize responsive behavior
      if (window.innerWidth <= 768) {
        document.getElementById("menuToggle").style.display = "inline-flex";
      }

      // Auto-save progress periodically
      setInterval(async () => {
        if (currentUser && Object.keys(courseProgress).length > 0) {
          await saveProgress();
        }
      }, 60000); // Save every minute

      // System initialization logging
      console.log("CyberSec Academy Course System Initialized");
      console.log("Current Course:", COURSE_DATA.title);
      console.log("Total Lessons:", COURSE_DATA.lessons.length);

      // Google OAuth Integration
      const googleBtn = document.querySelector(".btn-google");
      if (googleBtn) {
        googleBtn.addEventListener("click", async () => {
          const { data, error } = await supabase.auth.signInWithOAuth({
            provider: "google",
            options: {
              redirectTo:
                window.location.origin +
                "/courses/complete-application-hardening-course.html",
            },
          });

          if (error) {
            console.error("Google login error:", error.message);
            showToast("Google login failed: " + error.message, "error");
          }
        });
      }

      // Check for existing session
      supabase.auth.getSession().then(({ data }) => {
        if (data.session) {
          console.log("User already logged in:", data.session.user);
          currentUser = data.session.user;
          startCourseSession();
        }
      });

      // Add missing auth modal functions
      function openAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "flex";
        }
      }

      function closeAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Add auth tab switching functionality
      document.getElementById("tabSignIn")?.addEventListener("click", () => {
        document.getElementById("tabSignIn").classList.add("active");
        document.getElementById("tabSignUp").classList.remove("active");
        document.getElementById("signInForm").style.display = "block";
        document.getElementById("signUpForm").style.display = "none";
      });

      document.getElementById("tabSignUp")?.addEventListener("click", () => {
        document.getElementById("tabSignUp").classList.add("active");
        document.getElementById("tabSignIn").classList.remove("active");
        document.getElementById("signUpForm").style.display = "block";
        document.getElementById("signInForm").style.display = "none";
      });

      document
        .getElementById("closeAuthModal")
        ?.addEventListener("click", closeAuthModal);

      // Improved error handling for auth session
      supabase.auth.onAuthStateChange((event, session) => {
        if (event === "SIGNED_IN") {
          currentUser = session.user;
          closeAuthModal();
          startCourseSession();
        } else if (event === "SIGNED_OUT") {
          currentUser = null;
          openAuthModal();
        }
      });

      // Add form submission handlers
      document
        .getElementById("emailSignInForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signInEmail").value;
          const password = document.getElementById("signInPassword").value;

          try {
            const { data, error } = await supabase.auth.signInWithPassword({
              email,
              password,
            });

            if (error) throw error;

            closeAuthModal();
          } catch (error) {
            showToast(error.message, "error");
          }
        });

      document
        .getElementById("emailSignUpForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signUpEmail").value;
          const password = document.getElementById("signUpPassword").value;
          const name = document.getElementById("signUpName").value;

          try {
            const { data, error } = await supabase.auth.signUp({
              email,
              password,
              options: {
                data: {
                  full_name: name,
                },
              },
            });

            if (error) throw error;

            showToast(
              "Account created successfully! Please check your email.",
              "success"
            );
          } catch (error) {
            showToast(error.message, "error");
          }
        });
    </script>
  </body>
</html>

