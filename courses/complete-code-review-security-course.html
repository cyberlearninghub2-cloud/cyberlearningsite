


<!DOCTYPE html>
<html lang="en">
 <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- ========== Start: SEO & Schema Enhancement ========== -->
    <title>Complete Code Review Security Course | CipherHall</title>
    <meta name="description" content="A 31-lesson masterclass on security code review. Learn SAST, manual analysis, DevSecOps integration, and how to find critical vulnerabilities in code.">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png" />
    <link rel="shortcut icon" href="/favicon.png" type="image/x-icon" />
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png" />
    <link rel="canonical" href="https://www.cipherhall.com/courses/complete-code-review-security-course.html" />
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Course",
      "name": "Complete Code Review Security Course",
      "description": "A comprehensive course for developers and security professionals on the art and science of finding security vulnerabilities through manual and automated code review.",
      "provider": {
        "@type": "Organization",
        "name": "CipherHall",
        "sameAs": "https://www.cipherhall.com"
      },
      "hasCourseInstance": {
        "@type": "CourseInstance",
        "courseMode": "Online",
        "instructor": {
          "@type": "Person",
          "name": "Dr. Evelyn Reed"
        }
      }
    }
    </script>
    <!-- ========== End: SEO & Schema Enhancement ========== -->

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Exo+2:wght@700;800;900&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css"
    />
    <link rel="stylesheet" href="assets/css/coursepages.css">
</head>
  <body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
      <div class="loader-icon">
        <i class="fas fa-graduation-cap"></i>
      </div>
      <div class="loader-text">Loading Course Content...</div>
    </div>

    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- Music Player (fixed at top right) -->
    <div class="header-controls">
      <div class="music-dropdown" id="music-dropdown">
        <button class="btn btn-secondary">
          <span id="music-button-text">STUDY MUSIC</span>
          <i id="music-icon" class="fa-solid fa-music"></i>
        </button>
        <div class="music-dropdown-content" id="music-dropdown-content">
          <a
            href="#"
            data-src="https://www.learningcontainer.com/wp-content/uploads/2020/02/Kalimba.mp3"
            >1. Coffee Shop Vibes</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3"
            >2. City Lights Lofi</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-15.mp3"
            >3. Mellow Thoughts</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-13.mp3"
            >4. Rainy Mood</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3"
            >5. Time Alone</a
          >
          <a href="#" id="stop-music-link"
            ><i class="fa-solid fa-stop-circle"></i> Stop Music</a
          >
        </div>
      </div>

      <button class="btn btn-secondary" id="resetProgressBtn">
        <i class="fas fa-redo"></i>
        Reset Progress
      </button>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal" style="display: none">
      <div class="modal-overlay"></div>
      <div class="modal-content">
        <span class="close" id="closeAuthModal">&times;</span>
        <div class="auth-tabs">
          <button id="tabSignIn" class="auth-tab active">Sign In</button>
          <button id="tabSignUp" class="auth-tab">Sign Up</button>
        </div>
        <div
          id="authLoader"
          style="display: none; text-align: center; padding: 2rem"
        >
          <i
            class="fas fa-spinner fa-spin fa-2x"
            style="color: var(--color-green)"
          ></i>
          <p style="margin-top: 0.5rem">Authenticating...</p>
        </div>
        <div id="signInForm" class="auth-form">
          <h2>Sign In to CipherHall</h2>
          <button id="googleSignIn" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignInForm">
            <input
              type="email"
              id="signInEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signInPassword"
              placeholder="Password"
              required
            />
            <button type="submit" class="btn btn-primary">Sign In</button>
          </form>
        </div>
        <div id="signUpForm" class="auth-form" style="display: none">
          <h2>Join CipherHall</h2>
          <button id="googleSignUp" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignUpForm">
            <input
              type="text"
              id="signUpName"
              placeholder="Full Name"
              required
            />
            <input
              type="email"
              id="signUpEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signUpPassword"
              placeholder="Password (min. 8 characters)"
              required
            />
            <button type="submit" class="btn btn-secondary">
              Create Account
            </button>
          </form>
        </div>
        <div id="authMessage"></div>
      </div>
    </div>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="course-info">
          <h1 class="course-title" id="courseTitle">Loading...</h1>
          <div class="course-progress">
            <div class="progress-header">
              <span class="progress-label">Course Progress</span>
              <span class="progress-percentage" id="courseProgressPercent"
                >0%</span
              >
            </div>
            <div class="progress-bar">
              <div
                class="progress-fill"
                id="courseProgressFill"
                style="width: 0%"
              ></div>
            </div>
            <div class="progress-stats">
              <span id="completedLessons">0</span>
              <span id="totalLessons">0</span>
            </div>
          </div>
          <a href="/dashboard.html" class="back-to-dashboard">
            <i class="fas fa-arrow-left"></i>
            Back to Dashboard
          </a>
        </div>
      </div>

      <nav class="lesson-nav" id="lessonNav">
        <!-- Lessons will be loaded dynamically -->
      </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <header class="content-header">
        <div class="lesson-header">
          <div class="lesson-header-left">
            <span class="lesson-number" id="currentLessonNumber">1</span>
            <h1 class="lesson-header-title" id="currentLessonTitle">
              Loading...
            </h1>
          </div>
          <div class="lesson-actions">
            <button class="mbtn btn-primary" id="menuToggle">
              <i class="fas fa-bars"></i>
            </button>
          </div>
        </div>
      </header>

      <div class="content-body" id="contentBody">
        <div class="lesson-content" id="lessonContent">
          <!-- Lesson content will be loaded dynamically -->
        </div>
      </div>

      <footer class="lesson-navigation">
        <div class="nav-info" id="navInfo">Lesson 1 of 10</div>
        <div class="nav-controls">
          <button class="btn btn-secondary" id="prevLessonBtn" disabled>
            <i class="fas fa-chevron-left"></i>
            Previous
          </button>
          <button class="btn btn-primary" id="nextLessonBtn" disabled>
            Next
            <i class="fas fa-chevron-right"></i>
          </button>
        </div>
      </footer>
    </main>

    <!-- Achievement Notification -->
    <div id="achievementNotification" class="achievement-notification">
      <div class="notification-header">
        <div class="notification-icon" id="notificationIcon">
          <i class="fas fa-trophy"></i>
        </div>
        <div class="notification-content">
          <h3 id="notificationTitle">Achievement Unlocked!</h3>
          <p id="notificationDescription">Description here...</p>
        </div>
      </div>
      <div class="notification-reward" id="notificationReward">
        <i class="fas fa-coins"></i>
        <span id="notificationPoints">+100 Points</span>
      </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast">
      <span id="toastMessage"></span>
    </div>

    <script>
      // =====================================================
      // SYNCHRONIZED COURSE SYSTEM WITH DASHBOARD INTEGRATION
      // =====================================================

      // Supabase Configuration - Replace with your config
      const supabaseUrl = "https://lzcmzulemfubjaksoqor.supabase.co";
      const supabaseKey =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx6Y216dWxlbWZ1Ympha3NvcW9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzMzM5MDgsImV4cCI6MjA3MDkwOTkwOH0.crhPH4YWtRsr1BJTpAQcmPbWSpwIWRbzoI4sRb2_fPI";
      const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

      // =====================================================
      // COURSE DATA STRUCTURE - REPLACE WITH YOUR COURSE JSON
      // =====================================================
      const COURSE_DATA = {
        id: "code-review-security",
        title: "Complete Code Review Security Course",
        description:
          "A comprehensive course for developers and security professionals on the art and science of finding security vulnerabilities through manual and automated code review.",
        category: "application-security",
        difficulty: "Intermediate to Advanced",
        duration: "80 hours",
        instructor: "Dr. Evelyn Reed",
        lessons: [
          {
            id: "lesson-1",
            title: "Introduction to Security Code Review",
            duration: "90 min",
            objectives: [
              "Understand the purpose and critical importance of security code reviews.",
              "Differentiate between a functional code review and a security code review.",
              "Analyze the cost-benefit of performing security reviews throughout the SDLC.",
              "Identify the roles, responsibilities, and success metrics for a review program.",
            ],
            content: {
              overview:
                "This foundational lesson introduces the 'why' and 'what' of security code review. We will explore its role as one of the most effective methods for finding and eliminating vulnerabilities, how it fits into a modern DevSecOps lifecycle, and how to define success for a security review program.",
              sections: [
                {
                  title: "Purpose and Importance of Security Code Reviews",
                  content:
                    "<p>A security code review is a systematic, manual and/or automated examination of an application's source code to identify security vulnerabilities. Its primary purpose is to find flaws before they can be exploited in a production environment.</p><h3>Key Benefits:</h3><ul><li><strong>Finds Deep Flaws:</strong> It can uncover complex business logic flaws and architectural issues that automated scanners often miss.</li><li><strong>Early Detection:</strong> It's a 'shift-left' activity that finds bugs when they are cheapest to fix.</li><li><strong>Educational Tool:</strong> It is one of the best ways to train developers on secure coding practices.</li><li><strong>Compliance:</strong> It is a mandatory requirement for many compliance standards, such as PCI DSS.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1555099962-4199c345e546?w=800&h=400&fit=crop",
                },
                {
                  title: "Security vs. Functional Code Review",
                  content:
                    "<p>While both are quality assurance processes, their focus is different.</p><ul><li>A <strong>functional review</strong> asks: 'Does this code work as intended? Is it readable and maintainable?'</li><li>A <strong>security review</strong> asks: 'How can this code be abused? Can an attacker make it do something it was *not* intended to do?'</li></ul><p>A good security reviewer must learn to think like an attacker, looking for malicious inputs and unexpected edge cases.</p>",
                  image:
                    "https://images.unsplash.com/photo-1517694712202-14dd9538aa97?w=800&h=400&fit=crop",
                },
                {
                  title: "Roles and Responsibilities",
                  content:
                    "<p>A successful review process involves several roles.</p><ul><li><strong>Author:</strong> The developer who wrote the code.</li><li><strong>Reviewer:</strong> The peer (another developer or a security engineer) who examines the code.</li><li><strong>Moderator (optional):</strong> A facilitator for the review meeting.</li></ul><p>The culture must be collaborative and constructive, not adversarial. The goal is to improve the code, not to blame the author.</p>",
                  image:
                    "https://images.unsplash.com/photo-1552664730-d307ca884978?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab 1: Security Code Review Maturity Assessment",
                  language: "markdown",
                  code: "# Security Code Review Maturity Model\n\n**Level 1 (Initial):**\n- No formal process. Reviews are ad-hoc and informal.\n- Focus is purely on functionality.\n\n**Level 2 (Managed):**\n- A formal code review process exists (e.g., mandatory pull requests).\n- A basic security checklist is sometimes used.\n- Automated SAST tool is run, but results are often ignored.\n\n**Level 3 (Defined):**\n- A documented security code review process is followed by all teams.\n- Security Champions are trained to perform security-focused reviews.\n- SAST findings are triaged and tracked.\n\n**Level 4 (Measured):**\n- Metrics (e.g., Defect Density, Review Coverage) are used to measure the effectiveness of the program.\n- The process is continuously improved based on data.",
                },
                {
                  title:
                    "Code Example 1: Code Review Security Metrics Dashboard",
                  language: "json",
                  code: '{\n  "dashboardName": "Quarterly Code Review Security Metrics",\n  "metrics": [\n    {\n      "name": "Security Defect Density (per 1k lines)",\n      "value": 1.5,\n      "trend": "down",\n      "target": "< 1.0"\n    },\n    {\n      "name": "Pull Request Security Review Coverage",\n      "value": "92%",\n      "trend": "up",\n      "target": "100%"\n    },\n    {\n      "name": "Mean Time to Remediate (from Review Finding)",\n      "value": "2.1 days",\n      "trend": "stable",\n      "target": "< 3 days"\n    }\n  ]\n}',
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the primary difference in mindset between a functional and a security code review?",
                  options: [
                    "There is no difference.",
                    "A functional review checks if the code works, while a security review considers how the code could be abused.",
                    "A security review is only about code style and formatting.",
                    "A functional review is performed by security engineers.",
                  ],
                  correct: 1,
                  explanation:
                    "The key shift for a security code review is thinking adversarially. You are looking for ways to break the code's intended logic and cause it to behave in an insecure way.",
                },
                {
                  id: 2,
                  question:
                    "What is a major benefit of performing security code reviews?",
                  options: [
                    "It significantly slows down the development process.",
                    "It is a highly effective way to find deep business logic and design flaws that automated tools often miss.",
                    "It is completely free and requires no time.",
                    "It guarantees the code will be 100% bug-free.",
                  ],
                  correct: 1,
                  explanation:
                    "While automated tools are essential, they are poor at understanding context. A skilled human reviewer can spot complex authorization flaws or insecure business logic that a scanner would never find.",
                },
                {
                  id: 3,
                  question:
                    "A hybrid approach to security code review involves:",
                  options: [
                    "Only using manual review.",
                    "Only using automated tools.",
                    "Combining the results of automated tools (like SAST) with a manual, human-driven review.",
                    "Not reviewing code at all.",
                  ],
                  correct: 2,
                  explanation:
                    "The hybrid approach is the most effective and efficient. The automated tool finds the common, low-hanging fruit, allowing the human reviewer to focus their valuable time on finding more complex and subtle vulnerabilities.",
                },
                {
                  id: 4,
                  question:
                    "A successful security code review culture should be:",
                  options: [
                    "Adversarial and focused on blaming the author.",
                    "Optional and rarely enforced.",
                    "Performed only by the most senior security architects.",
                    "Collaborative, constructive, and focused on improving the code's security.",
                  ],
                  correct: 3,
                  explanation:
                    "A positive culture is essential. The goal of a code review is to improve the product, not to criticize the person who wrote the code. A collaborative approach fosters learning and a shared sense of ownership for security.",
                },
              ],
            },
          },
          {
            id: "lesson-2",
            title: "Security Code Review Fundamentals",
            duration: "120 min",
            objectives: [
              "Understand common vulnerability classifications like the OWASP Top 10 and CWE.",
              "Learn to differentiate between a vulnerability, a weakness, and an anti-pattern.",
              "Develop a risk-based mindset for assessing the severity of a finding.",
              "Grasp the importance of clear and actionable documentation for findings.",
            ],
            content: {
              overview:
                "To find vulnerabilities, you first need to know what you're looking for. This lesson provides the foundational knowledge for a security code reviewer, covering the standard classifications for software weaknesses and the principles of risk assessment. We'll explore the OWASP Top 10 and CWE to build a common vocabulary for discussing security flaws.",
              sections: [
                {
                  title: "OWASP Top 10 in Code Review Context",
                  content:
                    "<p>The OWASP Top 10 is a list of the most critical web application security risks. As a code reviewer, it provides an excellent high-level checklist of what to look for.</p><p>For example, when you see a code change that involves database queries, the OWASP risk 'A03: Injection' should immediately come to mind, prompting you to specifically check if parameterized queries are being used.</p>",
                  image:
                    "https://images.unsplash.com/photo-1605995538181-22920bee518f?w=800&h=400&fit=crop",
                },
                {
                  title: "CWE (Common Weakness Enumeration)",
                  content:
                    "<p>While the OWASP Top 10 is a list of *risks*, the Common Weakness Enumeration (CWE) is a detailed, community-developed dictionary of software *weakness types*. It provides a much more granular level of detail.</p><ul><li>**OWASP Top 10:** Injection</li><li>**CWEs:**<ul><li>CWE-89: Improper Neutralization of Special Elements used in a SQL Command ('SQL Injection')</li><li>CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</li><li>CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')</li></ul></li></ul><p>As a reviewer, you should use CWEs in your findings to provide a precise, standardized description of the weakness.</p>",
                  image:
                    "https://images.unsplash.com/photo-1517694712202-14dd9538aa97?w=800&h=400&fit=crop",
                },
                {
                  title: "Risk Assessment During Code Review",
                  content:
                    "<p>Not all bugs are created equal. When you find a weakness, you must assess its risk to prioritize it. Risk is a function of likelihood and impact.</p><ul><li><strong>Likelihood:</strong> How easy is it for an attacker to discover and exploit this weakness? A flaw in an unauthenticated, internet-facing API is more likely to be exploited than a flaw in an internal admin tool.</li><li><strong>Impact:</strong> What is the worst-case business impact if this weakness is exploited? Does it lead to a minor data leak or a full system compromise?</li></ul><p>A finding with high likelihood and high impact is a critical risk that must be fixed immediately.</p>",
                  image:
                    "https://images.unsplash.com/photo-1600880292210-859bb1fed5b1?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab 2: Vulnerability Classification Workshop",
                  language: "markdown",
                  code: '# Code Snippet Analysis\n\n**Code:** `ResultSet rs = statement.executeQuery("SELECT * FROM users WHERE id = " + userId);`\n\n- **OWASP Top 10 Category:** A03: Injection\n- **CWE:** CWE-89: SQL Injection\n- **Likelihood:** High (if `userId` comes from a user)\n- **Impact:** High (could lead to data exfiltration)\n- **Risk:** Critical\n- **Recommendation:** Rewrite the code to use a parameterized query (prepared statement).',
                },
                {
                  title:
                    "Code Example 2: Security Finding Classification Engine",
                  language: "python",
                  code: "def assess_finding_risk(finding):\n    likelihood_score = calculate_likelihood(finding)\n    impact_score = calculate_impact(finding)\n    \n    # Risk is often a product of likelihood and impact\n    risk_score = likelihood_score * impact_score\n    \n    if risk_score >= 15:\n        return 'Critical'\n    elif risk_score >= 10:\n        return 'High'\n    elif risk_score >= 5:\n        return 'Medium'\n    else:\n        return 'Low'",
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "A detailed, standardized dictionary of software weakness types, such as 'CWE-89: SQL Injection', is known as the:",
                  options: [
                    "OWASP Top 10",
                    "Common Weakness Enumeration (CWE)",
                    "SANS Top 25",
                    "PCI DSS",
                  ],
                  correct: 1,
                  explanation:
                    "CWE provides a common language for describing software security weaknesses in a very specific and granular way. It is the industry standard for classifying the underlying bugs.",
                },
                {
                  id: 2,
                  question: "The OWASP Top 10 is a list of the most critical:",
                  options: [
                    "Software development tools",
                    "Programming languages",
                    "Web application security risks",
                    "Compliance regulations",
                  ],
                  correct: 2,
                  explanation:
                    "The OWASP Top 10 is an awareness document that focuses on broad categories of risk, representing the most common and impactful issues seen in web applications.",
                },
                {
                  id: 3,
                  question: "Risk is typically calculated as a function of:",
                  options: [
                    "Likelihood and Impact",
                    "Cost and Time",
                    "Features and Bugs",
                    "Developers and Managers",
                  ],
                  correct: 0,
                  explanation:
                    "This is the fundamental risk equation. Likelihood is the probability of a vulnerability being exploited, and Impact is the damage that would be caused. A high-risk issue is one that is both likely and damaging.",
                },
                {
                  id: 4,
                  question:
                    "A common practice or solution that is ineffective and often counterproductive is known as:",
                  options: [
                    "A security pattern",
                    "A security anti-pattern",
                    "A vulnerability",
                    "A risk",
                  ],
                  correct: 1,
                  explanation:
                    "An anti-pattern is a common but bad practice. For example, 'Security Through Obscurity' is an anti-pattern because it provides a false sense of security. Recognizing these is a key skill for a reviewer.",
                },
              ],
            },
          },
          {
            id: "lesson-3",
            title: "Manual Code Review Techniques",
            duration: "120 min",
            objectives: [
              "Learn and apply systematic manual review methodologies.",
              "Understand how to perform control flow and data flow analysis.",
              "Grasp the principles of taint analysis for tracking untrusted data.",
              "Develop and use a security code review checklist effectively.",
            ],
            content: {
              overview:
                "Manual code review is a skill that blends systematic analysis with an adversarial mindset. While automated tools find the obvious, a skilled human reviewer finds the subtle and complex flaws. This lesson dives into the practical techniques that reviewers use to dissect code, trace data, and uncover hidden vulnerabilities.",
              sections: [
                {
                  title: "Code Reading and Analysis Techniques",
                  content:
                    "<p>You don't need to read every single line of code. The key is to focus on the highest-risk areas.</p><h3>Where to Start:</h3><ol><li><strong>Identify the Attack Surface:</strong> Find the parts of the code that handle input from an untrusted source (e.g., API endpoints, file upload handlers, network listeners). This is where most vulnerabilities occur.</li><li><strong>Follow the Data:</strong> Pick a single input and trace its path through the code. This is called **Data Flow Analysis**. Where is it used? Is it validated? Is it used to build a query? Is it written to a log? Is it returned to the user?</li><li><strong>Understand the Logic:</strong> Analyze the application's logic, especially for anything related to authentication, authorization, and session management. This is called **Control Flow Analysis**.</li></ol>",
                  image:
                    "https://images.unsplash.com/photo-1555099962-4199c345e546?w=800&h=400&fit-crop",
                },
                {
                  title: "Taint Analysis Principles",
                  content:
                    "<p>Taint analysis is a formal way to perform data flow analysis. It is a core technique for both manual reviewers and automated SAST tools.</p><h3>The Process:</h3><ol><li><strong>Sources:</strong> Identify all the 'sources' where untrusted, or 'tainted', data enters the application (e.g., an HTTP request parameter).</li><li><strong>Sinks:</strong> Identify all the security-sensitive functions, or 'sinks', where this data could cause harm (e.g., a function that executes a SQL query, a function that renders HTML).</li><li><strong>Taint Propagation:</strong> Trace the flow of the tainted data through the code.</li><li><strong>Sanitizers:</strong> Look for any 'sanitizers' or 'validators' that clean the tainted data along its path.</li><li><strong>Vulnerability:</strong> If you can find a path where tainted data from a source can reach a sink without being properly sanitized, you have found a vulnerability.</li></ol>",
                  image:
                    "https://images.unsplash.com/photo-1517694712202-14dd9538aa97?w=800&h=400&fit-crop",
                },
                {
                  title: "Review Checklist Development and Usage",
                  content:
                    "<p>A checklist helps to structure a review and ensure consistency. It should be a living document that is updated with lessons learned from past incidents and reviews. The checklist should be organized around the most common vulnerability types.</p><h3>Example Checklist Section (for Access Control):</h3><ul><li>[ ] Does every endpoint have an authorization check?</li><li>[ ] For endpoints that access a specific data object, is there a check to verify the user owns that object (IDOR/BOLA prevention)?</li><li>[ ] Are authorization decisions made on the server-side, not the client-side?</li><li>[ ] Does the code enforce the principle of least privilege?</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1454165804606-c3d57bc86b40?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab 3: Manual Security Review Practice Platform",
                  language: "python",
                  code: "# A function to review using Taint Analysis\n\nfrom flask import request, render_template_string\nimport db_connector\n\ndef search_products(product_name):\n    # 1. Source: 'product_name' comes directly from an HTTP request.\n    #    It is considered 'TAINTED'.\n    \n    # 2. Sink: The variable is used directly in a SQL query.\n    #    This is a security-sensitive sink.\n    #    There is NO sanitizer in between.\n    #    VULNERABILITY: SQL Injection.\n    query = f\"SELECT * FROM products WHERE name = '{product_name}'\"\n    results = db_connector.execute(query)\n    \n    # 3. Sink: The original tainted data is also rendered in the HTML.\n    #    This is another security-sensitive sink.\n    #    There is NO sanitizer (output encoder).\n    #    VULNERABILITY: Cross-Site Scripting.\n    return render_template_string(f\"<h1>Results for {product_name}</h1> ...\")",
                },
                {
                  title:
                    "Code Example 3: Interactive Code Review Training System",
                  language: "java",
                  code: "public void processFile(String filename) {\n    // Taint Analysis:\n    // 1. Source: 'filename' is a tainted input from the user.\n    \n    // 2. Sanitizer? Let's check the validation logic.\n    if (!isValidFilename(filename)) { // This function needs to be reviewed!\n        throw new InvalidInputException();\n    }\n    \n    // 3. Sink: The filename is used to construct a file path.\n    // If the validation is weak, this could be a Path Traversal vulnerability.\n    File f = new File(\"/var/data/\" + filename);\n    f.read();\n}",
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "The process of following a piece of user input from where it enters the application to where it is used is known as:",
                  options: [
                    "Control Flow Analysis",
                    "Data Flow Analysis",
                    "Unit Testing",
                    "Code Commenting",
                  ],
                  correct: 1,
                  explanation:
                    "Data flow analysis is a fundamental manual review technique. By tracing untrusted data, a reviewer can spot many of the most common vulnerabilities, like injection flaws.",
                },
                {
                  id: 2,
                  question:
                    "In taint analysis, a security-sensitive function where untrusted data could cause harm (like a function that executes a SQL query) is known as a:",
                  options: ["Source", "Sink", "Sanitizer", "Taint"],
                  correct: 1,
                  explanation:
                    "A 'sink' is the destination. A vulnerability exists when tainted data from a 'source' can reach a 'sink' without being cleaned by a 'sanitizer'.",
                },
                {
                  id: 3,
                  question:
                    "When starting a manual code review, what is the best strategy?",
                  options: [
                    "Read every single line of code in alphabetical order.",
                    "Start by identifying the application's attack surface—the parts of the code that handle untrusted input.",
                    "Only review the comments in the code.",
                    "Assume the code is completely secure and look for functional bugs.",
                  ],
                  correct: 1,
                  explanation:
                    "An effective review is risk-based. By focusing on the attack surface first, you are spending your time on the parts of the application where vulnerabilities are most likely to be found.",
                },
                {
                  id: 4,
                  question:
                    "A function that validates or encodes untrusted data to make it safe is known as a:",
                  options: ["Source", "Sink", "Sanitizer", "Taint"],
                  correct: 2,
                  explanation:
                    "A sanitizer is the defense. The goal of a reviewer using taint analysis is to find data flows where a required sanitizer is missing.",
                },
              ],
            },
          },
          {
            id: "lesson-4",
            title: "Static Analysis Security Testing (SAST)",
            duration: "120 min",
            objectives: [
              "Understand the fundamentals of how SAST tools work.",
              "Learn to select and configure a SAST tool for a project.",
              "Develop effective strategies for triaging results and reducing false positives.",
              "Integrate SAST into the CI/CD pipeline and the developer workflow.",
            ],
            content: {
              overview:
                "Static Analysis Security Testing (SAST) tools are the automated workhorses of a secure development program. They act as a security-focused linter, scanning an application's source code to find common vulnerability patterns. This lesson covers how these tools work and how to integrate them effectively into your review process.",
              sections: [
                {
                  title: "SAST Fundamentals and Capabilities",
                  content:
                    "<p>SAST is a 'white-box' testing method. It analyzes the code without executing it. Most modern SAST tools work by performing sophisticated taint analysis, similar to the manual process we just learned, but at a massive scale.</p><h3>How SAST Works:</h3><ol><li><strong>Parsing:</strong> The tool first parses the source code to build an abstract representation of the application, including its data flows and control flows.</li><li><strong>Analysis:</strong> It then applies a set of rules to this model. The rules look for a path where tainted data from a known 'source' can reach a known 'sink' without passing through a known 'sanitizer'.</li><li><strong>Reporting:</strong> The tool reports all the vulnerable paths it finds.</li></ol>",
                  image:
                    "https://images.unsplash.com/photo-1517694712202-14dd9538aa97?w=800&h=400&fit=crop",
                },
                {
                  title: "Rule Configuration and Customization",
                  content:
                    "<p>Out of the box, a SAST tool can be very noisy. Effective use requires tuning the rules to fit your application's context.</p><h3>Tuning Strategies:</h3><ul><li><strong>Disable Irrelevant Rules:</strong> A ruleset might have checks for a framework you don't use. These can be disabled.</li><li><strong>Adjust Severity:</strong> You might decide that a certain type of finding is less critical in your specific context and lower its default severity.</li><li><strong>Custom Rules:</strong> Some advanced tools allow you to write your own custom rules. For example, you could write a rule that flags any use of an old, deprecated internal library.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit-crop",
                },
                {
                  title: "False Positive Reduction Strategies",
                  content:
                    "<p>A high false positive rate is the number one reason that development teams stop trusting and start ignoring SAST results. Managing this is a critical task for the reviewer or security champion.</p><h3>The Triage Process:</h3><p>When a new finding is reported, a human must review it.</p><ol><li>Is this a true positive?</li><li>If yes, is it exploitable in our context?</li><li>If yes, create a ticket and prioritize a fix.</li><li>If no, formally mark it as a 'False Positive' or 'Won't Fix' in the tool, providing a justification.</li></ol><p>This continuous feedback loop trains the system and ensures that the results shown to developers are high-quality and actionable.</p>",
                  image:
                    "https://images.unsplash.com/photo-1555099962-4199c345e546?w=800&h=400&fit-crop",
                },
                {
                  title: "Integration with Development Environments",
                  content:
                    "<p>The goal is to provide developers with fast feedback. This means integrating SAST at multiple points in the workflow.</p><ul><li><strong>In the IDE:</strong> Lightweight plugins (like SonarLint) provide real-time feedback as code is written.</li><li><strong>In the Pull Request:</strong> The CI/CD pipeline should run a scan and post the findings as a comment on the PR. This allows the author and the reviewer to see the findings in context before the code is ever merged.</li><li><strong>In the Main Branch:</strong> A full, deep scan should be run on the main branch to track the overall health of the application and to act as a final security gate.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1542382257-80deda0e5d99?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab 4: SAST Tool Integration Workshop",
                  language: "markdown",
                  code: '# Triage of a SAST Finding\n\n- **Tool:** SonarQube\n- **Finding:** Critical - SQL Injection\n- **File:** `legacy_report.js`, line 25\n- **Code:** `db.query("SELECT * FROM reports WHERE id = " + req.params.id);`\n\n**Triage Analysis:**\n- **Is it a True Positive?** Yes. The code is clearly concatenating a raw HTTP request parameter into a SQL query.\n- **Is it Exploitable?** Yes. The endpoint is exposed and unauthenticated.\n- **Business Impact:** High. The `reports` table contains sensitive customer data.\n\n**Decision:**\n- Mark as **True Positive**.\n- Create a **Critical** severity ticket in Jira.\n- Assign to the responsible team with a 15-day SLA.',
                },
                {
                  title:
                    "Code Example 4: Multi-SAST Tool Orchestration Platform",
                  language: "json",
                  code: '{\n  "findingId": "SONAR-123",\n  "cwe": "CWE-89",\n  "severity": "CRITICAL",\n  "file": "UserRepository.java",\n  "line": 52,\n  "taintFlow": [\n    {\n      "type": "Source",\n      "file": "UserController.java",\n      "line": 30,\n      "description": "Data read from HTTP request parameter \'username\'."\n    },\n    {\n      "type": "Sink",\n      "file": "UserRepository.java",\n      "line": 52,\n      "description": "Data is used to construct a SQL query without parameterization."\n    }\n  ],\n  "status": "OPEN"\n}',
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "SAST is known as a 'white-box' testing method because:",
                  options: [
                    "It tests the running application from the outside.",
                    "It has full visibility into the application's source code.",
                    "It can only be used on applications with a white background.",
                    "It is always 100% accurate.",
                  ],
                  correct: 1,
                  explanation:
                    "'White-box' testing implies that the tester has full knowledge of the internal workings of the system, which is exactly what SAST does by analyzing the source code directly.",
                },
                {
                  id: 2,
                  question:
                    "What is the most common reason that developers lose trust in a SAST tool?",
                  options: [
                    "It finds too many real vulnerabilities.",
                    "It runs too quickly.",
                    "A high rate of false positives that waste their time.",
                    "The user interface is too simple.",
                  ],
                  correct: 2,
                  explanation:
                    "If a tool constantly reports issues that are not real, developers will start to ignore all of its output. A robust triage process to manage false positives is essential for the success of a SAST program.",
                },
                {
                  id: 3,
                  question:
                    "The core analysis technique used by most modern SAST tools, which involves tracing data from a 'source' to a 'sink', is known as:",
                  options: [
                    "Taint Analysis",
                    "Dynamic Analysis",
                    "Penetration Testing",
                    "Unit Testing",
                  ],
                  correct: 0,
                  explanation:
                    "Taint analysis is the powerful data flow analysis technique that allows SAST tools to find injection-style vulnerabilities by tracking the flow of untrusted data through the application.",
                },
                {
                  id: 4,
                  question:
                    "The best place to integrate a SAST scan to provide the fastest feedback to a developer and the reviewer on a proposed change is:",
                  options: [
                    "Once a year.",
                    "In the production monitoring system.",
                    "As an automated check on the pull/merge request.",
                    "After the code has been deployed to production for a week.",
                  ],
                  correct: 2,
                  explanation:
                    "Integrating the scan directly into the pull request workflow is a core DevSecOps pattern. It presents the findings in context, before the code is merged, making it easy for the developer and reviewer to address the issues.",
                },
              ],
            },
          },
          {
            id: "lesson-5",
            title: "Input Validation Security Review",
            duration: "120 min",
            objectives: [
              "Learn to identify common input validation vulnerabilities in a code review.",
              "Review code for proper whitelisting and data type validation.",
              "Analyze code for vulnerabilities related to output encoding.",
              "Assess the security of file upload and API input handling.",
            ],
            content: {
              overview:
                "As we've learned, improper input validation is the root cause of the majority of critical software vulnerabilities. This lesson provides a code reviewer's guide to hunting for these flaws. We will focus on the specific code patterns and anti-patterns to look for when reviewing any piece of code that handles external data.",
              sections: [
                {
                  title: "SQL Injection Prevention Analysis",
                  content:
                    "<h3>The #1 Thing to Look For:</h3><p>When reviewing any code that interacts with a database, your primary mission is to hunt for string concatenation used to build a query.</p><p>Search the code for query execution functions (e.g., `executeQuery`, `db.query`) and trace the query string back. If you see it being built with `+` signs and variables that come from an external source, you have found a SQL injection vulnerability. The only acceptable pattern is the use of parameterized queries (prepared statements).</p>",
                  image:
                    "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit-crop",
                },
                {
                  title: "Cross-Site Scripting (XSS) Prevention Review",
                  content:
                    "<p>When reviewing any code that renders data in a UI (a web page, a PDF, etc.), your mission is to hunt for missing output encoding.</p><h3>The Process:</h3><p>Identify the 'sink'—the point where data is written to the output stream (e.g., inside a JSP, an HTML template, or a JavaScript variable). Trace the data backward to its 'source'. If the data originated from an untrusted source (like the database or a request parameter) and it is not passed through a contextual output encoding function, you have found an XSS vulnerability.</p>",
                  image:
                    "https://images.unsplash.com/photo-1555099962-4199c345e546?w=800&h=400&fit-crop",
                },
                {
                  title: "Command Injection Prevention",
                  content:
                    "<p>This occurs when an application uses untrusted data to build a command-line string that is executed on the operating system.</p><h3>What to Look For:</h3><p>Search the code for functions that execute OS commands (e.g., `os.system`, `subprocess.run(..., shell=True)`, `Runtime.exec`). If the command string is being built by concatenating user input, it is vulnerable. An attacker could inject characters like `;` or `&&` to execute their own commands.</p><p>The fix is to use the version of the execution function that takes an array of arguments, which passes the user input safely as a single argument.</p>",
                  image:
                    "https://images.unsplash.com/photo-1517694712202-14dd9538aa97?w=800&h=400&fit-crop",
                },
                {
                  title: "File Upload Security Review",
                  content:
                    "<p>When reviewing a file upload feature, check for this layered defense:</p><ol><li>Is the file type being validated on the server-side, preferably by checking magic numbers?</li><li>Is there a file size limit being enforced?</li><li>Is the user-supplied filename being discarded and a new, random filename being generated?</li><li>Is the file being stored in a secure, non-web-accessible location?</li><li>Is the file being scanned for malware?</li></ol><p>A 'no' to any of these questions indicates a potential vulnerability.</p>",
                  image:
                    "https://images.unsplash.com/photo-1588665387928-a8d2a13f8373?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab 5: Input Validation Security Assessment",
                  language: "java",
                  code: '// VULNERABLE CODE TO REVIEW (XXE)\n\npublic Document parseXML(String xmlString) throws Exception {\n    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n    \n    // ANTI-PATTERN: Default settings for many XML parsers are insecure.\n    // An attacker could provide an XML with an external entity to read local files.\n    DocumentBuilder builder = factory.newDocumentBuilder();\n    \n    return builder.parse(new InputSource(new StringReader(xmlString)));\n}\n\n// SECURE CODE\n\npublic Document secureParseXML(String xmlString) throws Exception {\n    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n    \n    // FIX: Explicitly disable dangerous features.\n    factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);\n    factory.setFeature("http://xml.org/sax/features/external-general-entities", false);\n    factory.setFeature("http://xml.org/sax/features/external-parameter-entities", false);\n    \n    DocumentBuilder builder = factory.newDocumentBuilder();\n    return builder.parse(new InputSource(new StringReader(xmlString)));\n}',
                },
                {
                  title:
                    "Code Example 5: Comprehensive Input Validation Analyzer",
                  language: "markdown",
                  code: '# Code Review Finding: Command Injection\n\n**File:** `VideoConverter.py`, line 21\n\n**Vulnerable Code:**\n`os.system(f"ffmpeg -i {input_file} -vcodec h264 {output_file}")`\n\n**Analysis:**\n- **Source:** The `input_file` variable comes from a user\'s HTTP request.\n- **Sink:** The variable is directly concatenated into a string that is passed to `os.system`.\n- **Vulnerability:** An attacker could provide a filename like `myvideo.mp4; rm -rf /`. The semicolon would be interpreted by the shell, causing the `rm` command to be executed.\n- **CWE:** CWE-78: OS Command Injection.\n\n**Recommendation:**\nRewrite the code to use the `subprocess.run` function with an array of arguments, which does not use the shell and is not vulnerable to this injection.',
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "When reviewing code that builds a SQL query, what is the single biggest red flag for a SQL Injection vulnerability?",
                  options: [
                    "The use of parameterized queries.",
                    "The use of string concatenation (`+`) to build the query with user input.",
                    "The use of a stored procedure.",
                    "The query is selecting data from a table.",
                  ],
                  correct: 1,
                  explanation:
                    "String concatenation is the root cause of SQLi. If you see a query being built by adding strings together, especially strings that contain user-controlled data, you have almost certainly found a SQL injection vulnerability.",
                },
                {
                  id: 2,
                  question:
                    "When reviewing code that displays user-supplied data on a web page, what is the key thing to look for to prevent XSS?",
                  options: [
                    "To ensure the data is encrypted before being displayed.",
                    "To ensure the data is passed through a contextual output encoding function.",
                    "To ensure the data is validated to be an integer.",
                    "To trust the data if the user is authenticated.",
                  ],
                  correct: 1,
                  explanation:
                    "The core defense against XSS is to look for the absence of output encoding. Any piece of data that originated from an external source and is being rendered in the UI must be encoded for the specific context it's being placed in.",
                },
                {
                  id: 3,
                  question:
                    'A function that executes an OS command using a string built from user input (e.g., `os.system("ping " + ip_address)`) is likely vulnerable to:',
                  options: [
                    "OS Command Injection",
                    "Cross-Site Scripting",
                    "SQL Injection",
                    "A buffer overflow",
                  ],
                  correct: 0,
                  explanation:
                    "This is the classic pattern for OS Command Injection. An attacker can inject shell metacharacters (like `;`, `|`, `&&`) to execute their own commands on the server.",
                },
                {
                  id: 4,
                  question:
                    "What is the best location to store user-uploaded files?",
                  options: [
                    "In the web root, alongside the application's HTML and CSS files.",
                    "In a temporary directory that is cleared on every reboot.",
                    "In the database itself.",
                    "Outside of the web root, in a dedicated, isolated directory or object store like S3.",
                  ],
                  correct: 3,
                  explanation:
                    "Storing files outside the web root is the most critical control for preventing an attacker from executing an uploaded web shell. If the file is not in a web-accessible directory, the web server cannot be tricked into executing it.",
                },
              ],
            },
          },
          {
            id: "lesson-6",
            title: "Authentication and Authorization Review",
            duration: "120 min",
            objectives: [
              "Learn to review code for common authentication vulnerabilities.",
              "Assess the security of password management and MFA implementations.",
              "Become an expert at identifying authorization flaws, especially Broken Object Level Authorization (BOLA/IDOR).",
              "Review token-based authentication (e.g., JWT) for common mistakes.",
            ],
            content: {
              overview:
                "Flaws in authentication and authorization logic are a primary cause of account takeover and data breaches. As a reviewer, you must be able to critically analyze the code that controls who can access the system and what they can do. This lesson focuses on the specific code patterns and anti-patterns to look for when reviewing these critical components.",
              sections: [
                {
                  title: "Authentication Mechanism Analysis",
                  content:
                    "<h3>Things to Check:</h3><ul><li><strong>Password Management:</strong> Look at the code that handles user registration and password changes. Is it using a modern, slow, salted hashing algorithm like Argon2 or bcrypt? Any use of MD5 or SHA-1 for passwords is a critical finding. Is the code generating a unique salt for each user?</li><li><strong>Brute-Force Protection:</strong> Is there a mechanism to lock an account or require a CAPTCHA after a certain number of failed login attempts?</li><li><strong>Password Reset:</strong> Review the password reset logic. Does it use a long, unpredictable, single-use token that is tied to the user's identity and expires after a short time?</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?w=800&h=400&fit-crop",
                },
                {
                  title: "Authorization Logic Vulnerability Analysis",
                  content:
                    "<p>This is where you hunt for Broken Access Control flaws, the #1 risk on the OWASP Top 10.</p><h3>The BOLA/IDOR Pattern:</h3><p>This is the most important thing to look for. For *every single function* that takes an ID as a parameter to access a resource (e.g., a document, an invoice, a user profile), you must ask: **'Is there a check that proves the currently logged-in user is actually the owner of this resource?'**</p><p>If you see code that retrieves an object from the database using a user-supplied ID but does not perform an ownership check, you have found a critical vulnerability.</p><h3>Function Level Authorization:</h3><p>Look for missing authorization checks on endpoints. A common pattern is for developers to remember to put a check on the `GET` endpoint but forget it on the `POST` or `DELETE` endpoints. Review all state-changing functions to ensure they have a role or permission check.</p>",
                  image:
                    "https://images.unsplash.com/photo-1605995538181-22920bee518f?w=800&h=400&fit-crop",
                },
                {
                  title: "Token-Based Authentication Security",
                  content:
                    "<p>When reviewing code that uses JSON Web Tokens (JWTs), look for common mistakes.</p><ul><li><strong>Signature Validation:</strong> The code *must* validate the signature of every incoming JWT. If it doesn't, an attacker can forge any token they want. Look for implementations that allow the `alg` (algorithm) header to be set to `none`.</li><li><strong>Sensitive Data in Payload:</strong> The payload of a JWT is just Base64 encoded, not encrypted. Never store sensitive data in a JWT payload.</li><li><strong>Token Revocation:</strong> JWTs are self-contained and, by default, are valid until they expire. The system should have a mechanism to revoke a token if a user's session is compromised (e.g., by checking against a blacklist).</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1562907450-446aa741b2b3?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab 6: Authentication Security Review Workshop",
                  language: "java",
                  code: "// VULNERABLE CODE (BOLA/IDOR)\n\n@PostMapping(\"/profiles/update\")\n// The code checks that the user is authenticated...\npublic void updateUserProfile(@RequestBody UserProfile profile, Authentication auth) {\n    // ...but it NEVER checks if the authenticated user is the one whose profile is being updated.\n    // An attacker can log in as themselves and then send a request with a different user's ID\n    // in the 'profile' object to overwrite that user's data.\n    userProfileRepository.save(profile);\n}\n\n// SECURE CODE\n\n@PostMapping(\"/profiles/update\")\npublic void secureUpdateUserProfile(@RequestBody UserProfile profile, Authentication auth) {\n    User currentUser = (User) auth.getPrincipal();\n\n    // THE FIX: An explicit ownership check.\n    if (!currentUser.getId().equals(profile.getUserId())) {\n        throw new ForbiddenException();\n    }\n    \n    userProfileRepository.save(profile);\n}",
                },
                {
                  title:
                    "Code Example 6: Authentication Security Analysis Framework",
                  language: "python",
                  code: "# VULNERABLE CODE: Insecure password reset token generation\n\nimport random\n\ndef generate_reset_token(user_id):\n    # ANTI-PATTERN: Using a weak, predictable random number generator.\n    # An attacker could potentially guess another user's token.\n    token = random.randint(100000, 999999)\n    db.save_token(user_id, token)\n    return token\n\n# SECURE CODE\n\nimport secrets\n\ndef secure_generate_reset_token(user_id):\n    # FIX: Use a cryptographically secure random number generator.\n    # The token should also be much longer and more complex.\n    token = secrets.token_hex(32)\n    db.save_token(user_id, token)\n    return token",
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "When reviewing a user registration function, you see it is storing passwords using MD5 without a salt. This is a critical vulnerability because:",
                  options: [
                    "MD5 is too slow for passwords.",
                    "MD5 is a broken hashing algorithm and can be easily cracked, especially without a unique salt for each user.",
                    "The passwords should be encrypted, not hashed.",
                    "This is a secure way to store passwords.",
                  ],
                  correct: 1,
                  explanation:
                    "Using a fast, unsalted, broken hashing algorithm like MD5 for passwords is a cardinal sin. An attacker who steals the database can crack the vast majority of the passwords in a very short time using pre-computed rainbow tables.",
                },
                {
                  id: 2,
                  question:
                    "When reviewing an API endpoint like `GET /api/orders/{orderId}`, what is the most important authorization check to look for in the code?",
                  options: [
                    "A check that the user is authenticated.",
                    "A check that the `orderId` is a valid number.",
                    "A check that the authenticated user is the actual owner of the requested `orderId`.",
                    "A check that the server is online.",
                  ],
                  correct: 2,
                  explanation:
                    "This is the classic Broken Object Level Authorization (BOLA/IDOR) vulnerability. Simply checking for authentication is not enough; the code must perform the second, critical step of verifying ownership.",
                },
                {
                  id: 3,
                  question:
                    "Why should a developer avoid storing sensitive user data in the payload of a JWT?",
                  options: [
                    "The payload is encrypted and cannot be read.",
                    "The payload is just Base64 encoded and can be easily read by anyone who has the token.",
                    "JWTs cannot store complex data.",
                    "JWTs are too small to hold user data.",
                  ],
                  correct: 1,
                  explanation:
                    "A common misconception is that the JWT payload is encrypted. It is not; it is only encoded. Its purpose is to be readable. Therefore, it must never contain sensitive PII or other confidential information.",
                },
                {
                  id: 4,
                  question: "A password reset token should be:",
                  options: [
                    "Short, predictable, and valid forever.",
                    "The same for every user.",
                    "Long, cryptographically random, single-use, and short-lived.",
                    "The user's username.",
                  ],
                  correct: 2,
                  explanation:
                    "A password reset token is a temporary password. It must be treated with the same level of care, meaning it must be highly unpredictable and expire very quickly to be secure.",
                },
              ],
            },
          },
          {
            id: "lesson-7",
            title: "Cryptographic Implementation Review",
            duration: "120 min",
            objectives: [
              "Learn to identify the use of weak or broken cryptographic algorithms in code.",
              "Review code for common key management anti-patterns, like hard-coded keys.",
              "Assess the security of random number generation.",
              "Validate that cryptographic libraries are being used correctly and with secure defaults.",
            ],
            content: {
              overview:
                "Cryptography is a double-edged sword: when used correctly, it provides powerful security guarantees; when used incorrectly, it provides a false sense of security. This lesson provides a code reviewer's guide to spotting the most common and dangerous cryptographic implementation mistakes that developers make.",
              sections: [
                {
                  title: "Common Cryptographic Mistakes",
                  content:
                    "<h3>The #1 Anti-Pattern: Hard-Coded Keys</h3><p>Your first step when reviewing any crypto code is to search for hard-coded secrets. Look for variables named `key`, `secret`, `iv`, or `password` that are assigned a static, constant value. Storing keys in code is a critical vulnerability. The code must be refactored to load keys from a secure secrets management system at runtime.</p><h3>The #2 Anti-Pattern: Broken or Weak Algorithms</h3><p>Scan the code for the use of known broken or weak algorithms. Any use of these is a high-severity finding.</p><ul><li><strong>Encryption:</strong> DES, RC4, Blowfish.</li><li><strong>Hashing (for integrity):</strong> MD5, SHA-1.</li><li><strong>Password Hashing:</strong> MD5, SHA-1, or any other fast hash.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?w=800&h=400&fit=crop",
                },
                {
                  title: "Random Number Generation Security",
                  content:
                    "<p>Many cryptographic operations (generating keys, salts, session IDs, password reset tokens) depend on unpredictable random numbers. The use of a weak random number generator is a subtle but critical vulnerability.</p><h3>What to Look For:</h3><p>Review the code to ensure it is using the operating system's cryptographically secure pseudo-random number generator (CSPRNG). Do NOT use a standard, non-secure pseudo-random number generator (PRNG) like C's `rand()` or Java's `java.util.Random` for any security-sensitive purpose, as their output is predictable.</p><ul><li><strong>Java:</strong> Use `java.security.SecureRandom`.</li><li><strong>Python:</strong> Use the `secrets` module.</li><li><strong>.NET:</strong> Use `System.Security.Cryptography.RandomNumberGenerator`.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1584929788015-230a14589d31?w=800&h=400&fit=crop",
                },
                {
                  title: "Cryptographic Algorithm Usage Review",
                  content:
                    "<p>Even a strong algorithm can be made weak if it's used incorrectly.</p><h3>Common Mistakes:</h3><ul><li><strong>Insecure AES Mode:</strong> As a reviewer, if you see `AES/ECB/...` being used, you have found a vulnerability. ECB (Electronic Codebook) mode is not secure because it doesn't use randomness, and identical blocks of plaintext will produce identical blocks of ciphertext. The code should be changed to use a modern, authenticated encryption mode like `AES/GCM/NoPadding`.</li><li><strong>IV Reuse:</strong> For modes like GCM or CBC, the Initialization Vector (IV) or nonce must be unique and unpredictable for every single encryption operation with the same key. Reusing an IV with the same key can completely break the encryption.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1555949963-ff9808202534?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab 7: Cryptographic Code Review Lab",
                  language: "java",
                  code: '// VULNERABLE CODE: Hard-coded key and insecure algorithm/mode\n\npublic class InsecureEncryption {\n    // ANTI-PATTERN: Key is hard-coded in the source code.\n    private static final byte[] KEY = "thisIsASecretKey".getBytes();\n\n    public byte[] encrypt(String data) throws Exception {\n        // ANTI-PATTERN: ECB mode is insecure and should never be used.\n        Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");\n        cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(KEY, "AES"));\n        return cipher.doFinal(data.getBytes());\n    }\n}',
                },
                {
                  title:
                    "Code Example 7: Cryptographic Security Validation Tool",
                  language: "python",
                  code: "# VULNERABLE CODE: Using a weak PRNG for a security token\nimport random\n\ndef generate_session_id():\n    # ANTI-PATTERN: random is not cryptographically secure.\n    # Its output is predictable.\n    return random.getrandbits(128)\n\n# SECURE CODE\nimport secrets\n\ndef secure_generate_session_id():\n    # FIX: The 'secrets' module is specifically designed for generating\n    # cryptographically strong random numbers.\n    return secrets.token_hex(16) # 16 bytes = 128 bits",
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    'When reviewing code, you find the line `private final String key = "mysecretkey123!";`. This is a critical vulnerability known as:',
                  options: [
                    "A hard-coded key",
                    "A secure key management practice",
                    "An insecure algorithm",
                    "A random number generation flaw",
                  ],
                  correct: 0,
                  explanation:
                    "Storing any secret (key, password, token) as a static value in source code is a major security anti-pattern. The code must be refactored to load the key from a secure vault at runtime.",
                },
                {
                  id: 2,
                  question:
                    "For a security-sensitive purpose like generating a password reset token, which type of random number generator must be used?",
                  options: [
                    "A standard, predictable one like `java.util.Random` for better performance.",
                    "A cryptographically secure one like `java.security.SecureRandom`.",
                    "No random number generator is needed.",
                    "The system clock.",
                  ],
                  correct: 1,
                  explanation:
                    "Standard PRNGs are designed for things like simulations or games and are predictable. A CSPRNG is designed to be unpredictable, which is essential for any cryptographic or security use case.",
                },
                {
                  id: 3,
                  question:
                    "You are reviewing Java code and see that it is using the `AES/ECB/PKCS5Padding` cipher mode. Why is this a security vulnerability?",
                  options: [
                    "It is not a vulnerability; ECB is the most secure mode.",
                    "ECB mode is insecure because it does not use an Initialization Vector (IV), causing identical blocks of plaintext to be encrypted into identical blocks of ciphertext.",
                    "ECB mode is too slow.",
                    "ECB mode only works for DES, not AES.",
                  ],
                  correct: 1,
                  explanation:
                    "The lack of randomness in ECB leaks patterns from the plaintext into the ciphertext, which can be exploited. Modern, secure modes like GCM should always be used instead.",
                },
                {
                  id: 4,
                  question:
                    "The security of an encryption algorithm like AES depends entirely on:",
                  options: [
                    "The length of the data being encrypted.",
                    "The speed of the computer.",
                    "The secrecy of the algorithm.",
                    "The secrecy and security of the key.",
                  ],
                  correct: 3,
                  explanation:
                    "This is a fundamental principle. You must assume the attacker knows the algorithm you are using. The security rests solely on the fact that they do not know your secret key. Therefore, protecting the key is the most important part of the system.",
                },
              ],
            },
          },
          {
            id: "lesson-8",
            title: "Error Handling and Logging Review",
            duration: "90 min",
            objectives: [
              "Learn to identify error handling that leads to information disclosure.",
              "Review code for secure logging practices, ensuring sensitive data is not logged.",
              "Assess the implementation of an audit trail for security-relevant events.",
              "Analyze exception handling for fail-secure behavior.",
            ],
            content: {
              overview:
                "Error handling and logging are essential for reliable software, but they are also a common source of security vulnerabilities. As a code reviewer, you must analyze how the application behaves when things go wrong and what information it records. This lesson covers how to spot insecure error handling and logging patterns in code.",
              sections: [
                {
                  title: "Information Disclosure Vulnerability Review",
                  content:
                    "<p>This is the most common vulnerability in error handling. The application must not leak internal details to the end-user.</p><h3>What to Look For:</h3><p>Review the `catch` blocks of exception handlers. If an exception is caught and its details (especially the stack trace) are written directly to the HTTP response, you have found a vulnerability. The code must follow the 'log detailed, show generic' pattern.</p><ul><li><strong>Anti-Pattern:</strong> `response.getWriter().println(exception.toString());`</li><li><strong>Secure Pattern:</strong> Show a generic message and a reference ID, and log the full exception details to a secure, server-side log.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1555099962-4199c345e546?w=800&h=400&fit-crop",
                },
                {
                  title: "Logging Security Implementation Review",
                  content:
                    "<p>Logs themselves can be a high-value target for attackers, as they may contain sensitive data.</p><h3>What to Look For:</h3><ul><li><strong>Logging of Sensitive Data:</strong> This is a critical flaw. Search the code for logging statements. If you see sensitive data like passwords, session tokens, API keys, or credit card numbers being written to a log, this must be fixed immediately.</li><li><strong>Log Injection:</strong> If a log message is constructed by concatenating un-sanitized user input, an attacker could inject newline characters (`\\n`) to forge log entries and confuse log analysis tools or hide their tracks. Use structured logging to prevent this.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1581291518857-4e27b48ff24e?w=800&h=400&fit-crop",
                },
                {
                  title: "Audit Trail Implementation Assessment",
                  content:
                    "<p>When reviewing the code, ensure that all security-relevant events are being explicitly logged to create a clear audit trail.</p><h3>Key Events to Check For:</h3><ul><li>Successful and failed login attempts.</li><li>Password changes and resets.</li><li>Changes to a user's permissions or roles.</li><li>Access to high-risk data or business functions.</li><li>Any administrative action.</li></ul><p>If you find a critical security function that does not have a corresponding audit log entry, that is a security finding.</p>",
                  image:
                    "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab 8: Error Handling Security Analysis",
                  language: "python",
                  code: '# VULNERABLE CODE: Information Disclosure\n\n@app.errorhandler(Exception)\ndef handle_error(e):\n    # ANTI-PATTERN: The full, detailed exception is sent to the client.\n    # This leaks internal details about the framework and code.\n    return f"<h1>Error</h1><p>{e}</p>", 500\n\n# SECURE CODE\n\n@app.errorhandler(Exception)\ndef secure_handle_error(e):\n    error_id = uuid.uuid4()\n    # 1. Log the detailed error server-side with the ID.\n    app.logger.error(f"Error ID {error_id}: {e}", exc_info=True)\n    \n    # 2. Return a generic message to the client with the ID.\n    return f"<h1>Error</h1><p>An internal error occurred. Please contact support with ID: {error_id}</p>", 500',
                },
                {
                  title: "Code Example 8: Secure Error Handling Validator",
                  language: "java",
                  code: "// VULNERABLE CODE: Logging sensitive data\n\npublic void login(String username, String password) {\n    // ANTI-PATTERN: The user's password is being written to the log file.\n    // If the log files are compromised, all user passwords will be exposed.\n    log.info(\"User '{}' is attempting to log in with password '{}'\", username, password);\n\n    if (authenticate(username, password)) {\n        // ...\n    } \n}\n\n// FIX: Do not log the password.\nlog.info(\"User '{}' is attempting to log in.\", username);",
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the primary security risk of showing a detailed stack trace in an error message to an end-user?",
                  options: [
                    "It makes the error message too long.",
                    "It reveals internal implementation details of the application, which can help an attacker plan their attack.",
                    "It is required for compliance.",
                    "It has no security risk.",
                  ],
                  correct: 1,
                  explanation:
                    "This is a form of information disclosure. A stack trace can reveal the frameworks you use, internal file paths, and other details that make it easier for an attacker to find and exploit other vulnerabilities.",
                },
                {
                  id: 2,
                  question:
                    "When reviewing logging code, what is the most critical type of information to ensure is NEVER logged?",
                  options: [
                    "Timestamps",
                    "Usernames",
                    "Source IP addresses",
                    "Sensitive credentials like passwords, session tokens, or API keys",
                  ],
                  correct: 3,
                  explanation:
                    "Logging sensitive credentials is a critical vulnerability. It means that a compromise of your logging system (which is often less secured than your production database) can lead to a full compromise of all user accounts.",
                },
                {
                  id: 3,
                  question:
                    "The 'log detailed, show generic' pattern for error handling means:",
                  options: [
                    "Log a generic error on the server and show a detailed stack trace to the user.",
                    "Log the full, detailed error securely on the server-side, but show a generic, non-technical message to the user.",
                    "Do not log errors at all.",
                    "Show the same detailed error message to both the user and the log.",
                  ],
                  correct: 1,
                  explanation:
                    "This is the core principle of secure error handling. It ensures that developers have the information they need to debug the problem without exposing any of those sensitive details to a potential attacker.",
                },
                {
                  id: 4,
                  question:
                    "An attack where a user provides input like `login failed\\nuser admin logged in successfully` to try and forge log entries is known as:",
                  options: [
                    "SQL Injection",
                    "Log Injection",
                    "Cross-Site Scripting",
                    "Path Traversal",
                  ],
                  correct: 1,
                  explanation:
                    "Log injection attacks use characters like newlines (`\\n`) to add fake entries to a log file, which can be used to confuse analysts or hide an attacker's tracks. The primary defense is to use a structured logging format (like JSON) that correctly handles special characters.",
                },
              ],
            },
          },
          {
            id: "lesson-9",
            title: "Database Security Code Review",
            duration: "90 min",
            objectives: [
              "Master the identification of SQL Injection vulnerabilities in code.",
              "Review database connection logic for security flaws.",
              "Analyze code for proper enforcement of least privilege.",
              "Assess the security of code that uses Object-Relational Mappers (ORMs).",
            ],
            content: {
              overview:
                "This lesson provides a focused guide for code reviewers on database security. We will build on the concepts from the secure development lesson, focusing specifically on how to spot the most common and dangerous database-related security flaws in a code review, with a heavy emphasis on injection attacks.",
              sections: [
                {
                  title: "SQL Injection Vulnerability Analysis",
                  content:
                    '<p>This is the most critical part of a database security code review. Your mission is to hunt for any place where a SQL query is built by concatenating strings with untrusted data.</p><h3>The Review Process:</h3><ol><li>Identify all the code that executes database queries.</li><li>For each query, trace the origin of every variable used to build the query string.</li><li>If any part of the query string comes from an external source (HTTP request, another service, etc.) and is not handled via a parameterized query, you have found a SQL injection vulnerability.</li></ol><div class="info-box warning"><div class="info-box-header"><i class="fas fa-exclamation-triangle"></i><strong>Focus on the Sink</strong></div><p>Even if you think there is input validation happening at the start of the request, you must still check the database query code itself. A developer might add a new, unsafe query later that forgets to use the validation. The only guaranteed defense is to ensure the query itself is built safely using parameters.</p></div>',
                  image:
                    "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit-crop",
                },
                {
                  title: "ORM Security Implementation Review",
                  content:
                    "<p>Object-Relational Mappers (ORMs) like Hibernate, Entity Framework, and SQLAlchemy are great because they use parameterized queries by default, which prevents most standard SQLi. However, they are not a silver bullet.</p><h3>What to Review:</h3><ul><li><strong>Raw SQL Escape Hatches:</strong> Look for any use of functions like `FromSqlRaw`, `ExecuteSqlCommand`, or `session.execute`. These functions allow the developer to bypass the ORM and write raw SQL. When they are used, you must review them with the same scrutiny as any other database query.</li><li><strong>HQL/JPQL Injection:</strong> Some ORMs have their own query languages (like Hibernate's HQL). These can also be vulnerable to injection if the queries are built using string concatenation.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1517694712202-14dd9538aa97?w=800&h=400&fit-crop",
                },
                {
                  title: "Database Privilege Analysis",
                  content:
                    "<p>Review the application's configuration to see what database user it is connecting as. Then, check the permissions of that user in the database. This is a review of least privilege.</p><h3>Red Flags:</h3><ul><li>The application connects as a highly privileged user like `sa`, `root`, or `dbo`.</li><li>The application's service account has permissions to tables it doesn't need to access.</li><li>The service account has `UPDATE` or `DELETE` permissions when it only needs to read data.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1556155092-490a1ba16284?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab 9: Database Security Review Workshop",
                  language: "csharp",
                  code: '// VULNERABLE CODE TO REVIEW (ORM Escape Hatch)\n// This code uses Entity Framework Core.\n\npublic List<Product> GetProductsByCategory(string category) {\n    // ANTI-PATTERN: The developer has used FromSqlRaw and string interpolation to build the query.\n    // This bypasses the ORM\'s default safety and is vulnerable to SQL Injection.\n    return _context.Products\n        .FromSqlRaw($"SELECT * FROM Products WHERE Category = \'{category}\'")\n        .ToList();\n}\n\n// SECURE CODE\n\npublic List<Product> SecureGetProductsByCategory(string category) {\n    // FIX: The FromSqlInterpolated method uses parameterization under the hood, making it safe.\n    return _context.Products\n        .FromSqlInterpolated($"SELECT * FROM Products WHERE Category = {category}")\n        .ToList();\n}',
                },
                {
                  title: "Code Example 9: Database Security Analysis Engine",
                  language: "markdown",
                  code: "# Code Review Finding: Excessive Privilege\n\n**File:** `config/database.yml`\n\n**Vulnerable Configuration:**\n`username: db_owner`\n\n**Analysis:**\n- The application is connecting to the database using the powerful `db_owner` role.\n- A review of the application's code shows that it only ever performs `SELECT` and `INSERT` operations on two specific tables.\n- **Vulnerability:** If the application is compromised, the attacker will gain full owner-level privileges on the entire database, allowing them to drop tables, delete data, and compromise all other applications that use this database.\n- **CWE:** CWE-272: Least Privilege Violation.\n\n**Recommendation:**\nCreate a new, dedicated database role for this application. Grant that role only the specific `SELECT` and `INSERT` permissions it requires on the `orders` and `customers` tables. Update the configuration to use this new, least-privileged role.",
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    'You are reviewing code and see the line `db.query("SELECT ... WHERE name = \'" + userName + "\'")`. This is a critical finding for what vulnerability?',
                  options: [
                    "Cross-Site Scripting",
                    "SQL Injection",
                    "Buffer Overflow",
                    "This is secure code.",
                  ],
                  correct: 1,
                  explanation:
                    "This is the classic, unmistakable pattern of SQL Injection. User input (`userName`) is being directly concatenated into a SQL query string. This is a critical vulnerability that must be fixed.",
                },
                {
                  id: 2,
                  question:
                    "While ORM frameworks generally prevent SQLi by default, what feature should a code reviewer pay close attention to?",
                  options: [
                    "The ORM's ability to map objects to tables.",
                    "Any function that acts as an 'escape hatch' to allow developers to write and execute raw, un-parameterized SQL strings.",
                    "The ORM's connection pooling.",
                    "The version number of the ORM.",
                  ],
                  correct: 1,
                  explanation:
                    "Functions like `FromSqlRaw` are powerful but dangerous. When a developer uses them, they are taking responsibility for security back from the ORM, and a reviewer must scrutinize this code just as they would any other raw SQL query.",
                },
                {
                  id: 3,
                  question:
                    "Reviewing the application's database connection user and finding it has `db_owner` privileges is a violation of what principle?",
                  options: [
                    "Defense in Depth",
                    "Fail Securely",
                    "Principle of Least Privilege",
                    "Open Design",
                  ],
                  correct: 2,
                  explanation:
                    "The application should only have the bare minimum permissions it needs to function. Granting it owner-level privileges dramatically increases the 'blast radius' if the application is ever compromised.",
                },
                {
                  id: 4,
                  question:
                    "What is the best way to secure a database connection string in an application's configuration?",
                  options: [
                    "Store it in a version-controlled plaintext config file.",
                    "Hard-code it in the source code.",
                    "Store it in a secure secrets management vault and have the application retrieve it at runtime.",
                    "Email it to the development team.",
                  ],
                  correct: 2,
                  explanation:
                    "The connection string is a highly sensitive secret. A code reviewer should always check that it is not being stored insecurely in a config file or source code.",
                },
              ],
            },
          },
          {
            id: "lesson-10",
            title: "Memory Management Security Review",
            duration: "90 min",
            objectives: [
              "Learn to identify buffer overflow vulnerabilities in C/C++ code.",
              "Review code for other memory corruption flaws like use-after-free.",
              "Analyze the use of safe versus unsafe string and memory functions.",
              "Understand how to use static analysis tools to find memory issues.",
            ],
            content: {
              overview:
                "This lesson provides a focused guide for code reviewers on memory safety. Building on the concepts from the secure development lesson, we will dive deep into the specific code patterns and anti-patterns that lead to memory corruption vulnerabilities in languages like C and C++, and how to spot them during a review.",
              sections: [
                {
                  title: "Buffer Overflow Vulnerability Analysis",
                  content:
                    "<p>Your primary goal when reviewing C/C++ code is to hunt for potential buffer overflows. This means scrutinizing any code that copies data into a fixed-size buffer.</p><h3>The Anti-Patterns to Hunt For:</h3><p>Search the code for any use of known unsafe C-style string and memory functions. Their presence is an immediate red flag.</p><ul><li><strong>Unbounded String Functions:</strong> `strcpy`, `strcat`, `sprintf`, `vsprintf`, `gets`.</li><li><strong>Unbounded Memory Functions:</strong> `memcpy` when the size argument comes from an untrusted source.</li></ul><p>For every instance you find, you must verify that the code is not vulnerable or recommend that it be replaced with its safer, bounded equivalent (e.g., `strncpy`, `snprintf`).</p>",
                  image:
                    "https://images.unsplash.com/photo-1555099962-4199c345e546?w=800&h=400&fit-crop",
                },
                {
                  title: "Integer Overflow Analysis",
                  content:
                    "<p>Integer overflows can often lead to buffer overflows. An attacker might provide a large number that, when used in a calculation to allocate memory, wraps around to become a small number.</p><h3>What to Look For:</h3><p>Review any code where an integer from an untrusted source is used in a size calculation for a subsequent memory operation (like a `malloc` or a `memcpy`). This is a subtle but critical vulnerability. Modern compilers have flags and sanitizers that can help detect these at compile time and runtime.</p>",
                  image:
                    "https://images.unsplash.com/photo-1517694712202-14dd9538aa97?w=800&h=400&fit-crop",
                },
                {
                  title: "Use-After-Free Vulnerability Detection",
                  content:
                    "<p>This vulnerability occurs when a program continues to use a pointer after the memory it points to has been deallocated (freed).</p><h3>What to Look For:</h3><p>This is a very difficult bug to find with manual review alone, as it depends on complex program state. It often involves multiple threads. Your best approach as a reviewer is to:</p><ol><li>Rely on specialized static and dynamic analysis tools designed to find these issues.</li><li>Pay close attention to complex code that deals with pointers and dynamically allocated objects, especially in a multi-threaded context.</li><li>Ensure that whenever memory is freed, any pointers to that memory are immediately set to `NULL` to prevent their accidental reuse.</li></ol>",
                  image:
                    "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab 10: Memory Safety Analysis Lab",
                  language: "c",
                  code: "// VULNERABLE CODE TO REVIEW (Integer Overflow leading to Heap Overflow)\n\nvoid process_packet(Packet *p) {\n    // The packet header contains a 'length' field controlled by the attacker.\n    int size = p->header.length;\n\n    // ANTI-PATTERN: The developer tries to add 1 for a null terminator, but doesn't check for overflow.\n    // If an attacker sets 'length' to the maximum value for an integer (INT_MAX),\n    // `size + 1` will overflow and wrap around to 0.\n    int buffer_size = size + 1;\n\n    // malloc(0) might return a very small, default-sized chunk of memory.\n    char *buffer = (char *)malloc(buffer_size);\n\n    // Now, memcpy will try to copy INT_MAX bytes from the packet into the tiny buffer,\n    // causing a massive heap-based buffer overflow.\n    memcpy(buffer, p->data, size);\n    buffer[size] = '\\0';\n}\n\n// FIX: Always use checked arithmetic for size calculations from untrusted sources.",
                },
                {
                  title:
                    "Code Example 10: Memory Security Vulnerability Scanner",
                  language: "markdown",
                  code: "# Code Review Finding: Use of Unsafe Function\n\n**File:** `parser.c`, line 92\n\n**Vulnerable Code:**\n`strcpy(buffer, user_supplied_string);`\n\n**Analysis:**\n- The code uses the `strcpy` function, which is known to be unsafe as it does not perform bounds checking.\n- The source `user_supplied_string` comes from a network socket and its length is not validated before the copy.\n- The destination `buffer` is a fixed-size 256-byte buffer on the stack.\n- **Vulnerability:** If an attacker sends a string longer than 255 bytes, this will cause a stack-based buffer overflow.\n- **CWE:** CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow').\n\n**Recommendation:**\nReplace `strcpy` with the safer `strncpy` function:\n`strncpy(buffer, user_supplied_string, sizeof(buffer) - 1);`",
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "When reviewing C/C++ code, the presence of which function is an immediate red flag for a potential buffer overflow?",
                  options: ["strncpy", "snprintf", "strcpy", "malloc"],
                  correct: 2,
                  explanation:
                    "`strcpy` is the classic example of an unsafe C function. It performs no bounds checking, making it a primary cause of buffer overflows. A reviewer should search for all instances of it.",
                },
                {
                  id: 2,
                  question:
                    "A vulnerability where a program continues to use a pointer to memory that has already been deallocated is known as:",
                  options: [
                    "Buffer Overflow",
                    "Integer Overflow",
                    "Use-After-Free",
                    "SQL Injection",
                  ],
                  correct: 2,
                  explanation:
                    "Use-after-free is a subtle but dangerous type of memory corruption. It can lead to unpredictable behavior, crashes, and often remote code execution.",
                },
                {
                  id: 3,
                  question:
                    "An integer overflow is a security risk primarily when:",
                  options: [
                    "It happens in code that doesn't affect security.",
                    "The overflowing integer is used in a size calculation to allocate a buffer, which then leads to a buffer overflow.",
                    "The integer is displayed to a user.",
                    "It is not a security risk.",
                  ],
                  correct: 1,
                  explanation:
                    "The integer overflow itself is a mathematical error, but it becomes a critical security vulnerability when it is used to subvert a security check, most commonly by causing a much smaller buffer to be allocated than expected.",
                },
                {
                  id: 4,
                  question:
                    "What is the best way to prevent buffer overflows when copying strings in C?",
                  options: [
                    "Guessing that the buffer is probably large enough.",
                    "Using unsafe functions like `strcpy` and hoping for the best.",
                    "Using bounded, 'safe' functions like `strncpy` that take the size of the destination buffer as an argument.",
                    "Writing all new code in a memory-safe language like Rust.",
                  ],
                  correct: 2,
                  explanation:
                    "While using a memory-safe language is the ultimate solution, when working with C/C++, the rule is to always use the bounded versions of memory and string functions that require you to specify the buffer size.",
                },
              ],
            },
          },
          {
            id: "lesson-11",
            title: "Concurrency and Race Condition Review",
            duration: "90 min",
            objectives: [
              "Learn to identify code patterns that are susceptible to race conditions.",
              "Review the implementation of synchronization mechanisms like locks for correctness.",
              "Spot Time-of-Check to Time-of-Use (TOCTOU) vulnerabilities in code.",
              "Analyze the security of atomic operations and lock-free programming.",
            ],
            content: {
              overview:
                "This lesson provides a focused guide for code reviewers on concurrency security. Building on the concepts from the secure development lesson, we will explore how to spot the subtle and often hard-to-find bugs that arise from multi-threaded code, with a special focus on the dangerous 'check-then-act' anti-pattern.",
              sections: [
                {
                  title: "Race Condition Vulnerability Identification",
                  content:
                    "<p>Race conditions are some of the hardest bugs to find in a review because they are not always obvious from a static reading of the code and they are difficult to reproduce in testing. As a reviewer, you need to develop a sense for spotting code that accesses a shared resource without proper locking.</p><h3>What to Look For:</h3><p>Pay close attention to any code that modifies a shared object or state (e.g., a static variable, a shared cache, an application-level setting). If multiple threads can access this code and it is not protected by a `synchronized` block (in Java) or a lock, you may have found a race condition.</p>",
                  image:
                    "https://images.unsplash.com/photo-1534972195531-0e108fc312f0?w=800&h=400&fit-crop",
                },
                {
                  title: "Time-of-Check to Time-of-Use (TOCTOU) Analysis",
                  content:
                    "<p>This is the most common and important type of race condition for a security reviewer to find.</p><h3>The Anti-Pattern to Hunt For:</h3><p>Look for any sequence of code that does the following:</p><ol><li>**CHECK:** It performs a security check on a resource (e.g., `if (user.hasPermission(file))`).</li><li>**ACT:** It then performs an action on that same resource in a separate statement (e.g., `file.open()`).</li></ol><p>If you find this pattern, you have found a potential TOCTOU vulnerability. The state of the resource could change in the tiny time window between the check and the act.</p>",
                  image:
                    "https://images.unsplash.com/photo-1588665387928-a8d2a13f8373?w=800&h=400&fit-crop",
                },
                {
                  title: "Synchronization Mechanism Review",
                  content:
                    "<p>When you see that a developer has used a lock to prevent a race condition, your job as a reviewer is to check that it has been implemented correctly.</p><h3>Common Mistakes:</h3><ul><li><strong>Locking the Wrong Object:</strong> The lock must be on a shared object that is common to all threads.</li><li><strong>Deadlocks:</strong> A situation where two or more threads are blocked forever, waiting for each other to release a lock. Review complex locking logic carefully for potential deadlock scenarios.</li><li><strong>Improper Lock Release:</strong> The lock must *always* be released, even if an exception occurs. In languages like Java and C#, this means the `unlock()` call should be in a `finally` block.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab 11: Concurrency Security Analysis Workshop",
                  language: "java",
                  code: "// VULNERABLE CODE TO REVIEW (TOCTOU)\n\npublic void deleteFile(User user, String filePath) {\n    File file = new File(filePath);\n\n    // 1. Time of Check: The code checks if the user has permission for the file.\n    if (!user.canDelete(file)) {\n        throw new AccessDeniedException();\n    }\n\n    // ATTACKER'S WINDOW OF OPPORTUNITY:\n    // An attacker could replace the 'file' with a symbolic link to a critical system file\n    // right after the check passes but before the delete operation happens.\n\n    // 2. Time of Use: The code deletes the file.\n    file.delete();\n}\n\n// MITIGATION:\n// This type of filesystem race is very hard to fix in code. The best defense is often\n// to use proper, restrictive file system permissions so the application process itself\n// does not have permission to delete critical files, regardless of what the code does.",
                },
                {
                  title: "Code Example 11: Race Condition Detection Framework",
                  language: "csharp",
                  code: "// VULNERABLE CODE: Improper lock release\n\npublic void doWork() {\n    _lock.Enter(); // Acquire the lock\n    \n    // If this method throws an exception, the lock is never released!\n    // This will cause a deadlock, and the application will hang.\n    performRiskyOperation(); \n    \n    _lock.Exit(); // This line is never reached\n}\n\n// SECURE CODE\n\npublic void secureDoWork() {\n    _lock.Enter();\n    try {\n        performRiskyOperation();\n    } finally {\n        // FIX: The 'finally' block ensures that the lock is always released,\n        // even if an exception is thrown.\n        _lock.Exit();\n    }\n}",
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "The 'check-then-act' anti-pattern is the classic indicator of what type of vulnerability?",
                  options: [
                    "Time-of-Check to Time-of-Use (TOCTOU)",
                    "SQL Injection",
                    "Cross-Site Scripting",
                    "Buffer Overflow",
                  ],
                  correct: 0,
                  explanation:
                    "TOCTOU is the formal name for this race condition. As a reviewer, you should be highly suspicious of any code that checks a condition and then acts on it in a separate step without proper locking.",
                },
                {
                  id: 2,
                  question:
                    "When reviewing code that uses locks, placing the `unlock()` call in a `finally` block is essential for what reason?",
                  options: [
                    "To make the code run faster.",
                    "To prevent deadlocks by ensuring the lock is always released, even if an exception occurs.",
                    "It has no purpose.",
                    "To make the code harder to read.",
                  ],
                  correct: 1,
                  explanation:
                    "This is a critical correctness and security pattern. Forgetting to release a lock can cause the entire application to hang, leading to a denial of service. The `finally` block guarantees that the lock is released.",
                },
                {
                  id: 3,
                  question:
                    "A section of code that accesses a shared resource and must not be executed by more than one thread at a time is known as a:",
                  options: [
                    "Race Condition",
                    "Critical Section",
                    "Vulnerability",
                    "Comment",
                  ],
                  correct: 1,
                  explanation:
                    "A critical section is the part of the code that needs to be protected by a synchronization mechanism like a lock to ensure it is executed atomically.",
                },
                {
                  id: 4,
                  question:
                    "Why are race condition vulnerabilities particularly difficult to find and debug?",
                  options: [
                    "They are not difficult to find.",
                    "They are often non-deterministic; they only occur when threads execute in a specific, unpredictable order, making them hard to reproduce consistently.",
                    "They can only be found by automated tools.",
                    "They do not have any negative impact.",
                  ],
                  correct: 1,
                  explanation:
                    "The non-deterministic nature of race conditions is what makes them so challenging. This is why a careful manual code review is often more effective at finding them than testing alone.",
                },
              ],
            },
          },
          {
            id: "lesson-12",
            title: "Web Application Security Review",
            duration: "120 min",
            objectives: [
              "Learn to spot Cross-Site Scripting (XSS) and Cross-Site Request Forgery (CSRF) flaws in code.",
              "Review the implementation of Content Security Policy (CSP) and other security headers.",
              "Analyze code for session fixation and clickjacking vulnerabilities.",
              "Identify insecure URL redirection and file inclusion flaws.",
            ],
            content: {
              overview:
                "This lesson provides a focused guide for code reviewers on web application security. We will build on the concepts from previous lessons, focusing on how to spot the specific code patterns and anti-patterns for the most common web-based attacks, from XSS and CSRF to clickjacking and open redirects.",
              sections: [
                {
                  title: "XSS and CSRF Prevention Analysis",
                  content:
                    "<h3>Cross-Site Scripting (XSS):</h3><p>Your review must focus on the boundary where data is rendered to the user. Look for any instance where data from an untrusted source is placed into the HTML output without being passed through a contextual output encoding library.</p><h3>Cross-Site Request Forgery (CSRF):</h3><p>Review any state-changing actions (e.g., POST requests like changing a password or transferring funds). The application must defend against CSRF using a technique like the synchronizer token pattern (anti-CSRF tokens) or by checking the `SameSite` attribute on cookies.</p>",
                  image:
                    "https://images.unsplash.com/photo-1555099962-4199c345e546?w=800&h=400&fit-crop",
                },
                {
                  title: "Content Security Policy (CSP) Review",
                  content:
                    "<p>A Content Security Policy is a powerful, defense-in-depth HTTP header. When reviewing its implementation, look for common mistakes.</p><h3>What to Review:</h3><ul><li><strong>Is it too permissive?</strong> A policy that includes `'unsafe-inline'` or `'unsafe-eval'` significantly weakens its effectiveness.</li><li><strong>Does it use nonces or hashes?</strong> For inline scripts, using a nonce (a random value) or a hash is the secure way to allow them, rather than using `'unsafe-inline'`.</li><li><strong>Is it in `report-only` mode?</strong> A `Content-Security-Policy-Report-Only` header will report violations but not block them. Check if this is intended for testing or has been left in production by mistake.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1563237023-b1e97623d00b?w=800&h=400&fit-crop",
                },
                {
                  title: "Clickjacking and UI Redressing Prevention",
                  content:
                    "<p>Clickjacking is an attack where an attacker uses a transparent iframe to trick a user into clicking on something different from what they perceive. For example, tricking them into clicking a 'Delete My Account' button that is hidden invisibly under a 'Click Here to Win a Prize!' button.</p><h3>What to Look For in Code:</h3><p>The primary defense is the `X-Frame-Options` HTTP header. Review the application's base configuration to ensure this header is being sent with a value of `DENY` (prevents framing entirely) or `SAMEORIGIN` (only allows framing by pages from the same origin).</p>",
                  image:
                    "https://images.unsplash.com/photo-1544256718-3b62ff04b356?w=800&h=400&fit-crop",
                },
                {
                  title: "URL Redirection Security Review",
                  content:
                    "<p>An open redirect is a vulnerability where an application takes a URL as a parameter and redirects the user to that URL without validating it. Attackers can use this to redirect users from your trusted site to their malicious phishing site.</p><h3>What to Look For:</strong></h3><p>Review any code that performs an HTTP redirect where the destination URL, or part of it, comes from a request parameter (e.g., `.../login?redirect_url=...`). The code must validate that the redirect URL is a known, safe, internal URL. The best way to do this is to check it against an allow-list of permitted URLs.</p>",
                  image:
                    "https://images.unsplash.com/photo-1517694712202-14dd9538aa97?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab 12: Web Security Code Review Platform",
                  language: "python",
                  code: "# VULNERABLE CODE TO REVIEW (Open Redirect)\n\nfrom flask import request, redirect\n\n@app.route('/redirect')\ndef redirect_to_url():\n    # ANTI-PATTERN: The redirect URL comes directly from a request parameter\n    # and is not validated. An attacker could craft a link like:\n    # /redirect?url=http://malicious-phishing-site.com\n    redirect_url = request.args.get('url')\n    return redirect(redirect_url)\n\n# SECURE CODE\n\nALLOWED_REDIRECTS = ['https://mysite.com/profile', 'https://mysite.com/dashboard']\n\n@app.route('/secure_redirect')\ndef secure_redirect_to_url():\n    redirect_url = request.args.get('url')\n    # FIX: The URL is validated against a strict allow-list.\n    if redirect_url in ALLOWED_REDIRECTS:\n        return redirect(redirect_url)\n    else:\n        return redirect('/default_page') # Redirect to a safe default",
                },
                {
                  title: "Code Example 12: Web Application Security Analyzer",
                  language: "http",
                  code: "// INSECURE Content Security Policy (too permissive)\nContent-Security-Policy: script-src * 'unsafe-inline' 'unsafe-eval';\n\n// SECURE Content Security Policy\nContent-Security-Policy: \n  default-src 'self'; // By default, only allow content from our own domain\n  script-src 'self' https://apis.google.com; // Also allow scripts from Google APIs\n  img-src 'self' https://images.example.com; // Also allow images from our CDN\n  object-src 'none'; // Disallow plugins like Flash",
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "A Content Security Policy (CSP) that includes `'unsafe-inline'` is considered weak because:",
                  options: [
                    "It is the most secure setting.",
                    "It allows any inline script to run, which significantly reduces its effectiveness against XSS.",
                    "It blocks all scripts from running.",
                    "It only works in older browsers.",
                  ],
                  correct: 1,
                  explanation:
                    "The `'unsafe-inline'` directive re-enables one of the primary attack vectors that CSP is designed to block. A strong CSP should avoid it and use nonces or hashes to approve specific inline scripts.",
                },
                {
                  id: 2,
                  question:
                    "The primary defense against clickjacking is the use of which HTTP header?",
                  options: [
                    "Content-Security-Policy",
                    "Strict-Transport-Security",
                    "X-Frame-Options",
                    "X-Content-Type-Options",
                  ],
                  correct: 2,
                  explanation:
                    "The `X-Frame-Options` header (with a value of `DENY` or `SAMEORIGIN`) instructs the browser not to render the page inside an iframe, which is the mechanism used to perform a clickjacking attack.",
                },
                {
                  id: 3,
                  question:
                    "A vulnerability where an application redirects a user to a malicious site based on a URL parameter is called an:",
                  options: [
                    "Open Redirect",
                    "SQL Injection",
                    "Cross-Site Scripting",
                    "File Inclusion",
                  ],
                  correct: 0,
                  explanation:
                    "Open redirects are dangerous because they allow an attacker to leverage the trust of your domain to launch phishing attacks. The only defense is to validate the redirect URL against an allow-list.",
                },
                {
                  id: 4,
                  question:
                    "The best way to implement a defense against Cross-Site Request Forgery (CSRF) is to:",
                  options: [
                    "Use the synchronizer token pattern (anti-CSRF tokens).",
                    "Encode all output to the user.",
                    "Use parameterized queries.",
                    "Disable all forms in the application.",
                  ],
                  correct: 0,
                  explanation:
                    "Anti-CSRF tokens are the standard, robust defense. The server generates a secret, unpredictable token that an attacker cannot guess, and requires this token to be present in all state-changing requests.",
                },
              ],
            },
          },
          {
            id: "lesson-13",
            title: "API Security Code Review",
            duration: "120 min",
            objectives: [
              "Learn to review code for the OWASP API Security Top 10 vulnerabilities.",
              "Assess the security of REST and GraphQL API implementations.",
              "Review API authentication and authorization logic, especially for BOLA/IDOR.",
              "Analyze the implementation of rate limiting and error handling in API code.",
            ],
            content: {
              overview:
                "This lesson provides a focused guide for code reviewers on API security. We will explore the common pitfalls in API development and how to spot them in the code, with a heavy emphasis on the authorization flaws that are the most common and critical risk to modern APIs.",
              sections: [
                {
                  title: "REST API Security Implementation Review",
                  content:
                    "<p>When reviewing a REST API, your primary focus should be on access control.</p><h3>The BOLA/IDOR Hunt:</h3><p>This is the most important part of your review. For every single endpoint that deals with a specific resource (e.g., `GET /users/{id}`, `POST /orders/{id}/update`), you must find the code that performs the authorization check to ensure the authenticated user has permission to access *that specific resource ID*.</p><p>If you find an endpoint that checks for authentication (`@jwt_required`) but does not perform this second, object-level ownership check, you have found a critical Broken Object Level Authorization (BOLA) vulnerability.</p>",
                  image:
                    "https://images.unsplash.com/photo-1605995538181-22920bee518f?w=800&h=400&fit=crop",
                },
                {
                  title: "GraphQL Security Analysis",
                  content:
                    "<p>GraphQL is a powerful query language for APIs, but it introduces its own security challenges.</p><h3>What to Review:</h3><ul><li><strong>Authorization:</strong> In GraphQL, the authorization logic is often in the 'resolver' for each field. Review these resolvers to ensure they are performing the correct permission checks.</li><li><strong>Query Depth and Complexity:</strong> A malicious user could send a deeply nested, complex query that consumes excessive server resources, leading to a denial of service. The GraphQL server must be configured with limits on query depth, complexity, and amount of data returned.</li><li><strong>Introspection:</strong> By default, GraphQL allows anyone to send an 'introspection' query to get the entire API schema. This can be useful for attackers. The review should check if introspection is disabled in the production environment.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit-crop",
                },
                {
                  title: "Input Validation for APIs",
                  content:
                    "<p>All the principles of input validation apply to APIs. The code must validate the structure, data types, and format of all incoming request bodies and parameters.</p><p>A common best practice is to define a formal schema for your API's requests (e.g., using JSON Schema or the API's OpenAPI specification) and use a library to automatically validate all incoming requests against this schema. As a reviewer, you should check that this validation is being performed for all endpoints.</p>",
                  image:
                    "https://images.unsplash.com/photo-1555099962-4199c345e546?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab 13: API Security Review Workshop",
                  language: "python",
                  code: "# VULNERABLE CODE TO REVIEW (Broken Function Level Authorization)\n\n@app.route('/api/users/<int:user_id>/delete', methods=['POST'])\n# The developer remembered the auth check...\n@jwt_required()\ndef delete_user(user_id):\n    # ...but they forgot the authorization check!\n    # Any authenticated user can delete any other user.\n    # This should be restricted to users with an 'admin' role.\n    user = User.query.get(user_id)\n    db.session.delete(user)\n    db.session.commit()\n    return {'status': 'deleted'}\n\n# SECURE CODE\n\n@app.route('/api/users/<int:user_id>/delete', methods=['POST'])\n@jwt_required()\ndef secure_delete_user(user_id):\n    # FIX: Add a check to ensure the user has the required role.\n    jwt_claims = get_jwt()\n    if 'admin' not in jwt_claims['roles']:\n        abort(403) # Forbidden\n    \n    user = User.query.get(user_id)\n    db.session.delete(user)\n    db.session.commit()\n    return {'status': 'deleted'}",
                },
                {
                  title: "Code Example 13: API Security Assessment Framework",
                  language: "markdown",
                  code: "# Code Review Finding: Excessive Data Exposure\n\n**File:** `UserSerializer.java`\n\n**Vulnerable Code:**\n`// This serializer converts the entire User database object to JSON.`\n`// The User object includes fields like 'passwordHash', 'resetToken', etc.`\n\n**Analysis:**\n- The API endpoint for getting a user's profile uses this serializer.\n- As a result, the API response contains many sensitive fields that the client UI does not need.\n- This violates the principle of least privilege and increases the risk if an attacker finds another flaw.\n- **OWASP API Top 10:** API3: Excessive Data Exposure.\n\n**Recommendation:**\nCreate a separate Data Transfer Object (DTO), `UserProfileDTO`, that contains only the specific, non-sensitive fields needed by the UI (`username`, `displayName`). Refactor the API endpoint to use this DTO for its response.",
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "When reviewing an API, what is the most common and critical vulnerability to look for?",
                  options: [
                    "Broken Object Level Authorization (BOLA) / IDOR",
                    "Excessive Data Exposure",
                    "Missing Rate Limiting",
                    "Poor Error Handling",
                  ],
                  correct: 0,
                  explanation:
                    "BOLA/IDOR is consistently ranked as the #1 most critical API security risk by OWASP. As a reviewer, hunting for this flaw in every relevant endpoint should be your top priority.",
                },
                {
                  id: 2,
                  question:
                    "An API that returns the user's password hash in a JSON response is an example of what vulnerability?",
                  options: [
                    "Broken Authentication",
                    "Excessive Data Exposure",
                    "SQL Injection",
                    "Broken Function Level Authorization",
                  ],
                  correct: 1,
                  explanation:
                    "The API should be designed to return only the minimum data required by the client. Returning the full, unfiltered database object is a dangerous anti-pattern that can expose sensitive data.",
                },
                {
                  id: 3,
                  question:
                    "What is a key security risk specific to GraphQL APIs?",
                  options: [
                    "They are not vulnerable to injection attacks.",
                    "They do not require authentication.",
                    "An attacker can send an overly complex or deeply nested query to cause a denial of service.",
                    "They can only be used with SQL databases.",
                  ],
                  correct: 2,
                  explanation:
                    "Because GraphQL gives so much power to the client to define the query, the server must have strong controls (like query depth and complexity limits) to prevent abuse and protect itself from denial-of-service attacks.",
                },
                {
                  id: 4,
                  question:
                    "When reviewing a `POST /api/admin/users` endpoint, the two key things to check are that the endpoint requires authentication and that it...",
                  options: [
                    "is fast.",
                    "returns a lot of data.",
                    "is accessible to all users.",
                    "performs an authorization check to ensure the user has the 'admin' role.",
                  ],
                  correct: 3,
                  explanation:
                    "This is a check for Broken Function Level Authorization. The reviewer must ensure that powerful, administrative functions are protected by a proper role or permission check, not just an authentication check.",
                },
              ],
            },
          },
          {
            id: "lesson-14",
            title: "Mobile Application Code Review",
            duration: "120 min",
            objectives: [
              "Learn to review mobile code for insecure data storage vulnerabilities.",
              "Assess the security of network communication code, including certificate pinning.",
              "Analyze the use of platform-specific security features like Keychain and Keystore.",
              "Identify vulnerabilities related to inter-process communication and URL schemes.",
            ],
            content: {
              overview:
                "This lesson provides a focused guide for code reviewers on mobile application security. We will explore the common pitfalls in both iOS and Android development and how to spot them in the code, with a heavy emphasis on insecure data storage and insecure network communication.",
              sections: [
                {
                  title: "Data Storage Security Assessment",
                  content:
                    "<p>This is the most critical area of a mobile code review. An attacker with physical access to a device (or malware on a rooted device) can often access the app's local data.</p><h3>What to Look For:</h3><ul><li><strong>Sensitive Data in Insecure Locations:</strong> Search the code for any instance where sensitive data (session tokens, PII, API keys) is being written to an insecure location like `SharedPreferences` (Android) or `UserDefaults` (iOS) without being encrypted first.</li><li><strong>Proper Use of Secure Storage:</strong> Verify that small secrets are being stored in the platform's hardware-backed secure storage: the **iOS Keychain** or the **Android Keystore**.</li><li><strong>Database Encryption:</strong> If the app uses a local SQLite database, review the code to ensure that a library like SQLCipher is being used to encrypt the entire database file.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1512428209919-8cf3c88b480c?w=800&h=400&fit-crop",
                },
                {
                  title: "Network Communication Security Analysis",
                  content:
                    "<h3>What to Look For:</h3><ul><li><strong>Cleartext Traffic:</strong> Search the code and configuration for any use of `http://` URLs. All traffic must be over `https://` (TLS). Android's Network Security Configuration file should be reviewed to ensure it does not allow cleartext traffic.</li><li><strong>Certificate Validation:</strong> Review the network library's configuration. Is it properly validating the server's certificate? A common anti-pattern is a custom `TrustManager` that blindly accepts all certificates, which completely disables TLS protection and makes the app vulnerable to man-in-the-middle attacks.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1534972195531-0e108fc312f0?w=800&h=400&fit-crop",
                },
                {
                  title: "Platform Security Feature Usage Review",
                  content:
                    "<ul><li><strong>Biometric Authentication:</strong> Review the code that uses Touch ID or Face ID. Is it correctly handling the case where authentication fails?</li><li><strong>Root/Jailbreak Detection:</strong> If the app has root detection, review the logic. Is it easy to bypass? What does the app do when it detects a rooted device?</li><li><strong>URL Schemes:</strong> If the app registers a custom URL scheme (e.g., `myapp://`), review the code that handles these deep links. This is an attack surface. The handler must perform robust input validation on any parameters from the URL.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1600267185393-e158a781ea27?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab 14: Mobile Security Code Review Lab",
                  language: "java",
                  code: '// VULNERABLE CODE TO REVIEW (Insecure Data Storage in Android)\n\npublic void saveSessionToken(Context context, String token) {\n    // ANTI-PATTERN: SharedPreferences stores data in a plaintext XML file\n    // in the app\'s sandboxed directory. On a rooted device, this file can be easily read.\n    SharedPreferences prefs = context.getSharedPreferences("user_prefs", Context.MODE_PRIVATE);\n    prefs.edit().putString("session_token", token).apply();\n}\n\n// SECURE CODE\n\npublic void secureSaveSessionToken(Context context, String token) {\n    // FIX: Use EncryptedSharedPreferences, which uses the Android Keystore\n    // to automatically encrypt the data before writing it to disk.\n    EncryptedSharedPreferences prefs = // ... initialization code ...\n    prefs.edit().putString("session_token", token).apply();\n}',
                },
                {
                  title: "Code Example 14: Mobile Security Analysis Platform",
                  language: "xml",
                  code: '<!-- VULNERABLE CODE TO REVIEW (Android Network Security Config) -->\n<!-- This configuration allows the app to send unencrypted HTTP traffic. -->\n\n<network-security-config>\n    <base-config cleartextTrafficPermitted="true">\n        <trust-anchors>\n            <certificates src="system" />\n        </trust-anchors>\n    </base-config>\n</network-security-config>\n\n<!-- SECURE CONFIGURATION -->\n<network-security-config>\n    <!-- FIX: By default, cleartext traffic is NOT permitted. -->\n    <base-config cleartextTrafficPermitted="false">\n        <trust-anchors>\n            <certificates src="system" />\n        </trust-anchors>\n    </base-config>\n</network-security-config>',
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "When reviewing Android code, you find sensitive data being stored using `SharedPreferences`. Why is this a potential vulnerability?",
                  options: [
                    "It is the most secure way to store data.",
                    "Standard `SharedPreferences` stores data in a plaintext XML file, which can be easily read on a rooted device.",
                    "It encrypts the data automatically.",
                    "It stores the data in the cloud.",
                  ],
                  correct: 1,
                  explanation:
                    "This is a classic insecure data storage flaw. The secure alternative is to use `EncryptedSharedPreferences`, which integrates with the hardware-backed Android Keystore.",
                },
                {
                  id: 2,
                  question:
                    "The most secure, hardware-backed location to store a secret like an API key on an iOS device is the:",
                  options: [
                    "iOS Keychain",
                    "UserDefaults",
                    "A plaintext file in the app's documents directory",
                    "Notes app",
                  ],
                  correct: 0,
                  explanation:
                    "The iOS Keychain is specifically designed for the secure storage of small secrets. It leverages the device's Secure Enclave hardware for protection.",
                },
                {
                  id: 3,
                  question:
                    "A piece of networking code that is configured to accept any TLS certificate presented by a server is vulnerable to what attack?",
                  options: [
                    "SQL Injection",
                    "Man-in-the-Middle (MITM) attacks",
                    "Buffer Overflow",
                    "Cross-Site Scripting",
                  ],
                  correct: 1,
                  explanation:
                    "Proper certificate validation is the only thing that ensures you are talking to the legitimate server. Disabling this check allows an attacker on the same network to intercept and decrypt all the app's traffic.",
                },
                {
                  id: 4,
                  question:
                    "An application that registers a custom URL scheme like `myapp://` must be carefully reviewed for what vulnerability?",
                  options: [
                    "The code that handles the incoming URL must perform robust input validation on any parameters passed in the URL.",
                    "The color scheme of the app.",
                    "The size of the application icon.",
                    "There are no vulnerabilities associated with URL schemes.",
                  ],
                  correct: 0,
                  explanation:
                    "Custom URL schemes are a form of inter-process communication and are an attack surface. A malicious web page or another app can invoke these URLs, so the handling code must treat any data from the URL as fully untrusted input.",
                },
              ],
            },
          },
          {
            id: "lesson-15",
            title: "Cloud and Container Security Review",
            duration: "120 min",
            objectives: [
              "Learn to review Infrastructure as Code (IaC) for security misconfigurations.",
              "Assess the security of a Dockerfile.",
              "Review Kubernetes configurations for security best practice violations.",
              "Analyze the security of serverless function code and permissions.",
            ],
            content: {
              overview:
                "As a developer in a cloud-native world, you are increasingly responsible for the code that defines your application's infrastructure and runtime environment. This lesson provides a code reviewer's guide to spotting security flaws in Infrastructure as Code (IaC), Dockerfiles, and serverless configurations.",
              sections: [
                {
                  title: "Infrastructure as Code (IaC) Security Analysis",
                  content:
                    "<p>When reviewing IaC (like Terraform or CloudFormation), you are performing a 'pre-deployment' configuration review. You are looking for misconfigurations that would create a vulnerability if deployed.</p><h3>What to Look For:</h3><ul><li><strong>Publicly Exposed Resources:</strong> Look for S3 buckets, storage containers, or databases that are configured to be publicly accessible.</li><li><strong>Overly Permissive Firewall Rules:</strong> Look for security group or network security group rules that allow unrestricted ingress (0.0.0.0/0), especially on sensitive ports like SSH (22) or RDP (3389).</li><li><strong>Missing Encryption:</strong> Check that encryption at rest is enabled for all databases and storage volumes.</li><li><strong>Excessive IAM Permissions:</strong> Review the IAM roles and policies defined in the code to ensure they follow the principle of least privilege.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1510915228340-29c85a43dcfe?w=800&h=400&fit-crop",
                },
                {
                  title: "Container Security Implementation Review",
                  content:
                    "<p>The Dockerfile is the source code for your container image. It must be reviewed for security best practices.</p><h3>Dockerfile Checklist:</h3><ul><li>[ ] Is the `FROM` instruction using a minimal, trusted base image? Or is it using a large, unknown image from a public repository?</li><li>[ ] Is the `USER` instruction used to switch to a non-root user before the application is run?</li><li>[ ] Are any secrets (passwords, keys) being copied into the image with an `ADD` or `COPY` instruction?</li><li>[ ] Is a multi-stage build being used to keep the final image small and free of build tools?</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1614064548237-02f0d1a2c39c?w=800&h=400&fit-crop",
                },
                {
                  title: "Serverless Function Security Review",
                  content:
                    "<p>When reviewing a serverless application (defined in a template like `serverless.yml` or AWS SAM), the two most important things to review are the function's code and its permissions.</p><ol><li><strong>Review the Function Code:</strong> The code itself should be reviewed for vulnerabilities just like any other application (e.g., for injection flaws, insecure dependencies).</li><li><strong>Review the IAM Role:</strong> This is the most critical part. Scrutinize the IAM role defined for the function in the IaC template. Does it follow the principle of least privilege? If the function only needs to read from one DynamoDB table, its role should only grant it the `dynamodb:GetItem` permission on that specific table's ARN. Any overly broad permission (like `dynamodb:*` or a resource of `*`) is a critical finding.</li></ol>",
                  image:
                    "https://images.unsplash.com/photo-1555949963-ff9808202534?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab 15: Cloud Security Code Review Workshop",
                  language: "hcl",
                  code: '// VULNERABLE TERRAFORM CODE TO REVIEW\n\nresource "aws_security_group" "bad_sg" {\n  name = "allow-all-access"\n\n  // ANTI-PATTERN: This allows SSH access from the entire internet.\n  ingress {\n    from_port   = 22\n    to_port     = 22\n    protocol    = "tcp"\n    cidr_blocks = ["0.0.0.0/0"]\n  }\n}\n\n// VULNERABLE TERRAFORM IAM POLICY\nresource "aws_iam_role_policy" "bad_policy" {\n  name = "s3-full-access-policy"\n  role = aws_iam_role.my_role.id\n\n  policy = jsonencode({\n    Statement = [\n      {\n        Action = "s3:*", // ANTI-PATTERN: Overly broad wildcard permissions\n        Effect = "Allow",\n        Resource = "*" // ANTI-PATTERN: Applies to ALL S3 buckets\n      }\n    ]\n  })\n}',
                },
                {
                  title:
                    "Code Example 15: Cloud Security Configuration Analyzer",
                  language: "dockerfile",
                  code: '# VULNERABLE DOCKERFILE TO REVIEW\n\nFROM ubuntu:latest\n\n# ANTI-PATTERN: Runs as root by default.\n# ANTI-PATTERN: Copies a file with secrets into the image.\nCOPY secrets.env /app/secrets.env\n\nRUN apt-get update && apt-get install -y nodejs\n\nCOPY . /app\nWORKDIR /app\n\nCMD ["node", "server.js"]\n\n# SECURE DOCKERFILE\n\nFROM node:18-alpine AS builder\n# ... build steps ...\n\nFROM gcr.io/distroless/nodejs18-debian11\n\n# FIX: Use a non-root user\nUSER nonroot:nonroot\n\nWORKDIR /app\nCOPY --from=builder /app/dist .\n\n# Secrets are NOT copied in. They will be injected at runtime from a vault.\n\nCMD ["server.js"]',
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    'When reviewing a Terraform file, you see a security group with an ingress rule allowing traffic from `cidr_blocks = ["0.0.0.0/0"]` on port 22. This is a critical misconfiguration because:',
                  options: [
                    "It is the most secure configuration.",
                    "It exposes the SSH port of the server to the entire internet, making it a target for brute-force attacks.",
                    "It blocks all traffic to the server.",
                    "It only allows traffic from a specific IP address.",
                  ],
                  correct: 1,
                  explanation:
                    "A CIDR block of `0.0.0.0/0` means 'any IP address on the internet'. Exposing a management port like SSH or RDP to the entire world is a major security risk that should be flagged in any code review.",
                },
                {
                  id: 2,
                  question:
                    "When reviewing a Dockerfile, what is the most important security best practice regarding the user?",
                  options: [
                    "Always run the application as the `root` user.",
                    "Use the `USER` instruction to switch to a dedicated, non-root user before running the application.",
                    "The user does not matter for security.",
                    "Create a new user named 'admin'.",
                  ],
                  correct: 1,
                  explanation:
                    "Running as a non-root user is a critical defense-in-depth measure. It ensures that if an attacker compromises the application, their privileges within the container are limited, making it much harder for them to escalate their attack.",
                },
                {
                  id: 3,
                  question:
                    "When reviewing the IAM role for a serverless function, what is the most important thing to assess?",
                  options: [
                    "That the role has full administrator privileges (`*:*`) to avoid permission errors.",
                    "That the role strictly follows the principle of least privilege, granting only the specific permissions needed for the function to do its job.",
                    "The name of the role.",
                    "That the role is shared by as many functions as possible.",
                  ],
                  correct: 1,
                  explanation:
                    "The IAM role is the security perimeter for a serverless function. A reviewer must scrutinize this policy to ensure it is not overly permissive, as this is the most common and dangerous serverless vulnerability.",
                },
                {
                  id: 4,
                  question:
                    "The process of reviewing Infrastructure as Code (IaC) is a form of:",
                  options: [
                    "'Shift Left' security, allowing you to find cloud misconfigurations before they are ever deployed.",
                    "'Shift Right' security, where you only find issues in production.",
                    "Runtime security.",
                    "Network security.",
                  ],
                  correct: 0,
                  explanation:
                    "Reviewing IaC is a classic 'shift-left' activity. It transforms cloud configuration security from a reactive, detective process (finding a public S3 bucket in production) into a proactive, preventative process (blocking the code that would create a public S3 bucket).",
                },
              ],
            },
          },

          {
            id: "lesson-16",
            title: "Third-Party Component Security Review",
            duration: "90 min",
            objectives: [
              "Understand the security risks inherited from open-source and third-party dependencies.",
              "Learn to analyze and interpret the results of Software Composition Analysis (SCA) tools.",
              "Review code for safe and secure dependency management practices.",
              "Assess the risk of software supply chain attacks within a codebase.",
            ],
            content: {
              overview:
                "Modern applications are heavily composed of third-party libraries. As a code reviewer, you are not just reviewing the code your team wrote, but also implicitly accepting the risk of all the dependencies it includes. This lesson focuses on how to review the use of third-party components and analyze the output of SCA tools.",
              sections: [
                {
                  title: "Open Source Component Vulnerability Analysis",
                  content:
                    "<p>Your primary tool for this is a Software Composition Analysis (SCA) scanner. The CI/CD pipeline should run an SCA scan on every pull request and post the results for you to review.</p><h3>Your Role as a Reviewer:</h3><ul><li><strong>Validate New Dependencies:</strong> If a developer is adding a new third-party library, you should perform due diligence. Is it a well-known, maintained library, or an obscure, single-author package?</li><li><strong>Triage SCA Findings:</strong> Review the vulnerabilities flagged by the SCA tool. Your job is to assess the *contextual risk*. A critical vulnerability in a library used for development testing is less urgent than a high vulnerability in a library that processes production user input.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1556075798-4825dfaaf498?w=800&h=400&fit-crop",
                },
                {
                  title: "Dependency Security Assessment",
                  content:
                    "<p>Look for insecure dependency management patterns in the code and configuration.</p><h3>What to Look For:</h3><ul><li><strong>Missing Lock Files:</strong> A pull request should include a package lock file (e.g., `package-lock.json`, `Pipfile.lock`). The absence of a lock file is a red flag, as it can lead to non-deterministic builds and the accidental introduction of vulnerable dependencies.</li><li><strong>Unpinned Versions:</strong> Look for package manager files that specify a version range (e.g., `library: ^1.2.3`) instead of a specific, pinned version. This can be risky as it might automatically pull in a new, potentially malicious, version of a dependency.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1542382257-80deda0e5d99?w=800&h=400&fit-crop",
                },
                {
                  title: "Supply Chain Security Review",
                  content:
                    "<p>Review the build and pipeline configuration for supply chain risks.</p><h3>What to Look For:</h3><ul><li><strong>Build Script Integrity:</strong> Review scripts that download dependencies (e.g., a `curl | bash` pattern). Are they downloading from a trusted source? Is the integrity of the downloaded file being checked with a hash?</li><li><strong>Internal Package Confusion:</strong> If your organization uses internal packages, check that the package manager is configured to look for them in your private repository *first*, to prevent dependency confusion attacks.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab 16: Component Security Analysis Lab",
                  language: "json",
                  code: '// VULNERABLE DEPENDENCY in package.json\n\n{\n  "dependencies": {\n    // ANTI-PATTERN: Using a wildcard can pull in any future version,\n    // including potentially malicious or unstable ones.\n    "left-pad": "*"\n  }\n}\n\n// SECURE DEPENDENCY in package.json and package-lock.json\n\n// package.json\n{\n  "dependencies": {\n    // FIX: Specify a specific version.\n    "left-pad": "1.3.0"\n  }\n}\n\n// package-lock.json (generated)\n// This file locks the exact version and its transitive dependencies, ensuring a repeatable build.',
                },
                {
                  title:
                    "Code Example 16: Third-Party Security Assessment Tool",
                  language: "markdown",
                  code: "# Code Review Finding: Vulnerable Third-Party Component\n\n**File:** `pom.xml`\n\n**SCA Tool Finding:**\n- **Component:** `org.apache.logging.log4j:log4j-core:2.14.1`\n- **Vulnerability:** CVE-2021-44228 (Log4Shell)\n- **Severity:** CRITICAL\n\n**Analysis:**\n- The application is using a version of Log4j that is vulnerable to a critical Remote Code Execution (RCE) vulnerability.\n- This is a direct, not transitive, dependency.\n\n**Recommendation:**\nThe pull request cannot be merged until this dependency is upgraded to a patched version (e.g., `2.17.1` or later). Please use the automated pull request created by our SCA tool to apply the fix.",
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "The primary tool used to automatically find known vulnerabilities in an application's open-source dependencies is a:",
                  options: ["SAST Tool", "DAST Tool", "SCA Tool", "Firewall"],
                  correct: 2,
                  explanation:
                    "Software Composition Analysis (SCA) tools are specifically designed to analyze the 'composition' of your software—its third-party components—and check them against a database of known vulnerabilities.",
                },
                {
                  id: 2,
                  question:
                    "What is the primary security benefit of using a package lock file (e.g., `package-lock.json`)?",
                  options: [
                    "It makes the application run faster.",
                    "It ensures a deterministic build by locking the exact version of every direct and transitive dependency, preventing unexpected and potentially malicious updates.",
                    "It encrypts the source code.",
                    "It is not a security control.",
                  ],
                  correct: 1,
                  explanation:
                    "Lock files are a critical supply chain security control. They prevent attacks like dependency confusion and ensure that the build is repeatable and predictable.",
                },
                {
                  id: 3,
                  question:
                    "As a reviewer, you see a shell script in a pull request that contains the line `curl http://example.com/install.sh | bash`. This is a major red flag for what reason?",
                  options: [
                    "It is very performant.",
                    "This is a secure and trusted way to install software.",
                    "This is a supply chain risk. The script is being downloaded from an unencrypted URL and executed without any integrity check, meaning an attacker could easily inject malicious code.",
                    "It will not work on most systems.",
                  ],
                  correct: 2,
                  explanation:
                    "This 'curl-to-bash' pattern is a significant security anti-pattern. The downloaded script should be saved, its integrity should be verified with a checksum (hash), and it should be manually reviewed before being executed.",
                },
                {
                  id: 4,
                  question:
                    "When an SCA tool reports a critical vulnerability in a dependency, what is the reviewer's first step?",
                  options: [
                    "To immediately approve the pull request.",
                    "To ignore the finding.",
                    "To validate the finding and assess its contextual risk to the application.",
                    "To blame the developer for using open-source software.",
                  ],
                  correct: 2,
                  explanation:
                    "The reviewer's job is to add context. Not every vulnerability is equally risky. They must assess the finding to see if it's a true positive and how it impacts their specific application to determine the correct priority for a fix.",
                },
              ],
            },
          },
          {
            id: "lesson-17",
            title: "Language-Specific Security Patterns",
            duration: "120 min",
            objectives: [
              "Learn to review Java code for common vulnerabilities like deserialization and XXE.",
              "Identify common security pitfalls in Python and JavaScript/Node.js.",
              "Analyze C/C++ code for memory safety issues.",
              "Recognize the security benefits of modern languages like Go and Rust.",
            ],
            content: {
              overview:
                "This lesson provides a code reviewer's guide to the specific security patterns and anti-patterns found in popular programming languages. We will build on the concepts from the secure development lesson, focusing on what a reviewer should hunt for in Java, C/C++, Python, and JavaScript code, and why languages like Rust are inherently safer.",
              sections: [
                {
                  title: "Java Security Code Review Patterns",
                  content:
                    "<h3>What to Look For:</h3><ul><li><strong>Deserialization of Untrusted Data:</strong> Search for any use of `ObjectInputStream.readObject()`. If the data being read comes from an untrusted source, this is a potential remote code execution vulnerability.</li><li><strong>XML External Entity (XXE):</strong> Search for any code that parses XML (`DocumentBuilderFactory`). Review its configuration to ensure that external entity processing is explicitly disabled to prevent XXE attacks.</li><li><strong>Secure ORM Usage:</strong> If the code uses a raw SQL function from an ORM (like JPA's `createNativeQuery`), review it with the same scrutiny as any other SQL query for injection flaws.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1517694712202-14dd9538aa97?w=800&h=400&fit=crop",
                },
                {
                  title: "Python Security Best Practice Review",
                  content:
                    "<h3>What to Look For:</h3><ul><li><strong>Use of `pickle`:</strong> Search for `pickle.load()` or `pickle.loads()`. As a reviewer, you should almost always flag this as a critical vulnerability if the data is from an untrusted source.</li><li><strong>Command Injection:</strong> Search for `os.system()` or `subprocess.run()` with `shell=True`. Flag any instances where user-controlled data is part of the command string.</li><li><strong>Template Injection:</strong> If the application uses a web template engine like Jinja2, look for cases where user input is used to construct the template itself, rather than being passed in as data.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit-crop",
                },
                {
                  title: "JavaScript/Node.js Security Assessment",
                  content:
                    "<h3>What to Look For:</h3><ul><li><strong>Prototype Pollution:</strong> A complex vulnerability where an attacker modifies the `__proto__` property of a JavaScript object, which can lead to application-wide logic changes and often remote code execution. Review code that recursively merges objects for this flaw.</li><li><strong>Insecure Regular Expressions (ReDoS):</strong> Look for complex regular expressions that are run against user input. A poorly written regex can have exponential complexity, allowing an attacker to cause a denial of service with a short, specially crafted string.</li><li><strong>Command Injection:</strong> Look for the use of `child_process.exec()`, which is similar to Python's `os.system`.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1587620962725-abab7fe55159?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab 17: Multi-Language Security Review",
                  language: "javascript",
                  code: "// VULNERABLE NODE.JS CODE TO REVIEW (Command Injection)\n\nconst { exec } = require('child_process');\n\napp.get('/api/dns-lookup', (req, res) => {\n    const domain = req.query.domain;\n\n    // ANTI-PATTERN: The 'exec' function invokes a shell.\n    // An attacker can set domain to '; ls -la' to execute their own commands.\n    exec(`nslookup ${domain}`, (err, stdout, stderr) => {\n        res.send(stdout);\n    });\n});\n\n// SECURE CODE\n\nconst { execFile } = require('child_process');\n\napp.get('/api/secure-dns-lookup', (req, res) => {\n    const domain = req.query.domain;\n\n    // FIX: The 'execFile' function does not invoke a shell.\n    // The user input is passed as a safe, separate argument.\n    execFile('nslookup', [domain], (err, stdout, stderr) => {\n        res.send(stdout);\n    });\n});",
                },
                {
                  title:
                    "Code Example 17: Language-Specific Security Pattern Detector",
                  language: "markdown",
                  code: "# Code Review Finding: Insecure Deserialization in Java\n\n**File:** `DataProcessor.java`, line 35\n\n**Vulnerable Code:**\n`ObjectInputStream ois = new ObjectInputStream(networkSocket.getInputStream());`\n`MyObject obj = (MyObject) ois.readObject();`\n\n**Analysis:**\n- The code is using Java's native serialization to read an object directly from an untrusted network socket.\n- An attacker can send a specially crafted byte stream that, when deserialized, can trigger a chain of gadgets in the application's classpath, leading to Remote Code Execution.\n- **CWE:** CWE-502: Deserialization of Untrusted Data.\n\n**Recommendation:**\nDo not use Java native serialization for untrusted data. Refactor the code to use a safe, data-only format like JSON or Protocol Buffers.",
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "When reviewing Java code, the use of `ObjectInputStream.readObject()` on data from an untrusted source is a major red flag for what vulnerability?",
                  options: [
                    "SQL Injection",
                    "Insecure Deserialization",
                    "Cross-Site Scripting",
                    "Buffer Overflow",
                  ],
                  correct: 1,
                  explanation:
                    "Java deserialization is notoriously dangerous. Deserializing a malicious payload can lead to remote code execution and is a critical vulnerability that a reviewer must always look for.",
                },
                {
                  id: 2,
                  question:
                    "When reviewing C/C++ code, the reviewer's primary focus should be on:",
                  options: [
                    "Code style and formatting.",
                    "Memory safety issues, such as buffer overflows and use-after-free vulnerabilities.",
                    "The number of comments.",
                    "The speed of the algorithm.",
                  ],
                  correct: 1,
                  explanation:
                    "Because C/C++ are not memory-safe languages, the burden of preventing memory corruption falls entirely on the developer. These are the most common and most critical vulnerabilities in C/C++ codebases.",
                },
                {
                  id: 3,
                  question:
                    "In a Node.js application, which function is dangerous because it invokes a shell and can be vulnerable to command injection?",
                  options: [
                    "`child_process.exec()`",
                    "`child_process.execFile()`",
                    "`fs.readFile()`",
                    "`http.createServer()`",
                  ],
                  correct: 0,
                  explanation:
                    "`exec` spawns a shell to run the command, which means it will interpret shell metacharacters. `execFile` does not use a shell and is the safer alternative when user input is involved.",
                },
                {
                  id: 4,
                  question:
                    "An attacker crafts a very complex regular expression and submits it to a search form, causing the server's CPU to spike to 100% and become unresponsive. This is known as:",
                  options: [
                    "Prototype Pollution",
                    "A memory leak",
                    "Regular Expression Denial of Service (ReDoS)",
                    "XML External Entity (XXE)",
                  ],
                  correct: 2,
                  explanation:
                    "ReDoS is a specific type of algorithmic complexity attack. A poorly written regex can have exponential runtime, and a reviewer should scrutinize any complex regex that processes untrusted input.",
                },
              ],
            },
          },
          {
            id: "lesson-18",
            title: "Automated Code Review Integration",
            duration: "90 min",
            objectives: [
              "Understand how to integrate SAST tools into the CI/CD pipeline and pull request workflow.",
              "Learn to configure and use pre-commit hooks to find issues before they are committed.",
              "Explore the benefits of using IDE security plugins for real-time feedback.",
              "Design a workflow that combines automated findings with manual review.",
            ],
            content: {
              overview:
                "A purely manual code review process cannot scale in a modern DevOps environment. The key to effective and efficient code review is to augment the human reviewer with a suite of integrated, automated tools. This lesson covers the practical aspects of integrating these tools into the developer's daily workflow.",
              sections: [
                {
                  title: "CI/CD Pipeline Integration Strategies",
                  content:
                    "<p>The pull request (or merge request) is the central point for code review. This is where automated tools should provide their feedback.</p><h3>The PR-centric Workflow:</h3><ol><li>A developer pushes code and opens a pull request.</li><li>The CI/CD pipeline triggers automatically.</li><li>The pipeline runs the SAST and SCA scans.</li><li>The scanning tool uses an API to post its findings as a comment directly on the pull request.</li><li>The pipeline can also act as a 'quality gate', blocking the merge if critical vulnerabilities are found.</li></ol><p>This provides a single, unified view where the developer and the human reviewer can see the code, the functional test results, and the security scan results all in one place.</p>",
                  image:
                    "https://images.unsplash.com/photo-1542382257-80deda0e5d99?w=800&h=400&fit=crop",
                },
                {
                  title: "Pre-Commit Hook Implementation",
                  content:
                    "<p>A pre-commit hook is the earliest possible point to run an automated check. It is a script that runs on the developer's local machine before a commit is finalized.</p><h3>What it's Good For:</h3><p>Pre-commit hooks must be extremely fast (a few seconds at most). They are perfect for catching high-confidence, easy-to-fix issues.</p><ul><li><strong>Secret Scanning:</strong> This is the #1 use case. A tool like `gitleaks` can quickly scan the staged changes for anything that looks like a hard-coded secret and block the commit if one is found.</li><li><strong>Linting:</strong> Running a fast code linter.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit-crop",
                },
                {
                  title: "IDE Plugin Configuration and Usage",
                  content:
                    "<p>IDE plugins provide the fastest feedback loop of all, giving the developer real-time security analysis as they type.</p><p>As a review team or a security champion, you should standardize on a specific IDE plugin (like SonarLint) and create a shared, central configuration file for it. This ensures that every developer on the team is using the same set of security rules and getting consistent feedback directly in their editor.</p>",
                  image:
                    "https://images.unsplash.com/photo-1587620962725-abab7fe55159?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab 18: Automated Review Pipeline Setup",
                  language: "yaml",
                  code: "# Example of a GitHub Action that runs a SAST scan and uploads the results\n\nname: SonarCloud Scan\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: SonarCloud Scan\n        uses: SonarSource/sonarcloud-github-action@master\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # Needed to decorate PRs\n          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}\n\n# When this action runs on a pull request, the SonarCloud bot will automatically\n# post a comment on the PR with a summary of the findings.",
                },
                {
                  title: "Code Example 18: Code Review Automation Framework",
                  language: "json",
                  code: '{\n  "source": "SAST-Bot",\n  "pullRequestId": 205,\n  "status": "ACTION_REQUIRED",\n  "commentBody": "### Security Scan Results\\n\\n| Severity | New Findings |\\n|---|---:|\\n| CRITICAL | 1 |\\n| HIGH     | 3 |\\n\\n**Blocking Finding:** A new Critical **SQL Injection** vulnerability was found in `UserRepo.java`.\\n\\n[Click here for full report]"\n}',
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the best way to present the findings of an automated SAST scan to a developer and reviewer?",
                  options: [
                    "Emailing a PDF report to them a week after the review.",
                    "Automatically posting the findings as a comment on the pull request.",
                    "Only showing the findings in a separate security tool.",
                    "Telling them about it in a meeting.",
                  ],
                  correct: 1,
                  explanation:
                    "Integrating the findings directly into the pull request workflow is the core of a modern, automated review process. It provides immediate, contextual feedback in the place where the developer and reviewer are already working.",
                },
                {
                  id: 2,
                  question:
                    "A script that runs on a developer's local machine to scan for hard-coded secrets before a commit is finalized is known as a:",
                  options: [
                    "CI/CD job",
                    "DAST scanner",
                    "Pre-commit hook",
                    "Post-mortem",
                  ],
                  correct: 2,
                  explanation:
                    "A pre-commit hook is the furthest 'left' you can shift an automated check. It's a highly effective way to prevent simple mistakes, especially hard-coded secrets, from ever entering the central code repository.",
                },
                {
                  id: 3,
                  question:
                    "A security tool like SonarLint that provides real-time feedback to a developer as they type is an:",
                  options: [
                    "IDE Plugin",
                    "CI/CD Pipeline",
                    "Operating System",
                    "API Gateway",
                  ],
                  correct: 0,
                  explanation:
                    "IDE plugins provide the fastest possible feedback loop, acting like a security-focused spell checker for code.",
                },
                {
                  id: 4,
                  question:
                    "The combination of automated scanning tools and a manual, human-driven review is known as what type of review?",
                  options: [
                    "A manual review",
                    "An automated review",
                    "A hybrid review",
                    "A functional review",
                  ],
                  correct: 2,
                  explanation:
                    "The hybrid approach is the most effective. The automation finds the common patterns, allowing the human reviewer to focus their expertise on finding complex business logic and design flaws.",
                },
              ],
            },
          },
          {
            id: "lesson-19",
            title: "Code Review Process and Workflow",
            duration: "90 min",
            objectives: [
              "Learn to design an efficient and effective code review process.",
              "Develop and use a standardized review checklist.",
              "Understand strategies for assigning reviewers and managing time.",
              "Foster a positive and collaborative review culture.",
            ],
            content: {
              overview:
                "Technology is only half of the equation for a successful code review program. The human process—how reviews are conducted, tracked, and communicated—is equally important. This lesson covers the practical aspects of designing and managing an effective and efficient security code review workflow.",
              sections: [
                {
                  title: "Review Process Design and Optimization",
                  content:
                    "<p>A well-defined process ensures that reviews are consistent and effective.</p><h3>The Pull Request (PR) Workflow:</h3><ol><li><strong>Author Creates PR:</strong> The developer creates a pull request for their change. The PR should be small and focused on a single logical change.</li><li><strong>Automated Checks Run:</strong> The CI/CD pipeline runs all the automated tests and security scans.</li><li><strong>Reviewer Assignment:</strong> At least one peer reviewer is assigned. For high-risk changes, a security champion should also be assigned.</li><li><strong>Manual Review:</strong> The reviewer(s) analyze the code, using a checklist and the results of the automated scans.</li><li><strong>Feedback and Iteration:</strong> The reviewer leaves constructive comments. The author makes changes and pushes updates to the PR.</li><li><strong>Approval and Merge:</strong> Once all comments are resolved and all checks are passing, the reviewer approves the PR, and it is merged into the main branch.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop",
                },
                {
                  title: "Reviewer Assignment Strategies",
                  content:
                    "<p>Getting the right eyes on the code is crucial.</p><h3>Strategies:</h3><ul><li><strong>Peer Review:</strong> At least one other developer from the same team should review the code for functional correctness and style.</li><li><strong>Security Champion Review:</strong> For changes that touch a security-sensitive area (e.g., authentication, file uploads, cryptography), the team's security champion should be added as a required reviewer.</li><li><strong>Cross-Team Review:</strong> For very large or complex changes, it can be valuable to bring in a reviewer from another team to get a fresh perspective.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1552664730-d307ca884978?w=800&h=400&fit-crop",
                },
                {
                  title: "Documentation Standards and Templates",
                  content:
                    "<p>Clear communication is key. All feedback should be constructive and actionable.</p><h3>The 'Good Comment' Template:</h3><ul><li><strong>Be Specific:</strong> Refer to the exact line of code.</li><li><strong>Explain the 'What':</strong> What is the issue? (e.g., 'This looks like a potential SQL injection vulnerability.')</li><li><strong>Explain the 'Why':</strong> Why is it an issue? (e.g., 'Because the user input is being concatenated directly into the query string.')</li><li><strong>Suggest a Solution:</strong> How can it be fixed? (e.g., 'Could we refactor this to use a parameterized query?')</li></ul><p>This format is respectful, educational, and helps the author understand and fix the issue quickly.</p>",
                  image:
                    "https://images.unsplash.com/photo-1454165804606-c3d57bc86b40?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab 19: Review Process Optimization Workshop",
                  language: "markdown",
                  code: "# Pull Request Template for High-Risk Changes\n\n## Description\n\n(A clear description of what this change does)\n\n## Related Ticket\n\n(Link to the Jira ticket)\n\n## Security Checklist\n\nThis change affects a security-sensitive area. Please complete the following checklist:\n\n- [ ] Have you performed a self-review for common OWASP Top 10 vulnerabilities?\n- [ ] Does this change handle user-supplied input? If so, is it being validated and/or encoded?\n- [ ] Does this change affect authentication or authorization logic?\n- [ ] Have you added or updated automated tests for the new functionality?\n\n## Threat Model\n\n(Link to the threat model document for this feature)",
                },
                {
                  title:
                    "Code Example 19: Code Review Workflow Management System",
                  language: "yaml",
                  code: "# Example of a GitHub CODEOWNERS file\n# This file automatically assigns reviewers based on the files that were changed.\n\n# All changes require a review from at least one member of the core team.\n*       @my-org/core-team\n\n# Changes to any file in the 'src/auth/' directory MUST be reviewed\n# by the security champions team.\n/src/auth/  @my-org/security-champions\n\n# Changes to the database schema require a review from a DBA.\n/db/migrations/ @my-org/dbas",
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the most important characteristic of the feedback given in a code review?",
                  options: [
                    "It should be vague and confusing.",
                    "It should be constructive, specific, and actionable.",
                    "It should focus on blaming the author.",
                    "It should be delivered in person in a large meeting.",
                  ],
                  correct: 1,
                  explanation:
                    "The goal of a review is to improve the code. Feedback that is not constructive or actionable is just criticism and undermines the collaborative culture needed for an effective review process.",
                },
                {
                  id: 2,
                  question:
                    "A file in a Git repository that automatically assigns required reviewers to a pull request based on which files were changed is often called:",
                  options: [
                    "A README file",
                    "A CODEOWNERS file",
                    "A license file",
                    "A log file",
                  ],
                  correct: 1,
                  explanation:
                    "A `CODEOWNERS` file is a powerful governance feature in platforms like GitHub and GitLab. It allows you to programmatically enforce that the right experts are always included in the review for high-risk parts of the codebase.",
                },
                {
                  id: 3,
                  question: "What is the ideal size for a pull request?",
                  options: [
                    "As large as possible, containing months of work.",
                    "Small and focused on a single logical change.",
                    "It does not matter.",
                    "Exactly 1,000 lines of code.",
                  ],
                  correct: 1,
                  explanation:
                    "Small, focused PRs are much easier and faster for a human to review effectively. Large, sprawling PRs often lead to reviewer fatigue, which is when subtle bugs and security flaws get missed.",
                },
                {
                  id: 4,
                  question:
                    "In a modern DevSecOps workflow, the pull request is the ideal place to conduct a review because:",
                  options: [
                    "It provides a unified view of the code changes, the automated test and scan results, and the human review comments.",
                    "It is a completely manual process.",
                    "It is not integrated with the CI/CD system.",
                    "It is only visible to the author of the code.",
                  ],
                  correct: 0,
                  explanation:
                    "The pull request has become the central collaboration hub for development teams. By integrating all quality and security feedback directly into it, you create a highly efficient and contextual review experience.",
                },
              ],
            },
          },
          {
            id: "lesson-20",
            title: "Security Code Review Metrics",
            duration: "90 min",
            objectives: [
              "Understand the importance of measuring the code review process.",
              "Define and track key metrics for review effectiveness, such as Defect Density.",
              "Measure the efficiency and velocity of the review process.",
              "Use metrics to drive continuous improvement and demonstrate value.",
            ],
            content: {
              overview:
                "To improve a process, you must first be able to measure it. This lesson focuses on the key metrics and Key Performance Indicators (KPIs) that can be used to measure the health, efficiency, and effectiveness of a security code review program. We will explore how to collect this data and use it to drive continuous improvement.",
              sections: [
                {
                  title: "Security Review Effectiveness Metrics",
                  content:
                    "<p>These metrics help to measure the quality and impact of the review process.</p><h3>Key Metrics:</h3><ul><li><strong>Security Defect Density:</strong> The number of security defects found per thousand lines of code (KLOC). A downward trend over time is a strong indicator that developers are writing more secure code.</li><li><strong>Review Coverage:</strong> The percentage of pull requests or commits that have undergone a security review. The goal should be 100% for all code destined for production.</li><li><strong>Vulnerability Escape Rate:</strong> The percentage of vulnerabilities that were missed in the review process and later found in production (e.g., by a penetration test or a security incident). This is the ultimate measure of the review's effectiveness.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop",
                },
                {
                  title: "Review Velocity Optimization",
                  content:
                    "<p>A code review process that is too slow will become a bottleneck and developers will look for ways to bypass it. Measuring and optimizing the velocity of the review process is critical.</p><h3>Key Metrics:</h3><ul><li><strong>Time to First Review:</strong> The time from when a pull request is opened to when the first review comment is made.</li><li><strong>Time to Approve:</strong> The total time from when a pull request is opened to when it is approved and merged.</li></ul><p>If these times are too long, it may indicate that reviewers are overloaded or that PRs are too large.</p>",
                  image:
                    "https://images.unsplash.com/photo-1543286386-713bdd548da4?w=800&h=400&fit=crop",
                },
                {
                  title: "Cost-Benefit Analysis Methodologies",
                  content:
                    "<p>Metrics are essential for demonstrating the value of the code review program to business leadership.</p><p>By tracking the number of critical and high vulnerabilities found and fixed during the code review process, you can make a strong business case. You can use the cost-of-remediation data (from Lesson 1) to say:</p><p>'In the last quarter, our code review process found and fixed 50 critical vulnerabilities. By finding these before they reached production, we estimate that we saved the company over $5 million in potential breach costs and emergency remediation efforts.'</p>",
                  image:
                    "https://images.unsplash.com/photo-1600880292210-859bb1fed5b1?w=800&h=400&fit=crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab 20: Security Review Metrics Dashboard",
                  language: "json",
                  code: '{\n  "team": "checkout-api-team",\n  "timePeriod": "Q3-2025",\n  "effectivenessMetrics": {\n    "securityDefectDensity": 0.8,\n    "reviewCoveragePercent": 100,\n    "vulnerabilityEscapeRatePercent": 2\n  },\n  "velocityMetrics": {\n    "timeToFirstReviewHours": 4.5,\n    "timeToApproveHours": 22.0\n  },\n  "findingsSummary": {\n    "criticalFoundInReview": 5,\n    "highFoundInReview": 12\n  }\n}',
                },
                {
                  title:
                    "Code Example 20: Comprehensive Review Analytics Platform",
                  language: "sql",
                  code: "-- Conceptual SQL query to calculate security defect density\n\nSELECT\n    -- Count the number of high/critical security bugs found\n    (COUNT(CASE WHEN issue_type = 'SECURITY_BUG' AND priority IN ('High', 'Critical') THEN 1 END) \n    /\n    -- Divide by the total lines of code changed (in thousands)\n    (SUM(lines_added) + SUM(lines_deleted))) * 1000 AS security_defect_density\nFROM\n    pull_request_stats\nWHERE\n    merge_date BETWEEN '2025-07-01' AND '2025-09-30';",
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "The number of security bugs found per thousand lines of code is a metric known as:",
                  options: [
                    "Review Coverage",
                    "Security Defect Density",
                    "Time to Approve",
                    "Vulnerability Escape Rate",
                  ],
                  correct: 1,
                  explanation:
                    "Security Defect Density is a key quality metric. A downward trend over time indicates that the team's secure coding practices are improving.",
                },
                {
                  id: 2,
                  question:
                    "The percentage of vulnerabilities that were missed during a code review and later found in production is the:",
                  options: [
                    "Review Coverage",
                    "Security Defect Density",
                    "Time to Approve",
                    "Vulnerability Escape Rate",
                  ],
                  correct: 3,
                  explanation:
                    "The escape rate is the ultimate measure of the review process's effectiveness. A low escape rate means the process is working well at catching flaws before they reach production.",
                },
                {
                  id: 3,
                  question:
                    "Metrics like 'Time to First Review' and 'Time to Approve' are used to measure what aspect of the code review process?",
                  options: [
                    "Effectiveness",
                    "Velocity and Efficiency",
                    "Cost",
                    "Coverage",
                  ],
                  correct: 1,
                  explanation:
                    "These are velocity metrics. They are crucial for ensuring that the code review process is not becoming a bottleneck that slows down development.",
                },
                {
                  id: 4,
                  question:
                    "How do metrics help to justify the value of a security code review program?",
                  options: [
                    "They do not provide any value.",
                    "They allow you to have more meetings.",
                    "They provide a data-driven way to demonstrate how the process is reducing risk and saving the company money by finding flaws early.",
                    "They are only for the developers to see.",
                  ],
                  correct: 2,
                  explanation:
                    "Metrics are the language of business. By translating the activities of the code review process into quantifiable data on risk reduction and cost savings, you can effectively demonstrate its value to leadership.",
                },
              ],
            },
          },
          {
            id: "lesson-21",
            title: "Advanced Analysis Techniques",
            duration: "90 min",
            objectives: [
              "Understand how dynamic (DAST) and interactive (IAST) analysis complement a code review.",
              "Explore the use of machine learning in modern code analysis tools.",
              "Learn how fuzzing can be used to find bugs that are hard to spot in a manual review.",
              "Grasp the concept of hybrid analysis for a more holistic view of security.",
            ],
            content: {
              overview:
                "While a manual review augmented with SAST is the core of the process, a mature security program uses a variety of advanced analysis techniques to find deeper and more complex vulnerabilities. This lesson explores how a code reviewer can leverage the findings from dynamic analysis, IAST, and fuzzing to get a more complete picture of an application's security posture.",
              sections: [
                {
                  title: "Dynamic Analysis (DAST) Integration",
                  content:
                    "<p>DAST is 'black-box' testing. It probes the running application from the outside. As a code reviewer, the findings from a DAST scan are valuable because they are almost always true positives and they find runtime issues that you cannot see in the source code.</p><h3>How it helps a reviewer:</h3><p>If a DAST scan reports a SQL injection vulnerability on a specific API endpoint, you as the reviewer can go directly to the code for that endpoint and know exactly where to look for the missing parameterized query. It provides a highly focused starting point for your manual review.</p>",
                  image:
                    "https://images.unsplash.com/photo-1555949963-aa79dcee981c?w=800&h=400&fit-crop",
                },
                {
                  title: "Hybrid Analysis Approaches",
                  content:
                    "<p>The most effective approach is a hybrid one that combines the strengths of each method.</p><h3>The Hybrid Workflow:</h3><ul><li><strong>SAST:</strong> Scans the source code for common vulnerability patterns and data flows.</li><li><strong>DAST:</strong> Tests the running application for runtime and configuration issues.</li><li><strong>IAST:</strong> Runs in the background during DAST or functional testing, using its internal view to provide highly accurate findings that pinpoint the exact line of code.</li><li><strong>Manual Review:</strong> The human reviewer uses the findings from all these automated tools as context to perform a deeper analysis, looking for the business logic and design flaws that the tools missed.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1573497175235-d3648a07b388?w=800&h=400&fit=crop",
                },
                {
                  title: "Machine Learning in Code Analysis",
                  content:
                    "<p>Modern security tools are increasingly using machine learning to improve their accuracy and capabilities.</p><h3>Use Cases:</h3><ul><li><strong>False Positive Reduction:</strong> An ML model can be trained on a large dataset of past findings to predict whether a new finding is likely to be a true or false positive, helping to automate the triage process.</li><li><strong>Vulnerability Prediction:</strong> An ML model can analyze the history of a codebase to predict which files or components are most likely to contain security defects in the future, allowing reviewers to focus their attention on the highest-risk areas.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1620712943543-285f231f7927?w=800&h=400&fit-crop",
                },
                {
                  title: "Fuzzing Integration with Reviews",
                  content:
                    "<p>Fuzzing is a dynamic testing technique that bombards an application with malformed data to find crashes and bugs. For a code reviewer, fuzzing is a powerful tool for finding memory corruption bugs, unhandled exceptions, and denial-of-service flaws that are very difficult to spot manually.</p><p>The output of a fuzzer is usually a 'crashing input'. The reviewer's job is to take this input, run it in a debugger, and analyze the code to find the root cause of the crash.</p>",
                  image:
                    "https://images.unsplash.com/photo-1588665387928-a_d2a13f8373?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab 21: Advanced Analysis Integration Lab",
                  language: "markdown",
                  code: "# Hybrid Analysis Triage Process\n\n**Scenario:** Reviewing a new feature.\n\n1.  **SAST Finding:** `High` - Potential Stored XSS in `comment` field.\n    - *Reviewer's Note:* The data flow looks suspicious, but I can't be sure if it's exploitable.\n\n2.  **DAST Finding:** `High` - Confirmed Stored XSS by submitting `\\u003cscript\\u003ealert(1)\\u003c/script\\u003e` to the `comment` field.\n    - *Reviewer's Note:* Okay, the DAST scan confirms the finding is a true positive.\n\n3.  **IAST Finding:** `High` - Stored XSS in `CommentController.java` on line 52.\n    - **Data Flow Trace:** Tainted data from HTTP parameter `comment` reached the HTML output sink in `view.jsp` on line 25 without encoding.\n    - *Reviewer's Note:* Perfect. The IAST finding not only confirms the bug but tells me the exact line of code to fix.\n\n**Final Review Comment:**\n> Confirmed Stored XSS vulnerability. Per the IAST report, please add output encoding to the `comment` variable on line 25 of `view.jsp`.",
                },
                {
                  title: "Code Example 21: AI-Powered Code Analysis Framework",
                  language: "json",
                  code: '{\n  "finding": {\n    "cwe": "CWE-79",\n    "file": "Profile.js",\n    "line": 102\n  },\n  "mlTriageService": {\n    "isLikelyFalsePositive": true,\n    "confidence": 0.85,\n    "reasoning": "The data is being rendered within a React component that uses default JSX encoding, which mitigates XSS. This pattern has been marked as a false positive in 98% of similar cases."\n  }\n}',
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "A testing method that combines the code-level visibility of SAST with the runtime context of DAST by using an agent inside the running application is known as:",
                  options: [
                    "Manual Review",
                    "Fuzzing",
                    "IAST (Interactive Application Security Testing)",
                    "SCA",
                  ],
                  correct: 2,
                  explanation:
                    "IAST is a 'gray-box' technique. Its key advantage is that it can provide highly accurate findings that pinpoint the exact line of vulnerable code, making it very valuable for a code reviewer.",
                },
                {
                  id: 2,
                  question: "How do DAST findings help a code reviewer?",
                  options: [
                    "They are usually false positives.",
                    "They find vulnerabilities in the source code directly.",
                    "They confirm that a vulnerability is a real, exploitable true positive and can point the reviewer to the specific part of the application to investigate.",
                    "They replace the need for manual review.",
                  ],
                  correct: 2,
                  explanation:
                    "DAST provides external validation. A DAST finding gives the reviewer a highly confident starting point, allowing them to focus their manual analysis on a known-bad part of the application.",
                },
                {
                  id: 3,
                  question:
                    "Using a machine learning model to analyze the history of a codebase to identify which files are most likely to contain bugs is an example of:",
                  options: [
                    "Vulnerability Prediction",
                    "Fuzzing",
                    "DAST",
                    "SAST",
                  ],
                  correct: 0,
                  explanation:
                    "This is an emerging use case for AI/ML in security. By analyzing historical data, these models can help to focus a code reviewer's limited time on the areas of the code that represent the highest risk.",
                },
                {
                  id: 4,
                  question:
                    "Fuzzing is a particularly effective technique for finding what class of vulnerabilities in C/C++ code?",
                  options: [
                    "SQL Injection",
                    "Memory corruption vulnerabilities like buffer overflows and crashes.",
                    "Cross-Site Scripting",
                    "Broken Access Control",
                  ],
                  correct: 1,
                  explanation:
                    "Fuzzers excel at finding bugs that are triggered by unexpected or malformed input. This makes them extremely effective at uncovering memory safety issues that can be difficult for a human to spot in a complex codebase.",
                },
              ],
            },
          },
          {
            id: "lesson-22",
            title: "Risk Assessment and Prioritization",
            duration: "90 min",
            objectives: [
              "Understand the difference between vulnerability severity and risk.",
              "Learn to use a risk scoring methodology to prioritize findings.",
              "Integrate threat modeling outputs into the review and prioritization process.",
              "Effectively communicate risk to stakeholders.",
            ],
            content: {
              overview:
                "A code review can produce a long list of findings. A critical skill for a reviewer is to be able to prioritize these findings based on their actual risk to the business. This lesson focuses on the process of risk assessment, moving beyond the technical severity of a bug to understand its true, contextual risk.",
              sections: [
                {
                  title: "Vulnerability Risk Scoring Methodologies",
                  content:
                    "<p>Risk is not the same as severity.</p><ul><li><strong>Severity:</strong> An intrinsic property of the vulnerability itself. The CVSS (Common Vulnerability Scoring System) score is a measure of severity.</li><li><strong>Risk:</strong> The severity of the vulnerability *in the specific context of your application*.</li></ul><p>A 'Critical' severity vulnerability in a non-critical, internal-only application may be a 'Medium' risk. A 'High' severity vulnerability in a critical, internet-facing payment processing application is a 'Critical' risk.</p>",
                  image:
                    "https://images.unsplash.com/photo-1600880292210-859bb1fed5b1?w=800&h=400&fit=crop",
                },
                {
                  title: "Business Impact Assessment",
                  content:
                    "<p>To assess risk, you must understand the business context of the code you are reviewing.</p><h3>Questions to Ask:</h3><ul><li><strong>What does this application do?</strong> Is it a marketing website or the core trading platform?</li><li><strong>What data does it handle?</strong> Is it processing public data or sensitive PII and financial data?</li><li><strong>Who uses it?</strong> Is it used by internal employees or external customers?</li><li><strong>What is the impact of a compromise?</strong> Would a breach lead to a minor inconvenience or a massive financial and reputational loss?</li></ul><p>This business context is the most important factor in determining the true impact of a vulnerability.</p>",
                  image:
                    "https://images.unsplash.com/photo-1556740738-b6a63e27c4df?w=800&h=400&fit=crop",
                },
                {
                  title: "Threat Modeling Integration",
                  content:
                    "<p>The threat model for the application provides critical context for a code reviewer.</p><p>By reviewing the threat model, you can understand the key assets, the trust boundaries, and the most likely attack vectors. This allows you to focus your code review efforts on the parts of the application that the design team has already identified as being the highest risk.</p>",
                  image:
                    "https://images.unsplash.com/photo-1543286386-713bdd548da4?w=800&h=400&fit=crop",
                },
                {
                  title: "Exploitability Analysis",
                  content:
                    "<p>This is the 'likelihood' part of the risk equation. As a reviewer, you need to assess how easy it would be for an attacker to find and exploit the weakness.</p><h3>Factors to Consider:</h3><ul><li><strong>Access Vector:</strong> Can the flaw be exploited by an unauthenticated attacker on the internet, or does it require an attacker to already have an authenticated session?</li><li><strong>Complexity:</strong> Is the exploit simple to perform, or does it require deep expertise and a complex chain of actions?</li><li><strong>Threat Intelligence:</strong> Is there a known, public exploit or tool available for this vulnerability?</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1556155092-490a1ba16284?w=800&h=400&fit=crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab 22: Risk Assessment Workshop",
                  language: "markdown",
                  code: "# Risk Assessment of a Code Review Finding\n\n- **Finding:** Stored Cross-Site Scripting (XSS)\n- **Severity (CVSS):** High (e.g., 8.0)\n\n**Contextual Analysis:**\n- **Application:** The company's internal wiki, used by employees.\n- **Business Impact:** Medium. A compromise could lead to session hijacking of employee accounts, but not direct financial loss.\n- **Exploitability:** Medium. An attacker would need to be an authenticated employee to post the malicious content.\n\n**Final Risk Rating:**\n- **Risk:** High (not Critical).\n- **Prioritization:** This should be fixed in the next sprint, but it is not a 'drop everything and fix it now' emergency like an unauthenticated RCE on the e-commerce site would be.",
                },
                {
                  title:
                    "Code Example 22: Intelligent Risk Prioritization Engine",
                  language: "python",
                  code: "def prioritize_finding(finding, asset_context, threat_intel):\n    risk_score = finding['cvss_score']\n\n    if asset_context['is_internet_facing']:\n        risk_score += 1.0\n        \n    if asset_context['handles_pii_data']:\n        risk_score += 1.5\n        \n    if threat_intel.has_public_exploit(finding['cve']):\n        risk_score += 2.0\n\n    return risk_score",
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "The key difference between vulnerability severity and risk is that:",
                  options: [
                    "They are the same thing.",
                    "Severity is a static property of the vulnerability itself, while risk is the severity considered in the specific context of your application.",
                    "Risk is a static property, while severity is contextual.",
                    "Severity is determined by developers, and risk is determined by managers.",
                  ],
                  correct: 1,
                  explanation:
                    "This is a crucial distinction. A reviewer's job is not just to report severity, but to assess and communicate risk, which requires understanding the business context of the code they are reviewing.",
                },
                {
                  id: 2,
                  question:
                    "The CVSS score of a vulnerability is a measure of its:",
                  options: [
                    "Business Impact",
                    "Risk",
                    "Severity",
                    "Cost to fix",
                  ],
                  correct: 2,
                  explanation:
                    "The Common Vulnerability Scoring System (CVSS) is the industry standard for rating the technical severity of a vulnerability based on its intrinsic characteristics. It is an input to, but not the final answer for, a risk assessment.",
                },
                {
                  id: 3,
                  question:
                    "Information about whether a vulnerability has a known, public exploit available for it comes from what source?",
                  options: [
                    "The application's source code.",
                    "Threat Intelligence",
                    "The business impact assessment.",
                    "The user manual.",
                  ],
                  correct: 1,
                  explanation:
                    "Threat intelligence provides external context that is critical for assessing likelihood. A vulnerability with a readily available exploit on GitHub is much more likely to be attacked than a purely theoretical one.",
                },
                {
                  id: 4,
                  question:
                    "What is the primary purpose of assessing the risk of code review findings?",
                  options: [
                    "To create more work for developers.",
                    "To prioritize the limited time of the development team on fixing the most important issues first.",
                    "To blame the developer who wrote the code.",
                    "To generate a longer report.",
                  ],
                  correct: 1,
                  explanation:
                    "Prioritization is everything. A good risk assessment process ensures that engineering effort is always being directed at the vulnerabilities that pose the greatest actual risk to the business.",
                },
              ],
            },
          },
          {
            id: "lesson-23",
            title: "Remediation and Fix Verification",
            duration: "90 min",
            objectives: [
              "Understand the reviewer's role in the remediation process.",
              "Learn to provide clear and actionable guidance for fixing vulnerabilities.",
              "Develop a process for verifying that a fix is correct and complete.",
              "Write security regression tests to prevent vulnerabilities from recurring.",
            ],
            content: {
              overview:
                "Finding a vulnerability is only the first step. The code review process is not complete until a secure fix has been implemented, verified, and merged. This lesson covers the reviewer's role in the final, critical stages of the lifecycle: guiding remediation and ensuring the fix is correct and permanent.",
              sections: [
                {
                  title: "Remediation Strategy Development",
                  content:
                    "<p>A good finding report doesn't just say 'this is broken'; it provides clear, actionable guidance on how to fix it.</p><h3>The Reviewer's Role:</h3><ul><li><strong>Be Prescriptive:</strong> Don't just point out a problem. Suggest the correct, secure pattern to use. For example, instead of saying 'This is SQLi', say 'This is vulnerable to SQLi. Please refactor it to use a parameterized query, like this example from our secure coding guide.'</li><li><strong>Provide Resources:</strong> Include links to internal secure coding standards, external cheat sheets (like from OWASP), or even a working code snippet.</li><li><strong>Be a Partner:</strong> Offer to pair with the developer to help them implement the fix. The goal is to be a teacher and an enabler, not just a critic.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1516321497487-e288fb19713f?w=800&h=400&fit-crop",
                },
                {
                  title: "Fix Verification Methodologies",
                  content:
                    "<p>When a developer submits a fix for a vulnerability, it must be reviewed with the same rigor as the original code. You must verify that the fix is both correct and complete.</p><h3>The Verification Process:</h3><ol><li><strong>Review the Fix:</strong> Analyze the new code. Does it correctly implement the recommended secure pattern?</li><li><strong>Check for Incompleteness:</strong> Did the developer fix this one instance of the bug but miss five other similar instances in other parts of the code?</li><li><strong>Check for New Bugs:</strong> Did the fix accidentally introduce a new functional or security bug?</li><li><strong>Verify with Testing:</strong> The fix must be accompanied by automated tests that prove it works.</li></ol>",
                  image:
                    "https://images.unsplash.com/photo-1542382257-80deda0e5d99?w=800&h=400&fit-crop",
                },
                {
                  title: "Regression Testing for Security Fixes",
                  content:
                    "<p>This is the most critical part of ensuring a fix is permanent. When a vulnerability is fixed, a new **security regression test** must be added to the automated test suite.</p><h3>The Workflow:</h3><ol><li>A vulnerability is found.</li><li>The developer writes a new, failing test that specifically exploits the vulnerability.</li><li>The developer then writes the code fix to make the new test pass.</li><li>This new test is now part of the permanent regression suite.</li></ol><p>This guarantees that if any future code change ever accidentally re-introduces the same vulnerability, the automated regression test will fail, the build will break, and the regression will be caught immediately.</p>",
                  image:
                    "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab 23: Remediation Management Platform",
                  language: "markdown",
                  code: "# Code Review Comment: Fix Verification\n\n**Original Finding:** SQL Injection in `ProductController.java`.\n\n**Developer's Fix:** The developer has submitted a pull request that refactors the vulnerable code to use a parameterized query.\n\n**Reviewer's Verification Comment:**\n> Thanks for the quick fix! The use of a PreparedStatement here is correct and effectively mitigates the SQL injection vulnerability. I've approved the change.\n>\n> **One follow-up action:** Could we also add a new integration test that attempts to pass a SQL injection payload to this endpoint and asserts that it doesn't succeed? That will give us a permanent regression test to ensure this never comes back.",
                },
                {
                  title: "Code Example 23: Fix Verification Automation System",
                  language: "java",
                  code: '// Example of a security regression test for a fixed IDOR vulnerability\n\n@Test\npublic void testGetOrder_cannotAccessAnotherUsersOrder() {\n    // 1. Authenticate as \'userA\'\n    String tokenA = getAuthToken("userA");\n\n    // 2. Try to access an order that belongs to \'userB\'\n    given()\n        .header("Authorization", "Bearer " + tokenA)\n    .when()\n        .get("/api/orders/{orderId}", orderBelongingToUserB)\n    .then()\n        // 3. Assert that the API correctly returns a 403 Forbidden status.\n        // This test will now run on every build, preventing a regression.\n        .statusCode(403);\n}',
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "When you find a vulnerability in a code review, what is the most helpful way to communicate it to the developer?",
                  options: [
                    "By simply saying 'This is insecure.'",
                    "By providing a specific, actionable recommendation with an explanation of the risk and a secure code example.",
                    "By telling their manager they wrote bad code.",
                    "By approving the code and hoping someone else finds it.",
                  ],
                  correct: 1,
                  explanation:
                    "A constructive and educational approach is key. The goal is not just to get the one bug fixed, but to help the developer understand the underlying principle so they don't make the same mistake again.",
                },
                {
                  id: 2,
                  question:
                    "The process of re-reviewing a code change that was intended to fix a vulnerability is known as:",
                  options: [
                    "Remediation",
                    "Fix Verification",
                    "Regression Testing",
                    "Triage",
                  ],
                  correct: 1,
                  explanation:
                    "You must review the fix with the same rigor as the original code. It's important to verify that the fix is correct, complete, and doesn't introduce any new bugs.",
                },
                {
                  id: 3,
                  question:
                    "What is the primary purpose of writing a security regression test after fixing a vulnerability?",
                  options: [
                    "To make the build process slower.",
                    "To prove that the vulnerability existed.",
                    "To create a permanent, automated safety net that will immediately detect if the same vulnerability is ever accidentally re-introduced.",
                    "It has no purpose.",
                  ],
                  correct: 2,
                  explanation:
                    "This is the core of the 'lessons learned' feedback loop. It encodes the knowledge of the vulnerability into an automated test, ensuring the mistake is never repeated without being caught.",
                },
                {
                  id: 4,
                  question:
                    "A developer fixes a SQL injection vulnerability in the user search page, but the reviewer notices that the same vulnerable code pattern exists in the product search page. This means the fix was not:",
                  options: ["Correct", "Complete", "Reviewed", "Fast"],
                  correct: 1,
                  explanation:
                    "A key part of fix verification is to look for other instances of the same flawed pattern. A complete fix addresses the root cause and all instances, not just the single one that was initially reported.",
                },
              ],
            },
          },
          {
            id: "lesson-24",
            title: "Team Structure and Training",
            duration: "90 min",
            objectives: [
              "Understand how to structure a team for a successful security code review program.",
              "Learn to design and implement a Security Champions program.",
              "Develop a curriculum for training developers and reviewers.",
              "Foster a culture of shared ownership for security.",
            ],
            content: {
              overview:
                "A successful security code review program is built on a foundation of skilled people and a collaborative culture. This lesson, previously covered in the DevSecOps course, focuses on the human element: how to structure your teams, train your reviewers, and create a culture where everyone feels responsible for the security of the code.",
              sections: [
                {
                  title: "Security Review Team Organization",
                  content:
                    "<p>A purely centralized model, where a small team of security engineers tries to review all code, does not scale. A successful program uses a federated model.</p><h3>The Federated Model:</h3><ul><li><strong>Central Security Team:</strong> Acts as a center of excellence. They provide the tools, training, and standards. They perform reviews only on the most critical, high-risk changes.</li><li><strong>Security Champions:</strong> Developers and QAs on the product teams who have received extra security training. They perform the majority of the day-to-day security reviews for their own teams.</li><li><strong>All Developers:</strong> All developers are trained in basic security awareness and are expected to look for common flaws during their standard peer reviews.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1552664730-d307ca884978?w=800&h=400&fit-crop",
                },
                {
                  title: "Training Curriculum Design",
                  content:
                    "<p>Training must be role-based and hands-on.</p><h3>The Curriculum:</h3><ul><li><strong>Level 1 (All Developers):</strong> Annual secure coding fundamentals training. How to use the automated tools. How to spot the OWASP Top 10 in a peer review.</li><li><strong>Level 2 (Security Champions):</strong> Advanced, in-depth training on manual review techniques, threat modeling, and specific vulnerability classes.</li><li><strong>Level 3 (Central Security Team):</strong> Expert-level training on penetration testing, reverse engineering, and emerging threats.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1516321497487-e288fb19713f?w=800&h=400&fit-crop",
                },
                {
                  title: "Knowledge Sharing Strategies",
                  content:
                    "<p>Creating a culture of learning is essential.</p><ul><li><strong>Lunch & Learns / Dojos:</strong> Hold regular sessions where the security team or a champion can present on a recent vulnerability or a new secure coding technique.</li><li><strong>Internal Blog/Wiki:</strong> Maintain a central repository of secure coding standards, approved patterns, and lessons learned from past reviews and incidents.</li><li><strong>Gamification:</strong> Use CTF events and bug bounties to make learning about security fun and engaging.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab 24: Team Development Workshop",
                  language: "markdown",
                  code: "# Security Champions Program Charter\n\n**Mission:**\nTo scale security expertise across the engineering organization by creating a network of empowered, trained, and engaged security advocates within each development team.\n\n**Responsibilities of a Champion:**\n- Be the primary security consultant for their team.\n- Perform security-focused code reviews for high-risk changes.\n- Lead threat modeling workshops for new features.\n- Share security knowledge and promote best practices with their peers.\n\n**Support from Central Security Team:**\n- Monthly advanced training sessions.\n- A dedicated Slack channel for direct access to security engineers.\n- Early access to new security tools.\n- Public recognition for their contributions.",
                },
                {
                  title:
                    "Code Example 24: Security Review Training Management System",
                  language: "json",
                  code: '{\n  "developerId": "susan.dev",\n  "isSecurityChampion": true,\n  "trainingCompleted": [\n    {\n      "course": "Secure Coding 101",\n      "date": "2024-03-15"\n    },\n    {\n      "course": "Advanced Web Security Review",\n      "date": "2025-08-22"\n    }\n  ],\n  "reviewsPerformed": 152,\n  "vulnerabilitiesFound": 45\n}',
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "A model where trained developers within product teams perform the majority of security code reviews, supported by a central security team, is known as a:",
                  options: [
                    "Centralized model",
                    "Federated model (using Security Champions)",
                    "Ad-hoc model",
                    "Outsourced model",
                  ],
                  correct: 1,
                  explanation:
                    "The federated or 'hub-and-spoke' model is the only way to effectively scale a security code review program in a large organization. It leverages the Security Champions as a force multiplier for the central team.",
                },
                {
                  id: 2,
                  question:
                    "What is the primary goal of a Security Champions program?",
                  options: [
                    "To create an elite, separate security team.",
                    "To embed and scale security expertise directly within development teams.",
                    "To handle all the HR functions.",
                    "To write all the code for the company.",
                  ],
                  correct: 1,
                  explanation:
                    "The champions program is about empowerment and distribution of knowledge. It makes security a shared, collaborative effort rather than the responsibility of a siloed central team.",
                },
                {
                  id: 3,
                  question:
                    "To be effective, security training for developers should be:",
                  options: [
                    "A single, 8-hour, non-interactive video once a year.",
                    "Purely theoretical with no practical examples.",
                    "Hands-on, continuous, and relevant to their specific technology stack.",
                    "The same for every single employee in the company, from the CEO to the developers.",
                  ],
                  correct: 2,
                  explanation:
                    "Effective training is practical and contextual. Developers learn best by doing, so hands-on labs and training that directly relates to the code they write every day is far more effective than generic awareness training.",
                },
                {
                  id: 4,
                  question:
                    "A key aspect of building a strong security culture is:",
                  options: [
                    "A 'blame culture' where developers are punished for mistakes.",
                    "A collaborative culture where finding a vulnerability is seen as a positive contribution to improving the product.",
                    "A culture where security is seen as someone else's problem.",
                    "A culture where code reviews are seen as a waste of time.",
                  ],
                  correct: 1,
                  explanation:
                    "Culture is paramount. You want to create an environment where developers are rewarded for finding security issues (in their own code or others'), as this demonstrates engagement and a commitment to quality.",
                },
              ],
            },
          },
          {
            id: "lesson-25",
            title: "Tool Selection and Evaluation",
            duration: "90 min",
            objectives: [
              "Understand the criteria for selecting a SAST tool.",
              "Develop a plan for conducting a Proof of Concept (POC) to evaluate tools.",
              "Analyze the trade-offs between commercial and open-source tools.",
              "Learn to measure the Total Cost of Ownership (TCO) of a security tool.",
            ],
            content: {
              overview:
                "Choosing the right automated code analysis tool is a critical strategic decision for a security review program. The market is crowded with many commercial and open-source options, each with its own strengths and weaknesses. This lesson covers a structured, data-driven process for evaluating and selecting the SAST tool that is the best fit for your organization.",
              sections: [
                {
                  title: "SAST Tool Evaluation Criteria",
                  content:
                    "<p>The decision should be based on a comprehensive set of criteria, not just one feature.</p><h3>Key Criteria:</h3><ul><li><strong>Language and Framework Support:</strong> Does the tool have high-quality support for the specific languages and frameworks your organization uses?</li><li><strong>Vulnerability Coverage:</strong> How good is the tool at finding the most common and critical vulnerabilities (e.g., the OWASP Top 10)?</li><li><strong>Accuracy:</strong> What is the tool's false positive and false negative rate?</li><li><strong>Integration:</strong> Does the tool have robust APIs and pre-built integrations for your CI/CD systems, source code repositories, and IDEs? This is critical.</li><li><strong>Speed and Scalability:</strong> How long does a scan take? Can it handle the size of your codebases?</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1556155092-490a1ba16284?w=800&h=400&fit=crop",
                },
                {
                  title: "Proof of Concept (POC) Planning",
                  content:
                    "<p>You should never buy a SAST tool without first conducting a hands-on Proof of Concept (POC). A POC is a trial where you test the top 2-3 shortlisted tools in your own environment on your own code.</p><h3>The POC Process:</h3><ol><li><strong>Define Success Criteria:</strong> Before you start, define a specific, measurable set of success criteria based on your evaluation criteria.</li><li><strong>Select Representative Applications:</strong> Choose a few of your real-world applications to test the tools against.</li><li><strong>Run the Scans:</strong> Install and run each tool on the test applications.</li><li><strong>Triage the Results:</strong> Have your developers and security champions triage the findings from each tool to assess their accuracy.</li><li><strong>Score and Compare:</strong> Score each tool against your pre-defined success criteria to make an objective, data-driven decision.</li></ol>",
                  image:
                    "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit-crop",
                },
                {
                  title: "Total Cost of Ownership (TCO)",
                  content:
                    "<p>The cost of a tool is not just its license fee.</p><h3>TCO includes:</h3><ul><li><strong>License Cost:</strong> The annual fee for the software.</li><li><strong>Infrastructure Cost:</strong> The cost of the servers needed to run the tool (if it's not a SaaS solution).</li><li><strong>Implementation Cost:</strong> The time and effort required to integrate the tool into your pipelines.</li><li><strong>Operational Cost:</strong> The time your team will spend triaging findings, tuning rules, and maintaining the tool. A tool with a high false positive rate might have a low license cost but a very high operational cost.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1600880292210-859bb1fed5b1?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab 25: Tool Evaluation Workshop",
                  language: "markdown",
                  code: "# SAST Tool POC - Scoring Matrix\n\n| Criteria | Weight | Vendor A Score (1-5) | Vendor B Score (1-5) |\n|---|---|---|---|\n| **Java Spring Support** | 20% | 5 | 4 |\n| **SQLi Detection Rate** | 25% | 4 | 5 |\n| **False Positive Rate** | 20% | 3 | 5 |\n| **GitLab Integration** | 15% | 5 | 3 |\n| **Scan Speed** | 10% | 4 | 4 |\n| **Ease of Use** | 10% | 4 | 5 |\n| **Weighted Total** | | **4.05** | **4.45** |\n\n**Conclusion:** Vendor B is the recommended choice due to its significantly lower false positive rate and better detection of our highest-priority vulnerability, even though its GitLab integration is less mature.",
                },
                {
                  title: "Code Example 25: Security Tool Assessment Framework",
                  language: "json",
                  code: '{\n  "tool": "Vendor B SAST",\n  "totalCostOfOwnership": {\n    "annualLicenseFee": 80000,\n    "estimatedAnnualTriageHours": 200,\n    "analystHourlyRate": 75,\n    "annualOperationalCost": 15000, // 200 * 75\n    "totalAnnualTco": 95000\n  },\n  "comparison": {\n    "tool": "Vendor A SAST",\n    "totalAnnualTco": 110000 // Higher operational cost due to more false positives\n  }\n}',
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "What is the most critical phase of a SAST tool selection process?",
                  options: [
                    "Watching the vendor's marketing demo.",
                    "Reading the product brochure.",
                    "Conducting a hands-on Proof of Concept (POC) with your own code in your own environment.",
                    "Negotiating the price with the salesperson.",
                  ],
                  correct: 2,
                  explanation:
                    "A POC is the only way to truly validate a tool's capabilities. A tool that looks great in a demo might have a high false positive rate or poor performance on your specific codebases. You must test it yourself.",
                },
                {
                  id: 2,
                  question:
                    "When evaluating a SAST tool, which of the following is a critical integration requirement for a DevSecOps environment?",
                  options: [
                    "The ability to email PDF reports.",
                    "A beautiful user interface.",
                    "A robust API and pre-built integrations for your CI/CD platform and source code repository.",
                    "A command-line interface that only works on Windows.",
                  ],
                  correct: 2,
                  explanation:
                    "Automation and integration are non-negotiable. If the tool cannot be seamlessly integrated into your pull request workflow, it will become a manual bottleneck and fail to provide the fast feedback that is the core of DevSecOps.",
                },
                {
                  id: 3,
                  question:
                    "The Total Cost of Ownership (TCO) for a security tool includes the license fee and what other major cost?",
                  options: [
                    "The cost of the electricity to run the tool.",
                    "The operational cost, which is the time your team will spend using and maintaining the tool, especially triaging false positives.",
                    "The cost of the vendor's marketing budget.",
                    "There are no other costs.",
                  ],
                  correct: 1,
                  explanation:
                    "The human cost is often the largest part of the TCO. A cheap tool that is very noisy can end up costing more in wasted engineer time than a more expensive tool that is highly accurate.",
                },
                {
                  id: 4,
                  question:
                    "What is the primary purpose of defining success criteria *before* starting a POC?",
                  options: [
                    "To make the process more difficult.",
                    "To ensure the evaluation is objective and data-driven, rather than based on subjective feelings.",
                    "It has no purpose.",
                    "To guarantee that your preferred vendor will win.",
                  ],
                  correct: 1,
                  explanation:
                    "Pre-defined success criteria are essential for a fair and objective evaluation. It ensures that all tools are being measured against the same, pre-agreed-upon yardstick that is based on your organization's specific requirements.",
                },
              ],
            },
          },
          {
            id: "lesson-26",
            title: "Compliance and Regulatory Requirements",
            duration: "90 min",
            objectives: [
              "Understand how a security code review program helps meet compliance requirements.",
              "Learn to map specific regulations (like PCI DSS) to code review practices.",
              "Generate artifacts from the review process that can be used as audit evidence.",
              "Integrate compliance checks into the automated review process.",
            ],
            content: {
              overview:
                "For many organizations, compliance is a major driver for the security program. A mature security code review process is a key technical control for meeting many regulatory requirements and provides a powerful source of evidence for auditors. This lesson covers how the code review process directly supports and proves compliance.",
              sections: [
                {
                  title: "Compliance Requirement Mapping",
                  content:
                    "<p>Many regulations have specific requirements related to secure software development. A code review process is a direct implementation of these requirements.</p><h3>Example: PCI DSS Requirement 6</h3><p>PCI DSS has a whole section (Requirement 6) on 'Develop and Maintain Secure Systems and Applications'. This includes:</p><ul><li>**6.3.1:** Remove development and test accounts before the application becomes active. (Verifiable in code review).</li><li>**6.5:** Address common coding vulnerabilities. (The entire purpose of a security code review).</li><li>**6.3.2:** Review of code prior to release. (The definition of a code review process).</li></ul><p>As a reviewer, understanding these requirements helps you to focus on the controls that auditors will be looking for.</p>",
                  image:
                    "https://images.unsplash.com/photo-1590102426319-c72115b5a832?w=800&h=400&fit-crop",
                },
                {
                  title: "Evidence Collection and Management",
                  content:
                    "<p>The output of your code review process is a valuable source of evidence for auditors.</p><h3>What to Provide to an Auditor:</h3><ul><li><strong>Your Secure SDLC Policy:</strong> A document that states that all code must go through a security review before being deployed.</li><li><strong>The Pull Request:</strong> Show the auditor a pull request in your source code management system. It provides an immutable, time-stamped record showing:<ul><li>The code that was changed.</li><li>The results of the automated SAST/SCA scans.</li><li>The comments from the human reviewer.</li><li>The final approval before the merge.</li></ul></li></ul><p>This provides a much higher level of assurance than a simple checkbox on a spreadsheet.</p>",
                  image:
                    "https://images.unsplash.com/photo-1581291518857-4e27b48ff24e?w=800&h=400&fit-crop",
                },
                {
                  title: "Compliance Testing Integration",
                  content:
                    "<p>You can integrate compliance checks directly into the review process.</p><h3>Compliance as Code:</h3><p>You can write automated tests that check for compliance requirements. For example, you could write a custom SAST rule that flags any use of a weak, non-compliant cryptographic algorithm. If a developer tries to use this algorithm, the automated review in their pull request will fail, preventing the non-compliant code from being merged.</p>",
                  image:
                    "https://images.unsplash.com/photo-1510915228340-29c85a43dcfe?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab 26: Compliance Integration Workshop",
                  language: "markdown",
                  code: "# Audit Evidence Package for PR #123\n\n**Requirement:** PCI DSS 6.3.2 - Review of code prior to release.\n\n**Evidence:**\n1.  **Policy:** Link to `Secure SDLC Policy` wiki page.\n2.  **Process:** Link to `Code Review Process` wiki page.\n3.  **Implementation:** \n    - Link to GitHub Pull Request #123.\n    - (Screenshot of the PR showing the code changes).\n    - (Screenshot of the automated SAST scan check passing).\n    - (Screenshot of the required approval from the Security Champion).",
                },
                {
                  title:
                    "Code Example 26: Compliance Validation Automation Platform",
                  language: "python",
                  code: '# Example of a custom Semgrep rule (Compliance as Code)\n# This rule enforces a policy that the insecure MD5 hashing algorithm should not be used.\n\nrules:\n- id: no-md5-hashing\n  patterns:\n    - pattern-either:\n        - pattern: hashlib.md5(...)\n        - pattern: Crypto.Hash.MD5.new(...)\n  message: "Use of the MD5 hashing algorithm is not compliant with our security standards. Please use a stronger algorithm like SHA-256 for integrity checks or bcrypt for passwords."\n  languages: [python]\n  severity: ERROR',
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "A formal, documented security code review process is a direct technical control for which major compliance standard?",
                  options: [
                    "GDPR",
                    "HIPAA",
                    "PCI DSS",
                    "It is not related to compliance.",
                  ],
                  correct: 2,
                  explanation:
                    "PCI DSS Requirement 6 is explicitly about secure software development and specifically calls for a code review process before code is released into the cardholder data environment.",
                },
                {
                  id: 2,
                  question:
                    "What is the best form of evidence to provide to an auditor to prove that a code review took place?",
                  options: [
                    "A verbal confirmation from the developer.",
                    "A checkbox on a spreadsheet.",
                    "A link to the pull request in the source code management system, showing the automated scan results and the human approval.",
                    "A promise that a review will be done in the future.",
                  ],
                  correct: 2,
                  explanation:
                    "The pull request provides an immutable, time-stamped, and detailed record of the entire review process. It is a very high-fidelity piece of evidence that is far more trustworthy than manual documentation.",
                },
                {
                  id: 3,
                  question:
                    "The practice of writing a custom SAST rule to automatically check for a specific compliance requirement in the CI/CD pipeline is known as:",
                  options: [
                    "Manual Auditing",
                    "Compliance as Code",
                    "Penetration Testing",
                    "Incident Response",
                  ],
                  correct: 1,
                  explanation:
                    "Compliance as Code allows you to transform a human-readable compliance rule into an automated, machine-enforced test, providing continuous assurance that your code remains compliant.",
                },
                {
                  id: 4,
                  question:
                    "How does a security code review process help with GDPR?",
                  options: [
                    "It has no impact on GDPR.",
                    "It helps to enforce principles like 'Privacy by Design' by allowing a reviewer to check if personal data is being handled correctly and if features like data deletion are implemented properly.",
                    "It automatically makes all data anonymous.",
                    "It is only for finding performance bugs.",
                  ],
                  correct: 1,
                  explanation:
                    "During a code review, a reviewer can specifically look for how the code handles personal data, making it a key verification step for ensuring that privacy principles are being correctly implemented.",
                },
              ],
            },
          },
          {
            id: "lesson-27",
            title: "Enterprise Scale Implementation",
            duration: "90 min",
            objectives: [
              "Develop a strategy for rolling out a security code review program across a large enterprise.",
              "Design a governance framework that balances central oversight with team autonomy.",
              "Implement a 'paved road' of tools and processes to drive standardization.",
              "Measure and communicate the success of the program to stakeholders.",
            ],
            content: {
              overview:
                "Scaling a security code review program from a few teams to an entire enterprise requires a strategic approach. You cannot simply mandate a process and expect it to work. This lesson, previously covered in the DevSecOps course, focuses on the governance and enablement strategies needed to successfully implement and scale a security code review program.",
              sections: [
                {
                  title: "Governance Framework Development",
                  content:
                    "<p>A central governance function, often part of a Security Center of Excellence (CoE), is needed to provide oversight and ensure consistency.</p><h3>The CoE's Role:</h3><ul><li><strong>Set the Standard:</strong> Define the mandatory minimum security requirements for all code (the 'security bar').</li><li><strong>Build the Platform:</strong> Provide and manage the central tools (SAST, SCA, etc.).</li><li><strong>Train the People:</strong> Run the Security Champions program and provide training to all developers.</li><li><strong>Measure and Report:</strong> Track the metrics and report on the health and effectiveness of the program to leadership.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1552664730-d307ca884978?w=800&h=400&fit-crop",
                },
                {
                  title: "Standardization and the 'Paved Road'",
                  content:
                    "<p>The 'paved road' is the concept of making the secure way the easy way. The central team provides a well-supported, easy-to-use set of tools and processes.</p><h3>Example:</h3><p>The CoE provides a standard, reusable CI/CD template. Any development team can include this template in their pipeline, and they automatically get the standard SAST, SCA, and other security scans pre-configured. This is much easier for them than building their own security pipeline from scratch.</p>",
                  image:
                    "https://images.unsplash.com/photo-1510915228340-29c85a43dcfe?w=800&h=400&fit-crop",
                },
                {
                  title: "Change Management Strategies",
                  content:
                    "<p>Rolling out a new process across a large organization is a change management challenge.</p><h3>Keys to Success:</h3><ul><li><strong>Start with a Pilot:</strong> Don't try to boil the ocean. Start with a few friendly, motivated pilot teams. Work closely with them to make the process successful.</li><li><strong>Evangelize the Wins:</strong> Turn the pilot teams into evangelists. Use their success stories and positive metrics to show other teams the benefits of the new process.</li><li><strong>Listen to Feedback:</strong> The process will not be perfect at first. Create a feedback loop to listen to the development teams and continuously improve the tools and processes based on their input.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab 27: Enterprise Implementation Planning",
                  language: "markdown",
                  code: "# 12-Month Rollout Plan for Enterprise Security Code Review\n\n**Phase 1 (Months 1-3): Foundation & Pilot**\n- [ ] Establish the Security CoE team.\n- [ ] Select and procure the central SAST and SCA tools.\n- [ ] Select 3 motivated pilot teams.\n- [ ] Work hands-on with pilot teams to integrate scans into their pipelines.\n- [ ] Develop the first version of the security review checklist.\n\n**Phase 2 (Months 4-9): Scale & Evangelize**\n- [ ] Launch the Security Champions program with members from the pilot teams.\n- [ ] Create the reusable CI/CD templates (the 'Paved Road').\n- [ ] Begin onboarding the next 20 teams, using the champions as support.\n- [ ] Develop and publish the metrics dashboard.\n\n**Phase 3 (Months 10-12): Full Rollout & Optimization**\n- [ ] Onboard all remaining development teams.\n- [ ] Use the metrics to identify problem areas and continuously improve the process.",
                },
                {
                  title: "Code Example 27: Enterprise Security Review Platform",
                  language: "yaml",
                  code: "# Example of a reusable GitLab CI template (the 'Paved Road')\n\n# File: .sast-template.yml (in a central repository)\n\nsast_scan_job:\n  image: sast-scanner:latest\n  script:\n    - /usr/bin/run-scan --output report.json\n  artifacts:\n    paths: [report.json]\n\n# --- Developer's pipeline ---\n# File: .gitlab-ci.yml (in the application's repository)\n\ninclude:\n  - project: 'security-coe/cicd-templates'\n    ref: 'v1.2'\n    file: '/.sast-template.yml'\n\n# The developer automatically gets the centrally managed SAST job\n# without needing to know how it's configured.",
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "The concept of a central team providing an easy-to-use, secure set of tools and templates for developers is known as:",
                  options: [
                    "A manual review",
                    "The 'Paved Road'",
                    "An anti-pattern",
                    "A silo",
                  ],
                  correct: 1,
                  explanation:
                    "The 'Paved Road' is a key scaling pattern. It encourages adoption of best practices by making them the path of least resistance for development teams.",
                },
                {
                  id: 2,
                  question:
                    "What is the most effective strategy for rolling out a new security process across a large enterprise?",
                  options: [
                    "Mandating it for all teams on day one with no support.",
                    "Starting with a willing pilot team, making them successful, and then using their success to evangelize.",
                    "Keeping the process a secret.",
                    "Only applying the process to non-critical applications.",
                  ],
                  correct: 1,
                  explanation:
                    "The 'start small and scale' approach is a proven change management strategy. A success story from a peer team is a much more powerful motivator than a mandate from a central authority.",
                },
                {
                  id: 3,
                  question:
                    "A central team that is responsible for governance, standards, and enabling other teams in a scaled DevSecOps program is often called a:",
                  options: [
                    "Center of Excellence (CoE)",
                    "Help Desk",
                    "Network Operations Center",
                    "Development Team",
                  ],
                  correct: 0,
                  explanation:
                    "A CoE is a strategic governance function. Its goal is to provide the central platform and expertise that enables the rest of the organization to operate securely and efficiently at scale.",
                },
                {
                  id: 4,
                  question:
                    "Why is a feedback loop from development teams essential for a successful enterprise rollout?",
                  options: [
                    "It is not needed.",
                    "To allow the central team to continuously improve the tools and processes based on what is actually working for the developers.",
                    "To slow down the process.",
                    "To assign blame when things go wrong.",
                  ],
                  correct: 1,
                  explanation:
                    "A process that is designed in a vacuum will likely fail. The central team must actively listen to its 'customers'—the development teams—to ensure that the security processes are effective and not an unreasonable burden.",
                },
              ],
            },
          },
          {
            id: "lesson-28",
            title: "Legacy Code Security Review",
            duration: "90 min",
            objectives: [
              "Understand the unique challenges and risks of reviewing legacy code.",
              "Develop a risk-based strategy for prioritizing reviews of legacy systems.",
              "Learn to apply 'wrapper-based' security mitigations.",
              "Integrate legacy systems into modern automated analysis tools.",
            ],
            content: {
              overview:
                "Reviewing a modern, well-structured greenfield application is one thing. Reviewing a 15-year-old monolithic legacy codebase is another challenge entirely. This lesson focuses on pragmatic strategies for a reviewer to tackle the security of legacy code, focusing on risk reduction and incremental improvement rather than perfect security.",
              sections: [
                {
                  title: "Legacy Code Assessment Strategies",
                  content:
                    "<p>You cannot review everything in a million-line monolith. You must prioritize based on risk.</p><h3>The Strategy:</h3><ol><li><strong>Start from the Outside In:</strong> Begin by using 'black-box' and 'gray-box' tools. Run a DAST scanner against the running application and enable an IAST agent. These tools will find the real, exploitable vulnerabilities and point you to the highest-risk parts of the code.</li><li><strong>Analyze Dependencies:</strong> Run an SCA scan. Legacy applications are often a graveyard of ancient, highly vulnerable libraries, and fixing these can be a quick and high-impact win.</li><li><strong>Focus on the Attack Surface:</strong> Once you have the automated findings, use them to guide your manual review. Focus your time on the parts of the code that handle user input and are directly related to the vulnerabilities the scanners found.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1555099962-4199c345e546?w=800&h=400&fit-crop",
                },
                {
                  title: "Risk-Based Remediation Planning",
                  content:
                    "<p>For legacy code, a full fix might be too risky or expensive. The reviewer's job is often to recommend compensating controls.</p><h3>The Hierarchy of Fixes:</h3><ol><li><strong>The Ideal Fix:</strong> Fix the root cause in the code (e.g., refactor to use parameterized queries). This is the best option, but may not be feasible.</li><li><strong>The Good Fix (Wrapping):</strong> If the code can't be changed, 'wrap' it in an external control. For example, if you find a SQL injection, but the code is too fragile to change, the recommendation would be to create a highly specific 'virtual patch' in the WAF to block that specific attack pattern.</li><li><strong>The Last Resort (Risk Acceptance):</strong> If the risk is low and the cost of fixing it is very high, the final option is to formally document the risk and have the business owner accept it.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1600880292210-859bb1fed5b1?w=800&h=400&fit-crop",
                },
                {
                  title: "Technical Debt Integration",
                  content:
                    "<p>Security vulnerabilities in legacy code are a form of technical debt. They are problems that were deferred in the past and are now incurring 'interest' in the form of risk.</p><p>As a reviewer, your findings should be integrated into the team's technical debt backlog. This allows the product owner to make a data-driven decision, prioritizing the security fix against new features based on its risk and the cost of fixing it.</p>",
                  image:
                    "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab 28: Legacy Code Security Assessment",
                  language: "markdown",
                  code: "# Legacy App Review - Executive Summary\n\n**Application:** `OldBillingSystem`\n\n**Findings:**\n- **DAST:** Found 3 Critical SQL Injection vulnerabilities.\n- **SCA:** The application is using a version of Struts from 2010 with 15 known RCE vulnerabilities.\n\n**Business Risk:** CRITICAL. The application processes sensitive financial data and is highly vulnerable to a full compromise.\n\n**Recommendations:**\n1.  **Immediate (Containment):** Place the application behind a WAF with strict virtual patching rules for Struts and SQLi. This is a temporary 'wrapper'.\n2.  **Short-Term (Incremental Fix):** Dedicate one sprint to upgrading the Struts library. This is a high-effort but essential fix.\n3.  **Long-Term (Strategic):** This application should be prioritized for decommissioning and replacement within the next 18 months.",
                },
                {
                  title: "Code Example 28: Legacy Security Analysis Framework",
                  language: "plaintext",
                  code: "/*\n  Reviewer's Thought Process for a Legacy App\n\n  1.  I don't have time to read 2 million lines of code.\n  2.  First, I'll run an SCA scan. That's the easiest, highest-value first step.\n      - Result: It's using a 12-year-old logging library with a known RCE. That's my first finding.\n  3.  Next, I'll run a DAST scan against the live test environment.\n      - Result: It found a SQL Injection in the search page. Now I know exactly which part of the code to look at.\n  4.  Now, I'll do a manual review, but ONLY on the `SearchController.java` file that the DAST scan pointed me to.\n      - I confirm the string concatenation and document the finding.\n  5.  I will recommend two fixes: a short-term WAF rule, and a longer-term task for the dev team to refactor that specific controller.\n\n  This risk-based, tool-driven approach allows me to effectively review a legacy app in a few hours instead of a few weeks.\n*/",
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "When starting a review of a large, unfamiliar legacy codebase, what is the most efficient first step?",
                  options: [
                    "Reading every single line of code from the beginning.",
                    "Running automated DAST and SCA tools to find the most obvious and exploitable vulnerabilities first.",
                    "Assuming the code is secure.",
                    "Immediately recommending a full rewrite.",
                  ],
                  correct: 1,
                  explanation:
                    "The 'outside-in' approach is most effective for legacy code. The automated tools act as a reconnaissance phase, helping you to find the highest-risk areas of the code where you should then focus your manual review efforts.",
                },
                {
                  id: 2,
                  question:
                    "A WAF rule that is specifically crafted to block an exploit for a known vulnerability in a legacy application that cannot be patched is known as a:",
                  options: [
                    "A permanent fix",
                    "A virtual patch",
                    "A firewall",
                    "A false positive",
                  ],
                  correct: 1,
                  explanation:
                    "Virtual patching is a key 'wrapper' technique. It uses an external control (the WAF) to provide a compensating control for a vulnerability that cannot be fixed directly in the code, reducing the immediate risk.",
                },
                {
                  id: 3,
                  question:
                    "Security vulnerabilities in legacy code can be thought of as a form of:",
                  options: [
                    "A new feature",
                    "Technical Debt",
                    "A good thing",
                    "A completed project",
                  ],
                  correct: 1,
                  explanation:
                    "Security debt is a type of technical debt. It represents the implied cost of rework caused by choosing an easy (insecure) solution now instead of using a better approach that would take longer. Review findings should be managed as part of the tech debt backlog.",
                },
                {
                  id: 4,
                  question: "The 'Strangler Fig' pattern is a strategy for:",
                  options: [
                    "Keeping a legacy application running forever.",
                    "Gradually modernizing a monolith by replacing its functionality piece by piece with new microservices.",
                    "Performing a security code review.",
                    "Finding vulnerabilities.",
                  ],
                  correct: 1,
                  explanation:
                    "This is a popular and pragmatic approach to modernization. It allows an organization to incrementally reduce the risk and footprint of a legacy system without the high risk of a 'big bang' rewrite.",
                },
              ],
            },
          },
          {
            id: "lesson-29",
            title: "Continuous Security Improvement",
            duration: "90 min",
            objectives: [
              "Understand the importance of a feedback loop in a security review program.",
              "Learn to use the results of reviews to improve security standards and patterns.",
              "Develop a process for updating and optimizing automated tool rulesets.",
              "Foster a culture of continuous learning and adaptation.",
            ],
            content: {
              overview:
                "A security code review program is not a 'set it and forget it' activity. It is a living process that must be continuously measured, adapted, and improved. This lesson focuses on creating the critical feedback loops that allow you to learn from your findings and consistently raise the security bar for your entire organization.",
              sections: [
                {
                  title: "Feedback Loop Implementation",
                  content:
                    "<p>Every output of the review process should be used as an input to improve the process itself.</p><h3>The Virtuous Cycle:</h3><ol><li>A review (manual or automated) finds a vulnerability.</li><li>The vulnerability is remediated and a regression test is added.</li><li>A root cause analysis is performed: **Why did this bug happen in the first place?**</li><li>The answer to that question drives an improvement to an earlier stage of the lifecycle.</li></ol>",
                  image:
                    "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit-crop",
                },
                {
                  title: "Process Optimization Strategies",
                  content:
                    "<h3>Example Feedback Loop:</h3><ul><li><strong>Finding:</strong> A reviewer finds a critical SQL injection vulnerability in a new microservice.</li><li><strong>Root Cause Analysis:</strong> The team that wrote the service was new and had not received secure coding training. The standard corporate SAST scanner was also not enabled for their project.</li><li><strong>Process Improvements (The Feedback):</strong><ul><li>**To Training:** The developer training program is updated to be a mandatory part of the onboarding process for all new engineers.</li><li>**To Onboarding Process:** The new project creation checklist is updated to include a mandatory step: 'Enable SAST scanning in the CI/CD pipeline'.</li><li>**To Secure Patterns:** A new, secure database access library is created that makes parameterized queries easier to use than raw SQL.</li></ul></li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1542626991-a2f5702b3c2b?w=800&h=400&fit=crop",
                },
                {
                  title: "Technology Evolution Adaptation",
                  content:
                    "<p>The tools and processes must also evolve.</p><h3>What to Review Periodically:</h3><ul><li><strong>SAST Rule Tuning:</strong> Based on the false positive data you've collected, periodically tune your SAST tool's ruleset to make it more accurate for your specific codebase.</li><li><strong>Checklist Updates:</strong> Your security review checklist should be a living document. When a new type of vulnerability is discovered (e.g., in a new cloud service), add it to the checklist.</li><li><strong>Metrics Review:</strong> Use the metrics you are collecting (from Lesson 20) to identify bottlenecks or areas for improvement in the review process itself.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab 29: Continuous Improvement Workshop",
                  language: "markdown",
                  code: "# Root Cause Analysis of a Production Incident\n\n**Incident:** A security incident was caused by a hard-coded API key found in a public GitHub repository.\n\n**Root Cause Analysis:**\n- **Why did this happen?** A developer accidentally committed the key.\n- **Why was it not caught?** We did not have a pre-commit hook for secret scanning, and the SAST scan in the CI/CD pipeline did not run on their feature branch.\n\n**Actionable Improvements (The Feedback Loop):**\n1.  **[Process]** Implement a mandatory, centrally managed pre-commit hook for secret scanning on all developer workstations.\n2.  **[Pipeline]** Change the CI/CD configuration to run a fast secret scan on *every* push to *every* branch, not just on pull requests to main.\n3.  **[Training]** Add a specific module to the developer onboarding training about the dangers of hard-coded secrets.",
                },
                {
                  title:
                    "Code Example 29: Self-Improving Security Review System",
                  language: "python",
                  code: '# Conceptual script to identify noisy SAST rules for tuning\n\ndef find_top_false_positives(triage_database, time_window):\n    """Query the triage database to find which rules are most often marked as false positives."""\n    \n    query = f"""\n        SELECT \n            rule_id,\n            COUNT(*) as false_positive_count\n        FROM \n            sast_findings\n        WHERE \n            triage_status = \'FALSE_POSITIVE\'\n            AND \n            timestamp >= NOW() - INTERVAL \'{time_window}\'\n        GROUP BY \n            rule_id\n        ORDER BY \n            false_positive_count DESC\n        LIMIT 10;\n    """\n    \n    # The output of this query tells the security team exactly which rules\n    # they should investigate for tuning or suppression.\n    return triage_database.execute(query)',
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "The primary goal of a continuous improvement program for security code review is to:",
                  options: [
                    "Keep the process exactly the same forever.",
                    "Use the findings and metrics from the review process as feedback to systematically improve security training, tools, and standards.",
                    "Perform code reviews less frequently.",
                    "Blame developers for all security bugs.",
                  ],
                  correct: 1,
                  explanation:
                    "Continuous improvement is about creating a virtuous cycle. Each vulnerability found is not just a bug to be fixed, but an opportunity to learn and improve the system to prevent that entire class of bug from happening again.",
                },
                {
                  id: 2,
                  question:
                    "A code review finds a specific type of vulnerability that the current SAST scanner does not have a rule for. What is the best 'feedback loop' action?",
                  options: [
                    "To do nothing.",
                    "To blame the SAST vendor.",
                    "To write a new, custom rule for the SAST scanner to automatically detect this vulnerability in the future.",
                    "To stop using the SAST scanner.",
                  ],
                  correct: 2,
                  explanation:
                    "This is a perfect example of the feedback loop. The manual review has uncovered a gap in the automated tooling. The next step is to close that gap by encoding the human's knowledge into a new automated rule.",
                },
                {
                  id: 3,
                  question:
                    "Analyzing metrics about which SAST rules are most frequently marked as false positives is an activity related to:",
                  options: [
                    "Tool Tuning and Optimization",
                    "Incident Response",
                    "Penetration Testing",
                    "Writing new code",
                  ],
                  correct: 0,
                  explanation:
                    "A good security review program doesn't just use its tools; it actively manages and optimizes them. Using data to tune the tools reduces noise and makes them more effective and trusted by developers.",
                },
                {
                  id: 4,
                  question:
                    "The 'lessons learned' from a security incident should be used to:",
                  options: [
                    "Create a report that is never read.",
                    "Find someone to blame.",
                    "Drive concrete improvements, such as adding new security regression tests and updating secure coding patterns.",
                    "Justify a larger budget.",
                  ],
                  correct: 2,
                  explanation:
                    "This is the most critical part of the incident response lifecycle. The knowledge gained from a real-world failure is incredibly valuable and must be used to create specific, actionable improvements that make the system more resilient.",
                },
              ],
            },
          },
          {
            id: "lesson-30",
            title: "Future of Security Code Review",
            duration: "90 min",
            objectives: [
              "Understand the impact of AI/ML on the future of code analysis.",
              "Explore the evolution of DevSecOps and its effect on code review.",
              "Grasp the importance of emerging standards like SLSA for supply chain security.",
              "Identify key areas for career development and continuous learning.",
            ],
            content: {
              overview:
                "The world of software development and security is in a constant state of evolution. The tools and techniques we use for code review are becoming more intelligent and more integrated every year. This final lesson looks to the future, exploring the trends that will shape the next generation of security code review.",
              sections: [
                {
                  title: "AI/ML Advancement Implications",
                  content:
                    "<p>Artificial intelligence is set to revolutionize code analysis.</p><h3>The Future of SAST:</h3><ul><li><strong>AI-Powered Triage:</strong> Future tools will use sophisticated AI models to automatically determine if a finding is a true or false positive with a high degree of accuracy, nearly eliminating the manual triage burden.</li><li><strong>AI-Assisted Remediation:</strong> The tools will not just find a bug, but will automatically write the secure code to fix it and submit it as a pull request.</li><li><strong>AI Co-Pilots:</strong> IDE plugins will evolve into true AI-powered assistants that can provide real-time, context-aware secure coding advice as a developer is writing their code.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1620712943543-285f231f7927?w=800&h=400&fit-crop",
                },
                {
                  title: "DevSecOps Evolution Trends",
                  content:
                    "<p>The trend is towards more and more automation, with the human reviewer focusing only on the highest-risk and most complex issues.</p><ul><li><strong>Policy as Code as the Gatekeeper:</strong> The CI/CD pipeline, governed by a rich set of policies defined as code, will become the primary enforcement point. Most reviews will be fully automated.</li><li><strong>Shift Left, Shift Right:</strong> The feedback loop will become tighter. Data from production monitoring ('shift right') will be used to inform the security checks happening in the pipeline ('shift left'). For example, if a WAF sees a new attack pattern in production, it could automatically generate a new rule for the SAST scanner.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1542382257-80deda0e5d99?w=800&h=400&fit-crop",
                },
                {
                  title: "Industry Standardization Efforts",
                  content:
                    "<p>Standardization is key to securing the software supply chain.</p><h3>Key Standards to Watch:</h3><ul><li><strong>SBOM (Software Bill of Materials):</strong> The requirement to produce and consume SBOMs will become standard practice, and eventually a regulatory requirement in many industries.</li><li><strong>SLSA (Supply-chain Levels for Software Artifacts):</strong> The SLSA framework provides a standard for ensuring the integrity of the build process. In the future, your code review process may need to verify that your build pipeline meets a certain SLSA level.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title: "Lab 30: Future Technology Integration Lab",
                  language: "python",
                  code: '# Conceptual example of an AI-powered code reviewer bot\n\nimport large_language_model_api\n\ndef review_code_with_ai(code_snippet):\n    prompt = f"""\n    You are an expert security code reviewer. Analyze the following Python code for vulnerabilities,\n    focusing on the OWASP Top 10. For each finding, explain the risk and provide the\n    corrected, secure code.\n\n    Code:\n    ---\n    {code_snippet}\n    ---\n    """\n\n    # The LLM would analyze the code and generate a human-readable review comment.\n    return large_language_model_api.generate(prompt)',
                },
                {
                  title:
                    "Code Example 30: Next-Generation Security Review Platform",
                  language: "json",
                  code: '{\n  "pullRequest": 451,\n  "automatedReview": {\n    "status": "APPROVED_WITH_SUGGESTIONS",\n    "findings": [],\n    "aiSuggestions": [\n      {\n        "file": "utils.py",\n        "line": 25,\n        "suggestion": "This function could be made more resilient by adding a timeout to the network request.",\n        "confidence": 0.88\n      }\n    ]\n  },\n  "humanReviewRequired": false\n}',
                },
              ],
            },
            quiz: {
              passingScore: 75,
              questions: [
                {
                  id: 1,
                  question:
                    "The emerging trend of security platforms that combine CSPM and CWPP into a single, unified solution is known as:",
                  options: [
                    "SAST",
                    "CNAPP (Cloud-Native Application Protection Platform)",
                    "DAST",
                    "SIEM",
                  ],
                  correct: 1,
                  explanation:
                    "CNAPP is the future of cloud security. It aims to break down the silos between different tools to provide a single, correlated view of risk all the way from the code to the running cloud workload.",
                },
                {
                  id: 2,
                  question:
                    "A key future application of AI/ML in security code review will be:",
                  options: [
                    "To make the process fully manual.",
                    "To automatically suggest the correct, secure code to fix a discovered vulnerability.",
                    "To make the code review process slower.",
                    "To replace all developers.",
                  ],
                  correct: 1,
                  explanation:
                    "AI-assisted remediation is a major area of research and development. In the future, tools will not just find problems but will also be able to automatically and accurately fix them, significantly increasing developer productivity.",
                },
                {
                  id: 3,
                  question:
                    "The SLSA framework is an emerging standard focused on what aspect of security?",
                  options: [
                    "Securing the integrity of the software supply chain and build process.",
                    "Web application firewalls.",
                    "Network security.",
                    "User authentication.",
                  ],
                  correct: 0,
                  explanation:
                    "SLSA provides a standard set of levels and controls for hardening the CI/CD pipeline itself against tampering, which is a critical part of modern software supply chain security.",
                },
                {
                  id: 4,
                  question:
                    "The concept of using data from production monitoring ('shift right') to inform the security checks happening in the development pipeline ('shift left') is an example of:",
                  options: [
                    "A broken process",
                    "A security silo",
                    "A continuous feedback loop",
                    "A manual review",
                  ],
                  correct: 2,
                  explanation:
                    "This is a key trend in the evolution of DevSecOps. The future is not just about shifting left, but about creating a full-circle feedback loop where data from every stage of the lifecycle is used to make the entire system smarter and more secure.",
                },
              ],
            },
          },
          {
            id: "lesson-31",
            title: "Final Capstone Project",
            duration: "240 min",
            objectives: [
              "Apply the principles of security code review to a real-world codebase.",
              "Perform a hybrid review, combining automated SAST results with manual analysis.",
              "Identify, classify, and prioritize a set of security vulnerabilities.",
              "Write a high-quality, actionable code review report with remediation guidance.",
            ],
            content: {
              overview:
                "This final capstone project brings together all the concepts covered in the Complete Security Code Review Course. You will be given a small but realistic web application codebase that contains a number of intentional security vulnerabilities. Your task will be to act as a security code reviewer, perform a comprehensive review, and produce a professional-grade report of your findings.",
              sections: [
                {
                  title: "Scenario: 'VulnerableApp'",
                  content:
                    "<p>You will be given access to a Git repository containing 'VulnerableApp', a simple web application written in the language of your choice (starter projects will be provided for Python/Flask, Java/Spring, and Node.js/Express). The application is a basic blog platform that allows users to register, log in, create posts, and leave comments.</p><p>You will also be provided with the output from a SAST scanner that has been run on the codebase.</p>",
                  image:
                    "https://images.unsplash.com/photo-1517694712202-14dd9538aa97?w=800&h=400&fit=crop",
                },
                {
                  title: "Project Task 1: Triage Automated Findings",
                  content:
                    "<p>Review the provided SAST scan results. For each finding, you must triage it:</p><ol><li>Validate whether it is a True Positive or a False Positive by analyzing the code.</li><li>If it is a True Positive, perform a risk assessment (Likelihood/Impact) to assign a final risk rating (Critical, High, Medium, or Low).</li></ol>",
                  image:
                    "https://images.unsplash.com/photo-1555099962-4199c345e546?w=800&h=400&fit=crop",
                },
                {
                  title: "Project Task 2: Perform a Manual Review",
                  content:
                    "<p>Perform your own manual code review of the 'VulnerableApp' codebase. You are looking for security vulnerabilities that the automated scanner may have missed, with a particular focus on authentication, authorization, and business logic flaws.</p>",
                  image:
                    "https://images.unsplash.com/photo-1486312338219-ce68d2c6f44d?w=800&h=400&fit=crop",
                },
                {
                  title: "Project Task 3: Create a Final Report",
                  content:
                    "<p>Create a single, professional code review report that consolidates all of your findings (both the validated automated findings and the new findings from your manual review). For each finding, your report must include:</p><ul><li>A clear title and a classification (CWE).</li><li>The final risk rating.</li><li>The specific file and line number of the vulnerability.</li><li>A code snippet showing the vulnerable code.</li><li>A detailed explanation of the vulnerability and its risk.</li><li>A clear, actionable recommendation on how to fix the vulnerability.</li></ul>",
                  image:
                    "https://images.unsplash.com/photo-1454165804606-c3d57bc86b40?w=800&h=400&fit-crop",
                },
              ],
              codeExamples: [
                {
                  title:
                    "Final Lab: End-to-End Security Review Program Implementation",
                  language: "markdown",
                  code: "# Capstone Project Submission Checklist\n\n1.  **Triage Document (Markdown or PDF):**\n    - A list of all the findings from the provided SAST scan.\n    - For each finding, your triage decision (True Positive / False Positive) and a justification.\n    - For all True Positives, your final risk rating.\n\n2.  **Code Review Report (Markdown or PDF):**\n    - A single, consolidated report containing all validated SAST findings and any new findings from your manual review.\n    - The report must follow the required format (Title, Risk, Location, Code, Analysis, Recommendation).",
                },
                {
                  title:
                    "Final Code Project: Enterprise Security Code Review Platform",
                  language: "plaintext",
                  code: "/*\n  This final project is a hands-on analysis exercise. You will be evaluated on your ability\n  to accurately identify vulnerabilities, assess their risk, and communicate your findings in a\n  clear, professional, and actionable manner, applying the skills from the entire course.\n*/",
                },
              ],
            },
            quiz: {
              passingScore: 100,
              questions: [
                {
                  id: 1,
                  question:
                    "This capstone project requires you to act as a security code reviewer, analyzing a codebase and producing a professional report. Are you ready to begin?",
                  options: [
                    "Yes, I am ready to review 'VulnerableApp'.",
                    "No, I would like to review some of the previous lessons.",
                  ],
                  correct: 0,
                  explanation:
                    "This question confirms your readiness to apply the comprehensive, hands-on knowledge gained throughout the course to a final, practical code review project.",
                },
              ],
            },
          },
        ],
      };
      // =====================================================
      // GLOBAL VARIABLES
      // =====================================================
      let currentUser = null;
      let currentLessonIndex = 0;
      let courseProgress = {};
      let userStats = {};
      let quizState = {
        currentQuestion: 0,
        answers: [],
        score: 0,
        isComplete: false,
      };

      // Enhanced session tracking
      let courseSession = {
        startTime: null,
        totalStudyTime: 0,
        lessonsStarted: 0,
        lessonsCompleted: 0,
        pageLoadTime: new Date(),
        interactionCount: 0,
        lastActivityTime: new Date(),
      };

      // Music Player Variables
      let audioPlayer = new Audio();

      // Achievement notification system
      let notificationQueue = [];
      let isShowingNotification = false;

      // =====================================================
      // INITIALIZATION
      // =====================================================
      document.addEventListener("DOMContentLoaded", async () => {
        try {
          showLoadingScreen();
          await checkAuth();

          if (currentUser) {
            // Initialize session tracking
            startCourseSession();

            // Load course data and progress
            await loadCourseData();
            await loadUserProfile();
            await loadProgress();

            // Initialize UI
            initializeEventListeners();
            renderSidebar();
            loadLesson(currentLessonIndex);

            // Initialize additional features
            initMusicPlayer();
            addMusicIndicator();
            initializeActivityTracking();

            hideLoadingScreen();
          } else {
            openAuthModal();
          }
        } catch (error) {
          console.error("Error initializing course:", error);
          hideLoadingScreen();
          showToast("Failed to initialize course system", "error");
        }
      });

      // =====================================================
      // AUTHENTICATION SYSTEM
      // =====================================================
      async function checkAuth() {
        try {
          const {
            data: { session },
            error,
          } = await supabase.auth.getSession();

          if (error) {
            console.error("Auth error:", error);
            currentUser = null;
            openAuthModal();
            return;
          }

          if (!session) {
            currentUser = null;
            openAuthModal();
            return;
          }

          currentUser = session.user;
          updateUIWithUser();
        } catch (error) {
          console.error("Error checking auth:", error);
          currentUser = null;
          openAuthModal();
        }
      }

      function updateUIWithUser() {
        if (!currentUser) return;

        const name =
          currentUser.user_metadata?.full_name ||
          currentUser.email.split("@")[0];
        const userElements = document.querySelectorAll("[data-user-name]");
        userElements.forEach((el) => (el.textContent = name));
      }

      // =====================================================
      // USER PROFILE & STATS MANAGEMENT
      // =====================================================
      async function loadUserProfile() {
        try {
          // 🔍 Step 1: Try to fetch existing profile
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("*")
            .eq("id", currentUser.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (!profile) {
            // 🆕 Step 2: Create new profile if missing
            await createUserProfile();
          } else {
            // ✅ Step 3: Use existing profile
            userStats = profile;
            await updateLastActivity();
          }
        } catch (error) {
          console.error("❌ Error loading user profile:", error);
          showToast("Failed to load user profile", "error");
        }
      }
      async function createUserProfile() {
        try {
          const newProfile = {
            id: currentUser.id,
            full_name: currentUser.user_metadata?.full_name || "",
            email: currentUser.email,
            level: "Script Kiddie",
            total_points: 0,
            completed_courses: 0,
            current_streak: 0,
            total_certificates: 0,
            total_achievements: 0,
            sections_visited: 0,
            bonus_points: 0,
            in_progress_courses: 0,
            settings_changed: 0,
            midnight_sessions: 0,
            early_sessions: 0,
            weekend_sessions: 0,
            last_activity: new Date().toISOString(),
            created_at: new Date().toISOString(),
          };

          const { error } = await supabase
            .from("profiles")
            .insert([newProfile]);

          if (!error) {
            userStats = newProfile;
            // Award first login achievement
            setTimeout(() => checkAndUnlockAchievement("first_login"), 1000);
          }
        } catch (error) {
          console.error("Error creating user profile:", error);
        }
      }

      async function updateLastActivity() {
        try {
          const now = new Date();

          // Update activity tracking
          courseSession.lastActivityTime = now;

          // Update database
          await supabase
            .from("profiles")
            .update({
              last_activity: now.toISOString(),
            })
            .eq("id", currentUser.id);

          // Check time-based achievements
          await checkTimeBasedAchievements(now);
        } catch (error) {
          console.error("Error updating last activity:", error);
        }
      }

      // =====================================================
      // COURSE SESSION MANAGEMENT
      // =====================================================
      function startCourseSession() {
        courseSession.startTime = new Date();
        courseSession.pageLoadTime = new Date();

        logUserActivity("course_session_start", {
          course_id: COURSE_DATA.id,
          course_title: COURSE_DATA.title,
          user_agent: navigator.userAgent,
          screen_resolution: `${screen.width}x${screen.height}`,
        });

        // Check daily streak
        checkDailyStreak();
      }

      function initializeActivityTracking() {
        // Track page focus/blur for accurate study time
        document.addEventListener("visibilitychange", handleVisibilityChange);

        // Track user interactions
        ["click", "keydown", "scroll", "mousemove"].forEach((event) => {
          document.addEventListener(event, trackUserInteraction, {
            passive: true,
          });
        });

        // Periodic activity updates
        setInterval(updateStudyTime, 60000); // Every minute

        // Save session data before page unload
        window.addEventListener("beforeunload", saveSessionData);
      }

      function handleVisibilityChange() {
        if (document.hidden) {
          courseSession.lastActivityTime = new Date();
        } else {
          // Page became visible again - update activity
          updateLastActivity();
        }
      }

      function trackUserInteraction() {
        courseSession.interactionCount++;
        courseSession.lastActivityTime = new Date();

        // Throttle activity updates
        if (courseSession.interactionCount % 50 === 0) {
          updateLastActivity();
        }
      }

      function updateStudyTime() {
        if (!courseSession.startTime || document.hidden) return;

        const now = new Date();
        const sessionDuration = now - courseSession.startTime;
        courseSession.totalStudyTime = Math.floor(sessionDuration / 1000 / 60); // in minutes

        // Update progress with study time
        saveProgress();
      }

      function saveSessionData() {
        if (!currentUser || !courseSession.startTime) return;

        const sessionData = {
          user_id: currentUser.id,
          course_id: COURSE_DATA.id,
          session_duration: courseSession.totalStudyTime,
          lessons_viewed: courseSession.lessonsStarted,
          lessons_completed: courseSession.lessonsCompleted,
          interactions: courseSession.interactionCount,
          session_date: courseSession.startTime.toISOString().split("T")[0],
        };

        // Store in localStorage as backup
        localStorage.setItem(
          "course_session_backup",
          JSON.stringify(sessionData)
        );

        // Try to save to database
        logUserActivity("course_session_end", sessionData);
      }

      // =====================================================
      // COURSE DATA & PROGRESS MANAGEMENT
      // =====================================================
      async function loadCourseData() {
        try {
          // Update course info in UI
          document.getElementById("courseTitle").textContent =
            COURSE_DATA.title;
          document.getElementById("totalLessons").textContent =
            COURSE_DATA.lessons.length;

          // Log course access
          logUserActivity("course_access", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
          });
        } catch (error) {
          console.error("Error loading course data:", error);
        }
      }

      async function loadProgress() {
        try {
          // Get existing progress from database
          const { data, error } = await supabase
            .from("course_progress")
            .select("*")
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (data) {
            courseProgress = JSON.parse(data.lesson_progress || "{}");
            currentLessonIndex = data.current_lesson || 0;

            // Update session tracking
            courseSession.lessonsStarted = Object.keys(courseProgress).length;
            courseSession.lessonsCompleted = Object.values(
              courseProgress
            ).filter((p) => p.completed).length;
          } else {
            // Initialize new progress
            courseProgress = {};
            currentLessonIndex = 0;
            await saveProgress();

            // Award first course start achievement
            await checkAndUnlockAchievement("first_course_start");
          }

          updateProgressDisplay();
        } catch (error) {
          console.error("Error loading progress:", error);
          showToast("Failed to load progress", "error");
        }
      }

      async function saveProgress() {
        try {
          if (!currentUser) return;

          const now = new Date();
          const progressData = {
            user_id: currentUser.id,
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            current_lesson: currentLessonIndex,
            lesson_progress: JSON.stringify(courseProgress),
            progress: calculateOverallProgress(),
            lessons_completed: getCompletedLessonsCount(),
            lessons_started: Object.keys(courseProgress).length,
            study_time_minutes: courseSession.totalStudyTime,
            last_accessed: now.toISOString(),
            updated_at: now.toISOString(),
          };

          // Upsert progress
          const { error } = await supabase
            .from("course_progress")
            .upsert([progressData]);

          if (error) throw error;

          // Update user stats
          await updateUserStats();

          updateProgressDisplay();
        } catch (error) {
          console.error("Error saving progress:", error);
          showToast("Failed to save progress", "error");
        }
      }

      async function updateUserStats() {
        try {
          // Get all course progress for this user
          const { data: allProgress, error } = await supabase
            .from("course_progress")
            .select("progress, course_id, study_time_minutes")
            .eq("user_id", currentUser.id);

          if (error) throw error;

          // Calculate stats
          const completedCourses =
            allProgress?.filter((p) => p.progress >= 100).length || 0;
          const inProgressCourses =
            allProgress?.filter((p) => p.progress > 0 && p.progress < 100)
              .length || 0;
          const totalStudyTime =
            allProgress?.reduce(
              (sum, p) => sum + (p.study_time_minutes || 0),
              0
            ) || 0;

          // Calculate points (500 per completed course + achievement points)
          const coursePoints = completedCourses * 500;
          const bonusPoints = userStats.bonus_points || 0;
          const totalPoints = coursePoints + bonusPoints;

          // Update profile
          const updateData = {
            completed_courses: completedCourses,
            in_progress_courses: inProgressCourses,
            total_points: totalPoints,
            total_study_time: totalStudyTime,
            last_activity: new Date().toISOString(),
          };

          const { error: updateError } = await supabase
            .from("profiles")
            .update(updateData)
            .eq("id", currentUser.id);

          if (updateError) throw updateError;

          // Update local stats
          Object.assign(userStats, updateData);
        } catch (error) {
          console.error("Error updating user stats:", error);
        }
      }

      function calculateOverallProgress() {
        const completedLessons = getCompletedLessonsCount();
        return Math.round(
          (completedLessons / COURSE_DATA.lessons.length) * 100
        );
      }

      function getCompletedLessonsCount() {
        return Object.values(courseProgress).filter(
          (lesson) => lesson.completed
        ).length;
      }

      function updateProgressDisplay() {
        const completedCount = getCompletedLessonsCount();
        const progressPercent = calculateOverallProgress();

        // Update UI elements
        const elements = {
          completedLessons: completedCount,
          courseProgressPercent: `${progressPercent}%`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });

        // Update progress bar
        const progressBar = document.getElementById("courseProgressFill");
        if (progressBar) progressBar.style.width = `${progressPercent}%`;
      }

      // =====================================================
      // LESSON MANAGEMENT
      // =====================================================
      function loadLesson(index) {
        if (index < 0 || index >= COURSE_DATA.lessons.length) return;

        const lesson = COURSE_DATA.lessons[index];
        currentLessonIndex = index;

        // Mark lesson as started and track activity
        if (!courseProgress[lesson.id]) {
          courseProgress[lesson.id] = {
            started: true,
            completed: false,
            startedAt: new Date().toISOString(),
            timeSpent: 0,
          };

          courseSession.lessonsStarted++;
          saveProgress();

          // Log lesson start
          logUserActivity("lesson_start", {
            lesson_id: lesson.id,
            lesson_title: lesson.title,
            lesson_index: index,
          });
        }

        // Update lesson start time for time tracking
        courseProgress[lesson.id].currentSessionStart = new Date();

        // Update sidebar and navigation
        renderSidebar();
        updateNavigationButtons();

        // Update header info
        updateLessonHeader(lesson, index);

        // Render lesson content
        renderLessonContent(lesson);

        // Smooth scroll and animations
        window.scrollTo({ top: 0, behavior: "smooth" });
        document.getElementById("contentBody").scrollTop = 0;

        const contentBody = document.getElementById("contentBody");
        contentBody.classList.add("fade-in");
        setTimeout(() => contentBody.classList.remove("fade-in"), 500);

        // Check lesson-based achievements
        checkLessonAchievements(index + 1);
      }

      function updateLessonHeader(lesson, index) {
        const elements = {
          currentLessonNumber: index + 1,
          currentLessonTitle: lesson.title,
          navInfo: `Lesson ${index + 1} of ${COURSE_DATA.lessons.length}`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });
      }

      function renderSidebar() {
        const lessonNav = document.getElementById("lessonNav");
        if (!lessonNav) return;

        lessonNav.innerHTML = "";

        COURSE_DATA.lessons.forEach((lesson, index) => {
          const lessonItem = document.createElement("div");
          lessonItem.className = "lesson-item";

          // Determine lesson status
          const lessonProgress = courseProgress[lesson.id];
          const isCompleted = lessonProgress?.completed || false;
          const isInProgress = lessonProgress?.started || false;
          const isLocked = !isCompleted && !canAccessLesson(index);
          const isActive = index === currentLessonIndex;

          // Apply status classes
          if (isCompleted) lessonItem.classList.add("completed");
          if (isLocked) lessonItem.classList.add("locked");
          if (isActive) lessonItem.classList.add("active");

          // Determine status display
          let statusClass = "not-started";
          let statusIcon = index + 1;

          if (isCompleted) {
            statusClass = "completed";
            statusIcon = "✓";
          } else if (isInProgress) {
            statusClass = "in-progress";
            statusIcon = "◐";
          }

          // Create lesson item HTML
          lessonItem.innerHTML = `
            <div class="lesson-status ${statusClass}">${statusIcon}</div>
            <div class="lesson-info">
                <div class="lesson-title">${lesson.title}</div>
                <div class="lesson-meta">
                    ${
                      isCompleted
                        ? "Completed"
                        : isInProgress
                        ? "In Progress"
                        : isLocked
                        ? "Locked"
                        : "Not Started"
                    }
                </div>
            </div>
            <div class="lesson-duration">${lesson.duration}</div>
        `;

          // Add click handler if not locked
          if (!isLocked) {
            lessonItem.addEventListener("click", () => {
              if (index !== currentLessonIndex) {
                // Track lesson time before switching
                trackLessonTime();

                currentLessonIndex = index;
                loadLesson(index);
                closeSidebar();
              }
            });
          }

          lessonNav.appendChild(lessonItem);
        });
      }

      function canAccessLesson(index) {
        if (index === 0) return true; // First lesson always accessible

        // Can access if previous lesson is completed
        const previousLessonId = COURSE_DATA.lessons[index - 1].id;
        return courseProgress[previousLessonId]?.completed || false;
      }

      function trackLessonTime() {
        const currentLesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonProgress = courseProgress[currentLesson.id];

        if (lessonProgress?.currentSessionStart) {
          const sessionTime = Math.floor(
            (new Date() - new Date(lessonProgress.currentSessionStart)) /
              1000 /
              60
          );
          lessonProgress.timeSpent =
            (lessonProgress.timeSpent || 0) + sessionTime;
          delete lessonProgress.currentSessionStart;
        }
      }

      // =====================================================
      // LESSON CONTENT RENDERING
      // =====================================================
      function renderLessonContent(lesson) {
        const contentContainer = document.getElementById("lessonContent");
        if (!contentContainer) return;

        let contentHTML = `
        <div class="content-section">
            <h2>Learning Objectives</h2>
            <ul>
                ${lesson.objectives.map((obj) => `<li>${obj}</li>`).join("")}
            </ul>
        </div>
        
        <div class="content-section">
            <h2>Overview</h2>
            <p>${lesson.content.overview}</p>
        </div>
    `;

        // Render content sections
        lesson.content.sections.forEach((section) => {
          contentHTML += `
            <div class="content-section">
                <h2>${section.title}</h2>
                ${section.content}
                ${
                  section.image
                    ? `<img src="${section.image}" alt="${section.title}" class="content-image" loading="lazy">`
                    : ""
                }
            </div>
        `;
        });

        // Render code examples
        if (
          lesson.content.codeExamples &&
          lesson.content.codeExamples.length > 0
        ) {
          contentHTML += `<div class="content-section"><h2>Code Examples</h2></div>`;

          lesson.content.codeExamples.forEach((example, index) => {
            const codeId = `code-${lesson.id}-${index}`;
            contentHTML += `
                <div class="code-section">
                    <div class="code-header">
                        <span class="code-title">${example.title}</span>
                        <button class="copy-btn" onclick="copyCode('${codeId}')">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <pre class="code-block"><code id="${codeId}" class="language-${
              example.language
            }">${escapeHtml(example.code)}</code></pre>
                </div>
            `;
          });
        }

        // Render quiz
        contentHTML += renderQuiz(lesson.quiz);

        contentContainer.innerHTML = contentHTML;

        // Highlight code syntax if Prism is available
        setTimeout(() => {
          if (window.Prism) {
            Prism.highlightAll();
          }
        }, 100);
      }

      // =====================================================
      // QUIZ SYSTEM
      // =====================================================
      function renderQuiz(quiz) {
        const currentLessonProgress =
          courseProgress[COURSE_DATA.lessons[currentLessonIndex].id];
        const isCompleted = currentLessonProgress?.completed || false;

        let quizHTML = `
        <div class="quiz-section" id="quizSection">
            <div class="quiz-header">
                <h2 class="quiz-title">
                    <i class="fas fa-clipboard-check"></i>
                    Knowledge Check
                </h2>
                <p class="quiz-info">
                    Complete this quiz with ${quiz.passingScore}% or higher to unlock the next lesson.
                </p>
            </div>
    `;

        if (isCompleted) {
          const savedScore = currentLessonProgress.quizScore || 0;
          quizHTML += `
            <div class="quiz-results show">
                <div class="quiz-score pass">${savedScore}%</div>
                <div class="quiz-message">
                    <strong>Lesson Completed!</strong><br>
                    You've successfully passed this lesson's quiz.
                </div>
            </div>
        `;
        } else {
          // Render quiz questions
          quiz.questions.forEach((question, qIndex) => {
            quizHTML += `
                <div class="quiz-question ${
                  qIndex === 0 ? "active" : ""
                }" data-question="${qIndex}">
                    <div class="question-header">
                        <span class="question-number">Question ${
                          qIndex + 1
                        }</span>
                        <span class="question-progress">${qIndex + 1}/${
              quiz.questions.length
            }</span>
                    </div>
                    <div class="question-text">${question.question}</div>
                    <div class="question-options">
                        ${question.options
                          .map(
                            (option, oIndex) => `
                            <div class="option" data-option="${oIndex}" onclick="selectOption(${qIndex}, ${oIndex})">
                                <span class="option-letter">${String.fromCharCode(
                                  65 + oIndex
                                )}</span>
                                <span class="option-text">${option}</span>
                            </div>
                        `
                          )
                          .join("")}
                    </div>
                </div>
            `;
          });

          quizHTML += `
            <div class="quiz-controls">
                <button class="btn btn-secondary" id="prevQuestionBtn" onclick="previousQuestion()" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <div>
                    <button class="btn btn-secondary" id="nextQuestionBtn" onclick="nextQuestion()" disabled>
                        Next
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <button class="btn btn-primary" id="submitQuizBtn" onclick="submitQuiz()" style="display: none;">
                        <i class="fas fa-check"></i>
                        Submit Quiz
                    </button>
                </div>
            </div>

            <div class="quiz-results" id="quizResults">
                <div class="quiz-score" id="quizScore">0%</div>
                <div class="quiz-message" id="quizMessage"></div>
                <div class="quiz-actions">
                    <button class="btn btn-primary" id="continueBtn" onclick="completeLesson()" style="display: none;">
                        <i class="fas fa-arrow-right"></i>
                        Continue to Next Lesson
                    </button>
                    <button class="btn btn-secondary" onclick="retakeQuiz()">
                        <i class="fas fa-redo"></i>
                        Retake Quiz
                    </button>
                </div>
            </div>
        `;
        }

        quizHTML += "</div>";
        return quizHTML;
      }

      // Quiz interaction functions
      function selectOption(questionIndex, optionIndex) {
        // Clear previous selections
        document
          .querySelectorAll(`[data-question="${questionIndex}"] .option`)
          .forEach((opt) => {
            opt.classList.remove("selected");
          });

        // Select current option
        const selectedOption = document.querySelector(
          `[data-question="${questionIndex}"] [data-option="${optionIndex}"]`
        );
        selectedOption.classList.add("selected");

        // Store answer
        quizState.answers[questionIndex] = optionIndex;

        // Update navigation
        const isLastQuestion =
          questionIndex ===
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length - 1;
        if (isLastQuestion) {
          document.getElementById("submitQuizBtn").style.display =
            "inline-flex";
          document.getElementById("nextQuestionBtn").style.display = "none";
        } else {
          document.getElementById("nextQuestionBtn").disabled = false;
        }
      }

      function nextQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const nextQuestionEl = currentQuestionEl.nextElementSibling;

        if (
          nextQuestionEl &&
          nextQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          nextQuestionEl.classList.add("active");
          quizState.currentQuestion++;
          updateQuizNavigation();
        }
      }

      function previousQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const prevQuestionEl = currentQuestionEl.previousElementSibling;

        if (
          prevQuestionEl &&
          prevQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          prevQuestionEl.classList.add("active");
          quizState.currentQuestion--;
          updateQuizNavigation();
        }
      }

      function updateQuizNavigation() {
        const totalQuestions =
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length;
        const prevBtn = document.getElementById("prevQuestionBtn");
        const nextBtn = document.getElementById("nextQuestionBtn");
        const submitBtn = document.getElementById("submitQuizBtn");

        prevBtn.disabled = quizState.currentQuestion === 0;

        const hasAnswer =
          quizState.answers[quizState.currentQuestion] !== undefined;
        const isLastQuestion = quizState.currentQuestion === totalQuestions - 1;

        if (isLastQuestion) {
          nextBtn.style.display = "none";
          submitBtn.style.display = hasAnswer ? "inline-flex" : "none";
        } else {
          nextBtn.style.display = "inline-flex";
          nextBtn.disabled = !hasAnswer;
          submitBtn.style.display = "none";
        }
      }

      async function submitQuiz() {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const quiz = lesson.quiz;
        let correctAnswers = 0;

        // Hide questions and controls
        document
          .querySelectorAll(".quiz-question")
          .forEach((q) => (q.style.display = "none"));
        document.querySelector(".quiz-controls").style.display = "none";

        // Calculate score and highlight answers
        quiz.questions.forEach((question, index) => {
          const userAnswer = quizState.answers[index];
          const correctAnswer = question.correct;
          const isCorrect = userAnswer === correctAnswer;

          if (isCorrect) correctAnswers++;

          // Highlight answers
          const questionEl = document.querySelector(
            `[data-question="${index}"]`
          );
          const options = questionEl.querySelectorAll(".option");

          options[correctAnswer].classList.add("correct");
          if (userAnswer !== correctAnswer && userAnswer !== undefined) {
            options[userAnswer].classList.add("incorrect");
          }
        });

        const score = Math.round(
          (correctAnswers / quiz.questions.length) * 100
        );
        const passed = score >= quiz.passingScore;

        // Update quiz results UI
        const quizScore = document.getElementById("quizScore");
        const quizMessage = document.getElementById("quizMessage");
        const quizActions = document.querySelector(".quiz-actions");

        quizScore.textContent = `${score}%`;
        quizScore.className = `quiz-score ${passed ? "pass" : "fail"}`;

        if (passed) {
          quizMessage.innerHTML = `
            <strong>Congratulations!</strong><br>
            You passed with ${score}%. You can now proceed to the next lesson.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-primary" onclick="completeLesson()">
                <i class="fas fa-arrow-right"></i>
                Continue to Next Lesson
            </button>
        `;

          // Mark lesson as completed
          await markLessonComplete(score);
        } else {
          quizMessage.innerHTML = `
            <strong>Not quite there yet.</strong><br>
            You scored ${score}%. You need ${quiz.passingScore}% to pass. Review the material and try again.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-secondary" onclick="retakeQuiz()">
                <i class="fas fa-redo"></i>
                Retake Quiz
            </button>
        `;
        }

        document.getElementById("quizResults").classList.add("show");

        // Log quiz completion
        logUserActivity("quiz_completed", {
          lesson_id: lesson.id,
          lesson_title: lesson.title,
          score: score,
          passed: passed,
          attempts: (courseProgress[lesson.id]?.quizAttempts || 0) + 1,
        });

        // Scroll to results
        document
          .getElementById("quizResults")
          .scrollIntoView({ behavior: "smooth" });
      }

      function retakeQuiz() {
        // Reset quiz state
        quizState = {
          currentQuestion: 0,
          answers: [],
          score: 0,
          isComplete: false,
        };

        // Track quiz retry
        const lessonId = COURSE_DATA.lessons[currentLessonIndex].id;
        if (!courseProgress[lessonId]) courseProgress[lessonId] = {};
        courseProgress[lessonId].quizAttempts =
          (courseProgress[lessonId].quizAttempts || 0) + 1;

        // Reload lesson content
        loadLesson(currentLessonIndex);

        // Scroll to quiz
        setTimeout(() => {
          document
            .getElementById("quizSection")
            .scrollIntoView({ behavior: "smooth" });
        }, 500);
      }

      async function markLessonComplete(score) {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonId = lesson.id;

        // Track lesson completion time
        trackLessonTime();

        // Update lesson progress
        courseProgress[lessonId] = {
          ...courseProgress[lessonId],
          completed: true,
          quizScore: score,
          completedAt: new Date().toISOString(),
          finalScore: score,
        };

        // Update session tracking
        courseSession.lessonsCompleted++;

        // Save progress to database
        await saveProgress();

        // Update UI
        renderSidebar();
        updateNavigationButtons();

        // Check various achievements
        await checkLessonCompletionAchievements();
        await checkPerfectScoreAchievements(score);
        await checkStudyTimeAchievements();

        // Log lesson completion
        logUserActivity("lesson_completed", {
          lesson_id: lessonId,
          lesson_title: lesson.title,
          final_score: score,
          time_spent: courseProgress[lessonId].timeSpent || 0,
          lesson_number: currentLessonIndex + 1,
        });

        showToast("Lesson completed successfully!", "success");
      }

      async function completeLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          // Move to next lesson
          currentLessonIndex++;
          loadLesson(currentLessonIndex);
        } else {
          // Course completion
          await completeCourse();
        }
      }

      async function completeCourse() {
        try {
          const completionTime = courseSession.totalStudyTime;

          // Update course progress to 100% completed
          await supabase
            .from("course_progress")
            .update({
              progress: 100,
              completed_at: new Date().toISOString(),
              completion_time_minutes: completionTime,
            })
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Award course completion achievements
          await checkAndUnlockAchievement("course_completion_1");
          await checkSpeedCompletionAchievements(completionTime);
          await checkCourseStreakAchievements();

          // Update user stats
          await updateUserStats();

          // Show completion message
          showToast(
            "Congratulations! Course completed successfully!",
            "certificate"
          );

          // Log course completion
          logUserActivity("course_completed", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            completion_time_minutes: completionTime,
            total_lessons: COURSE_DATA.lessons.length,
            average_quiz_score: calculateAverageQuizScore(),
          });

          // Redirect to dashboard after delay
          setTimeout(() => {
            window.location.href = "/dashboard.html";
          }, 3000);
        } catch (error) {
          console.error("Error completing course:", error);
          showToast("Error marking course as complete", "error");
        }
      }

      // =====================================================
      // ACHIEVEMENT INTEGRATION SYSTEM
      // =====================================================
      async function checkAndUnlockAchievement(
        achievementId,
        skipNotification = false
      ) {
        try {
          // Prevent duplicate checks
          const cacheKey = `achievement_${achievementId}_${currentUser.id}`;
          if (sessionStorage.getItem(cacheKey)) return false;

          // Check if already unlocked
          const { data: existing, error } = await supabase
            .from("user_achievements")
            .select("id")
            .eq("user_id", currentUser.id)
            .eq("achievement_id", achievementId)
            .single();

          if (existing) {
            sessionStorage.setItem(cacheKey, "true");
            return false;
          }

          // Award achievement
          const achievementData = {
            user_id: currentUser.id,
            achievement_id: achievementId,
            unlocked_at: new Date().toISOString(),
            points_awarded: getAchievementPoints(achievementId),
            context: "course_system",
          };

          const { data, error: insertError } = await supabase
            .from("user_achievements")
            .insert([achievementData])
            .select()
            .single();

          if (insertError) {
            if (insertError.code === "23505") return false; // Already exists
            throw insertError;
          }

          // Update user points
        await supabase.rpc('increment_user_stats', {
  user_id_param: currentUser.id,
  points_to_add: achievementData.points_awarded,
  achievements_to_add: 1
});

          // Cache and queue notification
          sessionStorage.setItem(cacheKey, "true");

          if (!skipNotification) {
            queueAchievementNotification({
              id: achievementId,
              name: getAchievementName(achievementId),
              description: getAchievementDescription(achievementId),
              points: achievementData.points_awarded,
              rarity: getAchievementRarity(achievementId),
              icon: getAchievementIcon(achievementId),
            });
          }

          return true;
        } catch (error) {
          console.error("Error unlocking achievement:", error);
          return false;
        }
      }

      // Helper functions for achievement data (replace with your actual achievement definitions)
      function getAchievementPoints(id) {
        const pointsMap = {
          first_course_start: 75,
          first_lesson: 100,
          course_completion_1: 500,
          perfect_score: 250,
          speed_demon: 750,
          marathon_learner: 500,
          night_owl: 200,
          early_bird: 200,
          weekend_warrior: 150,
          // Add more as needed
        };
        return pointsMap[id] || 100;
      }

      function getAchievementName(id) {
        const nameMap = {
          first_course_start: "Learning Initiated",
          first_lesson: "First Steps",
          course_completion_1: "Course Conqueror",
          perfect_score: "Perfectionist",
          speed_demon: "Speed Demon",
          // Add more as needed
        };
        return nameMap[id] || "Achievement Unlocked";
      }

      function getAchievementDescription(id) {
        const descMap = {
          first_course_start: "Start your first cybersecurity course",
          first_lesson: "Complete your first lesson",
          course_completion_1: "Complete your first course",
          perfect_score: "Score 100% on any quiz",
          speed_demon: "Complete a course in under 2 hours",
          // Add more as needed
        };
        return descMap[id] || "Achievement description";
      }

      function getAchievementRarity(id) {
        const rarityMap = {
          first_course_start: "common",
          first_lesson: "bronze",
          course_completion_1: "silver",
          perfect_score: "gold",
          speed_demon: "legendary",
          // Add more as needed
        };
        return rarityMap[id] || "common";
      }

      function getAchievementIcon(id) {
        const iconMap = {
          first_course_start: "fas fa-play",
          first_lesson: "fas fa-baby",
          course_completion_1: "fas fa-trophy",
          perfect_score: "fas fa-star",
          speed_demon: "fas fa-rocket",
          // Add more as needed
        };
        return iconMap[id] || "fas fa-award";
      }

      async function checkLessonAchievements(lessonNumber) {
        if (lessonNumber === 1) {
          await checkAndUnlockAchievement("first_lesson");
        }

        // Check if user has completed multiple lessons in one day
        const today = new Date().toISOString().split("T")[0];
        const todayCompletions = Object.values(courseProgress).filter(
          (p) => p.completed && p.completedAt?.startsWith(today)
        ).length;

        if (todayCompletions >= 3) {
          await checkAndUnlockAchievement("lesson_marathon");
        }
      }

      async function checkLessonCompletionAchievements() {
        const completedCount = getCompletedLessonsCount();

        // Lesson-based achievements
        const lessonMilestones = [1, 5, 10, 25, 50, 100];
        for (const milestone of lessonMilestones) {
          if (completedCount >= milestone) {
            await checkAndUnlockAchievement(`lessons_${milestone}`);
          }
        }

        // Course completion achievements
        if (completedCount === COURSE_DATA.lessons.length) {
          await checkAndUnlockAchievement("course_completion_1");

          // Check for additional course completion achievements
          const { data: allCourses } = await supabase
            .from("course_progress")
            .select("course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100);

          const totalCompleted = allCourses?.length || 0;

          const courseMilestones = [1, 5, 10, 25];
          for (const milestone of courseMilestones) {
            if (totalCompleted >= milestone) {
              await checkAndUnlockAchievement(`course_completion_${milestone}`);
            }
          }
        }
      }

      async function checkPerfectScoreAchievements(score) {
        if (score === 100) {
          await checkAndUnlockAchievement("perfect_score");

          // Check for consecutive perfect scores
          const recentScores = Object.values(courseProgress)
            .filter((p) => p.completed && p.quizScore)
            .slice(-5) // Last 5 completed
            .map((p) => p.quizScore);

          if (
            recentScores.length >= 3 &&
            recentScores.every((s) => s === 100)
          ) {
            await checkAndUnlockAchievement("perfectionist_streak");
          }
        }
      }

      async function checkSpeedCompletionAchievements(completionTime) {
        // Speed demon: Complete course in under 2 hours (120 minutes)
        if (completionTime <= 120) {
          await checkAndUnlockAchievement("speed_demon");
        }

        // Quick learner: Complete course in under 4 hours (240 minutes)
        if (completionTime <= 240) {
          await checkAndUnlockAchievement("quick_learner");
        }
      }

      async function checkStudyTimeAchievements() {
        const totalTime = courseSession.totalStudyTime;

        // Marathon learner: Study for 8+ hours in a course session
        if (totalTime >= 480) {
          // 8 hours
          await checkAndUnlockAchievement("marathon_learner");
        }

        // Dedicated learner: Study for 4+ hours
        if (totalTime >= 240) {
          // 4 hours
          await checkAndUnlockAchievement("dedicated_learner");
        }
      }

      async function checkCourseStreakAchievements() {
        try {
          // Check for consecutive course completions
          const { data: recentCourses, error } = await supabase
            .from("course_progress")
            .select("completed_at, course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100)
            .order("completed_at", { ascending: false })
            .limit(10);

          if (error || !recentCourses) return;

          // Check for courses completed on consecutive days
          let consecutiveDays = 1;
          for (let i = 1; i < recentCourses.length; i++) {
            const prevDate = new Date(
              recentCourses[i - 1].completed_at
            ).toDateString();
            const currentDate = new Date(
              recentCourses[i].completed_at
            ).toDateString();
            const dayDiff =
              Math.abs(new Date(prevDate) - new Date(currentDate)) /
              (1000 * 60 * 60 * 24);

            if (dayDiff <= 1) {
              consecutiveDays++;
            } else {
              break;
            }
          }

          if (consecutiveDays >= 3) {
            await checkAndUnlockAchievement("learning_streak");
          }
        } catch (error) {
          console.error("Error checking course streak achievements:", error);
        }
      }

      // =====================================================
      // TIME-BASED ACHIEVEMENTS
      // =====================================================
      async function checkTimeBasedAchievements(timestamp) {
        const hour = timestamp.getHours();
        const dayOfWeek = timestamp.getDay();

        // Night owl (after midnight, before 6 AM)
        if (hour >= 0 && hour < 6) {
          await incrementTimeBasedCounter("midnight_sessions", "night_owl");
        }

        // Early bird (4 AM to 6 AM)
        if (hour >= 4 && hour < 6) {
          await incrementTimeBasedCounter("early_sessions", "early_bird");
        }

        // Weekend warrior (Saturday = 6, Sunday = 0)
        if (dayOfWeek === 0 || dayOfWeek === 6) {
          await incrementTimeBasedCounter(
            "weekend_sessions",
            "weekend_warrior"
          );
        }
      }

      async function incrementTimeBasedCounter(counterType, achievementId) {
        try {
          const dateStr = new Date().toISOString().split("T")[0];
          const cacheKey = `${counterType}_${currentUser.id}_${dateStr}`;

          // Prevent multiple increments per day
          if (sessionStorage.getItem(cacheKey)) return;

          // Update counter
          await supabase.rpc('increment_profile_counter', {
  user_id_param: currentUser.id,
  counter_field: counterType,
  increment_value: 1
});

          // Cache to prevent double counting
          sessionStorage.setItem(cacheKey, "true");

          // Check related achievement
          if (achievementId) {
            await checkAndUnlockAchievement(achievementId, true);
          }
        } catch (error) {
          console.error(`Error incrementing ${counterType}:`, error);
        }
      }

      async function checkDailyStreak() {
        try {
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("last_activity, current_streak, last_streak_date")
            .eq("id", currentUser.id)
            .single();

          if (error) throw error;

          const now = new Date();
          const today = now.toDateString();
          const lastActivity = profile.last_activity
            ? new Date(profile.last_activity)
            : null;
          const lastStreakDate = profile.last_streak_date
            ? new Date(profile.last_streak_date).toDateString()
            : null;

          let newStreak = profile.current_streak || 0;
          let shouldUpdateStreak = false;

          if (!lastActivity) {
            // First time user
            newStreak = 1;
            shouldUpdateStreak = true;
          } else {
            const daysSinceLastActivity = Math.floor(
              (now - lastActivity) / (1000 * 60 * 60 * 24)
            );

            if (lastStreakDate === today) {
              // Already counted today's streak
              return newStreak;
            } else if (
              daysSinceLastActivity === 1 ||
              (daysSinceLastActivity === 0 && lastStreakDate !== today)
            ) {
              // Consecutive day or same day but not counted yet
              newStreak += 1;
              shouldUpdateStreak = true;
            } else if (daysSinceLastActivity > 1) {
              // Streak broken
              newStreak = 1;
              shouldUpdateStreak = true;
            }
          }

          if (shouldUpdateStreak) {
            await supabase
              .from("profiles")
              .update({
                current_streak: newStreak,
                last_activity: now.toISOString(),
                last_streak_date: now.toISOString(),
              })
              .eq("id", currentUser.id);

            userStats.current_streak = newStreak;

            showToast(`Daily streak: ${newStreak} days!`, "success");
            await checkStreakAchievements(newStreak);
          }

          return newStreak;
        } catch (error) {
          console.error("Error checking daily streak:", error);
          return 0;
        }
      }

      async function checkStreakAchievements(currentStreak) {
        const streakMilestones = [3, 7, 14, 30, 100, 365];

        for (const milestone of streakMilestones) {
          if (currentStreak >= milestone) {
            await checkAndUnlockAchievement(`streak_${milestone}`);
          }
        }
      }

      // =====================================================
      // USER ACTIVITY LOGGING
      // =====================================================
      async function logUserActivity(activityType, metadata = {}) {
        try {
          const now = new Date();

          const activityData = {
            user_id: currentUser.id,
            activity_type: activityType,
            timestamp: now.toISOString(),
            course_id: COURSE_DATA.id,
            lesson_index: currentLessonIndex,
            session_duration: courseSession.totalStudyTime,
            metadata: JSON.stringify(metadata),
            created_at: now.toISOString(),
          };

          // Try to log to activities table
          const { error } = await supabase
            .from("user_activities")
            .insert([activityData]);

          if (error && error.code !== "42P01") {
            console.warn("Activity logging failed:", error.message);
          }

          // Always update last activity in profile
          await supabase
            .from("profiles")
            .update({ last_activity: now.toISOString() })
            .eq("id", currentUser.id);
        } catch (error) {
          console.error("Error logging user activity:", error);
        }
      }

      // =====================================================
      // NAVIGATION SYSTEM
      // =====================================================
      function updateNavigationButtons() {
        const prevBtn = document.getElementById("prevLessonBtn");
        const nextBtn = document.getElementById("nextLessonBtn");

        if (!prevBtn || !nextBtn) return;

        // Previous button
        prevBtn.disabled = currentLessonIndex === 0;

        // Next button logic
        const isLastLesson =
          currentLessonIndex === COURSE_DATA.lessons.length - 1;
        const canGoNext =
          currentLessonIndex < COURSE_DATA.lessons.length - 1 &&
          canAccessLesson(currentLessonIndex + 1);

        if (isLastLesson) {
          const isCurrentCompleted =
            courseProgress[COURSE_DATA.lessons[currentLessonIndex].id]
              ?.completed;
          nextBtn.disabled = !isCurrentCompleted;
          nextBtn.innerHTML = '<i class="fas fa-trophy"></i> Complete Course';
        } else {
          nextBtn.disabled = !canGoNext;
          nextBtn.innerHTML = 'Next <i class="fas fa-chevron-right"></i>';
        }
      }

      // Navigation button event handlers
      function goToPreviousLesson() {
        if (currentLessonIndex > 0) {
          trackLessonTime(); // Track time spent on current lesson
          currentLessonIndex--;
          loadLesson(currentLessonIndex);
        }
      }

      function goToNextLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          const canGoNext = canAccessLesson(currentLessonIndex + 1);
          if (canGoNext) {
            trackLessonTime();
            currentLessonIndex++;
            loadLesson(currentLessonIndex);
          } else {
            showToast("Complete the current lesson quiz to proceed", "warning");
          }
        } else {
          // Complete course
          completeCourse();
        }
      }

      // =====================================================
      // SIDEBAR FUNCTIONS
      // =====================================================
      function toggleSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.toggle("open");
        if (overlay) overlay.classList.toggle("active");
      }

      function closeSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.remove("open");
        if (overlay) overlay.classList.remove("active");
      }

      // =====================================================
      // ACHIEVEMENT NOTIFICATION SYSTEM
      // =====================================================
      function queueAchievementNotification(achievement) {
        notificationQueue.push(achievement);
        processNotificationQueue();
      }

      function processNotificationQueue() {
        if (isShowingNotification || notificationQueue.length === 0) return;

        isShowingNotification = true;
        const achievement = notificationQueue.shift();
        showAchievementNotification(achievement);

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          isShowingNotification = false;
          processNotificationQueue();
        }, duration + 500);
      }

      function showAchievementNotification(achievement) {
        const notification = document.getElementById("achievementNotification");
        if (!notification) return;

        const icon = document.getElementById("notificationIcon");
        const title = document.getElementById("notificationTitle");
        const description = document.getElementById("notificationDescription");
        const points = document.getElementById("notificationPoints");

        if (icon) {
          icon.innerHTML = `<i class="${achievement.icon}"></i>`;
          icon.className = `notification-icon ${achievement.rarity}`;
        }
        if (title) title.textContent = achievement.name;
        if (description) description.textContent = achievement.description;
        if (points) points.textContent = `+${achievement.points} Points`;

        notification.className = `achievement-notification ${achievement.rarity}`;
        notification.classList.add("show");

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          notification.classList.remove("show");
        }, duration);
      }

      // =====================================================
      // UTILITY FUNCTIONS
      // =====================================================
      function calculateAverageQuizScore() {
        const scores = Object.values(courseProgress)
          .filter((p) => p.completed && p.quizScore)
          .map((p) => p.quizScore);

        if (scores.length === 0) return 0;
        return Math.round(
          scores.reduce((sum, score) => sum + score, 0) / scores.length
        );
      }

      async function resetProgress() {
        if (
          !confirm(
            "Are you sure you want to reset your progress? This action cannot be undone."
          )
        ) {
          return;
        }

        try {
          // Track lesson time before reset
          trackLessonTime();

          // Reset local state
          courseProgress = {};
          currentLessonIndex = 0;
          courseSession = {
            startTime: new Date(),
            totalStudyTime: 0,
            lessonsStarted: 0,
            lessonsCompleted: 0,
            pageLoadTime: new Date(),
            interactionCount: 0,
            lastActivityTime: new Date(),
          };

          // Delete from database
          await supabase
            .from("course_progress")
            .delete()
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Log reset activity
          logUserActivity("progress_reset", {
            course_id: COURSE_DATA.id,
            reset_reason: "manual",
          });

          // Reinitialize
          await saveProgress();
          renderSidebar();
          loadLesson(0);

          showToast("Progress reset successfully", "success");
        } catch (error) {
          console.error("Error resetting progress:", error);
          showToast("Failed to reset progress", "error");
        }
      }

      function copyCode(codeId) {
        const codeElement = document.getElementById(codeId);
        if (!codeElement) return;

        const text = codeElement.textContent;

        navigator.clipboard
          .writeText(text)
          .then(() => {
            showToast("Code copied to clipboard!", "success");

            // Track code copy for achievements
            logUserActivity("code_copied", {
              code_section: codeId,
              lesson_id: COURSE_DATA.lessons[currentLessonIndex].id,
            });
          })
          .catch((err) => {
            console.error("Failed to copy code:", err);
            showToast("Failed to copy code", "error");

            // Fallback for older browsers
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            try {
              document.execCommand("copy");
              showToast("Code copied to clipboard!", "success");
            } catch (fallbackError) {
              showToast(
                "Copy failed - please select and copy manually",
                "error"
              );
            }
            document.body.removeChild(textArea);
          });
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // =====================================================
      // UI FEEDBACK SYSTEMS
      // =====================================================
      function showToast(message, type = "success") {
        const toast = document.getElementById("toast");
        const messageEl = document.getElementById("toastMessage");

        if (!toast || !messageEl) {
          console.log(`Toast: ${message} (${type})`);
          return;
        }

        messageEl.textContent = message;
        toast.className = `toast ${type} show`;

        setTimeout(() => {
          toast.classList.remove("show");
        }, 4000);
      }

      function showLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) loadingScreen.classList.remove("hidden");
      }

      function hideLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) {
          setTimeout(() => {
            loadingScreen.classList.add("hidden");
          }, 1000);
        }
      }

      // =====================================================
      // MUSIC PLAYER INTEGRATION
      // =====================================================
      function initMusicPlayer() {
        const btnText = document.getElementById("music-button-text");
        const icon = document.getElementById("music-icon");
        const dropdown = document.getElementById("music-dropdown-content");

        if (!btnText || !icon || !dropdown) return;

        function setUI(state) {
          btnText.textContent =
            state === "Playing" ? "PAUSE MUSIC" : "STUDY MUSIC";
          icon.className =
            state === "Playing"
              ? "fa-solid fa-circle-pause"
              : "fa-solid fa-music";
        }

        // Load saved music state
        const savedSrc = localStorage.getItem("cybersec_music_src");
        const savedTime = parseFloat(
          localStorage.getItem("cybersec_music_time") || 0
        );

        if (savedSrc) {
          audioPlayer.src = savedSrc;
          audioPlayer.currentTime = savedTime;
          audioPlayer
            .play()
            .then(() => setUI("Playing"))
            .catch(() => setUI("Stopped"));
        }

        // Music button click handler
        document
          .getElementById("music-dropdown")
          .querySelector("button")
          .addEventListener("click", (e) => {
            e.stopPropagation();
            dropdown.style.display =
              dropdown.style.display === "block" ? "none" : "block";

            if (audioPlayer.src && !audioPlayer.paused) {
              audioPlayer.pause();
              setUI("Stopped");
            } else if (audioPlayer.src) {
              audioPlayer.play().then(() => setUI("Playing"));
            }
          });

        // Music selection handlers
        dropdown.querySelectorAll("a[data-src]").forEach((link) => {
          link.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.src = link.dataset.src;
            audioPlayer.play().then(() => setUI("Playing"));
            localStorage.setItem("cybersec_music_src", link.dataset.src);
            dropdown.style.display = "none";
          });
        });

        // Stop music handler
        const stopLink = document.getElementById("stop-music-link");
        if (stopLink) {
          stopLink.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            audioPlayer.removeAttribute("src");
            setUI("Stopped");
            localStorage.removeItem("cybersec_music_src");
            localStorage.removeItem("cybersec_music_time");
            dropdown.style.display = "none";
          });
        }

        // Save music state before page unload
        window.addEventListener("beforeunload", () => {
          if (!audioPlayer.paused && audioPlayer.src) {
            localStorage.setItem("cybersec_music_src", audioPlayer.src);
            localStorage.setItem(
              "cybersec_music_time",
              audioPlayer.currentTime
            );
          }
        });

        // Close dropdown when clicking outside
        window.addEventListener("click", (e) => {
          if (!e.target.closest("#music-dropdown")) {
            dropdown.style.display = "none";
          }
        });
      }

      // Show initial music indicator
      function addMusicIndicator() {
        const musicBtn = document.querySelector("#music-dropdown");
        if (musicBtn) {
          const indicator = document.createElement("div");
          indicator.className = "music-indicator";
          indicator.innerHTML = `<i class="fa-solid fa-music"></i> Try Study Music!`;

          musicBtn.style.position = "relative";
          musicBtn.appendChild(indicator);

          setTimeout(() => indicator.remove(), 3000);
        }
      }

      // Initialize Event Listeners
      function initializeEventListeners() {
        // Navigation buttons
        document
          .getElementById("prevLessonBtn")
          ?.addEventListener("click", goToPreviousLesson);
        document
          .getElementById("nextLessonBtn")
          ?.addEventListener("click", goToNextLesson);

        // Reset progress button
        document
          .getElementById("resetProgressBtn")
          ?.addEventListener("click", resetProgress);

        // Mobile menu toggle
        document
          .getElementById("menuToggle")
          ?.addEventListener("click", toggleSidebar);
        document
          .getElementById("sidebarOverlay")
          ?.addEventListener("click", closeSidebar);

        // Keyboard shortcuts
        document.addEventListener("keydown", handleKeyboardShortcuts);

        // Window resize handler
        window.addEventListener("resize", handleWindowResize);

        // Content interaction tracking
        document.getElementById("contentBody")?.addEventListener(
          "scroll",
          debounce(() => {
            trackUserInteraction();
          }, 1000)
        );
      }

      // Keyboard Shortcuts
      function handleKeyboardShortcuts(e) {
        if (document.querySelector(".quiz-question.active")) return;

        if (e.key === "ArrowLeft" && e.ctrlKey) {
          e.preventDefault();
          goToPreviousLesson();
        } else if (e.key === "ArrowRight" && e.ctrlKey) {
          e.preventDefault();
          goToNextLesson();
        }
      }

      // Window Resize Handler
      function handleWindowResize() {
        if (window.innerWidth > 768) {
          closeSidebar();
        }
      }

      // Debounce Helper
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Initialize responsive behavior
      if (window.innerWidth <= 768) {
        document.getElementById("menuToggle").style.display = "inline-flex";
      }

      // Auto-save progress periodically
      setInterval(async () => {
        if (currentUser && Object.keys(courseProgress).length > 0) {
          await saveProgress();
        }
      }, 60000); // Save every minute

      // System initialization logging
      console.log("CyberSec Academy Course System Initialized");
      console.log("Current Course:", COURSE_DATA.title);
      console.log("Total Lessons:", COURSE_DATA.lessons.length);

      // Google OAuth Integration
      const googleBtn = document.querySelector(".btn-google");
      if (googleBtn) {
        googleBtn.addEventListener("click", async () => {
          const { data, error } = await supabase.auth.signInWithOAuth({
            provider: "google",
            options: {
              redirectTo:
                window.location.origin +
                "/courses/complete-code-review-security-course.html",
            },
          });

          if (error) {
            console.error("Google login error:", error.message);
            showToast("Google login failed: " + error.message, "error");
          }
        });
      }

      // Check for existing session
      supabase.auth.getSession().then(({ data }) => {
        if (data.session) {
          console.log("User already logged in:", data.session.user);
          currentUser = data.session.user;
          startCourseSession();
        }
      });

      // Add missing auth modal functions
      function openAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "flex";
        }
      }

      function closeAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Add auth tab switching functionality
      document.getElementById("tabSignIn")?.addEventListener("click", () => {
        document.getElementById("tabSignIn").classList.add("active");
        document.getElementById("tabSignUp").classList.remove("active");
        document.getElementById("signInForm").style.display = "block";
        document.getElementById("signUpForm").style.display = "none";
      });

      document.getElementById("tabSignUp")?.addEventListener("click", () => {
        document.getElementById("tabSignUp").classList.add("active");
        document.getElementById("tabSignIn").classList.remove("active");
        document.getElementById("signUpForm").style.display = "block";
        document.getElementById("signInForm").style.display = "none";
      });

      document
        .getElementById("closeAuthModal")
        ?.addEventListener("click", closeAuthModal);

      // Improved error handling for auth session
      supabase.auth.onAuthStateChange((event, session) => {
        if (event === "SIGNED_IN") {
          currentUser = session.user;
          closeAuthModal();
          startCourseSession();
        } else if (event === "SIGNED_OUT") {
          currentUser = null;
          openAuthModal();
        }
      });

      // Add form submission handlers
      document
        .getElementById("emailSignInForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signInEmail").value;
          const password = document.getElementById("signInPassword").value;

          try {
            const { data, error } = await supabase.auth.signInWithPassword({
              email,
              password,
            });

            if (error) throw error;

            closeAuthModal();
          } catch (error) {
            showToast(error.message, "error");
          }
        });

      document
        .getElementById("emailSignUpForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signUpEmail").value;
          const password = document.getElementById("signUpPassword").value;
          const name = document.getElementById("signUpName").value;

          try {
            const { data, error } = await supabase.auth.signUp({
              email,
              password,
              options: {
                data: {
                  full_name: name,
                },
              },
            });

            if (error) throw error;

            showToast(
              "Account created successfully! Please check your email.",
              "success"
            );
          } catch (error) {
            showToast(error.message, "error");
          }
        });
    </script>
  </body>
</html>

