



<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- ========== Start: SEO & Schema Enhancement ========== -->
    <title>Azure Security Fundamentals Course | CipherHall</title>
    <meta name="description" content="A 50-lesson roadmap to mastering Azure security. Learn Azure AD, VNet security, Key Vault, Sentinel, and prepare for certifications with hands-on labs.">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png" />
    <link rel="shortcut icon" href="/favicon.png" type="image/x-icon" />
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png" />
    <link rel="canonical" href="https://www.cipherhall.com/courses/azure-security-basics.html" />
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Course",
      "name": "Azure Security Basics",
      "description": "A comprehensive, 50-lesson course designed to take you from a foundational understanding of Azure security to an advanced practitioner, covering identity, network, data, applications, and operations.",
      "provider": {
        "@type": "Organization",
        "name": "CipherHall",
        "sameAs": "https://www.cipherhall.com"
      },
      "hasCourseInstance": {
        "@type": "CourseInstance",
        "courseMode": "Online",
        "instructor": {
          "@type": "Person",
          "name": "Dr. Fatima Al-Jamil"
        }
      }
    }
    </script>
    <!-- ========== End: SEO & Schema Enhancement ========== -->

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Exo+2:wght@700;800;900&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css"
    />
    <link rel="stylesheet" href="assets/css/coursepages.css">
</head>
  <body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
      <div class="loader-icon">
        <i class="fas fa-graduation-cap"></i>
      </div>
      <div class="loader-text">Loading Course Content...</div>
    </div>

    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- Music Player (fixed at top right) -->
    <div class="header-controls">
      <div class="music-dropdown" id="music-dropdown">
        <button class="btn btn-secondary">
          <span id="music-button-text">STUDY MUSIC</span>
          <i id="music-icon" class="fa-solid fa-music"></i>
        </button>
        <div class="music-dropdown-content" id="music-dropdown-content">
          <a
            href="#"
            data-src="https://www.learningcontainer.com/wp-content/uploads/2020/02/Kalimba.mp3"
            >1. Coffee Shop Vibes</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3"
            >2. City Lights Lofi</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-15.mp3"
            >3. Mellow Thoughts</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-13.mp3"
            >4. Rainy Mood</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3"
            >5. Time Alone</a
          >
          <a href="#" id="stop-music-link"
            ><i class="fa-solid fa-stop-circle"></i> Stop Music</a
          >
        </div>
      </div>

      <button class="btn btn-secondary" id="resetProgressBtn">
        <i class="fas fa-redo"></i>
        Reset Progress
      </button>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal" style="display: none">
      <div class="modal-overlay"></div>
      <div class="modal-content">
        <span class="close" id="closeAuthModal">&times;</span>
        <div class="auth-tabs">
          <button id="tabSignIn" class="auth-tab active">Sign In</button>
          <button id="tabSignUp" class="auth-tab">Sign Up</button>
        </div>
        <div
          id="authLoader"
          style="display: none; text-align: center; padding: 2rem"
        >
          <i
            class="fas fa-spinner fa-spin fa-2x"
            style="color: var(--color-green)"
          ></i>
          <p style="margin-top: 0.5rem">Authenticating...</p>
        </div>
        <div id="signInForm" class="auth-form">
          <h2>Sign In to CipherHall</h2>
          <button id="googleSignIn" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignInForm">
            <input
              type="email"
              id="signInEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signInPassword"
              placeholder="Password"
              required
            />
            <button type="submit" class="btn btn-primary">Sign In</button>
          </form>
        </div>
        <div id="signUpForm" class="auth-form" style="display: none">
          <h2>Join CipherHall</h2>
          <button id="googleSignUp" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignUpForm">
            <input
              type="text"
              id="signUpName"
              placeholder="Full Name"
              required
            />
            <input
              type="email"
              id="signUpEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signUpPassword"
              placeholder="Password (min. 8 characters)"
              required
            />
            <button type="submit" class="btn btn-secondary">
              Create Account
            </button>
          </form>
        </div>
        <div id="authMessage"></div>
      </div>
    </div>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="course-info">
          <h1 class="course-title" id="courseTitle">Loading...</h1>
          <div class="course-progress">
            <div class="progress-header">
              <span class="progress-label">Course Progress</span>
              <span class="progress-percentage" id="courseProgressPercent"
                >0%</span
              >
            </div>
            <div class="progress-bar">
              <div
                class="progress-fill"
                id="courseProgressFill"
                style="width: 0%"
              ></div>
            </div>
            <div class="progress-stats">
              <span id="completedLessons">0</span>
              <span id="totalLessons">0</span>
            </div>
          </div>
          <a href="/dashboard.html" class="back-to-dashboard">
            <i class="fas fa-arrow-left"></i>
            Back to Dashboard
          </a>
        </div>
      </div>

      <nav class="lesson-nav" id="lessonNav">
        <!-- Lessons will be loaded dynamically -->
      </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <header class="content-header">
        <div class="lesson-header">
          <div class="lesson-header-left">
            <span class="lesson-number" id="currentLessonNumber">1</span>
            <h1 class="lesson-header-title" id="currentLessonTitle">
              Loading...
            </h1>
          </div>
          <div class="lesson-actions">
            <button class="mbtn btn-primary" id="menuToggle">
              <i class="fas fa-bars"></i>
            </button>
          </div>
        </div>
      </header>

      <div class="content-body" id="contentBody">
        <div class="lesson-content" id="lessonContent">
          <!-- Lesson content will be loaded dynamically -->
        </div>
      </div>

      <footer class="lesson-navigation">
        <div class="nav-info" id="navInfo">Lesson 1 of 10</div>
        <div class="nav-controls">
          <button class="btn btn-secondary" id="prevLessonBtn" disabled>
            <i class="fas fa-chevron-left"></i>
            Previous
          </button>
          <button class="btn btn-primary" id="nextLessonBtn" disabled>
            Next
            <i class="fas fa-chevron-right"></i>
          </button>
        </div>
      </footer>
    </main>

    <!-- Achievement Notification -->
    <div id="achievementNotification" class="achievement-notification">
      <div class="notification-header">
        <div class="notification-icon" id="notificationIcon">
          <i class="fas fa-trophy"></i>
        </div>
        <div class="notification-content">
          <h3 id="notificationTitle">Achievement Unlocked!</h3>
          <p id="notificationDescription">Description here...</p>
        </div>
      </div>
      <div class="notification-reward" id="notificationReward">
        <i class="fas fa-coins"></i>
        <span id="notificationPoints">+100 Points</span>
      </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast">
      <span id="toastMessage"></span>
    </div>

    <script>
      // =====================================================
      // SYNCHRONIZED COURSE SYSTEM WITH DASHBOARD INTEGRATION
      // =====================================================

      // Supabase Configuration - Replace with your config
      const supabaseUrl = "https://lzcmzulemfubjaksoqor.supabase.co";
      const supabaseKey =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx6Y216dWxlbWZ1Ympha3NvcW9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzMzM5MDgsImV4cCI6MjA3MDkwOTkwOH0.crhPH4YWtRsr1BJTpAQcmPbWSpwIWRbzoI4sRb2_fPI";
      const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

      // =====================================================
      // COURSE DATA STRUCTURE - REPLACE WITH YOUR COURSE JSON
      // =====================================================
      const COURSE_DATA = {
        "id": "azure-security-basics",
        "title": "Azure Security Basics",
        "description": "A comprehensive, 50-lesson course designed to take you from a foundational understanding of Azure security to an advanced practitioner, covering identity, network, data, applications, and operations.",
        "category": "cloud-security",
        "difficulty": "Beginner to Advanced",
        "duration": "100 hours",
        "instructor": "Dr. Fatima Al-Jamil",
        "lessons": [
            {
                "id": "lesson-1-azure-security-overview",
                "title": "Lesson 1: Azure Security Overview",
                "duration": "120 min",
                "objectives": [
                    "Define the Azure Shared Responsibility Model",
                    "Differentiate between Security 'of' the Cloud and Security 'in' the Cloud",
                    "Understand Microsoft's security philosophy and principles like Zero Trust",
                    "Explore the Azure Trust Center and its compliance offerings"
                ],
                "content": {
                    "overview": "This foundational lesson introduces the core principles of security within the Microsoft Azure ecosystem. We will explore the critical Shared Responsibility Model, which defines your security duties versus Microsoft's, and lay the groundwork for a secure-by-design approach to cloud architecture.",
                    "sections": [
                        {
                            "title": "Azure Shared Responsibility Model",
                            "content": "<p>Understanding the division of responsibility is the single most important concept in cloud security. The model defines which security tasks are handled by the cloud provider (Microsoft) and which are handled by you, the customer. This varies depending on the service model (IaaS, PaaS, SaaS).</p><h3>Key Responsibilities:</h3><ul><li><strong>Microsoft is responsible for 'Security OF the Cloud':</strong> This encompasses the physical security of the datacenters (guards, gates, fences), the physical network infrastructure, and the physical hosts that run the cloud services.</li><li><strong>You are responsible for 'Security IN the Cloud':</strong> Your responsibility increases as you move from SaaS to PaaS to IaaS. At a minimum, you are always responsible for your data, your identities, and the configuration of the cloud services you use. In IaaS, you are also responsible for patching the operating system, network controls (NSGs), and the application.</li></ul><div class='info-box tip'><div class='info-box-header'><i class='fas fa-lightbulb'></i><strong>IaaS vs. PaaS Example</strong></div><p>In IaaS (a Virtual Machine), you are responsible for patching the Windows or Linux OS. In PaaS (an Azure App Service), Microsoft is responsible for patching the underlying OS, but you are still responsible for the security of your application code and managing who can access it.</p></div>",
                            "image": "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Azure Security Pillars and Zero Trust",
                            "content": "<p>Microsoft's security strategy is guided by a set of core principles, with Zero Trust being the most prominent. The Zero Trust model assumes a breach is possible and verifies each request as though it originates from an uncontrolled network. It is not about trusting a network location.</p><h3>The Three Principles of Zero Trust:</h3><ol><li><strong>Verify Explicitly:</strong> Always authenticate and authorize based on all available data points, including user identity, location, device health, service or workload, data classification, and anomalies.</li><li><strong>Use Least Privileged Access:</strong> Limit user access with Just-in-Time and Just-Enough-Access (JIT/JEA), risk-based adaptive policies, and data protection to help secure both data and productivity.</li><li><strong>Assume Breach:</strong> Minimize blast radius for breaches and prevent lateral movement by segmenting access by network, user, devices, and applications. Verify all sessions are encrypted end-to-end.</li></ol>",
                            "image": "https://images.unsplash.com/photo-1510915228340-29c85a43dcfe?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Compliance and Trust Center",
                            "content": "<p>Azure maintains the largest compliance portfolio of any cloud provider. The Microsoft Trust Center is the public-facing portal where you can find detailed information about security, privacy, and compliance, including audit reports and certifications.</p><h3>Key Services:</h3><ul><li><strong>Azure Trust Center:</strong> Public website with compliance documentation and security whitepapers.</li><li><strong>Azure Service Trust Portal:</strong> An authenticated portal where you can download sensitive audit reports (like ISO 27001 or SOC 2 Type II reports) to provide to your own auditors.</li><li><strong>Microsoft Defender for Cloud:</strong> The in-platform tool to monitor your compliance against specific benchmarks like PCI DSS or the CIS Controls.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1454165804606-c3d57bc86b40?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Check Your Secure Score (Azure CLI)",
                        "language": "bash",
                        "code": "# The Secure Score in Microsoft Defender for Cloud gives you a high-level view of your security posture.\naz security secure-score show"
                    },
                    {
                        "title": "List Compliance Standards in Defender for Cloud (PowerShell)",
                        "language": "powershell",
                        "code": "# Get the list of regulatory compliance standards applied to your subscription.\nGet-AzSecurityCompliance"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Under the Shared Responsibility Model for IaaS, who is responsible for patching the virtual machine's operating system?", "options": ["Microsoft", "The Customer", "The Internet Service Provider", "The hardware vendor"], "correct": 1, "explanation": "In an Infrastructure as a Service (IaaS) model, the customer is responsible for the virtual machine, including its OS, applications, and data. Microsoft manages the underlying hypervisor and physical infrastructure." },
                        { "id": 2, "question": "What is the core philosophy of the Zero Trust model?", "options": ["Trust all users inside the corporate network", "Never trust, always verify every access request", "Only trust administrator accounts", "Trust all devices with an antivirus installed"], "correct": 1, "explanation": "Zero Trust fundamentally changes the security paradigm from trusting a network perimeter to explicitly verifying every identity, device, and service for every access request." },
                        { "id": 3, "question": "Where can you download Microsoft's official audit reports, such as their SOC 2 report, for your own auditors?", "options": ["A public GitHub repository", "The Azure marketing page", "The Azure Service Trust Portal", "The Azure blog"], "correct": 2, "explanation": "The Service Trust Portal is the authenticated, official repository for Azure's sensitive compliance and audit documentation." }
                    ]
                }
            },
            {
                "id": "lesson-2-aad-fundamentals",
                "title": "Lesson 2: Azure Active Directory Fundamentals",
                "duration": "150 min",
                "objectives": [
                    "Differentiate between Azure AD and traditional on-premises Active Directory",
                    "Understand the concepts of an Azure AD Tenant and Directory",
                    "Perform user and group management in Azure AD",
                    "Use Administrative Units to delegate permissions"
                ],
                "content": {
                    "overview": "Azure Active Directory (Azure AD) is the heart of identity and access management for Microsoft's cloud. It is not just 'Active Directory in the cloud'; it is a modern, cloud-native identity platform. This lesson covers the fundamental concepts of Azure AD that every security professional must know.",
                    "sections": [
                        {
                            "title": "Azure AD vs On-Premises AD",
                            "content": "<p>While they share a name, Azure AD and on-premises Windows Server Active Directory (AD DS) are fundamentally different technologies with different purposes.</p><h3>Key Differences:</h3><ul><li><strong>Protocol:</strong> AD DS uses Kerberos and LDAP for authentication on the internal network. Azure AD is an HTTP/HTTPS service that uses modern protocols like SAML, OAuth 2.0, and OpenID Connect for web and cloud applications.</li><li><strong>Structure:</strong> AD DS is hierarchical, with domains, forests, and Organizational Units (OUs). Azure AD has a flat structure of users and groups within a single tenant.</li><li><strong>Purpose:</strong> AD DS is primarily for managing on-premises machines and resources. Azure AD is for managing access to cloud services like Microsoft 365 and Azure, as well as third-party SaaS applications.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1554224155-83e8b835d07a?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Tenant and Directory Concepts",
                            "content": "<p>When your organization signs up for a Microsoft cloud service, a dedicated Azure AD tenant is created.</p><ul><li><strong>Tenant:</strong> The tenant represents your organization. It is a dedicated and trusted instance of Azure AD. It's the ultimate container for all your organization's users, groups, and applications.</li><li><strong>Directory:</strong> The tenant contains one or more directories. The directory is the identity store that holds the users, groups, and other objects.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Administrative Units",
                            "content": "<p>Administrative Units (AUs) are an Azure AD resource that can contain other Azure AD resources, such as users and groups. They allow you to delegate administrative permissions over a specific subset of your directory. For example, you can create a 'Marketing Department' AU and assign a user the 'User Administrator' role scoped *only* to that AU. This allows them to manage users in the Marketing AU, but not anywhere else in the directory. It is Azure AD's equivalent to an on-premises OU for delegation.</p>",
                            "image": "https'://images.unsplash.com/photo-1552664730-d307ca884978?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Create an Azure AD User (Azure CLI)",
                        "language": "bash",
                        "code": "# Creates a new user in your Azure AD tenant.\naz ad user create --display-name \"Bob Ross\" --password \"aVeryComplexP@ssw0rd\" --user-principal-name bob.ross@yourtenant.onmicrosoft.com"
                    },
                    {
                        "title": "Create an Azure AD Group (PowerShell)",
                        "language": "powershell",
                        "code": "# Connect to Azure AD first with Connect-AzureAD\nNew-AzureADGroup -DisplayName \"Marketing Team\" -MailEnabled $false -SecurityEnabled $true -MailNickName \"marketing\""
                    },
                    {
                        "title": "Add a User to a Group (Azure CLI)",
                        "language": "bash",
                        "code": "az ad group member add --group \"Marketing Team\" --member-id (az ad user show --id bob.ross@yourtenant.onmicrosoft.com --query objectId -o tsv)"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What authentication protocols are primarily used by Azure AD?", "options": ["Kerberos and LDAP", "SAML, OAuth 2.0, and OpenID Connect", "NTP and DNSSEC", "SSH and FTP"], "correct": 1, "explanation": "Azure AD is a modern identity provider that uses HTTP-based federation protocols suitable for web and cloud applications." },
                        { "id": 2, "question": "What is an Azure AD Tenant?", "options": ["A virtual machine", "A dedicated and trusted instance of Azure AD that represents an organization", "A type of user account", "A network firewall"], "correct": 1, "explanation": "The tenant is the highest-level container, representing your entire organization in the Microsoft cloud." },
                        { "id": 3, "question": "Which Azure AD feature allows you to delegate administrative permissions over a specific subset of users, similar to an on-premises OU?", "options": ["A Security Group", "A Subscription", "An Administrative Unit", "A Resource Group"], "correct": 2, "explanation": "Administrative Units are the primary mechanism for scoped delegation of administrative roles in Azure AD." }
                    ]
                }
            },
            {
                "id": "lesson-3-identity-access-management",
                "title": "Lesson 3: Identity and Access Management",
                "duration": "150 min",
                "objectives": [
                    "Assign Azure Role-Based Access Control (RBAC) roles effectively",
                    "Understand how to use Privileged Identity Management (PIM) for just-in-time access",
                    "Configure Access Reviews to ensure permissions remain appropriate",
                    "Differentiate between Azure AD roles and Azure RBAC roles"
                ],
                "content": {
                    "overview": "While Azure AD manages identities, Azure RBAC controls access to Azure *resources* like virtual machines and storage accounts. This lesson covers the crucial concepts of RBAC, Privileged Identity Management (PIM), and other governance features for enforcing least privilege in your Azure environment.",
                    "sections": [
                        {
                            "title": "Role-Based Access Control (RBAC)",
                            "content": "<p>Azure RBAC is how you grant permissions to Azure resources. The system is built on three key components:</p><ul><li><strong>Security Principal:</strong> An object that represents a user, group, service principal (application), or managed identity.</li><li><strong>Role Definition:</strong> A collection of permissions. Azure has many built-in roles like `Owner` (full access), `Contributor` (can create and manage resources, but not grant access), and `Reader` (view-only). You can also create custom roles.</li><li><strong>Scope:</strong> The boundary at which the access applies. You can assign roles at different levels: Management Group (a collection of subscriptions), Subscription, Resource Group, or an individual Resource. Permissions are inherited down the hierarchy.</li></ul><p>An RBAC assignment is the process of attaching a role definition to a security principal at a specific scope.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Privileged Identity Management (PIM)",
                            "content": "<p>PIM is a powerful Azure AD Premium P2 feature for managing, controlling, and monitoring access to important resources. It provides just-in-time (JIT) privileged access.</p><h3>How PIM Works:</h3><p>Instead of making a user a permanent `Global Administrator` or `Subscription Owner`, you make them *eligible* for the role. When they need to perform a privileged task, they go to the PIM portal to 'activate' their role. This can require an approval workflow, an MFA check, and a justification ticket number. The user is then granted the role for a limited time (e.g., 4 hours). All activations are fully audited. This is a core component of a least privilege strategy.</p>",
                            "image": "https://images.unsplash.com/photo-1556742044-15b56a42a033?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Azure AD Roles vs. Azure RBAC Roles",
                            "content": "<p>This is a critical distinction that often confuses beginners.</p><ul><li><strong>Azure AD Roles:</strong> Manage permissions for Azure AD resources *only*. Examples include `User Administrator`, `Application Administrator`, and `Global Administrator`. They grant permissions within the Azure AD directory.</li><li><strong>Azure RBAC Roles:</strong> Manage permissions for Azure resources *only*. Examples include `Owner`, `Contributor`, `Virtual Machine Contributor`, and `Storage Blob Data Reader`. They grant permissions to the Azure resource hierarchy (subscriptions, resource groups, etc.).</li></ul>",
                            "image": "https://images.unsplash.com/photo-1516321497487-e288fb19713f?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Assign a Role at a Resource Group Scope (Azure CLI)",
                        "language": "bash",
                        "code": "# Assign the 'Virtual Machine Contributor' role to a user for the 'MyProdRG' resource group.\naz role assignment create --assignee \"bob.ross@yourtenant.onmicrosoft.com\" --role \"Virtual Machine Contributor\" --resource-group \"MyProdRG\""
                    },
                    {
                        "title": "Create a Custom RBAC Role (JSON)",
                        "language": "json",
                        "code": "{\n  \"Name\": \"Virtual Machine Operator\",\n  \"IsCustom\": true,\n  \"Description\": \"Can monitor and restart virtual machines.\",\n  \"Actions\": [\n    \"Microsoft.Compute/virtualMachines/start/action\",\n    \"Microsoft.Compute/virtualMachines/restart/action\",\n    \"Microsoft.Compute/virtualMachines/read\"\n  ],\n  \"NotActions\": [],\n  \"AssignableScopes\": [\n    \"/subscriptions/your_subscription_id\"\n  ]\n}"
                    },
                    {
                        "title": "Make a User Eligible for an Azure AD Role in PIM (PowerShell)",
                        "language": "powershell",
                        "code": "# Make a user eligible for the 'Security Administrator' role in Azure AD.\nAdd-AzureADMSPrivilegedRoleAssignment -ProviderId 'aadRoles' -ResourceId 'your_tenant_id' -RoleId 'the_role_definition_id' -SubjectId 'the_user_object_id' -AssignmentState 'Eligible' -Type 'Admin'"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "You want to grant a user the ability to manage virtual machines in a specific resource group, but not any other resources. Which is the most appropriate role and scope?", "options": ["'Owner' at the subscription scope", "'Contributor' at the subscription scope", "'Virtual Machine Contributor' at the resource group scope", "'Reader' at the management group scope"], "correct": 2, "explanation": "This follows the principle of least privilege by granting the narrowest permissions ('Virtual Machine Contributor') at the smallest necessary scope (the specific resource group)." },
                        { "id": 2, "question": "The `Global Administrator` role is an example of what?", "options": ["An Azure RBAC role", "An Azure AD role", "A custom role", "A resource group"], "correct": 1, "explanation": "Global Administrator grants permissions to manage the Azure AD service itself, making it an Azure AD role." },
                        { "id": 3, "question": "What is the primary security benefit of using Privileged Identity Management (PIM)?", "options": ["It makes user passwords stronger", "It provides just-in-time (JIT) access, reducing the number of standing privileged accounts", "It monitors network traffic", "It backs up your data"], "correct": 1, "explanation": "PIM dramatically improves security by converting permanent, standing administrative access into temporary, on-demand, and audited access." },
                        { "id": 4, "question": "Permissions in Azure RBAC are inherited. If you are granted the `Reader` role at a subscription level, what access do you have to the resource groups within that subscription?", "options": ["No access", "You inherit the Reader role for all resource groups", "You are automatically granted Contributor access", "You have to request access to each resource group individually"], "correct": 1, "explanation": "RBAC permissions flow down the hierarchy. Permissions assigned at a higher scope are inherited by all child scopes." }
                    ]
                }
            },
            {
                "id": "lesson-4-mfa",
                "title": "Lesson 4: Multi-Factor Authentication",
                "duration": "120 min",
                "objectives": [
                    "Understand different MFA methods available in Azure AD",
                    "Build and apply Conditional Access policies to enforce MFA",
                    "Configure risk-based authentication using Azure AD Identity Protection",
                    "Enable and configure Self-Service Password Reset (SSPR)"
                ],
                "content": {
                    "overview": "Passwords alone are not enough. Multi-Factor Authentication (MFA) is one of the single most effective security controls you can implement. This lesson covers how to enforce MFA in Azure AD, using the powerful Conditional Access engine to apply it intelligently.",
                    "sections": [
                        {
                            "title": "Conditional Access Policies",
                            "content": "<p>Conditional Access is the 'brain' of Azure AD's modern authentication system. It acts as a policy engine that evaluates every single sign-in attempt and enforces specific actions. A Conditional Access policy is a powerful 'if-then' statement.</p><h3>The If-Then Logic:</h3><ul><li><strong>IF (Conditions / Signals):</strong> The policy evaluates signals from the sign-in. This includes the **user** or group, the **application** they are trying to access, their **location** (IP address), the **device** they are using (is it compliant?), and the real-time **sign-in risk**.</li><li><strong>THEN (Controls / Actions):</strong> If the conditions are met, the policy enforces a control. The most common control is `Grant access, but require Multi-Factor Authentication`. Other controls include `Block access` or `Require compliant device`.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Risk-Based Authentication",
                            "content": "<p>Azure AD Identity Protection is a premium feature that uses machine learning to detect risk during a sign-in. It analyzes billions of signals to identify risky behaviors.</p><h3>Risk Types:</h3><ul><li><strong>Sign-in Risk:</strong> The risk of a specific authentication request (e.g., login from an anonymous IP address, impossible travel).</li><li><strong>User Risk:</strong> The overall risk of the user account itself (e.g., their credentials have been found on the dark web).</li></ul><p>You can use these risk levels as a condition in your Conditional Access policies. For example, you can create a policy that says 'IF sign-in risk is Medium or High, THEN require MFA and force a password reset'. This provides adaptive, risk-based security.</p>",
                            "image": "https://images.unsplash.com/photo-1614064548237-02f8f17374b2?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Example Conditional Access Policy Logic (Pseudocode)",
                        "language": "markdown",
                        "code": "**Name:** Require MFA for Admins\n\n**APPLIES TO (Users/Groups):**\n  - All users assigned to an Administrator role.\n\n**APPLIES TO (Cloud Apps):**\n  - All Cloud Apps.\n\n**CONDITIONS:**\n  - None.\n\n**GRANT CONTROLS:**\n  - Grant access\n  - **Require Multi-Factor Authentication**"
                    },
                    {
                        "title": "Example Risk-Based Conditional Access Policy Logic",
                        "language": "markdown",
                        "code": "**Name:** Block High Risk Sign-ins\n\n**APPLIES TO (Users/Groups):**\n  - All users.\n\n**APPLIES TO (Cloud Apps):**\n  - All Cloud Apps.\n\n**CONDITIONS:**\n  - **Sign-in Risk: High**\n\n**GRANT CONTROLS:**\n  - **Block Access**"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the core tool used in Azure AD to enforce MFA and other access requirements based on a set of signals?", "options": ["Network Security Groups", "Azure Policy", "Conditional Access Policies", "Resource Groups"], "correct": 2, "explanation": "Conditional Access is the 'if-then' policy engine that is central to modern authentication and Zero Trust in Azure AD." },
                        { "id": 2, "question": "A Conditional Access policy that requires MFA only when a user is signing in from an untrusted network is using what as a condition/signal?", "options": ["The user's identity", "The application being accessed", "The user's location (IP address)", "The time of day"], "correct": 2, "explanation": "Location is a common signal, allowing you to create policies that are more relaxed for users inside a trusted corporate network and stricter for those outside." },
                        { "id": 3, "question": "Azure AD Identity Protection uses machine learning to assess what?", "options": ["The cost of your subscription", "The compliance of your devices", "The real-time risk of a user account or a specific sign-in attempt", "The number of users in your directory"], "correct": 2, "explanation": "Identity Protection provides the dynamic risk signals that enable powerful, adaptive, risk-based authentication policies." },
                        { "id": 4, "question": "Which of the following is considered the strongest MFA method?", "options": ["SMS text message", "An authenticator app with a number-matching prompt (like Microsoft Authenticator)", "A security question", "A phone call"], "correct": 1, "explanation": "App-based authenticators that use number matching are resistant to prompt-spamming (MFA fatigue) attacks, and unlike SMS, are not vulnerable to SIM-swapping attacks." }
                    ]
                }
            },
            {
                "id": "lesson-5-vnet-security",
                "title": "Lesson 5: Virtual Network Security",
                "duration": "150 min",
                "objectives": [
                    "Design a secure Virtual Network (VNet) architecture using a hub-and-spoke model",
                    "Implement network segmentation with Network Security Groups (NSGs)",
                    "Differentiate between and use Service Endpoints and Private Endpoints",
                    "Build a secure VNet from scratch in a lab environment"
                ],
                "content": {
                    "overview": "The Azure Virtual Network (VNet) is the fundamental building block for your private network in Azure. Securing your VNet through proper segmentation and firewalling is the first step in infrastructure protection. This lesson covers the best practices for secure VNet design.",
                    "sections": [
                        {
                            "title": "VNet Architecture and Segmentation",
                            "content": "<p>A VNet enables Azure resources like VMs to securely communicate with each other, the internet, and your on-premises networks. The most important security practice is to segment your VNet into multiple subnets.</p><h3>The Subnet Tiers:</h3><p>A typical three-tier application architecture would use three subnets:</p><ul><li><strong>Web Tier Subnet:</strong> Contains your public-facing web servers. This is the only subnet that might allow inbound traffic from the internet (on port 443).</li><li><strong>Application Tier Subnet:</strong> Contains your backend application servers. This subnet should only allow traffic from the Web Tier Subnet.</li><li><strong>Data Tier Subnet:</strong> Contains your database servers. This is the most secure subnet and should only allow traffic from the Application Tier Subnet on the specific database port.</li></ul><p>This segmentation limits the blast radius. If a web server is compromised, the attacker does not have immediate, direct network access to the database.</p>",
                            "image": "https://images.unsplash.com/photo-1461749280684-dccba630e2f6?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Service Endpoints and Private Endpoints",
                            "content": "<p>By default, if your VM in a private subnet needs to access a PaaS service like Azure Storage, that traffic goes over the public internet to the service's public endpoint. Service Endpoints and Private Endpoints allow you to keep this traffic on the secure Azure backbone network.</p><ul><li><strong>Service Endpoints:</strong> Provide a secure, direct connection to specific Azure services. The service endpoint remains a publicly addressable IP, but the route to it from your VNet stays on the Azure network.</li><li><strong>Private Endpoints (using Private Link):</strong> This is the more modern and secure method. It projects the PaaS service *into* your VNet. A Private Endpoint creates a network interface in your private subnet with a private IP address from your VNet's address space. The PaaS service effectively becomes part of your private network.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Create a Virtual Network and Subnets (Azure CLI)",
                        "language": "bash",
                        "code": "# Create the VNet\naz network vnet create -g MyResourceGroup -n MyVNet --address-prefix 10.1.0.0/16\n\n# Create the subnets\naz network vnet subnet create -g MyResourceGroup --vnet-name MyVNet -n WebSubnet --address-prefixes 10.1.1.0/24\naz network vnet subnet create -g MyResourceGroup --vnet-name MyVNet -n AppSubnet --address-prefixes 10.1.2.0/24"
                    },
                    {
                        "title": "Create a Network Security Group (NSG) and a Rule (Azure CLI)",
                        "language": "bash",
                        "code": "# Create the NSG\naz network nsg create -g MyResourceGroup -n WebServer-NSG\n\n# Create a rule to allow inbound HTTPS traffic\naz network nsg rule create -g MyResourceGroup --nsg-name WebServer-NSG -n AllowHTTPS --priority 100 \\\n    --source-address-prefixes Internet --destination-address-prefixes '*' \\\n    --destination-port-ranges 443 --direction Inbound --access Allow --protocol Tcp"
                    },
                    {
                        "title": "Associate an NSG with a Subnet (PowerShell)",
                        "language": "powershell",
                        "code": "$vnet = Get-AzVirtualNetwork -Name MyVNet -ResourceGroupName MyResourceGroup\n$nsg = Get-AzNetworkSecurityGroup -Name WebServer-NSG -ResourceGroupName MyResourceGroup\n\nSet-AzVirtualNetworkSubnetConfig -Name WebSubnet -VirtualNetwork $vnet -AddressPrefix 10.1.1.0/24 -NetworkSecurityGroup $nsg\n\n$vnet | Set-AzVirtualNetwork"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary tool for filtering network traffic between Azure resources in a VNet?", "options": ["Azure Policy", "IAM Roles", "Network Security Groups (NSGs)", "Azure Firewall"], "correct": 2, "explanation": "NSGs are the fundamental, distributed firewalling capability for Azure VNets, operating at Layer 4 (TCP/UDP)." },
                        { "id": 2, "question": "The best practice of creating separate Web, Application, and Data subnets is an example of what?", "options": ["Network segmentation", "Encryption at rest", "Multi-factor authentication", "Incident response"], "correct": 0, "explanation": "Segmentation is a core security principle that limits the blast radius of a potential compromise." },
                        { "id": 3, "question": "What is the primary security benefit of using a Private Endpoint to connect to a PaaS service like Azure Storage?", "options": ["It makes the storage account faster", "It assigns a private IP address from your VNet to the PaaS service, ensuring traffic never leaves the Azure private network", "It encrypts the data at rest", "It makes the storage account public"], "correct": 1, "explanation": "Private Endpoints are the premier solution for securing PaaS services by integrating them directly into your private network space." }
                    ]
                }
            },
            {
                "id": "lesson-6-azure-firewall",
                "title": "Lesson 6: Azure Firewall and Network Security",
                "duration": "120 min",
                "objectives": [
                    "Deploy and configure Azure Firewall as a central network control point",
                    "Understand the difference between Azure Firewall and an NSG",
                    "Implement central firewall management with Azure Firewall Manager",
                    "Enable and configure DDoS Protection Standard"
                ],
                "content": {
                    "overview": "While NSGs provide distributed firewalling, Azure Firewall provides a centralized, stateful firewall-as-a-service. This lesson covers how to deploy Azure Firewall in a hub-and-spoke topology to inspect and control all inbound and outbound network traffic.",
                    "sections": [
                        {
                            "title": "Azure Firewall vs. NSGs",
                            "content": "<table><tr><th>Feature</th><th>Network Security Group (NSG)</th><th>Azure Firewall</th></tr><tr><td>**Purpose**</td><td>Distributed, micro-segmentation</td><td>Centralized, network edge security</td></tr><tr><td>**Layer**</td><td>Layer 4 (TCP, UDP, IP)</td><td>Layer 4 and Layer 7 (HTTP, FQDN)</td></tr><tr><td>**Intelligence**</td><td>No</td><td>Yes, threat intelligence-based filtering</td></tr><tr><td>**Cost**</td><td>Free</td><td>Paid service</td></tr></table><p>NSGs are for filtering traffic *between* subnets and VMs within your VNet. Azure Firewall is for filtering all traffic *leaving* your VNet (egress) or coming *into* your VNet from the internet or on-premises (ingress).</p>",
                            "image": "https://images.unsplash.com/photo-1544890225-2fde1e46f71b?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Hub and Spoke Topology",
                            "content": "<p>The standard architecture is to deploy a single Azure Firewall into a central 'hub' VNet. All your application 'spoke' VNets are then peered to the hub. You use User-Defined Routes (UDRs) to force all outbound traffic from the spoke VNets to be routed through the Azure Firewall in the hub for inspection. This provides a single, central point for managing and auditing all egress traffic.</p>",
                            "image": "https://images.unsplash.com/photo-1461749280684-dccba630e2f6?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "DDoS Protection",
                            "content": "<p>Azure provides two tiers of DDoS protection.</p><ul><li><strong>Basic:</strong> Enabled by default on all public IPs at no extra charge. Protects against common volumetric attacks.</li><li><strong>Standard:</strong> A paid service that provides much more advanced, adaptive protection for your specific applications. It uses machine learning to baseline your normal traffic patterns and can detect and mitigate more sophisticated attacks. It also provides access to the DDoS Rapid Response team and cost protection against billing spikes during an attack.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1599691888286-93e433f064b8?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Create an Azure Firewall and a Public IP (Azure CLI)",
                        "language": "bash",
                        "code": "# Note: Firewall requires a dedicated subnet named 'AzureFirewallSubnet'\naz network public-ip create -g MyResourceGroup -n MyFirewall-IP --sku Standard\n\naz network firewall create -g MyResourceGroup -n MyFirewall -l westus2"
                    },
                    {
                        "title": "Create a Firewall Application Rule (Azure CLI)",
                        "language": "bash",
                        "code": "# This rule allows outbound access from any source to specific FQDNs on HTTP/HTTPS.\naz network firewall application-rule create -g MyResourceGroup -f MyFirewall \\\n    --collection-name \"Allow-Updates\" --action Allow --priority 100 \\\n    --rule-name \"Allow Windows Update\" \\\n    --source-addresses \"*\" --protocols Http=80 Https=443 \\\n    --target-fqdns \"*.windowsupdate.com\" \"*.microsoft.com\""
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is a primary advantage of Azure Firewall over Network Security Groups?", "options": ["It is free", "It can operate at Layer 7 and filter traffic based on Fully Qualified Domain Names (FQDNs)", "It is stateless", "It can only be applied to VMs, not subnets"], "correct": 1, "explanation": "This Layer 7 capability allows you to create much more intelligent egress filtering rules than an NSG, which can only filter by IP address." },
                        { "id": 2, "question": "In the hub-and-spoke model, what is used to force traffic from spoke VNets to go through the Azure Firewall in the hub?", "options": ["VNet Peering", "Network Security Groups", "User-Defined Routes (UDRs)", "IAM Roles"], "correct": 2, "explanation": "A UDR is a custom route table that overrides Azure's default routing. You create a default route (0.0.0.0/0) that points to the firewall as the next hop." },
                        { "id": 3, "question": "Azure DDoS Protection Standard offers what key benefit over the Basic tier?", "options": ["It is enabled for free by default", "It offers adaptive, machine-learning based protection tailored to your applications and cost protection", "It protects against on-premises attacks", "It protects against malware"], "correct": 1, "explanation": "The advanced tuning, expert support, and financial protection are the key value propositions of the Standard tier for mission-critical applications." }
                    ]
                }
            },
            {
                "id": "lesson-7-load-balancer-security",
                "title": "Lesson 7: Load Balancer and Application Gateway Security",
                "duration": "120 min",
                "objectives": [
                    "Deploy an Application Gateway with the Web Application Firewall (WAF)",
                    "Configure WAF rules to protect against the OWASP Top 10",
                    "Securely implement SSL/TLS termination",
                    "Secure backend pools to ensure they only accept traffic from the load balancer"
                ],
                "content": {
                    "overview": "Load balancing services are a critical ingress point to your applications. Securing them is paramount. This lesson focuses on the security features of Azure Load Balancer and, more importantly, the Web Application Firewall (WAF) capabilities of Azure Application Gateway.",
                    "sections": [
                        {
                            "title": "Application Gateway WAF",
                            "content": "<p>Azure Application Gateway is a Layer 7 load balancer. Its most important security feature is the optional, integrated Web Application Firewall (WAF). The WAF can be deployed in two modes:</p><ul><li><strong>Detection Mode:</strong> The WAF monitors and logs all alerts, but does not block traffic. This is useful for testing and tuning.</li><li><strong>Prevention Mode:</strong> The WAF actively blocks any requests that match its rules.</li></ul><h3>OWASP Top 10 Protection:</h3><p>The WAF provides managed rule sets that are designed to protect against the most common web application vulnerabilities, including:</p><ul><li>SQL Injection (SQLi)</li><li>Cross-Site Scripting (XSS)</li><li>Command Injection</li><li>HTTP Protocol Violations</li></ul>",
                            "image": "https://images.unsplash.com/photo-1605379399642-870262d3d051?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Securing Backend Pools",
                            "content": "<p>A common misconfiguration is to only protect the load balancer, but leave the backend servers exposed. An attacker could bypass the WAF and connect directly to a backend VM's public IP.</p><h3>The Correct Architecture:</h3><ol><li>Place your backend servers in a private subnet. They should not have public IP addresses.</li><li>Create an NSG for the backend subnet.</li><li>In the NSG, create an inbound rule that allows traffic *only* from the Application Gateway's subnet on the required application port. This ensures that the *only* way to reach the backend servers is by going through the WAF.</li></ol>",
                            "image": "https://images.unsplash.com/photo-1498050108023-c5249f4df085?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary function of the WAF feature in Azure Application Gateway?", "options": ["To distribute traffic evenly", "To protect web applications from common exploits like SQL injection and XSS", "To provide DDoS protection", "To perform network address translation"], "correct": 1, "explanation": "The WAF is a Layer 7 firewall specifically designed to inspect and filter HTTP/S traffic to block application-layer attacks." },
                        { "id": 2, "question": "What is the best way to ensure attackers cannot bypass your Application Gateway and connect directly to your backend web servers?", "options": ["Placing the backend servers in a public subnet with large NSG rules", "Publishing the public IPs of your backend servers", "Placing the backend servers in a private subnet and using an NSG to restrict inbound traffic to only come from the Application Gateway", "Disabling the WAF"], "correct": 2, "explanation": "This is a critical architectural principle for ensuring a strong defense-in-depth posture for your web applications." }
                    ]
                }
            },
            {
                "id": "lesson-8-vpn-hybrid-connectivity",
                "title": "Lesson 8: VPN and Hybrid Connectivity",
                "duration": "120 min",
                "objectives": [
                    "Implement a secure Site-to-Site VPN to connect on-premises networks",
                    "Configure a Point-to-Site VPN for secure remote user access",
                    "Understand the security architecture of ExpressRoute",
                    "Explore Azure Virtual WAN as a managed hub-and-spoke service"
                ],
                "content": {
                    "overview": "For hybrid cloud environments, a secure connection between your on-premises datacenter and Azure is essential. This lesson covers the primary methods for establishing this connectivity: IPsec VPNs and the dedicated ExpressRoute service.",
                    "sections": [
                        {
                            "title": "VPN Gateway Security",
                            "content": "<p>An Azure VPN Gateway uses the standard IPsec protocol to create encrypted tunnels over the public internet.</p><ul><li><strong>Site-to-Site (S2S) VPN:</strong> Connects your entire on-premises network to your Azure VNet. This requires a compatible VPN device in your datacenter.</li><li><strong>Point-to-Site (P2S) VPN:</strong> Connects a single, individual client computer to your Azure VNet. This is ideal for secure remote access for employees. P2S VPNs can integrate with Azure AD for authentication, allowing you to enforce MFA and Conditional Access policies for remote user access.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "ExpressRoute Security",
                            "content": "<p>Azure ExpressRoute provides a private, dedicated, high-throughput network connection between your on-premises network and Azure. Unlike a VPN, ExpressRoute traffic does not traverse the public internet.</p><h3>Security Considerations:</h3><ul><li><strong>Private Peering:</strong> The standard offering, which provides a direct private extension of your on-premises network into your Azure VNets.</li><li><strong>Encryption:</strong> By default, traffic over ExpressRoute is not encrypted (as it is on a private network). However, for the highest level of security, you can configure MACsec encryption at the hardware layer or run an IPsec VPN tunnel *over* your ExpressRoute circuit to provide end-to-end encryption.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Which hybrid connectivity method uses the public internet?", "options": ["ExpressRoute", "A VNet-to-VNet connection", "A Site-to-Site VPN", "A private endpoint"], "correct": 2, "explanation": "A VPN Gateway creates a secure, encrypted tunnel *over* the public internet. ExpressRoute uses a private, dedicated circuit that bypasses the public internet." },
                        { "id": 2, "question": "To provide secure remote access for individual employees to your Azure VNet and enforce Azure AD MFA, which solution is the best fit?", "options": ["ExpressRoute", "A Site-to-Site VPN", "A Point-to-Site (P2S) VPN", "Making the VNet public"], "correct": 2, "explanation": "P2S VPNs are specifically designed for individual client access and their integration with Azure AD makes them a very secure choice for remote workforces." }
                    ]
                }
            },
            {
                "id": "lesson-9-storage-account-security",
                "title": "Lesson 9: Storage Account Security",
                "duration": "120 min",
                "objectives": [
                    "Secure storage accounts using RBAC and Shared Access Signatures (SAS)",
                    "Implement Storage Service Encryption (SSE) with managed and customer-managed keys",
                    "Restrict network access to storage accounts using firewalls and virtual network rules"
                ],
                "content": {
                    "overview": "Azure Storage accounts are a foundational service, but like S3 in AWS, they can be a common source of data leaks if misconfigured. This lesson is dedicated to the layered security model for protecting your data in Azure Storage.",
                    "sections": [
                        {
                            "title": "Storage Account Authentication",
                            "content": "<p>There are several ways to authenticate to a storage account, but the best practice is to use Azure AD.</p><ul><li><strong>Azure AD Integration (Recommended):</strong> The most secure method. Assign RBAC roles (like `Storage Blob Data Reader` or `Storage Blob Data Contributor`) to users, groups, or managed identities. This provides centralized, auditable access.</li><li><strong>Account Access Keys:</strong> These are the 'root' keys for the storage account, granting full access. They should be treated like a root password and used sparingly. Your application should not use these keys; it should use a Managed Identity with RBAC permissions instead.</li><li><strong>Shared Access Signatures (SAS):</strong> A SAS token is a signed URI that grants delegated, time-limited access to a specific resource (like a single file) with specific permissions (like read-only). This is a secure way to grant temporary access to a client application without giving them a permanent key.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542382156942-0268579cf259?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Network Access Controls",
                            "content": "<p>By default, a storage account is accessible over the public internet. You must restrict this access.</p><ul><li><strong>Storage Firewall:</strong> You can configure the storage account's built-in firewall to only allow connections from specific IP address ranges.</li><li><strong>Virtual Network Service Endpoints/Private Endpoints:</strong> The best practice is to disable public internet access entirely and only allow access from specific virtual networks using service endpoints or, even better, a private endpoint that brings the storage account into your VNet's private IP space.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1599691888286-93e433f064b8?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Add a Network Rule to a Storage Account (Azure CLI)",
                        "language": "bash",
                        "code": "# Get the ID of the subnet you want to allow\nSUBNET_ID=$(az network vnet subnet show -g MyResourceGroup --vnet-name MyVNet -n AppSubnet --query id -o tsv)\n\n# Set the default action to Deny and add an exception for the subnet\naz storage account update -g MyResourceGroup -n mystorageaccount --default-action Deny\naz storage account network-rule add -g MyResourceGroup -n mystorageaccount --subnet $SUBNET_ID"
                    },
                    {
                        "title": "Generate a SAS Token for a Blob (PowerShell)",
                        "language": "powershell",
                        "code": "# Grant read access to a specific blob for 1 hour\n$context = New-AzStorageContext -StorageAccountName mystorageaccount -StorageAccountKey 'your_key'\n$sasToken = New-AzStorageBlobSASToken -Container 'mycontainer' -Blob 'myblob.txt' -Permission 'r' -ExpiryTime (Get-Date).AddHours(1) -Context $context"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is a Shared Access Signature (SAS) token?", "options": ["A permanent, root-level key for a storage account", "A way to make a storage account public", "A signed URI that grants delegated, time-limited access to a specific storage resource", "An encryption key"], "correct": 2, "explanation": "SAS tokens are the primary mechanism for granting secure, temporary, and limited permissions to clients without giving them a long-term secret." },
                        { "id": 2, "question": "To allow access to a storage account only from within a specific VNet and block all internet access, what should you use?", "options": ["Shared Access Signatures", "A WAF", "The storage account firewall and VNet private endpoints", "Azure AD"], "correct": 2, "explanation": "These network controls are the essential tools for isolating your storage account from the public internet." },
                        { "id": 3, "question": "What is the most secure way for an application running on an Azure VM to access a storage account?", "options": ["Storing the account access key in a text file on the VM", "Using a SAS token with a 10-year expiry", "Using a Managed Identity assigned to the VM with an RBAC role like 'Storage Blob Data Reader'", "Making the storage account anonymous"], "correct": 2, "explanation": "Managed Identity eliminates the need for the developer to handle any credentials in their code, which is a major security benefit." }
                    ]
                }
            },
            {
                "id": "lesson-10-key-vault",
                "title": "Lesson 10: Azure Key Vault",
                "duration": "120 min",
                "objectives": [
                    "Understand Key Vault's role as a secure store for secrets, keys, and certificates",
                    "Configure access control using both access policies and RBAC",
                    "Integrate applications with Key Vault using Managed Identity",
                    "Explore the use of HSM-backed keys for maximum security"
                ],
                "content": {
                    "overview": "Azure Key Vault is the central, secure repository for all your application secrets. Hard-coding credentials is a thing of the past. This lesson covers how to use Key Vault to securely manage your keys, secrets, and certificates, and how to provide secure access to them for your applications.",
                    "sections": [
                        {
                            "title": "Key, Secret, and Certificate Management",
                            "content": "<p>Key Vault provides three main types of storage:</p><ul><li><strong>Keys:</strong> Cryptographic keys (like RSA keys) used for encryption. The key material itself can be stored in software or in FIPS 140-2 Level 2 validated Hardware Security Modules (HSMs) for the highest level of assurance. You can use the key for operations like encrypt/decrypt without ever seeing the key material.</li><li><strong>Secrets:</strong> Any small secret string (under 25KB), such as a password, a database connection string, or an API key.</li><li><strong>Certificates:</strong> SSL/TLS certificates. Key Vault can manage the entire lifecycle of a certificate, including auto-renewal.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1599373922312-5b9340d8a5a5?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Access Policies vs. RBAC",
                            "content": "<p>There are two models for granting access to a Key Vault. You must choose one.</p><ul><li><strong>Vault Access Policies (Legacy):</strong> The original model. You create an access policy on the vault itself that grants a specific identity (user, group, etc.) a set of permissions (e.g., `Get` and `List` on secrets).</li><li><strong>Azure RBAC for Key Vault (Recommended):</strong> The modern model. This integrates Key Vault into the standard Azure RBAC system. You can assign roles like `Key Vault Secrets User` (can read secrets) or `Key Vault Administrator` (can manage the vault). This is the preferred method as it allows for uniform access control and management with all your other Azure resources.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1554224155-83e8b835d07a?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary purpose of Azure Key Vault?", "options": ["To act as a firewall", "To securely store and manage secrets, keys, and certificates", "To store virtual machine disks", "To analyze logs"], "correct": 1, "explanation": "Key Vault is a secure secrets store, designed to protect your most sensitive application credentials." },
                        { "id": 2, "question": "For the highest level of security, cryptographic keys in Key Vault can be protected by what?", "options": ["Software encryption", "FIPS 140-2 Level 2 validated Hardware Security Modules (HSMs)", "A simple password", "A security group"], "correct": 1, "explanation": "HSM-backed keys provide the strongest guarantees that the key material can never be extracted or tampered with." },
                        { "id": 3, "question": "What is the most secure and recommended way for an application running on an Azure App Service to retrieve a secret from Key Vault?", "options": ["Store the Key Vault's password in the app's web.config file", "Use the application's Managed Identity with an appropriate RBAC role on the Key Vault", "Make the Key Vault's secrets public", "Email the secret to the developer"], "correct": 1, "explanation": "Managed Identity provides a seamless and secure, password-free way for Azure resources to authenticate to services that support Azure AD authentication, like Key Vault." }
                    ]
                }
            },
            {
                "id": "lesson-11-data-encryption-strategies",
                "title": "Lesson 11: Data Encryption Strategies",
                "duration": "120 min",
                "objectives": [
                    "Understand Azure's different encryption at rest options for PaaS and IaaS",
                    "Configure Transparent Data Encryption (TDE) for Azure SQL Database",
                    "Use customer-managed keys (CMK) from Key Vault to encrypt services",
                    "Implement 'Always Encrypted' for end-to-end database column protection"
                ],
                "content": {
                    "overview": "This lesson provides a comprehensive look at data encryption strategies in Azure, from the default platform-level encryption to advanced application-level encryption, ensuring your data is protected at every layer.",
                    "sections": [
                        {
                            "title": "Encryption at Rest Options",
                            "content": "<p>Azure provides several layers of encryption for data at rest.</p><ul><li><strong>Server-Side Encryption (SSE):</strong> This is the most common model. The Azure service (like Storage or SQL) automatically encrypts the data before writing it to disk and decrypts it when you access it. This can use Microsoft-managed keys (default) or customer-managed keys from Key Vault.</li><li><strong>Azure Disk Encryption (ADE):</strong> This encrypts the entire OS and data disks of your Windows and Linux IaaS virtual machines using BitLocker (Windows) or dm-crypt (Linux). ADE is often used for compliance scenarios that require full-disk encryption.</li><li><strong>Client-Side Encryption:</strong> Your application encrypts the data *before* ever sending it to Azure. This gives you the ultimate control but is more complex to manage.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542382156942-0268579cf259?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "TDE and Always Encrypted",
                            "content": "<p>For SQL databases, Azure provides specialized encryption technologies.</p><ul><li><strong>Transparent Data Encryption (TDE):</strong> This is a form of server-side encryption. It encrypts the entire database, its logs, and its backups at rest. It is 'transparent' because it requires no changes to your application code. You can enable it with a simple toggle.</li><li><strong>Always Encrypted:</strong> This is a form of client-side encryption. The database driver on the application server encrypts sensitive columns (like a Social Security Number) *before* sending the data to the SQL server. The data remains encrypted in the database, in memory, and in transit. Even a database administrator with full access to the SQL server can never see the plaintext data. This provides the strongest protection for specific, highly sensitive data elements.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1599373922312-5b9340d8a5a5?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Which SQL database encryption technology encrypts sensitive data on the client side, meaning that even a database admin cannot see the plaintext data?", "options": ["Transparent Data Encryption (TDE)", "Server-Side Encryption (SSE)", "Always Encrypted", "Azure Disk Encryption (ADE)"], "correct": 2, "explanation": "Always Encrypted is a powerful client-side technology that ensures the data is only ever seen in plaintext by the authorized client application, providing true end-to-end data protection." },
                        { "id": 2, "question": "Using your own key from Azure Key Vault to encrypt an Azure Storage account is an example of what?", "options": ["Client-Side Encryption", "Server-Side Encryption with Customer-Managed Keys (CMK)", "Server-Side Encryption with Microsoft-Managed Keys (MMK)", "Hybrid Encryption"], "correct": 1, "explanation": "This model gives you control over the key (you can rotate it, revoke it) while still leveraging the ease-of-use of the platform-native encryption." },
                        { "id": 3, "question": "Azure Disk Encryption for IaaS VMs uses which underlying technologies?", "options": ["Kerberos (Windows) and SSH (Linux)", "BitLocker (Windows) and dm-crypt (Linux)", "FileVault (Windows) and TrueCrypt (Linux)", "NTFS (Windows) and EXT4 (Linux)"], "correct": 1, "explanation": "ADE is essentially a managed service that orchestrates the use of the native, battle-tested full-disk encryption technologies of the respective operating systems." }
                    ]
                }
            },
            {
                "id": "lesson-12-aip",
                "title": "Lesson 12: Azure Information Protection",
                "duration": "120 min",
                "objectives": [
                    "Implement a data classification and labeling schema with AIP",
                    "Use labels to apply protection policies (like encryption and rights management)",
                    "Understand how labels travel with and protect documents everywhere",
                    "Integrate AIP with compliance and data loss prevention tools"
                ],
                "content": {
                    "overview": "Data protection should follow the data itself, no matter where it goes. Azure Information Protection (AIP) is a cloud-based solution that helps an organization to classify and optionally, protect its documents and emails by applying labels. This lesson covers how to use AIP to enable a data-centric security model.",
                    "sections": [
                        {
                            "title": "Data Classification and Labeling",
                            "content": "<p>The core of AIP is the 'label'. A label is a piece of metadata that you define and apply to documents and emails.</p><h3>The Label Hierarchy:</h3><p>You can create a hierarchy of labels to represent your data classification policy. For example:</p><ul><li><strong>Public:</strong> No protection.</li><li><strong>Internal:</strong> Document is for internal use. A watermark is applied.</li><li><strong>Confidential:</strong> A sub-label of Internal. This adds encryption, allowing only specific groups to access the document.</li><li><strong>Highly Confidential:</strong> The most restrictive label. It applies encryption and may prevent printing or copying of content.</li></ul><p>Labels can be applied manually by users (prompted by Office apps), automatically based on sensitive content detection, or as a default.</p>",
                            "image": "https://images.unsplash.com/photo-1589998059171-988d887df646?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Rights Management Services",
                            "content": "<p>When a label applies protection, it uses Azure Rights Management (Azure RMS). This is the encryption and access control technology behind AIP.</p><p>When a document is protected, it is encrypted and an access policy is embedded within it. This protection is persistent; it travels with the document. If you apply a 'Confidential' label and email the document to an unauthorized person outside the company, they will not be able to open it, even though they have the file. Their identity is checked against the policy in Azure AD when they attempt to open it.</p>",
                            "image": "https://images.unsplash.com/photo-1599373922312-5b9340d8a5a5?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary concept in Azure Information Protection (AIP)?", "options": ["A virtual machine", "A firewall rule", "A label that classifies and protects a document", "A user account"], "correct": 2, "explanation": "Labels are the core of AIP, acting as the user-facing implementation of an organization's data classification policy." },
                        { "id": 2, "question": "If a document protected by an AIP label is attached to an email and sent outside the company, what happens?", "options": ["The protection is automatically removed", "The protection (encryption and access policy) travels with the document, preventing unauthorized users from opening it", "The email is blocked by the firewall", "The document is converted to a PDF"], "correct": 1, "explanation": "This persistent protection is the key value of AIP. The security is data-centric, not location-centric." }
                    ]
                }
            },
            {
                "id": "lesson-13-azure-monitor-security",
                "title": "Lesson 13: Azure Monitor Security",
                "duration": "120 min",
                "objectives": [
                    "Configure the Azure Activity Log for a complete audit trail",
                    "Enable and route Diagnostic Settings for all resources",
                    "Set up and secure a central Log Analytics Workspace",
                    "Create security-focused alert rules"
                ],
                "content": {
                    "overview": "Azure Monitor is the central platform for collecting, analyzing, and acting on telemetry from your Azure and on-premises environments. This lesson focuses on the security-relevant aspects of Azure Monitor, covering how to configure comprehensive logging and create alerts for suspicious activity.",
                    "sections": [
                        {
                            "title": "Activity Log and Diagnostic Settings",
                            "content": "<p>Azure has two fundamental types of platform logs.</p><ul><li><strong>Activity Log:</strong> This is the subscription-level control plane log. It's the Azure equivalent of AWS CloudTrail. It records every action taken on your subscription resources (e.g., 'VM created', 'Security Group updated'). There is only one Activity Log per subscription, and it is crucial for auditing.</li><li><strong>Diagnostic Settings:</strong> These are resource-level data plane logs. They provide detailed insights into the operation of a specific resource. For example, Diagnostic Settings for a Key Vault will show every time a secret was accessed. You must manually enable Diagnostic Settings for each resource and configure a destination for the logs.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542438408-abb2021e1837?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Log Analytics Workspace",
                            "content": "<p>A Log Analytics Workspace is the primary destination for log data in Azure Monitor. It is a scalable data store and query engine powered by Azure Data Explorer. It uses the powerful Kusto Query Language (KQL) for analysis.</p><h3>Best Practice:</h3><p>Create a dedicated, centralized Log Analytics Workspace in a separate 'Security' resource group. Configure the Diagnostic Settings for all your resources to send their logs to this central workspace. This provides a single place for your security team to analyze logs from across your entire environment.</p>",
                            "image": "https...//images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Query the Activity Log for VM Deletions (Azure CLI)",
                        "language": "bash",
                        "code": "# Show all Virtual Machine delete operations in the last 7 days.\naz monitor activity-log list --resource-provider Microsoft.Compute --query \"[?operationName.value=='Microsoft.Compute/virtualMachines/delete' && eventTimestamp > '`date -u -d '7 days ago' +%Y-%m-%dT%H:%M:%SZ`']\""
                    },
                    {
                        "title": "Create an Alert Rule for a Custom KQL Query (Azure CLI)",
                        "language": "bash",
                        "code": "az monitor scheduled-query create -g MyResourceGroup -n \"Detect-Root-Logons\" \\\n --scopes \"/subscriptions/your_subscription_id\" \\\n --condition \"count 'AzureActivity | where OperationNameValue contains \\\"Microsoft.Authorization/roleAssignments/write\\\" and Caller == \\\"root@yourtenant.onmicrosoft.com\\\"' > 0\" \\\n --description \"Alert when root user modifies permissions\""
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the Azure Activity Log?", "options": ["A log of network traffic", "The subscription-level control plane log that records all management actions on resources", "A log of application performance", "A security vulnerability report"], "correct": 1, "explanation": "The Activity Log is the fundamental audit trail for your Azure subscription, equivalent to AWS CloudTrail." },
                        { "id": 2, "question": "To get detailed logs about the internal operations of a specific resource, like an NSG or a Key Vault, you must enable:", "options": ["The Activity Log", "Diagnostic Settings for that resource", "Azure Policy", "An IAM Role"], "correct": 1, "explanation": "Diagnostic Settings provide the deep, 'data plane' visibility into individual resources, but they must be explicitly enabled and configured." },
                        { "id": 3, "question": "What is the query language used to analyze logs in a Log Analytics Workspace?", "options": ["SQL", "Python", "Kusto Query Language (KQL)", "JSON"], "correct": 2, "explanation": "KQL is the powerful, read-only query language used across Azure Monitor, Sentinel, and other Azure data platforms." }
                    ]
                }
            },
            {
                "id": "lesson-14-sentinel-intro",
                "title": "Lesson 14: Azure Sentinel Introduction",
                "duration": "150 min",
                "objectives": [
                    "Understand the capabilities of Azure Sentinel as a cloud-native SIEM and SOAR",
                    "Connect key data sources to Sentinel",
                    "Enable and analyze built-in analytics rules",
                    "Use Workbooks for visualization and reporting"
                ],
                "content": {
                    "overview": "Microsoft Sentinel is a scalable, cloud-native Security Information and Event Management (SIEM) and Security Orchestration, Automation, and Response (SOAR) solution. This lesson covers how to deploy Sentinel and begin using its core features for threat detection and visualization.",
                    "sections": [
                        {
                            "title": "Data Connector Configuration",
                            "content": "<p>Sentinel's effectiveness depends on the data it ingests. It provides a gallery of over 100 built-in data connectors to make this process easy.</p><h3>Key Connectors:</h3><ul><li><strong>Azure Services:</strong> Azure Activity Log, Azure AD Identity Protection, Microsoft Defender for Cloud, Azure Firewall, etc. These are often one-click connectors.</li><li><strong>Microsoft 365:</strong> Office 365, Microsoft Defender for Endpoint.</li><li><strong>Third-Party:</strong> Sentinel can ingest data from other clouds and third-party security appliances (e.g., Palo Alto, Check Point) using Syslog or the Common Event Format (CEF).</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Analytics Rules",
                            "content": "<p>An analytics rule is a scheduled KQL query that runs against your ingested logs to look for suspicious patterns. When the query returns results, the rule creates an 'incident'. Sentinel comes with hundreds of built-in rule templates based on the MITRE ATT&CK framework that you can enable.</p>",
                            "image": "https://images.unsplash.com/photo-1614064548237-02f8f17374b2?w=800&h=400&fit-crop"
                        },
                        {
                            "title": "Workbooks",
                            "content": "<p>Workbooks are interactive dashboards within Sentinel. They provide a canvas where you can combine text, KQL queries, and visualizations to build rich, interactive reports and investigation guides. Sentinel has many built-in workbooks that are automatically populated when you connect a data source.</p>",
                            "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What are the two primary functions of Microsoft Sentinel?", "options": ["SIEM and SOAR", "Firewall and VPN", "Vulnerability scanning and patch management", "Data encryption and key management"], "correct": 0, "explanation": "Sentinel is a comprehensive security operations platform, combining Security Information and Event Management (SIEM) with Security Orchestration, Automation, and Response (SOAR) capabilities." },
                        { "id": 2, "question": "What is an 'analytics rule' in Sentinel?", "options": ["A visualization dashboard", "A connection to a data source", "A scheduled KQL query that runs to detect threats and create incidents", "An automated response workflow"], "correct": 2, "explanation": "Analytics rules are the core detection mechanism in Sentinel." },
                        { "id": 3, "question": "Sentinel Workbooks are best described as:", "options": ["Data connectors", "Automated response playbooks", "The raw log data", "Interactive dashboards and reports"], "correct": 3, "explanation": "Workbooks are the primary tool for visualization and building rich, interactive experiences for data analysis and reporting in Sentinel." }
                    ]
                }
            },
            {
                "id": "lesson-15-defender-for-cloud",
                "title": "Lesson 15: Microsoft Defender for Cloud",
                "duration": "120 min",
                "objectives": [
                    "Use Secure Score to assess and improve your security posture",
                    "Prioritize and remediate security recommendations",
                    "Understand how Defender for Cloud's dashboards map to regulatory compliance standards",
                    "Use Just-in-Time (JIT) VM access to reduce attack surface"
                ],
                "content": {
                    "overview": "Microsoft Defender for Cloud is the central tool for Cloud Security Posture Management (CSPM) and Cloud Workload Protection (CWP) in Azure. This lesson covers how to use Defender for Cloud to find and fix misconfigurations and weaknesses in your environment.",
                    "sections": [
                        {
                            "title": "Secure Score and Recommendations",
                            "content": "<p>Secure Score is a numerical score that represents your overall security posture. It is calculated by continuously assessing your resources against a set of security controls based on benchmarks like the CIS Controls. Defender for Cloud provides a prioritized list of actionable recommendations. Implementing a recommendation (e.g., 'Enable MFA on subscription') will improve your Secure Score.</p>",
                            "image": "https://images.unsplash.com/photo-1543286386-2e659306cd6c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Regulatory Compliance Dashboard",
                            "content": "<p>Defender for Cloud can assess your environment against specific compliance standards like PCI DSS, ISO 27001, and SOC TSP. The Regulatory Compliance Dashboard maps the controls from these standards to specific security assessments. It provides a clear view of your compliance status and generates evidence for your auditors.</p>",
                            "image": "https://images.unsplash.com/photo-1542626991-cbc4e32524cc?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Just-in-Time (JIT) VM Access",
                            "content": "<p>One of the most common security weaknesses is leaving management ports like SSH (22) and RDP (3389) permanently open to the internet. JIT VM Access solves this. It locks down these ports by default. When an administrator needs to connect, they request access through Defender for Cloud. JIT then opens the port in the NSG, but only for the administrator's specific source IP address and only for a limited time (e.g., 3 hours). This is a powerful application of the least privilege principle to network access.</p>",
                            "image": "https://images.unsplash.com/photo-1461749280684-dccba630e2f6?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary purpose of Secure Score in Microsoft Defender for Cloud?", "options": ["To measure your monthly Azure bill", "To provide a high-level, numerical representation of your security posture and a prioritized list of recommendations", "To count the number of VMs you have", "To automatically block attacks"], "correct": 1, "explanation": "Secure Score is a key CSPM feature that helps organizations understand and improve their security hygiene in a measurable way." },
                        { "id": 2, "question": "What security problem does Just-in-Time (JIT) VM Access solve?", "options": ["Vulnerable software on a VM", "The risk of leaving high-privilege management ports like RDP and SSH open to the internet", "Insecure data storage", "Lack of MFA"], "correct": 1, "explanation": "JIT access dramatically reduces a VM's attack surface by ensuring management ports are closed by default and only opened on-demand for authorized users." },
                        { "id": 3, "question": "The functionality of Defender for Cloud that checks your environment against frameworks like PCI DSS and ISO 27001 is provided by the:", "options": ["Secure Score dashboard", "Just-in-Time Access dashboard", "Regulatory Compliance dashboard", "Firewall dashboard"], "correct": 2, "explanation": "This dashboard is specifically designed for compliance management and reporting." }
                    ]
                }
            },
            {
                "id": "lesson-16-azure-policy-governance",
                "title": "Lesson 16: Azure Policy and Governance",
                "duration": "120 min",
                "objectives": [
                    "Create and assign Azure Policy definitions to enforce rules",
                    "Group policies into Initiatives for easier management",
                    "Use policy to assess compliance and find non-compliant resources",
                    "Configure automated remediation tasks for non-compliant resources"
                ],
                "content": {
                    "overview": "Azure Policy is the core service for enforcing governance and compliance at scale across your Azure environment. This lesson covers how to use Azure Policy to create preventative and detective controls that ensure your resources stay compliant with your corporate standards.",
                    "sections": [
                        {
                            "title": "Policy Hierarchy",
                            "content": "<ul><li><strong>Policy Definition:</strong> This is the rule itself, written in JSON. It defines a condition (e.g., 'if a storage account does not have HTTPS traffic only enabled') and an effect (e.g., `audit`, `deny`, `deployIfNotExists`).</li><li><strong>Assignment:</strong> An assignment is the process of applying a policy definition to a specific scope (a management group, subscription, or resource group).</li><li><strong>Initiative (Policy Set):</strong> An initiative is a collection of related policy definitions that you group together to achieve a single goal (e.g., a 'HIPAA Compliance' initiative might contain 20 different policies). You assign the initiative instead of assigning each policy individually.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Policy Effects",
                            "content": "<p>The 'effect' of a policy determines what happens when the condition is met.</p><ul><li><strong>`Deny` (Preventative):</strong> The action is blocked. For example, a policy with a `Deny` effect would prevent a user from creating a public storage account. This is a very powerful preventative control.</li><li><strong>`Audit` (Detective):</strong> The resource is created, but it is flagged as non-compliant in the policy dashboard.</li><li><strong>`DeployIfNotExists` / `Modify` (Remediation):</strong> These effects can be used to automatically deploy a required configuration (like a Diagnostic Setting) or modify an existing resource to bring it into compliance.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1499750310107-5fef28a66643?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Azure Policy Definition to Audit Public IPs",
                        "language": "json",
                        "code": "{\n  \"if\": {\n    \"field\": \"type\",\n    \"equals\": \"Microsoft.Network/publicIPAddresses\"\n  },\n  \"then\": {\n    \"effect\": \"audit\"\n  }\n}"
                    },
                    {
                        "title": "Assign a Built-in Policy (Azure CLI)",
                        "language": "bash",
                        "code": "# Assign the built-in policy that requires a tag on all resource groups\naz policy assignment create --name 'Require-CostCenter-Tag' --scope '/subscriptions/your_subscription_id' --policy '/providers/Microsoft.Authorization/policyDefinitions/the_policy_definition_id'"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary function of Azure Policy?", "options": ["To monitor for threats", "To enforce governance and compliance rules across Azure resources", "To manage user identities", "To provide DDoS protection"], "correct": 1, "explanation": "Azure Policy is the key service for defining and enforcing standards for your resources, which is the heart of cloud governance." },
                        { "id": 2, "question": "A policy with a `Deny` effect is an example of what kind of control?", "options": ["Detective control", "Corrective control", "Preventative control", "Responsive control"], "correct": 2, "explanation": "A 'Deny' policy prevents a non-compliant action from ever happening, making it a very strong preventative control." },
                        { "id": 3, "question": "A collection of related Azure Policy definitions that are grouped together is called a(n):", "options": ["Assignment", "Initiative (or Policy Set)", "Resource Group", "Management Group"], "correct": 1, "explanation": "Initiatives simplify the assignment and management of policies by bundling them into a logical group." }
                    ]
                }
            },
            {
                "id": "lesson-17-app-service-security",
                "title": "Lesson 17: App Service Security",
                "duration": "120 min",
                "objectives": [
                    "Configure built-in authentication and authorization for App Services",
                    "Securely manage application secrets using Key Vault integration",
                    "Isolate an App Service using VNet integration and private endpoints",
                    "Understand security considerations for deployment slots"
                ],
                "content": {
                    "overview": "Azure App Service is a fully managed PaaS offering for hosting web applications. This lesson covers the built-in security features of the platform, focusing on identity, secret management, and network isolation for your web apps.",
                    "sections": [
                        {
                            "title": "Authentication and Managed Identity",
                            "content": "<p>App Service has a built-in authentication and authorization module, often called 'Easy Auth'. It can be configured to use Azure AD as an identity provider with just a few clicks, offloading the work of user authentication from your application code.</p><h3>Managed Identity:</h3><p>The most important security feature for an App Service is its Managed Identity. You can enable a system-assigned managed identity for your app, which creates an identity for it in Azure AD. You can then grant this identity access to other Azure resources (like Key Vault or SQL Database) using RBAC. Your application code can then get an access token for that identity without needing any passwords or connection strings, which is the most secure way to access backend services.</p>",
                            "image": "https://images.unsplash.com/photo-1554224155-83e8b835d07a?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Network Isolation",
                            "content": "<p>By default, an App Service is a public, multi-tenant service. However, you can isolate it.</p><ul><li><strong>VNet Integration:</strong> Allows your App Service to make *outbound* calls to resources inside your private VNet.</li><li><strong>Private Endpoints:</strong> Allows you to make your App Service reachable *only* from within your private VNet by giving it a private IP address. This effectively makes your web app an internal, private application, completely inaccessible from the public internet.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1461749280684-dccba630e2f6?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the most secure way for an Azure App Service to get a database connection string from Azure Key Vault?", "options": ["Hard-code it in the web.config file", "Store it in an App Setting in plain text", "Enable the app's Managed Identity, grant it access to the Key Vault via RBAC, and have the app retrieve the secret at runtime", "Email it to the on-call developer"], "correct": 2, "explanation": "Managed Identity provides a password-less, automated, and secure way for Azure services to authenticate to each other." }
                    ]
                }
            },
            {
                "id": "lesson-18-functions-security",
                "title": "Lesson 18: Azure Functions Security",
                "duration": "120 min",
                "objectives": [
                    "Securely configure function app settings and triggers",
                    "Use Managed Identity for serverless permissions",
                    "Integrate with API Management for security policies",
                    "Understand serverless runtime security and network configuration"
                ],
                "content": {
                    "overview": "Azure Functions is the primary serverless, event-driven compute service on Azure. Securing functions involves a strong focus on permissions, as they are often small, single-purpose pieces of code that connect different services.",
                    "sections": [
                        {
                            "title": "Security Model",
                            "content": "<p>Securing an Azure Function is very similar to securing an App Service. The core principles are the same:</p><ul><li><strong>Managed Identity:</strong> Every function app should have a managed identity. The IAM role assigned to this identity is the primary security boundary for the function. Least privilege is critical.</li><li><strong>Key Vault for Secrets:</strong> Use Key Vault integration to securely inject secrets as application settings, rather than storing them in the function's configuration files.</li><li><strong>Network Isolation:</strong> Use VNet integration and private endpoints to control inbound and outbound network access for your functions.</li><li><strong>API Management:</strong> For HTTP-triggered functions that act as APIs, placing Azure API Management in front of them provides a crucial layer for authentication, rate limiting, and other security policies.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1555099962-4199c345e541?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Just like with an App Service, the most important security control for an Azure Function is its:", "options": ["Runtime language", "Trigger type", "Managed Identity and associated RBAC role", "Geographic location"], "correct": 2, "explanation": "The Managed Identity's permissions define the blast radius of a compromised function. It is the most critical control to get right." }
                    ]
                }
            },
            {
                "id": "lesson-19-container-security",
                "title": "Lesson 19: Container Security",
                "duration": "120 min",
                "objectives": [
                    "Secure Azure Container Instances (ACI)",
                    "Implement security best practices for Azure Kubernetes Service (AKS)",
                    "Scan images in Azure Container Registry (ACR)",
                    "Use pod security policies and Kubernetes RBAC"
                ],
                "content": {
                    "overview": "This lesson focuses on the specifics of container security in Azure, with a particular emphasis on the best practices for securing a full-fledged Kubernetes cluster in Azure Kubernetes Service (AKS).",
                    "sections": [
                        {
                            "title": "AKS Security",
                            "content": "<p>Securing AKS involves securing multiple layers: the cluster control plane, the nodes, the containers themselves, and the network.</p><h3>Key Best Practices:</h3><ul><li><strong>Integrate with Azure AD:</strong> Configure your AKS cluster to use Azure AD for user authentication. This allows you to manage access to the cluster (using `kubectl`) with your corporate identities and groups.</li><li><strong>Use Kubernetes RBAC:</strong> On top of Azure AD authentication, use Kubernetes's native RBAC to define fine-grained roles and role bindings within the cluster.</li><li><strong>Use Managed Identities for Pods:</strong> Instead of storing secrets in your pods, use the Azure AD Pod Identity project to assign managed identities to individual pods.</li><li><strong>Secure the Network:</strong> Use Network Policies to create a micro-segmented, least-privilege network within your cluster. Use a private cluster to ensure your Kubernetes API server is not exposed to the public internet.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1579543183319-a16eee1b1fd3?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the recommended way to manage user access to an AKS cluster?", "options": ["Using a single, shared administrator certificate", "Making the cluster anonymous", "Integrating the cluster with Azure AD for authentication and using Kubernetes RBAC for authorization", "Using a local user database on each node"], "correct": 2, "explanation": "This combination provides centralized, auditable, and granular control over who can do what within your Kubernetes cluster." },
                        { "id": 2, "question": "To control traffic flow *between* pods inside an AKS cluster, you would use:", "options": ["A Network Security Group", "An Application Security Group", "A Kubernetes Network Policy", "Azure Firewall"], "correct": 2, "explanation": "Network Policies are the Kubernetes-native way to implement micro-segmentation and firewalling for your pods." }
                    ]
                }
            },
            {
                "id": "lesson-20-api-management-security",
                "title": "Lesson 20: API Management Security",
                "duration": "120 min",
                "objectives": [
                    "Use Azure API Management (APIM) as a secure gateway for your APIs",
                    "Implement authentication and authorization policies like JWT validation",
                    "Protect backend services from abuse with rate limiting and throttling",
                    "Secure the connection between APIM and your backend services"
                ],
                "content": {
                    "overview": "APIs are the new perimeter. Azure API Management (APIM) acts as a facade or gateway for your backend APIs, providing a critical layer of security and governance. This lesson covers how to use APIM to secure your API endpoints.",
                    "sections": [
                        {
                            "title": "APIM Security Policies",
                            "content": "<p>APIM's power comes from its policies. A policy is a piece of logic that executes on a request or response as it passes through the gateway. You can use built-in policies to enforce security.</p><h3>Key Security Policies:</h3><ul><li><strong>Validate JWT:</strong> Enforces that every request has a valid JSON Web Token (JWT) from your Azure AD tenant. This is the standard for securing modern APIs.</li><li><strong>Rate Limit / Quota:</strong> Protects your backend from denial of service and abuse by limiting how many calls a user or subscription key can make in a given time period.</li><li><strong>IP Filter:</strong> Restrict which client IP addresses can call the API.</li><li><strong>Check Headers:</strong> Enforce that required HTTP headers are present.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1596003906915-013661138ae2?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Securing the Backend",
                            "content": "<p>It's not enough to secure APIM; you must also ensure that attackers can't bypass it and call your backend API directly. You can place your APIM instance within a VNet and use mutual TLS certificate authentication to ensure your backend Function App or App Service will *only* accept traffic that comes from your APIM instance.</p>",
                            "image": "https://images.unsplash.com/photo-1498050108023-c5249f4df085?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary role of Azure API Management (APIM)?", "options": ["To host a database", "To act as a secure gateway or facade for backend APIs", "To run containerized applications", "To manage virtual networks"], "correct": 1, "explanation": "APIM provides a central point of control to secure, publish, and analyze your APIs." },
                        { "id": 2, "question": "An APIM policy that checks for a valid OAuth 2.0 access token from Azure AD is a:", "options": ["Rate Limit policy", "Validate JWT policy", "IP Filter policy", "Header Check policy"], "correct": 1, "explanation": "Validating the JWT is the standard and most secure way to handle authentication and authorization for APIs." }
                    ]
                }
            },
            {
                "id": "lesson-21-sql-database-security",
                "title": "Lesson 21: SQL Database Security",
                "duration": "120 min",
                "objectives": [
                    "Use firewall rules and VNet service/private endpoints for network isolation",
                    "Implement Advanced Threat Protection for real-time threat detection",
                    "Use Vulnerability Assessment to find and remediate database weaknesses",
                    "Leverage data masking and other advanced data security features"
                ],
                "content": {
                    "overview": "This lesson provides a deeper dive into the specific security features of Azure SQL Database, building on the general database security principles discussed earlier. We will focus on the advanced, built-in security intelligence of the platform.",
                    "sections": [
                        {
                            "title": "Advanced Threat Protection (ATP)",
                            "content": "<p>Advanced Threat Protection for Azure SQL is part of the Microsoft Defender for SQL offering. It is a unified package of advanced security capabilities.</p><ul><li><strong>Vulnerability Assessment:</strong> A scanning service that can discover, track, and help you remediate potential database vulnerabilities.</li><li><strong>Threat Detection:</strong> It detects anomalous activities indicating unusual and potentially harmful attempts to access or exploit your database. It looks for things like SQL injection, brute-force login attempts, and unusual data access patterns, and it generates real-time alerts.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1614064548237-02f8f17374b2?w=800&h=400&fit-crop"
                        },
                        {
                            "title": "Dynamic Data Masking",
                            "content": "<p>Dynamic Data Masking limits sensitive data exposure by masking it to non-privileged users. For example, a support user querying a customer table might see an email address as `aXXXX@XXXX.com` while a privileged user sees the full email address. The masking rules are applied in the database, so no changes are needed to the application code.</p>",
                            "image": "https://images.unsplash.com/photo-1599373922312-5b9340d8a5a5?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Which Azure SQL feature uses machine learning to detect anomalous activities like SQL injection or brute force attacks and sends real-time alerts?", "options": ["Dynamic Data Masking", "The SQL firewall", "Transparent Data Encryption (TDE)", "Advanced Threat Protection (ATP)"], "correct": 3, "explanation": "ATP provides the intelligent, behavioral threat detection layer for Azure SQL Database." },
                        { "id": 2, "question": "The feature that automatically hides portions of sensitive data (like a credit card number) from non-privileged users is called:", "options": ["The firewall", "Advanced Threat Protection", "Always Encrypted", "Dynamic Data Masking"], "correct": 3, "explanation": "Data masking is a useful security feature for limiting accidental exposure of sensitive data in production databases to roles like support or development." }
                    ]
                }
            },
            {
                "id": "lesson-22-cosmos-db-security",
                "title": "Lesson 22: Cosmos DB Security",
                "duration": "120 min",
                "objectives": [
                    "Secure a Cosmos DB account with RBAC and network controls",
                    "Understand the difference between master keys and resource tokens",
                    "Configure encryption with customer-managed keys"
                ],
                "content": {
                    "overview": "Azure Cosmos DB is a globally distributed, multi-model NoSQL database. This lesson covers its unique security model, focusing on authentication, authorization, and network isolation.",
                    "sections": [
                        {
                            "title": "Authentication and Authorization",
                            "content": "<p>Cosmos DB has two primary ways of controlling access.</p><ul><li><strong>Master Keys:</strong> These are the root keys for the account. They grant full access and should be protected and rotated regularly. They should NOT be used by your application.</li><li><strong>Resource Tokens (via RBAC):</strong> This is the recommended method. You use Azure AD identities and RBAC to grant specific permissions (e.g., `Cosmos DB Built-in Data Reader`) to your application's Managed Identity. Your application then requests a short-lived 'resource token' to perform its operations. This aligns with a least-privilege, password-less model.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1554224155-83e8b835d07a?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Network Controls",
                            "content": "<p>Just like with Azure Storage, you can lock down network access to your Cosmos DB account using its built-in firewall, VNet service endpoints, or private endpoints. Using a private endpoint is the best practice for isolating a Cosmos DB account so it is only accessible from within your private virtual network.</p>",
                            "image": "https://images.unsplash.com/photo-1599691888286-93e433f064b8?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "For your application to access Cosmos DB, what is the most secure method of authentication?", "options": ["Using the primary master key hard-coded in the application", "Creating a resource token based on an Azure AD identity with an RBAC role", "Disabling all authentication", "Using a SAS token"], "correct": 1, "explanation": "Using Azure AD identities with RBAC and resource tokens provides a much more secure and granular alternative to the all-powerful master keys." }
                    ]
                }
            },
            {
                "id": "lesson-23-data-warehouse-security",
                "title": "Lesson 23: Data Warehouse Security",
                "duration": "120 min",
                "objectives": [
                    "Secure an Azure Synapse Analytics workspace",
                    "Implement network security for data lakes built on Azure Data Lake Storage",
                    "Use column-level and row-level security to enforce fine-grained access"
                ],
                "content": {
                    "overview": "Modern data platforms like Azure Synapse Analytics bring together data warehousing, big data processing, and data integration. Securing this environment requires a multi-layered approach, from the network to the data itself. This lesson covers the key security controls for Azure's analytics platforms.",
                    "sections": [
                        {
                            "title": "Azure Synapse Security",
                            "content": "<p>Azure Synapse Analytics workspaces have a comprehensive security model.</p><ul><li><strong>Network Security:</strong> A key feature is the 'Managed VNet', which creates an isolated network for the workspace, and 'Managed private endpoints' to securely connect to other data sources.</li><li><strong>Access Control:</strong> Uses a combination of Azure RBAC (for the workspace itself) and internal SQL permissions and roles (for the data within the databases).</li><li><strong>Data Protection:</strong> Supports all the standard Azure SQL data protection features, including TDE, dynamic data masking, and auditing.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Row-Level and Column-Level Security",
                            "content": "<p>These are powerful, fine-grained data security features available in Azure SQL and Synapse.</p><ul><li><strong>Row-Level Security (RLS):</strong> Allows you to control which users can see which rows in a table. For example, a sales manager can only see the rows in the sales table that belong to their own region. The filtering logic is implemented in the database, simplifying the application.</li><li><strong>Column-Level Security:</strong> Allows you to control which users can see which columns in a table. For example, a support user might be able to see a customer's name and address, but not their Social Security Number column.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1522252234503-e356032cafd5?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "You have a table of employees, and you want to implement a rule where managers can only see the rows belonging to their direct reports. Which technology is best suited for this?", "options": ["Transparent Data Encryption (TDE)", "A network security group (NSG)", "Row-Level Security (RLS)", "Column-Level Security"], "correct": 2, "explanation": "Row-Level Security is specifically designed for this type of scenario, where a user's access rights determine which rows of data they can see in a shared table." }
                    ]
                }
            },
            {
                "id": "lesson-24-backup-recovery-security",
                "title": "Lesson 24: Backup and Recovery Security",
                "duration": "120 min",
                "objectives": [
                    "Securely configure Azure Backup and its Recovery Services Vault",
                    "Understand the security model for Azure Site Recovery",
                    "Manage encryption for backups and replicated data",
                    "Perform secure recovery testing"
                ],
                "content": {
                    "overview": "Protecting your backups is just as important as protecting your production data. This lesson covers the security features of Azure's native backup and disaster recovery services, Azure Backup and Azure Site Recovery.",
                    "sections": [
                        {
                            "title": "Azure Backup Security",
                            "content": "<p>Azure Backup stores its data in a Recovery Services Vault. Securing this vault is critical.</p><h3>Vault Security Features:</h3><ul><li><strong>Soft Delete:</strong> When a backup is deleted, it is first placed in a 'soft delete' state for 14 days, during which it can be recovered. This protects against accidental or malicious deletion of backups.</li><li><strong>Encryption:</strong> Data in the Recovery Services Vault is encrypted at rest by default with Microsoft-managed keys. You can also use customer-managed keys for an extra layer of control.</li><li><strong>RBAC:</strong> Access to the vault and its data is controlled by Azure RBAC. You should use roles like `Backup Contributor` and `Backup Reader` to enforce least privilege.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1579548122216-3841a12d1b5a?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Azure Site Recovery (ASR)",
                            "content": "<p>ASR is the primary disaster recovery service, replicating your VMs to another Azure region. Security is a key consideration in the DR process.</p><ul><li><strong>Encryption:</strong> Data is encrypted both in transit and at rest in the target region. You can specify a customer-managed key for encryption at rest in the DR site.</li><li><strong>Testing:</strong> ASR allows you to perform non-disruptive DR tests. You can 'test failover' into an isolated VNet in the DR region to validate your recovery process without impacting your production environment.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Which Azure Backup feature helps protect against an attacker trying to delete your backups?", "options": ["The backup policy", "Soft Delete", "Cross-region restore", "Encryption"], "correct": 1, "explanation": "Soft Delete is a critical defense against ransomware and other destructive attacks, as it ensures you have a 14-day window to recover any deleted backup data." },
                        { "id": 2, "question": "What is the primary function of Azure Site Recovery (ASR)?", "options": ["To back up data", "To manage virtual networks", "To orchestrate the replication and failover of virtual machines for disaster recovery", "To scan for vulnerabilities"], "correct": 2, "explanation": "ASR is Azure's native Disaster Recovery as a Service (DRaaS) offering." }
                    ]
                }
            },
            {
                "id": "lesson-25-defender-for-cloud-workloads",
                "title": "Lesson 25: Microsoft Defender for Cloud",
                "duration": "150 min",
                "objectives": [
                    "Implement the workload protection features (CWP) of Defender for Cloud",
                    "Investigate security alerts for workloads like servers, containers, and databases",
                    "Use Adaptive Application Controls to create application whitelists",
                    "Enable and use File Integrity Monitoring (FIM)"
                ],
                "content": {
                    "overview": "This lesson provides a deeper dive into Microsoft Defender for Cloud, moving beyond the posture management features to focus on its advanced Cloud Workload Protection (CWP) capabilities. These are the features that provide real-time threat detection and advanced defenses for your specific workloads.",
                    "sections": [
                        {
                            "title": "Workload Protection Features",
                            "content": "<p>Microsoft Defender for Cloud is not just a single service; it's a suite of 'Defender' plans for different workload types. You enable the plans for the resources you want to protect.</p><h3>Key Defender Plans:</h3><ul><li><strong>Defender for Servers:</strong> Provides threat detection (based on the Defender for Endpoint EDR), vulnerability assessment, JIT VM access, File Integrity Monitoring, and more for your IaaS VMs.</li><li><strong>Defender for Storage:</strong> Detects unusual and potentially harmful attempts to access or exploit your storage accounts.</li><li><strong>Defender for SQL:</strong> Provides vulnerability assessment and advanced threat protection for your SQL databases.</li><li><strong>Defender for Containers:</strong> Scans your container images for vulnerabilities and provides real-time threat detection for your Kubernetes nodes and clusters.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1614064548237-02f8f17374b2?w=800&h=400&fit-crop"
                        },
                        {
                            "title": "Adaptive Application Controls",
                            "content": "<p>Adaptive Application Controls is an intelligent, automated application whitelisting solution provided by Defender for Servers. It uses machine learning to analyze the processes running on your VMs and create a baseline of known-good applications. It then generates a recommendation for a set of application control rules. Once you approve and apply these rules, it will alert you if any application that is *not* on the approved list tries to run. This is a very powerful defense against malware.</p>",
                            "image": "https://images.unsplash.com/photo-1510915228340-29c85a43dcfe?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "File Integrity Monitoring (FIM)",
                            "content": "<p>FIM, also part of Defender for Servers, monitors key files and registry keys on your Windows and Linux VMs for changes that could indicate an attack. It can alert you if a critical system file is modified, a new file is created in a sensitive directory, or a registry key used for persistence is changed. This is a crucial control for compliance standards like PCI DSS.</p>",
                            "image": "https://images.unsplash.com/photo-1563206767-5b18f218e8de?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "The features in Microsoft Defender for Cloud that provide threat detection and advanced defenses for specific resource types are collectively known as:", "options": ["Cloud Security Posture Management (CSPM)", "Cloud Workload Protection (CWP)", "Azure Policy", "Secure Score"], "correct": 1, "explanation": "CSPM is about finding misconfigurations (the posture), while CWP is about protecting the workloads themselves from active threats." },
                        { "id": 2, "question": "Which Defender for Cloud feature helps create automated application whitelisting rules based on machine learning?", "options": ["File Integrity Monitoring (FIM)", "Just-in-Time (JIT) VM Access", "Adaptive Application Controls", "Vulnerability Assessment"], "correct": 2, "explanation": "Adaptive Application Controls simplify the traditionally difficult process of creating and managing application whitelists." },
                        { "id": 3, "question": "File Integrity Monitoring (FIM) is designed to detect what?", "options": ["Network intrusions", "Unauthorized changes to critical files and registry keys", "Phishing emails", "Vulnerable software"], "correct": 1, "explanation": "FIM is a key host-based control for detecting tampering and maintaining the integrity of your servers." }
                    ]
                }
            },
            
            {
                "id": "lesson-26-sentinel-advanced",
                "title": "Lesson 26: Azure Sentinel Advanced",
                "duration": "150 min",
                "objectives": [
                    "Write custom analytics rules using advanced KQL queries",
                    "Develop and execute threat hunting queries based on hypotheses",
                    "Create automated response playbooks using Logic Apps",
                    "Understand and leverage Sentinel's built-in Machine Learning (UEBA) analytics"
                ],
                "content": {
                    "overview": "Moving beyond the basics, this lesson unlocks the true power of Azure Sentinel. You will learn how to write your own custom detections, proactively hunt for threats that bypass automated rules, and build sophisticated automated response workflows to contain threats at machine speed.",
                    "sections": [
                        {
                            "title": "Custom Analytics Rules with KQL",
                            "content": "<p>While built-in rules are a great start, advanced threat detection requires writing custom rules tailored to your environment. These are scheduled KQL queries that run against your logs. The key is to create high-fidelity queries that are specific enough to reduce false positives but general enough to catch variations of an attack.</p><h3>Rule Development Process:</h3><ol><li><strong>Form a Hypothesis:</strong> Start with a specific threat you want to detect (e.g., 'An attacker will use PowerShell to download a file from the internet').</li><li><strong>Write the KQL Query:</strong> Translate your hypothesis into a KQL query that searches the relevant logs (e.g., `SecurityEvent` table for process creation).</li><li><strong>Tune the Query:</strong> Test the query to see what normal activity it might trigger. Add exceptions (`where` clauses) to filter out known benign behavior.</li><li><strong>Configure the Rule:</strong> Set the schedule, the lookback period, and the alert details (name, severity, MITRE ATT&CK tactics).</li></ol>",
                            "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Playbook Creation (Logic Apps)",
                            "content": "<p>A playbook is an automated response workflow built using Azure Logic Apps. When a Sentinel incident is created, it can automatically trigger a playbook.</p><h3>Playbook Logic:</h3><p>Playbooks are visual workflows. You can drag and drop connectors for hundreds of services.</p><ul><li><strong>Example: Isolate a VM.</strong> The playbook is triggered by a high-severity Sentinel incident. It gets the compromised VM's name from the incident entities. It then makes an API call to Azure Networking to associate that VM's network interface with a 'Quarantine' Network Security Group that blocks all traffic. Finally, it posts a message to a Teams channel notifying the SOC team of the action taken.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542708944-9721d234a413?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "KQL Hunting Query for Suspicious PowerShell Downloads",
                        "language": "sql",
                        "code": "SecurityEvent\n| where EventID == 4688 and Process has \"powershell.exe\"\n| where CommandLine has_any (\"DownloadString\", \"DownloadFile\", \"IEX\", \"Invoke-WebRequest\")\n// Exclude known-good scripts or administrative tools\n| where CommandLine !has \"MyLegitAdminScript.ps1\"\n| project TimeGenerated, Computer, Account, CommandLine, ParentProcessName"
                    },
                    {
                        "title": "Logic App Playbook Definition (Simplified JSON View)",
                        "language": "json",
                        "code": "{\n    \"trigger\": {\n        \"type\": \"ApiConnectionWebhook\",\n        \"inputs\": {\n            \"body\": {\n                \"callback_url\": \"@{listCallbackUrl()}\"\n            },\n            \"host\": { \"connection\": { \"name\": \"@parameters('$connections')['azuresentinel']['connectionId']\" } },\n            \"path\": \"/incident-trigger\"\n        }\n    },\n    \"actions\": {\n        \"Isolate_VM_in_NSG\": {\n            \"type\": \"ApiConnection\",\n            \"inputs\": {\n                 // ... Logic to get VM and NSG details from trigger body\n            }\n        }\n    }\n}"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "The primary automation technology used to build Sentinel Playbooks is:", "options": ["Azure Functions", "Azure Logic Apps", "Azure Runbooks", "PowerShell"], "correct": 1, "explanation": "Logic Apps provide the visual designer and rich connector ecosystem for building SOAR playbooks in Sentinel." },
                        { "id": 2, "question": "Proactively searching through logs for threats using a hypothesis-driven approach is known as:", "options": ["Alerting", "Reporting", "Threat Hunting", "Compliance"], "correct": 2, "explanation": "Threat hunting is a key proactive activity for any mature SOC, and Sentinel's rich query capabilities make it a powerful platform for it." }
                    ]
                }
            },
            {
                "id": "lesson-27-mcas",
                "title": "Lesson 27: Microsoft Cloud App Security (MCAS)",
                "duration": "120 min",
                "objectives": [
                    "Understand the role of a Cloud Access Security Broker (CASB)",
                    "Use MCAS to discover 'Shadow IT' cloud application usage",
                    "Create policies to govern and secure sanctioned apps",
                    "Implement Data Loss Prevention (DLP) and threat protection for cloud apps"
                ],
                "content": {
                    "overview": "Your users are accessing hundreds of SaaS applications, many of which are not sanctioned by IT. Microsoft Cloud App Security (MCAS) is a Cloud Access Security Broker (CASB) that provides visibility and control over your data as it travels across these cloud apps. This lesson covers the core capabilities of MCAS.",
                    "sections": [
                        {
                            "title": "Shadow IT Discovery",
                            "content": "<p>MCAS can analyze logs from your firewalls and proxies to discover which cloud applications your users are actually using. It then provides a risk score for over 25,000 apps. This allows you to identify high-risk, unsanctioned application usage ('Shadow IT') and make informed decisions about whether to block or formally sanction an application.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "App Governance and Conditional Access",
                            "content": "<p>For your sanctioned applications (like Microsoft 365, Salesforce, etc.), you can connect them to MCAS via an API connector. This unlocks deep visibility and control.</p><h3>Session Policies:</h3><p>MCAS can be integrated with Azure AD Conditional Access to create powerful 'session policies'. For example, you can create a policy that says 'IF a user is logging into SharePoint from an unmanaged (BYOD) device, THEN allow access, BUT start an MCAS session that blocks them from downloading any files'. This provides real-time, in-browser controls to prevent data leakage.</p>",
                            "image": "https://images.unsplash.com/photo-1556742044-15b56a42a033?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary function of a Cloud Access Security Broker (CASB) like Microsoft Cloud App Security?", "options": ["To act as a firewall for a VNet", "To provide visibility and control over data and threats in cloud applications (SaaS)", "To scan virtual machines for vulnerabilities", "To manage user identities"], "correct": 1, "explanation": "A CASB acts as an intermediary control point between your users and the cloud applications they consume." },
                        { "id": 2, "question": "The process of using firewall logs to discover all the cloud apps being used within an organization, especially unsanctioned ones, is called:", "options": ["App Governance", "Shadow IT Discovery", "Threat Hunting", "Data Classification"], "correct": 1, "explanation": "'Shadow IT' refers to the technology and services that employees use without official approval, and discovering it is a primary use case for a CASB." },
                        { "id": 3, "question": "An MCAS policy that allows a user to access an app from their personal laptop but blocks them from downloading any sensitive files is a:", "options": ["File policy", "Access policy", "Session policy", "Threat detection policy"], "correct": 2, "explanation": "Session policies provide real-time, in-browser controls over a user's session within a cloud application." }
                    ]
                }
            },
            {
                "id": "lesson-28-aad-identity-protection",
                "title": "Lesson 28: Azure AD Identity Protection",
                "duration": "120 min",
                "objectives": [
                    "Differentiate between sign-in risk and user risk",
                    "Configure and enforce risk-based Conditional Access policies",
                    "Investigate risky users and sign-ins",
                    "Automate risk remediation workflows"
                ],
                "content": {
                    "overview": "Azure AD Identity Protection uses Microsoft's vast threat intelligence network to provide powerful, automated risk detection and remediation for your identities. This lesson covers how to use this service to protect your users from compromise.",
                    "sections": [
                        {
                            "title": "Sign-in Risk and User Risk",
                            "content": "<p>Identity Protection detects two types of risk:</p><ul><li><strong>Sign-in Risk:</strong> The probability that a given authentication request is not authorized by the identity owner. This is calculated in real-time. Examples of signals include 'anonymous IP address', 'atypical travel', or 'malware-linked IP'.</li><li><strong>User Risk:</strong> The probability that a given identity or account has been compromised. This is a longer-term calculation. Examples of signals include 'credentials leaked' (i.e., found on the dark web) or a history of high-risk sign-ins.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1614064548237-02f8f17374b2?w=800&h=400&fit-crop"
                        },
                        {
                            "title": "Risk Policy Configuration",
                            "content": "<p>You use these risk signals to create powerful automated security policies. There are two main policy types:</p><ul><li><strong>Sign-in risk policy:</strong> This policy acts on real-time sign-in risk. For example, 'IF sign-in risk is Medium or High, THEN require MFA'.</li><li><strong>User risk policy:</strong> This policy acts on the user's overall risk level. For example, 'IF user risk is High, THEN require password reset'.</li></ul><p>These policies can be configured directly in Identity Protection or, for more flexibility, as part of the broader Conditional Access policy framework.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "A user logging in from North America and then five minutes later from an IP in Asia would trigger which type of risk detection in Identity Protection?", "options": ["Leaked credentials", "Atypical travel / Impossible travel", "Anonymous IP address", "Malware-linked IP"], "correct": 1, "explanation": "This is a classic 'impossible travel' scenario that generates a high-risk, real-time sign-in event." },
                        { "id": 2, "question": "You want to create a policy that forces a user to change their password if their credentials are discovered in a public data breach dump. You would configure a:", "options": ["Sign-in risk policy", "User risk policy", "Device compliance policy", "Firewall policy"], "correct": 1, "explanation": "'Leaked credentials' affects the overall risk of the user account itself, so it's a user risk. Forcing a password reset is the appropriate remediation." },
                        { "id": 3, "question": "Risk-based policies are a powerful example of what security model?", "options": ["The traditional perimeter model", "The Zero Trust model", "A network-only security model", "A compliance-only model"], "correct": 1, "explanation": "They exemplify the Zero Trust principle of 'Verify Explicitly' by using real-time risk as a key signal in every authentication decision." }
                    ]
                }
            },
            {
                "id": "lesson-29-devops-security",
                "title": "Lesson 29: Azure DevOps Security",
                "duration": "120 min",
                "objectives": [
                    "Secure service connections to prevent credential exposure",
                    "Manage secrets using variable groups and Azure Key Vault integration",
                    "Integrate automated code scanning into pipelines",
                    "Secure build agents and artifacts"
                ],
                "content": {
                    "overview": "Your CI/CD pipeline is a high-value target for attackers; it has the keys to your production kingdom. This lesson covers the best practices for securing your Azure DevOps environment, focusing on protecting the pipeline and integrating security into the development workflow.",
                    "sections": [
                        {
                            "title": "Pipeline Security",
                            "content": "<ul><li><strong>Service Connections:</strong> When your pipeline needs to connect to Azure, you should use a 'Service Connection'. For Azure, the best practice is to use a 'Workload Identity Federation' or 'Service Principal' type that does *not* use a long-lived secret, but instead leverages a short-lived token.</li><li><strong>Secret Management:</strong> Do not store secrets as plain text variables in your pipeline. Use 'Variable Groups' and link them to Azure Key Vault. This allows your pipeline to securely fetch secrets from Key Vault at runtime.</li><li><strong>YAML Pipelines:</strong> Define your pipelines as code using YAML. This allows for version control, peer review, and the use of templates, which can enforce security best practices.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1498050108023-c5249f4df085?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Code Scanning Integration (SAST)",
                            "content": "<p>You can integrate Static Application Security Testing (SAST) tools directly into your pipeline. These tools scan your source code for security vulnerabilities. A common practice is to configure the pipeline to fail the build if the SAST scanner finds any high-severity vulnerabilities.</p>",
                            "image": "https://images.unsplash.com/photo-1555099962-4199c345e541?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Azure Pipeline YAML with Integrated Security Scan",
                        "language": "yaml",
                        "code": "trigger:\n- main\n\npool:\n  vmImage: 'ubuntu-latest'\n\nsteps:\n- task: UseDotNet@2\n  inputs:\n    version: '6.x'\n\n- script: dotnet build --configuration Release\n  displayName: 'Build Application'\n\n- task: SonarCloudPrepare@1\n  inputs:\n    SonarCloud: 'SonarCloudConnection'\n    organization: 'your-org'\n    scannerMode: 'MSBuild'\n    projectKey: 'your-project-key'\n\n- task: SonarCloudAnalyze@1\n\n- task: SonarCloudPublish@1"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the most secure way to manage secrets like database connection strings in an Azure DevOps pipeline?", "options": ["Store them in a text file in the source code repository", "Store them as plain text variables in the pipeline definition", "Use a Variable Group linked to Azure Key Vault to fetch them at runtime", "Email them to the lead developer"], "correct": 2, "explanation": "Key Vault integration provides a secure, auditable, and centralized way to manage secrets, completely separating them from the pipeline's definition and source code." },
                        { "id": 2, "question": "The practice of integrating automated security scanners directly into a CI/CD pipeline is a core principle of what?", "options": ["DevSecOps", "Incident Response", "Waterfall development", "Billing management"], "correct": 0, "explanation": "DevSecOps is all about 'shifting left' and making security an automated and integral part of the development process." }
                    ]
                }
            },
            {
                "id": "lesson-30-iac-security",
                "title": "Lesson 30: Infrastructure as Code Security",
                "duration": "120 min",
                "objectives": [
                    "Understand security best practices for ARM templates, Bicep, and Terraform",
                    "Use pre-flight validation and testing tools to find issues before deployment",
                    "Use Azure Policy to enforce security on IaC deployments",
                    "Prevent secret exposure in IaC templates"
                ],
                "content": {
                    "overview": "Infrastructure as Code (IaC) allows you to deploy infrastructure in a repeatable, automated way. This lesson covers how to secure your IaC templates and workflows, ensuring that you are deploying infrastructure that is secure-by-design.",
                    "sections": [
                        {
                            "title": "Template Validation and Testing",
                            "content": "<p>The biggest benefit of IaC for security is the ability to test it before it becomes real. You should integrate static analysis tools for your IaC templates into your CI/CD pipeline.</p><h3>Key Tools:</h3><ul><li><strong>ARM Template `what-if`:</strong> A feature of Azure Resource Manager that allows you to preview the changes that will be made by a deployment *without* actually applying them.</li><li><strong>Bicep Linter:</strong> Bicep has a built-in linter that checks for syntax errors and best practice violations.</li><li><strong>Static Analysis Tools:</strong> Open source tools like `Checkov` or `Terrascan` can scan ARM, Bicep, and Terraform templates for thousands of common security misconfigurations (e.g., public storage accounts, overly permissive NSG rules) and can fail a pipeline build if issues are found.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1555099962-4199c345e541?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Secret Management in IaC",
                            "content": "<p>You should NEVER hard-code a secret, like a VM password or a connection string, directly into an IaC template. This would save the secret in plain text in your source control repository.</p><h3>The Secure Pattern:</h3><p>Your IaC template should provision the resource (e.g., a VM). The template should then retrieve the password from Azure Key Vault at deployment time by referencing the Key Vault and the secret name. The secret itself is never in the template.</p>",
                            "image": "https://images.unsplash.com/photo-1599373922312-5b9340d8a5a5?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary security benefit of using Infrastructure as Code (IaC)?", "options": ["It makes deployments slower", "It allows you to codify, peer review, and automatically test your infrastructure's security posture before it is ever deployed", "It eliminates the need for security monitoring", "It costs more"], "correct": 1, "explanation": "IaC turns infrastructure into software, which means you can apply all the best practices of secure software development (like automated testing) to it." },
                        { "id": 2, "question": "To avoid storing a VM's password in a plain text ARM template, what should you do?", "options": ["Don't use a password", "Store the password in a text file next to the template", "Reference a secret stored in Azure Key Vault from within the template", "Email the password to yourself"], "correct": 2, "explanation": "Referencing secrets in Key Vault is the standard, secure pattern for handling sensitive data in IaC." },
                        { "id": 3, "question": "The ARM `what-if` operation allows you to do what?", "options": ["Deploy an ARM template", "Delete an ARM template", "Preview the changes a deployment will make without actually applying them", "Check your ARM template for spelling errors"], "correct": 2, "explanation": "The `what-if` operation is a crucial pre-flight check that helps prevent accidental and potentially destructive infrastructure changes." }
                    ]
                }
            },
            {
                "id": "lesson-31-container-devops-security",
                "title": "Lesson 31: Container DevOps Security",
                "duration": "120 min",
                "objectives": [
                    "Integrate container image scanning into a CI/CD pipeline",
                    "Use Azure Policy for AKS to enforce cluster-level security",
                    "Understand and secure the container supply chain"
                ],
                "content": {
                    "overview": "This lesson combines the concepts of container security and DevSecOps, focusing on how to build a secure CI/CD pipeline for containerized applications. The goal is a fully automated workflow that builds, scans, and deploys containers in a secure and compliant manner.",
                    "sections": [
                        {
                            "title": "Container Image Scanning in the Pipeline",
                            "content": "<p>The most critical step is to scan your container image for vulnerabilities during the build process. Tools like Microsoft Defender for Containers or third-party tools like Trivy can be integrated directly into your Azure DevOps or GitHub Actions pipeline. If a high-severity vulnerability is found in the base image or an installed package, the pipeline must fail, preventing the insecure image from being pushed to the registry.</p>",
                            "image": "https://images.unsplash.com/photo-1579543183319-a16eee1b1fd3?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Supply Chain Security",
                            "content": "<p>A container image is built from layers. You must trust every layer. Securing the supply chain involves:</p><ul><li><strong>Using Trusted Base Images:</strong> Only use official or hardened base images from trusted sources.</li><li><strong>Signing Images:</strong> Use a tool like Notary to cryptographically sign your images when they are pushed to your registry. Your AKS cluster can then be configured to only allow images that have a valid signature to run.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "To ensure that your AKS cluster only runs container images that were built by your trusted CI/CD pipeline, you should implement what?", "options": ["A Network Policy", "Image signing and an admission controller that enforces signatures", "A more powerful node type", "A load balancer"], "correct": 1, "explanation": "Image signing provides a cryptographic guarantee of the image's integrity and provenance." }
                    ]
                }
            },
            {
                "id": "lesson-32-security-testing-automation",
                "title": "Lesson 32: Security Testing Automation",
                "duration": "120 min",
                "objectives": [
                    "Integrate Static Application Security Testing (SAST) into your pipeline",
                    "Integrate Dynamic Application Security Testing (DAST) into your release process",
                    "Automate the scanning of third-party dependencies (SCA)",
                    "Fail pipeline builds based on security testing results"
                ],
                "content": {
                    "overview": "This DevSecOps lesson provides a broader look at the different types of automated security testing you can integrate into your development lifecycle to find vulnerabilities before they reach production.",
                    "sections": [
                        {
                            "title": "SAST, DAST, and SCA",
                            "content": "<ul><li><strong>Static Application Security Testing (SAST):</strong> A 'white-box' testing method. A SAST tool analyzes your application's source code directly, looking for potential vulnerabilities like SQL injection or buffer overflows. It runs early in the pipeline without needing a running application.</li><li><strong>Dynamic Application Security Testing (DAST):</strong> A 'black-box' testing method. A DAST tool attacks a *running* application from the outside, just as an attacker would. It probes the application's web front end for vulnerabilities. This is typically run in a staging environment later in the pipeline.</li><li><strong>Software Composition Analysis (SCA):</strong> This tool analyzes your project's dependencies (e.g., NuGet packages, npm libraries) and checks them against a database of known vulnerabilities. This is critical for managing supply chain risk.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1498050108023-c5249f4df085?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "A tool that analyzes your source code for vulnerabilities without running the application is a:", "options": ["DAST tool", "SCA tool", "SAST tool", "WAF"], "correct": 2, "explanation": "SAST tools are static, white-box scanners that work directly on the code itself." },
                        { "id": 2, "question": "To find vulnerabilities in the third-party open source libraries your application uses, you would run a(n):", "options": ["SAST scan", "DAST scan", "SCA scan", "Firewall"], "correct": 2, "explanation": "Software Composition Analysis (SCA) is specifically for managing the security of your dependencies, a key part of the software supply chain." }
                    ]
                }
            },
            {
                "id": "lesson-33-azure-ir",
                "title": "Lesson 33: Azure Incident Response",
                "duration": "120 min",
                "objectives": [
                    "Adapt the IR lifecycle for Azure environments",
                    "Use native Azure tools for evidence collection",
                    "Escalate to Microsoft Support and the DART team",
                    "Understand forensic investigation workflows in the cloud"
                ],
                "content": {
                    "overview": "When an incident happens, you need a plan. This lesson adapts the classic incident response framework to the Azure cloud, covering the specific tools and techniques used for detection, containment, eradication, and recovery in an Azure environment.",
                    "sections": [
                        {
                            "title": "Evidence Collection in Azure",
                            "content": "<p>Cloud evidence collection is API-driven. The key is to act quickly to preserve volatile data and create forensically sound copies of persistent data.</p><h3>Key Collection Actions:</h3><ul><li><strong>Preserve Logs:</strong> Ensure logs from Sentinel, Azure Monitor, and storage accounts are safe from deletion.</li><li><strong>Acquire Disk Snapshots:</strong> Take a snapshot of a VM's disk for offline forensic analysis.</li><li><strong>Acquire Memory Dump:</strong> For IaaS VMs, you can use built-in VM diagnostics or specialized tools to acquire a full memory dump. This is critical for investigating fileless malware.</li><li><strong>Network Packet Capture:</strong> Use Network Watcher to perform a packet capture on a VM's network interface.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1618498263386-339c9a7593c6?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Acquire a Disk Snapshot for Forensics (Azure CLI)",
                        "language": "bash",
                        "code": "# First, get the ID of the managed disk attached to the compromised VM\nDISK_ID=$(az vm show -g MyCompromisedRG -n MyCompromisedVM --query \"storageProfile.osDisk.managedDisk.id\" -o tsv)\n\n# Create the snapshot\naz snapshot create -g MyForensicsRG -n \"CompromisedDisk-Snapshot-IR123\" --source $DISK_ID"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the cloud-native equivalent of taking a physical hard drive and putting it on a write blocker to create a bit-for-bit image?", "options": ["Restarting the VM", "Creating a disk snapshot of the VM's managed disk", "Running a virus scan", "Calling Microsoft support"], "correct": 1, "explanation": "A snapshot is the primary, non-invasive method for creating a forensically sound copy of a VM's disk for offline analysis." }
                    ]
                }
            },
            {
                "id": "lesson-34-security-automation",
                "title": "Lesson 34: Security Automation",
                "duration": "120 min",
                "objectives": [
                    "Build automated security responses using Logic Apps and Azure Functions",
                    "Trigger automation from Azure Sentinel and Defender for Cloud",
                    "Use Event Grid for event-driven security workflows"
                ],
                "content": {
                    "overview": "This lesson focuses on the hands-on implementation of security automation in Azure. You will learn how to use serverless tools like Logic Apps and Functions to create auto-remediation workflows that respond to security events in real time.",
                    "sections": [
                        {
                            "title": "Logic Apps for Security (SOAR)",
                            "content": "<p>Azure Logic Apps are the engine behind Sentinel's SOAR playbooks. You can build powerful workflows that connect to hundreds of services.</p><h3>Example: Auto-remediate a Public Blob Container</h3><ol><li><strong>Trigger:</strong> An alert from Microsoft Defender for Cloud, 'Storage accounts should prevent public access', is sent to Event Grid.</li><li><strong>Logic App Trigger:</strong> A Logic App is triggered by the Event Grid event.</li><li><strong>Action:</strong> The Logic App's first step parses the event data to get the storage account's name and resource group.</li><li><strong>Remediation:</strong> The next step is an 'Azure Resource Manager' connector action that calls the Storage Account API to set the `allowBlobPublicAccess` property to `false`.</li><li><strong>Notification:</strong> The final step posts a message to a Teams channel, 'Remediated public access on storage account XYZ'.</li></ol>",
                            "image": "https://images.unsplash.com/photo-1542708944-9721d234a413?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "To build an automated workflow that is triggered by a security alert and then performs a series of actions across different services, which Azure service is the best fit?", "options": ["Azure Virtual Machines", "Azure Storage", "Azure Logic Apps", "Azure DNS"], "correct": 2, "explanation": "Logic Apps are Azure's primary service for serverless workflow orchestration and are the engine behind Sentinel SOAR." }
                    ]
                }
            },
            {
                "id": "lesson-35-threat-hunting-azure",
                "title": "Lesson 35: Threat Hunting in Azure",
                "duration": "150 min",
                "objectives": [
                    "Develop advanced threat hunting queries in KQL",
                    "Hunt for specific MITRE ATT&CK techniques in Azure logs",
                    "Use behavioral analytics and ML to find anomalies",
                    "Integrate threat intelligence into your hunting process"
                ],
                "content": {
                    "overview": "This lesson takes you deep into the proactive side of security operations. You will learn how to use the powerful Kusto Query Language (KQL) and the rich data in Azure Sentinel and Defender for Cloud to hunt for advanced threats that have evaded your automated detections.",
                    "sections": [
                        {
                            "title": "The Hunting Loop",
                            "content": "<p>Threat hunting is an iterative, human-driven process.</p><ol><li><strong>Hypothesis:</strong> 'I believe an attacker is using a specific LOLBAS (Living Off the Land Binary) to download their tools'.</li><li><strong>Hunt:</strong> Write a KQL query to search for that specific LOLBAS being used with suspicious parameters.</li><li><strong>Investigate:</strong> Analyze the results of your query. Do you see any unusual activity?</li><li><strong>Learn:</strong> Based on your findings, you either confirm the hypothesis (and create a new incident and detection rule) or you refine it and start a new hunt. The motto is: 'Never hunt for the same thing twice'. A successful hunt should always result in a new automated detection.</li></ol>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "KQL Hunt for Suspicious Service Creation",
                        "language": "sql",
                        "code": "// Hunt for attackers using sc.exe to create a malicious service for persistence\nSecurityEvent \n| where EventID == 4688 and Process has \"sc.exe\"\n| where CommandLine has \"create\" and CommandLine has \"binPath\""
                    },
                    {
                        "title": "KQL Hunt for Password Spray Attack",
                        "language": "sql",
                        "code": "SigninLogs\n| where ResultType == 50126 // Error code for 'InvalidCredentials'\n| summarize FailureCount = count(), DistinctUsers = dcount(UserPrincipalName) by SourceIPAddress\n| where FailureCount > 50 and DistinctUsers > 10 // Thresholds to be tuned"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What should be the ultimate output of a successful threat hunt?", "options": ["A long report", "A bill for the customer", "A new, automated analytics rule to detect the activity you found", "A new firewall"], "correct": 2, "explanation": "The motto 'never hunt the same thing twice' means that knowledge gained from a hunt should be codified into an automated detection, maturing your security posture and freeing up hunters to look for the next unknown threat." }
                    ]
                }
            },
            {
                "id": "lesson-36-recovery-bcdr",
                "title": "Lesson 36: Recovery and Business Continuity",
                "duration": "120 min",
                "objectives": [
                    "Integrate security considerations into DR and BCDR planning",
                    "Securely replicate resources across regions with ASR",
                    "Ensure security controls are tested as part of DR drills"
                ],
                "content": {
                    "overview": "Business Continuity and Disaster Recovery (BCDR) plans are essential for resilience, but they also have security implications. This lesson focuses on ensuring your recovery processes don't re-introduce vulnerabilities and that your DR site is just as secure as your primary site.",
                    "sections": [
                        {
                            "title": "Security in DR Planning",
                            "content": "<p>Your DR plan must consider security at every step.</p><ul><li><strong>Replication Security:</strong> Ensure that the network link used for replication between regions (e.g., for ASR) is secure.</li><li><strong>Configuration Sync:</strong> Your DR site isn't just a copy of your data; it needs to be a copy of your secure configuration. Ensure that your NSGs, Azure Policies, RBAC roles, and other security settings are replicated or defined in IaC so they are applied consistently during a failover.</li><li><strong>Identity:</strong> If your on-premises domain controllers go down, how will you authenticate to Azure? Your DR plan needs to account for the availability of the identity system itself.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1517048676732-d65bc937f952?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Why is it important to synchronize your security configurations (like NSGs and Policies) to your DR site?", "options": ["It is not important", "To ensure that when you fail over, you are failing over to an environment with the same security posture, not an insecure one", "To make the failover slower", "To increase costs"], "correct": 1, "explanation": "A common mistake is to only focus on data replication. You must also replicate your security controls to ensure your recovered environment is not vulnerable." }
                    ]
                }
            },
            {
                "id": "lesson-37-iot-security-azure",
                "title": "Lesson 37: IoT Security in Azure",
                "duration": "120 min",
                "objectives": [
                    "Secure an Azure IoT Hub and Device Provisioning Service (DPS)",
                    "Implement security for IoT Edge devices",
                    "Use Microsoft Defender for IoT for threat detection"
                ],
                "content": {
                    "overview": "Securing IoT solutions requires a layered approach, from the small devices at the edge to the cloud services they connect to. This lesson covers the security architecture of Microsoft's IoT platform on Azure.",
                    "sections": [
                        {
                            "title": "IoT Hub and DPS Security",
                            "content": "<p>Azure IoT Hub is the central message broker and management point for your IoT devices.</p><ul><li><strong>Authentication:</strong> IoT Hub supports several authentication methods, with X.509 certificates being the most secure for large-scale deployments.</li><li><strong>Device Provisioning Service (DPS):</strong> DPS allows for zero-touch, just-in-time provisioning of devices. When a new device comes online for the first time, it connects to DPS, proves its identity, and is then automatically registered with the correct IoT Hub with the correct credentials.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1544890225-2fde1e46f71b?w=800&h=400&fit-crop"
                        },
                        {
                            "title": "Microsoft Defender for IoT",
                            "content": "<p>Microsoft Defender for IoT is an agentless network detection and response (NDR) solution that provides visibility and threat detection for both IoT and OT (Operational Technology) environments. It can analyze the specialized protocols used in these environments to find threats, vulnerabilities, and misconfigurations.</p>",
                            "image": "https://images.unsplash.com/photo-1614113168853-39f1577f152d?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Which Azure service is used to automate the large-scale, secure onboarding of new IoT devices?", "options": ["Azure Functions", "Azure IoT Hub", "Azure IoT Device Provisioning Service (DPS)", "Azure Virtual Machines"], "correct": 2, "explanation": "DPS provides the secure and automated provisioning mechanism needed for deployments with thousands or millions of devices." },
                        { "id": 2, "question": "Which security solution provides agentless threat detection for both IoT and industrial OT environments by analyzing their specialized network protocols?", "options": ["Azure Sentinel", "Azure Firewall", "Microsoft Defender for IoT", "A Network Security Group"], "correct": 2, "explanation": "Defender for IoT is Microsoft's specialized offering for the unique security challenges of IoT/OT networks." }
                    ]
                }
            },
            {
                "id": "lesson-38-ai-ml-security-azure",
                "title": "Lesson 38: AI and ML Security",
                "duration": "120 min",
                "objectives": [
                    "Secure an Azure Machine Learning workspace and its associated resources",
                    "Protect sensitive training data and trained models",
                    "Understand threats against AI systems like data poisoning and model inversion"
                ],
                "content": {
                    "overview": "Your machine learning models are valuable intellectual property, and the data used to train them can be highly sensitive. This lesson covers the best practices for securing your entire AI/ML lifecycle in Azure Machine Learning.",
                    "sections": [
                        {
                            "title": "Securing Azure ML Workspaces",
                            "content": "<p>An Azure ML Workspace relies on several other Azure resources (like Storage, Key Vault, and Container Registry), so a holistic security approach is needed.</p><ul><li><strong>Network Isolation:</strong> The workspace and all its associated resources should be secured within a VNet using private endpoints.</li><li><strong>Identity and Access:</strong> Use Azure AD identities and RBAC to control access to the workspace. Create custom roles for different personas, like 'Data Scientist' (can run experiments) versus 'MLOps Engineer' (can deploy models).</li><li><strong>Protecting Data:</strong> Use RBAC on the underlying storage accounts to control who can access the training data. The trained models themselves are also stored in these accounts and must be protected.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1620712943543-959bab121695?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "How can you ensure an Azure ML workspace and its training data are not exposed to the public internet?", "options": ["By making the storage account public", "By securing the workspace and its associated resources within a VNet using private endpoints", "By using a simple password", "By storing the data on-premises"], "correct": 1, "explanation": "VNet integration and private endpoints are the primary mechanisms for network isolation of PaaS services like Azure ML." }
                    ]
                }
            },
            {
                "id": "lesson-39-industry-security",
                "title": "Lesson 39: Healthcare and Financial Services",
                "duration": "120 min",
                "objectives": [
                    "Use Azure Policy to audit and enforce HIPAA compliance",
                    "Design a PCI DSS compliant architecture in Azure",
                    "Apply industry-specific security best practices"
                ],
                "content": {
                    "overview": "Regulated industries like healthcare and finance have stringent security and compliance requirements. This lesson demonstrates how Azure services and features can be used to build environments that meet the demanding standards of HIPAA and PCI DSS.",
                    "sections": [
                        {
                            "title": "HIPAA and HITECH in Azure",
                            "content": "<p>To build a HIPAA-compliant environment, you must use Azure services that are covered under Microsoft's Business Associate Agreement (BAA). You must then configure these services correctly to protect Protected Health Information (PHI).</p><h3>Key Controls:</h3><ul><li><strong>Data Protection:</strong> Encrypt all PHI at rest (using TDE, SSE with CMK) and in transit (enforcing TLS).</li><li><strong>Access Control:</strong> Use strong RBAC, MFA, and PIM to enforce least-privilege access to PHI.</li><li><strong>Auditing:</strong> Enable and centralize logs from all services that touch PHI (e.g., Activity Log, Diagnostic Settings for Storage and SQL) into a secure Log Analytics workspace for monitoring.</li><li><strong>Governance:</strong> Use the built-in Azure Policy initiative for HIPAA/HITRUST to continuously audit your environment for compliance.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1538692125883-909953930b5e?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the easiest way to continuously audit your Azure environment against the technical controls required by a framework like PCI DSS?", "options": ["Doing a manual check once a year", "Hiring a consultant to look at it", "Assigning the built-in Azure Policy initiative for PCI DSS to your subscription", "Assuming it is compliant by default"], "correct": 2, "explanation": "Azure Policy provides powerful, automated, and continuous auditing capabilities that map directly to the technical controls of many major compliance frameworks." }
                    ]
                }
            },
            {
                "id": "lesson-40-government-cloud",
                "title": "Lesson 40: Government and Public Sector",
                "duration": "120 min",
                "objectives": [
                    "Understand the purpose and structure of Azure Government",
                    "Differentiate between Azure Government and the public Azure cloud",
                    "Recognize compliance frameworks like FedRAMP, DISA IL4/5, and CJIS"
                ],
                "content": {
                    "overview": "U.S. government agencies have the most stringent security and compliance requirements. To meet these needs, Microsoft operates a completely separate, air-gapped version of Azure called Azure Government. This lesson explores this specialized cloud environment.",
                    "sections": [
                        {
                            "title": "Azure Government",
                            "content": "<ul><li><strong>Physical and Logical Separation:</strong> Azure Government is a physically isolated instance of Azure located only in the United States. Its network is separate from the commercial Azure network.</li><li><strong>Screened Personnel:</strong> It is operated by screened U.S. persons.</li><li><strong>High-Level Compliance:</strong> It is built to meet the demanding compliance standards of the U.S. government, including FedRAMP High, DoD DISA Impact Levels 4 and 5, and support for CJIS (for law enforcement data) and IRS 1075 (for tax information).</li></ul><p>Functionally, it offers most of the same services as the commercial cloud, but with a much higher compliance and security bar.</p>",
                            "image": "https://images.unsplash.com/photo-1614064548237-02f8f17374b2?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is a primary reason for a U.S. Department of Defense agency to use Azure Government instead of the public Azure cloud?", "options": ["It is cheaper", "It has more regions worldwide", "It is physically located in the U.S., operated by screened U.S. persons, and built to meet high-level government compliance standards like DISA IL5", "It has more features"], "correct": 2, "explanation": "Azure Government is specifically designed and accredited to handle the high-impact, sensitive workloads of the U.S. public sector." }
                    ]
                }
            },
            {
                "id": "lesson-41-hybrid-identity",
                "title": "Lesson 41: Hybrid Identity Security",
                "duration": "120 min",
                "objectives": [
                    "Securely implement Azure AD Connect to synchronize on-premises identities",
                    "Understand the security models of PHS, PTA, and Federation",
                    "Protect AD FS infrastructure when using federation"
                ],
                "content": {
                    "overview": "For most enterprises, the identity journey to the cloud is a hybrid one, starting with an on-premises Active Directory. This lesson covers how to securely extend your on-premises identities to the cloud using Azure AD Connect.",
                    "sections": [
                        {
                            "title": "Azure AD Connect Models",
                            "content": "<p>Azure AD Connect is the tool that synchronizes your on-premises AD DS objects (users, groups) to Azure AD. It offers three primary methods for handling authentication:</p><ul><li><strong>Password Hash Synchronization (PHS - Recommended):</strong> The on-premises password hash is synchronized to Azure AD. Authentication happens directly in the cloud. This is the simplest and most resilient option.</li><li><strong>Pass-through Authentication (PTA):</strong> The user's authentication request is passed through from Azure AD to an on-premises agent that validates the password against your local AD DS.</li><li><strong>Federation (with AD FS):</strong> The most complex option. Authentication is fully delegated to an on-premises Active Directory Federation Services (AD FS) farm.</li></ul><p>For most organizations, PHS provides the best balance of security, simplicity, and user experience.</p>",
                            "image": "https://images.unsplash.com/photo-1554224155-83e8b835d07a?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary tool used to synchronize on-premises Active Directory users to Azure AD?", "options": ["Azure Firewall", "Azure AD Connect", "Azure Migrate", "ExpressRoute"], "correct": 1, "explanation": "Azure AD Connect is the dedicated Microsoft tool for managing hybrid identity synchronization." }
                    ]
                }
            },
            {
                "id": "lesson-42-migration-security",
                "title": "Lesson 42: Migration Security",
                "duration": "120 min",
                "objectives": [
                    "Integrate security into the cloud migration process using the Cloud Adoption Framework (CAF)",
                    "Use Azure Migrate to assess on-premises workloads for security requirements",
                    "Apply security baselines and best practices as part of the migration"
                ],
                "content": {
                    "overview": "Migrating to the cloud is an opportunity to improve your security posture, not just 'lift and shift' old problems. This lesson covers how to integrate security into your migration strategy, ensuring that what you build in the cloud is more secure than what you had on-premises.",
                    "sections": [
                        {
                            "title": "Security in the Cloud Adoption Framework (CAF)",
                            "content": "<p>The Microsoft Cloud Adoption Framework (CAF) provides comprehensive guidance for cloud adoption. The 'Secure' methodology within the CAF is a critical part of this.</p><h3>Key Takeaways:</h3><ul><li><strong>Security is a Continuous Process:</strong> Security should be considered at every stage: defining strategy, planning, getting ready (building your landing zone), and adopting (migrating).</li><li><strong>Assess Before You Migrate:</strong> Use tools like Azure Migrate to inventory and assess your on-premises servers. This includes dependency mapping to understand what your applications need to talk to, which informs the NSG rules you will need to build in Azure.</li><li><strong>Remediate During Migration:</strong> The migration is the perfect time to fix old problems. Don't migrate a server with an outdated, vulnerable operating system. Instead, migrate the application to a new, patched, and hardened PaaS service or VM.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the key security principle of a cloud migration?", "options": ["Migrate everything as fast as possible without planning", "Use the migration as an opportunity to improve security posture and remediate old issues", "Exactly replicate your on-premises security problems in the cloud", "Focus only on cost and not on security"], "correct": 1, "explanation": "A successful migration doesn't just move workloads; it transforms them and makes them more secure, resilient, and manageable." }
                    ]
                }
            },
            {
                "id": "lesson-43-third-party-integration",
                "title": "Lesson 43: Third-Party Integration",
                "duration": "120 min",
                "objectives": [
                    "Securely grant access to third-party SaaS applications using App Registrations",
                    "Understand OAuth 2.0 consent and permissions",
                    "Review and govern permissions granted to third-party apps"
                ],
                "content": {
                    "overview": "Your organization uses dozens of third-party SaaS applications that may require access to your Microsoft 365 or Azure data. This lesson covers how to manage this integration securely using Azure AD's application model.",
                    "sections": [
                        {
                            "title": "App Registrations and Consent",
                            "content": "<p>When you integrate a third-party app with Azure AD, an 'App Registration' is created in your tenant. When a user first uses this app, they are presented with a 'consent prompt'. This prompt lists the specific permissions the application is asking for (e.g., 'Read your user profile', 'Read your mail').</p><h3>Security Governance:</h3><p>As an administrator, you can configure how this consent is handled. Best practice is to require administrator consent for any application that asks for high-privilege permissions. You can then use the 'Admin consent workflow' to review and approve or deny these requests. This prevents users from accidentally granting excessive permissions to a malicious application.</p>",
                            "image": "https://images.unsplash.com/photo-1556742044-15b56a42a033?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "To prevent users from granting risky permissions to third-party applications, an administrator should configure what?", "options": ["Let all users consent to all apps", "The admin consent workflow, which requires an admin to approve permission requests", "Remove all third-party apps", "Block all internet access"], "correct": 1, "explanation": "The admin consent workflow is a critical governance control for managing the security of your SaaS application ecosystem." }
                    ]
                }
            },
            {
                "id": "lesson-44-cost-resource-security",
                "title": "Lesson 44: Cost and Resource Security",
                "duration": "120 min",
                "objectives": [
                    "Use Microsoft Cost Management to set budgets and alerts",
                    "Apply resource locks to prevent accidental deletion of critical infrastructure",
                    "Leverage tagging for security governance and chargeback"
                ],
                "content": {
                    "overview": "Securing your resources also means protecting them from accidental deletion and preventing uncontrolled costs that could indicate abuse. This lesson covers the Azure features for financial and operational governance.",
                    "sections": [
                        {
                            "title": "Resource Locks",
                            "content": "<p>A Resource Lock is a simple but powerful safety feature that prevents a resource from being accidentally modified or deleted. There are two types of locks:</p><ul><li><strong>ReadOnly:</strong> Users can read the resource, but cannot modify or delete it.</li><li><strong>CanNotDelete:</strong> Users can read and modify the resource, but cannot delete it.</li></ul><p>You should apply a `CanNotDelete` lock to all of your critical production resources, like your production VNet or your ExpressRoute circuit. Even an Owner of the subscription cannot delete a locked resource without first removing the lock.</p>",
                            "image": "https://images.unsplash.com/photo-1599691888286-93e433f064b8?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Apply a Delete Lock to a Resource Group (Azure CLI)",
                        "language": "bash",
                        "code": "az lock create --name \"CantDeleteRG-Lock\" --lock-type CanNotDelete --resource-group MyProductionRG"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary purpose of applying a 'CanNotDelete' resource lock to a critical resource group?", "options": ["To encrypt the resources", "To provide a strong safeguard against accidental deletion by any user, including administrators", "To monitor the resources for threats", "To back up the resources"], "correct": 1, "explanation": "Resource locks are a fundamental governance control for protecting your most important infrastructure from human error." }
                    ]
                }
            },
            {
                "id": "lesson-45-enterprise-security-architecture",
                "title": "Lesson 45: Enterprise Security Architecture",
                "duration": "150 min",
                "objectives": [
                    "Design a secure landing zone using the Cloud Adoption Framework",
                    "Implement the hub-and-spoke network security model",
                    "Establish an enterprise-scale governance and security baseline"
                ],
                "content": {
                    "overview": "This lesson brings everything together at a strategic level, focusing on designing a comprehensive, enterprise-scale security architecture in Azure. We will cover the standard 'hub-and-spoke' network model and the principles of Enterprise-Scale Landing Zones.",
                    "sections": [
                        {
                            "title": "Hub and Spoke Security Model",
                            "content": "<p>This is the standard, Microsoft-recommended architecture for enterprise networking in Azure.</p><ul><li><strong>Hub VNet:</strong> A central VNet that contains all your shared security and connectivity services. This is where you would place your Azure Firewall, your VPN/ExpressRoute gateways, and potentially shared domain controllers.</li><li><strong>Spoke VNets:</strong> Your individual application workloads are deployed in their own spoke VNets.</li><li><strong>VNet Peering:</strong> Each spoke VNet is peered to the central hub VNet.</li><li><strong>Forced Tunneling:</strong> User-Defined Routes (UDRs) are used on the spoke subnets to force all outbound traffic to be routed through the Azure Firewall in the hub for inspection.</li></ul><p>This model provides central control, cost savings (you only need one firewall), and clear segmentation between workloads.</p>",
                            "image": "https://images.unsplash.com/photo-1461749280684-dccba630e2f6?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "In a hub-and-spoke network architecture, where should you place your central Azure Firewall?", "options": ["In every spoke VNet", "In the hub VNet", "In your on-premises datacenter", "It is not needed"], "correct": 1, "explanation": "The hub is the central point of transit and control for all network traffic, making it the logical and most efficient place to deploy shared security appliances like Azure Firewall." }
                    ]
                }
            },
            {
                "id": "lesson-46-zero-trust",
                "title": "Lesson 46: Zero Trust Implementation",
                "duration": "120 min",
                "objectives": [
                    "Apply the core principles of Zero Trust to your Azure architecture",
                    "Use Azure AD Conditional Access to verify identity signals",
                    "Implement least-privilege network access using NSGs and private endpoints",
                    "Use Microsoft Defender for Cloud and Sentinel to 'assume breach'"
                ],
                "content": {
                    "overview": "This lesson synthesizes everything you've learned through the lens of the Zero Trust security model. We will revisit key services and show how they map directly to the three core principles of Zero Trust: Verify Explicitly, Use Least Privileged Access, and Assume Breach.",
                    "sections": [
                        {
                            "title": "Implementing the Principles in Azure",
                            "content": "<ul><li><strong>Verify Explicitly:</strong> This is primarily implemented with **Azure AD Conditional Access**. For every access request, it verifies multiple signals: user identity (with MFA), device health (with Microsoft Endpoint Manager compliance), location, and real-time risk (from Identity Protection).</li><li><strong>Use Least Privileged Access:</strong> This is implemented across multiple layers. At the identity layer, **PIM** provides JIT access. At the resource layer, **RBAC** provides JEA access. At the network layer, **NSGs**, **Network Policies**, and **Private Endpoints** provide micro-segmentation.</li><li><strong>Assume Breach:</strong> This means you need comprehensive visibility and rapid response capabilities. This is provided by **Microsoft Defender for Cloud** (for workload protection) and **Azure Sentinel** (for SIEM/SOAR). You assume a compromise will happen, and you build the capabilities to detect and contain it quickly.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1510915228340-29c85a43dcfe?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Using PIM to grant a user temporary access to a role is an example of which Zero Trust principle?", "options": ["Verify Explicitly", "Use Least Privileged Access", "Assume Breach"], "correct": 1, "explanation": "Just-in-Time (JIT) access is a core tenet of least privilege, ensuring users don't have standing, permanent access to sensitive roles." }
                    ]
                }
            },
            {
                "id": "lesson-47-soc-design-azure",
                "title": "Lesson 47: Security Operations Center (SOC) Design for Azure",
                "duration": "120 min",
                "objectives": [
                    "Design a modern SOC workflow using Azure-native tools",
                    "Understand the relationship between Defender for Cloud, Sentinel, and Azure Monitor",
                    "Develop escalation procedures and metrics for an Azure SOC"
                ],
                "content": {
                    "overview": "This lesson focuses on the operational aspect of security, explaining how Azure's primary security services work together to support a modern Security Operations Center (SOC).",
                    "sections": [
                        {
                            "title": "The Azure SOC Toolchain",
                            "content": "<p>The three key services work together as a pipeline:</p><ol><li><strong>Azure Monitor:</strong> The foundational layer. It collects all the raw logs and metrics from your entire Azure environment into a Log Analytics Workspace.</li><li><strong>Microsoft Defender for Cloud:</strong> This layer sits on top of the logs. It provides CSPM (finding misconfigurations) and CWP (generating high-quality alerts about your workloads, like 'malware detected on VM XYZ').</li><li><strong>Azure Sentinel:</strong> The top layer. It is the 'SIEM on top'. It ingests all the alerts from Defender for Cloud, along with logs from Azure Monitor and many other sources (like firewalls and Office 365). It then allows you to correlate these findings, perform threat hunting, and orchestrate a response (SOAR).</li></ol>",
                            "image": "https://images.unsplash.com/photo-1614064548237-02f8f17374b2?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "In the Azure SOC toolchain, which service acts as the central SIEM and SOAR platform?", "options": ["Azure Monitor", "Microsoft Defender for Cloud", "Azure Sentinel", "Azure Policy"], "correct": 2, "explanation": "Sentinel is the 'single pane of glass' for security operations, ingesting alerts and logs from all other sources for correlation and response." }
                    ]
                }
            },
            {
                "id": "lesson-48-advanced-compliance",
                "title": "Lesson 48: Advanced Compliance",
                "duration": "120 min",
                "objectives": [
                    "Use Azure Blueprints to package and deploy compliant environments",
                    "Create custom policy initiatives for specific compliance needs",
                    "Prepare for and manage a formal audit of your Azure environment"
                ],
                "content": {
                    "overview": "For organizations with complex compliance needs, Azure Blueprints provides a powerful way to define and deploy repeatable, governed environments. This lesson covers how to use Blueprints to scale your compliance efforts.",
                    "sections": [
                        {
                            "title": "Azure Blueprints",
                            "content": "<p>An Azure Blueprint is a package or container for composing a set of 'artifacts' that implement your standards. A single blueprint can contain:</p><ul><li>A set of ARM Templates to deploy the base infrastructure.</li><li>A set of RBAC role assignments to apply your standard permissions.</li><li>A set of Policy assignments to enforce your governance rules.</li></ul><p>You can then 'assign' this blueprint to a new subscription. This automates the process of setting up a new environment that is compliant-by-default with your organization's standards.</p>",
                            "image": "https://images.unsplash.com/photo-1498050108023-c5249f4df085?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary function of an Azure Blueprint?", "options": ["To monitor for threats", "To provide a repeatable, packageable way to deploy entire environments complete with infrastructure, policies, and RBAC", "To back up your data", "To manage user identities"], "correct": 1, "explanation": "Blueprints are a key tool for cloud governance at scale, enabling the rapid deployment of pre-approved, compliant environments." }
                    ]
                }
            },
            {
                "id": "lesson-49-security-assessment-pen-testing",
                "title": "Lesson 49: Security Assessment and Penetration Testing",
                "duration": "120 min",
                "objectives": [
                    "Use native Azure tools to assess security posture",
                    "Understand the Microsoft Cloud Penetration Testing Rules of Engagement",
                    "Differentiate between a vulnerability assessment and a penetration test"
                ],
                "content": {
                    "overview": "Validating your security controls requires a combination of automated assessment and human-led testing. This lesson revisits the concepts of assessment and penetration testing, focusing on the rules and best practices for conducting them against your Azure environment.",
                    "sections": [
                        {
                            "title": "Vulnerability Assessment vs. Penetration Testing",
                            "content": "<p>It's important to understand the difference:</p><ul><li><strong>Vulnerability Assessment:</strong> A broad scan that aims to find and report a list of known potential vulnerabilities. The goal is breadth. Tools like Defender for Cloud's vulnerability scanner perform this.</li><li><strong>Penetration Test:</strong> A deep, goal-oriented attack simulation. A human tester actively tries to exploit the vulnerabilities found to see how far they can get. The goal is depth.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1614064548237-02f8f17374b2?w=800&h=400&fit-crop"
                        },
                        {
                            "title": "Penetration Testing Rules of Engagement",
                            "content": "<p>Microsoft has a formal set of Rules of Engagement for penetration testing. Before starting a test, you must review and agree to them. While Microsoft no longer requires pre-approval for most tests, certain high-risk activities (like performing a DDoS attack) are strictly forbidden.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "An automated scan that checks your systems against a list of known CVEs is a:", "options": ["Penetration test", "Vulnerability assessment", "Threat hunt", "Firewall"], "correct": 1, "explanation": "A vulnerability assessment is a broad, automated process focused on finding potential weaknesses. A penetration test is a manual, in-depth process focused on exploiting them." }
                    ]
                }
            },
            {
                "id": "lesson-50-final-capstone-project",
                "title": "Lesson 50: Final Capstone Project",
                "duration": "240 min",
                "objectives": [
                    "Design and build a complete, end-to-end secure Azure solution for a complex, realistic scenario",
                    "Integrate multiple security services across identity, network, data, and applications",
                    "Produce a professional-quality security architecture document and a set of IaC templates"
                ],
                "content": {
                    "overview": "The capstone project is the culmination of the entire course. You will be given a detailed business and security requirements document for a fictional company. Your mission is to act as the lead cloud security architect, designing and deploying a secure, compliant, and well-architected Azure environment that meets all their needs.",
                    "sections": [
                        {
                            "title": "The Capstone Scenario",
                            "content": "<p><strong>The Task:</strong> You are tasked with designing the Azure environment for 'Contoso Health', a healthcare organization that is migrating its patient portal application to Azure. The solution must be HIPAA compliant and follow Zero Trust principles.</p><h3>Your Deliverables:</h3><ol><li><strong>Security Architecture Document:</strong> A detailed document outlining your proposed architecture, including network diagrams (hub-and-spoke), identity strategy (PIM, Conditional Access), data protection controls (encryption, Key Vault), and the monitoring plan (Defender for Cloud, Sentinel).</li><li><strong>Infrastructure as Code (IaC):</strong> A set of Bicep or Terraform templates that will deploy your core infrastructure.</li><li><strong>Policy and Governance:</strong> A custom Azure Policy initiative that enforces key HIPAA technical controls.</li><li><strong>Presentation:</strong> A final presentation to a panel of 'executives' where you justify your architectural decisions.</li></ol>",
                            "image": "https://images.unsplash.com/photo-1498050108023-c5249f4df085?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 100,
                    "questions": [
                        { "id": 1, "question": "The capstone project requires you to:", "options": ["Write a single firewall rule", "Answer multiple choice questions", "Demonstrate mastery of the course by synthesizing knowledge from all domains into a single, comprehensive, practical solution", "Restart a virtual machine"], "correct": 2, "explanation": "This project serves as the final, all-encompassing test of your ability to function as a cloud security professional, moving from theory to implementation." }
                    ]
                }
            }
        ]
    }
      // =====================================================
      // GLOBAL VARIABLES
      // =====================================================
      let currentUser = null;
      let currentLessonIndex = 0;
      let courseProgress = {};
      let userStats = {};
      let quizState = {
        currentQuestion: 0,
        answers: [],
        score: 0,
        isComplete: false,
      };

      // Enhanced session tracking
      let courseSession = {
        startTime: null,
        totalStudyTime: 0,
        lessonsStarted: 0,
        lessonsCompleted: 0,
        pageLoadTime: new Date(),
        interactionCount: 0,
        lastActivityTime: new Date(),
      };

      // Music Player Variables
      let audioPlayer = new Audio();

      // Achievement notification system
      let notificationQueue = [];
      let isShowingNotification = false;

      // =====================================================
      // INITIALIZATION
      // =====================================================
      document.addEventListener("DOMContentLoaded", async () => {
        try {
          showLoadingScreen();
          await checkAuth();

          if (currentUser) {
            // Initialize session tracking
            startCourseSession();

            // Load course data and progress
            await loadCourseData();
            await loadUserProfile();
            await loadProgress();

            // Initialize UI
            initializeEventListeners();
            renderSidebar();
            loadLesson(currentLessonIndex);

            // Initialize additional features
            initMusicPlayer();
            addMusicIndicator();
            initializeActivityTracking();

            hideLoadingScreen();
          } else {
            openAuthModal();
          }
        } catch (error) {
          console.error("Error initializing course:", error);
          hideLoadingScreen();
          showToast("Failed to initialize course system", "error");
        }
      });

      // =====================================================
      // AUTHENTICATION SYSTEM
      // =====================================================
      async function checkAuth() {
        try {
          const {
            data: { session },
            error,
          } = await supabase.auth.getSession();

          if (error) {
            console.error("Auth error:", error);
            currentUser = null;
            openAuthModal();
            return;
          }

          if (!session) {
            currentUser = null;
            openAuthModal();
            return;
          }

          currentUser = session.user;
          updateUIWithUser();
        } catch (error) {
          console.error("Error checking auth:", error);
          currentUser = null;
          openAuthModal();
        }
      }

      function updateUIWithUser() {
        if (!currentUser) return;

        const name =
          currentUser.user_metadata?.full_name ||
          currentUser.email.split("@")[0];
        const userElements = document.querySelectorAll("[data-user-name]");
        userElements.forEach((el) => (el.textContent = name));
      }

      // =====================================================
      // USER PROFILE & STATS MANAGEMENT
      // =====================================================
      async function loadUserProfile() {
        try {
          //  Step 1: Try to fetch existing profile
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("*")
            .eq("id", currentUser.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (!profile) {
            //  Step 2: Create new profile if missing
            await createUserProfile();
          } else {
            //  Step 3: Use existing profile
            userStats = profile;
            await updateLastActivity();
          }
        } catch (error) {
          console.error(" Error loading user profile:", error);
          showToast("Failed to load user profile", "error");
        }
      }
      async function createUserProfile() {
        try {
          const newProfile = {
            id: currentUser.id,
            full_name: currentUser.user_metadata?.full_name || "",
            email: currentUser.email,
            level: "Script Kiddie",
            total_points: 0,
            completed_courses: 0,
            current_streak: 0,
            total_certificates: 0,
            total_achievements: 0,
            sections_visited: 0,
            bonus_points: 0,
            in_progress_courses: 0,
            settings_changed: 0,
            midnight_sessions: 0,
            early_sessions: 0,
            weekend_sessions: 0,
            last_activity: new Date().toISOString(),
            created_at: new Date().toISOString(),
          };

          const { error } = await supabase
            .from("profiles")
            .insert([newProfile]);

          if (!error) {
            userStats = newProfile;
            // Award first login achievement
            setTimeout(() => checkAndUnlockAchievement("first_login"), 1000);
          }
        } catch (error) {
          console.error("Error creating user profile:", error);
        }
      }

      async function updateLastActivity() {
        try {
          const now = new Date();

          // Update activity tracking
          courseSession.lastActivityTime = now;

          // Update database
          await supabase
            .from("profiles")
            .update({
              last_activity: now.toISOString(),
            })
            .eq("id", currentUser.id);

          // Check time-based achievements
          await checkTimeBasedAchievements(now);
        } catch (error) {
          console.error("Error updating last activity:", error);
        }
      }

      // =====================================================
      // COURSE SESSION MANAGEMENT
      // =====================================================
      function startCourseSession() {
        courseSession.startTime = new Date();
        courseSession.pageLoadTime = new Date();

        logUserActivity("course_session_start", {
          course_id: COURSE_DATA.id,
          course_title: COURSE_DATA.title,
          user_agent: navigator.userAgent,
          screen_resolution: `${screen.width}x${screen.height}`,
        });

        // Check daily streak
        checkDailyStreak();
      }

      function initializeActivityTracking() {
        // Track page focus/blur for accurate study time
        document.addEventListener("visibilitychange", handleVisibilityChange);

        // Track user interactions
        ["click", "keydown", "scroll", "mousemove"].forEach((event) => {
          document.addEventListener(event, trackUserInteraction, {
            passive: true,
          });
        });

        // Periodic activity updates
        setInterval(updateStudyTime, 60000); // Every minute

        // Save session data before page unload
        window.addEventListener("beforeunload", saveSessionData);
      }

      function handleVisibilityChange() {
        if (document.hidden) {
          courseSession.lastActivityTime = new Date();
        } else {
          // Page became visible again - update activity
          updateLastActivity();
        }
      }

      function trackUserInteraction() {
        courseSession.interactionCount++;
        courseSession.lastActivityTime = new Date();

        // Throttle activity updates
        if (courseSession.interactionCount % 50 === 0) {
          updateLastActivity();
        }
      }

      function updateStudyTime() {
        if (!courseSession.startTime || document.hidden) return;

        const now = new Date();
        const sessionDuration = now - courseSession.startTime;
        courseSession.totalStudyTime = Math.floor(sessionDuration / 1000 / 60); // in minutes

        // Update progress with study time
        saveProgress();
      }

      function saveSessionData() {
        if (!currentUser || !courseSession.startTime) return;

        const sessionData = {
          user_id: currentUser.id,
          course_id: COURSE_DATA.id,
          session_duration: courseSession.totalStudyTime,
          lessons_viewed: courseSession.lessonsStarted,
          lessons_completed: courseSession.lessonsCompleted,
          interactions: courseSession.interactionCount,
          session_date: courseSession.startTime.toISOString().split("T")[0],
        };

        // Store in localStorage as backup
        localStorage.setItem(
          "course_session_backup",
          JSON.stringify(sessionData)
        );

        // Try to save to database
        logUserActivity("course_session_end", sessionData);
      }

      // =====================================================
      // COURSE DATA & PROGRESS MANAGEMENT
      // =====================================================
      async function loadCourseData() {
        try {
          // Update course info in UI
          document.getElementById("courseTitle").textContent =
            COURSE_DATA.title;
          document.getElementById("totalLessons").textContent =
            COURSE_DATA.lessons.length;

          // Log course access
          logUserActivity("course_access", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
          });
        } catch (error) {
          console.error("Error loading course data:", error);
        }
      }

      async function loadProgress() {
        try {
          // Get existing progress from database
          const { data, error } = await supabase
            .from("course_progress")
            .select("*")
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (data) {
            courseProgress = JSON.parse(data.lesson_progress || "{}");
            currentLessonIndex = data.current_lesson || 0;

            // Update session tracking
            courseSession.lessonsStarted = Object.keys(courseProgress).length;
            courseSession.lessonsCompleted = Object.values(
              courseProgress
            ).filter((p) => p.completed).length;
          } else {
            // Initialize new progress
            courseProgress = {};
            currentLessonIndex = 0;
            await saveProgress();

            // Award first course start achievement
            await checkAndUnlockAchievement("first_course_start");
          }

          updateProgressDisplay();
        } catch (error) {
          console.error("Error loading progress:", error);
          showToast("Failed to load progress", "error");
        }
      }

      async function saveProgress() {
        try {
          if (!currentUser) return;

          const now = new Date();
          const progressData = {
            user_id: currentUser.id,
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            current_lesson: currentLessonIndex,
            lesson_progress: JSON.stringify(courseProgress),
            progress: calculateOverallProgress(),
            lessons_completed: getCompletedLessonsCount(),
            lessons_started: Object.keys(courseProgress).length,
            study_time_minutes: courseSession.totalStudyTime,
            last_accessed: now.toISOString(),
            updated_at: now.toISOString(),
          };

          // Upsert progress
          const { error } = await supabase
            .from("course_progress")
            .upsert([progressData]);

          if (error) throw error;

          // Update user stats
          await updateUserStats();

          updateProgressDisplay();
        } catch (error) {
          console.error("Error saving progress:", error);
          showToast("Failed to save progress", "error");
        }
      }

      async function updateUserStats() {
        try {
          // Get all course progress for this user
          const { data: allProgress, error } = await supabase
            .from("course_progress")
            .select("progress, course_id, study_time_minutes")
            .eq("user_id", currentUser.id);

          if (error) throw error;

          // Calculate stats
          const completedCourses =
            allProgress?.filter((p) => p.progress >= 100).length || 0;
          const inProgressCourses =
            allProgress?.filter((p) => p.progress > 0 && p.progress < 100)
              .length || 0;
          const totalStudyTime =
            allProgress?.reduce(
              (sum, p) => sum + (p.study_time_minutes || 0),
              0
            ) || 0;

          // Calculate points (500 per completed course + achievement points)
          const coursePoints = completedCourses * 500;
          const bonusPoints = userStats.bonus_points || 0;
          const totalPoints = coursePoints + bonusPoints;

          // Update profile
          const updateData = {
            completed_courses: completedCourses,
            in_progress_courses: inProgressCourses,
            total_points: totalPoints,
            total_study_time: totalStudyTime,
            last_activity: new Date().toISOString(),
          };

          const { error: updateError } = await supabase
            .from("profiles")
            .update(updateData)
            .eq("id", currentUser.id);

          if (updateError) throw updateError;

          // Update local stats
          Object.assign(userStats, updateData);
        } catch (error) {
          console.error("Error updating user stats:", error);
        }
      }

      function calculateOverallProgress() {
        const completedLessons = getCompletedLessonsCount();
        return Math.round(
          (completedLessons / COURSE_DATA.lessons.length) * 100
        );
      }

      function getCompletedLessonsCount() {
        return Object.values(courseProgress).filter(
          (lesson) => lesson.completed
        ).length;
      }

      function updateProgressDisplay() {
        const completedCount = getCompletedLessonsCount();
        const progressPercent = calculateOverallProgress();

        // Update UI elements
        const elements = {
          completedLessons: completedCount,
          courseProgressPercent: `${progressPercent}%`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });

        // Update progress bar
        const progressBar = document.getElementById("courseProgressFill");
        if (progressBar) progressBar.style.width = `${progressPercent}%`;
      }

      // =====================================================
      // LESSON MANAGEMENT
      // =====================================================
      function loadLesson(index) {
        if (index < 0 || index >= COURSE_DATA.lessons.length) return;

        const lesson = COURSE_DATA.lessons[index];
        currentLessonIndex = index;

        // Mark lesson as started and track activity
        if (!courseProgress[lesson.id]) {
          courseProgress[lesson.id] = {
            started: true,
            completed: false,
            startedAt: new Date().toISOString(),
            timeSpent: 0,
          };

          courseSession.lessonsStarted++;
          saveProgress();

          // Log lesson start
          logUserActivity("lesson_start", {
            lesson_id: lesson.id,
            lesson_title: lesson.title,
            lesson_index: index,
          });
        }

        // Update lesson start time for time tracking
        courseProgress[lesson.id].currentSessionStart = new Date();

        // Update sidebar and navigation
        renderSidebar();
        updateNavigationButtons();

        // Update header info
        updateLessonHeader(lesson, index);

        // Render lesson content
        renderLessonContent(lesson);

        // Smooth scroll and animations
        window.scrollTo({ top: 0, behavior: "smooth" });
        document.getElementById("contentBody").scrollTop = 0;

        const contentBody = document.getElementById("contentBody");
        contentBody.classList.add("fade-in");
        setTimeout(() => contentBody.classList.remove("fade-in"), 500);

        // Check lesson-based achievements
        checkLessonAchievements(index + 1);
      }

      function updateLessonHeader(lesson, index) {
        const elements = {
          currentLessonNumber: index + 1,
          currentLessonTitle: lesson.title,
          navInfo: `Lesson ${index + 1} of ${COURSE_DATA.lessons.length}`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });
      }

      function renderSidebar() {
        const lessonNav = document.getElementById("lessonNav");
        if (!lessonNav) return;

        lessonNav.innerHTML = "";

        COURSE_DATA.lessons.forEach((lesson, index) => {
          const lessonItem = document.createElement("div");
          lessonItem.className = "lesson-item";

          // Determine lesson status
          const lessonProgress = courseProgress[lesson.id];
          const isCompleted = lessonProgress?.completed || false;
          const isInProgress = lessonProgress?.started || false;
          const isLocked = !isCompleted && !canAccessLesson(index);
          const isActive = index === currentLessonIndex;

          // Apply status classes
          if (isCompleted) lessonItem.classList.add("completed");
          if (isLocked) lessonItem.classList.add("locked");
          if (isActive) lessonItem.classList.add("active");

          // Determine status display
          let statusClass = "not-started";
          let statusIcon = index + 1;

          if (isCompleted) {
            statusClass = "completed";
            statusIcon = "";
          } else if (isInProgress) {
            statusClass = "in-progress";
            statusIcon = "";
          }

          // Create lesson item HTML
          lessonItem.innerHTML = `
            <div class="lesson-status ${statusClass}">${statusIcon}</div>
            <div class="lesson-info">
                <div class="lesson-title">${lesson.title}</div>
                <div class="lesson-meta">
                    ${
                      isCompleted
                        ? "Completed"
                        : isInProgress
                        ? "In Progress"
                        : isLocked
                        ? "Locked"
                        : "Not Started"
                    }
                </div>
            </div>
            <div class="lesson-duration">${lesson.duration}</div>
        `;

          // Add click handler if not locked
          if (!isLocked) {
            lessonItem.addEventListener("click", () => {
              if (index !== currentLessonIndex) {
                // Track lesson time before switching
                trackLessonTime();

                currentLessonIndex = index;
                loadLesson(index);
                closeSidebar();
              }
            });
          }

          lessonNav.appendChild(lessonItem);
        });
      }

      function canAccessLesson(index) {
        if (index === 0) return true; // First lesson always accessible

        // Can access if previous lesson is completed
        const previousLessonId = COURSE_DATA.lessons[index - 1].id;
        return courseProgress[previousLessonId]?.completed || false;
      }

      function trackLessonTime() {
        const currentLesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonProgress = courseProgress[currentLesson.id];

        if (lessonProgress?.currentSessionStart) {
          const sessionTime = Math.floor(
            (new Date() - new Date(lessonProgress.currentSessionStart)) /
              1000 /
              60
          );
          lessonProgress.timeSpent =
            (lessonProgress.timeSpent || 0) + sessionTime;
          delete lessonProgress.currentSessionStart;
        }
      }

      // =====================================================
      // LESSON CONTENT RENDERING
      // =====================================================
      function renderLessonContent(lesson) {
        const contentContainer = document.getElementById("lessonContent");
        if (!contentContainer) return;

        let contentHTML = `
        <div class="content-section">
            <h2>Learning Objectives</h2>
            <ul>
                ${lesson.objectives.map((obj) => `<li>${obj}</li>`).join("")}
            </ul>
        </div>
        
        <div class="content-section">
            <h2>Overview</h2>
            <p>${lesson.content.overview}</p>
        </div>
    `;

        // Render content sections
        lesson.content.sections.forEach((section) => {
          contentHTML += `
            <div class="content-section">
                <h2>${section.title}</h2>
                ${section.content}
                ${
                  section.image
                    ? `<img src="${section.image}" alt="${section.title}" class="content-image" loading="lazy">`
                    : ""
                }
            </div>
        `;
        });

        // Render code examples
        if (
          lesson.content.codeExamples &&
          lesson.content.codeExamples.length > 0
        ) {
          contentHTML += `<div class="content-section"><h2>Code Examples</h2></div>`;

          lesson.content.codeExamples.forEach((example, index) => {
            const codeId = `code-${lesson.id}-${index}`;
            contentHTML += `
                <div class="code-section">
                    <div class="code-header">
                        <span class="code-title">${example.title}</span>
                        <button class="copy-btn" onclick="copyCode('${codeId}')">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <pre class="code-block"><code id="${codeId}" class="language-${
              example.language
            }">${escapeHtml(example.code)}</code></pre>
                </div>
            `;
          });
        }

        // Render quiz
        contentHTML += renderQuiz(lesson.quiz);

        contentContainer.innerHTML = contentHTML;

        // Highlight code syntax if Prism is available
        setTimeout(() => {
          if (window.Prism) {
            Prism.highlightAll();
          }
        }, 100);
      }

      // =====================================================
      // QUIZ SYSTEM
      // =====================================================
      function renderQuiz(quiz) {
        const currentLessonProgress =
          courseProgress[COURSE_DATA.lessons[currentLessonIndex].id];
        const isCompleted = currentLessonProgress?.completed || false;

        let quizHTML = `
        <div class="quiz-section" id="quizSection">
            <div class="quiz-header">
                <h2 class="quiz-title">
                    <i class="fas fa-clipboard-check"></i>
                    Knowledge Check
                </h2>
                <p class="quiz-info">
                    Complete this quiz with ${quiz.passingScore}% or higher to unlock the next lesson.
                </p>
            </div>
    `;

        if (isCompleted) {
          const savedScore = currentLessonProgress.quizScore || 0;
          quizHTML += `
            <div class="quiz-results show">
                <div class="quiz-score pass">${savedScore}%</div>
                <div class="quiz-message">
                    <strong>Lesson Completed!</strong><br>
                    You've successfully passed this lesson's quiz.
                </div>
            </div>
        `;
        } else {
          // Render quiz questions
          quiz.questions.forEach((question, qIndex) => {
            quizHTML += `
                <div class="quiz-question ${
                  qIndex === 0 ? "active" : ""
                }" data-question="${qIndex}">
                    <div class="question-header">
                        <span class="question-number">Question ${
                          qIndex + 1
                        }</span>
                        <span class="question-progress">${qIndex + 1}/${
              quiz.questions.length
            }</span>
                    </div>
                    <div class="question-text">${question.question}</div>
                    <div class="question-options">
                        ${question.options
                          .map(
                            (option, oIndex) => `
                            <div class="option" data-option="${oIndex}" onclick="selectOption(${qIndex}, ${oIndex})">
                                <span class="option-letter">${String.fromCharCode(
                                  65 + oIndex
                                )}</span>
                                <span class="option-text">${option}</span>
                            </div>
                        `
                          )
                          .join("")}
                    </div>
                </div>
            `;
          });

          quizHTML += `
            <div class="quiz-controls">
                <button class="btn btn-secondary" id="prevQuestionBtn" onclick="previousQuestion()" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <div>
                    <button class="btn btn-secondary" id="nextQuestionBtn" onclick="nextQuestion()" disabled>
                        Next
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <button class="btn btn-primary" id="submitQuizBtn" onclick="submitQuiz()" style="display: none;">
                        <i class="fas fa-check"></i>
                        Submit Quiz
                    </button>
                </div>
            </div>

            <div class="quiz-results" id="quizResults">
                <div class="quiz-score" id="quizScore">0%</div>
                <div class="quiz-message" id="quizMessage"></div>
                <div class="quiz-actions">
                    <button class="btn btn-primary" id="continueBtn" onclick="completeLesson()" style="display: none;">
                        <i class="fas fa-arrow-right"></i>
                        Continue to Next Lesson
                    </button>
                    <button class="btn btn-secondary" onclick="retakeQuiz()">
                        <i class="fas fa-redo"></i>
                        Retake Quiz
                    </button>
                </div>
            </div>
        `;
        }

        quizHTML += "</div>";
        return quizHTML;
      }

      // Quiz interaction functions
      function selectOption(questionIndex, optionIndex) {
        // Clear previous selections
        document
          .querySelectorAll(`[data-question="${questionIndex}"] .option`)
          .forEach((opt) => {
            opt.classList.remove("selected");
          });

        // Select current option
        const selectedOption = document.querySelector(
          `[data-question="${questionIndex}"] [data-option="${optionIndex}"]`
        );
        selectedOption.classList.add("selected");

        // Store answer
        quizState.answers[questionIndex] = optionIndex;

        // Update navigation
        const isLastQuestion =
          questionIndex ===
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length - 1;
        if (isLastQuestion) {
          document.getElementById("submitQuizBtn").style.display =
            "inline-flex";
          document.getElementById("nextQuestionBtn").style.display = "none";
        } else {
          document.getElementById("nextQuestionBtn").disabled = false;
        }
      }

      function nextQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const nextQuestionEl = currentQuestionEl.nextElementSibling;

        if (
          nextQuestionEl &&
          nextQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          nextQuestionEl.classList.add("active");
          quizState.currentQuestion++;
          updateQuizNavigation();
        }
      }

      function previousQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const prevQuestionEl = currentQuestionEl.previousElementSibling;

        if (
          prevQuestionEl &&
          prevQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          prevQuestionEl.classList.add("active");
          quizState.currentQuestion--;
          updateQuizNavigation();
        }
      }

      function updateQuizNavigation() {
        const totalQuestions =
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length;
        const prevBtn = document.getElementById("prevQuestionBtn");
        const nextBtn = document.getElementById("nextQuestionBtn");
        const submitBtn = document.getElementById("submitQuizBtn");

        prevBtn.disabled = quizState.currentQuestion === 0;

        const hasAnswer =
          quizState.answers[quizState.currentQuestion] !== undefined;
        const isLastQuestion = quizState.currentQuestion === totalQuestions - 1;

        if (isLastQuestion) {
          nextBtn.style.display = "none";
          submitBtn.style.display = hasAnswer ? "inline-flex" : "none";
        } else {
          nextBtn.style.display = "inline-flex";
          nextBtn.disabled = !hasAnswer;
          submitBtn.style.display = "none";
        }
      }

      async function submitQuiz() {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const quiz = lesson.quiz;
        let correctAnswers = 0;

        // Hide questions and controls
        document
          .querySelectorAll(".quiz-question")
          .forEach((q) => (q.style.display = "none"));
        document.querySelector(".quiz-controls").style.display = "none";

        // Calculate score and highlight answers
        quiz.questions.forEach((question, index) => {
          const userAnswer = quizState.answers[index];
          const correctAnswer = question.correct;
          const isCorrect = userAnswer === correctAnswer;

          if (isCorrect) correctAnswers++;

          // Highlight answers
          const questionEl = document.querySelector(
            `[data-question="${index}"]`
          );
          const options = questionEl.querySelectorAll(".option");

          options[correctAnswer].classList.add("correct");
          if (userAnswer !== correctAnswer && userAnswer !== undefined) {
            options[userAnswer].classList.add("incorrect");
          }
        });

        const score = Math.round(
          (correctAnswers / quiz.questions.length) * 100
        );
        const passed = score >= quiz.passingScore;

        // Update quiz results UI
        const quizScore = document.getElementById("quizScore");
        const quizMessage = document.getElementById("quizMessage");
        const quizActions = document.querySelector(".quiz-actions");

        quizScore.textContent = `${score}%`;
        quizScore.className = `quiz-score ${passed ? "pass" : "fail"}`;

        if (passed) {
          quizMessage.innerHTML = `
            <strong>Congratulations!</strong><br>
            You passed with ${score}%. You can now proceed to the next lesson.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-primary" onclick="completeLesson()">
                <i class="fas fa-arrow-right"></i>
                Continue to Next Lesson
            </button>
        `;

          // Mark lesson as completed
          await markLessonComplete(score);
        } else {
          quizMessage.innerHTML = `
            <strong>Not quite there yet.</strong><br>
            You scored ${score}%. You need ${quiz.passingScore}% to pass. Review the material and try again.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-secondary" onclick="retakeQuiz()">
                <i class="fas fa-redo"></i>
                Retake Quiz
            </button>
        `;
        }

        document.getElementById("quizResults").classList.add("show");

        // Log quiz completion
        logUserActivity("quiz_completed", {
          lesson_id: lesson.id,
          lesson_title: lesson.title,
          score: score,
          passed: passed,
          attempts: (courseProgress[lesson.id]?.quizAttempts || 0) + 1,
        });

        // Scroll to results
        document
          .getElementById("quizResults")
          .scrollIntoView({ behavior: "smooth" });
      }

      function retakeQuiz() {
        // Reset quiz state
        quizState = {
          currentQuestion: 0,
          answers: [],
          score: 0,
          isComplete: false,
        };

        // Track quiz retry
        const lessonId = COURSE_DATA.lessons[currentLessonIndex].id;
        if (!courseProgress[lessonId]) courseProgress[lessonId] = {};
        courseProgress[lessonId].quizAttempts =
          (courseProgress[lessonId].quizAttempts || 0) + 1;

        // Reload lesson content
        loadLesson(currentLessonIndex);

        // Scroll to quiz
        setTimeout(() => {
          document
            .getElementById("quizSection")
            .scrollIntoView({ behavior: "smooth" });
        }, 500);
      }

      async function markLessonComplete(score) {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonId = lesson.id;

        // Track lesson completion time
        trackLessonTime();

        // Update lesson progress
        courseProgress[lessonId] = {
          ...courseProgress[lessonId],
          completed: true,
          quizScore: score,
          completedAt: new Date().toISOString(),
          finalScore: score,
        };

        // Update session tracking
        courseSession.lessonsCompleted++;

        // Save progress to database
        await saveProgress();

        // Update UI
        renderSidebar();
        updateNavigationButtons();

        // Check various achievements
        await checkLessonCompletionAchievements();
        await checkPerfectScoreAchievements(score);
        await checkStudyTimeAchievements();

        // Log lesson completion
        logUserActivity("lesson_completed", {
          lesson_id: lessonId,
          lesson_title: lesson.title,
          final_score: score,
          time_spent: courseProgress[lessonId].timeSpent || 0,
          lesson_number: currentLessonIndex + 1,
        });

        showToast("Lesson completed successfully!", "success");
      }

      async function completeLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          // Move to next lesson
          currentLessonIndex++;
          loadLesson(currentLessonIndex);
        } else {
          // Course completion
          await completeCourse();
        }
      }

      async function completeCourse() {
        try {
          const completionTime = courseSession.totalStudyTime;

          // Update course progress to 100% completed
          await supabase
            .from("course_progress")
            .update({
              progress: 100,
              completed_at: new Date().toISOString(),
              completion_time_minutes: completionTime,
            })
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Award course completion achievements
          await checkAndUnlockAchievement("course_completion_1");
          await checkSpeedCompletionAchievements(completionTime);
          await checkCourseStreakAchievements();

          // Update user stats
          await updateUserStats();

          // Show completion message
          showToast(
            "Congratulations! Course completed successfully!",
            "certificate"
          );

          // Log course completion
          logUserActivity("course_completed", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            completion_time_minutes: completionTime,
            total_lessons: COURSE_DATA.lessons.length,
            average_quiz_score: calculateAverageQuizScore(),
          });

          // Redirect to dashboard after delay
          setTimeout(() => {
            window.location.href = "/dashboard.html";
          }, 3000);
        } catch (error) {
          console.error("Error completing course:", error);
          showToast("Error marking course as complete", "error");
        }
      }

      // =====================================================
      // ACHIEVEMENT INTEGRATION SYSTEM
      // =====================================================
      async function checkAndUnlockAchievement(
        achievementId,
        skipNotification = false
      ) {
        try {
          // Prevent duplicate checks
          const cacheKey = `achievement_${achievementId}_${currentUser.id}`;
          if (sessionStorage.getItem(cacheKey)) return false;

          // Check if already unlocked
          const { data: existing, error } = await supabase
            .from("user_achievements")
            .select("id")
            .eq("user_id", currentUser.id)
            .eq("achievement_id", achievementId)
            .single();

          if (existing) {
            sessionStorage.setItem(cacheKey, "true");
            return false;
          }

          // Award achievement
          const achievementData = {
            user_id: currentUser.id,
            achievement_id: achievementId,
            unlocked_at: new Date().toISOString(),
            points_awarded: getAchievementPoints(achievementId),
            context: "course_system",
          };

          const { data, error: insertError } = await supabase
            .from("user_achievements")
            .insert([achievementData])
            .select()
            .single();

          if (insertError) {
            if (insertError.code === "23505") return false; // Already exists
            throw insertError;
          }

          // Update user points
    await supabase.rpc('increment_user_stats', {
  user_id_param: currentUser.id,
  points_to_add: achievementData.points_awarded,
  achievements_to_add: 1
});

          // Cache and queue notification
          sessionStorage.setItem(cacheKey, "true");

          if (!skipNotification) {
            queueAchievementNotification({
              id: achievementId,
              name: getAchievementName(achievementId),
              description: getAchievementDescription(achievementId),
              points: achievementData.points_awarded,
              rarity: getAchievementRarity(achievementId),
              icon: getAchievementIcon(achievementId),
            });
          }

          return true;
        } catch (error) {
          console.error("Error unlocking achievement:", error);
          return false;
        }
      }

      // Helper functions for achievement data (replace with your actual achievement definitions)
      function getAchievementPoints(id) {
        const pointsMap = {
          first_course_start: 75,
          first_lesson: 100,
          course_completion_1: 500,
          perfect_score: 250,
          speed_demon: 750,
          marathon_learner: 500,
          night_owl: 200,
          early_bird: 200,
          weekend_warrior: 150,
          // Add more as needed
        };
        return pointsMap[id] || 100;
      }

      function getAchievementName(id) {
        const nameMap = {
          first_course_start: "Learning Initiated",
          first_lesson: "First Steps",
          course_completion_1: "Course Conqueror",
          perfect_score: "Perfectionist",
          speed_demon: "Speed Demon",
          // Add more as needed
        };
        return nameMap[id] || "Achievement Unlocked";
      }

      function getAchievementDescription(id) {
        const descMap = {
          first_course_start: "Start your first cybersecurity course",
          first_lesson: "Complete your first lesson",
          course_completion_1: "Complete your first course",
          perfect_score: "Score 100% on any quiz",
          speed_demon: "Complete a course in under 2 hours",
          // Add more as needed
        };
        return descMap[id] || "Achievement description";
      }

      function getAchievementRarity(id) {
        const rarityMap = {
          first_course_start: "common",
          first_lesson: "bronze",
          course_completion_1: "silver",
          perfect_score: "gold",
          speed_demon: "legendary",
          // Add more as needed
        };
        return rarityMap[id] || "common";
      }

      function getAchievementIcon(id) {
        const iconMap = {
          first_course_start: "fas fa-play",
          first_lesson: "fas fa-baby",
          course_completion_1: "fas fa-trophy",
          perfect_score: "fas fa-star",
          speed_demon: "fas fa-rocket",
          // Add more as needed
        };
        return iconMap[id] || "fas fa-award";
      }

      async function checkLessonAchievements(lessonNumber) {
        if (lessonNumber === 1) {
          await checkAndUnlockAchievement("first_lesson");
        }

        // Check if user has completed multiple lessons in one day
        const today = new Date().toISOString().split("T")[0];
        const todayCompletions = Object.values(courseProgress).filter(
          (p) => p.completed && p.completedAt?.startsWith(today)
        ).length;

        if (todayCompletions >= 3) {
          await checkAndUnlockAchievement("lesson_marathon");
        }
      }

      async function checkLessonCompletionAchievements() {
        const completedCount = getCompletedLessonsCount();

        // Lesson-based achievements
        const lessonMilestones = [1, 5, 10, 25, 50, 100];
        for (const milestone of lessonMilestones) {
          if (completedCount >= milestone) {
            await checkAndUnlockAchievement(`lessons_${milestone}`);
          }
        }

        // Course completion achievements
        if (completedCount === COURSE_DATA.lessons.length) {
          await checkAndUnlockAchievement("course_completion_1");

          // Check for additional course completion achievements
          const { data: allCourses } = await supabase
            .from("course_progress")
            .select("course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100);

          const totalCompleted = allCourses?.length || 0;

          const courseMilestones = [1, 5, 10, 25];
          for (const milestone of courseMilestones) {
            if (totalCompleted >= milestone) {
              await checkAndUnlockAchievement(`course_completion_${milestone}`);
            }
          }
        }
      }

      async function checkPerfectScoreAchievements(score) {
        if (score === 100) {
          await checkAndUnlockAchievement("perfect_score");

          // Check for consecutive perfect scores
          const recentScores = Object.values(courseProgress)
            .filter((p) => p.completed && p.quizScore)
            .slice(-5) // Last 5 completed
            .map((p) => p.quizScore);

          if (
            recentScores.length >= 3 &&
            recentScores.every((s) => s === 100)
          ) {
            await checkAndUnlockAchievement("perfectionist_streak");
          }
        }
      }

      async function checkSpeedCompletionAchievements(completionTime) {
        // Speed demon: Complete course in under 2 hours (120 minutes)
        if (completionTime <= 120) {
          await checkAndUnlockAchievement("speed_demon");
        }

        // Quick learner: Complete course in under 4 hours (240 minutes)
        if (completionTime <= 240) {
          await checkAndUnlockAchievement("quick_learner");
        }
      }

      async function checkStudyTimeAchievements() {
        const totalTime = courseSession.totalStudyTime;

        // Marathon learner: Study for 8+ hours in a course session
        if (totalTime >= 480) {
          // 8 hours
          await checkAndUnlockAchievement("marathon_learner");
        }

        // Dedicated learner: Study for 4+ hours
        if (totalTime >= 240) {
          // 4 hours
          await checkAndUnlockAchievement("dedicated_learner");
        }
      }

      async function checkCourseStreakAchievements() {
        try {
          // Check for consecutive course completions
          const { data: recentCourses, error } = await supabase
            .from("course_progress")
            .select("completed_at, course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100)
            .order("completed_at", { ascending: false })
            .limit(10);

          if (error || !recentCourses) return;

          // Check for courses completed on consecutive days
          let consecutiveDays = 1;
          for (let i = 1; i < recentCourses.length; i++) {
            const prevDate = new Date(
              recentCourses[i - 1].completed_at
            ).toDateString();
            const currentDate = new Date(
              recentCourses[i].completed_at
            ).toDateString();
            const dayDiff =
              Math.abs(new Date(prevDate) - new Date(currentDate)) /
              (1000 * 60 * 60 * 24);

            if (dayDiff <= 1) {
              consecutiveDays++;
            } else {
              break;
            }
          }

          if (consecutiveDays >= 3) {
            await checkAndUnlockAchievement("learning_streak");
          }
        } catch (error) {
          console.error("Error checking course streak achievements:", error);
        }
      }

      // =====================================================
      // TIME-BASED ACHIEVEMENTS
      // =====================================================
      async function checkTimeBasedAchievements(timestamp) {
        const hour = timestamp.getHours();
        const dayOfWeek = timestamp.getDay();

        // Night owl (after midnight, before 6 AM)
        if (hour >= 0 && hour < 6) {
          await incrementTimeBasedCounter("midnight_sessions", "night_owl");
        }

        // Early bird (4 AM to 6 AM)
        if (hour >= 4 && hour < 6) {
          await incrementTimeBasedCounter("early_sessions", "early_bird");
        }

        // Weekend warrior (Saturday = 6, Sunday = 0)
        if (dayOfWeek === 0 || dayOfWeek === 6) {
          await incrementTimeBasedCounter(
            "weekend_sessions",
            "weekend_warrior"
          );
        }
      }

      async function incrementTimeBasedCounter(counterType, achievementId) {
        try {
          const dateStr = new Date().toISOString().split("T")[0];
          const cacheKey = `${counterType}_${currentUser.id}_${dateStr}`;

          // Prevent multiple increments per day
          if (sessionStorage.getItem(cacheKey)) return;

          // Update counter
        await supabase.rpc('increment_profile_counter', {
  user_id_param: currentUser.id,
  counter_field: counterType,
  increment_value: 1
});

          // Cache to prevent double counting
          sessionStorage.setItem(cacheKey, "true");

          // Check related achievement
          if (achievementId) {
            await checkAndUnlockAchievement(achievementId, true);
          }
        } catch (error) {
          console.error(`Error incrementing ${counterType}:`, error);
        }
      }

      async function checkDailyStreak() {
        try {
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("last_activity, current_streak, last_streak_date")
            .eq("id", currentUser.id)
            .single();

          if (error) throw error;

          const now = new Date();
          const today = now.toDateString();
          const lastActivity = profile.last_activity
            ? new Date(profile.last_activity)
            : null;
          const lastStreakDate = profile.last_streak_date
            ? new Date(profile.last_streak_date).toDateString()
            : null;

          let newStreak = profile.current_streak || 0;
          let shouldUpdateStreak = false;

          if (!lastActivity) {
            // First time user
            newStreak = 1;
            shouldUpdateStreak = true;
          } else {
            const daysSinceLastActivity = Math.floor(
              (now - lastActivity) / (1000 * 60 * 60 * 24)
            );

            if (lastStreakDate === today) {
              // Already counted today's streak
              return newStreak;
            } else if (
              daysSinceLastActivity === 1 ||
              (daysSinceLastActivity === 0 && lastStreakDate !== today)
            ) {
              // Consecutive day or same day but not counted yet
              newStreak += 1;
              shouldUpdateStreak = true;
            } else if (daysSinceLastActivity > 1) {
              // Streak broken
              newStreak = 1;
              shouldUpdateStreak = true;
            }
          }

          if (shouldUpdateStreak) {
            await supabase
              .from("profiles")
              .update({
                current_streak: newStreak,
                last_activity: now.toISOString(),
                last_streak_date: now.toISOString(),
              })
              .eq("id", currentUser.id);

            userStats.current_streak = newStreak;

            showToast(`Daily streak: ${newStreak} days!`, "success");
            await checkStreakAchievements(newStreak);
          }

          return newStreak;
        } catch (error) {
          console.error("Error checking daily streak:", error);
          return 0;
        }
      }

      async function checkStreakAchievements(currentStreak) {
        const streakMilestones = [3, 7, 14, 30, 100, 365];

        for (const milestone of streakMilestones) {
          if (currentStreak >= milestone) {
            await checkAndUnlockAchievement(`streak_${milestone}`);
          }
        }
      }

      // =====================================================
      // USER ACTIVITY LOGGING
      // =====================================================
      async function logUserActivity(activityType, metadata = {}) {
        try {
          const now = new Date();

          const activityData = {
            user_id: currentUser.id,
            activity_type: activityType,
            timestamp: now.toISOString(),
            course_id: COURSE_DATA.id,
            lesson_index: currentLessonIndex,
            session_duration: courseSession.totalStudyTime,
            metadata: JSON.stringify(metadata),
            created_at: now.toISOString(),
          };

          // Try to log to activities table
          const { error } = await supabase
            .from("user_activities")
            .insert([activityData]);

          if (error && error.code !== "42P01") {
            console.warn("Activity logging failed:", error.message);
          }

          // Always update last activity in profile
          await supabase
            .from("profiles")
            .update({ last_activity: now.toISOString() })
            .eq("id", currentUser.id);
        } catch (error) {
          console.error("Error logging user activity:", error);
        }
      }

      // =====================================================
      // NAVIGATION SYSTEM
      // =====================================================
      function updateNavigationButtons() {
        const prevBtn = document.getElementById("prevLessonBtn");
        const nextBtn = document.getElementById("nextLessonBtn");

        if (!prevBtn || !nextBtn) return;

        // Previous button
        prevBtn.disabled = currentLessonIndex === 0;

        // Next button logic
        const isLastLesson =
          currentLessonIndex === COURSE_DATA.lessons.length - 1;
        const canGoNext =
          currentLessonIndex < COURSE_DATA.lessons.length - 1 &&
          canAccessLesson(currentLessonIndex + 1);

        if (isLastLesson) {
          const isCurrentCompleted =
            courseProgress[COURSE_DATA.lessons[currentLessonIndex].id]
              ?.completed;
          nextBtn.disabled = !isCurrentCompleted;
          nextBtn.innerHTML = '<i class="fas fa-trophy"></i> Complete Course';
        } else {
          nextBtn.disabled = !canGoNext;
          nextBtn.innerHTML = 'Next <i class="fas fa-chevron-right"></i>';
        }
      }

      // Navigation button event handlers
      function goToPreviousLesson() {
        if (currentLessonIndex > 0) {
          trackLessonTime(); // Track time spent on current lesson
          currentLessonIndex--;
          loadLesson(currentLessonIndex);
        }
      }

      function goToNextLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          const canGoNext = canAccessLesson(currentLessonIndex + 1);
          if (canGoNext) {
            trackLessonTime();
            currentLessonIndex++;
            loadLesson(currentLessonIndex);
          } else {
            showToast("Complete the current lesson quiz to proceed", "warning");
          }
        } else {
          // Complete course
          completeCourse();
        }
      }

      // =====================================================
      // SIDEBAR FUNCTIONS
      // =====================================================
      function toggleSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.toggle("open");
        if (overlay) overlay.classList.toggle("active");
      }

      function closeSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.remove("open");
        if (overlay) overlay.classList.remove("active");
      }

      // =====================================================
      // ACHIEVEMENT NOTIFICATION SYSTEM
      // =====================================================
      function queueAchievementNotification(achievement) {
        notificationQueue.push(achievement);
        processNotificationQueue();
      }

      function processNotificationQueue() {
        if (isShowingNotification || notificationQueue.length === 0) return;

        isShowingNotification = true;
        const achievement = notificationQueue.shift();
        showAchievementNotification(achievement);

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          isShowingNotification = false;
          processNotificationQueue();
        }, duration + 500);
      }

      function showAchievementNotification(achievement) {
        const notification = document.getElementById("achievementNotification");
        if (!notification) return;

        const icon = document.getElementById("notificationIcon");
        const title = document.getElementById("notificationTitle");
        const description = document.getElementById("notificationDescription");
        const points = document.getElementById("notificationPoints");

        if (icon) {
          icon.innerHTML = `<i class="${achievement.icon}"></i>`;
          icon.className = `notification-icon ${achievement.rarity}`;
        }
        if (title) title.textContent = achievement.name;
        if (description) description.textContent = achievement.description;
        if (points) points.textContent = `+${achievement.points} Points`;

        notification.className = `achievement-notification ${achievement.rarity}`;
        notification.classList.add("show");

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          notification.classList.remove("show");
        }, duration);
      }

      // =====================================================
      // UTILITY FUNCTIONS
      // =====================================================
      function calculateAverageQuizScore() {
        const scores = Object.values(courseProgress)
          .filter((p) => p.completed && p.quizScore)
          .map((p) => p.quizScore);

        if (scores.length === 0) return 0;
        return Math.round(
          scores.reduce((sum, score) => sum + score, 0) / scores.length
        );
      }

      async function resetProgress() {
        if (
          !confirm(
            "Are you sure you want to reset your progress? This action cannot be undone."
          )
        ) {
          return;
        }

        try {
          // Track lesson time before reset
          trackLessonTime();

          // Reset local state
          courseProgress = {};
          currentLessonIndex = 0;
          courseSession = {
            startTime: new Date(),
            totalStudyTime: 0,
            lessonsStarted: 0,
            lessonsCompleted: 0,
            pageLoadTime: new Date(),
            interactionCount: 0,
            lastActivityTime: new Date(),
          };

          // Delete from database
          await supabase
            .from("course_progress")
            .delete()
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Log reset activity
          logUserActivity("progress_reset", {
            course_id: COURSE_DATA.id,
            reset_reason: "manual",
          });

          // Reinitialize
          await saveProgress();
          renderSidebar();
          loadLesson(0);

          showToast("Progress reset successfully", "success");
        } catch (error) {
          console.error("Error resetting progress:", error);
          showToast("Failed to reset progress", "error");
        }
      }

      function copyCode(codeId) {
        const codeElement = document.getElementById(codeId);
        if (!codeElement) return;

        const text = codeElement.textContent;

        navigator.clipboard
          .writeText(text)
          .then(() => {
            showToast("Code copied to clipboard!", "success");

            // Track code copy for achievements
            logUserActivity("code_copied", {
              code_section: codeId,
              lesson_id: COURSE_DATA.lessons[currentLessonIndex].id,
            });
          })
          .catch((err) => {
            console.error("Failed to copy code:", err);
            showToast("Failed to copy code", "error");

            // Fallback for older browsers
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            try {
              document.execCommand("copy");
              showToast("Code copied to clipboard!", "success");
            } catch (fallbackError) {
              showToast(
                "Copy failed - please select and copy manually",
                "error"
              );
            }
            document.body.removeChild(textArea);
          });
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // =====================================================
      // UI FEEDBACK SYSTEMS
      // =====================================================
      function showToast(message, type = "success") {
        const toast = document.getElementById("toast");
        const messageEl = document.getElementById("toastMessage");

        if (!toast || !messageEl) {
          console.log(`Toast: ${message} (${type})`);
          return;
        }

        messageEl.textContent = message;
        toast.className = `toast ${type} show`;

        setTimeout(() => {
          toast.classList.remove("show");
        }, 4000);
      }

      function showLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) loadingScreen.classList.remove("hidden");
      }

      function hideLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) {
          setTimeout(() => {
            loadingScreen.classList.add("hidden");
          }, 1000);
        }
      }

      // =====================================================
      // MUSIC PLAYER INTEGRATION
      // =====================================================
      function initMusicPlayer() {
        const btnText = document.getElementById("music-button-text");
        const icon = document.getElementById("music-icon");
        const dropdown = document.getElementById("music-dropdown-content");

        if (!btnText || !icon || !dropdown) return;

        function setUI(state) {
          btnText.textContent =
            state === "Playing" ? "PAUSE MUSIC" : "STUDY MUSIC";
          icon.className =
            state === "Playing"
              ? "fa-solid fa-circle-pause"
              : "fa-solid fa-music";
        }

        // Load saved music state
        const savedSrc = localStorage.getItem("cybersec_music_src");
        const savedTime = parseFloat(
          localStorage.getItem("cybersec_music_time") || 0
        );

        if (savedSrc) {
          audioPlayer.src = savedSrc;
          audioPlayer.currentTime = savedTime;
          audioPlayer
            .play()
            .then(() => setUI("Playing"))
            .catch(() => setUI("Stopped"));
        }

        // Music button click handler
        document
          .getElementById("music-dropdown")
          .querySelector("button")
          .addEventListener("click", (e) => {
            e.stopPropagation();
            dropdown.style.display =
              dropdown.style.display === "block" ? "none" : "block";

            if (audioPlayer.src && !audioPlayer.paused) {
              audioPlayer.pause();
              setUI("Stopped");
            } else if (audioPlayer.src) {
              audioPlayer.play().then(() => setUI("Playing"));
            }
          });

        // Music selection handlers
        dropdown.querySelectorAll("a[data-src]").forEach((link) => {
          link.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.src = link.dataset.src;
            audioPlayer.play().then(() => setUI("Playing"));
            localStorage.setItem("cybersec_music_src", link.dataset.src);
            dropdown.style.display = "none";
          });
        });

        // Stop music handler
        const stopLink = document.getElementById("stop-music-link");
        if (stopLink) {
          stopLink.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            audioPlayer.removeAttribute("src");
            setUI("Stopped");
            localStorage.removeItem("cybersec_music_src");
            localStorage.removeItem("cybersec_music_time");
            dropdown.style.display = "none";
          });
        }

        // Save music state before page unload
        window.addEventListener("beforeunload", () => {
          if (!audioPlayer.paused && audioPlayer.src) {
            localStorage.setItem("cybersec_music_src", audioPlayer.src);
            localStorage.setItem(
              "cybersec_music_time",
              audioPlayer.currentTime
            );
          }
        });

        // Close dropdown when clicking outside
        window.addEventListener("click", (e) => {
          if (!e.target.closest("#music-dropdown")) {
            dropdown.style.display = "none";
          }
        });
      }

      // Show initial music indicator
      function addMusicIndicator() {
        const musicBtn = document.querySelector("#music-dropdown");
        if (musicBtn) {
          const indicator = document.createElement("div");
          indicator.className = "music-indicator";
          indicator.innerHTML = `<i class="fa-solid fa-music"></i> Try Study Music!`;

          musicBtn.style.position = "relative";
          musicBtn.appendChild(indicator);

          setTimeout(() => indicator.remove(), 3000);
        }
      }

      // Initialize Event Listeners
      function initializeEventListeners() {
        // Navigation buttons
        document
          .getElementById("prevLessonBtn")
          ?.addEventListener("click", goToPreviousLesson);
        document
          .getElementById("nextLessonBtn")
          ?.addEventListener("click", goToNextLesson);

        // Reset progress button
        document
          .getElementById("resetProgressBtn")
          ?.addEventListener("click", resetProgress);

        // Mobile menu toggle
        document
          .getElementById("menuToggle")
          ?.addEventListener("click", toggleSidebar);
        document
          .getElementById("sidebarOverlay")
          ?.addEventListener("click", closeSidebar);

        // Keyboard shortcuts
        document.addEventListener("keydown", handleKeyboardShortcuts);

        // Window resize handler
        window.addEventListener("resize", handleWindowResize);

        // Content interaction tracking
        document.getElementById("contentBody")?.addEventListener(
          "scroll",
          debounce(() => {
            trackUserInteraction();
          }, 1000)
        );
      }

      // Keyboard Shortcuts
      function handleKeyboardShortcuts(e) {
        if (document.querySelector(".quiz-question.active")) return;

        if (e.key === "ArrowLeft" && e.ctrlKey) {
          e.preventDefault();
          goToPreviousLesson();
        } else if (e.key === "ArrowRight" && e.ctrlKey) {
          e.preventDefault();
          goToNextLesson();
        }
      }

      // Window Resize Handler
      function handleWindowResize() {
        if (window.innerWidth > 768) {
          closeSidebar();
        }
      }

      // Debounce Helper
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Initialize responsive behavior
      if (window.innerWidth <= 768) {
        document.getElementById("menuToggle").style.display = "inline-flex";
      }

      // Auto-save progress periodically
      setInterval(async () => {
        if (currentUser && Object.keys(courseProgress).length > 0) {
          await saveProgress();
        }
      }, 60000); // Save every minute

      // System initialization logging
      console.log("CyberSec Academy Course System Initialized");
      console.log("Current Course:", COURSE_DATA.title);
      console.log("Total Lessons:", COURSE_DATA.lessons.length);

      // Google OAuth Integration
      const googleBtn = document.querySelector(".btn-google");
      if (googleBtn) {
        googleBtn.addEventListener("click", async () => {
          const { data, error } = await supabase.auth.signInWithOAuth({
            provider: "google",
            options: {
              redirectTo:
                window.location.origin +
                "/courses/azure-security-basics.html",
            },
          });

          if (error) {
            console.error("Google login error:", error.message);
            showToast("Google login failed: " + error.message, "error");
          }
        });
      }

      // Check for existing session
      supabase.auth.getSession().then(({ data }) => {
        if (data.session) {
          console.log("User already logged in:", data.session.user);
          currentUser = data.session.user;
          startCourseSession();
        }
      });

      // Add missing auth modal functions
      function openAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "flex";
        }
      }

      function closeAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Add auth tab switching functionality
      document.getElementById("tabSignIn")?.addEventListener("click", () => {
        document.getElementById("tabSignIn").classList.add("active");
        document.getElementById("tabSignUp").classList.remove("active");
        document.getElementById("signInForm").style.display = "block";
        document.getElementById("signUpForm").style.display = "none";
      });

      document.getElementById("tabSignUp")?.addEventListener("click", () => {
        document.getElementById("tabSignUp").classList.add("active");
        document.getElementById("tabSignIn").classList.remove("active");
        document.getElementById("signUpForm").style.display = "block";
        document.getElementById("signInForm").style.display = "none";
      });

      document
        .getElementById("closeAuthModal")
        ?.addEventListener("click", closeAuthModal);

      // Improved error handling for auth session
      supabase.auth.onAuthStateChange((event, session) => {
        if (event === "SIGNED_IN") {
          currentUser = session.user;
          closeAuthModal();
          startCourseSession();
        } else if (event === "SIGNED_OUT") {
          currentUser = null;
          openAuthModal();
        }
      });

      // Add form submission handlers
      document
        .getElementById("emailSignInForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signInEmail").value;
          const password = document.getElementById("signInPassword").value;

          try {
            const { data, error } = await supabase.auth.signInWithPassword({
              email,
              password,
            });

            if (error) throw error;

            closeAuthModal();
          } catch (error) {
            showToast(error.message, "error");
          }
        });

      document
        .getElementById("emailSignUpForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signUpEmail").value;
          const password = document.getElementById("signUpPassword").value;
          const name = document.getElementById("signUpName").value;

          try {
            const { data, error } = await supabase.auth.signUp({
              email,
              password,
              options: {
                data: {
                  full_name: name,
                },
              },
            });

            if (error) throw error;

            showToast(
              "Account created successfully! Please check your email.",
              "success"
            );
          } catch (error) {
            showToast(error.message, "error");
          }
        });
    </script>
  </body>
</html>

