



<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- ========== Start: SEO & Schema Enhancement ========== -->
    <title>Detection Engineering Course | CipherHall</title>
    <meta name="description" content="Enroll in our expert-led Detection Engineering course. Learn a systematic approach to finding threats using MITRE ATT&CK, Sigma, and modern security tools." />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png" />
    <link rel="shortcut icon" href="/favicon.png" type="image/x-icon" />
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png" />
    <link rel="canonical" href="https://www.cipherhall.com/courses/detection-engineering-detail.html" />
    <meta name="robots" content="noindex, nofollow" />

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Course",
      "name": "Detection Engineering: A Systematic Approach to Finding Evil",
      "description": "A comprehensive 30-lesson course on the principles and practices of detection engineering, from threat modeling and data analysis to building, testing, and managing a robust detection program.",
      "provider": {
        "@type": "Organization",
        "name": "CipherHall",
        "sameAs": "https://www.cipherhall.com"
      },
      "hasCourseInstance": {
        "@type": "CourseInstance",
        "courseMode": "Online",
        "instructor": {
          "@type": "Person",
          "name": "Dr. Anya Sharma"
        }
      }
    }
    </script>
    <!-- ========== End: SEO & Schema Enhancement ========== -->
    
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Exo+2:wght@700;800;900&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css"
    />
    <link rel="icon" type="image/x-icon" href="assets/favicon.ico" />

    <link rel="stylesheet" href="assets/css/coursepages.css" />
</head>
  <body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
      <div class="loader-icon">
        <i class="fas fa-graduation-cap"></i>
      </div>
      <div class="loader-text">Loading Course Content...</div>
    </div>

    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- Music Player (fixed at top right) -->
    <div class="header-controls">
      <div class="music-dropdown" id="music-dropdown">
        <button class="btn btn-secondary">
          <span id="music-button-text">STUDY MUSIC</span>
          <i id="music-icon" class="fa-solid fa-music"></i>
        </button>
        <div class="music-dropdown-content" id="music-dropdown-content">
          <a
            href="#"
            data-src="https://www.learningcontainer.com/wp-content/uploads/2020/02/Kalimba.mp3"
            >1. Coffee Shop Vibes</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3"
            >2. City Lights Lofi</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-15.mp3"
            >3. Mellow Thoughts</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-13.mp3"
            >4. Rainy Mood</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3"
            >5. Time Alone</a
          >
          <a href="#" id="stop-music-link"
            ><i class="fa-solid fa-stop-circle"></i> Stop Music</a
          >
        </div>
      </div>

      <button class="btn btn-secondary" id="resetProgressBtn">
        <i class="fas fa-redo"></i>
        Reset Progress
      </button>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal" style="display: none">
      <div class="modal-overlay"></div>
      <div class="modal-content">
        <span class="close" id="closeAuthModal">&times;</span>
        <div class="auth-tabs">
          <button id="tabSignIn" class="auth-tab active">Sign In</button>
          <button id="tabSignUp" class="auth-tab">Sign Up</button>
        </div>
        <div
          id="authLoader"
          style="display: none; text-align: center; padding: 2rem"
        >
          <i
            class="fas fa-spinner fa-spin fa-2x"
            style="color: var(--color-green)"
          ></i>
          <p style="margin-top: 0.5rem">Authenticating...</p>
        </div>
        <div id="signInForm" class="auth-form">
          <h2>Sign In to CipherHall</h2>
          <button id="googleSignIn" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignInForm">
            <input
              type="email"
              id="signInEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signInPassword"
              placeholder="Password"
              required
            />
            <button type="submit" class="btn btn-primary">Sign In</button>
          </form>
        </div>
        <div id="signUpForm" class="auth-form" style="display: none">
          <h2>Join CipherHall</h2>
          <button id="googleSignUp" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignUpForm">
            <input
              type="text"
              id="signUpName"
              placeholder="Full Name"
              required
            />
            <input
              type="email"
              id="signUpEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signUpPassword"
              placeholder="Password (min. 8 characters)"
              required
            />
            <button type="submit" class="btn btn-secondary">
              Create Account
            </button>
          </form>
        </div>
        <div id="authMessage"></div>
      </div>
    </div>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="course-info">
          <h1 class="course-title" id="courseTitle">Loading...</h1>
          <div class="course-progress">
            <div class="progress-header">
              <span class="progress-label">Course Progress</span>
              <span class="progress-percentage" id="courseProgressPercent"
                >0%</span
              >
            </div>
            <div class="progress-bar">
              <div
                class="progress-fill"
                id="courseProgressFill"
                style="width: 0%"
              ></div>
            </div>
            <div class="progress-stats">
              <span id="completedLessons">0</span>
              <span id="totalLessons">0</span>
            </div>
          </div>
          <a href="/dashboard.html" class="back-to-dashboard">
            <i class="fas fa-arrow-left"></i>
            Back to Dashboard
          </a>
        </div>
      </div>

      <nav class="lesson-nav" id="lessonNav">
        <!-- Lessons will be loaded dynamically -->
      </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <header class="content-header">
        <div class="lesson-header">
          <div class="lesson-header-left">
            <span class="lesson-number" id="currentLessonNumber">1</span>
            <h1 class="lesson-header-title" id="currentLessonTitle">
              Loading...
            </h1>
          </div>
          <div class="lesson-actions">
            <button class="mbtn btn-primary" id="menuToggle">
              <i class="fas fa-bars"></i>
            </button>
          </div>
        </div>
      </header>

      <div class="content-body" id="contentBody">
        <div class="lesson-content" id="lessonContent">
          <!-- Lesson content will be loaded dynamically -->
        </div>
      </div>

      <footer class="lesson-navigation">
        <div class="nav-info" id="navInfo">Lesson 1 of 10</div>
        <div class="nav-controls">
          <button class="btn btn-secondary" id="prevLessonBtn" disabled>
            <i class="fas fa-chevron-left"></i>
            Previous
          </button>
          <button class="btn btn-primary" id="nextLessonBtn" disabled>
            Next
            <i class="fas fa-chevron-right"></i>
          </button>
        </div>
      </footer>
    </main>

    <!-- Achievement Notification -->
    <div id="achievementNotification" class="achievement-notification">
      <div class="notification-header">
        <div class="notification-icon" id="notificationIcon">
          <i class="fas fa-trophy"></i>
        </div>
        <div class="notification-content">
          <h3 id="notificationTitle">Achievement Unlocked!</h3>
          <p id="notificationDescription">Description here...</p>
        </div>
      </div>
      <div class="notification-reward" id="notificationReward">
        <i class="fas fa-coins"></i>
        <span id="notificationPoints">+100 Points</span>
      </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast">
      <span id="toastMessage"></span>
    </div>

    <script>
      // =====================================================
      // SYNCHRONIZED COURSE SYSTEM WITH DASHBOARD INTEGRATION
      // =====================================================

      // Supabase Configuration - Replace with your config
      const supabaseUrl = "https://lzcmzulemfubjaksoqor.supabase.co";
      const supabaseKey =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx6Y216dWxlbWZ1Ympha3NvcW9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzMzM5MDgsImV4cCI6MjA3MDkwOTkwOH0.crhPH4YWtRsr1BJTpAQcmPbWSpwIWRbzoI4sRb2_fPI";
      const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

      // =====================================================
      // COURSE DATA STRUCTURE - REPLACE WITH YOUR COURSE JSON
      // =====================================================

      const COURSE_DATA = 

{
    "id": "detection-engineering",
    "title": "Detection Engineering: A Systematic Approach to Finding Evil",
    "description": "A comprehensive 30-lesson course on the principles and practices of detection engineering, from threat modeling and data analysis to building, testing, and managing a robust detection program.",
    "category": "cybersecurity-defensive",
    "difficulty": "Intermediate to Advanced",
    "duration": "50 hours",
    "instructor": "Dr. Anya Sharma",
    "lessons": [
        {
            "id": "lesson-1",
            "title": "Introduction to Detection Engineering",
            "duration": "60 min",
            "objectives": [
                "Define the role and responsibilities of a Detection Engineer",
                "Differentiate detection engineering from a SOC Analyst role",
                "Understand the primary goal: systematically reducing threat detection time",
                "Analyze the core skills required for the role"
            ],
            "content": {
                "overview": "This foundational lesson introduces the discipline of Detection Engineering. We will define what a Detection Engineer does, how the role differs from a traditional SOC Analyst, and establish the core mission: to treat the creation of security detections as a formal engineering discipline, enabling a proactive and scalable approach to finding threats.",
                "sections": [
                    {
                        "title": "Defining the Role",
                        "content": "<p>A <strong>Detection Engineer</strong> is a security professional who applies a software engineering mindset to the problem of threat detection. Their job is not just to respond to alerts, but to build, test, and maintain the systems and rules that *generate* those alerts.</p><p>While a SOC Analyst is a consumer of alerts, a Detection Engineer is the *producer* of alerts. They are responsible for the entire lifecycle of a detection, from the initial idea to the final, high-fidelity rule that a SOC Analyst can act upon.</p>",
                        "image": "https://images.unsplash.com/photo-1510915228340-29c85a43dcfe?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The Core Mission",
                        "content": "<p>The primary goal of a detection engineering program is to systematically reduce the organization's <strong>Mean Time to Detect (MTTD)</strong> and <strong>Mean Time to Respond (MTTR)</strong> to threats.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>From Reactive to Proactive</strong></div><p>A mature detection program moves an organization away from a reactive posture (waiting for a security vendor to ship a new signature) to a proactive one. Detection Engineers proactively study the threat landscape, hypothesize how an attacker might target their specific organization, and build custom detections to find that behavior, often before it's ever seen in the wild.</p></div>",
                        "image": "https://images.unsplash.com/photo-1573495627361-ab2d_50a8a86a?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Detection_Engineering_Mission_Statement.md",
                        "language": "markdown",
                        "code": "# Detection Engineering Team Mission\n\nOur mission is to proactively detect and enable response to malicious activity within the enterprise. We achieve this by:\n\n1.  **Understanding** the adversary through threat intelligence and research.\n2.  **Building** robust, high-fidelity detections based on adversary behaviors (TTPs).\n3.  **Validating** our detections through continuous, automated testing.\n4.  **Improving** our visibility and capabilities by constantly evaluating new data sources and technologies.\n\nOur primary metric for success is the continuous reduction of threat dwell time in our environment."
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the key difference between a Detection Engineer and a SOC Analyst?",
                        "options": [
                            "There is no difference.",
                            "A SOC Analyst is a consumer of alerts, while a Detection Engineer is the producer, builder, and maintainer of the detection rules.",
                            "A Detection Engineer does not need to understand cybersecurity.",
                            "A SOC Analyst writes all the code."
                        ],
                        "correct": 1,
                        "explanation": "This is the core distinction. The Detection Engineer builds the tools and content that the SOC Analyst uses to perform their incident response duties."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary goal of a detection engineering program?",
                        "options": [
                            "To buy a SIEM.",
                            "To hire as many analysts as possible.",
                            "To systematically reduce the time it takes to detect and respond to threats.",
                            "To write a report after an incident."
                        ],
                        "correct": 2,
                        "explanation": "The ultimate goal is to minimize the impact of a breach. This is achieved by finding and responding to malicious activity as quickly as possible, which is measured by MTTD and MTTR."
                    },
                    {
                        "id": 3,
                        "question": "A detection engineering approach is best described as...",
                        "options": [
                            "Reactive",
                            "Proactive",
                            "Passive",
                            "Manual"
                        ],
                        "correct": 1,
                        "explanation": "The discipline is fundamentally proactive. It involves anticipating adversary actions based on threat intelligence and building detections for them before they are used against the organization."
                    }
                ]
            }
        },
        {
            "id": "lesson-2",
            "title": "The Pyramid of Pain",
            "duration": "60 min",
            "objectives": [
                "Understand David J. Bianco's Pyramid of Pain model",
                "Differentiate between atomic indicators (hashes, IPs) and behavioral indicators (TTPs)",
                "Analyze why detecting TTPs is more robust and valuable",
                "Map indicators from a real threat report to the pyramid"
            ],
            "content": {
                "overview": "Not all detections are created equal. Some are easy for an attacker to change, while others are very difficult. This lesson introduces the 'Pyramid of Pain', a foundational model in cybersecurity that helps us prioritize our detection efforts on the things that cause the most 'pain' for an adversary to change.",
                "sections": [
                    {
                        "title": "The Pyramid of Pain Model",
                        "content": "<p>The Pyramid of Pain, created by David J. Bianco, illustrates the relationship between the types of indicators we can detect and how much pain it causes an adversary when we deny them those indicators.</p><p>The levels of the pyramid, from bottom (easy for an attacker to change) to top (hard to change), are:</p><ul><li><strong>Hash Values:</strong> Trivial to change. An attacker can change a single byte and the hash is different.</li><li><strong>IP Addresses:</strong> Easy to change. An attacker can quickly cycle through different servers.</li><li><strong>Domain Names:</strong> Simple to change. An attacker can register thousands of domains.</li><li><strong>Network/Host Artifacts:</strong> Annoying to change. These are things like file names or registry keys the malware creates.</li><li><strong>Tools:</strong> Difficult to change. An attacker would have to re-engineer their entire C2 framework.</li><li><strong>TTPs (Tactics, Techniques, and Procedures):</strong> The adversary's behavior. This is very difficult to change, as it requires them to learn entirely new ways of operating.</li></ul>",
                        "image": "https://i.imgur.com/8a6R2aU.png"
                    },
                    {
                        "title": "Detecting at the Top",
                        "content": "<p>The core lesson of the pyramid is that we should focus our detection engineering efforts as high up the pyramid as possible. </p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>The Value of Behavioral Detections</strong></div><p>A detection for a malware file hash is brittle and will only ever catch that one specific file. A detection for the *behavior* of the malware (e.g., 'detects a process that uses WMI to remotely create a process on another host') is far more powerful. This behavioral detection will catch the attacker's technique, regardless of what specific tool they use or what the file's hash is. This is the essence of modern detection engineering.</p></div>",
                        "image": "https://images.unsplash.com/photo-1573495627361-ab2d_50a8a86a?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Pyramid_of_Pain_Analysis_of_a_Threat_Report.json",
                        "language": "json",
                        "code": "{\n  \"threat_actor\": \"FIN7\",\n  \"indicators\": [\n    {\n      \"type\": \"Hash\",\n      \"value\": \"123abc...\",\n      \"pain_level\": \"Trivial\"\n    },\n    {\n      \"type\": \"IP Address\",\n      \"value\": \"123.45.67.89\",\n      \"pain_level\": \"Easy\"\n    },\n    {\n      \"type\": \"Tool\",\n      \"value\": \"Cobalt Strike\",\n      \"pain_level\": \"Difficult\"\n    },\n    {\n      \"type\": \"TTP\",\n      \"value\": \"T1021.002 - SMB/Windows Admin Shares for Lateral Movement\",\n      \"pain_level\": \"Very Difficult\"\n    }\n  ]\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "According to the Pyramid of Pain, which of the following indicators is the most difficult for an attacker to change?",
                        "options": [
                            "The IP address of their C2 server.",
                            "The hash of their malware file.",
                            "Their TTPs (their behavior).",
                            "The domain name they are using."
                        ],
                        "correct": 2,
                        "explanation": "TTPs represent the attacker's core methodology and knowledge. Changing them requires the attacker to learn entirely new ways of operating, which is far more difficult than simply getting a new IP address or recompiling a file."
                    },
                    {
                        "id": 2,
                        "question": "A detection rule that alerts on a specific file hash operates at which level of the pyramid?",
                        "options": [
                            "Top (TTPs)",
                            "Middle (Tools)",
                            "Bottom (Hash Values)",
                            "Middle (Domain Names)"
                        ],
                        "correct": 2,
                        "explanation": "File hashes are the most trivial indicators. They are useful for identifying known threats, but a detection based on a hash is extremely brittle and easy to bypass."
                    },
                    {
                        "id": 3,
                        "question": "What is the primary strategic lesson from the Pyramid of Pain for a detection engineer?",
                        "options": [
                            "To only focus on blocking IP addresses.",
                            "To focus on building robust, behavioral detections based on TTPs, as these are the most resilient and cause the most pain for an adversary.",
                            "To ignore atomic indicators like hashes and IPs.",
                            "The pyramid is not relevant for detection."
                        ],
                        "correct": 1,
                        "explanation": "The pyramid provides a mental model for prioritizing detection development. The goal is to move up the pyramid, from simple indicator matching to more sophisticated behavioral detection that is harder for an attacker to evade."
                    }
                ]
            }
        },
        {
            "id": "lesson-3",
            "title": "Threat Modeling for Detections with MITRE ATT&CKÂ®",
            "duration": "75 min",
            "objectives": [
                "Understand how to use the ATT&CK framework as a blueprint for detection",
                "Learn how to prioritize techniques based on threat intelligence",
                "Map adversary behaviors from a threat report to specific TTPs",
                "Use the ATT&CK Navigator to visualize and plan detection coverage"
            ],
            "content": {
                "overview": "We can't detect everything. We need a structured way to prioritize our efforts. This lesson covers how to use the MITRE ATT&CK framework as a threat modeling tool to identify the most relevant adversary behaviors and to plan and track our detection coverage.",
                "sections": [
                    {
                        "title": "Using ATT&CK as a Blueprint",
                        "content": "<p>The <strong>MITRE ATT&CK framework</strong> is a comprehensive knowledge base of adversary Tactics, Techniques, and Procedures (TTPs) based on real-world observations. For a detection engineer, it is a blueprint of everything we *could* detect.</p><p>Instead of randomly writing rules, we can use ATT&CK as a structured guide. Our goal is to systematically build detections for the techniques listed in the framework, starting with the ones that are most common and most relevant to our organization.</p>",
                        "image": "https://i.imgur.com/u7y7o9o.png"
                    },
                    {
                        "title": "Prioritizing with Threat Intelligence",
                        "content": "<p>The ATT&CK matrix is huge. No organization can have a high-fidelity detection for every single technique. The key is to prioritize based on <strong>threat intelligence</strong>.</p><p>A detection engineer will read threat intelligence reports about the adversaries that are most likely to target their industry (e.g., a financial company will study FIN7). They will map the TTPs described in the report to the ATT&CK framework. This gives them a data-driven list of the most important techniques to focus their detection efforts on.</p>",
                        "image": "https://images.unsplash.com/photo-1588196749107-15d08b4be52a?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The ATT&CK Navigator",
                        "content": "<p>The <strong>ATT&CK Navigator</strong> is a free, web-based tool developed by MITRE for visualizing and exploring the ATT&CK matrix.</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Visualizing Coverage</strong></div><p>Detection engineers use the Navigator to:<ul><li>Highlight and color-code the techniques used by a specific threat actor.</li><li>Create a 'heatmap' of their current detection coverage, showing which techniques have a high-fidelity detection, which have basic telemetry, and which have no visibility.</li><li>Identify gaps in their defenses and plan their future detection development work.</li></ul></p></div>",
                        "image": "https://i.imgur.com/kYq3Q6k.png"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "ATT&CK_Navigator_Layer_for_APT29.json",
                    "language": "json",
                    "code": "{\n    \"name\": \"APT29 Detection Coverage\",\n    \"version\": \"4.2\",\n    \"domain\": \"enterprise-attack\",\n    \"description\": \"Mapping our detections to APT29 TTPs\",\n    \"techniques\": [\n        {\n            \"techniqueID\": \"T1566.001\",\n            \"tactic\": \"initial-access\",\n            \"comment\": \"Spearphishing Attachment - Covered by Email Security Gateway\",\n            \"enabled\": true,\n            \"color\": \"#2e8b57\", \n            \"score\": 3\n        },\n        {\n            \"techniqueID\": \"T1059.001\",\n            \"tactic\": \"execution\",\n            \"comment\": \"PowerShell - High-fidelity detection rule in place\",\n            \"enabled\": true,\n            \"color\": \"#2e8b57\", \n            \"score\": 3\n        },\n        {\n            \"techniqueID\": \"T1021.002\",\n            \"tactic\": \"lateral-movement\",\n            \"comment\": \"SMB/Windows Admin Shares - Basic telemetry only, needs improvement\",\n            \"enabled\": true,\n            \"color\": \"#ffd700\", \n            \"score\": 1\n        }\n    ]\n}"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary use of the MITRE ATT&CK framework for a detection engineer?",
                        "options": [
                            "It is a security product that automatically detects threats.",
                            "It is a list of vulnerabilities to patch.",
                            "It is a comprehensive knowledge base of adversary TTPs that can be used as a blueprint for planning and prioritizing detection development.",
                            "It is a tool for managing security incidents."
                        ],
                        "correct": 2,
                        "explanation": "ATT&CK provides the 'what'. It's the catalog of adversary behaviors that a detection engineering program aims to find."
                    },
                    {
                        "id": 2,
                        "question": "How should a detection engineer prioritize which ATT&CK techniques to build detections for first?",
                        "options": [
                            "By starting with the first technique and working down the list.",
                            "By choosing techniques at random.",
                            "By using threat intelligence to identify the TTPs used by adversaries that are most likely to target their specific organization.",
                            "By focusing only on the easiest techniques to detect."
                        ],
                        "correct": 2,
                        "explanation": "Threat intelligence provides the context needed for prioritization. A good program focuses on building detections for the threats they are most likely to actually face."
                    },
                    {
                        "id": 3,
                        "question": "What is the ATT&CK Navigator primarily used for?",
                        "options": [
                            "To launch attacks.",
                            "To visualize the ATT&CK matrix, for example to create a heatmap of detection coverage.",
                            "To write detection rules.",
                            "To collect logs."
                        ],
                        "correct": 1,
                        "explanation": "The Navigator is a visualization and annotation tool. It's essential for threat modeling, coverage analysis, and communicating the state of the detection program to leadership."
                    }
                ]
            }
        },
        {
            "id": "lesson-4",
            "title": "Essential Data Sources and Telemetry",
            "duration": "90 min",
            "objectives": [
                "Understand that detections are built on data",
                "Identify and evaluate critical log sources (Endpoint, Network, Identity, Cloud)",
                "Explore the value of rich endpoint telemetry from Sysmon",
                "Learn how to configure Sysmon for maximum visibility"
            ],
            "content": {
                "overview": "You cannot detect what you cannot see. The foundation of any detection engineering program is high-quality, comprehensive data. This lesson covers the most critical data sources across the enterprise, with a special focus on Sysmon, the tool that provides the deep endpoint visibility needed to detect advanced threats.",
                "sections": [
                    {
                        "title": "The Four Pillars of Data",
                        "content": "<p>A mature detection program needs visibility across the four key domains of a modern enterprise:</p><ul><li><strong>Endpoint:</strong> This is where the attacks execute. We need to see process creations, command lines, network connections, registry modifications, and file writes. Tools: EDR, <strong>Sysmon</strong>.</li><li><strong>Network:</strong> This shows us how the attacker moves between machines and communicates with their C2. We need to see firewall logs, DNS queries, and rich protocol metadata. Tools: Zeek, Suricata, Firewall Logs.</li><li><strong>Identity:</strong> This shows us how the attacker authenticates. We need to see all login attempts (success and failure) and credential usage. Tools: Active Directory logs, Azure AD logs, Okta logs.</li><li><strong>Cloud:</strong> This shows us activity in the cloud control plane. We need to see all API calls. Tools: AWS CloudTrail, Azure Monitor.</li></ul>",
                        "image": "https://i.imgur.com/kYq3Q6k.png"
                    },
                    {
                        "title": "Sysmon: Deep Endpoint Visibility",
                        "content": "<p><strong>System Monitor (Sysmon)</strong> is a free and incredibly powerful tool from Microsoft. It is a device driver that, once installed, logs a huge amount of high-quality security telemetry to the Windows Event Log. It is the gold standard for free endpoint visibility.</p><h3>Key Sysmon Event IDs:</h3><ul><li><strong>Event ID 1:</strong> Process Creation. Logs the command line, hash, and parent process for every new process. This is the single most important log source for detecting LotL.</li><li><strong>Event ID 3:</strong> Network Connection. Logs all outbound network connections made by a process.</li><li><strong>Event ID 11:</strong> FileCreate. Logs the creation of new files.</li><li><strong>Event ID 13:</strong> RegistryEvent (SetValue). Logs modifications to the registry.</li><li><strong>Event ID 22:</strong> DNSEvent. Logs all DNS queries made by a process.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Configuring Sysmon",
                        "content": "<p>A default installation of Sysmon can be very noisy. Its power comes from using a detailed XML configuration file to filter out the noise and only log the high-value security events. The security community maintains several excellent open-source Sysmon configuration files that are designed to be a great starting point for any organization.</p>",
                        "image": "https://images.unsplash.com/photo-1573495627361-ab2d_50a8a86a?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "Sysmon_Configuration_for_Maximum_Visibility.xml",
                    "language": "xml",
                    "code": "<!-- This is a highly abbreviated excerpt from a Sysmon config file -->\n<Sysmon schemaversion=\"4.81\">\n  <EventFiltering>\n    <!-- RuleGroup for Process Creation events (Event ID 1) -->\n    <RuleGroup name=\"\" groupRelation=\"or\">\n      <ProcessCreate onmatch=\"include\">\n        <!-- Include events where the command line contains these suspicious strings -->\n        <CommandLine condition=\"contains\">-ExecutionPolicy Bypass -e</CommandLine>\n        <CommandLine condition=\"contains\">sekurlsa::logonpasswords</CommandLine>\n      </ProcessCreate>\n    </RuleGroup>\n\n    <!-- RuleGroup for Network Connection events (Event ID 3) -->\n    <RuleGroup name=\"\" groupRelation=\"or\">\n      <NetworkConnect onmatch=\"exclude\">\n        <!-- Exclude connections from known good browsers to reduce noise -->\n        <Image condition=\"is\">C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe</Image>\n      </NetworkConnect>\n      <NetworkConnect onmatch=\"include\">\n        <!-- But include any connection made by a suspicious process -->\n        <Image condition=\"is\">C:\\Windows\\System32\\regsvr32.exe</Image>\n      </NetworkConnect>\n    </RuleGroup>\n  </EventFiltering>\n</Sysmon>"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "Which of the following is considered a primary 'pillar' of data sources for a detection program?",
                        "options": [
                            "Endpoint",
                            "Network",
                            "Identity",
                            "All of the above"
                        ],
                        "correct": 3,
                        "explanation": "A mature program requires visibility across all these domains to effectively detect and trace a complex attack chain."
                    },
                    {
                        "id": 2,
                        "question": "What is Sysmon?",
                        "options": [
                            "A SIEM.",
                            "A free tool from Microsoft that provides deep, EDR-like endpoint telemetry.",
                            "A firewall.",
                            "A type of malware."
                        ],
                        "correct": 1,
                        "explanation": "Sysmon is a foundational tool for any detection engineer. It provides the raw data needed to build high-fidelity detections for a wide range of post-exploitation TTPs."
                    },
                    {
                        "id": 3,
                        "question": "Which Sysmon Event ID is arguably the most important for detecting Living-off-the-Land techniques?",
                        "options": [
                            "Event ID 11 (FileCreate)",
                            "Event ID 3 (NetworkConnection)",
                            "Event ID 1 (ProcessCreate)",
                            "Event ID 22 (DNSEvent)"
                        ],
                        "correct": 2,
                        "explanation": "Event ID 1, which logs process creation along with the full command line and parent process, is the single richest source of data for detecting the abuse of legitimate binaries. It shows *how* a tool was used, which is the key to behavioral detection."
                    }
                ]
            }
        },
        {
            "id": "lesson-5",
            "title": "Building Your Detection Lab",
            "duration": "90 min",
            "objectives": [
                "Understand the 'Detection Lab Triad' (SIEM, Endpoint, Attack VM)",
                "Learn how to deploy a basic SIEM using the Elastic Stack",
                "Practice deploying an endpoint agent (Sysmon) and forwarding logs",
                "Establish a workflow for attacking, logging, and analyzing in the lab"
            ],
            "content": {
                "overview": "To build and test detections, we need a lab that simulates a real environment. This lesson is a practical guide to building an effective, low-cost detection lab. We will set up the 'Detection Lab Triad': a SIEM to collect and analyze logs, an endpoint agent to generate telemetry, and an attacker VM to simulate threats.",
                "sections": [
                    {
                        "title": "The Detection Lab Triad",
                        "content": "<p>A functional detection lab consists of three core components, which can all be run as virtual machines:</p><ol><li><strong>The SIEM (Security Information and Event Management):</strong> This is our central log collection and analysis platform. We will use the <strong>Elastic Stack</strong> (Elasticsearch, Logstash, Kibana), which is a powerful and popular open-source option.</li><li><strong>The Endpoint:</strong> This is our 'victim' machine, a standard Windows 10 VM. We will install and configure <strong>Sysmon</strong> on it to generate detailed telemetry, and an agent (like Winlogbeat) to forward those logs to our SIEM.</li><li><strong>The Attacker:</strong> This is our 'Red Team' machine. We will use <strong>Kali Linux</strong>, which comes pre-loaded with the tools we need to simulate adversary behavior.</li></ol>",
                        "image": "https://i.imgur.com/kYq3Q6k.png"
                    },
                    {
                        "title": "The Workflow",
                        "content": "<p>The workflow for testing a detection in the lab is simple and repeatable:</p><ol><li>Have a detection hypothesis (e.g., 'I can detect remote WMI execution').</li><li>On the Kali VM, launch an attack against the Windows VM that uses this technique.</li><li>On the Windows VM, verify that Sysmon generated the correct event logs.</li><li>In the SIEM (Kibana), search for those logs. Analyze the fields and data to build a high-fidelity detection query.</li><li>Save the query as a new detection rule.</li></ol>",
                        "image": "https://images.unsplash.com/photo-1573495627361-ab2d_50a8a86a?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "Docker-Compose_for_Elastic_Stack_Deployment.yml",
                    "language": "yaml",
                    "code": "# This docker-compose file provides a very simple way to stand up a local Elastic Stack for our lab.\n\nversion: '3.7'\nservices:\n  elasticsearch:\n    image: docker.elastic.co/elasticsearch/elasticsearch:8.5.0\n    ports:\n      - 9200:9200\n    environment:\n      - discovery.type=single-node\n      - xpack.security.enabled=false\n\n  kibana:\n    image: docker.elastic.co/kibana/kibana:8.5.0\n    ports:\n      - 5601:5601\n    depends_on:\n      - elasticsearch\n\n# To run this, you would save it as docker-compose.yml and run 'docker-compose up'"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What are the three core components of the 'Detection Lab Triad'?",
                        "options": [
                            "Firewall, Router, Switch",
                            "A SIEM, an Endpoint with a sensor, and an Attacker VM.",
                            "A web server, a database, and a client.",
                            "Kali, Metasploitable, and Windows."
                        ],
                        "correct": 1,
                        "explanation": "This triad provides the complete feedback loop needed for detection engineering: an attacker to simulate threats, an endpoint to generate telemetry about those threats, and a SIEM to analyze that telemetry and build detections."
                    },
                    {
                        "id": 2,
                        "question": "In our lab, what is the role of the Elastic Stack (Kibana, Elasticsearch)?",
                        "options": [
                            "It is the attacker's C2 server.",
                            "It is the victim machine.",
                            "It is the SIEM, used for collecting, searching, and analyzing log data.",
                            "It is the firewall."
                        ],
                        "correct": 2,
                        "explanation": "The Elastic Stack is a powerful and widely used open-source platform for log analytics, making it a perfect choice for a detection lab SIEM."
                    },
                    {
                        "id": 3,
                        "question": "What is the purpose of the Kali Linux VM in the lab?",
                        "options": [
                            "To act as the defender (Blue Team).",
                            "To act as the attacker (Red Team) and simulate adversary behaviors.",
                            "To host the SIEM.",
                            "To be the target of the attacks."
                        ],
                        "correct": 1,
                        "explanation": "Kali Linux is a specialized distribution that comes pre-loaded with hundreds of security tools. It is the standard platform for ethical hackers and is used to simulate attacker activity in a controlled lab environment."
                    }
                ]
            }
        },
        {
            "id": "lesson-6",
            "title": "The Detection Development Lifecycle",
            "duration": "60 min",
            "objectives": [
                "Understand the importance of a structured, repeatable process for creating detections",
                "Learn the six key phases: Hypothesis, Collection, Development, Testing, Tuning, Deployment",
                "Analyze how this lifecycle mirrors a standard software development lifecycle (SDLC)",
                "Explore how to track the lifecycle using project management tools"
            ],
            "content": {
                "overview": "Good detections are not created by accident. They are the result of a structured, repeatable engineering process. This lesson introduces the Detection Development Lifecycle, a formal process that takes a detection from a simple idea to a fully tested, documented, and deployed rule.",
                "sections": [
                    {
                        "title": "The Six Phases of the Lifecycle",
                        "content": "<p>Treating detection creation as an engineering discipline means following a consistent lifecycle. This ensures that all detections are well-researched, thoroughly tested, and provide real value to the SOC.</p><ol><li><strong>Hypothesis:</strong> The process starts with a clear, testable hypothesis about an adversary behavior.</li><li><strong>Collection:</strong> The engineer ensures that the necessary data sources to prove or disprove the hypothesis are being collected.</li><li><strong>Development:</strong> The engineer writes the initial detection logic (e.g., a SIEM query or a Sigma rule).</li><li><strong>Testing:</strong> The engineer rigorously tests the rule in a lab to ensure it detects the target behavior (true positives).</li><li><strong>Tuning:</strong> The rule is tested against real production data to identify and filter out any false positives.</li><li><strong>Deployment & Documentation:</strong> The final, tuned rule is deployed into the production security monitoring system, and its purpose, logic, and response procedures are clearly documented.</li></ol>",
                        "image": "https://i.imgur.com/kYq3Q6k.png"
                    },
                    {
                        "title": "Parallels to Software Development",
                        "content": "<p>This lifecycle is a direct parallel to a standard Software Development Lifecycle (SDLC). By adopting this formal process, we can move away from an ad-hoc approach and build a mature, scalable, and manageable detection program.</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Detection as Code</strong></div><p>This is the foundation for the concept of 'Detection-as-Code'. Each detection rule is treated like a piece of software. It has a clear purpose, it is based on requirements (the hypothesis), it is thoroughly tested, it is version controlled, and it is documented. We will explore this in more detail in a later lesson.</p></div>",
                        "image": "https://images.unsplash.com/photo-1573495627361-ab2d_50a8a86a?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "Detection_Lifecycle_Workflow_in_Jira.md",
                    "language": "markdown",
                    "code": "# Using a Kanban board (like Jira or Trello) to track detections.\n\n**Board Columns:**\n1.  **Backlog:** All potential detection ideas.\n2.  **Hypothesis & Research:** The engineer is actively researching the TTP.\n3.  **Development & Testing:** The engineer is writing and testing the rule in the lab.\n4.  **Tuning (In Prod):** The rule is running in a 'dry run' mode in production to check for false positives.\n5.  **Ready for Deployment:** The rule is tuned and has passed peer review.\n6.  **Deployed:** The rule is live and generating alerts for the SOC.\n\n**Example Ticket:**\n- **ID:** DET-123\n- **Title:** Detect Kerberoasting\n- **Hypothesis:** We can detect Kerberoasting by looking for an unusual number of Kerberos service ticket requests (Event ID 4769) from a single host.\n- **Status:** Development & Testing"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary benefit of using a formal Detection Development Lifecycle?",
                        "options": [
                            "It makes the process slower.",
                            "It ensures that every detection is created in a structured, repeatable, and high-quality manner.",
                            "It is only for junior engineers.",
                            "It eliminates the need for a SIEM."
                        ],
                        "correct": 1,
                        "explanation": "A formal lifecycle brings discipline and rigor to the process. It ensures that all detections are well-researched, tested, and documented, which is essential for building a mature program."
                    },
                    {
                        "id": 2,
                        "question": "What is the purpose of the 'Tuning' phase?",
                        "options": [
                            "To test that the rule detects the malicious behavior.",
                            "To write the initial query for the rule.",
                            "To test the rule against production data to find and eliminate false positives.",
                            "To deploy the rule."
                        ],
                        "correct": 2,
                        "explanation": "Tuning is a critical step for ensuring a detection has high 'fidelity'. A rule that generates thousands of false positives is worse than no rule at all, because it wastes the SOC's time."
                    },
                    {
                        "id": 3,
                        "question": "The principle of treating detection rules like software, with version control and automated testing, is known as what?",
                        "options": [
                            "SOC Analysis",
                            "Incident Response",
                            "Detection-as-Code",
                            "Threat Hunting"
                        ],
                        "correct": 2,
                        "explanation": "Detection-as-Code is a core principle of modern detection engineering. It applies the best practices of software development to the creation and management of detection logic."
                    }
                ]
            }
        },
        {
            "id": "lesson-7",
            "title": "Step 1: Forming a Detection Hypothesis",
            "duration": "60 min",
            "objectives": [
                "Understand the importance of starting with a clear hypothesis",
                "Learn how to source ideas for new detections from threat intelligence and other sources",
                "Practice writing a clear, testable detection hypothesis",
                "Analyze the components of a good hypothesis"
            ],
            "content": {
                "overview": "Every good detection starts with a good idea. This lesson covers the first and most creative phase of the lifecycle: forming a detection hypothesis. We will explore where to find inspiration for new detections and how to formulate a hypothesis that is clear, concise, and testable.",
                "sections": [
                    {
                        "title": "Sourcing Detection Ideas",
                        "content": "<p>A detection engineer is constantly looking for new detection opportunities. The best ideas come from understanding how attackers operate.</p><h3>Primary Sources:</h3><ul><li><strong>Threat Intelligence Reports:</strong> Public reports from security vendors (Mandiant, CrowdStrike) or government agencies (CISA) provide detailed descriptions of real-world attacker TTPs. These are a goldmine for new detection ideas.</li><li><strong>Incident Response Post-Mortems:</strong> After an incident, the most important question is 'How could we have detected this sooner?'. The answer to this question becomes a new detection requirement.</li><li><strong>Red Team Findings:</strong> The report from an internal or external red team engagement is a prioritized list of the organization's specific defensive gaps.</li><li><strong>MITRE ATT&CK Research:</strong> Simply browsing the ATT&CK website and looking for common techniques can spark new ideas.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1588196749107-15d08b4be52a?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Writing a Testable Hypothesis",
                        "content": "<p>A good hypothesis is a clear and testable statement. It should describe the adversary behavior and the data that could be used to find it.</p><div class='info-box tip'><div class='info-box-header'><i class='fas fa-lightbulb'></i><strong>A Good Hypothesis Structure</strong></div><p>A simple template for a good hypothesis is: <br/><strong>'We can detect [TTP] by finding [specific event or pattern] in [log source].'</strong></p><h3>Examples:</h3><ul><li>'We can detect Pass-the-Hash (T1550.002) by finding a 4624 logon event with a Logon Type of 9 and a NULL SID in the Windows Security Logs.'</li><li>'We can detect the abuse of certutil.exe for downloads (T1105) by finding a Process Creation event for `certutil.exe` with the `-urlcache` command-line argument in our Sysmon logs.'</li></ul><p>A clear hypothesis like this provides a precise goal for the development and testing phase.</p></div>",
                        "image": "https://i.imgur.com/k2H1z5F.png"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "Hypothesis_Template_for_Detecting_Kerberoasting.md",
                    "language": "markdown",
                    "code": "# Detection Hypothesis: Detect Kerberoasting\n\n- **ATT&CK Technique:** T1558.003 - Kerberoasting\n\n- **Hypothesis:** We can detect Kerberoasting activity by analyzing Windows Security Event ID 4769 (A Kerberos service ticket was requested). An attacker performing this activity will likely generate a large number of these events from a single source host in a short period of time, for multiple different service accounts.\n\n- **Primary Log Source:** Windows Security Event Log (Event ID 4769).\n\n- **Detection Logic:** \n  - Aggregate 4769 events by the source IP address.\n  - Alert if a single source IP requests tickets for an unusually high number of distinct service accounts within a 1-hour window.\n\n- **Known False Positives:** Some vulnerability scanners and administrative tools may exhibit similar behavior. These will need to be filtered out during the tuning phase."
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "Which of the following is the BEST source of ideas for new, high-priority detections?",
                        "options": [
                            "A random blog post about technology.",
                            "A detailed threat intelligence report describing the TTPs of an adversary known to target your industry.",
                            "A list of all possible ATT&CK techniques.",
                            "A conversation with a software developer."
                        ],
                        "correct": 1,
                        "explanation": "Threat intelligence provides the context needed to prioritize. It tells you what real attackers are actually doing, which is the best guide for what you should be trying to detect."
                    },
                    {
                        "id": 2,
                        "question": "What is the most important characteristic of a good detection hypothesis?",
                        "options": [
                            "It should be very long and detailed.",
                            "It should be vague.",
                            "It should be a clear, specific, and testable statement.",
                            "It should be based on a single log source."
                        ],
                        "correct": 2,
                        "explanation": "A good hypothesis is a scientific one. It must be specific enough that you can design a test to prove or disprove it, which is the core of the detection development lifecycle."
                    },
                    {
                        "id": 3,
                        "question": "The process of analyzing a past security incident to identify detection gaps is known as what?",
                        "options": [
                            "Threat hunting.",
                            "A red team engagement.",
                            "A post-mortem analysis.",
                            "Threat intelligence."
                        ],
                        "correct": 2,
                        "explanation": "A post-mortem is a critical source of detection ideas. Every successful attack is, by definition, a failure of detection. Analyzing these failures is the best way to prevent them from happening again."
                    }
                ]
            }
        },
        {
            "id": "lesson-8",
            "title": "Step 2: Log Collection, Parsing, and Normalization",
            "duration": "75 min",
            "objectives": [
                "Understand the importance of having the right data before writing a rule",
                "Learn the concept of log parsing and field extraction",
                "Explore the value of data normalization and a Common Information Model (CIM)",
                "Practice writing a Grok pattern to parse an unstructured log"
            ],
            "content": {
                "overview": "You can't write a detection on data you don't have. Before we can start writing a rule, we must ensure that the required log data is being successfully collected, parsed, and normalized in our SIEM. This lesson covers the crucial data engineering steps that are a prerequisite for any detection.",
                "sections": [
                    {
                        "title": "Log Parsing and Field Extraction",
                        "content": "<p>Logs often arrive at the SIEM as a single, unstructured block of text. For example:</p><p><code>Apr 1 10:30:01 web-server sshd[1234]: Accepted password for jsmith from 192.168.1.100 port 51234 ssh2</code></p><p>To use this for detection, we need to <strong>parse</strong> it. Parsing is the process of extracting the interesting pieces of information into distinct fields. The parsed version would look like:</p><ul><li><code>timestamp: Apr 1 10:30:01</code></li><li><code>hostname: web-server</code></li><li><code>process_name: sshd</code></li><li><code>pid: 1234</code></li><li><code>message: Accepted password...</code></li><li><code>user: jsmith</code></li><li><code>source_ip: 192.168.1.100</code></li></ul>",
                        "image": "https://i.imgur.com/k2H1z5F.png"
                    },
                    {
                        "title": "Parsing with Grok",
                        "content": "<p><strong>Grok</strong> is a powerful tool used in the Elastic Stack and other SIEMs to parse unstructured log data. It uses regular expressions combined with pre-built patterns to match and extract fields from a line of text. Writing a correct Grok pattern is a fundamental skill for a detection engineer, as it's the key to unlocking the value of new log sources.</p>",
                        "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Normalization and the Common Information Model (CIM)",
                        "content": "<p>Different tools use different names for the same thing. A Palo Alto Firewall might call the source IP address `src_ip`. A Windows event log might call it `IpAddress`. This makes writing rules difficult.</p><p><strong>Normalization</strong> is the process of mapping these different field names to a single, standardized name. This standardized schema is called a <strong>Common Information Model (CIM)</strong>. For example, the CIM-compliant name for a source IP address might be `source.ip`. By normalizing all data to the CIM at ingest time, a detection engineer can write a single, simple rule (`where source.ip = '1.2.3.4'`) that works across all log sources, regardless of their original field names.</p>",
                        "image": "https://i.imgur.com/u7y7o9o.png"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "Logstash_Filter_to_Parse_Custom_Application_Logs.conf",
                    "language": "ruby",
                    "code": "# This is a Logstash filter configuration using Grok to parse a custom log.\n# Log line: \"[2023-04-01 10:30:01] INFO: User 'jsmith' logged in from 192.168.1.100\"\n\nfilter {\n  grok {\n    match => { \"message\" => \"\\[%{TIMESTAMP_ISO8601:timestamp}\\] %{LOGLEVEL:log_level}: User '%{WORD:user}' logged in from %{IP:source_ip}\" }\n  }\n}\n\n# After this filter, the event will have the following structured fields:\n# timestamp: \"2023-04-01 10:30:01\"\n# log_level: \"INFO\"\n# user: \"jsmith\"\n# source_ip: \"192.168.1.100\""
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is 'log parsing'?",
                        "options": [
                            "Deleting logs.",
                            "The process of extracting structured fields (like IP address, username) from an unstructured log message.",
                            "Encrypting logs.",
                            "Forwarding logs to a SIEM."
                        ],
                        "correct": 1,
                        "explanation": "Parsing is the critical data preparation step that turns a simple line of text into a structured, searchable event with key-value pairs that can be used in a detection rule."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary benefit of using a Common Information Model (CIM)?",
                        "options": [
                            "It makes logs take up more space.",
                            "It normalizes field names from different log sources, allowing you to write a single rule that works across multiple data types.",
                            "It is a type of security alert.",
                            "It is only for Windows logs."
                        ],
                        "correct": 1,
                        "explanation": "The CIM is a powerful abstraction layer. It provides a standardized schema for your data, which dramatically simplifies the process of writing and managing detection rules."
                    },
                    {
                        "id": 3,
                        "question": "Grok is a tool that is primarily used for what purpose?",
                        "options": [
                            "To run attacks.",
                            "To visualize data.",
                            "To parse unstructured log data using pattern matching.",
                            "To collect logs from an endpoint."
                        ],
                        "correct": 2,
                        "explanation": "Grok is the de facto standard for log parsing in many popular SIEM platforms, most notably the Elastic Stack. It uses a combination of regular expressions and pre-built patterns to extract fields."
                    }
                ]
            }
        },
        {
            "id": "lesson-9",
            "title": "Step 3: Writing Your First Detection Rule",
            "duration": "75 min",
            "objectives": [
                "Understand the core components of a detection rule",
                "Learn the basics of the Sigma format for vendor-agnostic rules",
                "Craft a simple Sigma rule based on a clear hypothesis",
                "Translate a Sigma rule into a specific SIEM query language"
            ],
            "content": {
                "overview": "With a clear hypothesis and the right data, we can now write the detection logic. This lesson introduces the Sigma format, the open-source, generic signature format for SIEM systems. We will learn how to write a simple, vendor-agnostic Sigma rule and then translate it into the specific query language for our lab SIEM.",
                "sections": [
                    {
                        "title": "What is a Sigma Rule?",
                        "content": "<p><strong>Sigma</strong> is the 'YARA for logs'. It is a generic, open-source signature format that allows you to describe a detection in a way that is independent of any specific SIEM platform. A single Sigma rule can be automatically converted into a query for Splunk, Elastic, Sentinel, and many other platforms.</p><p>This allows the security community to share detection logic without being tied to a specific vendor. A detection engineer can write one Sigma rule and share it, and anyone can use it, regardless of their SIEM.</p>",
                        "image": "https://i.imgur.com/kYq3Q6k.png"
                    },
                    {
                        "title": "Components of a Sigma Rule",
                        "content": "<p>A Sigma rule is a simple YAML file with several key sections:</p><ul><li><strong>Metadata:</strong> Information about the rule, such as its title, author, description, and ATT&CK mapping.</li><li><strong>Log Source:</strong> The type of log the rule applies to (e.g., `product: windows`, `category: process_creation`).</li><li><strong>Detection:</strong> The core logic of the rule. It defines a set of search identifiers (selections) and a condition for when the rule should fire.</li><li><strong>False Positives:</strong> A list of known benign activities that might trigger the rule.</li><li><strong>Level:</strong> The severity of the detection (e.g., `low`, `medium`, `high`, `critical`).</li></ul>",
                        "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Sigma_Rule_for_Suspicious_Rundll32_Execution.yml",
                        "language": "yaml",
                        "code": "title: Rundll32.exe Execution of Remote Scriptlet\nstatus: stable\ndescription: Detects the use of rundll32.exe to execute a remote COM scriptlet, a common LotL technique.\nreferences:\n    - https://lolbas-project.github.io/lolbas/Binaries/Rundll32/\nauthor: Alex Chen\ndate: 2023/04/01\n\ntags:\n    - attack.execution\n    - attack.t1218.011\n\nlogsource:\n    category: process_creation\n    product: windows\n\ndetection:\n    selection:\n        Image|endswith: '\\rundll32.exe'\n        CommandLine|contains: 'javascript:'\n        CommandLine|contains: 'RunHTMLApplication'\n        CommandLine|contains: 'script:'\n    condition: selection\n\nfalsepositives:\n    - Unlikely\n\nlevel: high"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary benefit of the Sigma format?",
                        "options": [
                            "It is a type of SIEM.",
                            "It provides a vendor-agnostic way to write and share detection logic.",
                            "It can automatically block threats.",
                            "It is only for Windows."
                        ],
                        "correct": 1,
                        "explanation": "Sigma's key innovation is separating the detection logic from the specific SIEM syntax. This allows for a universal, shareable format for detection rules."
                    },
                    {
                        "id": 2,
                        "question": "In a Sigma rule, what is the purpose of the 'detection' section?",
                        "options": [
                            "To provide metadata about the rule.",
                            "To define the core logic of the rule, including the search conditions.",
                            "To list known false positives.",
                            "To set the severity level."
                        ],
                        "correct": 1,
                        "explanation": "The 'detection' section is where the actual logic lives. It contains the specific patterns, keywords, and conditions that the rule is looking for in the log data."
                    },
                    {
                        "id": 3,
                        "question": "If a detection engineer writes a rule in the Sigma format, what must they do before they can use it in Splunk?",
                        "options": [
                            "Nothing, it works automatically.",
                            "They must use a tool (like `sigmac`) to convert or translate the Sigma rule into the corresponding Splunk SPL query.",
                            "They must rewrite the rule from scratch.",
                            "They must get it approved by MITRE."
                        ],
                        "correct": 1,
                        "explanation": "Sigma itself is just a definition. A transpiler like `sigmac` is needed to convert that generic definition into the specific syntax required by the target SIEM platform."
                    }
                ]
            }
        },
        {
            "id": "lesson-10",
            "title": "Step 4: Testing and Validation",
            "duration": "75 min",
            "objectives": [
                "Understand the principle: 'a detection isn't a detection until it's tested'",
                "Learn about atomic testing and its role in validation",
                "Explore the Atomic Red Team framework for simulating TTPs",
                "Practice using Atomic Red Team to test a detection rule in the lab"
            ],
            "content": {
                "overview": "Writing a detection rule is only half the battle. We must rigorously test it to ensure it actually works as intended. This lesson covers the critical phase of testing and validation, with a focus on 'atomic testing' and the Atomic Red Team framework, which allow us to safely and reliably simulate specific adversary techniques.",
                "sections": [
                    {
                        "title": "The Need for Testing",
                        "content": "<p>A detection rule is a piece of software, and like any software, it can have bugs. It might have a typo in the logic, it might be looking at the wrong log source, or the underlying telemetry might not be what we expect. We cannot assume a rule works just because the query is syntactically correct. We must test it by generating the exact behavior the rule is designed to find and confirming that it fires an alert.</p>",
                        "image": "https://images.unsplash.com/photo-1573495627361-ab2d_50a8a86a?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Atomic Red Team",
                        "content": "<p><strong>Atomic Red Team</strong> is an open-source library of simple, automated tests that are mapped to the MITRE ATT&CK framework. Each 'atomic test' is a small, self-contained script that executes a specific ATT&CK technique. It is the perfect tool for detection validation.</p><p>For almost any ATT&CK technique, there is a corresponding atomic test. An engineer can simply run the atomic test for the TTP their rule is designed to detect. If the rule fires, the test passes. If it doesn't, the engineer knows they have a problem to debug.</p>",
                        "image": "https://i.imgur.com/k2H1z5F.png"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "Invoke-AtomicTest T1059.001 -ShowDetailsBrief",
                    "language": "powershell",
                    "code": "# Atomic Red Team is a PowerShell module.\n# This command will first show us the available tests for the technique T1059.001 (PowerShell).\n\nInvoke-AtomicTest T1059.001 -ShowDetailsBrief\n\n# --- Sample Output ---\n# T1059.001:\n#   1. PowerShell Command-Line\n#   2. PowerShell Encoded Command\n#   3. PowerShell Download Cradle\n\n# Now, let's execute the third test.\nInvoke-AtomicTest T1059.001 -TestNumbers 3\n\n# This will run a safe, proof-of-concept version of a PowerShell download cradle.\n# The detection engineer would then immediately check their SIEM to see if their\n# detection rule for this technique fired as expected."
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is 'atomic testing' in the context of detection engineering?",
                        "options": [
                            "Testing the entire kill chain at once.",
                            "The practice of testing a single, specific adversary technique in isolation to validate that a specific detection rule is working correctly.",
                            "A type of unit testing for software.",
                            "Testing that involves nuclear materials."
                        ],
                        "correct": 1,
                        "explanation": "An 'atomic' test is small, isolated, and focused on one thing. This allows for a very precise and scientific approach to validating that your detection for a specific TTP is functioning as expected."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary purpose of the Atomic Red Team framework?",
                        "options": [
                            "It is a C2 framework for real attacks.",
                            "It is a SIEM.",
                            "It is a library of simple, automated tests mapped to MITRE ATT&CK techniques, designed for detection validation.",
                            "It is a vulnerability scanner."
                        ],
                        "correct": 2,
                        "explanation": "Atomic Red Team is the standard tool for detection validation. It provides a safe and easy way to simulate a specific adversary behavior to ensure your security controls can detect it."
                    },
                    {
                        "id": 3,
                        "question": "What is the most important reason for testing every detection rule?",
                        "options": [
                            "To prove that the rule works and will fire when the adversary behavior it is designed to find actually occurs.",
                            "Because it is a fun exercise.",
                            "To generate a lot of alerts.",
                            "To satisfy a manager's request."
                        ],
                        "correct": 0,
                        "explanation": "The principle is 'trust but verify'. A detection that hasn't been tested is just a hypothesis. The testing phase is what turns that hypothesis into a validated, reliable security control."
                    }
                ]
            }
        },
        {
            "id": "lesson-11",
            "title": "Step 5: Tuning for Fidelity (Reducing False Positives)",
            "duration": "75 min",
            "objectives": [
                "Understand the concept of detection fidelity",
                "Learn the importance of reducing false positives for the SOC",
                "Explore techniques for tuning a noisy rule, such as adding exceptions and baselining",
                "Analyze the trade-off between false positives and false negatives"
            ],
            "content": {
                "overview": "A detection that correctly finds an attacker but also fires a thousand times a day on benign activity is a bad detection. This lesson covers the critical phase of tuning, where we refine our detection logic to maximize the signal (true positives) while minimizing the noise (false positives) to create a high-fidelity alert that is truly valuable to the SOC.",
                "sections": [
                    {
                        "title": "The Problem of False Positives",
                        "content": "<p>A <strong>false positive</strong> is an alert that is triggered by benign, non-malicious activity. A high rate of false positives can destroy a SOC's effectiveness.</p><h3>The Impact of Noise:</h3><ul><li><strong>Alert Fatigue:</strong> If analysts are constantly flooded with false alarms, they will become desensitized and may start to ignore all alerts, including the ones that are real.</li><li><strong>Wasted Time:</strong> Every false positive is an alert that an analyst has to investigate, which takes time away from hunting for real threats or responding to real incidents.</li><li><strong>Loss of Trust:</strong> If a detection is known to be noisy, analysts will lose trust in it and in the detection engineering team.</li></ul>",
                        "image": "https://i.imgur.com/kYq3Q6k.png"
                    },
                    {
                        "title": "Tuning Techniques",
                        "content": "<p>Tuning is an iterative process of refining a rule's logic based on what you see in your own production environment.</p><ul><li><strong>Adding Exceptions (Whitelisting):</strong> The most common method. If you discover that a legitimate administrative script is triggering your PowerShell detection, you can add an exception to the rule to ignore that specific script, user, or host.</li><li><strong>Baseling:</strong> For anomaly-based detections, tuning involves establishing a more accurate baseline of what is 'normal' for your specific environment.</li><li><strong>Enriching with Context:</strong> You can make a rule higher-fidelity by adding more logical conditions. For example, instead of alerting on *any* `whoami` command, you could alert on `whoami` *only if* the parent process is `winword.exe`.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1573495627361-ab2d_50a_a86a?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The Tuning Trade-off",
                        "content": "<p>It's important to remember that there is always a trade-off between false positives and false negatives.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>The Balancing Act</strong></div><p>If you make a rule extremely specific to avoid all false positives, you also risk making it so narrow that it will fail to detect a slightly different variation of the attack (a <strong>false negative</strong>). The goal of tuning is to find the optimal balance point where the rule is broad enough to catch the adversary's TTP, but specific enough to not generate an unmanageable amount of noise.</p></div>",
                        "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "SIEM_Query_to_Identify_False_Positives.sql",
                    "language": "sql",
                    "code": "-- This query can be run in a SIEM to analyze the output of a new, noisy rule.\n\n-- Assume our new rule detects 'powershell.exe' with a suspicious command line.\n\n-- Let's find the top 10 parent processes that are spawning our suspicious command.\n-- This can help us identify legitimate applications that are causing false positives.\n\nSELECT parent_process_name, COUNT(*) as event_count\nFROM alerts\nWHERE rule_name = 'Suspicious PowerShell Execution'\nGROUP BY parent_process_name\nORDER BY event_count DESC\nLIMIT 10;\n\n-- If we see that 'SCCM_Client.exe' is the top parent process, we know we need to\n-- add an exception to our rule to ignore PowerShell processes launched by the\n-- legitimate SCCM client."
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is a 'false positive' in the context of threat detection?",
                        "options": [
                            "A real attack that was missed.",
                            "A benign activity that was incorrectly flagged as malicious.",
                            "A real attack that was correctly identified.",
                            "A benign activity that was correctly ignored."
                        ],
                        "correct": 1,
                        "explanation": "False positives are the 'noise' that a detection rule generates. The goal of tuning is to reduce this noise as much as possible."
                    },
                    {
                        "id": 2,
                        "question": "What is 'alert fatigue'?",
                        "options": [
                            "A feeling of excitement when a new alert comes in.",
                            "A state of desensitization that occurs when analysts are overwhelmed by a high volume of false positive alerts.",
                            "A technical problem with the SIEM.",
                            "A type of security alert."
                        ],
                        "correct": 1,
                        "explanation": "Alert fatigue is a serious problem in a SOC. If analysts are constantly chasing false alarms, they will eventually burn out and may miss a real threat. This is why tuning is so critical."
                    },
                    {
                        "id": 3,
                        "question": "What is the primary trade-off that a detection engineer must manage during the tuning phase?",
                        "options": [
                            "Speed vs. accuracy.",
                            "Cost vs. performance.",
                            "The trade-off between false positives and false negatives.",
                            "The trade-off between endpoint and network logs."
                        ],
                        "correct": 2,
                        "explanation": "This is the fundamental balancing act. Making a rule too specific will reduce false positives but might create false negatives (misses). Making it too broad will reduce false negatives but increase false positives (noise). The art of detection engineering is finding the right balance."
                    }
                ]
            }
        },
        
        {
            "id": "lesson-12",
            "title": "SIEM Query Languages (SPL, KQL)",
            "duration": "75 min",
            "objectives": [
                "Understand the core functions of a SIEM query language",
                "Learn the basic syntax of Splunk's Search Processing Language (SPL)",
                "Learn the basic syntax of Azure Sentinel's Kusto Query Language (KQL)",
                "Practice rewriting a detection concept in both languages"
            ],
            "content": {
                "overview": "The SIEM query language is the detection engineer's primary tool for interrogating data and writing detection logic. This lesson provides a crash course in the two most dominant query languages in the industry: Splunk's SPL and Azure Sentinel's KQL. Mastering their syntax for filtering, aggregating, and correlating data is a fundamental skill.",
                "sections": [
                    {
                        "title": "Splunk Search Processing Language (SPL)",
                        "content": "<p><strong>SPL</strong> is a powerful, pipe-based query language. The output of one command is 'piped' (`|`) as the input to the next command. This allows you to build up complex queries step-by-step.</p><h3>Core SPL Commands:</h3><ul><li><code>index=... sourcetype=...</code>: The initial command to select the data to be searched.</li><li><code>search ...</code>: Used for basic keyword searching (often omitted).</li><li><code>| stats count by field</code>: An aggregation command used to count events grouped by a specific field.</li><li><code>| where condition</code>: Used to filter results based on a condition.</li><li><code>| table field1, field2</code>: Formats the output into a table with the specified fields.</li></ul>",
                        "image": "https://i.imgur.com/k2H1z5F.png"
                    },
                    {
                        "title": "Kusto Query Language (KQL)",
                        "content": "<p><strong>KQL</strong> is used by Azure Sentinel, Azure Data Explorer, and Microsoft 365 Defender. It also uses a pipe-based syntax and is known for its readability and powerful data manipulation capabilities.</p><h3>Core KQL Commands:</h3><ul><li><code>TableName</code>: You start with the name of the table you want to query.</li><li><code>| where condition</code>: The primary filtering command.</li><li><code>| summarize count() by field</code>: The equivalent of Splunk's `stats` command for aggregation.</li><li><code>| project field1, field2</code>: The equivalent of Splunk's `table` command to select specific columns.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Splunk_Query_to_Detect_Anomalous_Logon_Count.spl",
                        "language": "splunk",
                        "code": "index=wineventlog sourcetype=\"WinEventLog:Security\" EventCode=4624 Logon_Type=10\n| stats count by user, src_ip\n| where count > 50"
                    },
                    {
                        "title": "KQL_Query_to_Detect_Anomalous_Logon_Count.kql",
                        "language": "kusto",
                        "code": "SecurityEvent\n| where EventID == 4624 and LogonType == 10\n| summarize count() by Account, IpAddress\n| where count_ > 50"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "In both SPL and KQL, what character is used to 'pipe' the output of one command to the next?",
                        "options": [
                            ">",
                            "|",
                            "&",
                            "$"
                        ],
                        "correct": 1,
                        "explanation": "The pipe `|` character is the fundamental syntax element in both languages, allowing for the chaining of commands to build a data processing pipeline."
                    },
                    {
                        "id": 2,
                        "question": "What is the KQL equivalent of the Splunk `stats count by user` command?",
                        "options": [
                            "| project count by user",
                            "| where user has count",
                            "| summarize count() by user",
                            "| table user, count"
                        ],
                        "correct": 2,
                        "explanation": "The `summarize` operator in KQL is used for all aggregation functions, with `count()` being the specific function to count events."
                    },
                    {
                        "id": 3,
                        "question": "What is the primary purpose of a SIEM query language for a detection engineer?",
                        "options": [
                            "To write reports.",
                            "To collect logs.",
                            "To filter, aggregate, and correlate log data to create the logic for detection rules.",
                            "To manage user accounts."
                        ],
                        "correct": 2,
                        "explanation": "The query language is the core interface for a detection engineer. It is the 'code' they write to define the logic that will find malicious activity."
                    }
                ]
            }
        },
        {
            "id": "lesson-13",
            "title": "Endpoint Detection with EDR and Sysmon",
            "duration": "75 min",
            "objectives": [
                "Understand the value of rich endpoint telemetry",
                "Learn to detect threats based on process ancestry and command lines",
                "Explore detections for malicious network connections and registry modifications",
                "Practice writing an EDR query to hunt for Mimikatz activity"
            ],
            "content": {
                "overview": "The endpoint is where the attack executes. Gaining deep visibility into what is happening on an endpoint is the most effective way to detect post-exploitation activity. This lesson covers the core principles of endpoint detection, using the rich telemetry provided by tools like Sysmon and commercial EDRs.",
                "sections": [
                    {
                        "title": "Process Ancestry and Command Lines",
                        "content": "<p>The single most important data source on an endpoint is <strong>process creation</strong> data (Sysmon Event ID 1). For every process, we need to know:</p><ul><li><strong>Image:</strong> The process that was launched (e.g., `powershell.exe`).</li><li><strong>CommandLine:</strong> The full command line used to launch it. This is critical for detecting LotL.</li><li><strong>ParentImage:</strong> The process that launched this new process.</li></ul><p>The parent-child relationship is a huge source for detections. It is not normal for Microsoft Word (`winword.exe`) to spawn a PowerShell process. This is a classic indicator of a malicious macro.</p>",
                        "image": "https://i.imgur.com/kYq3Q6k.png"
                    },
                    {
                        "title": "Detecting Credential Dumping",
                        "content": "<p>One of the highest-priority detections to build is for credential dumping. The target of this attack is almost always the `lsass.exe` process.</p><p>A high-fidelity detection can be built by looking for any process *other than* known, legitimate Windows processes that tries to open a handle to `lsass.exe`. If a process like `rundll32.exe` or a custom malware binary tries to access LSASS memory, it is a very strong signal of an attack in progress. EDRs and Sysmon (Event ID 10: ProcessAccess) can provide this telemetry.</p>",
                        "image": "https://images.unsplash.com/photo-1599508704512-2f19efd1e_35f?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Sysmon_Rule_for_Detecting_LSASS_Memory_Dumping.xml",
                        "language": "xml",
                        "code": "<!-- This Sysmon rule detects a process accessing LSASS memory -->\n<Sysmon schemaversion=\"4.81\">\n  <RuleGroup name=\"\" groupRelation=\"or\">\n    <ProcessAccess onmatch=\"include\">\n      <TargetImage condition=\"is\">C:\\Windows\\system32\\lsass.exe</TargetImage>\n      <!-- The 0x1010 access mask includes PROCESS_VM_READ, which is needed to dump memory -->\n      <GrantedAccess condition=\"is\">0x1010</GrantedAccess>\n      <SourceImage condition=\"is not\">C:\\Windows\\system32\\svchost.exe</SourceImage>\n      <SourceImage condition=\"is not\">C:\\Windows\\system32\\taskmgr.exe</SourceImage>\n      <!-- (Add more legitimate processes to the exclusion list) -->\n    </ProcessAccess>\n  </RuleGroup>\n</Sysmon>"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is 'process ancestry' analysis?",
                        "options": [
                            "Looking at the age of a process.",
                            "Analyzing the parent-child relationship between processes.",
                            "Looking at a process's file hash.",
                            "Looking at a process's network connections."
                        ],
                        "correct": 1,
                        "explanation": "Analyzing the process tree is a fundamental endpoint detection technique. Legitimate processes are spawned by expected parents. A suspicious parent-child relationship (like Word spawning cmd.exe) is a major red flag."
                    },
                    {
                        "id": 2,
                        "question": "Why is logging the full command line of a process so important for detecting LotL attacks?",
                        "options": [
                            "It is not important.",
                            "Because the name of the process (e.g., `powershell.exe`) is legitimate, the malicious intent is only visible in its command-line arguments.",
                            "It shows the process's hash.",
                            "It makes the logs smaller."
                        ],
                        "correct": 1,
                        "explanation": "For LotL, the process name is benign. The malicious activity is entirely contained within the command line arguments. Without full command-line logging, this activity is invisible."
                    },
                    {
                        "id": 3,
                        "question": "A detection rule that looks for unexpected processes opening a handle to `lsass.exe` is designed to detect what?",
                        "options": [
                            "Initial Access",
                            "Lateral Movement",
                            "Persistence",
                            "Credential Dumping"
                        ],
                        "correct": 3,
                        "explanation": "The LSASS process memory is where Windows stores credentials. Any unusual process trying to read this memory is a very strong indicator of a credential dumping attempt using a tool like Mimikatz."
                    }
                ]
            }
        },
        {
            "id": "lesson-14",
            "title": "Network-Based Detections (NIDS/NTA)",
            "duration": "75 min",
            "objectives": [
                "Understand the role of Network Intrusion Detection Systems (NIDS)",
                "Learn how to write basic signatures for tools like Suricata",
                "Explore the value of rich protocol metadata from Zeek",
                "Analyze network traffic to find C2 tunneling and other anomalies"
            ],
            "content": {
                "overview": "While the endpoint provides the deepest visibility into execution, the network is where we can see the attacker's communications. This lesson covers the core principles of network-based detection, from writing simple signatures for NIDS to analyzing the rich metadata from Network Security Monitoring (NSM) tools like Zeek.",
                "sections": [
                    {
                        "title": "NIDS Signatures (Suricata)",
                        "content": "<p>A Network Intrusion Detection System (NIDS) like <strong>Suricata</strong> or <strong>Snort</strong> inspects network traffic in real-time and compares it against a set of rules or 'signatures'. These rules can look for specific byte patterns in a packet's payload, or specific combinations of header values.</p><p>Writing a NIDS signature is a way to detect a specific, known threat. For example, you could write a signature that looks for the unique User-Agent string used by a specific strain of malware in its C2 traffic.</p>",
                        "image": "https://i.imgur.com/k2H1z5F.png"
                    },
                    {
                        "title": "Network Security Monitoring with Zeek",
                        "content": "<p><strong>Zeek</strong> (formerly known as Bro) is a different kind of network analysis tool. It is not a signature-based IDS. Instead, it is a 'Network Security Monitor'. It watches all the traffic on a network and produces a rich set of high-fidelity, structured log files for all the protocols it sees.</p><h3>Example Zeek Logs:</h3><ul><li><code>conn.log</code>: A log of every TCP/UDP/ICMP connection, with duration, bytes transferred, etc.</li><li><code>http.log</code>: A log of every HTTP request and response, with the host, URI, user-agent, and mime-type.</li><li><code>dns.log</code>: A log of every DNS query and response.</li></ul><p>These logs provide the high-quality, structured data needed to build powerful behavioral and anomaly-based detections in a SIEM.</p>",
                        "image": "https://images.unsplash.com/photo-1544383835-bda2bc66a22d?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Detecting Anomalies in Network Logs",
                        "content": "<p>With the rich data from Zeek, a detection engineer can build rules to find the subtle signals of C2 traffic.</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Finding C2 Beacons</strong></div><p>A C2 beacon often has a very regular, machine-like connection pattern. A detection could look for:<ul><li><strong>Regularity:</strong> A host making an outbound connection every 60 seconds, with very low jitter.</li><li><strong>Long Durations:</strong> A single TCP connection that stays open for hours or days.</li><li><strong>Uncommon User-Agents:</strong> An HTTP request using a strange or non-standard User-Agent string.</li><li><strong>DNS Tunneling:</strong> A large number of DNS queries for unique, long, and high-entropy subdomains of the same parent domain.</li></ul></p></div>",
                        "image": "https://images.unsplash.com/photo-1573495627361-ab2d_50a_a86a?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "Suricata_Signature_for_Cobalt_Strike_Beacon.rules",
                    "language": "ruby",
                    "code": "# This is a simplified Suricata rule to detect a common Cobalt Strike beacon pattern.\n\nalert http $HOME_NET any -> $EXTERNAL_NET any ( \\\n    msg:\"ET TROJAN Cobalt Strike Beacon Checkin Malleable (URI) POST\"; \\\n    flow:established,to_server; \\\n    # Look for a POST request with a URI that ends in '/submit.php'\n    http.uri; content:\"/submit.php\"; endswith; \\\n    # Look for the specific 'Content-Type' header used by the default profile\n    http.header; content:\"Content-Type: application/octet-stream\"; \\\n    # Look for a specific User-Agent\n    http.user_agent; content:\"Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko\"; \\\n    classtype:trojan-activity; \\\n    sid:2027929; rev:1;\n)"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary difference between a tool like Suricata and a tool like Zeek?",
                        "options": [
                            "There is no difference.",
                            "Suricata is primarily a signature-based NIDS, while Zeek is a Network Security Monitor that produces rich protocol logs.",
                            "Zeek is a firewall, while Suricata is an antivirus.",
                            "Suricata is for Linux, and Zeek is for Windows."
                        ],
                        "correct": 1,
                        "explanation": "This is a key distinction. Suricata is primarily focused on finding 'known bad' with signatures. Zeek's goal is to provide a high-quality, comprehensive record of all network activity, which can then be used to find 'unknown bad' through analysis."
                    },
                    {
                        "id": 2,
                        "question": "A detection rule that looks for a host making a connection every 61 seconds, then 59 seconds, then 62 seconds is trying to detect what?",
                        "options": [
                            "A vulnerability scan.",
                            "A C2 beacon with a low amount of 'jitter'.",
                            "Normal web browsing.",
                            "A file transfer."
                        ],
                        "correct": 1,
                        "explanation": "This highly regular, machine-like connection pattern is a classic indicator of a C2 beacon. The small amount of jitter is an attempt by the attacker to make the connection slightly less regular to evade simple timers."
                    },
                    {
                        "id": 3,
                        "question": "What kind of data would you find in Zeek's `dns.log`?",
                        "options": [
                            "A log of all TCP connections.",
                            "A log of all HTTP requests.",
                            "A log of every DNS query and its corresponding answer.",
                            "A log of all file creations."
                        ],
                        "correct": 2,
                        "explanation": "Zeek parses network traffic and generates separate, detailed logs for each protocol it understands. `dns.log` is the specific log file that contains all the DNS activity, and it is the primary source for detecting DNS tunneling attacks."
                    }
                ]
            }
        },
        {
            "id": "lesson-15",
            "title": "Statistical and Anomaly-Based Detection",
            "duration": "75 min",
            "objectives": [
                "Understand how to move beyond simple, signature-based detections",
                "Learn the principles of baselining 'normal' activity",
                "Explore techniques for detecting deviations and outliers",
                "Build a SIEM rule to detect a user logging in from a new country"
            ],
            "content": {
                "overview": "While signature-based detections are great for known threats, they cannot find a novel or customized attack. This lesson covers the principles of statistical and anomaly-based detection, where the goal is to define a baseline of 'normal' for your environment and then create detections that find significant deviations from that baseline.",
                "sections": [
                    {
                        "title": "Baselining Normal Activity",
                        "content": "<p>The first step in anomaly detection is to establish a <strong>baseline</strong>. This is a model of what normal activity looks for a specific entity (like a user or a host) or for the network as a whole. The baseline is built by analyzing historical log data over a period of time (e.g., 30 days).</p><h3>Examples of Baselines:</h3><ul><li>The normal hours that a user works.</li><li>The normal set of countries that users log in from.</li><li>The normal set of processes that run on a web server.</li><li>The average amount of data a user uploads per day.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Detecting Deviations",
                        "content": "<p>Once a baseline is established, a detection rule can be written to find deviations. These detections are often not as high-fidelity as a signature, but they are much better at finding unknown or customized attacks.</p><h3>Example Detections:</h3><ul><li><strong>New Country Logon:</strong> The SIEM maintains a list of all the countries a user has logged in from in the last 30 days. Alert if the user logs in from a country that is *not* on that list.</li><li><strong>Rare Process:</strong> The SIEM maintains a list of all processes ever seen on the organization's web servers. Alert if a new process that has *never been seen before* is executed on any web server.</li><li><strong>Unusual Data Egress:</strong> The SIEM calculates the average and standard deviation of a user's daily data upload volume. Alert if a user's upload volume for one day is more than 4 standard deviations above their average.</li></ul>",
                        "image": "https://i.imgur.com/kYq3Q6k.png"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Elastic_Machine_Learning_Job_for_Rare_Process_Detection.json",
                        "language": "json",
                        "code": "{\n  \"description\": \"Detects the execution of a process that is rare for the host.\",\n  \"analysis_config\": {\n    \"bucket_span\": \"15m\",\n    \"detectors\": [\n      {\n        \"detector_description\": \"rare process by host\",\n        \"function\": \"rare\",\n        \"by_field_name\": \"process.name\",\n        \"partition_field_name\": \"host.name\"\n      }\n    ],\n    \"influencers\": [\"process.name\", \"host.name\"]\n  },\n  \"data_description\": {\n    \"time_field\": \"@timestamp\"\n  }\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary goal of anomaly-based detection?",
                        "options": [
                            "To find known malware signatures.",
                            "To establish a baseline of normal behavior and detect significant deviations from it.",
                            "To block all traffic.",
                            "To write a report."
                        ],
                        "correct": 1,
                        "explanation": "Anomaly-based detection is designed to find 'unknown unknowns'. By learning what is normal, it can flag any activity that doesn't conform to that pattern, which might be a novel attack."
                    },
                    {
                        "id": 2,
                        "question": "What is a 'baseline' in the context of this lesson?",
                        "options": [
                            "A type of firewall rule.",
                            "A model of normal activity for a user, host, or network, built from historical data.",
                            "A list of malicious IP addresses.",
                            "The minimum level of security."
                        ],
                        "correct": 1,
                        "explanation": "The baseline is the foundation of anomaly detection. It is the data-driven definition of 'normal' that we compare new activity against."
                    },
                    {
                        "id": 3,
                        "question": "An alert that fires when a user logs in from a country for the very first time is an example of what?",
                        "options": [
                            "A signature-based detection.",
                            "A statistical or anomaly-based detection.",
                            "A firewall rule.",
                            "A false negative."
                        ],
                        "correct": 1,
                        "explanation": "This is a classic anomaly detection use case. The system uses historical data to build a profile of a user's normal locations and then alerts when it sees a deviation (a new, previously unseen location)."
                    }
                ]
            }
        },
        {
            "id": "lesson-16",
            "title": "Identity-Based Detections",
            "duration": "75 min",
            "objectives": [
                "Understand why authentication logs are a critical data source",
                "Learn how to build detections for password spraying attacks",
                "Explore techniques for detecting Kerberoasting",
                "Analyze the patterns of brute-force and credential stuffing attacks",
                "Practice writing a KQL query to detect a password spray attack"
            ],
            "content": {
                "overview": "Identity is the new perimeter. Attackers are relentlessly targeting user credentials to gain initial access and escalate privileges. This lesson focuses on building detections using the rich data from authentication logs (like Active Directory and Azure AD) to find the common attacks against user identities.",
                "sections": [
                    {
                        "title": "Detecting Password Spraying",
                        "content": "<p>A <strong>password spraying</strong> attack is a stealthy brute-force technique where an attacker tries one or two common passwords (e.g., 'Winter2024') against a large number of different user accounts.</p><p>This is hard to detect from the perspective of a single user (who only sees one failed login), but it creates a very clear pattern when analyzed in aggregate. The detection logic is to look for a single source IP address that is generating a high count of failed logins across a high count of *distinct* usernames in a short period of time.</p>",
                        "image": "https://i.imgur.com/k2H1z5F.png"
                    },
                    {
                        "title": "Detecting Kerberoasting",
                        "content": "<p>As we learned in the offensive lessons, a <strong>Kerberoasting</strong> attack involves a user requesting a large number of service tickets (Kerberos Event ID 4769) to crack them offline.</p><p>This behavior is also highly anomalous. A normal user will only request a handful of service tickets during a normal workday. An attacker performing Kerberoasting will request dozens or hundreds in a few minutes. The detection logic is to baseline the normal number of 4769 events per user per hour and alert on any significant deviation from that baseline. A particularly high-fidelity signal is seeing a large number of these requests where the encryption type is RC4, which is weaker and easier to crack.</p>",
                        "image": "https://images.unsplash.com/photo-1599508704512-2f19efd1e_35f?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "KQL_Query_for_Password_Spraying_Detection.kql",
                    "language": "kusto",
                    "code": "// This KQL query detects a potential password spraying attack.\n\nSigninLogs // Start with the Azure AD sign-in logs table\n| where ResultType == 50126 // Filter for failed logins due to invalid credentials\n| summarize\n    // For each source IP, count the total failures and the number of unique users attacked\n    TotalFailedLogins = count(),\n    DistinctUsersAttacked = dcount(UserPrincipalName)\n    by IpAddress, bin(TimeGenerated, 10m) // Group by IP in 10-minute windows\n| where TotalFailedLogins > 20 and DistinctUsersAttacked > 10 // Set thresholds\n| project TimeGenerated, IpAddress, TotalFailedLogins, DistinctUsersAttacked"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the key pattern of a password spraying attack?",
                        "options": [
                            "Many failed logins for one user from many IPs.",
                            "One successful login.",
                            "Many failed logins for many different users, all coming from one source IP.",
                            "A single failed login."
                        ],
                        "correct": 2,
                        "explanation": "The key is the 'many-to-one' relationship: many users being targeted by one attacker. This creates a distinct statistical anomaly when the logs are aggregated by the source IP address."
                    },
                    {
                        "id": 2,
                        "question": "Which Windows Event ID is most relevant for detecting Kerberoasting?",
                        "options": [
                            "4624 (Successful Logon)",
                            "4625 (Failed Logon)",
                            "4769 (A Kerberos service ticket was requested)",
                            "4688 (Process Creation)"
                        ],
                        "correct": 2,
                        "explanation": "The Kerberoasting attack works by requesting service tickets. Event ID 4769 is the log that records this specific action, making it the primary data source for this detection."
                    },
                    {
                        "id": 3,
                        "question": "Why are authentication logs considered a critical data source for detection?",
                        "options": [
                            "They are not a critical source.",
                            "Because nearly all adversary actions, from initial access to lateral movement, require the use of credentials, which generates authentication events.",
                            "They are very small and easy to store.",
                            "They only show successful logins."
                        ],
                        "correct": 1,
                        "explanation": "Authentication is a fundamental part of almost every TTP. Having comprehensive authentication logs (both success and failure) provides visibility into a huge range of adversary behaviors."
                    }
                ]
            }
        },
        
        {
            "id": "lesson-17",
            "title": "Proactive Detection: The Art of Threat Hunting",
            "duration": "75 min",
            "objectives": [
                "Differentiate threat hunting from traditional SOC analysis",
                "Understand the principles of hypothesis-driven threat hunting",
                "Learn how to proactively search through data to find untriaged evil",
                "Explore the feedback loop between hunting and detection engineering"
            ],
            "content": {
                "overview": "Threat hunting is the proactive, iterative, and human-driven search for adversaries that have bypassed an organization's automated defenses. It assumes that the network is already compromised. This lesson covers the mindset and methodology of a threat hunter and its critical relationship with detection engineering.",
                "sections": [
                    {
                        "title": "Hunting vs. Analysis",
                        "content": "<p>A SOC Analyst typically starts with an alert from the SIEM and investigates it. A <strong>Threat Hunter</strong> starts with a hypothesis and dives into the raw data to see if they can prove it. A hunter does not wait for an alert; they actively search for the signs of an attack that the automated systems may have missed.</p>",
                        "image": "https://images.unsplash.com/photo-1573495627361-ab2d_50a_a86a?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The Hunt Lifecycle",
                        "content": "<p>A threat hunt is a structured process:</p><ol><li><strong>Form a Hypothesis:</strong> Based on threat intelligence, the hunter forms a hypothesis. (e.g., 'An attacker might be using DNS tunneling for C2').</li><li><strong>Gather Data:</strong> The hunter uses the SIEM to gather the relevant data (e.g., all Zeek DNS logs).</li><li><strong>Analyze and Investigate:</strong> The hunter uses complex queries and statistical analysis to look for the patterns described in the hypothesis (e.g., unusually long DNS queries, high-entropy subdomains).</li><li><strong>Respond:</strong> If a threat is found, the hunt immediately transitions into an incident response.</li><li><strong>Enrich Detections:</strong> This is the most critical step. The successful hunt's logic is then given to the detection engineering team, who turn it into a new, automated detection rule. This ensures the organization can automatically detect the same threat in the future.</li></ol>",
                        "image": "https://i.imgur.com/kYq3Q6k.png"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Threat_Hunting_Playbook_for_LOLBAS.md",
                        "language": "markdown",
                        "code": "# Hunt Playbook: Suspicious use of Certutil.exe\n\n**Hypothesis:** Attackers may be using the built-in `certutil.exe` to download malware or decode malicious payloads, bypassing other network and endpoint controls.\n\n**ATT&CK TTP:** T1105 - Ingress Tool Transfer\n\n**Data Source:** \n- Windows Security Event Logs (Event ID 4688)\n- Sysmon (Event ID 1)\n\n**Query:**\n```sql\n-- Find all command-line executions of certutil.exe with suspicious arguments\nSELECT timestamp, hostname, parent_process, process_commandline\nFROM endpoint_logs\nWHERE process_name = 'certutil.exe' \n  AND (command_line LIKE '%-urlcache%' OR command_line LIKE '%-decode%')\n```\n\n**Analysis Steps:**\n1.  Execute the query over the last 7 days.\n2.  For any results, investigate the parent process. Is it a legitimate admin script or an unusual parent like `winword.exe`?\n3.  Investigate the URL or file being downloaded/decoded. Is it from a known-good source?\n4.  If suspicious, pivot to the host and perform deeper analysis."
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the key characteristic of threat hunting?",
                        "options": [
                            "It is a purely automated process.",
                            "It is a proactive, human-driven search for threats that have evaded existing defenses.",
                            "It only involves reacting to alerts from an IDS.",
                            "It is the same as penetration testing."
                        ],
                        "correct": 1,
                        "explanation": "Threat hunting is proactive, not reactive. It assumes that a breach may have already occurred and involves actively searching for the evidence of that breach."
                    },
                    {
                        "id": 2,
                        "question": "What is the starting point for a typical threat hunt?",
                        "options": [
                            "A random search.",
                            "An alert from the IDS.",
                            "A hypothesis formulated by a human analyst based on threat intelligence.",
                            "A report from a user."
                        ],
                        "correct": 2,
                        "explanation": "A good hunt is not a random walk through the data. It's a structured investigation that starts with a specific, testable hypothesis about potential attacker activity."
                    },
                    {
                        "id": 3,
                        "question": "What is the most critical final step of a successful threat hunt?",
                        "options": [
                            "To keep the technique a secret.",
                            "To write a blog post about it.",
                            "To operationalize the discovery by turning the hunt's logic into a new, automated detection rule.",
                            "To immediately fire the person who was compromised."
                        ],
                        "correct": 2,
                        "explanation": "The ultimate goal of hunting is to continuously improve the organization's automated defenses. A successful hunt provides the logic for a new detection that can catch the same threat automatically in the future."
                    }
                ]
            }
        },
        {
            "id": "lesson-18",
            "title": "Detecting Evasion: Living-off-the-Land (LotL) Attacks",
            "duration": "75 min",
            "objectives": [
                "Understand the challenge of detecting the malicious use of legitimate tools",
                "Learn how to focus on anomalous usage patterns and command-line parameters",
                "Explore how to detect specific LotL techniques like remote scriptlet execution",
                "Practice building a high-fidelity detection for a LotL technique"
            ],
            "content": {
                "overview": "Detecting Living-off-the-Land attacks is the core challenge of a modern detection engineer. We cannot simply block legitimate tools like PowerShell. Instead, we must focus on the context and behavior to differentiate malicious use from benign. This lesson covers the strategies for building high-fidelity detections for these evasive techniques.",
                "sections": [
                    {
                        "title": "The Context is Key",
                        "content": "<p>The key to detecting LotL is to stop looking at the *process* and start looking at the *behavior*. The detection logic must be built around suspicious context.</p><h3>Contextual Indicators:</h3><ul><li><strong>Parent-Child Relationships:</strong> A legitimate tool spawned by an unusual parent process (e.g., `winword.exe` -> `powershell.exe`).</li><li><strong>Command-Line Arguments:</strong> A legitimate tool run with a combination of flags that is almost exclusively used by attackers (e.g., `powershell.exe -enc ...`).</li><li><strong>Network Connections:</strong> A legitimate tool making an outbound network connection to a strange or newly registered domain.</li><li><strong>Sequence of Actions:</strong> A legitimate tool being used as part of a longer, suspicious chain of events.</li></ul>",
                        "image": "https://i.imgur.com/kYq3Q6k.png"
                    },
                    {
                        "title": "Detecting Specific Techniques",
                        "content": "<p>Our detection rules should be mapped directly to the TTPs in the LOLBAS project.</p><ul><li><strong>`rundll32.exe` execution:</strong> A rule can look for the process `rundll32.exe` where the command line contains suspicious indicators like `javascript:` and `script:`.</li><li><strong>`certutil.exe` download:</strong> A rule can look for the process `certutil.exe` with the `-urlcache` flag in its command line.</li><li><strong>PowerShell download cradle:</strong> A rule can look for the process `powershell.exe` where the command line contains `New-Object Net.WebClient` and `.DownloadString`.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "Sigma_Rule_to_Detect_Certutil_Used_for_Downloads.yml",
                    "language": "yaml",
                    "code": "title: Certutil.exe Used for File Download\nstatus: stable\ndescription: Detects the use of the built-in certutil.exe binary to download a remote file.\nreferences:\n    - https://lolbas-project.github.io/lolbas/Binaries/Certutil/\nauthor: Alex Chen\ndate: 2023/04/01\ntags:\n    - attack.command_and_control\n    - attack.t1105\n\nlogsource:\n    category: process_creation\n    product: windows\n\ndetection:\n    selection:\n        Image|endswith: '\\certutil.exe'\n        CommandLine|contains|all:\n            - '-urlcache'\n            - '-split'\n            - '-f'\n    condition: selection\n\nfalsepositives:\n    - Extremely rare, but some legitimate software installers might use this.\nlevel: high"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the key to detecting a Living-off-the-Land attack?",
                        "options": [
                            "Blocking all legitimate system tools.",
                            "Focusing on the context and behavior of how a tool is used, rather than the tool itself.",
                            "Only looking at network traffic.",
                            "Ignoring alerts from PowerShell."
                        ],
                        "correct": 1,
                        "explanation": "Since the tool itself is legitimate, the detection logic must be nuanced. It needs to find the anomalous *usage* of the tool, such as a suspicious parent process or a dangerous combination of command-line flags."
                    },
                    {
                        "id": 2,
                        "question": "A detection rule that alerts when Microsoft Word (`winword.exe`) spawns a PowerShell process (`powershell.exe`) is an example of what?",
                        "options": [
                            "A network-based detection.",
                            "A signature-based detection.",
                            "A detection based on a suspicious parent-child process relationship.",
                            "A false positive."
                        ],
                        "correct": 2,
                        "explanation": "This is a classic behavioral detection. It is not normal for a word processor to launch a powerful scripting engine. This behavior is a very strong indicator of a malicious macro being executed."
                    },
                    {
                        "id": 3,
                        "question": "Why is it critical to have full command-line logging enabled to detect LotL?",
                        "options": [
                            "It is not critical.",
                            "Because the malicious intent of a LotL attack is almost always contained in the command-line arguments, not in the process name.",
                            "Because it helps to make the logs smaller.",
                            "Because it is required for compliance."
                        ],
                        "correct": 1,
                        "explanation": "Without the command-line arguments, a defender would just see `powershell.exe` running, which is normal. With the arguments, they can see `powershell.exe -enc ...`, which is highly suspicious."
                    }
                ]
            }
        },
        {
            "id": "lesson-19",
            "title": "Detecting Lateral Movement",
            "duration": "75 min",
            "objectives": [
                "Understand the importance of detecting lateral movement early",
                "Learn how to build detections for remote service creation (PsExec)",
                "Explore techniques for detecting remote WMI and WinRM usage",
                "Analyze authentication logs to find Pass-the-Hash activity"
            ],
            "content": {
                "overview": "Detecting lateral movement is one of the most important jobs of a detection engineer. An attacker moving from host to host is a clear sign of a hands-on-keyboard adversary and a major escalation of an incident. This lesson covers the data sources and detection logic for finding the most common lateral movement techniques.",
                "sections": [
                    {
                        "title": "Detecting Remote Service Creation (PsExec)",
                        "content": "<p>Tools like PsExec work by creating a temporary service on the remote machine. This leaves a very clear forensic trail in the logs.</p><p>A detection can be built by monitoring the Windows System Event Log on a target machine (like a server) for Event ID 7045: 'A service was installed in the system'. While legitimate software installations will trigger this, a 7045 event where the 'Service File Name' points to an unusual executable in a temporary directory (like `C:\\Windows\\Temp\\psexesvc.exe`) is a high-fidelity indicator of PsExec-like lateral movement.</p>",
                        "image": "https://i.imgur.com/k2H1z5F.png"
                    },
                    {
                        "title": "Detecting Pass-the-Hash",
                        "content": "<p>Detecting Pass-the-Hash (PtH) requires analyzing Windows authentication logs (Event ID 4624). While there is no single log that says 'a hash was used', PtH activity has several characteristic artifacts.</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>The Telltale Signs of PtH</strong></div><p>A classic Pass-the-Hash attack using a local account's hash will generate a logon event (4624) with the following properties:<ul><li><strong>Logon Type:</strong> 3 (Network logon).</li><li><strong>Authentication Package:</strong> NTLM.</li><li><strong>Logon Process:</strong> NtLmSsp.</li><li><strong>Key Indicator:</strong> The user's Security ID (SID) will be that of a well-known local account (like the local Administrator, S-1-5-...-500) but the logon is coming from a remote machine.</li></ul>This is highly anomalous. A local administrator account should not be used to log in *from* the network *to* another machine. This is a very strong signal of PtH.</p></div>",
                        "image": "https://images.unsplash.com/photo-1599508704512-2f19efd1e_35f?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "Detection_for_Anomalous_Windows_Service_Creation.spl",
                    "language": "splunk",
                    "code": "# This Splunk query detects PsExec-like activity.\n\nindex=wineventlog sourcetype=\"WinEventLog:System\" EventCode=7045\n\n# Filter for suspicious service names used by common tools\n| search ServiceName IN (PSEXESVC, PSEXEC, RemCom_Service)\n\n# Or, look for services where the executable is in a temporary or unusual location\n| regex ServiceFileName=\"(C:\\\\Windows\\\\Temp\\\\.*|C:\\\\Users\\\\.*\\\\AppData\\\\.*)\"\n\n| table _time, host, ServiceName, ServiceFileName, AccountName"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "A Windows Event ID 7045 ('A service was installed') where the service executable is in `C:\\Windows\\Temp` is a strong indicator of what?",
                        "options": [
                            "A normal Windows update.",
                            "Lateral movement using a tool like PsExec.",
                            "A user logging in.",
                            "A file being downloaded."
                        ],
                        "correct": 1,
                        "explanation": "Legitimate services are almost always installed in `C:\\Program Files` or `C:\\Windows\\System32`. A service being created that runs from a temporary directory is a classic sign of a malicious remote administration tool."
                    },
                    {
                        "id": 2,
                        "question": "Which Windows Event ID is the primary source for analyzing authentication activity, including lateral movement?",
                        "options": [
                            "4688 (Process Creation)",
                            "7045 (Service Installation)",
                            "4624 (An account was successfully logged on)",
                            "4769 (A Kerberos service ticket was requested)"
                        ],
                        "correct": 2,
                        "explanation": "Event ID 4624 is the 'successful logon' event. By analyzing the fields within this event (like Logon Type, source IP, and account name), a detection engineer can build a detailed picture of authentication activity in their network."
                    },
                    {
                        "id": 3,
                        "question": "A network logon (Logon Type 3) using a local administrator account is a strong indicator of what?",
                        "options": [
                            "Normal administrative activity.",
                            "A Pass-the-Hash attack.",
                            "A user logging into their own workstation.",
                            "A bug in the logging system."
                        ],
                        "correct": 1,
                        "explanation": "Local accounts are designed for local logons. When a local account's credentials are seen authenticating *over the network*, it is a highly anomalous event and a key indicator for Pass-the-Hash."
                    }
                ]
            }
        },
        {
            "id": "lesson-20",
            "title": "Detecting Persistence",
            "duration": "75 min",
            "objectives": [
                "Understand the importance of detecting persistence mechanisms",
                "Learn how to monitor for the creation of new services and scheduled tasks",
                "Explore techniques for detecting modifications to registry run keys",
                "Analyze the challenges of differentiating malicious persistence from benign"
            ],
            "content": {
                "overview": "Detecting an attacker's persistence mechanism is one of the most valuable things a Blue Team can do. Finding the persistence mechanism allows you to fully eradicate the attacker from the network and ensure they cannot easily regain access. This lesson covers the detection strategies for the most common persistence TTPs.",
                "sections": [
                    {
                        "title": "Detecting Persistence via Scheduled Tasks",
                        "content": "<p>Attackers frequently use scheduled tasks to maintain persistence. A detection can be built by monitoring the Windows Security Event Log for <strong>Event ID 4698: 'A scheduled task was created'</strong>.</p><p>While legitimate software will create scheduled tasks, a detection engineer can filter for suspicious indicators:<ul><li>A task where the command to be executed (`/tr`) is in a strange location (e.g., a user's Temp folder).</li><li>A task that is configured to run a scripting engine like PowerShell with a suspicious, encoded command.</li><li>A task with a name that is trying to masquerade as a legitimate update (e.g., 'GoogleUpdater').</li></ul></p>",
                        "image": "https://i.imgur.com/k2H1z5F.png"
                    },
                    {
                        "title": "Detecting Persistence via Registry Run Keys",
                        "content": "<p>Monitoring for changes to the common `Run` and `RunOnce` registry keys is another critical detection. Tools like Sysmon (<strong>Event ID 13: RegistryEvent (SetValue)</strong>) can provide this telemetry.</p><p>A detection rule would look for any new value being written to a key like `HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run`. The logic would then need to filter out known-good installers and updaters to reduce false positives. An entry that points to an unsigned executable in a temporary location is highly suspicious.</p>",
                        "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "Detection_for_Suspicious_Scheduled_Task_Creation.kql",
                    "language": "kusto",
                    "code": "// This KQL query hunts for suspicious scheduled tasks.\n\nSecurityEvent\n| where EventID == 4698 // 'A scheduled task was created'\n| parse EventData with * 'TaskName\">' TaskName '<' * 'Command\">' Command '<' *\n| where \n    // Look for tasks that run from temporary or user-writable locations\n    Command matches regex @\"(C:\\\\Users\\\\.*|C:\\\\Windows\\\\Temp\\\\.*|C:\\\\ProgramData\\\\.*)\"\n    // Or look for tasks that run suspicious scripting engines\n    or Command has_any (\"powershell\", \"wscript\", \"cscript\", \"mshta\")\n| project TimeGenerated, Computer, TaskName, Command"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "Why is detecting an attacker's persistence mechanism so important?",
                        "options": [
                            "It is not very important.",
                            "Because it is the key to fully eradicating the attacker from the network and preventing them from regaining access.",
                            "Because it is the first sign of an attack.",
                            "Because it is easy to do."
                        ],
                        "correct": 1,
                        "explanation": "If you clean up a malware infection but miss the persistence mechanism, the attacker will be back as soon as the machine reboots. Finding and removing the persistence is critical for a successful incident response."
                    },
                    {
                        "id": 2,
                        "question": "Which Windows Event ID logs the creation of a new scheduled task?",
                        "options": [
                            "4624 (Logon)",
                            "4688 (Process Creation)",
                            "4698 (Scheduled Task Creation)",
                            "7045 (Service Creation)"
                        ],
                        "correct": 2,
                        "explanation": "Event ID 4698 is the specific log source that provides the ground truth for when a new scheduled task is created, making it the primary data source for this detection."
                    },
                    {
                        "id": 3,
                        "question": "A new entry in a registry 'Run' key that points to an executable in `C:\\Users\\John\\AppData\\Local\\Temp\\updater.exe` is suspicious because...",
                        "options": [
                            "It is not suspicious.",
                            "Legitimate programs should not be running from a user's temporary directory at startup.",
                            "The file name is suspicious.",
                            "The user is not an administrator."
                        ],
                        "correct": 1,
                        "explanation": "The location of the executable is a key indicator. Legitimate system-wide startup items should be in protected directories like `Program Files`. An executable running from a user's temporary folder is a classic sign of malware persistence."
                    }
                ]
            }
        },
        {
            "id": "lesson-21",
            "title": "Cloud Detection Engineering",
            "duration": "75 min",
            "objectives": [
                "Apply detection engineering principles to cloud environments",
                "Learn to detect common cloud misconfigurations",
                "Explore techniques for detecting IAM privilege escalation",
                "Analyze suspicious API activity in logs like AWS CloudTrail"
            ],
            "content": {
                "overview": "As organizations move to the cloud, so do the attackers. Detection engineering in the cloud requires a different mindset and a different set of data sources. This lesson covers the core principles of detecting threats in cloud environments like AWS and Azure, focusing on IAM misconfigurations and suspicious API activity.",
                "sections": [
                    {
                        "title": "The Cloud Control Plane",
                        "content": "<p>The primary attack surface in the cloud is the <strong>control plane</strong>. This is the set of APIs that are used to manage the cloud resources themselves. Every action in the cloud, from starting a VM to creating a storage bucket, is an API call.</p><p>The primary data source for detection is the log of all these API calls. In AWS, this is <strong>CloudTrail</strong>. In Azure, it is the <strong>Azure Monitor Activity Log</strong>. Detecting a cloud attack is the process of finding a suspicious sequence of API calls in these logs.</p>",
                        "image": "https://i.imgur.com/fgS4fG3.png"
                    },
                    {
                        "title": "Detecting IAM Privilege Escalation",
                        "content": "<p>As we learned in the offensive lessons, cloud privilege escalation often involves chaining together multiple IAM permissions. The detection for this involves looking for that specific chain of API calls.</p><h3>Example: Detecting the AWS `CreatePolicyVersion` Escalation</h3><p>The attack chain is: `CreatePolicyVersion` -> `SetDefaultPolicyVersion` -> `CreateInstanceProfile` -> `AddRoleToInstanceProfile` -> `RunInstances` -> `Get Console Access`. A detection engineer can build a rule that looks for this specific sequence of events originating from a single user in a short period of time. While each individual API call might be legitimate, the sequence as a whole is highly suspicious.</p>",
                        "image": "https://images.unsplash.com/photo-1573495627361-ab2d_50a_a86a?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Cloud Red Teaming with Stratus Red Team",
                        "content": "<p><strong>Stratus Red Team</strong> is an open-source tool for emulating cloud-based adversary techniques. It is the 'Atomic Red Team for the cloud'. It contains a library of atomic tests for specific cloud TTPs (e.g., 'Steal EC2 Instance Credentials'). A detection engineer can use Stratus Red Team to safely test and validate their cloud detection rules in a lab environment.</p>",
                        "image": "https://i.imgur.com/k2H1z5F.png"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "AWS_CloudTrail_Rule_for_Detecting_Console_Login_Without_MFA.sql",
                    "language": "sql",
                    "code": "-- This is a query for a SIEM like AWS Athena to detect a common security issue.\n\nSELECT eventTime, awsRegion, sourceIPAddress, userIdentity.arn\nFROM cloudtrail_logs\nWHERE eventName = 'ConsoleLogin'\n  AND responseElements.ConsoleLogin = 'Success'\n  -- The key part of the logic:\n  AND json_extract_scalar(additionalEventData, '$.MFAUsed') != 'Yes'"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary data source for detecting threats in an AWS environment?",
                        "options": [
                            "Sysmon logs.",
                            "AWS CloudTrail logs.",
                            "Firewall logs.",
                            "DNS logs."
                        ],
                        "correct": 1,
                        "explanation": "CloudTrail records every single API call made in the AWS account. It is the ground truth for all activity in the control plane and the most critical log source for cloud detection."
                    },
                    {
                        "id": 2,
                        "question": "Detecting a sequence of API calls like `CreatePolicyVersion` followed by `RunInstances` is aimed at finding what type of threat?",
                        "options": [
                            "A phishing attack.",
                            "An IAM privilege escalation attack.",
                            "A ransomware attack.",
                            "A denial-of-service attack."
                        ],
                        "correct": 1,
                        "explanation": "This specific sequence is a known privilege escalation path in AWS. A good detection rule will look for the entire chain of events, not just a single API call, to increase its fidelity."
                    },
                    {
                        "id": 3,
                        "question": "What is the purpose of the Stratus Red Team tool?",
                        "options": [
                            "It is a cloud SIEM.",
                            "It is an open-source tool for safely simulating and testing specific cloud adversary TTPs to validate detections.",
                            "It is an IAM management tool.",
                            "It is a cloud firewall."
                        ],
                        "correct": 1,
                        "explanation": "Stratus Red Team is the 'Atomic Red Team for the cloud'. It is an essential tool for any cloud detection engineer to test and validate their rules in a repeatable way."
                    }
                ]
            }
        },
        {
            "id": "lesson-22",
            "title": "Detection-as-Code",
            "duration": "75 min",
            "objectives": [
                "Understand the principles of Detection-as-Code (DaC)",
                "Learn how to manage detection rules in a version control system like Git",
                "Explore how to build a CI/CD pipeline to automatically test and deploy rules",
                "Analyze the benefits of peer review and versioning for detections"
            ],
            "content": {
                "overview": "Detection-as-Code is the modern, mature approach to managing a detection program. It is the practice of treating your detection rules with the same rigor and process as production software code. This lesson covers the principles and practices of building a scalable, automated, and collaborative detection program using DaC.",
                "sections": [
                    {
                        "title": "The Principles of Detection-as-Code",
                        "content": "<p>In a traditional SOC, detection rules are often written directly in the SIEM's web interface. This can lead to chaos, with no version history, no testing, and no peer review.</p><p><strong>Detection-as-Code (DaC)</strong> treats the detection rule (e.g., a Sigma file) as the source of truth. The process is:<ul><li>All rules are written as code in a version control system like Git.</li><li>Any change to a rule must be made through a pull request, which is reviewed by another engineer.</li><li>The pull request triggers an automated CI/CD pipeline that tests the rule.</li><li>Only after the review and tests pass is the rule automatically deployed to the SIEM.</li></ul></p>",
                        "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The CI/CD Pipeline for Detections",
                        "content": "<p>A <strong>CI/CD (Continuous Integration/Continuous Deployment)</strong> pipeline for detections automates the entire testing and deployment process.</p><h3>A Typical Pipeline:</h3><ol><li><strong>Linting:</strong> The pipeline first checks the Sigma rule for correct syntax and formatting.</li><li><strong>Unit Testing:</strong> It can test the rule against a set of sample log files (some that should match, some that shouldn't) to ensure the logic is correct.</li><li><strong>Translation:</strong> It uses a tool like `sigmac` to translate the Sigma rule into the query languages for all the organization's different SIEMs.</li><li><strong>Deployment:</strong> If all tests pass, it uses the SIEM's API to automatically upload and enable the new rule.</li></ol>",
                        "image": "https://i.imgur.com/kYq3Q6k.png"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "GitHub_Action_to_Test_Sigma_Rules.yml",
                    "language": "yaml",
                    "code": "# This is a simplified GitHub Action workflow to automate Sigma rule testing.\n\nname: CI-CD for Detections\n\non: [pull_request]\n\njobs:\n  test-and-deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check out code\n        uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.x'\n\n      - name: Install dependencies (sigmac)\n        run: pip install sigmatools\n\n      - name: Lint the Sigma Rules\n        # Find all changed .yml files and run the linter on them\n        run: |\n          # ... (script to find changed files) ...\n          sigmac -c my-sigma-config.yml --validate ./rules/\n\n      - name: Translate to Splunk and Deploy\n        if: success()\n        # If linting passes, translate and deploy via API\n        run: |\n          sigmac -t splunk -c my-sigma-config.yml -o splunk_rule.spl ./rules/my_new_rule.yml\n          # ... (script to call Splunk API to deploy the rule) ..."
                }
            ]
        },
        {
            "id": "lesson-23",
            "title": "Measuring Success: Metrics and Coverage",
            "duration": "60 min",
            "objectives": [
                "Understand how to quantify the effectiveness of a detection program",
                "Learn how to track key metrics like Mean Time to Detect (MTTD)",
                "Explore how to measure rule efficacy and false positive rates",
                "Analyze how to map detection coverage against the ATT&CK framework"
            ],
            "content": {
                "overview": "You can't improve what you can't measure. A mature detection engineering program is data-driven. This lesson covers the key metrics and Key Performance Indicators (KPIs) used to measure the success of a detection program, from the speed of detection to the breadth of coverage against the MITRE ATT&CK framework.",
                "sections": [
                    {
                        "title": "Key Performance Indicators (KPIs)",
                        "content": "<p>Tracking metrics is essential for showing value and for identifying areas for improvement.</p><h3>Core Metrics:</h3><ul><li><strong>Mean Time to Detect (MTTD):</strong> The average time it takes from when a security incident begins to when it is detected by the SOC. This is one of the most important high-level metrics.</li><li><strong>Mean Time to Respond (MTTR):</strong> The average time from detection to containment.</li><li><strong>Detection Rule Efficacy:</strong> For each rule, what percentage of its alerts are true positives vs. false positives?</li><li><strong>Detection Latency:</strong> How long does it take for data to get from the endpoint to the SIEM and for a rule to fire?</li></ul>",
                        "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Measuring ATT&CK Coverage",
                        "content": "<p>One of the most powerful ways to visualize and measure the state of a detection program is by mapping its rules to the MITRE ATT&CK framework.</p><p>A detection engineer can use the ATT&CK Navigator to create a heatmap. Each technique in the matrix can be color-coded based on the quality of the detection coverage for that technique:<ul><li><strong>Green:</strong> High-fidelity, automated detection rule in place.</li><li><strong>Yellow:</strong> Basic telemetry exists, but requires a human to hunt for it.</li><li><strong>Red:</strong> No visibility or detection capability for this technique.</li></ul><p>This provides an instant, data-driven visualization of the program's strengths and weaknesses, and makes it easy to prioritize the next set of detections to be built (i.e., 'turn the red squares yellow, and the yellow squares green').</p>",
                        "image": "https://i.imgur.com/kYq3Q6k.png"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "ATT&CK_Coverage_Heatmap_Script.py",
                    "language": "python",
                    "code": "import json\n\n# This script would take your list of detection rules and generate an\n# ATT&CK Navigator JSON layer file from it.\n\ndef generate_coverage_layer(rules):\n    navigator_layer = {\n        \"name\": \"Detection Coverage\",\n        \"domain\": \"enterprise-attack\",\n        \"techniques\": []\n    }\n\n    for rule in rules:\n        technique_entry = {\n            \"techniqueID\": rule['attack_id'],\n            \"color\": \"#2e8b57\", # Green for high-fidelity\n            \"comment\": f\"Detected by rule: {rule['name']}\",\n            \"enabled\": True\n        }\n        navigator_layer['techniques'].append(technique_entry)\n\n    with open(\"coverage_layer.json\", \"w\") as f:\n        json.dump(navigator_layer, f)\n\n# The user can then upload this JSON file to the ATT&CK Navigator website\n# to see their coverage heatmap."
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What does MTTD stand for?",
                        "options": [
                            "Mean Time To Deploy",
                            "Mean Time To Detect",
                            "Maximum Time To Detect",
                            "Minimum Time To Detect"
                        ],
                        "correct": 1,
                        "explanation": "Mean Time to Detect is a critical, high-level metric that measures the speed of the detection program. The goal is to drive this number as low as possible."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary purpose of mapping detection rules to the MITRE ATT&CK framework?",
                        "options": [
                            "It is a compliance requirement.",
                            "To visualize the program's detection coverage, identify gaps, and prioritize future work.",
                            "To share the rules with other companies.",
                            "To make the rules run faster."
                        ],
                        "correct": 1,
                        "explanation": "ATT&CK provides a common language and a comprehensive map. Mapping your detections to it allows you to see your defenses from the adversary's perspective and to make data-driven decisions about what to build next."
                    },
                    {
                        "id": 3,
                        "question": "If a detection rule fires 100 times in a week, and 95 of those alerts are closed as false positives, what does this tell us?",
                        "options": [
                            "The rule is very effective.",
                            "The SOC analysts are not doing their job.",
                            "The rule has a very low fidelity (a 95% false positive rate) and needs to be urgently tuned or disabled.",
                            "The network is under heavy attack."
                        ],
                        "correct": 2,
                        "explanation": "Rule efficacy is a key metric. A rule with a high false positive rate is a 'noisy' rule that wastes analyst time and erodes trust in the detection system. Tuning this rule would be a high priority."
                    }
                ]
            }
        },
        {
            "id": "lesson-24",
            "title": "Fostering Collaboration: Purple Teaming",
            "duration": "75 min",
            "objectives": [
                "Understand the concept and goals of a Purple Team exercise",
                "Differentiate purple teaming from red and blue teaming",
                "Explore the collaborative process of testing and improving detections",
                "Learn how to create a TTP testing plan",
                "Analyze the feedback loop between attackers and defenders"
            ],
            "content": {
                "overview": "The ultimate goal of adversary simulation is to make the defenders better. A purple team exercise is a collaborative approach where the red team and the blue team work together to test, measure, and improve the organization's security controls in real-time. This lesson explores this powerful, collaborative security methodology.",
                "sections": [
                    {
                        "title": "What is a Purple Team?",
                        "content": "<p>A purple team is not a separate team, but a collaborative exercise. It's the process of bringing the red team (the attackers) and the blue team (the defenders) together in a single, open workshop.</p><p>Instead of the red team operating in secret, they will announce their actions. The red teamer will say, 'I am now going to execute TTP T1059.001, PowerShell, on this host'. The blue team then checks their monitoring tools. Did they see it? Did an alert fire? If not, the two teams work together to analyze why it was missed and to write a new detection rule. They then re-run the test to validate that the new detection works. This process is repeated for a list of specific TTPs.</p>",
                        "image": "https://i.imgur.com/o3V8Z7j.png"
                    },
                    {
                        "title": "Goals of a Purple Team Exercise",
                        "content": "<ul><li><strong>Improve Detections:</strong> The primary goal is to find gaps in the security monitoring and to write and validate new detection rules.</li><li><strong>Train the Blue Team:</strong> It's an incredible training opportunity for the blue team, as they get to see exactly what an attack looks like in their own tools and data.</li><li><strong>Foster Collaboration:</strong> It breaks down the silos between the offensive and defensive teams and encourages a more collaborative security culture.</li><li><strong>Measure Performance:</strong> It provides a data-driven way to measure the performance of specific security controls against specific threats.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "Purple_Team_Engagement_Plan.docx",
                    "language": "markdown",
                    "code": "# Purple Team Engagement Plan: Q1\n\n**Objective:** Test and improve detection coverage for the top 5 TTPs used by the FIN7 threat actor.\n\n**Scope:** Corporate user workstations.\n\n**Teams:**\n- Red Team: Alex Chen\n- Blue Team: Jane Doe (SOC), John Smith (Detection Engineering)\n\n**TTPs to Test:**\n1.  **T1566.001 - Spearphishing Attachment:** Red Team will send a test email. Blue Team will confirm it was blocked/alerted on by the email gateway.\n2.  **T1059.001 - PowerShell:** Red Team will execute a PowerShell download cradle. Blue/Detection team will verify the EDR alert and the SIEM rule.\n3.  **T1003.001 - LSASS Memory Dumping:** Red Team will execute a LotL LSASS dump. Blue/Detection team will verify the EDR alert.\n4.  **...**\n5.  **...**"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary characteristic of a purple team exercise?",
                        "options": [
                            "It is a secret, adversarial operation.",
                            "It is a collaborative exercise where the red and blue teams work together openly.",
                            "It is performed by a third-party team.",
                            "It only focuses on penetration testing."
                        ],
                        "correct": 1,
                        "explanation": "Purple teaming is about collaboration, not adversarial secrecy. The goal is to create a tight feedback loop between the attackers and defenders to improve security."
                    },
                    {
                        "id": 2,
                        "question": "What is a major goal of a purple team exercise?",
                        "options": [
                            "To achieve Domain Admin without being detected.",
                            "To test and improve the blue team's detection and response capabilities for specific TTPs.",
                            "To find as many vulnerabilities as possible.",
                            "To write a formal report for executives."
                        ],
                        "correct": 1,
                        "explanation": "A purple team exercise is a highly focused, data-driven effort to measure and improve detection coverage. The output is not a report, but better security controls."
                    },
                    {
                        "id": 3,
                        "question": "What happens during a purple team exercise if the blue team fails to detect a technique executed by the red team?",
                        "options": [
                            "The exercise ends.",
                            "The red team wins.",
                            "The two teams work together to figure out why it was missed and to build and validate a new detection rule.",
                            "The red team moves on to the next technique."
                        ],
                        "correct": 2,
                        "explanation": "This is the core of the purple team feedback loop. A missed detection is not a failure, but an opportunity to immediately improve the organization's defenses in a measurable way."
                    }
                ]
            }
        },
        {
            "id": "lesson-25",
            "title": "Alert Enrichment and Automation",
            "duration": "75 min",
            "objectives": [
                "Understand the concept of alert enrichment",
                "Learn how SOAR platforms can be used for automation",
                "Explore how to automatically enrich alerts with threat intelligence and asset data",
                "Design a simple playbook to automate an enrichment task"
            ],
            "content": {
                "overview": "A raw alert from a SIEM often lacks the context a SOC analyst needs to make a quick decision. Alert enrichment is the process of automatically adding that context. This lesson covers how to use SOAR platforms and scripts to automate the enrichment process, saving analysts valuable time and enabling faster responses.",
                "sections": [
                    {
                        "title": "The Need for Enrichment",
                        "content": "<p>Imagine a raw alert fires: 'Suspicious PowerShell on host WEB-SRV01'. An analyst's first questions will be:</p><ul><li>What is WEB-SRV01? Is it a critical production server or a test machine?</li><li>Who is the owner of this server?</li><li>What is the full command line that was executed?</li><li>Has this command been seen before?</li></ul><p>Answering these questions manually can take a lot of time. <strong>Alert enrichment</strong> is the process of automatically answering these questions and adding the information directly to the alert before the analyst even sees it.</p>",
                        "image": "https://i.imgur.com/kYq3Q6k.png"
                    },
                    {
                        "title": "SOAR Platforms and Playbooks",
                        "content": "<p><strong>Security Orchestration, Automation, and Response (SOAR)</strong> platforms are the primary tool for this. A SOAR platform can ingest new alerts from the SIEM and then execute a <strong>playbook</strong>.</p><p>A playbook is a workflow that defines a series of automated enrichment and response actions. For an IP address alert, a playbook might automatically:<ul><li>Query a threat intelligence provider (like VirusTotal) for the IP's reputation.</li><li>Query the organization's asset inventory to see what host the IP belongs to.</li><li>Query the Active Directory logs to see which user was logged into that host at the time.</li></ul>The playbook then adds all of this context to the original alert and presents it to the analyst.</p>",
                        "image": "https://images.unsplash.com/photo-1510915228340-29c85a43dcfe?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "SOAR_Playbook_to_Enrich_IP_Address_Alerts.json",
                    "language": "json",
                    "code": "{\n  \"name\": \"IP Address Enrichment Playbook\",\n  \"trigger\": {\n    \"type\": \"SIEM Alert\",\n    \"condition\": \"alert.name CONTAINS 'Suspicious IP'\"\n  },\n  \"steps\": [\n    {\n      \"name\": \"Extract IP Address\",\n      \"action\": \"extract_field\",\n      \"parameters\": {\n        \"field\": \"source.ip\"\n      }\n    },\n    {\n      \"name\": \"Query VirusTotal\",\n      \"action\": \"virustotal.ip_reputation\",\n      \"parameters\": {\n        \"ip\": \"{{steps.1.output.ip}}\"\n      }\n    },\n    {\n      \"name\": \"Update Alert\",\n      \"action\": \"add_comment_to_alert\",\n      \"parameters\": {\n        \"comment\": \"VirusTotal Reputation: {{steps.2.output.reputation}}\"\n      }\n    },\n    {\n      \"name\": \"Assign to Analyst\",\n      \"action\": \"assign_ticket\",\n      \"parameters\": {\n        \"analyst\": \"tier1_soc\"\n      }\n    }\n  ]\n}"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary goal of alert enrichment?",
                        "options": [
                            "To generate more alerts.",
                            "To automatically add contextual information to a raw alert to help an analyst make a faster, more informed decision.",
                            "To block the suspicious activity.",
                            "To delete the alert."
                        ],
                        "correct": 1,
                        "explanation": "Enrichment is all about adding context. It saves the analyst from having to manually look up information in five different tools, which significantly speeds up the triage process."
                    },
                    {
                        "id": 2,
                        "question": "What is a SOAR 'playbook'?",
                        "options": [
                            "A list of all the SOC analysts.",
                            "A document that describes a security policy.",
                            "A workflow that defines a series of automated actions to be taken in response to an alert.",
                            "A type of security alert."
                        ],
                        "correct": 2,
                        "explanation": "A playbook is the core of a SOAR platform. It's the codified, automated version of an organization's standard operating procedures for incident response."
                    },
                    {
                        "id": 3,
                        "question": "Automatically querying a threat intelligence provider like VirusTotal for the reputation of an IP address in an alert is an example of what?",
                        "options": [
                            "Detection",
                            "Prevention",
                            "Enrichment",
                            "Collection"
                        ],
                        "correct": 2,
                        "explanation": "This is a classic enrichment action. The raw alert just has an IP address; the enrichment adds the crucial context of whether that IP is known to be malicious, which is vital for the analyst."
                    }
                ]
            }
        },
        {
            "id": "lesson-26",
            "title": "The Feedback Loop: Learning from Incidents",
            "duration": "75 min",
            "objectives": [
                "Understand that a missed detection is a detection opportunity",
                "Learn how to perform a post-incident review to find detection gaps",
                "Analyze how to translate a gap analysis into new detection requirements",
                "Explore the importance of a blameless post-mortem culture",
                "Practice analyzing a simulated incident report to find new detection ideas"
            ],
            "content": {
                "overview": "Every security incident is a learning opportunity. This lesson covers the most critical part of the entire security lifecycle: the feedback loop. We will explore how to analyze a security incident or a red team finding to identify the gaps in visibility and detection, and how to turn those lessons learned into new, improved detection rules.",
                "sections": [
                    {
                        "title": "The Post-Incident Review",
                        "content": "<p>After an incident has been contained and remediated, the work is not over. The most important phase is the <strong>post-incident review</strong> or post-mortem.</p><p>The goal is to answer a few key questions:<ul><li>How did the attacker get in?</li><li>What was the full timeline of their actions?</li><li>What were our 'detection opportunities'? At which points in the attack chain *could* we have detected them?</li><li>Why did our existing detections fail? Was it a lack of visibility (no logs), or a flaw in our detection logic?</li></ul></p>",
                        "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The Feedback Loop to Detection Engineering",
                        "content": "<p>The output of the post-incident review is a set of specific, actionable requirements that are fed directly back into the detection development lifecycle. Each missed detection becomes the hypothesis for a new detection rule.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Never Waste a Crisis</strong></div><p>This feedback loop is the engine of a mature detection program. A red team finding or a real security incident is not a failure; it is a gift of valuable, free data about the true weaknesses of your program. A mature organization uses this data to systematically find and fix its detection gaps, ensuring that the same attack can never succeed in the same way again.</p></div>",
                        "image": "https://i.imgur.com/kYq3Q6k.png"
                    },
                    {
                        "title": "Blameless Post-Mortems",
                        "content": "<p>For this process to work, the organization must have a <strong>blameless post-mortem</strong> culture. The goal of the review is to find and fix systemic problems with technology and processes, not to assign blame to individual people. An environment of psychological safety is essential for honest and effective incident analysis.</p>",
                        "image": "https://images.unsplash.com/photo-1573495627361-ab2d_50a_a86a?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "Incident_Post-Mortem_Detection_Gap_Analysis.md",
                    "language": "markdown",
                    "code": "# Post-Mortem: Incident IR-2023-042\n\n**Summary:** Attacker gained access via phishing, dumped credentials from LSASS, and used Pass-the-Hash to move to the domain controller.\n\n**Detection Gap Analysis:**\n\n| Attack Stage      | Existing Detection | Result | Gap Analysis                                     | New Detection Requirement                        |\n|-------------------|--------------------|--------|--------------------------------------------------|--------------------------------------------------|\n| Initial Access    | Email Gateway      | FAILED | User clicked a link from a new, uncategorized domain. | Tune gateway to be more aggressive on new domains. |\n| Credential Access | EDR LSASS Rule     | FAILED | Attacker used a LotL technique (`comsvcs.dll`) that was not covered. | **Create new Sigma rule for `comsvcs.dll` LSASS dump.** |\n| Lateral Movement  | PtH Detection Rule | FAILED | Rule was only looking for local admin accounts. Attacker used a domain account hash. | **Widen the logic of the PtH rule to include domain accounts.** |"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary goal of a post-incident review?",
                        "options": [
                            "To find someone to blame for the incident.",
                            "To identify the root cause of the incident and the gaps in detection and prevention that allowed it to succeed.",
                            "To write a report for the public.",
                            "To end the incident response process."
                        ],
                        "correct": 1,
                        "explanation": "The post-mortem is a learning process. Its purpose is to perform a root cause analysis to ensure that the same type of incident can be prevented or, at a minimum, detected much more quickly in the future."
                    },
                    {
                        "id": 2,
                        "question": "What is the 'feedback loop' in this context?",
                        "options": [
                            "A network problem.",
                            "The process of taking the findings from an incident or red team report and using them to create new, improved detection rules.",
                            "A way to communicate with the attacker.",
                            "A type of log."
                        ],
                        "correct": 1,
                        "explanation": "This feedback loop is what drives continuous improvement. The findings from real-world attacks (simulated or real) are the best possible source of requirements for what the detection engineering team should build next."
                    },
                    {
                        "id": 3,
                        "question": "What is a 'blameless post-mortem'?",
                        "options": [
                            "A review where no one is held accountable.",
                            "A review culture that focuses on identifying and fixing systemic process and technology flaws, rather than assigning blame to individuals.",
                            "A review that does not result in any changes.",
                            "A review that is not documented."
                        ],
                        "correct": 1,
                        "explanation": "A blameless culture is essential for effective incident response. When people are not afraid of being punished, they are more likely to be open and honest during the review, which leads to a more accurate understanding of the root cause and better long-term solutions."
                    }
                ]
            }
        },
        {
            "id": "lesson-27",
            "title": "Deception Technology",
            "duration": "75 min",
            "objectives": [
                "Understand the principles of deception technology",
                "Learn the function of honeypots, honeytokens, and canary files",
                "Explore how to use deception to create high-fidelity, low-noise alerts",
                "Practice deploying a canary token in a file share"
            ],
            "content": {
                "overview": "Deception technology is a proactive defense strategy that turns the tables on the attacker. Instead of looking for the attacker's tools, we create traps and decoys that an attacker is likely to interact with. This lesson covers the core concepts of deception, from classic honeypots to modern honeytokens and canaries.",
                "sections": [
                    {
                        "title": "Honeypots and Honeytokens",
                        "content": "<p>The core idea of deception is to create attractive, fake assets that no legitimate user should ever interact with. Any interaction with these decoys is, by definition, suspicious.</p><ul><li><strong>Honeypot:</strong> A decoy server or service that is designed to look vulnerable and attract attackers. It is heavily monitored to study the attacker's TTPs.</li><li><strong>Honeytoken:</strong> A decoy piece of data. This could be a fake user account in Active Directory (a 'honeyuser'), a fake API key checked into a code repository, or a fake AWS access key. If this token is ever used, it triggers a high-priority alert.</li><li><strong>Canary File:</strong> A decoy document with an enticing name (e.g., `passwords.xlsx`) that is placed on a file share. The file is instrumented to 'call home' to a server when it is opened, immediately alerting the defenders that an attacker is browsing their files.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1588196749107-15d08b4be52a?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The Value of Deception",
                        "content": "<p>Deception technology provides one of the most valuable types of alerts in cybersecurity.</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>High-Fidelity, Low-Noise</strong></div><p>A detection rule for PowerShell might have thousands of legitimate triggers per day. But an alert that says 'Someone just opened the fake `passwords.xlsx` file on the finance share' is a <strong>high-fidelity</strong> alert. There is almost no legitimate reason for this to happen. This means the alert has an extremely low false positive rate, allowing the SOC to respond with speed and confidence.</p></div>",
                        "image": "https://i.imgur.com/kYq3Q6k.png"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "Creating_a_Honeytoken_in_Active_Directory.ps1",
                    "language": "powershell",
                    "code": "# This PowerShell script creates a fake 'honeyuser' in Active Directory.\n\n# 1. Create a new user account with a tempting name.\n$Password = ConvertTo-SecureString \"Password123!\" -AsPlainText -Force\nNew-ADUser -Name \"SQL-Admin-SVC\" -AccountPassword $Password -Enabled $true\n\n# 2. Add the fake user to a sensitive-sounding but unprivileged group.\nAdd-ADGroupMember -Identity \"Database Admins - Tier 2\" -Members \"SQL-Admin-SVC\"\n\n# 3. Set up the detection.\n# The detection engineer will now create a very simple but high-fidelity SIEM rule:\n# 'ALERT if logon_user = \"SQL-Admin-SVC\"'\n\n# No legitimate process should ever use this account. Any logon attempt is an\n# immediate indicator that an attacker is performing reconnaissance in AD."
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary goal of deception technology?",
                        "options": [
                            "To block all attacks.",
                            "To create decoy assets that no legitimate user should interact with, in order to get a high-fidelity signal of an attacker's presence.",
                            "To make the network more complex.",
                            "To replace the need for a firewall."
                        ],
                        "correct": 1,
                        "explanation": "Deception is about setting traps. By creating attractive but fake targets, we can get a very reliable alert as soon as an attacker starts to poke around."
                    },
                    {
                        "id": 2,
                        "question": "A fake AWS access key that is intentionally placed in a public source code repository is an example of what?",
                        "options": [
                            "A honeypot",
                            "A canary file",
                            "A honeytoken",
                            "A misconfiguration"
                        ],
                        "correct": 2,
                        "explanation": "A honeytoken is a decoy piece of data, in this case, a credential. The detection is simple: alert if this key is ever used, because no one should ever be using it."
                    },
                    {
                        "id": 3,
                        "question": "What is the main benefit of alerts generated by deception technology?",
                        "options": [
                            "They are very high-volume.",
                            "They are often very high-fidelity (low false positive rate).",
                            "They are easy to ignore.",
                            "They provide a lot of technical detail."
                        ],
                        "correct": 1,
                        "explanation": "Because legitimate users have no reason to interact with the decoy assets, almost every alert from a deception system is a true positive. This allows the SOC to respond with a high degree of confidence."
                    }
                ]
            }
        },
        {
            "id": "lesson-28",
            "title": "User and Entity Behavior Analytics (UEBA)",
            "duration": "75 min",
            "objectives": [
                "Understand the principles of User and Entity Behavior Analytics (UEBA)",
                "Learn how UEBA platforms use machine learning to baseline behavior",
                "Analyze how UEBA can automatically surface risky anomalies",
                "Discuss the role of UEBA in detecting insider threats and compromised accounts"
            ],
            "content": {
                "overview": "User and Entity Behavior Analytics (UEBA) is a category of security tool that uses machine learning and statistical analysis to find the most difficult threats: insider threats and compromised accounts. This lesson explores how UEBA platforms work and their role in a modern detection program.",
                "sections": [
                    {
                        "title": "How UEBA Works",
                        "content": "<p>A UEBA platform ingests a massive amount of data from many different sources (Active Directory logs, VPN logs, EDR data, etc.). It then uses unsupervised machine learning to build a detailed, dynamic <strong>baseline</strong> of normal behavior for every single user and device ('entity') in the organization.</p><p>It then monitors for deviations from this baseline in real-time. Each deviation is assigned a risk score. The platform's real power comes from its ability to automatically correlate multiple, low-risk anomalies into a single, high-risk incident.</p>",
                        "image": "https://i.imgur.com/kYq3Q6k.png"
                    },
                    {
                        "title": "Detecting Compromised Accounts and Insider Threats",
                        "content": "<p>UEBA is particularly effective at finding threats where the attacker is using legitimate credentials.</p><h3>Example Scenarios:</h3><ul><li><strong>Compromised Account:</strong> An attacker steals a user's password and logs in. The UEBA system detects that the login is from a new, anomalous country, at an unusual time, and that the user is now accessing servers they have never touched before. The system will dramatically increase this user's risk score and generate an alert.</li><li><strong>Insider Threat:</strong> A disgruntled employee is planning to leave the company. In their last week, they suddenly start downloading an unusually large volume of files from the company's SharePoint. The UEBA system's data exfiltration model would detect this as a major deviation from their normal behavior.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1573495627361-ab2d_50a_a86a?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "UEBA_Model_Risk_Scoring_Configuration.json",
                    "language": "json",
                    "code": "{\n  \"model\": \"UserLoginAnomaly\",\n  \"features\": [\n    \"user.department\",\n    \"user.role\",\n    \"login.time_of_day_bucket\",\n    \"login.day_of_week\",\n    \"login.source_country\",\n    \"login.source_asn\"\n  ],\n  \"risk_modifiers\": [\n    {\n      \"event\": \"First time user has logged in from this country\",\n      \"risk_score_increase\": 25\n    },\n    {\n      \"event\": \"Login occurs outside of user's normal working hours\",\n      \"risk_score_increase\": 15\n    },\n    {\n      \"event\": \"Login is to a critical server\",\n      \"risk_score_increase\": 30\n    }\n  ]\n}"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the core principle of a UEBA system?",
                        "options": [
                            "To use signatures to find known malware.",
                            "To use machine learning to build a baseline of normal behavior for every user and entity, and then detect risky anomalies.",
                            "To act as a firewall.",
                            "To manage user passwords."
                        ],
                        "correct": 1,
                        "explanation": "UEBA is a form of large-scale, automated anomaly detection. It's designed to find the threats that don't match a known signature but that deviate from a learned pattern of normalcy."
                    },
                    {
                        "id": 2,
                        "question": "UEBA is particularly effective at detecting which two types of threats?",
                        "options": [
                            "Viruses and worms.",
                            "Insider threats and compromised accounts.",
                            "Network scans and denial-of-service attacks.",
                            "Phishing emails and spam."
                        ],
                        "correct": 1,
                        "explanation": "These are the threats where the attacker is using valid credentials. Because the authentication is 'legitimate', the only way to find the threat is to recognize that the *behavior* of the account is anomalous, which is exactly what UEBA is designed to do."
                    },
                    {
                        "id": 3,
                        "question": "How does a UEBA system determine if an activity is risky?",
                        "options": [
                            "It has a hard-coded list of bad activities.",
                            "It compares the activity to the user's own, personal baseline of normal behavior.",
                            "It asks the user if the activity is risky.",
                            "All activities are considered risky."
                        ],
                        "correct": 1,
                        "explanation": "The power of UEBA is its personalization. It learns what is normal *for each specific user*. A software developer accessing the source code repository at 3 AM is normal. A finance employee doing the same thing is a high-risk anomaly."
                    }
                ]
            }
        },
        {
            "id": "lesson-29",
            "title": "Future Trends in Detection Engineering",
            "duration": "60 min",
            "objectives": [
                "Discuss the impact of AI/ML on the future of detection",
                "Learn about the rise of Open-Source security tools (OSDF)",
                "Explore the shift towards detecting threats in Infrastructure-as-Code (IaC)",
                "Analyze the long-term strategic challenges and opportunities"
            ],
            "content": {
                "overview": "The field of detection engineering is constantly evolving to keep pace with the threat landscape and the changes in technology. This lesson looks to the future, exploring the major trends that will shape the next generation of detection, from the deeper integration of AI to the new challenges of securing infrastructure-as-code.",
                "sections": [
                    {
                        "title": "AI and Machine Learning",
                        "content": "<p>The use of AI/ML in detection will move from specialized use cases (like UEBA) to being a core part of the detection engineer's toolkit. SIEM platforms will have more and more built-in, unsupervised machine learning features that can automatically surface anomalies that would be impossible for a human to write a rule for. The role of the detection engineer will be to supervise, tune, and interpret the outputs of these AI systems.</p>",
                        "image": "https://images.unsplash.com/photo-1555949963-aa79dcee981c?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Open-Source Detection and Response",
                        "content": "<p>The future of security is open. The rise of projects like Sigma, Sysmon, and Zeek shows a clear trend towards an <strong>Open Source Detection and Response (OSDR)</strong> stack. This allows the community to collaborate on building and sharing powerful, vendor-agnostic detections and tools, which raises the bar for everyone. The reliance on proprietary, black-box security tools will decrease as open, transparent alternatives become more powerful.</p>",
                        "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Shifting Left: Detecting in Infrastructure-as-Code (IaC)",
                        "content": "<p>The most effective way to handle a threat is to prevent it from ever happening. The future of detection is to 'shift left'âto find vulnerabilities and misconfigurations earlier in the development lifecycle.</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Scanning the Blueprint</strong></div><p>In a modern cloud environment, infrastructure is defined as code (IaC) using tools like Terraform or CloudFormation. The future of cloud security detection is to scan this code *before* it is ever deployed. Tools like `tfsec` or `checkov` can automatically scan Terraform code for security misconfigurations (like a public S3 bucket) and block the deployment. This is the ultimate proactive detection: finding the 'breach' before it even exists.</p></div>",
                        "image": "https://i.imgur.com/3Z4h7k2.png"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "IaC_Security_Scanning_with_Tfsec.sh",
                    "language": "bash",
                    "code": "# Tfsec is an open-source static analysis tool for Terraform code.\n# It can be integrated into a CI/CD pipeline to scan for misconfigurations before deployment.\n\n# Run tfsec on the current directory of Terraform files\ntfsec .\n\n# --- Sample Output ---\n# Result 1: AWS S3 bucket does not have logging enabled\n#   File: s3.tf, Lines: 10-15\n#   Severity: MEDIUM\n#\n# Result 2: AWS IAM policy allows all actions ('*') on all resources ('*').\n#   File: iam.tf, Lines: 5-12\n#   Severity: CRITICAL"
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What does it mean to 'shift left' in the context of security?",
                        "options": [
                            "To move security later in the lifecycle.",
                            "To move security earlier in the lifecycle, such as into the development and deployment phases.",
                            "To focus only on network security.",
                            "To move all infrastructure to the left."
                        ],
                        "correct": 1,
                        "explanation": "'Shifting left' is a core principle of modern DevSecOps. It's about building security in from the beginning, rather than trying to bolt it on at the end. Detecting misconfigurations in IaC code is a prime example."
                    },
                    {
                        "id": 2,
                        "question": "The rise of open-source projects like Sigma, Sysmon, and Zeek points to what future trend?",
                        "options": [
                            "A move towards more expensive, proprietary tools.",
                            "A move towards a more open, collaborative, and vendor-agnostic approach to detection and response (OSDR).",
                            "A decrease in the importance of security.",
                            "A focus only on endpoint security."
                        ],
                        "correct": 1,
                        "explanation": "The OSDR movement is a major trend that empowers the community to build and share their own detection and response capabilities, reducing the reliance on black-box commercial products."
                    },
                    {
                        "id": 3,
                        "question": "What is the primary benefit of scanning Infrastructure-as-Code (IaC) for security issues?",
                        "options": [
                            "It is a detective control.",
                            "It is a preventive control that can find and fix misconfigurations before the vulnerable infrastructure is ever deployed.",
                            "It is a manual process.",
                            "It is not very effective."
                        ],
                        "correct": 1,
                        "explanation": "Scanning IaC is the ultimate proactive detection. It prevents the vulnerability from ever existing in the production environment, which is far more effective than trying to detect its exploitation later."
                    }
                ]
            }
        },
        {
            "id": "lesson-30",
            "title": "Capstone Project: End-to-End Detection",
            "duration": "120 min",
            "objectives": [
                "Apply the full Detection Development Lifecycle to a practical scenario",
                "Research a given threat intelligence report and form a hypothesis",
                "Build and test a high-fidelity detection rule in the lab",
                "Document the rule and the testing process",
                "Present the final detection and its expected value"
            ],
            "content": {
                "overview": "This final lesson is the capstone project, where you will bring together everything you have learned to perform a full, end-to-end detection engineering lifecycle. You will be given a real-world threat intelligence report and will be tasked with researching, building, testing, and documenting a new detection to find the threat.",
                "sections": [
                    {
                        "title": "The Scenario",
                        "content": "<p>Students will be provided with a recent CISA alert or a vendor threat intelligence report describing the TTPs of a specific threat actor. The lab environment will be pre-configured with the necessary log sources.</p><h3>The Task:</h3><p>Your mission is to go through the full Detection Development Lifecycle for one of the TTPs described in the report. You must:</p><ol><li><strong>Hypothesize:</strong> Write a clear hypothesis for how to detect the TTP.</li><li><strong>Develop:</strong> Write a Sigma rule that implements the detection logic.</li><li><strong>Test:</strong> Use Atomic Red Team or another method to simulate the TTP in the lab and prove that your rule fires correctly.</li><li><strong>Tune:</strong> (Simulated) Describe the potential false positives and how you would refine the rule.</li><li><strong>Document:</strong> Create a full documentation page for your new detection.</li></ol>",
                        "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Final Deliverable",
                        "content": "<p>The final deliverable will be a complete 'detection package' submitted as a pull request to a class Git repository. The package must include:</p><ul><li>The final, documented Sigma rule (`.yml` file).</li><li>A markdown file containing your hypothesis, the testing procedure you followed, the evidence (screenshots) of your successful test, and your tuning considerations.</li><li>A brief presentation of your detection to the class, explaining the threat and how your rule works to detect it.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                    }
                ]
            },
            "codeExamples": [
                {
                    "title": "Capstone_Project_Threat_Intel_Brief.md",
                    "language": "markdown",
                    "code": "# Capstone Project Brief\n\n**Threat Intelligence Source:** CISA Alert AA22-277A (File-Tainting and Proxy-Not-Shell)\n\n**Adversary:** Unnamed APT\n\n**TTP for Detection:**\nThe report notes that the adversary uses the `msdt.exe` (Microsoft Support Diagnostic Tool) binary to execute PowerShell code. The command line is `msdt.exe -tab -pcalua -diagcab %LOCALAPPDATA%\\Random.diagcab`.\n\n**Your Mission:**\n1.  Form a hypothesis for detecting this specific abuse of `msdt.exe`.\n2.  Write a Sigma rule for it.\n3.  Figure out how to simulate this behavior in the lab (Note: Atomic Red Team may not have this specific test, you may need to do manual research).\n4.  Test and document your rule.\n5.  Submit your detection package."
                }
            ],
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary purpose of a capstone project in a course like this?",
                        "options": [
                            "To review the content of a single lesson.",
                            "To provide a large, hands-on project that allows a student to apply the knowledge and skills from the entire course.",
                            "To take a final exam.",
                            "To learn a new topic."
                        ],
                        "correct": 1,
                        "explanation": "A capstone project is a culminating experience that integrates all the concepts learned throughout the curriculum into a single, comprehensive, practical project."
                    },
                    {
                        "id": 2,
                        "question": "What is the first step in the capstone project?",
                        "options": [
                            "Writing the code.",
                            "Testing the rule.",
                            "Analyzing the provided threat intelligence report and forming a clear, testable hypothesis.",
                            "Deploying the rule."
                        ],
                        "correct": 2,
                        "explanation": "The entire lifecycle begins with a good hypothesis. The first step is always to thoroughly understand the adversary behavior you are trying to detect, based on the provided intelligence."
                    },
                    {
                        "id": 3,
                        "question": "What is the final deliverable for the capstone project?",
                        "options": [
                            "Just the Sigma rule.",
                            "A presentation.",
                            "A complete 'detection package', including the documented rule, the testing evidence, and the hypothesis.",
                            "A screenshot of the alert."
                        ],
                        "correct": 2,
                        "explanation": "The capstone simulates a real-world professional task. A complete package includes not just the code, but the documentation and evidence that are essential for peer review, deployment, and future maintenance."
                    }
                ]
            }
        }
    ]
}
      // =====================================================
      // GLOBAL VARIABLES
      // =====================================================
      let currentUser = null;
      let currentLessonIndex = 0;
      let courseProgress = {};
      let userStats = {};
      let quizState = {
        currentQuestion: 0,
        answers: [],
        score: 0,
        isComplete: false,
        timeStarted: null,
        timeCompleted: null,
        currentQuestionIndex: 0,
      };

      // Enhanced session tracking
      let courseSession = {
        startTime: null,
        totalStudyTime: 0,
        lessonsStarted: 0,
        lessonsCompleted: 0,
        pageLoadTime: new Date(),
        lastActive: new Date(),
        interactions: 0,
        completedSections: [],
        totalTime: 0,
        interactionCount: 0,
        lastActivityTime: new Date(),
      };

      // Music Player Variables
      let audioPlayer = new Audio();

      // Achievement notification system
      let notificationQueue = [];
      let isShowingNotification = false;

      // =====================================================
      // INITIALIZATION
      // =====================================================
      document.addEventListener("DOMContentLoaded", async () => {
        try {
          showLoadingScreen();
          await checkAuth();

          if (currentUser) {
            // Initialize session tracking
            startCourseSession();

            // Load course data and progress
            await loadCourseData();
            await loadUserProfile();
            await loadProgress();

            // Initialize UI
            initializeEventListeners();
            renderSidebar();
            loadLesson(currentLessonIndex);

            // Initialize additional features
            initMusicPlayer();
            addMusicIndicator();
            initializeActivityTracking();

            hideLoadingScreen();
          } else {
            openAuthModal();
          }
        } catch (error) {
          console.error("Error initializing course:", error);
          hideLoadingScreen();
          showToast("Failed to initialize course system", "error");
        }
      });

      // =====================================================
      // AUTHENTICATION SYSTEM
      // =====================================================
      async function checkAuth() {
        try {
          const {
            data: { session },
            error,
          } = await supabase.auth.getSession();

          if (error) {
            console.error("Auth error:", error);
            currentUser = null;
            openAuthModal();
            return;
          }

          if (!session) {
            currentUser = null;
            openAuthModal();
            return;
          }

          currentUser = session.user;
          updateUIWithUser();
        } catch (error) {
          console.error("Error checking auth:", error);
          currentUser = null;
          openAuthModal();
        }
      }

      function updateUIWithUser() {
        if (!currentUser) return;

        const name =
          currentUser.user_metadata?.full_name ||
          currentUser.email.split("@")[0];
        const userElements = document.querySelectorAll("[data-user-name]");
        userElements.forEach((el) => (el.textContent = name));
      }

      // =====================================================
      // USER PROFILE & STATS MANAGEMENT
      // =====================================================
      async function loadUserProfile() {
        try {
          // ð Step 1: Try to fetch existing profile
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("*")
            .eq("id", currentUser.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (!profile) {
            // ð Step 2: Create new profile if missing
            await createUserProfile();
          } else {
            // â Step 3: Use existing profile
            userStats = profile;
            await updateLastActivity();
          }
        } catch (error) {
          console.error("â Error loading user profile:", error);
          showToast("Failed to load user profile", "error");
        }
      }
      async function createUserProfile() {
        try {
          const newProfile = {
            id: currentUser.id,
            full_name: currentUser.user_metadata?.full_name || "",
            email: currentUser.email,
            level: "Script Kiddie",
            total_points: 0,
            completed_courses: 0,
            current_streak: 0,
            total_certificates: 0,
            total_achievements: 0,
            sections_visited: 0,
            bonus_points: 0,
            in_progress_courses: 0,
            settings_changed: 0,
            midnight_sessions: 0,
            early_sessions: 0,
            weekend_sessions: 0,
            last_activity: new Date().toISOString(),
            created_at: new Date().toISOString(),
          };

          const { error } = await supabase
            .from("profiles")
            .insert([newProfile]);

          if (!error) {
            userStats = newProfile;
            // Award first login achievement
            setTimeout(() => checkAndUnlockAchievement("first_login"), 1000);
          }
        } catch (error) {
          console.error("Error creating user profile:", error);
        }
      }

      async function updateLastActivity() {
        try {
          const now = new Date();

          // Update activity tracking
          courseSession.lastActivityTime = now;

          // Update database
          await supabase
            .from("profiles")
            .update({
              last_activity: now.toISOString(),
            })
            .eq("id", currentUser.id);

          // Check time-based achievements
          await checkTimeBasedAchievements(now);
        } catch (error) {
          console.error("Error updating last activity:", error);
        }
      }

      // =====================================================
      // COURSE SESSION MANAGEMENT
      // =====================================================
      function startCourseSession() {
        courseSession.startTime = new Date();
        courseSession.pageLoadTime = new Date();

        logUserActivity("course_session_start", {
          course_id: COURSE_DATA.id,
          course_title: COURSE_DATA.title,
          user_agent: navigator.userAgent,
          screen_resolution: `${screen.width}x${screen.height}`,
        });

        // Check daily streak
        checkDailyStreak();
      }

      function initializeActivityTracking() {
        // Track page focus/blur for accurate study time
        document.addEventListener("visibilitychange", handleVisibilityChange);

        // Track user interactions
        ["click", "keydown", "scroll", "mousemove"].forEach((event) => {
          document.addEventListener(event, trackUserInteraction, {
            passive: true,
          });
        });

        // Periodic activity updates
        setInterval(updateStudyTime, 60000); // Every minute

        // Save session data before page unload
        window.addEventListener("beforeunload", saveSessionData);
      }

      function handleVisibilityChange() {
        if (document.hidden) {
          courseSession.lastActivityTime = new Date();
        } else {
          // Page became visible again - update activity
          updateLastActivity();
        }
      }

      function trackUserInteraction() {
        courseSession.interactionCount++;
        courseSession.lastActivityTime = new Date();

        // Throttle activity updates
        if (courseSession.interactionCount % 50 === 0) {
          updateLastActivity();
        }
      }

      function updateStudyTime() {
        if (!courseSession.startTime || document.hidden) return;

        const now = new Date();
        const sessionDuration = now - courseSession.startTime;
        courseSession.totalStudyTime = Math.floor(sessionDuration / 1000 / 60); // in minutes

        // Update progress with study time
        saveProgress();
      }

      function saveSessionData() {
        if (!currentUser || !courseSession.startTime) return;

        const sessionData = {
          user_id: currentUser.id,
          course_id: COURSE_DATA.id,
          session_duration: courseSession.totalStudyTime,
          lessons_viewed: courseSession.lessonsStarted,
          lessons_completed: courseSession.lessonsCompleted,
          interactions: courseSession.interactionCount,
          session_date: courseSession.startTime.toISOString().split("T")[0],
        };

        // Store in localStorage as backup
        localStorage.setItem(
          "course_session_backup",
          JSON.stringify(sessionData)
        );

        // Try to save to database
        logUserActivity("course_session_end", sessionData);
      }

      // =====================================================
      // COURSE DATA & PROGRESS MANAGEMENT
      // =====================================================
      async function loadCourseData() {
        try {
          // Update course info in UI
          document.getElementById("courseTitle").textContent =
            COURSE_DATA.title;
          document.getElementById("totalLessons").textContent =
            COURSE_DATA.lessons.length;

          // Log course access
          logUserActivity("course_access", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
          });
        } catch (error) {
          console.error("Error loading course data:", error);
        }
      }

      async function loadProgress() {
        try {
          // Get existing progress from database
          const { data, error } = await supabase
            .from("course_progress")
            .select("*")
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (data) {
            courseProgress = JSON.parse(data.lesson_progress || "{}");
            currentLessonIndex = data.current_lesson || 0;

            // Update session tracking
            courseSession.lessonsStarted = Object.keys(courseProgress).length;
            courseSession.lessonsCompleted = Object.values(
              courseProgress
            ).filter((p) => p.completed).length;
          } else {
            // Initialize new progress
            courseProgress = {};
            currentLessonIndex = 0;
            await saveProgress();

            // Award first course start achievement
            await checkAndUnlockAchievement("first_course_start");
          }

          updateProgressDisplay();
        } catch (error) {
          console.error("Error loading progress:", error);
          showToast("Failed to load progress", "error");
        }
      }

      async function saveProgress() {
        try {
          if (!currentUser) return;

          const now = new Date();
          const progressData = {
            user_id: currentUser.id,
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            current_lesson: currentLessonIndex,
            lesson_progress: JSON.stringify(courseProgress),
            progress: calculateOverallProgress(),
            lessons_completed: getCompletedLessonsCount(),
            lessons_started: Object.keys(courseProgress).length,
            study_time_minutes: courseSession.totalStudyTime,
            last_accessed: now.toISOString(),
            updated_at: now.toISOString(),
          };

          // Upsert progress
          const { error } = await supabase
            .from("course_progress")
            .upsert([progressData]);

          if (error) throw error;

          // Update user stats
          await updateUserStats();

          updateProgressDisplay();
        } catch (error) {
          console.error("Error saving progress:", error);
          showToast("Failed to save progress", "error");
        }
      }

      async function updateUserStats() {
        try {
          // Get all course progress for this user
          const { data: allProgress, error } = await supabase
            .from("course_progress")
            .select("progress, course_id, study_time_minutes")
            .eq("user_id", currentUser.id);

          if (error) throw error;

          // Calculate stats
          const completedCourses =
            allProgress?.filter((p) => p.progress >= 100).length || 0;
          const inProgressCourses =
            allProgress?.filter((p) => p.progress > 0 && p.progress < 100)
              .length || 0;
          const totalStudyTime =
            allProgress?.reduce(
              (sum, p) => sum + (p.study_time_minutes || 0),
              0
            ) || 0;

          // Calculate points (500 per completed course + achievement points)
          const coursePoints = completedCourses * 500;
          const bonusPoints = userStats.bonus_points || 0;
          const totalPoints = coursePoints + bonusPoints;

          // Update profile
          const updateData = {
            completed_courses: completedCourses,
            in_progress_courses: inProgressCourses,
            total_points: totalPoints,
            total_study_time: totalStudyTime,
            last_activity: new Date().toISOString(),
          };

          const { error: updateError } = await supabase
            .from("profiles")
            .update(updateData)
            .eq("id", currentUser.id);

          if (updateError) throw updateError;

          // Update local stats
          Object.assign(userStats, updateData);
        } catch (error) {
          console.error("Error updating user stats:", error);
        }
      }

      function calculateOverallProgress() {
        const completedLessons = getCompletedLessonsCount();
        return Math.round(
          (completedLessons / COURSE_DATA.lessons.length) * 100
        );
      }

      function getCompletedLessonsCount() {
        return Object.values(courseProgress).filter(
          (lesson) => lesson.completed
        ).length;
      }

      function updateProgressDisplay() {
        const completedCount = getCompletedLessonsCount();
        const progressPercent = calculateOverallProgress();

        // Update UI elements
        const elements = {
          completedLessons: completedCount,
          courseProgressPercent: `${progressPercent}%`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });

        // Update progress bar
        const progressBar = document.getElementById("courseProgressFill");
        if (progressBar) progressBar.style.width = `${progressPercent}%`;
      }

      // =====================================================
      // LESSON MANAGEMENT
      // =====================================================
      function loadLesson(index) {
        if (index < 0 || index >= COURSE_DATA.lessons.length) return;

        const lesson = COURSE_DATA.lessons[index];
        currentLessonIndex = index;

        // Mark lesson as started and track activity
        if (!courseProgress[lesson.id]) {
          courseProgress[lesson.id] = {
            started: true,
            completed: false,
            startedAt: new Date().toISOString(),
            timeSpent: 0,
          };

          courseSession.lessonsStarted++;
          saveProgress();

          // Log lesson start
          logUserActivity("lesson_start", {
            lesson_id: lesson.id,
            lesson_title: lesson.title,
            lesson_index: index,
          });
        }

        // Update lesson start time for time tracking
        courseProgress[lesson.id].currentSessionStart = new Date();

        // Update sidebar and navigation
        renderSidebar();
        updateNavigationButtons();

        // Update header info
        updateLessonHeader(lesson, index);

        // Render lesson content
        renderLessonContent(lesson);

        // Smooth scroll and animations
        window.scrollTo({ top: 0, behavior: "smooth" });
        document.getElementById("contentBody").scrollTop = 0;

        const contentBody = document.getElementById("contentBody");
        contentBody.classList.add("fade-in");
        setTimeout(() => contentBody.classList.remove("fade-in"), 500);

        // Check lesson-based achievements
        checkLessonAchievements(index + 1);
      }

      function updateLessonHeader(lesson, index) {
        const elements = {
          currentLessonNumber: index + 1,
          currentLessonTitle: lesson.title,
          navInfo: `Lesson ${index + 1} of ${COURSE_DATA.lessons.length}`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });
      }

      function renderSidebar() {
        const lessonNav = document.getElementById("lessonNav");
        if (!lessonNav) return;

        lessonNav.innerHTML = "";

        COURSE_DATA.lessons.forEach((lesson, index) => {
          const lessonItem = document.createElement("div");
          lessonItem.className = "lesson-item";

          // Determine lesson status
          const lessonProgress = courseProgress[lesson.id];
          const isCompleted = lessonProgress?.completed || false;
          const isInProgress = lessonProgress?.started || false;
          const isLocked = !isCompleted && !canAccessLesson(index);
          const isActive = index === currentLessonIndex;

          // Apply status classes
          if (isCompleted) lessonItem.classList.add("completed");
          if (isLocked) lessonItem.classList.add("locked");
          if (isActive) lessonItem.classList.add("active");

          // Determine status display
          let statusClass = "not-started";
          let statusIcon = index + 1;

          if (isCompleted) {
            statusClass = "completed";
            statusIcon = "â";
          } else if (isInProgress) {
            statusClass = "in-progress";
            statusIcon = "â";
          }

          // Create lesson item HTML
          lessonItem.innerHTML = `
            <div class="lesson-status ${statusClass}">${statusIcon}</div>
            <div class="lesson-info">
                <div class="lesson-title">${lesson.title}</div>
                <div class="lesson-meta">
                    ${
                      isCompleted
                        ? "Completed"
                        : isInProgress
                        ? "In Progress"
                        : isLocked
                        ? "Locked"
                        : "Not Started"
                    }
                </div>
            </div>
            <div class="lesson-duration">${lesson.duration}</div>
        `;

          // Add click handler if not locked
          if (!isLocked) {
            lessonItem.addEventListener("click", () => {
              if (index !== currentLessonIndex) {
                // Track lesson time before switching
                trackLessonTime();

                currentLessonIndex = index;
                loadLesson(index);
                closeSidebar();
              }
            });
          }

          lessonNav.appendChild(lessonItem);
        });
      }

      function canAccessLesson(index) {
        if (index === 0) return true; // First lesson always accessible

        // Can access if previous lesson is completed
        const previousLessonId = COURSE_DATA.lessons[index - 1].id;
        return courseProgress[previousLessonId]?.completed || false;
      }

      function trackLessonTime() {
        const currentLesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonProgress = courseProgress[currentLesson.id];

        if (lessonProgress?.currentSessionStart) {
          const sessionTime = Math.floor(
            (new Date() - new Date(lessonProgress.currentSessionStart)) /
              1000 /
              60
          );
          lessonProgress.timeSpent =
            (lessonProgress.timeSpent || 0) + sessionTime;
          delete lessonProgress.currentSessionStart;
        }
      }

      // =====================================================
      // LESSON CONTENT RENDERING
      // =====================================================
      function renderLessonContent(lesson) {
        const contentContainer = document.getElementById("lessonContent");
        if (!contentContainer) return;

        let contentHTML = `
        <div class="content-section">
            <h2>Learning Objectives</h2>
            <ul>
                ${lesson.objectives.map((obj) => `<li>${obj}</li>`).join("")}
            </ul>
        </div>
        
        <div class="content-section">
            <h2>Overview</h2>
            <p>${lesson.content.overview}</p>
        </div>
    `;

        // Render content sections
        lesson.content.sections.forEach((section) => {
          contentHTML += `
            <div class="content-section">
                <h2>${section.title}</h2>
                ${section.content}
                ${
                  section.image
                    ? `<img src="${section.image}" alt="${section.title}" class="content-image" loading="lazy">`
                    : ""
                }
            </div>
        `;
        });

        // Render code examples
        if (
          lesson.content.codeExamples &&
          lesson.content.codeExamples.length > 0
        ) {
          contentHTML += `<div class="content-section"><h2>Code Examples</h2></div>`;

          lesson.content.codeExamples.forEach((example, index) => {
            const codeId = `code-${lesson.id}-${index}`;
            contentHTML += `
                <div class="code-section">
                    <div class="code-header">
                        <span class="code-title">${example.title}</span>
                        <button class="copy-btn" onclick="copyCode('${codeId}')">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <pre class="code-block"><code id="${codeId}" class="language-${
              example.language
            }">${escapeHtml(example.code)}</code></pre>
                </div>
            `;
          });
        }

        // Render quiz
        contentHTML += renderQuiz(lesson.quiz);

        contentContainer.innerHTML = contentHTML;

        // Highlight code syntax if Prism is available
        setTimeout(() => {
          if (window.Prism) {
            Prism.highlightAll();
          }
        }, 100);
      }

      // =====================================================
      // QUIZ SYSTEM
      // =====================================================
      function renderQuiz(quiz) {
        const currentLessonProgress =
          courseProgress[COURSE_DATA.lessons[currentLessonIndex].id];
        const isCompleted = currentLessonProgress?.completed || false;

        let quizHTML = `
        <div class="quiz-section" id="quizSection">
            <div class="quiz-header">
                <h2 class="quiz-title">
                    <i class="fas fa-clipboard-check"></i>
                    Knowledge Check
                </h2>
                <p class="quiz-info">
                    Complete this quiz with ${quiz.passingScore}% or higher to unlock the next lesson.
                </p>
            </div>
    `;

        if (isCompleted) {
          const savedScore = currentLessonProgress.quizScore || 0;
          quizHTML += `
            <div class="quiz-results show">
                <div class="quiz-score pass">${savedScore}%</div>
                <div class="quiz-message">
                    <strong>Lesson Completed!</strong><br>
                    You've successfully passed this lesson's quiz.
                </div>
            </div>
        `;
        } else {
          // Render quiz questions
          quiz.questions.forEach((question, qIndex) => {
            quizHTML += `
                <div class="quiz-question ${
                  qIndex === 0 ? "active" : ""
                }" data-question="${qIndex}">
                    <div class="question-header">
                        <span class="question-number">Question ${
                          qIndex + 1
                        }</span>
                        <span class="question-progress">${qIndex + 1}/${
              quiz.questions.length
            }</span>
                    </div>
                    <div class="question-text">${question.question}</div>
                    <div class="question-options">
                        ${question.options
                          .map(
                            (option, oIndex) => `
                            <div class="option" data-option="${oIndex}" onclick="selectOption(${qIndex}, ${oIndex})">
                                <span class="option-letter">${String.fromCharCode(
                                  65 + oIndex
                                )}</span>
                                <span class="option-text">${option}</span>
                            </div>
                        `
                          )
                          .join("")}
                    </div>
                </div>
            `;
          });

          quizHTML += `
            <div class="quiz-controls">
                <button class="btn btn-secondary" id="prevQuestionBtn" onclick="previousQuestion()" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <div>
                    <button class="btn btn-secondary" id="nextQuestionBtn" onclick="nextQuestion()" disabled>
                        Next
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <button class="btn btn-primary" id="submitQuizBtn" onclick="submitQuiz()" style="display: none;">
                        <i class="fas fa-check"></i>
                        Submit Quiz
                    </button>
                </div>
            </div>

            <div class="quiz-results" id="quizResults">
                <div class="quiz-score" id="quizScore">0%</div>
                <div class="quiz-message" id="quizMessage"></div>
                <div class="quiz-actions">
                    <button class="btn btn-primary" id="continueBtn" onclick="completeLesson()" style="display: none;">
                        <i class="fas fa-arrow-right"></i>
                        Continue to Next Lesson
                    </button>
                    <button class="btn btn-secondary" onclick="retakeQuiz()">
                        <i class="fas fa-redo"></i>
                        Retake Quiz
                    </button>
                </div>
            </div>
        `;
        }

        quizHTML += "</div>";
        return quizHTML;
      }

      // Quiz interaction functions
      function selectOption(questionIndex, optionIndex) {
        // Clear previous selections
        document
          .querySelectorAll(`[data-question="${questionIndex}"] .option`)
          .forEach((opt) => {
            opt.classList.remove("selected");
          });

        // Select current option
        const selectedOption = document.querySelector(
          `[data-question="${questionIndex}"] [data-option="${optionIndex}"]`
        );
        selectedOption.classList.add("selected");

        // Store answer
        quizState.answers[questionIndex] = optionIndex;

        // Update navigation
        const isLastQuestion =
          questionIndex ===
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length - 1;
        if (isLastQuestion) {
          document.getElementById("submitQuizBtn").style.display =
            "inline-flex";
          document.getElementById("nextQuestionBtn").style.display = "none";
        } else {
          document.getElementById("nextQuestionBtn").disabled = false;
        }
      }

      function nextQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const nextQuestionEl = currentQuestionEl.nextElementSibling;

        if (
          nextQuestionEl &&
          nextQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          nextQuestionEl.classList.add("active");
          quizState.currentQuestion++;
          updateQuizNavigation();
        }
      }

      function previousQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const prevQuestionEl = currentQuestionEl.previousElementSibling;

        if (
          prevQuestionEl &&
          prevQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          prevQuestionEl.classList.add("active");
          quizState.currentQuestion--;
          updateQuizNavigation();
        }
      }

      function updateQuizNavigation() {
        const totalQuestions =
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length;
        const prevBtn = document.getElementById("prevQuestionBtn");
        const nextBtn = document.getElementById("nextQuestionBtn");
        const submitBtn = document.getElementById("submitQuizBtn");

        prevBtn.disabled = quizState.currentQuestion === 0;

        const hasAnswer =
          quizState.answers[quizState.currentQuestion] !== undefined;
        const isLastQuestion = quizState.currentQuestion === totalQuestions - 1;

        if (isLastQuestion) {
          nextBtn.style.display = "none";
          submitBtn.style.display = hasAnswer ? "inline-flex" : "none";
        } else {
          nextBtn.style.display = "inline-flex";
          nextBtn.disabled = !hasAnswer;
          submitBtn.style.display = "none";
        }
      }

      async function submitQuiz() {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const quiz = lesson.quiz;
        let correctAnswers = 0;

        // Hide questions and controls
        document
          .querySelectorAll(".quiz-question")
          .forEach((q) => (q.style.display = "none"));
        document.querySelector(".quiz-controls").style.display = "none";

        // Calculate score and highlight answers
        quiz.questions.forEach((question, index) => {
          const userAnswer = quizState.answers[index];
          const correctAnswer = question.correct;
          const isCorrect = userAnswer === correctAnswer;

          if (isCorrect) correctAnswers++;

          // Highlight answers
          const questionEl = document.querySelector(
            `[data-question="${index}"]`
          );
          const options = questionEl.querySelectorAll(".option");

          options[correctAnswer].classList.add("correct");
          if (userAnswer !== correctAnswer && userAnswer !== undefined) {
            options[userAnswer].classList.add("incorrect");
          }
        });

        const score = Math.round(
          (correctAnswers / quiz.questions.length) * 100
        );
        const passed = score >= quiz.passingScore;

        // Update quiz results UI
        const quizScore = document.getElementById("quizScore");
        const quizMessage = document.getElementById("quizMessage");
        const quizActions = document.querySelector(".quiz-actions");

        quizScore.textContent = `${score}%`;
        quizScore.className = `quiz-score ${passed ? "pass" : "fail"}`;

        if (passed) {
          quizMessage.innerHTML = `
            <strong>Congratulations!</strong><br>
            You passed with ${score}%. You can now proceed to the next lesson.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-primary" onclick="completeLesson()">
                <i class="fas fa-arrow-right"></i>
                Continue to Next Lesson
            </button>
        `;

          // Mark lesson as completed
          await markLessonComplete(score);
        } else {
          quizMessage.innerHTML = `
            <strong>Not quite there yet.</strong><br>
            You scored ${score}%. You need ${quiz.passingScore}% to pass. Review the material and try again.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-secondary" onclick="retakeQuiz()">
                <i class="fas fa-redo"></i>
                Retake Quiz
            </button>
        `;
        }

        document.getElementById("quizResults").classList.add("show");

        // Log quiz completion
        logUserActivity("quiz_completed", {
          lesson_id: lesson.id,
          lesson_title: lesson.title,
          score: score,
          passed: passed,
          attempts: (courseProgress[lesson.id]?.quizAttempts || 0) + 1,
        });

        // Scroll to results
        document
          .getElementById("quizResults")
          .scrollIntoView({ behavior: "smooth" });
      }

      function retakeQuiz() {
        // Reset quiz state
        quizState = {
          currentQuestion: 0,
          answers: [],
          score: 0,
          isComplete: false,
        };

        // Track quiz retry
        const lessonId = COURSE_DATA.lessons[currentLessonIndex].id;
        if (!courseProgress[lessonId]) courseProgress[lessonId] = {};
        courseProgress[lessonId].quizAttempts =
          (courseProgress[lessonId].quizAttempts || 0) + 1;

        // Reload lesson content
        loadLesson(currentLessonIndex);

        // Scroll to quiz
        setTimeout(() => {
          document
            .getElementById("quizSection")
            .scrollIntoView({ behavior: "smooth" });
        }, 500);
      }

      async function markLessonComplete(score) {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonId = lesson.id;

        // Track lesson completion time
        trackLessonTime();

        // Update lesson progress
        courseProgress[lessonId] = {
          ...courseProgress[lessonId],
          completed: true,
          quizScore: score,
          completedAt: new Date().toISOString(),
          finalScore: score,
        };

        // Update session tracking
        courseSession.lessonsCompleted++;

        // Save progress to database
        await saveProgress();

        // Update UI
        renderSidebar();
        updateNavigationButtons();

        // Check various achievements
        await checkLessonCompletionAchievements();
        await checkPerfectScoreAchievements(score);
        await checkStudyTimeAchievements();

        // Log lesson completion
        logUserActivity("lesson_completed", {
          lesson_id: lessonId,
          lesson_title: lesson.title,
          final_score: score,
          time_spent: courseProgress[lessonId].timeSpent || 0,
          lesson_number: currentLessonIndex + 1,
        });

        showToast("Lesson completed successfully!", "success");
      }

      async function completeLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          // Move to next lesson
          currentLessonIndex++;
          loadLesson(currentLessonIndex);
        } else {
          // Course completion
          await completeCourse();
        }
      }

      async function completeCourse() {
        try {
          const completionTime = courseSession.totalStudyTime;

          // Update course progress to 100% completed
          await supabase
            .from("course_progress")
            .update({
              progress: 100,
              completed_at: new Date().toISOString(),
              completion_time_minutes: completionTime,
            })
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Award course completion achievements
          await checkAndUnlockAchievement("course_completion_1");
          await checkSpeedCompletionAchievements(completionTime);
          await checkCourseStreakAchievements();

          // Update user stats
          await updateUserStats();

          // Show completion message
          showToast(
            "Congratulations! Course completed successfully!",
            "certificate"
          );

          // Log course completion
          logUserActivity("course_completed", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            completion_time_minutes: completionTime,
            total_lessons: COURSE_DATA.lessons.length,
            average_quiz_score: calculateAverageQuizScore(),
          });

          // Redirect to dashboard after delay
          setTimeout(() => {
            window.location.href = "/dashboard.html";
          }, 3000);
        } catch (error) {
          console.error("Error completing course:", error);
          showToast("Error marking course as complete", "error");
        }
      }

      // =====================================================
      // ACHIEVEMENT INTEGRATION SYSTEM
      // =====================================================
      async function checkAndUnlockAchievement(
        achievementId,
        skipNotification = false
      ) {
        try {
          // Prevent duplicate checks
          const cacheKey = `achievement_${achievementId}_${currentUser.id}`;
          if (sessionStorage.getItem(cacheKey)) return false;

          // Check if already unlocked
          const { data: existing, error } = await supabase
            .from("user_achievements")
            .select("id")
            .eq("user_id", currentUser.id)
            .eq("achievement_id", achievementId)
            .single();

          if (existing) {
            sessionStorage.setItem(cacheKey, "true");
            return false;
          }

          // Award achievement
          const achievementData = {
            user_id: currentUser.id,
            achievement_id: achievementId,
            unlocked_at: new Date().toISOString(),
            points_awarded: getAchievementPoints(achievementId),
            context: "course_system",
          };

          const { data, error: insertError } = await supabase
            .from("user_achievements")
            .insert([achievementData])
            .select()
            .single();

          if (insertError) {
            if (insertError.code === "23505") return false; // Already exists
            throw insertError;
          }

          // Update user points
          await supabase.rpc('increment_user_stats', {
  user_id_param: currentUser.id,
  points_to_add: achievementData.points_awarded,
  achievements_to_add: 1
});

          // Cache and queue notification
          sessionStorage.setItem(cacheKey, "true");

          if (!skipNotification) {
            queueAchievementNotification({
              id: achievementId,
              name: getAchievementName(achievementId),
              description: getAchievementDescription(achievementId),
              points: achievementData.points_awarded,
              rarity: getAchievementRarity(achievementId),
              icon: getAchievementIcon(achievementId),
            });
          }

          return true;
        } catch (error) {
          console.error("Error unlocking achievement:", error);
          return false;
        }
      }

      // Helper functions for achievement data (replace with your actual achievement definitions)
      function getAchievementPoints(id) {
        const pointsMap = {
          first_course_start: 75,
          first_lesson: 100,
          course_completion_1: 500,
          perfect_score: 250,
          speed_demon: 750,
          marathon_learner: 500,
          night_owl: 200,
          early_bird: 200,
          weekend_warrior: 150,
          // Add more as needed
        };
        return pointsMap[id] || 100;
      }

      function getAchievementName(id) {
        const nameMap = {
          first_course_start: "Learning Initiated",
          first_lesson: "First Steps",
          course_completion_1: "Course Conqueror",
          perfect_score: "Perfectionist",
          speed_demon: "Speed Demon",
          // Add more as needed
        };
        return nameMap[id] || "Achievement Unlocked";
      }

      function getAchievementDescription(id) {
        const descMap = {
          first_course_start: "Start your first cybersecurity course",
          first_lesson: "Complete your first lesson",
          course_completion_1: "Complete your first course",
          perfect_score: "Score 100% on any quiz",
          speed_demon: "Complete a course in under 2 hours",
          // Add more as needed
        };
        return descMap[id] || "Achievement description";
      }

      function getAchievementRarity(id) {
        const rarityMap = {
          first_course_start: "common",
          first_lesson: "bronze",
          course_completion_1: "silver",
          perfect_score: "gold",
          speed_demon: "legendary",
          // Add more as needed
        };
        return rarityMap[id] || "common";
      }

      function getAchievementIcon(id) {
        const iconMap = {
          first_course_start: "fas fa-play",
          first_lesson: "fas fa-baby",
          course_completion_1: "fas fa-trophy",
          perfect_score: "fas fa-star",
          speed_demon: "fas fa-rocket",
          // Add more as needed
        };
        return iconMap[id] || "fas fa-award";
      }

      async function checkLessonAchievements(lessonNumber) {
        if (lessonNumber === 1) {
          await checkAndUnlockAchievement("first_lesson");
        }

        // Check if user has completed multiple lessons in one day
        const today = new Date().toISOString().split("T")[0];
        const todayCompletions = Object.values(courseProgress).filter(
          (p) => p.completed && p.completedAt?.startsWith(today)
        ).length;

        if (todayCompletions >= 3) {
          await checkAndUnlockAchievement("lesson_marathon");
        }
      }

      async function checkLessonCompletionAchievements() {
        const completedCount = getCompletedLessonsCount();

        // Lesson-based achievements
        const lessonMilestones = [1, 5, 10, 25, 50, 100];
        for (const milestone of lessonMilestones) {
          if (completedCount >= milestone) {
            await checkAndUnlockAchievement(`lessons_${milestone}`);
          }
        }

        // Course completion achievements
        if (completedCount === COURSE_DATA.lessons.length) {
          await checkAndUnlockAchievement("course_completion_1");

          // Check for additional course completion achievements
          const { data: allCourses } = await supabase
            .from("course_progress")
            .select("course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100);

          const totalCompleted = allCourses?.length || 0;

          const courseMilestones = [1, 5, 10, 25];
          for (const milestone of courseMilestones) {
            if (totalCompleted >= milestone) {
              await checkAndUnlockAchievement(`course_completion_${milestone}`);
            }
          }
        }
      }

      async function checkPerfectScoreAchievements(score) {
        if (score === 100) {
          await checkAndUnlockAchievement("perfect_score");

          // Check for consecutive perfect scores
          const recentScores = Object.values(courseProgress)
            .filter((p) => p.completed && p.quizScore)
            .slice(-5) // Last 5 completed
            .map((p) => p.quizScore);

          if (
            recentScores.length >= 3 &&
            recentScores.every((s) => s === 100)
          ) {
            await checkAndUnlockAchievement("perfectionist_streak");
          }
        }
      }

      async function checkSpeedCompletionAchievements(completionTime) {
        // Speed demon: Complete course in under 2 hours (120 minutes)
        if (completionTime <= 120) {
          await checkAndUnlockAchievement("speed_demon");
        }

        // Quick learner: Complete course in under 4 hours (240 minutes)
        if (completionTime <= 240) {
          await checkAndUnlockAchievement("quick_learner");
        }
      }

      async function checkStudyTimeAchievements() {
        const totalTime = courseSession.totalStudyTime;

        // Marathon learner: Study for 8+ hours in a course session
        if (totalTime >= 480) {
          // 8 hours
          await checkAndUnlockAchievement("marathon_learner");
        }

        // Dedicated learner: Study for 4+ hours
        if (totalTime >= 240) {
          // 4 hours
          await checkAndUnlockAchievement("dedicated_learner");
        }
      }

      async function checkCourseStreakAchievements() {
        try {
          // Check for consecutive course completions
          const { data: recentCourses, error } = await supabase
            .from("course_progress")
            .select("completed_at, course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100)
            .order("completed_at", { ascending: false })
            .limit(10);

          if (error || !recentCourses) return;

          // Check for courses completed on consecutive days
          let consecutiveDays = 1;
          for (let i = 1; i < recentCourses.length; i++) {
            const prevDate = new Date(
              recentCourses[i - 1].completed_at
            ).toDateString();
            const currentDate = new Date(
              recentCourses[i].completed_at
            ).toDateString();
            const dayDiff =
              Math.abs(new Date(prevDate) - new Date(currentDate)) /
              (1000 * 60 * 60 * 24);

            if (dayDiff <= 1) {
              consecutiveDays++;
            } else {
              break;
            }
          }

          if (consecutiveDays >= 3) {
            await checkAndUnlockAchievement("learning_streak");
          }
        } catch (error) {
          console.error("Error checking course streak achievements:", error);
        }
      }

      // =====================================================
      // TIME-BASED ACHIEVEMENTS
      // =====================================================
      async function checkTimeBasedAchievements(timestamp) {
        const hour = timestamp.getHours();
        const dayOfWeek = timestamp.getDay();

        // Night owl (after midnight, before 6 AM)
        if (hour >= 0 && hour < 6) {
          await incrementTimeBasedCounter("midnight_sessions", "night_owl");
        }

        // Early bird (4 AM to 6 AM)
        if (hour >= 4 && hour < 6) {
          await incrementTimeBasedCounter("early_sessions", "early_bird");
        }

        // Weekend warrior (Saturday = 6, Sunday = 0)
        if (dayOfWeek === 0 || dayOfWeek === 6) {
          await incrementTimeBasedCounter(
            "weekend_sessions",
            "weekend_warrior"
          );
        }
      }

      async function incrementTimeBasedCounter(counterType, achievementId) {
        try {
          const dateStr = new Date().toISOString().split("T")[0];
          const cacheKey = `${counterType}_${currentUser.id}_${dateStr}`;

          // Prevent multiple increments per day
          if (sessionStorage.getItem(cacheKey)) return;

          // Update counter
          await supabase
            .from("profiles")
            .update({
              [counterType]: supabase.sql`${counterType} + 1`,
            })
            .eq("id", currentUser.id);

          // Cache to prevent double counting
          sessionStorage.setItem(cacheKey, "true");

          // Check related achievement
          if (achievementId) {
            await checkAndUnlockAchievement(achievementId, true);
          }
        } catch (error) {
          console.error(`Error incrementing ${counterType}:`, error);
        }
      }

      async function checkDailyStreak() {
        try {
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("last_activity, current_streak, last_streak_date")
            .eq("id", currentUser.id)
            .single();

          if (error) throw error;

          const now = new Date();
          const today = now.toDateString();
          const lastActivity = profile.last_activity
            ? new Date(profile.last_activity)
            : null;
          const lastStreakDate = profile.last_streak_date
            ? new Date(profile.last_streak_date).toDateString()
            : null;

          let newStreak = profile.current_streak || 0;
          let shouldUpdateStreak = false;

          if (!lastActivity) {
            // First time user
            newStreak = 1;
            shouldUpdateStreak = true;
          } else {
            const daysSinceLastActivity = Math.floor(
              (now - lastActivity) / (1000 * 60 * 60 * 24)
            );

            if (lastStreakDate === today) {
              // Already counted today's streak
              return newStreak;
            } else if (
              daysSinceLastActivity === 1 ||
              (daysSinceLastActivity === 0 && lastStreakDate !== today)
            ) {
              // Consecutive day or same day but not counted yet
              newStreak += 1;
              shouldUpdateStreak = true;
            } else if (daysSinceLastActivity > 1) {
              // Streak broken
              newStreak = 1;
              shouldUpdateStreak = true;
            }
          }

          if (shouldUpdateStreak) {
            await supabase
              .from("profiles")
              .update({
                current_streak: newStreak,
                last_activity: now.toISOString(),
                last_streak_date: now.toISOString(),
              })
              .eq("id", currentUser.id);

            userStats.current_streak = newStreak;

            showToast(`Daily streak: ${newStreak} days!`, "success");
            await checkStreakAchievements(newStreak);
          }

          return newStreak;
        } catch (error) {
          console.error("Error checking daily streak:", error);
          return 0;
        }
      }

      async function checkStreakAchievements(currentStreak) {
        const streakMilestones = [3, 7, 14, 30, 100, 365];

        for (const milestone of streakMilestones) {
          if (currentStreak >= milestone) {
            await checkAndUnlockAchievement(`streak_${milestone}`);
          }
        }
      }

      // =====================================================
      // USER ACTIVITY LOGGING
      // =====================================================
      async function logUserActivity(activityType, metadata = {}) {
        try {
          const now = new Date();

          const activityData = {
            user_id: currentUser.id,
            activity_type: activityType,
            timestamp: now.toISOString(),
            course_id: COURSE_DATA.id,
            lesson_index: currentLessonIndex,
            session_duration: courseSession.totalStudyTime,
            metadata: JSON.stringify(metadata),
            created_at: now.toISOString(),
          };

          // Try to log to activities table
          const { error } = await supabase
            .from("user_activities")
            .insert([activityData]);

          if (error && error.code !== "42P01") {
            console.warn("Activity logging failed:", error.message);
          }

          // Always update last activity in profile
          await supabase
            .from("profiles")
            .update({ last_activity: now.toISOString() })
            .eq("id", currentUser.id);
        } catch (error) {
          console.error("Error logging user activity:", error);
        }
      }

      // =====================================================
      // NAVIGATION SYSTEM
      // =====================================================
      function updateNavigationButtons() {
        const prevBtn = document.getElementById("prevLessonBtn");
        const nextBtn = document.getElementById("nextLessonBtn");

        if (!prevBtn || !nextBtn) return;

        // Previous button
        prevBtn.disabled = currentLessonIndex === 0;

        // Next button logic
        const isLastLesson =
          currentLessonIndex === COURSE_DATA.lessons.length - 1;
        const canGoNext =
          currentLessonIndex < COURSE_DATA.lessons.length - 1 &&
          canAccessLesson(currentLessonIndex + 1);

        if (isLastLesson) {
          const isCurrentCompleted =
            courseProgress[COURSE_DATA.lessons[currentLessonIndex].id]
              ?.completed;
          nextBtn.disabled = !isCurrentCompleted;
          nextBtn.innerHTML = '<i class="fas fa-trophy"></i> Complete Course';
        } else {
          nextBtn.disabled = !canGoNext;
          nextBtn.innerHTML = 'Next <i class="fas fa-chevron-right"></i>';
        }
      }

      // Navigation button event handlers
      function goToPreviousLesson() {
        if (currentLessonIndex > 0) {
          trackLessonTime(); // Track time spent on current lesson
          currentLessonIndex--;
          loadLesson(currentLessonIndex);
        }
      }

      function goToNextLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          const canGoNext = canAccessLesson(currentLessonIndex + 1);
          if (canGoNext) {
            trackLessonTime();
            currentLessonIndex++;
            loadLesson(currentLessonIndex);
          } else {
            showToast("Complete the current lesson quiz to proceed", "warning");
          }
        } else {
          // Complete course
          completeCourse();
        }
      }

      // =====================================================
      // SIDEBAR FUNCTIONS
      // =====================================================
      function toggleSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.toggle("open");
        if (overlay) overlay.classList.toggle("active");
      }

      function closeSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.remove("open");
        if (overlay) overlay.classList.remove("active");
      }

      // =====================================================
      // ACHIEVEMENT NOTIFICATION SYSTEM
      // =====================================================
      function queueAchievementNotification(achievement) {
        notificationQueue.push(achievement);
        processNotificationQueue();
      }

      function processNotificationQueue() {
        if (isShowingNotification || notificationQueue.length === 0) return;

        isShowingNotification = true;
        const achievement = notificationQueue.shift();
        showAchievementNotification(achievement);

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          isShowingNotification = false;
          processNotificationQueue();
        }, duration + 500);
      }

      function showAchievementNotification(achievement) {
        const notification = document.getElementById("achievementNotification");
        if (!notification) return;

        const icon = document.getElementById("notificationIcon");
        const title = document.getElementById("notificationTitle");
        const description = document.getElementById("notificationDescription");
        const points = document.getElementById("notificationPoints");

        if (icon) {
          icon.innerHTML = `<i class="${achievement.icon}"></i>`;
          icon.className = `notification-icon ${achievement.rarity}`;
        }
        if (title) title.textContent = achievement.name;
        if (description) description.textContent = achievement.description;
        if (points) points.textContent = `+${achievement.points} Points`;

        notification.className = `achievement-notification ${achievement.rarity}`;
        notification.classList.add("show");

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          notification.classList.remove("show");
        }, duration);
      }

      // =====================================================
      // UTILITY FUNCTIONS
      // =====================================================
      function calculateAverageQuizScore() {
        const scores = Object.values(courseProgress)
          .filter((p) => p.completed && p.quizScore)
          .map((p) => p.quizScore);

        if (scores.length === 0) return 0;
        return Math.round(
          scores.reduce((sum, score) => sum + score, 0) / scores.length
        );
      }

      async function resetProgress() {
        if (
          !confirm(
            "Are you sure you want to reset your progress? This action cannot be undone."
          )
        ) {
          return;
        }

        try {
          // Track lesson time before reset
          trackLessonTime();

          // Reset local state
          courseProgress = {};
          currentLessonIndex = 0;
          courseSession = {
            startTime: new Date(),
            totalStudyTime: 0,
            lessonsStarted: 0,
            lessonsCompleted: 0,
            pageLoadTime: new Date(),
            interactionCount: 0,
            lastActivityTime: new Date(),
          };

          // Delete from database
          await supabase
            .from("course_progress")
            .delete()
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Log reset activity
          logUserActivity("progress_reset", {
            course_id: COURSE_DATA.id,
            reset_reason: "manual",
          });

          // Reinitialize
          await saveProgress();
          renderSidebar();
          loadLesson(0);

          showToast("Progress reset successfully", "success");
        } catch (error) {
          console.error("Error resetting progress:", error);
          showToast("Failed to reset progress", "error");
        }
      }

      function copyCode(codeId) {
        const codeElement = document.getElementById(codeId);
        if (!codeElement) return;

        const text = codeElement.textContent;

        navigator.clipboard
          .writeText(text)
          .then(() => {
            showToast("Code copied to clipboard!", "success");

            // Track code copy for achievements
            logUserActivity("code_copied", {
              code_section: codeId,
              lesson_id: COURSE_DATA.lessons[currentLessonIndex].id,
            });
          })
          .catch((err) => {
            console.error("Failed to copy code:", err);
            showToast("Failed to copy code", "error");

            // Fallback for older browsers
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            try {
              document.execCommand("copy");
              showToast("Code copied to clipboard!", "success");
            } catch (fallbackError) {
              showToast(
                "Copy failed - please select and copy manually",
                "error"
              );
            }
            document.body.removeChild(textArea);
          });
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // =====================================================
      // UI FEEDBACK SYSTEMS
      // =====================================================
      function showToast(message, type = "success") {
        const toast = document.getElementById("toast");
        const messageEl = document.getElementById("toastMessage");

        if (!toast || !messageEl) {
          console.log(`Toast: ${message} (${type})`);
          return;
        }

        messageEl.textContent = message;
        toast.className = `toast ${type} show`;

        setTimeout(() => {
          toast.classList.remove("show");
        }, 4000);
      }

      function showLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) loadingScreen.classList.remove("hidden");
      }

      function hideLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) {
          setTimeout(() => {
            loadingScreen.classList.add("hidden");
          }, 1000);
        }
      }

      // =====================================================
      // MUSIC PLAYER INTEGRATION
      // =====================================================
      function initMusicPlayer() {
        const btnText = document.getElementById("music-button-text");
        const icon = document.getElementById("music-icon");
        const dropdown = document.getElementById("music-dropdown-content");

        if (!btnText || !icon || !dropdown) return;

        function setUI(state) {
          btnText.textContent =
            state === "Playing" ? "PAUSE MUSIC" : "STUDY MUSIC";
          icon.className =
            state === "Playing"
              ? "fa-solid fa-circle-pause"
              : "fa-solid fa-music";
        }

        // Load saved music state
        const savedSrc = localStorage.getItem("cybersec_music_src");
        const savedTime = parseFloat(
          localStorage.getItem("cybersec_music_time") || 0
        );

        if (savedSrc) {
          audioPlayer.src = savedSrc;
          audioPlayer.currentTime = savedTime;
          audioPlayer
            .play()
            .then(() => setUI("Playing"))
            .catch(() => setUI("Stopped"));
        }

        // Music button click handler
        document
          .getElementById("music-dropdown")
          .querySelector("button")
          .addEventListener("click", (e) => {
            e.stopPropagation();
            dropdown.style.display =
              dropdown.style.display === "block" ? "none" : "block";

            if (audioPlayer.src && !audioPlayer.paused) {
              audioPlayer.pause();
              setUI("Stopped");
            } else if (audioPlayer.src) {
              audioPlayer.play().then(() => setUI("Playing"));
            }
          });

        // Music selection handlers
        dropdown.querySelectorAll("a[data-src]").forEach((link) => {
          link.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.src = link.dataset.src;
            audioPlayer.play().then(() => setUI("Playing"));
            localStorage.setItem("cybersec_music_src", link.dataset.src);
            dropdown.style.display = "none";
          });
        });

        // Stop music handler
        const stopLink = document.getElementById("stop-music-link");
        if (stopLink) {
          stopLink.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            audioPlayer.removeAttribute("src");
            setUI("Stopped");
            localStorage.removeItem("cybersec_music_src");
            localStorage.removeItem("cybersec_music_time");
            dropdown.style.display = "none";
          });
        }

        // Save music state before page unload
        window.addEventListener("beforeunload", () => {
          if (!audioPlayer.paused && audioPlayer.src) {
            localStorage.setItem("cybersec_music_src", audioPlayer.src);
            localStorage.setItem(
              "cybersec_music_time",
              audioPlayer.currentTime
            );
          }
        });

        // Close dropdown when clicking outside
        window.addEventListener("click", (e) => {
          if (!e.target.closest("#music-dropdown")) {
            dropdown.style.display = "none";
          }
        });
      }

      // Show initial music indicator
      function addMusicIndicator() {
        const musicBtn = document.querySelector("#music-dropdown");
        if (musicBtn) {
          const indicator = document.createElement("div");
          indicator.className = "music-indicator";
          indicator.innerHTML = `<i class="fa-solid fa-music"></i> Try Study Music!`;

          musicBtn.style.position = "relative";
          musicBtn.appendChild(indicator);

          setTimeout(() => indicator.remove(), 3000);
        }
      }

      // Initialize Event Listeners
      function initializeEventListeners() {
        // Navigation buttons
        document
          .getElementById("prevLessonBtn")
          ?.addEventListener("click", goToPreviousLesson);
        document
          .getElementById("nextLessonBtn")
          ?.addEventListener("click", goToNextLesson);

        // Reset progress button
        document
          .getElementById("resetProgressBtn")
          ?.addEventListener("click", resetProgress);

        // Mobile menu toggle
        document
          .getElementById("menuToggle")
          ?.addEventListener("click", toggleSidebar);
        document
          .getElementById("sidebarOverlay")
          ?.addEventListener("click", closeSidebar);

        // Keyboard shortcuts
        document.addEventListener("keydown", handleKeyboardShortcuts);

        // Window resize handler
        window.addEventListener("resize", handleWindowResize);

        // Content interaction tracking
        document.getElementById("contentBody")?.addEventListener(
          "scroll",
          debounce(() => {
            trackUserInteraction();
          }, 1000)
        );
      }

      // Keyboard Shortcuts
      function handleKeyboardShortcuts(e) {
        if (document.querySelector(".quiz-question.active")) return;

        if (e.key === "ArrowLeft" && e.ctrlKey) {
          e.preventDefault();
          goToPreviousLesson();
        } else if (e.key === "ArrowRight" && e.ctrlKey) {
          e.preventDefault();
          goToNextLesson();
        }
      }

      // Window Resize Handler
      function handleWindowResize() {
        if (window.innerWidth > 768) {
          closeSidebar();
        }
      }

      // Debounce Helper
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Initialize responsive behavior
      if (window.innerWidth <= 768) {
        document.getElementById("menuToggle").style.display = "inline-flex";
      }

      // Auto-save progress periodically
      setInterval(async () => {
        if (currentUser && Object.keys(courseProgress).length > 0) {
          await saveProgress();
        }
      }, 60000); // Save every minute

      // System initialization logging
      console.log("CyberSec Academy Course System Initialized");
      console.log("Current Course:", COURSE_DATA.title);
      console.log("Total Lessons:", COURSE_DATA.lessons.length);

      // Google OAuth Integration
      const googleBtn = document.querySelector(".btn-google");
      if (googleBtn) {
        googleBtn.addEventListener("click", async () => {
          const { data, error } = await supabase.auth.signInWithOAuth({
            provider: "google",
            options: {
              redirectTo:
                window.location.origin +
                "/courses/detection-engineering.html",
            },
          });

          if (error) {
            console.error("Google login error:", error.message);
            showToast("Google login failed: " + error.message, "error");
          }
        });
      }

      // Check for existing session
      supabase.auth.getSession().then(({ data }) => {
        if (data.session) {
          console.log("User already logged in:", data.session.user);
          currentUser = data.session.user;
          startCourseSession();
        }
      });

      // Add missing auth modal functions
      function openAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "flex";
        }
      }

      function closeAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Add auth tab switching functionality
      document.getElementById("tabSignIn")?.addEventListener("click", () => {
        document.getElementById("tabSignIn").classList.add("active");
        document.getElementById("tabSignUp").classList.remove("active");
        document.getElementById("signInForm").style.display = "block";
        document.getElementById("signUpForm").style.display = "none";
      });

      document.getElementById("tabSignUp")?.addEventListener("click", () => {
        document.getElementById("tabSignUp").classList.add("active");
        document.getElementById("tabSignIn").classList.remove("active");
        document.getElementById("signUpForm").style.display = "block";
        document.getElementById("signInForm").style.display = "none";
      });

      document
        .getElementById("closeAuthModal")
        ?.addEventListener("click", closeAuthModal);

      // Improved error handling for auth session
      supabase.auth.onAuthStateChange((event, session) => {
        if (event === "SIGNED_IN") {
          currentUser = session.user;
          closeAuthModal();
          startCourseSession();
        } else if (event === "SIGNED_OUT") {
          currentUser = null;
          openAuthModal();
        }
      });

      // Add form submission handlers
      document
        .getElementById("emailSignInForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signInEmail").value;
          const password = document.getElementById("signInPassword").value;

          try {
            const { data, error } = await supabase.auth.signInWithPassword({
              email,
              password,
            });

            if (error) throw error;

            closeAuthModal();
          } catch (error) {
            showToast(error.message, "error");
          }
        });

      document
        .getElementById("emailSignUpForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signUpEmail").value;
          const password = document.getElementById("signUpPassword").value;
          const name = document.getElementById("signUpName").value;

          try {
            const { data, error } = await supabase.auth.signUp({
              email,
              password,
              options: {
                data: {
                  full_name: name,
                },
              },
            });

            if (error) throw error;

            showToast(
              "Account created successfully! Please check your email.",
              "success"
            );
          } catch (error) {
            showToast(error.message, "error");
          }
        });
    </script>
  </body>
</html>
