


<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>Advanced Exploit Development Course Curriculum | CipherHall</title>
    <meta name="description" content="Begin your free, expert-level Exploit Development course. This curriculum covers vulnerability research, buffer overflows, ROP, kernel and browser exploitation." />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png" />
    <link rel="shortcut icon" href="/favicon.png" type="image/x-icon" />
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png" />
    <link rel="canonical" href="https://www.cipherhall.com/courses/advanced-exploit-development" />

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Course",
      "name": "Advanced Exploit Development",
      "description": "An expert-level course on modern exploit development techniques, covering everything from basic buffer overflows to advanced kernel exploitation and browser-based attacks.",
      "provider": {
        "@type": "Organization",
        "name": "CipherHall",
        "sameAs": "https://www.cipherhall.com"
      },
      "hasCourseInstance": {
        "@type": "CourseInstance",
        "courseMode": "Online",
        "instructor": {
          "@type": "Person",
          "name": "Dr. Evelyn '0xEFF' Reed"
        }
      }
    }
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Exo+2:wght@700;800;900&display=swap" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" />
    <link rel="stylesheet" href="assets/css/coursepages.css">
</head>
  <body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
      <div class="loader-icon">
        <i class="fas fa-graduation-cap"></i>
      </div>
      <div class="loader-text">Loading Course Content...</div>
    </div>

    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- Music Player (fixed at top right) -->
    <div class="header-controls">
      <div class="music-dropdown" id="music-dropdown">
        <button class="btn btn-secondary">
          <span id="music-button-text">STUDY MUSIC</span>
          <i id="music-icon" class="fa-solid fa-music"></i>
        </button>
        <div class="music-dropdown-content" id="music-dropdown-content">
          <a
            href="#"
            data-src="https://www.learningcontainer.com/wp-content/uploads/2020/02/Kalimba.mp3"
            >1. Coffee Shop Vibes</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3"
            >2. City Lights Lofi</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-15.mp3"
            >3. Mellow Thoughts</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-13.mp3"
            >4. Rainy Mood</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3"
            >5. Time Alone</a
          >
          <a href="#" id="stop-music-link"
            ><i class="fa-solid fa-stop-circle"></i> Stop Music</a
          >
        </div>
      </div>

      <button class="btn btn-secondary" id="resetProgressBtn">
        <i class="fas fa-redo"></i>
        Reset Progress
      </button>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal" style="display: none">
      <div class="modal-overlay"></div>
      <div class="modal-content">
        <span class="close" id="closeAuthModal">&times;</span>
        <div class="auth-tabs">
          <button id="tabSignIn" class="auth-tab active">Sign In</button>
          <button id="tabSignUp" class="auth-tab">Sign Up</button>
        </div>
        <div
          id="authLoader"
          style="display: none; text-align: center; padding: 2rem"
        >
          <i
            class="fas fa-spinner fa-spin fa-2x"
            style="color: var(--color-green)"
          ></i>
          <p style="margin-top: 0.5rem">Authenticating...</p>
        </div>
        <div id="signInForm" class="auth-form">
          <h2>Sign In to CipherHall</h2>
          <button id="googleSignIn" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignInForm">
            <input
              type="email"
              id="signInEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signInPassword"
              placeholder="Password"
              required
            />
            <button type="submit" class="btn btn-primary">Sign In</button>
          </form>
        </div>
        <div id="signUpForm" class="auth-form" style="display: none">
          <h2>Join CipherHall</h2>
          <button id="googleSignUp" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignUpForm">
            <input
              type="text"
              id="signUpName"
              placeholder="Full Name"
              required
            />
            <input
              type="email"
              id="signUpEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signUpPassword"
              placeholder="Password (min. 8 characters)"
              required
            />
            <button type="submit" class="btn btn-secondary">
              Create Account
            </button>
          </form>
        </div>
        <div id="authMessage"></div>
      </div>
    </div>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="course-info">
          <h1 class="course-title" id="courseTitle">Loading...</h1>
          <div class="course-progress">
            <div class="progress-header">
              <span class="progress-label">Course Progress</span>
              <span class="progress-percentage" id="courseProgressPercent"
                >0%</span
              >
            </div>
            <div class="progress-bar">
              <div
                class="progress-fill"
                id="courseProgressFill"
                style="width: 0%"
              ></div>
            </div>
            <div class="progress-stats">
              <span id="completedLessons">0</span>
              <span id="totalLessons">0</span>
            </div>
          </div>
          <a href="/dashboard" class="back-to-dashboard">
            <i class="fas fa-arrow-left"></i>
            Back to Dashboard
          </a>
        </div>
      </div>

      <nav class="lesson-nav" id="lessonNav">
        <!-- Lessons will be loaded dynamically -->
      </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <header class="content-header">
        <div class="lesson-header">
          <div class="lesson-header-left">
            <span class="lesson-number" id="currentLessonNumber">1</span>
            <h1 class="lesson-header-title" id="currentLessonTitle">
              Loading...
            </h1>
          </div>
          <div class="lesson-actions">
            <button class="mbtn btn-primary" id="menuToggle">
              <i class="fas fa-bars"></i>
            </button>
          </div>
        </div>
      </header>

      <div class="content-body" id="contentBody">
        <div class="lesson-content" id="lessonContent">
          <!-- Lesson content will be loaded dynamically -->
        </div>
      </div>

      <footer class="lesson-navigation">
        <div class="nav-info" id="navInfo">Lesson 1 of 10</div>
        <div class="nav-controls">
          <button class="btn btn-secondary" id="prevLessonBtn" disabled>
            <i class="fas fa-chevron-left"></i>
            Previous
          </button>
          <button class="btn btn-primary" id="nextLessonBtn" disabled>
            Next
            <i class="fas fa-chevron-right"></i>
          </button>
        </div>
      </footer>
    </main>

    <!-- Achievement Notification -->
    <div id="achievementNotification" class="achievement-notification">
      <div class="notification-header">
        <div class="notification-icon" id="notificationIcon">
          <i class="fas fa-trophy"></i>
        </div>
        <div class="notification-content">
          <h3 id="notificationTitle">Achievement Unlocked!</h3>
          <p id="notificationDescription">Description here...</p>
        </div>
      </div>
      <div class="notification-reward" id="notificationReward">
        <i class="fas fa-coins"></i>
        <span id="notificationPoints">+100 Points</span>
      </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast">
      <span id="toastMessage"></span>
    </div>

    <script>
      // =====================================================
      // SYNCHRONIZED COURSE SYSTEM WITH DASHBOARD INTEGRATION
      // =====================================================

      // Supabase Configuration - Replace with your config
      const supabaseUrl = "https://lzcmzulemfubjaksoqor.supabase.co";
      const supabaseKey =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx6Y216dWxlbWZ1Ympha3NvcW9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzMzM5MDgsImV4cCI6MjA3MDkwOTkwOH0.crhPH4YWtRsr1BJTpAQcmPbWSpwIWRbzoI4sRb2_fPI";
      const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

      // =====================================================
      // COURSE DATA STRUCTURE - REPLACE WITH YOUR COURSE JSON
      // =====================================================

      const COURSE_DATA =  
{
    "id": "advanced-exploit-development",
    "title": "Advanced Exploit Development",
    "description": "This course provides a deep, hands-on dive into the art and science of software exploitation. Students will learn to analyze, understand, and exploit a wide range of vulnerabilities in modern applications. The curriculum focuses on bypassing contemporary security mitigations and gaining arbitrary code execution on both Linux and Windows platforms, culminating in an introduction to kernel-level exploitation.",
    "category": "cybersecurity",
    "difficulty": "Advanced",
    "duration": "120 hours",
    "instructor": "Dr. Evelyn Reed",
    "lessons": [
        {
            "id": "lesson-1",
            "title": "Tooling and Environment Setup",
            "duration": "120 min",
            "objectives": [
                "Set up a virtualized lab environment for both Linux and Windows exploitation",
                "Gain proficiency with debuggers like GDB with Pwndbg/GEF and WinDbg",
                "Learn to use disassemblers such as Ghidra and IDA Pro for static analysis",
                "Understand the fundamentals of scripting exploits with Python and pwntools"
            ],
            "content": {
                "overview": "Welcome to Advanced Exploit Development. Before we can break software, we must build a robust and isolated laboratory. This foundational lesson will guide you through setting up a professional-grade virtual environment and mastering the essential tools of the trade: debuggers, disassemblers, and scripting libraries.",
                "sections": [
                    {
                        "title": "Virtualization for a Safe Lab",
                        "content": "<p>A dedicated and isolated lab is non-negotiable for exploit development. It protects your host machine from crashes or accidental damage and allows you to work with specific, vulnerable versions of operating systems and software without risk.</p><h3>Key Components:</h3><ul><li><strong>Hypervisor:</strong> Software like VMware Workstation or VirtualBox that creates and runs virtual machines (VMs).</li><li><strong>Guest Operating Systems:</strong> We will create two primary VMs: a Linux machine (like Ubuntu LTS) for Linux-based challenges, and a Windows 10 machine for Windows exploitation.</li><li><strong>Snapshots:</strong> A critical feature of hypervisors. Snapshots allow you to save the state of a VM at a specific moment. If an exploit crashes the system or makes it unstable, you can instantly revert to a clean, working state.</li></ul><div class='info-box tip'><div class='info-box-header'><i class='fas fa-lightbulb'></i><strong>Pro Tip</strong></div><p>Take a snapshot of your clean, fully-configured VMs before you begin working on any target. This 'golden image' will save you countless hours of setup time.</p></div>",
                        "image": "https://images.unsplash.com/photo-1593432336332-9513d64b545d?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Mastering Debuggers: GDB and WinDbg",
                        "content": "<p>A debugger is the single most important tool for an exploit developer. It gives you an intimate view into a program's execution, allowing you to control its flow, inspect memory, and understand its state at any given moment.</p><h3>Linux Debugging: GDB with Enhancements</h3><ul><li><strong>GDB (GNU Debugger):</strong> The standard debugger for Linux.</li><li><strong>Pwndbg/GEF:</strong> These are powerful enhancement suites for GDB that provide a much more intuitive interface. They display the current code, registers, stack, and other critical information in a clean, contextual layout, dramatically speeding up the debugging process.</li></ul><h3>Windows Debugging: WinDbg</h3><ul><li><strong>WinDbg:</strong> The premier debugger for the Windows operating system. It's essential for analyzing Windows applications and the kernel itself. It has a steeper learning curve than GDB but is incredibly powerful for Windows-specific structures like the PEB, TEB, and SEH chain.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1517694712202-1428bc64a259?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Static Analysis: Ghidra & IDA Pro",
                        "content": "<p>While a debugger shows you a program in motion (dynamic analysis), a disassembler lets you study its blueprint (static analysis). This is crucial for understanding an application's logic without even running it.</p><h3>Key Tools:</h3><ul><li><strong>Ghidra:</strong> A free, feature-rich, and powerful software reverse engineering suite developed by the NSA. Its decompiler, which translates assembly back into C-like code, is world-class.</li><li><strong>IDA Pro:</strong> The long-standing industry standard for disassembly. While it has a free version, the professional version is renowned for its speed, plugin ecosystem, and powerful analysis features.</li></ul><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Strategy</strong></div><p>Typically, you'll start with static analysis in Ghidra/IDA to map out the program and identify potential vulnerabilities. Then, you'll move to a debugger to confirm the bug and develop the exploit dynamically.</p></div>",
                        "image": "https://images.unsplash.com/photo-1526498460520-4c246339dccb?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Automation with Python and Pwntools",
                        "content": "<p>Manually typing inputs into a terminal is slow and inefficient. Modern exploit development relies on scripting to automate interactions with the target program. This ensures your exploit is precise, repeatable, and easy to modify.</p><h3>Pwntools: The Exploit Dev's Swiss Army Knife</h3><ul><li><strong>Pwntools</strong> is a Python library specifically designed for exploit development. It simplifies all the tedious tasks:</li><li>Interacting with processes (local and remote).</li><li>Packing and unpacking data (e.g., 64-bit addresses).</li><li>Assembling and disassembling shellcode.</li><li>Crafting ROP chains.</li><li>Handling remote connections and I/O.</li></ul><p>Learning pwntools is essential for productivity and is used in CTFs and professional engagements alike.</p>",
                        "image": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Installing Essential Linux Tools",
                        "language": "bash",
                        "code": "# Update package lists\nsudo apt update\n\n# Install build tools, python, and gdb\nsudo apt install -y build-essential python3-dev python3-pip gdb\n\n# Install pwntools\npip3 install pwntools\n\n# Install GDB Pwndbg\ngit clone https://github.com/pwndbg/pwndbg\ncd pwndbg\n./setup.sh\n\n# To start GDB with Pwndbg:\ngdb ./my_vulnerable_program"
                    },
                    {
                        "title": "Basic Pwntools Interaction Script",
                        "language": "python",
                        "code": "from pwn import *\n\n# Set the context for the target architecture\ncontext.arch = 'amd64'\ncontext.os = 'linux'\n\n# Start the process\n# For remote targets: p = remote('example.com', 1337)\np = process('./vulnerable_binary')\n\n# Receive data until a certain prompt\np.recvuntil(b'Enter your name: ')\n\n# Craft the payload\npayload = b'A' * 64 # Fill the buffer\npayload += p64(0xdeadbeef) # Overwrite return address\n\n# Send the payload\np.sendline(payload)\n\n# Switch to interactive mode to interact with the shell\np.interactive()"
                    }
                ]
            },
                "quiz": {
                    "passingScore": 75,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the primary reason for using virtual machine snapshots in exploit development?",
                            "options": [
                                "To increase the performance of the guest OS.",
                                "To easily transfer files between the host and guest.",
                                "To revert the system to a clean state after a crash or modification.",
                                "To debug the host operating system."
                            ],
                            "correct": 2,
                            "explanation": "Snapshots save the state of a VM, allowing you to quickly revert to a known-good configuration if your exploit corrupts or crashes the system, which is a common occurrence."
                        },
                        {
                            "id": 2,
                            "question": "Which tool is used for DYNAMIC analysis by stepping through a program's execution in real-time?",
                            "options": [
                                "Ghidra",
                                "IDA Pro",
                                "GDB",
                                "Wireshark"
                            ],
                            "correct": 2,
                            "explanation": "GDB (and WinDbg) are debuggers used for dynamic analysis, allowing you to control and inspect a program as it runs. Ghidra and IDA Pro are primarily for static analysis."
                        },
                        {
                            "id": 3,
                            "question": "What is the main purpose of the Pwntools library in Python?",
                            "options": [
                                "To write the vulnerable C code.",
                                "To compile programs from source.",
                                "To simplify and automate the process of writing and sending exploit payloads.",
                                "To decompile assembly code back to C."
                            ],
                            "correct": 2,
                            "explanation": "Pwntools is a powerful Python framework that streamlines all the common tasks in exploit development, such as process interaction, data packing, and connection handling."
                        }
                    ]
                
            }
        },
        {
            "id": "lesson-2",
            "title": "Deep Dive into x86/x64 Assembly",
            "duration": "150 min",
            "objectives": [
                "Identify key CPU registers and their purpose in x86-64",
                "Understand how stack frames are created and destroyed during function calls",
                "Differentiate between major calling conventions like cdecl and System V AMD64 ABI",
                "Read and understand basic assembly language instructions"
            ],
            "content": {
                "overview": "Exploitation does not happen in high-level languages; it happens at the machine level. To truly master this craft, you must speak the language of the CPU: assembly. This lesson is a deep dive into the practical x86-64 assembly knowledge required to understand and manipulate program execution.",
                "sections": [
                    {
                        "title": "Registers: The CPU's Scratchpad",
                        "content": "<p>Registers are small, high-speed storage locations within the CPU. Understanding their roles is fundamental to tracing program execution.</p><h3>Key x86-64 Registers:</h3><ul><li><strong>General Purpose:</strong> RAX (accumulator/return value), RBX, RCX (counter), RDX (data). The 64-bit 'R' prefix replaces the 32-bit 'E' (e.g., EAX).</li><li><strong>Instruction Pointer:</strong> RIP, the most critical register. It holds the memory address of the next instruction to be executed. Controlling RIP is the primary goal of most exploits.</li><li><strong>Stack Pointer:</strong> RSP. Points to the top of the current stack frame.</li><li><strong>Base Pointer:</strong> RBP. Points to the base of the current stack frame. Used as a stable reference point for local variables.</li><li><strong>Argument Registers (SysV ABI):</strong> RDI, RSI, RDX, RCX, R8, R9 are used to pass the first six integer/pointer arguments to functions.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1599667533358-bf522b103139?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The Stack and Function Calls",
                        "content": "<p>The stack is a region of memory used for managing function calls. It grows downwards in memory. When a function is called, a new 'stack frame' is created for it.</p><h3>The Function Prologue:</h3><p>A standard sequence of instructions at the start of a function:</p><code>push rbp<br>mov rbp, rsp</code><p>This saves the old base pointer and establishes the new one for the current function.</p><h3>The Function Epilogue:</h3><p>A standard sequence at the end of a function to clean up:</p><code>leave &nbsp;&nbsp; ; equivalent to mov rsp, rbp; pop rbp<br>ret</code><p>The <code>ret</code> instruction is crucial. It pops the address from the top of the stack and jumps to it, effectively loading that value into RIP. This is the mechanism we will abuse.</p>",
                        "image": "https://images.unsplash.com/photo-1550439062-609e1531270e?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Calling Conventions: The Rules of Communication",
                        "content": "<p>A calling convention is a standardized method for how functions receive parameters from and return results to their caller. This agreement is what makes separate compilation and libraries possible.</p><h3>Major Conventions:</h3><ul><li><strong>cdecl:</strong> The standard convention for C programs in 32-bit. The caller cleans the stack after the function returns. Arguments are passed on the stack.</li><li><strong>stdcall:</strong> Used heavily by the Win32 API. The callee is responsible for cleaning the stack. Arguments are passed on the stack.</li><li><strong>System V AMD64 ABI:</strong> The standard for Linux, macOS, and other UNIX-like systems on x86-64. The first six arguments are passed in registers (RDI, RSI, RDX, RCX, R8, R9) for efficiency. The rest are passed on the stack. The caller cleans the stack.</li></ul><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Crucial for Exploits</strong></div><p>When crafting exploits, especially ROP chains, you MUST respect the calling convention of the functions you plan to use. If a function expects its first argument in RDI, you must ensure RDI is loaded with the correct value before calling it.</p></div>",
                        "image": "https://images.unsplash.com/photo-1518773553398-650c184e0bb3?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Simple C Function",
                        "language": "c",
                        "code": "// Compile with: gcc -S -o example.s example.c -fno-asynchronous-unwind-tables\n\nlong add_numbers(long a, long b) {\n    long result = a + b;\n    return result;\n}"
                    },
                    {
                        "title": "Generated x86-64 Assembly (System V ABI)",
                        "language": "nasm",
                        "code": "; Function prologue\npush   rbp\nmov    rbp, rsp\n\n; Arguments 'a' and 'b' are already in RDI and RSI respectively\nmov    QWORD PTR [rbp-8], rdi\nmov    QWORD PTR [rbp-16], rsi\n\n; Perform the addition\nmov    rdx, QWORD PTR [rbp-8]\nmov    rax, QWORD PTR [rbp-16]\nadd    rax, rdx\n\n; Store result in [rbp-24]\nmov    QWORD PTR [rbp-24], rax\n\n; Return value is placed in RAX\nmov    rax, QWORD PTR [rbp-24]\n\n; Function epilogue\npop    rbp\nret"
                     }
                ]
            },
                "quiz": {
                    "passingScore": 75,
                    "questions": [
                        {
                            "id": 1,
                            "question": "Which register holds the address of the next instruction to be executed and is the primary target of exploitation?",
                            "options": [
                                "RAX (Accumulator)",
                                "RSP (Stack Pointer)",
                                "RBP (Base Pointer)",
                                "RIP (Instruction Pointer)"
                            ],
                            "correct": 3,
                            "explanation": "The Instruction Pointer (RIP on x64, EIP on x86) dictates the flow of execution. Gaining control of RIP allows an attacker to execute arbitrary code."
                        },
                        {
                            "id": 2,
                            "question": "In the System V AMD64 ABI (used by Linux), where is the first argument to a function typically passed?",
                            "options": [
                                "On the stack",
                                "In the RDI register",
                                "In the RAX register",
                                "In the RCX register"
                            ],
                            "correct": 1,
                            "explanation": "For efficiency, the System V AMD64 ABI passes the first six integer/pointer arguments in registers, starting with RDI for the first argument."
                        },
                        {
                            "id": 3,
                            "question": "What is the primary purpose of the 'ret' instruction in assembly?",
                            "options": [
                                "To push the current RIP onto the stack.",
                                "To add two numbers together.",
                                "To pop a value off the stack and jump to that address.",
                                "To clear the contents of the RAX register."
                            ],
                            "correct": 2,
                            "explanation": "The 'ret' instruction is fundamental to returning from a function. It pops the return address (which was pushed by the 'call' instruction) from the stack into the RIP register, redirecting execution flow."
                        }
                    ]
                
            }
        },
        {
            "id": "lesson-3",
            "title": "Operating System & Memory Management Review",
            "duration": "120 min",
            "objectives": [
                "Understand the concept of virtual memory and its importance in modern OSes",
                "Visualize the layout of a process's address space",
                "Explain the security boundary between Kernel and User space",
                "Describe the purpose of the GOT and PLT in dynamic linking"
            ],
            "content": {
                "overview": "Exploits don't exist in a vacuum; they operate within the structured world created by the Operating System. This lesson revisits crucial OS concepts from the perspective of an attacker, focusing on how memory is organized and managed, and how we can abuse these mechanisms.",
                "sections": [
                    {
                        "title": "Virtual Memory: An Illusion for Every Process",
                        "content": "<p>Modern operating systems use virtual memory to give each process its own private, contiguous address space. This is a powerful illusion managed by the OS and the CPU's Memory Management Unit (MMU).</p><h3>Key Benefits:</h3><ul><li><strong>Isolation:</strong> One process cannot interfere with the memory of another. A crash in one application doesn't bring down the entire system. This is a fundamental security boundary.</li><li><strong>Abstraction:</strong> Programmers don't need to worry about the physical layout of RAM. The OS handles the mapping from virtual addresses (used by the program) to physical addresses (in the RAM chips).</li><li><strong>Efficiency:</strong> Parts of a program can be loaded from disk on-demand (paging), and memory can be shared between processes (e.g., shared libraries).</li></ul>",
                        "image": "https://images.unsplash.com/photo-1544890225-2fde0e66f35b?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The Process Address Space",
                        "content": "<p>From the process's point of view, its virtual address space is laid out in a predictable way.</p><h3>Typical Layout on Linux x86-64:</h3><ul><li><strong>Text Segment (.text):</strong> The executable code itself. Usually marked read-only and executable.</li><li><strong>Data Segments (.data, .bss):</strong> Global and static variables.</li><li><strong>Heap:</strong> Dynamically allocated memory (e.g., via `malloc`). Grows upwards from the end of the data segment.</li><li><strong>Memory Mapping Segment:</strong> For shared libraries (like libc.so) and other mapped files.</li><li><strong>Stack:</strong> For local variables and function call management. Grows downwards from the top of the address space.</li><li><strong>Kernel Space:</strong> The upper portion of the address space is reserved for the OS kernel and is inaccessible to user-mode programs.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Dynamic Linking: GOT and PLT",
                        "content": "<p>Most programs don't include the full code for every function they use (like `printf`). Instead, they link against shared libraries (like libc) at runtime. This is handled by the dynamic linker using two key structures: the Global Offset Table (GOT) and the Procedure Linkage Table (PLT).</p><ul><li><strong>PLT:</strong> A small section of executable code that acts as a trampoline. When a program calls `printf` for the first time, it actually jumps to an entry in the PLT.</li><li><strong>GOT:</strong> A table of addresses. The PLT's job is to consult the GOT. The first time through, the GOT entry for `printf` points back to the PLT, which then calls the dynamic linker to find the real address of `printf` in libc.</li><li><strong>Lazy Resolution:</strong> The linker then updates the GOT entry with the real address. On all subsequent calls to `printf`, the PLT trampoline jumps directly to the libc function via the now-resolved GOT entry.</li></ul><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Attacker's Goal</strong></div><p>If an attacker can gain an arbitrary write primitive, they can overwrite a GOT entry (e.g., for `printf`) with the address of their own code (e.g., `system`). The next time the program calls `printf`, it will execute `system` instead. This is a powerful exploitation technique.</p></div>",
                        "image": "https://images.unsplash.com/photo-1542831371-d531d36971ad?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Viewing a Process's Memory Map",
                        "language": "bash",
                        "code": "# First, get the PID of a running process\npidof bash\n\n# Then, view its virtual memory layout\n# This file shows the address ranges and permissions for each segment\ncat /proc/$(pidof bash)/maps"
                    },
                    {
                        "title": "Inspecting PLT/GOT with 'readelf'",
                        "language": "bash",
                        "code": "# Compile a simple program\ngcc myprogram.c -o myprogram\n\n# View the dynamic symbols and their PLT/GOT entries\n# This shows which functions are resolved at runtime\nreadelf -r ./myprogram"
                    },
                    {
                        "title": "Observing Lazy Binding in GDB",
                        "language": "bash",
                        "code": "gdb -q ./myprogram\n\n# Set a breakpoint at the start\n(gdb) break main\n(gdb) run\n\n# Examine the GOT entry for a function like 'puts' before it's called\n# It will point back into the PLT\n(gdb) x/gx &puts@got.plt\n\n# Step until after puts is called\n(gdb) next\n(gdb) next\n\n# Examine the GOT entry again. It now points to the real address in libc!\n(gdb) x/gx &puts@got.plt"
                    }
                ]
            },
                "quiz": {
                    "passingScore": 75,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the primary function of the Procedure Linkage Table (PLT) and Global Offset Table (GOT)?",
                            "options": [
                                "To store local variables for functions.",
                                "To facilitate dynamic linking by resolving shared library function addresses at runtime.",
                                "To handle system calls to the kernel.",
                                "To store dynamically allocated heap memory."
                            ],
                            "correct": 1,
                            "explanation": "The PLT and GOT work together to enable dynamic linking, allowing a program to find the addresses of functions in shared libraries like libc only when they are first called (lazy binding)."
                        },
                        {
                            "id": 2,
                            "question": "Which of these memory segments is typically marked as read-only and executable?",
                            "options": [
                                "The Stack",
                                "The Heap",
                                "The .bss segment",
                                "The .text segment"
                            ],
                            "correct": 3,
                            "explanation": "The .text segment contains the program's actual machine code instructions. To prevent accidental or malicious modification, it is marked read-only and executable."
                        },
                        {
                            "id": 3,
                            "question": "What is the security boundary that virtual memory enforces between processes?",
                            "options": [
                                "It prevents a process from making system calls.",
                                "It encrypts all memory used by a process.",
                                "It ensures one process cannot read or write to the memory of another process.",
                                "It limits the number of files a process can open."
                            ],
                            "correct": 2,
                            "explanation": "Virtual memory provides isolation. The OS and MMU ensure that the memory addresses used by one process map to physical RAM that is completely separate from that of other processes."
                        }
                    ]
                
            }
        },
        {
            "id": "lesson-4",
            "title": "A Survey of Modern Mitigations",
            "duration": "90 min",
            "objectives": [
                "Understand the purpose and mechanism of Stack Canaries",
                "Explain how Data Execution Prevention (DEP/NX) prevents simple shellcode execution",
                "Describe how Address Space Layout Randomization (ASLR) makes exploitation unreliable",
                "Gain a conceptual understanding of Control Flow Guard (CFG)"
            ],
            "content": {
                "overview": "As attackers developed techniques to exploit software, defenders responded by building powerful mitigations into compilers and operating systems. This lesson provides a conceptual overview of the most common defenses you will encounter. Understanding what they are and how they work is the first step to defeating them.",
                "sections": [
                    {
                        "title": "Stack Canaries: The Guard at the Gate",
                        "content": "<p>A stack canary is a secret value placed on the stack between the local variables and the saved return address. Before a function returns, it checks if this value is still intact.</p><h3>How it Works:</h3><ul><li><strong>Function Prologue:</strong> A random value (the canary) is read from a secure location and pushed onto the stack.</li><li><strong>Exploitation Attempt:</strong> A classic stack buffer overflow that aims to overwrite the return address must also overwrite the canary.</li><li><strong>Function Epilogue:</strong> Before the `ret` instruction, the function checks the canary's value against the original. If they don't match, the program assumes a buffer overflow has occurred and terminates immediately, preventing the attacker from hijacking control flow.</li></ul><h3>Bypassing:</h3><ul><li>Leaking the canary value (e.g., via a format string vulnerability).</li><li>Brute-forcing the canary (if it's not very random, or in a forking server).</li></ul>",
                        "image": "https://images.unsplash.com/photo-1614064548237-02f0d1a2b733?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "DEP / NX Bit: No Execution Allowed",
                        "content": "<p>Data Execution Prevention (DEP) is a security feature that marks certain areas of memory as non-executable. The hardware equivalent is the No-eXecute (NX) bit.</p><h3>How it Works:</h3><p>The core principle is <strong>W^X (Write XOR Execute)</strong>. A memory page can be either writable or executable, but not both. Since the stack and heap need to be writable, the OS marks them as non-executable. If the instruction pointer (RIP) ever points to an address on the stack (e.g., where an attacker has placed shellcode), the CPU will raise an exception and the program will crash. This single mitigation defeated an entire class of simple stack overflow exploits.</p><h3>Bypassing:</h3><p>Return-Oriented Programming (ROP). Instead of writing and executing new code, we reuse existing, executable code snippets ('gadgets') from the program and its libraries.</p>",
                        "image": "https://images.unsplash.com/photo-1548092372-68b6b3b231d3?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "ASLR: Hiding the Targets",
                        "content": "<p>Address Space Layout Randomization (ASLR) randomizes the base addresses of key memory areas every time a program is run.</p><h3>What it Randomizes:</h3><ul><li>The base of the stack.</li><li>The base of the heap.</li><li>The base address of shared libraries (like libc).</li><li>The base address of the main executable (if compiled as a Position-Independent Executable, PIE).</li></ul><h3>How it Works:</h3><p>Without ASLR, an attacker would know the exact address of `system()` in libc. With ASLR, that address changes on every execution. An exploit that relies on hardcoded addresses will fail. It turns a reliable exploit into an unreliable one.</p><h3>Bypassing:</h3><p>Information Leaks. An attacker must first find another vulnerability (e.g., format string, memory leak) to leak an address from a randomized region. With one leaked address (e.g., of the `puts` function), they can calculate the base address of the library and from there, the addresses of all other functions within it.</p>",
                        "image": "https://images.unsplash.com/photo-1506953835492-f78a25a7a744?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Control Flow Guard (CFG): The Next Generation",
                        "content": "<p>Control Flow Guard is a more advanced mitigation, primarily found on Windows, designed to combat code reuse attacks like ROP.</p><h3>Conceptual Overview:</h3><ul><li><strong>Valid Targets:</strong> The compiler identifies every valid target for an indirect call (e.g., the start of a function). It builds a bitmap of these valid addresses.</li><li><strong>Pre-Call Check:</strong> Before executing an indirect call (like `call [rax]`), the program executes a special check instruction.</li><li><strong>Validation:</strong> This check verifies that the target address in the register is one of the 'valid' targets listed in the bitmap. If it's not (e.g., an attacker tries to jump to the middle of a function to use a ROP gadget), the program terminates.</li></ul><p>CFG makes traditional ROP much more difficult because you can generally only call the start of functions, not arbitrary gadgets.</p>",
                        "image": "https://images.unsplash.com/photo-1521992443324-4c3d31a7b46e?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Checking Mitigations with 'checksec'",
                        "language": "bash",
                        "code": "# checksec is a tool from the pwntools suite\n\nchecksec ./my_vulnerable_binary\n\n# --- Example Output ---\n# [*] '/path/to/my_vulnerable_binary'\n#     Arch:     amd64-64-little\n#     RELRO:    Full RELRO\n#     Stack:    Canary found\n#     NX:       NX enabled\n#     PIE:      PIE enabled"
                    },
                    {
                        "title": "Demonstrating ASLR",
                        "language": "bash",
                        "code": "# Run ldd on a binary multiple times\n# Notice how the base address of libc.so.6 and ld-linux-x86-64.so.2 changes each time\n\nldd /bin/ls\n# linux-vdso.so.1 (0x00007ffc1b7f6000)\n# libselinux.so.1 => /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007f3c3b0a0000)\n# libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f3c3acb0000)\n\nldd /bin/ls\n# linux-vdso.so.1 (0x00007ffd1d9f8000)\n# libselinux.so.1 => /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007f8b9e8a0000)\n# libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f8b9e4b0000)"
                    }
                ]
            },
                "quiz": {
                    "passingScore": 75,
                    "questions": [
                        {
                            "id": 1,
                            "question": "An attacker places shellcode on the stack and overwrites the return address to point to it. Which mitigation directly prevents the shellcode from EXECUTING?",
                            "options": [
                                "ASLR",
                                "Stack Canary",
                                "DEP / NX",
                                "PIE"
                            ],
                            "correct": 2,
                            "explanation": "Data Execution Prevention (DEP) or the No-eXecute (NX) bit marks the stack as non-executable. When the CPU tries to execute instructions from the stack, it will fault, crashing the program."
                        },
                        {
                            "id": 2,
                            "question": "How does a stack canary prevent a simple stack buffer overflow from succeeding?",
                            "options": [
                                "It randomizes the location of the stack.",
                                "It encrypts the return address on the stack.",
                                "It places a secret value that gets checked before the function returns; if it's overwritten, the program aborts.",
                                "It prevents the program from writing to the stack."
                            ],
                            "correct": 2,
                            "explanation": "The stack canary acts as a tripwire. An overflow large enough to overwrite the return address must first overwrite the canary. The function checks this value before returning, and if it's changed, it halts execution."
                        },
                        {
                            "id": 3,
                            "question": "What is the primary challenge that Address Space Layout Randomization (ASLR) presents to an attacker?",
                            "options": [
                                "It makes it impossible to write to memory.",
                                "It makes the addresses of useful functions and gadgets unpredictable.",
                                "It removes useful functions like `system` from libraries.",
                                "It detects and stops buffer overflows before they happen."
                            ],
                            "correct": 1,
                            "explanation": "ASLR randomizes the base addresses of the stack, heap, and libraries. This means an attacker cannot rely on hardcoded addresses for their ROP chains or for jumping to functions like `system`."
                        }
                    ]
                
            }
        },
        {
            "id": "lesson-5",
            "title": "Introduction to Return-Oriented Programming (ROP)",
            "duration": "150 min",
            "objectives": [
                "Understand the theory behind code reuse attacks",
                "Effectively defeat a Non-Executable (NX) stack",
                "Find and chain 'gadgets' to perform useful actions",
                "Build a simple, manual ROP chain to call a function"
            ],
            "content": {
                "overview": "Data Execution Prevention (DEP/NX) stopped us from running our own shellcode on the stack. But what if we don't need our own code? This lesson introduces Return-Oriented Programming (ROP), the foundational technique for modern exploitation. We will learn to reuse small snippets of the program's own executable code to achieve our goals, effectively bypassing NX.",
                "sections": [
                    {
                        "title": "The Theory of Code Reuse",
                        "content": "<p>The core idea of ROP is simple: if we cannot write our own code to the stack and execute it, we will instead turn the stack into a series of pointers to existing, executable code. The stack becomes a new program, executed by the `ret` instruction.</p><h3>What is a Gadget?</h3><ul><li>A gadget is a small sequence of one or more useful assembly instructions that already exists in the program's `.text` segment (which is executable).</li><li>Crucially, every gadget must end with a `ret` instruction.</li><li>When we overwrite the return address, we point it to our first gadget. After that gadget's instructions execute, its `ret` instruction will pop the next address off our controlled stack into RIP, jumping to our second gadget. This forms a 'ROP chain'.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1510511459019-5dda7724fd87?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Finding Gadgets",
                        "content": "<p>To build a ROP chain, you first need to find useful gadgets within the binary and its loaded libraries. Tools are essential for this process.</p><h3>Popular Gadget-Finding Tools:</h3><ul><li><strong>ROPgadget:</strong> A powerful and easy-to-use Python-based tool. It can search a binary for all kinds of gadgets (e.g., `pop rdi; ret`, `mov rax, rcx; ret`, etc.).</li><li><strong>ropper:</strong> Another excellent command-line gadget finder with similar functionality.</li></ul><p>The most fundamental gadget we need for calling functions on x86-64 is `pop rdi; ret`. This allows us to pop a value from our controlled stack into the RDI register, which is used to pass the first argument to functions in the System V ABI.</p>",
                        "image": "https://images.unsplash.com/photo-1521185496955-15097b20c5fe?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Building a Simple ROP Chain (ret2win)",
                        "content": "<p>Let's imagine a simple scenario where a binary has a hidden function called `win()` that we want to call. The binary is protected by NX, but not ASLR or canaries.</p><h3>The Strategy:</h3><ol><li>Find the offset to overwrite the return address using a pattern from `cyclic`.</li><li>Find the address of the `win()` function using `objdump`, `gdb`, or `readelf`.</li><li>Craft a payload that consists of padding to fill the buffer, followed by the 8-byte address of `win()`.</li></ol><p>When the vulnerable function returns, instead of its original return address, it will pop the address of `win()` into RIP, and execution will be redirected.</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Calling system('/bin/sh')</strong></div><p>A more realistic goal is to call `system(\"/bin/sh\")`. To do this, our ROP chain would need to:</p><ol><li>Find a `pop rdi; ret` gadget.</li><li>Find the address of the string `\"/bin/sh\"` within the program or a library.</li><li>Find the address of the `system` function.</li><li>Build the chain: `[addr of pop rdi; ret]` -> `[addr of \"/bin/sh\"]` -> `[addr of system]`</li></ol></div>",
                        "image": "https://images.unsplash.com/photo-1544256718-3b62ff58238d?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Finding Gadgets with ROPgadget",
                        "language": "bash",
                        "code": "# Search for all gadgets in a binary\nROPgadget --binary ./vulnerable_binary\n\n# Search for a specific gadget\nROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 | grep \"pop rdi\"\n\n# Example Output:\n# 0x000000000002155f : pop rdi ; ret"
                    },
                    {
                        "title": "Pwntools Script for a Simple ret2win",
                        "language": "python",
                        "code": "from pwn import *\n\n# Target binary information\nelf = context.binary = ELF('./ret2win_binary')\np = process()\n\n# We found the offset to be 40 bytes\npadding = b'A' * 40\n\n# Get the address of the 'win' function from the ELF file\nwin_address = elf.symbols.win\n\n# Build the payload\nrop_chain = p64(win_address)\npayload = padding + rop_chain\n\n# Send the payload\np.sendline(payload)\n\n# Receive the output\nprint(p.recvall().decode())"
                    }
                ]
            },
                "quiz": {
                    "passingScore": 75,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the primary security mitigation that Return-Oriented Programming (ROP) is designed to bypass?",
                            "options": [
                                "ASLR (Address Space Layout Randomization)",
                                "Stack Canaries",
                                "DEP / NX (Data Execution Prevention)",
                                "PIE (Position-Independent Executable)"
                            ],
                            "correct": 2,
                            "explanation": "DEP/NX prevents code execution on the stack. ROP bypasses this by not executing code *on* the stack, but by using the stack to point to existing, legitimate code snippets (gadgets) in executable memory."
                        },
                        {
                            "id": 2,
                            "question": "What is the defining characteristic of a ROP gadget?",
                            "options": [
                                "It must start with a `push` instruction.",
                                "It must perform a mathematical calculation.",
                                "It must end with a `ret` instruction.",
                                "It must be located on the stack."
                            ],
                            "correct": 2,
                            "explanation": "The `ret` instruction is what makes ROP possible. It pops the address of the next gadget from the stack into the instruction pointer, allowing gadgets to be chained together."
                        },
                        {
                            "id": 3,
                            "question": "To call the function `system(\"/bin/sh\")` on x86-64 Linux, what is the most essential gadget you need to find first?",
                            "options": [
                                "`pop rax ; ret`",
                                "`mov [rdi], rsi ; ret`",
                                "`pop rdi ; ret`",
                                "`syscall ; ret`"
                            ],
                            "correct": 2,
                            "explanation": "The System V AMD64 ABI requires the first argument to a function to be placed in the RDI register. The `pop rdi ; ret` gadget allows us to control the value of RDI by placing the desired value (the address of '/bin/sh') on the stack right after the gadget's address."
                        }
                    ]
                
            }
        },
        {
            "id": "lesson-6",
            "title": "Advanced ROP & Bypassing ASLR",
            "duration": "180 min",
            "objectives": [
                "Understand how information leaks defeat ASLR",
                "Use a known function address to calculate the base address of a library",
                "Construct a 'ret2libc' attack to call arbitrary library functions",
                "Combine an information leak and a ROP chain to defeat both NX and ASLR"
            ],
            "content": {
                "overview": "Our previous ROP chains relied on knowing the exact addresses of our gadgets and functions. Address Space Layout Randomization (ASLR) makes this impossible by randomizing library base addresses. In this lesson, we'll learn how to defeat ASLR using an information leak, leading to the powerful and common `ret2libc` attack.",
                "sections": [
                    {
                        "title": "The Power of Information Leaks",
                        "content": "<p>ASLR randomizes the base address, but it does not change the *offsets* between functions within a library. For example, the distance between the `puts` function and the `system` function in a specific version of libc is always the same.</p><h3>The Strategy:</h3><ol><li><strong>Find a Leak:</strong> The target program must have a vulnerability that prints out or 'leaks' a memory address. Often, this is a function that prints more data than it should, revealing a pointer on the stack (e.g., a saved GOT address of a libc function).</li><li><strong>Identify the Leak:</strong> We identify what the leaked address points to. For example, we leak the runtime address of `puts`.</li><li><strong>Calculate the Base:</strong> We look up the standard offset of `puts` in its version of libc. By subtracting this offset from the leaked runtime address, we find the base address of libc for this specific execution. `(libc_base = leaked_puts_addr - puts_offset)`</li><li><strong>Calculate Target Addresses:</strong> Now that we have the libc base address, we can calculate the runtime address of *any* function or string within that library. `(runtime_system_addr = libc_base + system_offset)`</li></ol>",
                        "image": "https://images.unsplash.com/photo-1526374965328-5f61d25c16c6?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The 'ret2libc' Attack",
                        "content": "<p>A `ret2libc` attack is a ROP chain that calls functions from a dynamically linked library, typically `libc`, which is loaded into almost every Linux process and contains powerful functions like `system`.</p><h3>Two-Stage Exploit:</h3><p>An exploit that bypasses both NX and ASLR usually requires two stages executed in a single run:</p><ul><li><strong>Stage 1: Leak the Address.</strong> We overflow a buffer to hijack control, but our first ROP chain doesn't aim for a shell. Instead, it calls a function like `puts` to print the contents of a GOT entry. For example, we call `puts(puts@got.plt)`. This prints the runtime address of `puts` back to us. After this chain runs, we need to return execution to a safe place, usually the beginning of the `main` function, to get a second chance to overflow.</li><li><strong>Stage 2: Get the Shell.</strong> Our script receives the leaked address, calculates the libc base, and then calculates the address of `system` and the string `\"/bin/sh\"`. It then triggers the vulnerability a second time, sending a new ROP chain built with the now-known addresses to pop a shell.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1618498082410-b4aa22193b38?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Finding Function Offsets in Libc",
                        "language": "bash",
                        "code": "# Using readelf to find symbol offsets in a specific libc version\n\nreadelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep ' system@'\n#  1457: 000000000004f440    45 FUNC    WEAK   DEFAULT   13 system@@GLIBC_2.2.5\n\nreadelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep ' puts@'\n#  748: 00000000000809c0   135 FUNC    WEAK   DEFAULT   13 puts@@GLIBC_2.2.5"
                    },
                    {
                        "title": "Pwntools Script for ret2libc with Leak",
                        "language": "python",
                        "code": "from pwn import *\n\nelf = context.binary = ELF('./aslr_nx_vulnerable')\nrop = ROP(elf)\np = process()\n\n# We need the local libc to calculate offsets\nlibc = ELF('/lib/x86_64-linux-gnu/libc.so.6')\n\n# STAGE 1: Leak the address of 'puts'\n\n# Gadget to pop address into RDI (for the argument to puts)\npop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]\n\n# Address of puts in the PLT (to call it) and GOT (to leak it)\nputs_plt = elf.plt['puts']\nputs_got = elf.got['puts']\n\n# We need to return to main after the leak\nmain_addr = elf.symbols['main']\n\npadding = b'A' * 72\n\n# ROP chain: pop rdi, puts@got, call puts@plt, return to main\nrop_chain_leak = p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main_addr)\n\np.sendline(padding + rop_chain_leak)\np.recvline() # Discard banner\n\n# Receive and parse the leak\nleaked_puts = u64(p.recvline().strip().ljust(8, b'\\x00'))\nlog.info(f'Leaked puts address: {hex(leaked_puts)}')\n\n# STAGE 2: Calculate addresses and pop a shell\n\nlibc.address = leaked_puts - libc.symbols['puts']\nlog.info(f'Calculated libc base: {hex(libc.address)}')\n\n# Now we can find the real addresses\nsystem_addr = libc.symbols['system']\nbin_sh_addr = next(libc.search(b'/bin/sh'))\n\n# ROP chain: pop rdi, '/bin/sh', call system, (optional exit)\nrop_chain_shell = p64(pop_rdi) + p64(bin_sh_addr) + p64(system_addr)\n\np.sendline(padding + rop_chain_shell)\np.interactive()"
                    }
                ]
            },
                "quiz": {
                    "passingScore": 75,
                    "questions": [
                        {
                            "id": 1,
                            "question": "If ASLR is enabled, what remains constant between different executions of a program?",
                            "options": [
                                "The base address of libc.",
                                "The address of the stack.",
                                "The offsets between functions within libc.",
                                "The address of the heap."
                            ],
                            "correct": 2,
                            "explanation": "ASLR randomizes the base address where a library is loaded, but the internal layout of the library is fixed. The distance (offset) from `puts` to `system` is always the same for a given libc.so file."
                        },
                        {
                            "id": 2,
                            "question": "In a ret2libc attack, if you leak the runtime address of `puts` and know its offset, how do you calculate the base address of libc?",
                            "options": [
                                "`libc_base = leaked_puts_addr + puts_offset`",
                                "`libc_base = leaked_puts_addr - puts_offset`",
                                "`libc_base = leaked_puts_addr * puts_offset`",
                                "`libc_base = puts_offset - leaked_puts_addr`"
                            ],
                            "correct": 1,
                            "explanation": "The runtime address is the sum of the base address and the offset. Therefore, to find the base, you subtract the known offset from the leaked runtime address."
                        },
                        {
                            "id": 3,
                            "question": "Why is it often necessary for a ret2libc exploit to return to `main` after the initial leak?",
                            "options": [
                                "To clean up the stack.",
                                "To cause the program to run faster.",
                                "To get a second opportunity to trigger the buffer overflow with a new payload.",
                                "To close any open files."
                            ],
                            "correct": 2,
                            "explanation": "The exploit is typically a two-stage process. The first stage leaks an address and returns control to the program. By returning to `main`, the program re-executes the vulnerable code, allowing the attacker's script (which now knows the libc base) to send the second, shell-spawning payload."
                        }
                    ]
                
            }
        },
        {
            "id": "lesson-7",
            "title": "Defeating Stack Canaries",
            "duration": "120 min",
            "objectives": [
                "Understand precisely how stack canaries protect the return address",
                "Learn techniques to bypass canaries, such as leaking their value",
                "Recognize scenarios where canaries can be brute-forced",
                "Combine techniques to defeat Canary, ASLR, and NX simultaneously"
            ],
            "content": {
                "overview": "We've bypassed NX with ROP and ASLR with information leaks. The final major stack protection is the stack canary. This lesson focuses on understanding and defeating this 'tripwire' mitigation. Mastering this allows us to compromise binaries protected by the full suite of common stack defenses.",
                "sections": [
                    {
                        "title": "Anatomy of a Stack Canary",
                        "content": "<p>A stack canary is a secret, random value placed on the stack right before the saved RBP and the return address. In x86-64 Linux, this value is typically read from the `fs` segment register.</p><h3>The Check:</h3><p>At the end of a function, just before the `leave` and `ret` instructions, the compiler inserts code to check the canary. It compares the value on the stack with the original secret value. If they differ, it means the stack has been smashed, and the program calls `__stack_chk_fail`, which terminates the process immediately. This prevents our exploit from ever reaching the `ret` instruction.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>The Null Byte</strong></div><p>A crucial feature of canaries on x86-64 is that their first byte is always a null byte (`\\x00`). This is designed to terminate string-based overflows (e.g., using `strcpy`). To overwrite the return address, our overflow must also write a null byte, which can be tricky with some functions.</p></div>",
                        "image": "https://images.unsplash.com/photo-1555949963-aa79dcee981c?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Bypassing Canaries: Leaking",
                        "content": "<p>The most common way to defeat a canary is to leak it. If we can read the canary's value, we can simply include it in our payload. When the check occurs, the value on the stack will match the secret value, and the check will pass, allowing execution to proceed to our controlled return address.</p><h3>How to Leak:</h3><ul><li><strong>Format String Vulnerability:</strong> A format string bug can be used to read arbitrary data from the stack. By providing format specifiers like `%p`, we can walk up the stack and print the canary's value.</li><li><strong>Arbitrary Read:</strong> Any vulnerability that allows reading data at an arbitrary offset from a buffer on the stack can be used. If a function prints more bytes than intended, it might print the canary along with the buffer content.</li></ul><h3>The Exploit Flow:</h3><p>A full exploit against all three mitigations becomes a multi-stage process: 1. Leak a libc address to defeat ASLR. 2. Leak the canary value. 3. Send the final payload containing: `[Padding] + [Leaked Canary] + [Padding for RBP] + [ROP Chain]`.</p>",
                        "image": "https://images.unsplash.com/photo-1542903660-eedba2cda473?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Other Bypasses: Brute-Forcing",
                        "content": "<p>In some specific scenarios, leaking is not necessary. We can guess the canary byte-by-byte.</p><h3>When Brute-Forcing Works:</h3><ul><li><strong>Forking Servers:</strong> When a network server `fork()`s to handle a new connection, the child process inherits the exact memory space of the parent, including the canary value. The canary does not change between connections.</li><li><strong>Byte-by-Byte Guessing:</strong> We can send a payload that overwrites the buffer and the first byte of the canary. If the program crashes, our guess was wrong. If it doesn't crash (e.g., it just closes the connection), our guess was right! We repeat this process for all bytes of the canary (excluding the null byte). This is slow but effective when leaking is not an option.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1599507593498-52ed8a45e755?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Conceptual Canary Leak Script",
                        "language": "python",
                        "code": "from pwn import *\n\n# Assume we have a vulnerability that lets us read N bytes past a buffer\np = process('./canary_vulnerable')\n\n# Send a specific length of input to just touch the canary\np.sendline(b'A' * 40)\n\n# Receive the output which includes the buffer + the canary\np.recvuntil(b'A' * 40)\n\n# The next 8 bytes are the canary. The first is \\x00.\ncanary = u64(b'\\x00' + p.recv(7))\nlog.info(f'Leaked canary: {hex(canary)}')\n\n# Now, construct the final payload\npadding = b'A' * 40\nrbp_padding = b'B' * 8\nrop_chain = p64(0xdeadbeef) # Our ROP chain starts here\n\npayload = padding + p64(canary) + rbp_padding + rop_chain\np.sendline(payload)\n\np.interactive()"
                    }
                ]
            },
                "quiz": {
                    "passingScore": 75,
                    "questions": [
                        {
                            "id": 1,
                            "question": "Where is the stack canary placed in a function's stack frame?",
                            "options": [
                                "At the very top of the stack.",
                                "After the function's return address.",
                                "Between the local variables and the saved frame pointer/return address.",
                                "On the heap."
                            ],
                            "correct": 2,
                            "explanation": "The canary is strategically placed to protect the saved RBP and return address. Any linear buffer overflow originating from local variables must overwrite the canary before it can reach the return address."
                        },
                        {
                            "id": 2,
                            "question": "What happens when the canary check fails?",
                            "options": [
                                "The program continues execution but logs an error.",
                                "The program calls `__stack_chk_fail` and terminates immediately.",
                                "The program jumps to the attacker's shellcode.",
                                "The operating system reboots."
                            ],
                            "correct": 1,
                            "explanation": "The entire purpose of the canary is to act as a fail-safe. Upon detecting a mismatch, the program is halted to prevent the attacker from gaining control of the instruction pointer via the corrupted return address."
                        },
                        {
                            "id": 3,
                            "question": "If you cannot leak the canary, under what condition could you potentially brute-force it?",
                            "options": [
                                "If ASLR is disabled.",
                                "In a forking network server where the canary value is the same for each new connection.",
                                "If the program is statically linked.",
                                "If DEP/NX is disabled."
                            ],
                            "correct": 1,
                            "explanation": "Brute-forcing requires trial and error. In a forking server, the child process is a clone of the parent, so the canary remains the same across connections. This allows an attacker to make many guesses, one byte at a time, to discover the canary value."
                        }
                    ]
                
            }
        },
        {
            "id": "lesson-8",
            "title": "Heap Internals (ptmalloc for GLIBC)",
            "duration": "180 min",
            "objectives": [
                "Understand the roles of malloc and free in dynamic memory management",
                "Visualize the structure of a memory 'chunk' including its metadata",
                "Learn about the different bin types (tcache, fastbins, smallbins, etc.) and their purpose",
                "Use GDB to inspect the state of the heap during allocations and frees"
            ],
            "content": {
                "overview": "We now move from the structured, last-in-first-out world of the stack to the far more complex and dynamic world of the heap. The heap is where programs request memory at runtime. Understanding its internal data structures, managed by allocators like `ptmalloc` in GLIBC, is the first step to exploiting heap-based vulnerabilities.",
                "sections": [
                    {
                        "title": "Chunks: The Building Blocks of the Heap",
                        "content": "<p>The heap is not a monolithic block of memory. It is divided into 'chunks'. Each chunk has a header containing metadata, followed by the user-data area that is returned to the programmer.</p><h3>Chunk Structure (64-bit):</h3><ul><li><strong>`prev_size` (8 bytes):</strong> The size of the previous chunk in memory, if it is free.</li><li><strong>`size` (8 bytes):</strong> The size of the current chunk. The last three bits are flags (A, M, P). P (PREV_INUSE) is the most important, indicating if the previous chunk is allocated.</li><li><strong>User Data:</strong> The memory area returned by `malloc`.</li><li><strong>When free:</strong> The user data area is repurposed to store pointers (`fd` for forward, `bk` for backward) to other free chunks in a doubly-linked list.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1504229618473-9da541e2e185?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Bins: Organizing Free Chunks",
                        "content": "<p>When a chunk is `free()`d, the memory allocator doesn't return it to the OS immediately. Instead, it places it into a 'bin'a list of free chunks of similar sizes. This makes subsequent `malloc()` requests faster if a suitable free chunk is already available.</p><h3>Major Bin Types in Modern GLIBC (ptmalloc2):</h3><ul><li><strong>Tcache (Thread-Local Cache):</strong> A per-thread cache for small chunks. It's a singly-linked list and is checked first for extreme speed. It has minimal security checks, making it a prime target for exploitation.</li><li><strong>Fastbins:</strong> Another high-speed cache for small chunks, also a singly-linked list.</li><li><strong>Small Bins:</strong> A set of doubly-linked lists for small-sized chunks. Chunks in small bins can be consolidated with their neighbors if they are also free.</li><li><strong>Large Bins:</strong> A set of doubly-linked lists for large chunks. Chunks here are not sorted by size perfectly, which has interesting properties.</li><li><strong>Unsorted Bin:</strong> A temporary holding area for freed chunks before they are sorted into the small or large bins.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1549617322-159472a397de?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Visualizing the Heap with GDB",
                        "content": "<p>It is nearly impossible to understand heap exploitation without looking at the heap in a debugger. GDB extensions like Pwndbg and GEF provide powerful commands to visualize the heap's state.</p><h3>Useful Pwndbg Commands:</h3><ul><li><strong>`heap` or `heap chunks`:</strong> Displays all the chunks in the current heap segment.</li><li><strong>`bins` or `heap bins`:</strong> Shows the state of all the bins (tcache, fastbins, etc.) and the chunks they contain.</li><li><strong>`vis_heap_chunks`:</strong> Provides a more graphical layout of the heap chunks.</li></ul><p>By setting breakpoints on `malloc` and `free` and using these commands, you can step through a program and observe exactly how the heap's data structures change with each operation. This is a critical skill for debugging heap exploits.</p>",
                        "image": "https://images.unsplash.com/photo-1589987879922-263a23a854cb?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Simple C program for Heap Inspection",
                        "language": "c",
                        "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    void *a, *b, *c, *d;\n\n    // Allocate some chunks\n    a = malloc(0x10);\n    b = malloc(0x20);\n    c = malloc(0x30);\n\n    // Free a chunk, it goes into tcache\n    free(a);\n\n    // Allocate another chunk, which will be served from tcache\n    d = malloc(0x10);\n\n    return 0;\n}"
                    },
                    {
                        "title": "Debugging Session with GDB/Pwndbg",
                        "language": "bash",
                        "code": "gdb ./heap_example\n\n(gdb) break 11 # Break after the first set of allocations\n(gdb) run\n\n# Inspect the heap chunks\n(pwndbg) heap chunks\n# ... output showing chunks a, b, and c as allocated ...\n\n(gdb) break 14 # Break after freeing 'a'\n(gdb) continue\n\n# Inspect the bins, 'a' should be in a tcache bin\n(pwndbg) heap bins tcache\n# ... output showing chunk 'a' in the tcache ...\n\n(gdb) break 17 # Break after allocating 'd'\n(gdb) continue\n\n# Inspect the heap again. 'd' will have the same address as 'a' did.\n(pwndbg) heap chunks"
                    }
                ]
            },
                "quiz": {
                    "passingScore": 75,
                    "questions": [
                        {
                            "id": 1,
                            "question": "In the GLIBC heap implementation, what is a 'chunk'?",
                            "options": [
                                "A list of free memory blocks.",
                                "A block of memory consisting of metadata (like size) and user data.",
                                "A special area reserved for the operating system.",
                                "The total amount of memory available to a process."
                            ],
                            "correct": 1,
                            "explanation": "The heap is managed as a collection of chunks. Each chunk contains a header with metadata (size, flags) and a data area that is returned to the user by malloc."
                        },
                        {
                            "id": 2,
                            "question": "What is the primary purpose of 'bins' in the heap allocator?",
                            "options": [
                                "To store executable code.",
                                "To track all allocated memory for security auditing.",
                                "To keep lists of free chunks of similar sizes to satisfy future allocation requests quickly.",
                                "To separate stack memory from heap memory."
                            ],
                            "correct": 2,
                            "explanation": "Bins are essentially free lists. When memory is freed, it's sorted into a bin based on its size. This makes subsequent malloc calls much faster as the allocator can just grab a chunk from the appropriate bin instead of asking the OS for more memory."
                        },
                        {
                            "id": 3,
                            "question": "Which type of bin is a per-thread, singly-linked list cache that is checked first and has minimal security checks, making it a common exploitation target?",
                            "options": [
                                "Large Bins",
                                "Small Bins",
                                "Unsorted Bin",
                                "Tcache"
                            ],
                            "correct": 3,
                            "explanation": "The Tcache (Thread-Local Cache) was introduced to improve performance in multi-threaded applications. Its focus on speed means it has fewer integrity checks, which attackers can abuse to perform powerful attacks like tcache poisoning."
                        }
                    ]
                
            }
        },
        {
            "id": "lesson-9",
            "title": "Classic Heap Vulnerabilities",
            "duration": "150 min",
            "objectives": [
                "Understand and identify Use-After-Free (UAF) vulnerabilities",
                "Recognize the dangers of a Double Free",
                "Exploit different types of Heap Overflows",
                "Achieve arbitrary code execution through a UAF vulnerability"
            ],
            "content": {
                "overview": "With a solid understanding of heap internals, we can now explore the classic vulnerabilities that arise from the incorrect management of dynamic memory. This lesson covers the most common and impactful types of heap bugs: Use-After-Free, Double Free, and Heap Overflows. We will learn how these logical errors can be turned into powerful exploitation primitives.",
                "sections": [
                    {
                        "title": "Use-After-Free (UAF)",
                        "content": "<p>A Use-After-Free vulnerability occurs when a program continues to use a pointer to a piece of memory after it has been `free()`'d.</p><h3>The Attack Flow:</h3><ol><li>A program allocates an object with a function pointer (or other critical data) and stores a pointer to it.</li><li>The object is `free()`d, but the pointer to it (now a 'dangling pointer') is not cleared. The freed chunk is placed in a bin (e.g., tcache).</li><li>The attacker triggers another `malloc()` of the *same size*. The allocator, for efficiency, returns the exact same chunk of memory that was just freed.</li><li>The attacker fills this new allocation with their own controlled data.</li><li>The program, through the original dangling pointer, accesses the memory again. It thinks it's accessing the old object, but it's actually accessing the attacker's controlled data. If it tries to call a function pointer from this data, the attacker gains control of RIP.</li></ol>",
                        "image": "https://images.unsplash.com/photo-1507722226383-a752b9a29486?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Double Free",
                        "content": "<p>A double free occurs when `free()` is called more than once on the same pointer without an intervening `malloc()`.</p><h3>Why it's Dangerous:</h3><p>In older versions of libc, this could lead to arbitrary write primitives via a technique called 'unsafe unlinking'. In modern libc, the most common exploitation path is through the tcache. If you `free(A)` and then `free(A)` again, the tcache bin will look like this: `A -> A -> ...`. When you `malloc()` twice, you will get the same chunk `A` returned to you twice. This gives you two valid pointers to the same memory, which can often be abused to create more complex attacks, like tcache poisoning.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Modern Defenses</strong></div><p>Modern allocators have checks to prevent simple double frees. For example, the tcache will check if the chunk being freed is already at the head of the bin. Exploits often require more complex arrangements, like freeing A, then B, then A again to bypass these checks.</p></div>",
                        "image": "https://images.unsplash.com/photo-1614741118884-6562b634883a?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Heap Overflow",
                        "content": "<p>Similar to a stack overflow, a heap overflow occurs when a program writes more data into a heap chunk than it can hold. This corrupts the metadata of the *next* chunk in memory.</p><h3>Exploitation:</h3><ul><li><strong>Overflowing the size field:</strong> By overwriting the `size` field of the next chunk, an attacker can create fake, overlapping chunks. When the program later frees or allocates chunks in this corrupted region, it can lead to memory disclosure or arbitrary write.</li><li><strong>Off-by-one:</strong> A common variant where the overflow is only one byte. This is often enough to overwrite the `PREV_INUSE` bit of the next chunk's size field, tricking the allocator into thinking the previous chunk is free and causing it to consolidate, which can be exploited.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1542831371-d531d36971ad?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Vulnerable C Code for Use-After-Free",
                        "language": "c",
                        "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef void (*func_ptr)();\n\nstruct user {\n    char name[16];\n    func_ptr say_hello;\n};\n\nvoid hello() {\n    printf(\"Hello, user!\\n\");\n}\n\nvoid shell() {\n    system(\"/bin/sh\");\n}\n\nint main() {\n    struct user *u = malloc(sizeof(struct user));\n    strcpy(u->name, \"normal_user\");\n    u->say_hello = hello;\n\n    u->say_hello(); // Prints \"Hello, user!\"\n\n    free(u);\n\n    // Vulnerability: 'u' is not set to NULL\n\n    char *attacker_data = malloc(sizeof(struct user));\n    strcpy(attacker_data, \"AAAAAAAAAAAAAAAA\"); // padding\n    *(long long*)(attacker_data + 16) = (long long)shell; // overwrite func_ptr\n\n    u->say_hello(); // UAF! This will now call shell()\n\n    return 0;\n}"
                    }
                ]
            },
                "quiz": {
                    "passingScore": 75,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the core condition for a Use-After-Free (UAF) vulnerability?",
                            "options": [
                                "Calling `malloc` too many times.",
                                "A program using a pointer to memory after that memory has been deallocated via `free`.",
                                "Writing past the boundary of a heap chunk.",
                                "Freeing the same pointer twice."
                            ],
                            "correct": 1,
                            "explanation": "A UAF occurs because the program retains a 'dangling pointer' to a freed memory region. When that memory is re-allocated for a different purpose, the program's use of the old pointer can lead to type confusion and exploitation."
                        },
                        {
                            "id": 2,
                            "question": "A heap overflow primarily corrupts the metadata of which chunk?",
                            "options": [
                                "The currently allocated chunk.",
                                "A random chunk in a different bin.",
                                "The chunk immediately following it in memory.",
                                "The chunk immediately preceding it in memory."
                            ],
                            "correct": 2,
                            "explanation": "A heap overflow writes past the allocated data area and into the header of the next adjacent chunk in physical memory, corrupting its size and in-use flags."
                        },
                        {
                            "id": 3,
                            "question": "What is a common result of a successful Double Free exploit on modern systems with tcache?",
                            "options": [
                                "The program immediately crashes without any chance for exploitation.",
                                "The allocator returns pointers to the same memory region twice, allowing the attacker to write to it while the program also has a valid pointer to it.",
                                "All heap memory becomes non-writable.",
                                "The operating system kernel panics."
                            ],
                            "correct": 1,
                            "explanation": "A double free can corrupt the tcache's singly-linked list, causing it to add the same chunk twice. This allows an attacker to request the same memory chunk twice, which is a powerful primitive for further attacks."
                        }
                    ]
                
            }
        },
        {
            "id": "lesson-10",
            "title": "Advanced Heap Manipulation",
            "duration": "180 min",
            "objectives": [
                "Understand and execute a tcache poisoning attack",
                "Learn the mechanics of a fastbin attack (corruption)",
                "Grasp the concept of 'unsafe unlinking' in older libc versions",
                "Use a Double Free to gain an arbitrary write primitive and hijack control flow"
            ],
            "content": {
                "overview": "Now that we know the basic heap vulnerabilities, we can learn the advanced techniques used to turn them into powerful primitives like arbitrary write. This lesson focuses on specific, named attacks against heap allocator data structures, primarily the tcache and fastbins, which are designed to achieve code execution.",
                "sections": [
                    {
                        "title": "Tcache Poisoning",
                        "content": "<p>Tcache poisoning is one of the most powerful and straightforward heap exploitation techniques on modern Linux systems. It abuses a double free to trick `malloc` into returning a pointer to an arbitrary memory location, such as the GOT entry for a function.</p><h3>The Attack Flow:</h3><ol><li>Allocate three chunks, A, B, and C.</li><li>Free A, then free B. The tcache bin for this size now looks like `B -> A`.</li><li>Free A again (a double free). This is a violation, but some allocator versions might allow it, or it can be achieved with intermediate allocations. The bin now looks like `A -> B -> A`.</li><li>Now, `malloc` three times. You will receive pointers to A, then B, then A again.</li><li>With the second pointer to A, we can now modify its `fd` (forward) pointer, which is stored in the user data section. We overwrite `A->fd` with the address of our target (e.g., `&__free_hook` or a GOT entry).</li><li>The tcache bin now looks like `A -> TARGET_ADDRESS`.</li><li>When we `malloc` one more time, the allocator will return a pointer to `TARGET_ADDRESS`. We can now write our own data (like the address of a `win` function or `system`) directly into that sensitive location.</li></ol>",
                        "image": "https://images.unsplash.com/photo-1547637581-8173514978a3?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Fastbin Attack (Corruption)",
                        "content": "<p>This is a similar technique that applies to the fastbin mechanism. It also typically relies on a double free. The goal is to make the fastbin's free list point to a fake chunk that you've crafted in a different memory location (e.g., in the data segment).</p><h3>The Goal:</h3><p>By controlling the `fd` pointer of a freed fastbin chunk, you can make the head of the fastbin list point to a fake chunk. The fake chunk's size field must be crafted to pass the allocator's checks. If successful, a subsequent `malloc` will return a pointer to your fake chunk, giving you control over a piece of memory that overlaps with other important data structures.</p>",
                        "image": "https://images.unsplash.com/photo-1590595969349-82386292395d?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Unsafe Unlinking (Historical)",
                        "content": "<p>In older versions of GLIBC, when a chunk was freed and consolidated with its neighbors, the allocator performed a doubly-linked list removal operation (`unlink`). This operation was: `FD->bk = BK; BK->fd = FD;` where FD is the forward pointer and BK is the backward pointer.</p><h3>The Vulnerability:</h3><p>If an attacker could corrupt the FD and BK pointers of a free chunk before it was unlinked, they could control the values written by this operation. By setting `FD` to `target_addr - 0x18` and `BK` to `target_addr - 0x10`, the unlink macro would effectively write `target_addr` into `target_addr`. This gave the attacker an arbitrary write primitive. This specific vulnerability has been patched for many years with checks on the list pointers, but the concept of abusing list manipulation is a recurring theme in heap exploitation.</p>",
                        "image": "https://images.unsplash.com/photo-1621237084537-8a430c8b6a4a?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Pwntools Script for Tcache Poisoning",
                        "language": "python",
                        "code": "from pwn import *\n\nelf = context.binary = ELF('./tcache_poison_vuln')\np = process()\n\n# This binary has a function to allocate and a function to free by index\ndef allocate(size, data):\n    # ... function implementation ...\n\ndef free(index):\n    # ... function implementation ...\n\n# Target we want to overwrite, e.g., a global variable holding a function pointer\ntarget_addr = elf.symbols['target_func_ptr']\n\n# Perform the double free\nallocate(0x20, b'A') # index 0\nallocate(0x20, b'B') # index 1\nfree(0)\nfree(1)\nfree(0) # Double free\n\n# Malloc a chunk, it will be the original chunk 0\n# Overwrite its 'fd' pointer with our target address\nallocate(0x20, p64(target_addr)) # index 2\n\n# Malloc two more times\nallocate(0x20, b'C') # index 3, points to chunk 1\n\n# The next malloc will return our target address!\nwin_func_addr = elf.symbols['win']\nallocate(0x20, p64(win_func_addr)) # index 4, writes win_func_addr to target_addr\n\n# Now, when the program calls the function pointer, it executes win()\np.sendline(b'callit')\np.interactive()"
                    }
                ]
            },
                "quiz": {
                    "passingScore": 75,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the immediate goal of a Tcache Poisoning attack?",
                            "options": [
                                "To crash the program by creating a corrupted list.",
                                "To cause `malloc` to return a pointer to an arbitrary, attacker-chosen memory location.",
                                "To fill the entire heap with attacker-controlled data.",
                                "To leak the base address of the libc library."
                            ],
                            "correct": 1,
                            "explanation": "Tcache poisoning corrupts the `fd` (forward) pointer of a freed chunk in the tcache bin. By pointing it to a sensitive address (like a GOT entry), the attacker can make the next `malloc` call return that address, achieving a powerful arbitrary write."
                        },
                        {
                            "id": 2,
                            "question": "Which vulnerability is most commonly used as a prerequisite for a tcache poisoning attack?",
                            "options": [
                                "Stack Overflow",
                                "Format String Vulnerability",
                                "Integer Overflow",
                                "Double Free"
                            ],
                            "correct": 3,
                            "explanation": "A double free is the classic way to manipulate the tcache's singly-linked list, allowing an attacker to get a pointer to a chunk that is still in the free list, which in turn allows them to overwrite its `fd` pointer."
                        },
                        {
                            "id": 3,
                            "question": "The historical 'unsafe unlinking' attack exploited the logic of which data structure operation?",
                            "options": [
                                "Singly-linked list insertion.",
                                "Doubly-linked list removal.",
                                "Binary tree rotation.",
                                "Hash table lookup."
                            ],
                            "correct": 1,
                            "explanation": "Unsafe unlinking worked by corrupting the forward (FD) and backward (BK) pointers of a chunk in a doubly-linked list (used by small and large bins). The macro used to remove the chunk from the list would then write a pointer to a location of the attacker's choosing."
                        }
                    ]
                
            }
        },
        {
            "id": "lesson-11",
            "title": "Windows Architecture & Tooling",
            "duration": "120 min",
            "objectives": [
                "Understand key components of the Windows architecture like the Win32 API and PE file format",
                "Learn about Structured Exception Handling (SEH) and its role in program execution",
                "Get hands-on experience using WinDbg for debugging Windows applications",
                "Differentiate between Linux and Windows exploit development environments"
            ],
            "content": {
                "overview": "We now transition from the Linux environment to Windows. While many core concepts like buffer overflows and ROP are universal, the implementation details, system architecture, libraries, and tooling are completely different. This lesson provides the foundational knowledge of the Windows OS and its specific structures that are relevant to exploit development.",
                "sections": [
                    {
                        "title": "The Win32 API and DLLs",
                        "content": "<p>The Windows API (Win32 API) is the primary interface for user-mode applications to interact with the operating system. It is composed of a vast set of functions exported from system DLLs (Dynamic-Link Libraries).</p><h3>Key System DLLs:</h3><ul><li><strong>`kernel32.dll`</strong>: Handles core functionality like memory management (`VirtualAlloc`), process and thread creation, and file I/O.</li><li><strong>`user32.dll`</strong>: Manages the user interface, such as windows, menus, and message passing.</li><li><strong>`ntdll.dll`</strong>: The lowest-level user-mode library. It provides the interface for system calls from user-mode to kernel-mode. The functions in `kernel32.dll` are often just wrappers around functions in `ntdll.dll`.</li><li><strong>`msvcrt.dll`</strong>: The Microsoft Visual C++ Runtime Library, which provides the standard C library functions like `printf` and `memcpy`.</li></ul><p>Exploits on Windows will often use ROP chains to call functions from these libraries, such as `VirtualProtect` to mark memory as executable.</p>",
                        "image": "https://images.unsplash.com/photo-1593720213428-28a5b9e94613?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "PE File Format",
                        "content": "<p>While Linux uses the ELF format, Windows executables and DLLs use the Portable Executable (PE) format. It contains headers with information about the file, such as the required libraries (Import Address Table), the functions it exports (Export Address Table), and the different sections of the file (`.text`, `.data`, etc.). Understanding the PE format is crucial for static analysis and finding necessary information for exploits.</p>",
                        "image": "https://images.unsplash.com/photo-1605379399642-870262d3d051?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Structured Exception Handling (SEH)",
                        "content": "<p>SEH is a mechanism in Windows for handling hardware and software exceptions (e.g., division by zero, access violation). It is implemented as a per-thread, stack-based linked list of exception handler records.</p><h3>SEH Chain:</h3><ul><li>Each record in the list contains a pointer to the next record and a pointer to an exception handler function.</li><li>When an exception occurs, the OS walks this chain and calls each handler in turn until one of them handles the exception.</li><li>Crucially, this entire chain of records is stored on the thread's stack. This makes it a very attractive target for stack buffer overflows.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1516116216624-53e6973bea12?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Debugging with WinDbg",
                        "content": "<p>WinDbg is the most powerful debugger for Windows. It can be used for user-mode and kernel-mode debugging and is essential for analyzing crashes and developing exploits.</p><h3>Common WinDbg Commands:</h3><ul><li><strong>`!gflags` and `!peb`</strong>: View process mitigation policies and Process Environment Block.</li><li><strong>`!teb`</strong>: View the Thread Environment Block, which points to the SEH chain.</li><li><strong>`!analyze -v`</strong>: A powerful command to automatically analyze a crash dump.</li><li><strong>`lm`</strong>: List loaded modules (DLLs).</li><li><strong>`x <module>!<symbol>`</strong>: Examine symbols (e.g., `x ntdll!*Create*` to find functions).</li><li><strong>`.reload /f /i`</strong>: Reload symbols for all modules.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1550009158-94ae762584d2?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Finding a Loaded DLL's Base Address in WinDbg",
                        "language": "shell",
                        "code": "# List all loaded modules and their base addresses\n0:000> lm\n\nstart             end                 module name\n00007ff7`b8e80000 00007ff7`b8ea7000   MyVulnerableApp\n00007ff8`0d1a0000 00007ff8`0d390000   ntdll\n00007ff8`0b1e0000 00007ff8`0b29a000   kernel32\n..."
                    },
                    {
                        "title": "Inspecting the SEH Chain in WinDbg",
                        "language": "shell",
                        "code": "# The !teb command shows the TEB, which points to the SEH chain\n0:000> !teb\n... \nExceptionList:        000000a6`751ff9e8\n...\n\n# Dump the SEH chain at that address\n0:000> !exchain\n000000a6`751ff9e8: MyVulnerableApp!__scrt_common_main_seh+0 [...\n000000a6`751ffa88: ntdll!_C_specific_handler+0 [..."
                    }
                ]
            },
                "quiz": {
                    "passingScore": 75,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the name of the executable file format used by Windows?",
                            "options": [
                                "ELF (Executable and Linkable Format)",
                                "Mach-O",
                                "PE (Portable Executable)",
                                "COFF (Common Object File Format)"
                            ],
                            "correct": 2,
                            "explanation": "Windows uses the Portable Executable (PE) format for its .exe and .dll files, analogous to the ELF format used on Linux."
                        },
                        {
                            "id": 2,
                            "question": "What is the Structured Exception Handling (SEH) chain?",
                            "options": [
                                "A data structure on the heap for managing memory.",
                                "A per-thread linked list on the stack containing pointers to exception handler functions.",
                                "A kernel object that tracks open files.",
                                "A table in the PE file that lists imported functions."
                            ],
                            "correct": 1,
                            "explanation": "SEH is a stack-based structure. When an exception occurs, the system walks this chain to find a handler. Because it's on the stack, it's a prime target for stack buffer overflows."
                        },
                        {
                            "id": 3,
                            "question": "Which core system DLL in Windows provides the lowest-level interface between user-mode applications and the kernel?",
                            "options": [
                                "`user32.dll`",
                                "`kernel32.dll`",
                                "`msvcrt.dll`",
                                "`ntdll.dll`"
                            ],
                            "correct": 3,
                            "explanation": "`ntdll.dll` sits at the boundary between user mode and kernel mode, containing the actual syscall instructions. Higher-level libraries like `kernel32.dll` call functions within `ntdll.dll` to perform system tasks."
                        }
                    ]
                
            }
        },
        {
            "id": "lesson-12",
            "title": "Structured Exception Handling (SEH) Overwrites",
            "duration": "150 min",
            "objectives": [
                "Understand the structure of an SEH record on the stack",
                "Learn how a stack buffer overflow can overwrite an SEH record",
                "Master the 'pop pop ret' technique to redirect execution flow",
                "Bypass SafeSEH, a mitigation designed to protect SEH"
            ],
            "content": {
                "overview": "The Structured Exception Handling (SEH) chain is a fundamental part of the Windows OS, but because it resides on the stack, it represents a classic attack vector. This lesson details how a simple stack buffer overflow can be used to overwrite an exception handler's function pointer, allowing an attacker to seize control of execution when an exception is triggered.",
                "sections": [
                    {
                        "title": "The SEH Record on the Stack",
                        "content": "<p>An SEH record is a simple structure pushed onto the stack for each `try` block (or by the system for each thread).</p><h3>Structure (32-bit):</h3><ul><li><strong>`Next SEH Record` (4 bytes):</strong> A pointer to the next record in the chain. Forms a linked list.</li><li><strong>`Exception Handler` (4 bytes):</strong> A pointer to the function that will be executed if an exception occurs. This is our primary target.</li></ul><p>In a classic stack overflow, our buffer grows up the stack, overwriting local variables, the saved EBP, the return address, and eventually, the SEH records.</p>",
                        "image": "https://images.unsplash.com/photo-1542903660-eedba2cda473?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Triggering the Exception",
                        "content": "<p>Overwriting the SEH record is only the first step. We need to cause an exception to make the system use our corrupted entry.</p><h3>The Exploit Flow:</h3><ol><li>Find a stack buffer overflow.</li><li>Craft a payload that overwrites the `Exception Handler` pointer with the address of our shellcode or a ROP gadget.</li><li>The payload must also overwrite the `Next SEH Record`.</li><li>Continue writing past the SEH record until we cause an exception, typically by accessing an invalid memory address. This triggers the exception handling mechanism.</li><li>The OS begins to walk the SEH chain, finds our corrupted record, and jumps to the address we supplied in the `Exception Handler` field.</li></ol>",
                        "image": "https://images.unsplash.com/photo-1611938342213-915513c41097?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The 'pop pop ret' Technique",
                        "content": "<p>A direct jump to shellcode on the stack often fails due to DEP. A more reliable method is to use a gadget. When an SEH handler is called, the stack is not clean; it contains pointers to exception-related structures. We need a way to get past this data to our own data.</p><h3>How it Works:</h3><p>We overwrite the handler pointer with the address of a `pop r32; pop r32; ret` gadget found in a loaded DLL. When the handler is called, these two `pop` instructions clean the exception records off the stack. The `ret` instruction then pops the next value on the stack into EIP. We cleverly place our `Next SEH Record` pointer such that it's this next value. This results in a short jump, hopping over the original handler pointer, to land on shellcode we placed immediately after the SEH record in our payload.</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Bypassing SafeSEH</strong></div><p>SafeSEH is a mitigation where the OS checks if an exception handler is in a list of known, valid handlers before calling it. To bypass this, we find our `pop pop ret` gadget in a module that was not compiled with SafeSEH (e.g., an older third-party DLL loaded by the application).</p></div>",
                        "image": "https://images.unsplash.com/photo-1510511459019-5dda7724fd87?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Conceptual SEH Overwrite Payload (32-bit)",
                        "language": "python",
                        "code": "# Assume a buffer overflow at an offset of 500 bytes\n\n# Padding to reach the SEH record\npadding = b'\\x90' * 500 \n\n# The next 4 bytes overwrite the Next SEH record.\n# We need a short forward jump to our shellcode. `\\xeb\\x06` is a 6-byte jump.\n# We pad with NOPs.\nnext_seh = b'\\xeb\\x06\\x90\\x90' \n\n# The next 4 bytes overwrite the SEH Handler itself.\n# We point this to a 'pop pop ret' gadget found in a DLL.\nseh_handler = p32(0x7C86467B) # Example address of pop edi; pop esi; ret in kernel32\n\n# Shellcode comes immediately after the handler\nshellcode = b'\\xcc\\xcc\\xcc...' # Our actual shellcode\n\n# Final payload\npayload = padding + next_seh + seh_handler + shellcode"
                    }
                ]
            },
                "quiz": {
                    "passingScore": 75,
                    "questions": [
                        {
                            "id": 1,
                            "question": "In an SEH-based exploit, what is the attacker's primary target to overwrite?",
                            "options": [
                                "The main function's return address.",
                                "A global variable in the .data section.",
                                "The `Exception Handler` function pointer within an SEH record on the stack.",
                                "The base pointer (EBP)."
                            ],
                            "correct": 2,
                            "explanation": "By overwriting the exception handler pointer, the attacker can redirect the flow of execution to a location of their choice when an exception is triggered."
                        },
                        {
                            "id": 2,
                            "question": "After overwriting an SEH record, what must an attacker do to gain control?",
                            "options": [
                                "Wait for the program to exit normally.",
                                "Trigger a software or hardware exception.",
                                "Call `malloc` to corrupt the heap.",
                                "Overwrite a file on the disk."
                            ],
                            "correct": 1,
                            "explanation": "The corrupted handler is only used when the exception handling mechanism is invoked. The attacker must force an exception (e.g., by causing an access violation) to make the OS walk the SEH chain and call their malicious handler."
                        },
                        {
                            "id": 3,
                            "question": "What is the purpose of using a 'pop pop ret' gadget in an SEH exploit?",
                            "options": [
                                "To add two numbers together.",
                                "To bypass ASLR by leaking an address.",
                                "To clean exception-related data off the stack before executing shellcode.",
                                "To prevent the program from crashing."
                            ],
                            "correct": 2,
                            "explanation": "When an SEH handler is called, the stack contains pointers and records related to the exception context. The `pop pop ret` sequence effectively skips over this data, allowing the `ret` to land on a controlled value, which can then redirect execution to the shellcode."
                        }
                    ]
                
            }
        },
        {
            "id": "lesson-13",
            "title": "Bypassing Windows Mitigations",
            "duration": "180 min",
            "objectives": [
                "Apply Return-Oriented Programming (ROP) techniques in the Windows environment",
                "Use ROP to call `VirtualProtect` to defeat Data Execution Prevention (DEP)",
                "Understand how ASLR is implemented in Windows and how to bypass it with leaks",
                "Gain a conceptual understanding of modern defenses like CFG and ACG"
            ],
            "content": {
                "overview": "Just like on Linux, modern Windows versions are protected by a suite of powerful security mitigations, including DEP and ASLR. This lesson adapts the ROP techniques we've already learned to the Windows ecosystem. The ultimate goal is to build a reliable ROP chain that bypasses these defenses to achieve code execution.",
                "sections": [
                    {
                        "title": "ROP on Windows",
                        "content": "<p>ROP on Windows follows the same principles as on Linux: we chain together small instruction snippets (gadgets) ending in `ret` to execute complex operations. However, the details are different.</p><h3>Key Differences:</h3><ul><li><strong>Calling Convention:</strong> 32-bit Windows APIs often use `stdcall`, where arguments are pushed onto the stack. 64-bit Windows uses a convention similar to System V, where the first four arguments are passed in RCX, RDX, R8, and R9.</li><li><strong>Libraries:</strong> Gadgets are found in loaded DLLs like `kernel32.dll` and `ntdll.dll`, not `libc.so`.</li><li><strong>Goal:</strong> A common goal is to call `VirtualProtect()` or `VirtualAlloc()` to allocate a new executable memory region or mark an existing one (like the stack) as executable. This bypasses DEP and allows us to run shellcode.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1618498082410-b4aa22193b38?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Defeating DEP with VirtualProtect",
                        "content": "<p>`VirtualProtect` is a Win32 API function that can change the memory protections on a region of pages.</p><code>BOOL VirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);</code><h3>The ROP Strategy:</h3><p>Our ROP chain must set up all the arguments for this function call. This involves:</p><ol><li>Finding gadgets to load the four arguments into the correct registers (on x64) or push them onto the stack (on x86).</li><li>`lpAddress`: The address of our shellcode on the stack. This can be tricky to get without a leak.</li><li>`dwSize`: The size of our shellcode.</li><li>`flNewProtect`: A constant value to mark the memory as executable (e.g., `0x40` for `PAGE_EXECUTE_READWRITE`).</li><li>`lpflOldProtect`: Address of a writable location to store the old protection flags.</li><li>Finally, the ROP chain must divert execution to the address of `VirtualProtect`. If this call succeeds, the stack becomes executable, and we can simply return into our shellcode.</li></ol>",
                        "image": "https://images.unsplash.com/photo-1548092372-68b6b3b231d3?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Windows ASLR and Information Leaks",
                        "content": "<p>ASLR on Windows works similarly to Linux, randomizing the base addresses of DLLs, the stack, and the heap. Bypassing it requires an information leak. A vulnerability that can leak a pointer to any function inside a loaded DLL (e.g., `kernel32.dll`) is sufficient. From that leaked pointer, we can calculate the DLL's base address and then the runtime address of any other function (like `VirtualProtect`) or ROP gadget within it.</p>",
                        "image": "https://images.unsplash.com/photo-1506953835492-f78a25a7a744?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Modern Mitigations: CFG and ACG",
                        "content": "<p>Modern Windows includes even more advanced protections that make traditional ROP difficult.</p><ul><li><strong>Control Flow Guard (CFG):</strong> As discussed previously, CFG validates indirect calls, ensuring they target the start of a valid function. This prevents jumping to the middle of a function to use a ROP gadget. Bypasses often involve finding functions whose starting bytes can be misinterpreted as useful gadgets or abusing other non-CFG-protected calls.</li><li><strong>Arbitrary Code Guard (ACG):</strong> A stricter mitigation that prevents a process from allocating new executable memory or changing existing memory to be executable. This makes calling `VirtualProtect` to mark memory as executable ineffective. Bypasses are much more complex and involve finding ways to reuse legitimate code in more creative ways (Code-Reuse attacks beyond ROP).</li></ul>",
                        "image": "https://images.unsplash.com/photo-1521992443324-4c3d31a7b46e?w=800&h=400&fit-crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Conceptual ROP Chain for VirtualProtect (x86)",
                        "language": "python",
                        "code": "# Goal: Call VirtualProtect(stack_addr, size, 0x40, writable_addr)\n\nrop_chain = [\n    p32(address_of_virtualprotect), # Return here after setting up args\n    p32(address_of_shellcode),      # This will be the return address after VP completes\n    \n    # Arguments for VirtualProtect\n    p32(stack_address_of_shellcode), # 1. lpAddress\n    p32(0x200),                      # 2. dwSize\n    p32(0x40),                       # 3. flNewProtect (PAGE_EXECUTE_READWRITE)\n    p32(some_writable_location)      # 4. lpflOldProtect\n]\n\n# The final payload would be padding + rop_chain + shellcode"
                    }
                ]
            },
                "quiz": {
                    "passingScore": 75,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the primary goal of a typical ROP chain on modern Windows to bypass DEP?",
                            "options": [
                                "To call the `system` function with `\"cmd.exe\"`.",
                                "To call `VirtualProtect` or `VirtualAlloc` to create an executable memory region.",
                                "To directly overwrite a GOT/IAT entry.",
                                "To crash the application gracefully."
                            ],
                            "correct": 1,
                            "explanation": "Because data sections like the stack are marked non-executable by DEP, the standard strategy is to use a ROP chain to call a Win32 API function like `VirtualProtect` to disable DEP on that region, then jump to the shellcode."
                        },
                        {
                            "id": 2,
                            "question": "How does an attacker typically bypass ASLR on Windows?",
                            "options": [
                                "By guessing the base address of kernel32.dll.",
                                "ASLR cannot be bypassed on Windows.",
                                "By exploiting an information leak vulnerability to get a runtime pointer into a loaded DLL, then calculating the DLL's base address.",
                                "By disabling ASLR system-wide before running the exploit."
                            ],
                            "correct": 2,
                            "explanation": "The method is conceptually the same as on Linux. An information leak provides a single runtime address, which acts as an anchor. Since the internal offsets of a DLL are constant, the attacker can calculate the base address and then the address of any required function or gadget."
                        },
                        {
                            "id": 3,
                            "question": "How does Control Flow Guard (CFG) make traditional ROP attacks more difficult?",
                            "options": [
                                "It randomizes the location of ROP gadgets.",
                                "It encrypts the content of the stack.",
                                "It validates indirect call targets, preventing jumps to arbitrary code snippets (gadgets) that are not at the start of a function.",
                                "It removes the `ret` instruction from all loaded DLLs."
                            ],
                            "correct": 2,
                            "explanation": "CFG maintains a bitmap of all valid indirect call targets (mostly function entry points). Before an indirect call, a check ensures the destination is in this bitmap. This stops ROP chains from jumping into the middle of functions to use gadgets."
                        }
                    ]
                }
            
        },
        {
            "id": "lesson-14",
            "title": "Format String Exploitation",
            "duration": "150 min",
            "objectives": [
                "Understand how format string functions work internally",
                "Use format specifiers like %x and %p to leak data from the stack",
                "Use the %n specifier to write to arbitrary memory locations",
                "Combine a format string vulnerability with other techniques to defeat mitigations"
            ],
            "content": {
                "overview": "Format string vulnerabilities are a powerful and versatile bug class. They arise from the improper use of functions like `printf` where user-supplied data is used as the format string argument. This lesson explores how this seemingly simple mistake can be leveraged to leak sensitive information from the stack and, more critically, to write arbitrary data to arbitrary memory locations.",
                "sections": [
                    {
                        "title": "The Vulnerability",
                        "content": "<p>Functions in the `printf` family expect a format string followed by a variable number of arguments that correspond to the format specifiers in the string.</p><code>printf(\"User ID: %d, Name: %s\", id, name);</code><p>The vulnerability occurs when a programmer directly passes user input as the format string:</p><code>char buffer[100];<br>read(0, buffer, 100);<br>printf(buffer);</code><p>If a user enters `%x %x %x`, `printf` will look for corresponding arguments on the stack. Since none were provided, it will simply read and print whatever values are currently on the stack after its own arguments. This allows an attacker to view the contents of the stack.</p>",
                        "image": "https://images.unsplash.com/photo-1517694712202-1428bc64a259?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Leaking Information",
                        "content": "<p>By carefully crafting the format string, an attacker can leak specific, valuable data.</p><h3>Techniques:</h3><ul><li><strong>`%p` or `%x`</strong>: Prints values from the stack in hexadecimal. By providing a chain like `%p.%p.%p.%p`, an attacker can dump large portions of the stack.</li><li><strong>Direct Parameter Access:</strong> Instead of popping values one by one, we can specify which argument to access. For example, `%6$p` will print the 6th argument on the stack. This is crucial for targeted leaking.</li><li><strong>`%s`</strong>: This specifier expects a pointer to a null-terminated string. If we can make it read a pointer from the stack that points to other interesting data, we can leak that data.</li></ul><p>This is a powerful way to defeat ASLR by leaking a return address (which points to the executable) or a saved libc pointer, and to defeat canaries by leaking the canary value itself.</p>",
                        "image": "https://images.unsplash.com/photo-1526374965328-5f61d25c16c6?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Arbitrary Write with %n",
                        "content": "<p>The `%n` format specifier is unique and dangerous. Instead of printing, it *writes* the number of bytes successfully printed so far into an integer pointer provided as an argument.</p><h3>The Attack:</h3><ol><li><strong>Goal:</strong> Overwrite a target address (e.g., a GOT entry, a function pointer) with a target value (e.g., the address of `system`).</li><li><strong>Control a Pointer:</strong> The attacker's input buffer (which is the format string) is on the stack. The attacker places the address they want to write to (`TARGET_ADDR`) into their buffer.</li><li><strong>Position the Pointer:</strong> The attacker uses direct parameter access (`%N$n`) to treat `TARGET_ADDR` as the argument for the `%n` specifier.</li><li><strong>Control the Count:</strong> The attacker controls the number of bytes printed *before* the `%n` specifier. This can be done with padding (`%12345c`) which prints 12345 characters. This number is what gets written.</li></ol><p>By chaining multiple writes with specifiers like `%hhn` (write 1 byte) and `%hn` (write 2 bytes), an attacker can construct an arbitrary value at an arbitrary address, byte by byte.</p>",
                        "image": "https://images.unsplash.com/photo-1504639725590-34d0984388bd?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Leaking the Stack Canary",
                        "language": "python",
                        "code": "from pwn import *\n\np = process('./format_string_vuln')\n\n# Assuming through trial and error, we found the canary is the 7th value on the stack\npayload = b'%7$p'\n\np.sendline(payload)\np.recvline() # Discard banner\nleaked_canary = int(p.recvline().strip(), 16)\n\nlog.info(f'Leaked Canary: {hex(leaked_canary)}')\n\n# Now we can use this in a subsequent buffer overflow attack\n# ... rest of exploit"
                    },
                    {
                        "title": "Pwntools 'fmtstr_payload' for Arbitrary Write",
                        "language": "python",
                        "code": "from pwn import *\n\nelf = context.binary = ELF('./format_string_arb_write')\np = process()\n\n# Pwntools can automate the complex calculation for format string writes\n\n# We want to overwrite the GOT entry for 'exit' with the address of 'win'\nexit_got_addr = elf.got['exit']\nwin_func_addr = elf.symbols['win']\n\n# We found the offset where our controlled data starts on the stack is 6\noffset = 6\n\n# Build the payload automatically\npayload = fmtstr_payload(offset, {exit_got_addr: win_func_addr})\n\np.sendline(payload)\n\n# The program will now call win() when it tries to exit\np.interactive()"
                    }
                ]
            },
                "quiz": {
                    "passingScore": 75,
                    "questions": [
                        {
                            "id": 1,
                            "question": "A format string vulnerability occurs when...",
                            "options": [
                                "A string is too long for its buffer.",
                                "User-controlled data is passed as the format string argument to a function like `printf`.",
                                "A program uses a string after it has been freed.",
                                "An integer is used as a string."
                            ],
                            "correct": 1,
                            "explanation": "The vulnerability is in allowing the user to supply the format specifiers (`%x`, `%s`, `%n`), which dictates how `printf` interprets data from the stack."
                        },
                        {
                            "id": 2,
                            "question": "Which format specifier is used to WRITE data to memory instead of reading it?",
                            "options": [
                                "`%x` (hex)",
                                "`%s` (string)",
                                "`%d` (decimal)",
                                "`%n` (number of bytes written)"
                            ],
                            "correct": 3,
                            "explanation": "The `%n` specifier is uniquely dangerous because it writes the count of characters printed so far to a pointer on the stack. An attacker who can control both the pointer and the count achieves an arbitrary write."
                        },
                        {
                            "id": 3,
                            "question": "What is the primary use of format string exploits in bypassing modern mitigations?",
                            "options": [
                                "To cause a denial of service by crashing the program.",
                                "To leak stack canaries and memory addresses (from libraries or the executable) to defeat canaries and ASLR.",
                                "To execute shellcode directly on the stack.",
                                "To bypass heap protections like tcache."
                            ],
                            "correct": 1,
                            "explanation": "Format string bugs are excellent 'leaking' primitives. They provide the information (canary values, libc addresses) needed to build the final ROP chain for a separate buffer overflow vulnerability."
                        }
                    ]
                
            }
        },
        {
            "id": "lesson-15",
            "title": "Integer Overflows",
            "duration": "120 min",
            "objectives": [
                "Differentiate between signed and unsigned integers and their representations",
                "Understand how integer overflow, underflow, and truncation bugs occur",
                "Recognize how logical errors from integer bugs can lead to memory corruption",
                "Exploit an integer overflow that results in a heap buffer overflow"
            ],
            "content": {
                "overview": "Not all vulnerabilities are direct memory corruption bugs like buffer overflows. Some are subtle logical flaws that can be used to create the conditions for memory corruption. Integer overflows are a prime example. This lesson covers how the finite size of integer types in C can lead to unexpected calculations, which, if used for security-critical decisions like memory allocation, can be disastrous.",
                "sections": [
                    {
                        "title": "The Basics of Integer Representation",
                        "content": "<p>Computers store integers using a fixed number of bits (e.g., 8, 16, 32, 64). This limitation is the root cause of overflow issues.</p><ul><li><strong>Unsigned Integers:</strong> Store only non-negative numbers. An 8-bit unsigned char can represent values from 0 to 255. Adding 1 to 255 'wraps around' back to 0.</li><li><strong>Signed Integers:</strong> Use one bit (the most significant bit) to represent the sign. An 8-bit signed char can represent values from -128 to 127. Adding 1 to 127 wraps around to -128. This behavior is technically 'undefined' in the C standard, but this is a common result.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Types of Integer Bugs",
                        "content": "<ul><li><strong>Overflow:</strong> Occurs when a calculation results in a number that is larger than the maximum value for the integer type. `(unsigned char)200 + (unsigned char)100 = 44` (because 300 % 256 = 44).</li><li><strong>Underflow:</strong> Occurs when a calculation is smaller than the minimum value. `(unsigned char)50 - (unsigned char)100 = 206`.</li><li><strong>Truncation:</strong> Occurs when a larger integer type is cast to a smaller one. The most significant bits are discarded. `(char)(0x1234) = 0x34`.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "From Logic Bug to Memory Corruption",
                        "content": "<p>An integer overflow on its own is just a logical bug. It becomes a security vulnerability when the incorrect result is used in a security-sensitive context, most commonly for calculating buffer sizes.</p><h3>Classic Example: Integer Overflow to Heap Overflow</h3><p>Consider a program that reads two lengths from a user, adds them to calculate a total size, and then allocates a buffer of that size.</p><code>unsigned short len1, len2, total_len;<br>// read len1, len2 from user<br>total_len = len1 + len2;<br>char *buffer = malloc(total_len);<br>memcpy(buffer, user_data1, len1);<br>memcpy(buffer + len1, user_data2, len2);</code><p>An attacker can provide `len1 = 40000` and `len2 = 40000`. An `unsigned short` can only hold up to 65535. The addition `40000 + 40000 = 80000`, which overflows and wraps around, so `total_len` becomes `14464`. The program allocates a small buffer of 14464 bytes. However, the `memcpy` operations still use the original, larger lengths. The first `memcpy` writes 40000 bytes into the 14464-byte buffer, resulting in a massive heap overflow.</p>",
                        "image": "https://images.unsplash.com/photo-1542831371-d531d36971ad?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Vulnerable C Code for Integer Overflow",
                        "language": "c",
                        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n\n// A short can hold up to 65535\nint process_data(char *data1, uint16_t len1, char *data2, uint16_t len2) {\n    uint16_t total_len = len1 + len2;\n    printf(\"[DEBUG] Allocating %u bytes\\n\", total_len);\n\n    char *buf = malloc(total_len);\n    if (!buf) return -1;\n\n    memcpy(buf, data1, len1); // Vulnerable copy\n    memcpy(buf + len1, data2, len2); // Vulnerable copy\n\n    // ... do something with buf ...\n    free(buf);\n    return 0;\n}\n\nint main() {\n    // Attacker controls len1 and len2\n    // 40000 + 40000 = 80000 -> overflows to 14464\n    uint16_t len1 = 40000;\n    uint16_t len2 = 40000;\n    char* data = malloc(len1 + len2);\n    memset(data, 'A', len1 + len2);\n\n    process_data(data, len1, data + len1, len2);\n\n    return 0;\n}"
                    }
                ]
            },
                "quiz": {
                    "passingScore": 75,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is an integer overflow?",
                            "options": [
                                "When a floating-point number is stored as an integer.",
                                "A result of a calculation that is too large to be stored in the destination integer type, causing it to 'wrap around'.",
                                "When a string contains numbers.",
                                "A CPU exception caused by dividing by zero."
                            ],
                            "correct": 1,
                            "explanation": "Integer types have a fixed size. An overflow happens when an arithmetic operation's result exceeds this size, leading to an incorrect, wrapped-around value."
                        },
                        {
                            "id": 2,
                            "question": "An integer overflow becomes a security vulnerability when the incorrect value is used for what?",
                            "options": [
                                "Displaying a score in a game.",
                                "Counting loops.",
                                "Security-critical decisions, like calculating the size of a buffer to allocate.",
                                "Simple arithmetic that is displayed to the user."
                            ],
                            "correct": 2,
                            "explanation": "The danger lies in the disconnect between the calculated value and the real-world expectation. If a small, overflowed value is used to allocate a buffer, but subsequent operations use the original, larger values, memory corruption will occur."
                        },
                        {
                            "id": 3,
                            "question": "If an `unsigned char` (range 0-255) has a value of 10, and you subtract 20 from it, what is the most likely result?",
                            "options": [
                                "-10",
                                "The program crashes.",
                                "246 (an underflow that wraps around)",
                                "0"
                            ],
                            "correct": 2,
                            "explanation": "Subtracting 20 from 10 results in an underflow. The calculation wraps around from the top: `(10 - 20) % 256 = 246`."
                        }
                    ]
                
            }
        },
        {
            "id": "lesson-16",
            "title": "Kernel Architecture & Debugging",
            "duration": "150 min",
            "objectives": [
                "Understand the concept of privilege rings (Ring 3 vs. Ring 0)",
                "Learn how user-mode applications interact with the kernel via system calls",
                "Recognize the role of kernel modules and drivers",
                "Set up a virtualized environment for kernel debugging"
            ],
            "content": {
                "overview": "We now take the final step up in privilege: from user-mode to kernel-mode. The kernel is the core of the operating system, running at the highest privilege level (Ring 0). A vulnerability in the kernel is catastrophic, as a successful exploit gives an attacker complete control over the entire system. This lesson introduces the fundamental concepts of kernel architecture and the specialized setup required to debug it.",
                "sections": [
                    {
                        "title": "Privilege Rings: User Space vs. Kernel Space",
                        "content": "<p>Modern CPUs enforce a security model using privilege levels called rings.</p><ul><li><strong>Ring 3 (User Mode):</strong> This is the least privileged ring where normal applications run (`bash`, web browsers, etc.). Code in Ring 3 cannot directly access hardware or modify critical OS data structures.</li><li><strong>Ring 0 (Kernel Mode):</strong> This is the most privileged ring. The OS kernel runs here. Code in Ring 0 has unrestricted access to all memory and hardware.</li></ul><p>The goal of a local privilege escalation exploit is to get code to run in Ring 0.</p>",
                        "image": "https://images.unsplash.com/photo-1550751827-4138d06733a1?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "The User/Kernel Boundary: System Calls",
                        "content": "<p>A user-mode application cannot simply call a function in the kernel. It must use a highly-controlled interface: the system call (syscall). When an application needs the kernel to do something (e.g., open a file, send network packets), it sets up arguments in registers and executes a special instruction (`syscall` on x64 Linux, `int 0x80` on x86). This instruction causes a privilege transition from Ring 3 to Ring 0. The kernel then looks at the arguments, performs the requested action, and returns the result to the user-mode application, transitioning back to Ring 3.</p>",
                        "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Drivers and Kernel Modules",
                        "content": "<p>The kernel is not a single, monolithic block of code. It is extensible through Loadable Kernel Modules (LKMs) on Linux or Drivers (.sys files) on Windows. These are pieces of code that can be loaded into the kernel at runtime to provide new functionality, typically to support a piece of hardware. Drivers are a huge source of kernel vulnerabilities because they expand the attack surface of the kernel and are often written by third parties who may not follow the same rigorous security standards as core kernel developers.</p>",
                        "image": "https://images.unsplash.com/photo-1573495627361-d9b87960b12d?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Setting Up for Kernel Debugging",
                        "content": "<p>You cannot debug a kernel with a debugger running on the same machine. A kernel crash takes the whole system with it, including the debugger. Therefore, kernel debugging requires a two-machine setup, almost always using virtual machines.</p><h3>Linux Kernel Debugging:</h3><ul><li><strong>Setup:</strong> Two VMs are needed: a 'target' VM that runs the kernel to be debugged, and a 'debugger' VM that runs GDB.</li><li><strong>Connection:</strong> The target VM is launched with QEMU/KVM with a special flag (`-s`) that exposes a GDB server stub.</li><li><strong>Debugging:</strong> The debugger VM connects its GDB client to the target's GDB server over a virtual network. The entire target VM can now be paused, its memory and registers inspected, and stepped through, just like a user-mode process.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1593432336332-9513d64b545d?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Launching a Linux VM for Kernel Debugging with QEMU",
                        "language": "bash",
                        "code": "# On the host machine, launch the target VM\n# The kernel image (bzImage) and root filesystem (rootfs.img) are required\n\nqemu-system-x86_64 \\\n    -kernel ./bzImage \\\n    -hda ./rootfs.img \\\n    -append \"root=/dev/sda console=ttyS0\" \\\n    -nographic \\\n    -s  # This is the crucial flag. It starts a GDB server on TCP port 1234"
                    },
                    {
                        "title": "Connecting GDB to the Target Kernel",
                        "language": "bash",
                        "code": "# On the debugger machine (or the host)\n\n# Launch GDB with the kernel symbol file (vmlinux)\ngdb ./vmlinux\n\n# Inside GDB, connect to the QEMU GDB server\n(gdb) target remote :1234\n\n# Now you can set breakpoints and control the target kernel\n(gdb) hb *0xffffffff81000000 # Break at kernel entry\n(gdb) c # Continue execution"
                    }
                ]
            },
                "quiz": {
                    "passingScore": 75,
                    "questions": [
                        {
                            "id": 1,
                            "question": "In the x86 privilege ring architecture, where does the operating system kernel execute?",
                            "options": [
                                "Ring 1",
                                "Ring 2",
                                "Ring 3 (User Mode)",
                                "Ring 0 (Kernel Mode)"
                            ],
                            "correct": 3,
                            "explanation": "Ring 0 is the highest privilege level, with direct access to hardware. The OS kernel runs here to manage the system's resources securely."
                        },
                        {
                            "id": 2,
                            "question": "How does a user-mode application request a service from the kernel?",
                            "options": [
                                "By directly calling a function in the kernel's memory space.",
                                "By writing to a special file on disk.",
                                "By executing a special system call instruction (e.g., `syscall`) to transition into Ring 0.",
                                "By sending a network packet to the kernel."
                            ],
                            "correct": 2,
                            "explanation": "Direct calls are forbidden by hardware protections. The system call is the only legitimate, controlled entry point from user mode into the kernel."
                        },
                        {
                            "id": 3,
                            "question": "Why is kernel debugging typically done with a two-machine (or two-VM) setup?",
                            "options": [
                                "Because a debugger requires twice the amount of RAM.",
                                "To improve network performance.",
                                "Because a kernel crash or breakpoint will halt the entire target system, so the debugger must be running on a separate, independent machine.",
                                "It is a licensing requirement for most debuggers."
                            ],
                            "correct": 2,
                            "explanation": "If the debugger were on the same machine as the kernel being debugged, halting the kernel would also halt the debugger, making it impossible to inspect the system's state. The two-machine setup ensures the debugger remains responsive even when the target is completely frozen."
                        }
                    ]
                
            }
        },
        {
            "id": "lesson-17",
            "title": "Common Kernel Vulnerabilities",
            "duration": "120 min",
            "objectives": [
                "Understand the impact of a NULL pointer dereference in the kernel",
                "Recognize stack overflow vulnerabilities within IOCTL handlers",
                "Grasp the concept of Time-of-Check to Time-of-Use (TOCTOU) race conditions",
                "Analyze other kernel bug classes like out-of-bounds writes"
            ],
            "content": {
                "overview": "Kernel vulnerabilities often mirror their user-space counterparts (overflows, use-after-frees) but their context and impact are far more severe. This lesson provides a survey of common bug classes found in kernel modules and drivers. Understanding these patterns is key to identifying and exploiting vulnerabilities that lead to privilege escalation.",
                "sections": [
                    {
                        "title": "NULL Pointer Dereference",
                        "content": "<p>In user-space, dereferencing a NULL pointer usually causes a harmless, isolated crash. In the kernel, it can be exploitable. On many systems, it is possible for a user-space process to map page zero of its virtual address space (`mmap(0, ...)`). This means address `0x0` is no longer an invalid address, but points to user-controlled data.</p><h3>The Exploit:</h3><p>If an attacker finds a bug where the kernel dereferences a NULL pointer (e.g., `struct my_obj *p = NULL; ...; p->value = 1;`), the kernel will attempt to write to address `0x0 + offsetof(value)`. Since the attacker controls the memory at address `0x0`, they can place shellcode or a fake data structure at this location and potentially hijack execution when the kernel tries to interact with it.</p>",
                        "image": "https://images.unsplash.com/photo-1542903660-eedba2cda473?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Stack Overflows in IOCTL Handlers",
                        "content": "<p>IOCTL (Input/Output Control) is a common system call on Linux used to communicate with device drivers. It's a generic interface that lets a driver define custom commands. A user-space program can send a command number and a data buffer to the driver.</p><h3>The Vulnerability:</h3><p>A frequent bug pattern is a driver that declares a fixed-size buffer on its kernel stack and then copies data into it from the user-supplied buffer without properly checking the length. This is a classic stack buffer overflow, but it happens in Ring 0. Overwriting the return address on the kernel stack allows the attacker to redirect execution to their own code when the IOCTL handler returns.</p>",
                        "image": "https://images.unsplash.com/photo-1550439062-609e1531270e?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Time-of-Check to Time-of-Use (TOCTOU)",
                        "content": "<p>A TOCTOU bug is a race condition. It occurs when the kernel checks a condition (e.g., a user's permissions to access a file) and then performs an action based on that check. An attacker can try to change the condition between the check and the action.</p><h3>The Exploit:</h3><ol><li><strong>Time-of-Check:</strong> The kernel checks if the user has permission to write to a file, `/home/user/data`. The check passes.</li><li><strong>The Race:</strong> The kernel is context-switched out, and the attacker's process runs. The attacker replaces the file `/home/user/data` with a symbolic link to `/etc/shadow`.</li><li><strong>Time-of-Use:</strong> The kernel is scheduled back in. It now proceeds to perform the write operation. It thinks it is writing to `/home/user/data`, but because of the symbolic link, it is now writing to `/etc/shadow`, a privileged file.</li></ol>",
                        "image": "https://images.unsplash.com/photo-1546530691-1b9ee1161a35?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Vulnerable Kernel Module IOCTL Handler (Stack Overflow)",
                        "language": "c",
                        "code": "long vulnerable_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {\n    char kbuf[64]; // Fixed-size buffer on the kernel stack\n\n    // ... checks for cmd ...\n\n    // Vulnerability: No size check on the user-supplied buffer 'arg'\n    if (copy_from_user(kbuf, (void __user *)arg, sizeof(kbuf))) {\n        return -EFAULT;\n    }\n\n    // If user sends > 64 bytes, this will overflow the stack\n\n    return 0;\n}"
                    }
                ]
            },
                "quiz": {
                    "passingScore": 75,
                    "questions": [
                        {
                            "id": 1,
                            "question": "Why can a NULL pointer dereference be an exploitable vulnerability in the Linux kernel?",
                            "options": [
                                "It can't; it always causes an unrecoverable kernel panic.",
                                "Because a user-space process can map memory at address 0x0, allowing them to control the data the kernel reads from or writes to via the NULL pointer.",
                                "Because the kernel automatically restarts after a NULL pointer dereference.",
                                "Because it allows the attacker to read any file on the system."
                            ],
                            "correct": 1,
                            "explanation": "The ability for user-space to map the zero page is the key. It turns what would be a guaranteed crash into a situation where the kernel interacts with user-controlled memory, which can be leveraged for code execution."
                        },
                        {
                            "id": 2,
                            "question": "An IOCTL handler in a Linux driver copies data from a user-supplied pointer into a fixed-size stack buffer without checking the user's provided length. What kind of vulnerability is this?",
                            "options": [
                                "NULL Pointer Dereference",
                                "Kernel Stack Overflow",
                                "Use-After-Free",
                                "Integer Overflow"
                            ],
                            "correct": 1,
                            "explanation": "This is a classic buffer overflow scenario. The only difference from a user-space overflow is that it occurs on the kernel's stack, making it a privilege escalation vulnerability."
                        },
                        {
                            "id": 3,
                            "question": "A TOCTOU vulnerability is a type of...",
                            "options": [
                                "Buffer Overflow",
                                "Type Confusion",
                                "Race Condition",
                                "Memory Leak"
                            ],
                            "correct": 2,
                            "explanation": "TOCTOU stands for Time-of-Check to Time-of-Use. It's a race condition where an attacker changes a resource between the kernel's check of that resource and its subsequent use of it."
                        }
                    ]
                
            }
        },
        {
            "id": "lesson-18",
            "title": "Privilege Escalation Techniques",
            "duration": "150 min",
            "objectives": [
                "Understand the ultimate goal of a kernel exploit: gaining Ring 0 execution",
                "Learn the classic Linux privilege escalation payload: overwriting the `cred` struct",
                "Learn the classic Windows privilege escalation payload: token stealing",
                "Write a payload that grants root/SYSTEM privileges to a user-space process"
            ],
            "content": {
                "overview": "Once we have control of the instruction pointer in Ring 0, what do we do next? We need a reliable payload that escalates the privileges of our user-space process to the highest level. This lesson covers the standard, OS-specific techniques for achieving this: modifying the `cred` structure in Linux and 'stealing' a system token in Windows.",
                "sections": [
                    {
                        "title": "The Goal: From Kernel Execution to User-Space Privileges",
                        "content": "<p>Executing a few instructions in the kernel is good, but our ultimate goal is to get a root or SYSTEM shell back in user-space. This requires us to use our kernel-mode execution primitive to modify the kernel's data structures that define our process's permissions.</p><h3>The General Strategy:</h3><ol><li>Gain control of RIP in the kernel (e.g., via a stack overflow).</li><li>Execute a small kernel-mode payload.</li><li>This payload finds the current process's privilege structure.</li><li>It overwrites the IDs in this structure to all-zeros (root/SYSTEM).</li><li>It then gracefully returns from the kernel back to our user-mode process.</li><li>Our process now has the highest privileges and can spawn a shell (`/bin/sh` or `cmd.exe`).</li></ol>",
                        "image": "https://images.unsplash.com/photo-1599507593498-52ed8a45e755?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Linux: Overwriting `cred` Structures",
                        "content": "<p>In Linux, every process is associated with a `cred` structure, which holds its credentials, including User ID (UID), Group ID (GID), effective UID (EUID), etc. The kernel uses this structure to make permission checks.</p><h3>The Payload (`commit_creds(prepare_kernel_cred(0))`):</h3><p>The Linux kernel conveniently exports two functions for this exact purpose:</p><ul><li><strong>`prepare_kernel_cred(0)`</strong>: This function creates a new, fresh `cred` structure with all privileges (root). It takes a base task struct as an argument; passing 0 tells it to create credentials for the initial kernel process.</li><li><strong>`commit_creds()`</strong>: This function applies a new `cred` structure to the current task.</li></ul><p>Our kernel payload is simply a ROP chain or shellcode that calls `commit_creds(prepare_kernel_cred(0))`. Once this is done, our process becomes root.</p>",
                        "image": "https://images.unsplash.com/photo-1518432031352-d6fc5c10da5a?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Windows: Token Stealing",
                        "content": "<p>In Windows, privileges are managed by Access Tokens attached to each process. The SYSTEM process (typically PID 4) has the most powerful token on the system.</p><h3>The Payload:</h3><p>A Windows kernel payload performs a series of steps to find the SYSTEM process's token and copy it to our own process:</p><ol><li>Get the address of the current process's `EPROCESS` structure.</li><li>Traverse the linked list of active processes (`ActiveProcessLinks`) to find the `EPROCESS` structure of the SYSTEM process (where `UniqueProcessId` is 4).</li><li>Get the `Token` field from the SYSTEM `EPROCESS` structure.</li><li>Get the `Token` field from our own process's `EPROCESS` structure.</li><li>Overwrite our process's `Token` field with the value of the SYSTEM token.</li></ol><p>After this, our process has the same privileges as the SYSTEM account.</p>",
                        "image": "https://images.unsplash.com/photo-1593720213428-28a5b9e94613?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Linux Kernel ROP Chain for Privilege Escalation",
                        "language": "python",
                        "code": "# In our user-space exploit, after triggering the kernel overflow:\n\n# We need the addresses of these functions in the kernel's symbol table (kallsyms)\nprepare_kernel_cred = 0xffffffff810a1410\ncommit_creds = 0xffffffff810a1010\n\n# A gadget to move the result from rax (return value) into rdi (first argument)\nmov_rdi_rax_ret = 0xffffffff810d2383 \n\nrop_chain = [\n    p64(prepare_kernel_cred), # Call prepare_kernel_cred(0)\n    p64(mov_rdi_rax_ret),     # Move the new cred struct from rax to rdi\n    p64(commit_creds),        # Call commit_creds with the new creds\n    p64(return_to_usermode)   # Address of code to safely return to Ring 3\n]\n\n# The full payload would be [padding] + [rop_chain]"
                    },
                    {
                        "title": "Spawning a Root Shell after Kernel Exploit (User-space)",
                        "language": "c",
                        "code": "// This code runs in our main exploit process\n\nvoid spawn_shell() {\n    // After the kernel payload has executed, our process has new credentials.\n    // We check if our UID is now 0.\n    if (getuid() == 0) {\n        printf(\"[+] Got root!\\n\");\n        system(\"/bin/sh\");\n    } else {\n        printf(\"[-] Exploit failed.\\n\");\n    }\n}\n\nint main() {\n    // ... code to trigger the kernel vulnerability ...\n    trigger_vuln();\n\n    // ... the kernel payload runs and returns ...\n    spawn_shell();\n\n    return 0;\n}"
                    }
                ]
            },
                "quiz": {
                    "passingScore": 75,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the primary goal of a privilege escalation payload after gaining code execution in the kernel?",
                            "options": [
                                "To crash the kernel, causing a denial of service.",
                                "To modify kernel data structures to grant the attacker's user-space process higher privileges.",
                                "To load a new driver into the kernel.",
                                "To reformat the hard drive."
                            ],
                            "correct": 1,
                            "explanation": "The objective is to leverage temporary kernel-mode execution to permanently elevate the privileges of the originating user-mode process, allowing the attacker to then run any command as root or SYSTEM."
                        },
                        {
                            "id": 2,
                            "question": "In Linux kernel exploitation, what is the standard payload for gaining root privileges?",
                            "options": [
                                "Calling `system(\"/bin/sh\")` directly from the kernel.",
                                "Overwriting the `/etc/passwd` file.",
                                "Calling the sequence `commit_creds(prepare_kernel_cred(0))`.",
                                "Disabling all security mitigations."
                            ],
                            "correct": 2,
                            "explanation": "The kernel provides the `prepare_kernel_cred` and `commit_creds` functions, which are the clean, intended way for kernel code to manipulate process credentials. Exploits abuse these functions to grant themselves root."
                        },
                        {
                            "id": 3,
                            "question": "The 'token stealing' payload in Windows kernel exploitation involves...",
                            "options": [
                                "Finding the access token of a high-privilege process (like SYSTEM) and copying it to the attacker's process.",
                                "Guessing the value of the SYSTEM process's access token.",
                                "Deleting the access token from the attacker's process.",
                                "Creating a brand new access token from scratch."
                            ],
                            "correct": 0,
                            "explanation": "The token stealing technique involves traversing the kernel's list of processes to find the SYSTEM process, grabbing a pointer to its powerful access token, and then overwriting the token pointer in the attacker's own process structure with the stolen one."
                        }
                    ]
                
            }
        },
        {
            "id": "lesson-19",
            "title": "Bypassing Kernel Mitigations",
            "duration": "120 min",
            "objectives": [
                "Understand the purpose of SMEP (Supervisor Mode Execution Prevention)",
                "Understand the purpose of SMAP (Supervisor Mode Access Prevention)",
                "Learn about Kernel ASLR (KASLR) and how to defeat it",
                "Grasp 'ret2usr' techniques for bypassing SMEP/SMAP"
            ],
            "content": {
                "overview": "Just as with user-space, kernel developers have introduced powerful mitigations to make exploitation much harder. This lesson covers the most significant kernel protections: SMEP, SMAP, and KASLR. We will learn what they do and the common techniques used to circumvent them to achieve privilege escalation.",
                "sections": [
                    {
                        "title": "SMEP: No Executing User Code",
                        "content": "<p>Supervisor Mode Execution Prevention (SMEP) is a hardware feature that prevents the kernel (running in Ring 0) from executing code that resides on a user-space page (Ring 3). </p><h3>How it Stops Exploits:</h3><p>A simple kernel stack overflow exploit might overwrite the return address with a pointer to shellcode in user-space memory. Without SMEP, when the kernel function returns, it would jump to that user-space address and execute the shellcode. With SMEP enabled, the moment the kernel attempts to execute code from a user-space page, the CPU will raise a page fault, and the system will crash. This single feature defeats all simple 'ret2usr' (return-to-user-space) attacks.</p>",
                        "image": "https://images.unsplash.com/photo-1548092372-68b6b3b231d3?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "SMAP: No Accessing User Data",
                        "content": "<p>Supervisor Mode Access Prevention (SMAP) is a related hardware feature that prevents the kernel from *reading from or writing to* user-space pages, unless specifically instructed to do so.</p><h3>How it Stops Exploits:</h3><p>This defeats exploits that rely on the kernel accessing user-controlled data when it shouldn't. For example, a NULL pointer dereference exploit where the attacker maps page zero in user-space would be blocked by SMAP. When the kernel tries to read or write to the NULL pointer (address 0x0), the CPU will fault because that address belongs to a user-space page.</p>",
                        "image": "https://images.unsplash.com/photo-1614064548237-02f0d1a2b733?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Bypassing SMEP and SMAP",
                        "content": "<p>SMEP and SMAP are controlled by bits in a CPU control register (CR4). If an attacker can find a way to flip those bits off, the protections are disabled. However, a more common approach is to use ROP.</p><h3>Kernel ROP (kROP):</h3><p>Instead of returning to user-space, the attacker builds a ROP chain using gadgets found *within the kernel's own executable code*. Since this code is already in Ring 0, SMEP does not apply. The goal of the kernel ROP chain is the same: call `commit_creds(prepare_kernel_cred(0))` or perform a token steal. This avoids executing any user-space code directly.</p>",
                        "image": "https://images.unsplash.com/photo-1510511459019-5dda7724fd87?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "KASLR: Kernel Address Space Layout Randomization",
                        "content": "<p>Just like user-space ASLR, KASLR randomizes the base address where the kernel image is loaded into memory at boot time. This makes it impossible for an attacker to know the addresses of kernel functions or ROP gadgets.</p><h3>Bypassing KASLR:</h3><p>Defeating KASLR requires an information leak. An attacker needs a vulnerability that leaks any pointer into the kernel memory space. Many side-channel attacks (like Spectre variants) or driver vulnerabilities that leak kernel pointers from log files or other outputs can be used. Once a single valid kernel pointer is leaked, the attacker can calculate the KASLR slide (the difference between the leaked address and the compile-time address), and from there, calculate the runtime address of any gadget or function needed for their kROP chain.</p>",
                        "image": "https://images.unsplash.com/photo-1506953835492-f78a25a7a744?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Conceptual Kernel ROP Chain (Bypassing SMEP)",
                        "language": "python",
                        "code": "# The goal is the same as the non-SMEP case, but all gadget\n# addresses must be within the kernel's code (.text section).\n\n# We've defeated KASLR and know the kernel base address.\nkernel_base = 0xffffffff81000000\n\n# Calculate runtime addresses of functions and gadgets\nprepare_kernel_cred = kernel_base + 0x0a1410\ncommit_creds = kernel_base + 0x0a1010\npop_rdi_ret = kernel_base + 0x00b130 # A 'pop rdi; ret' gadget inside the kernel\n\nrop_chain = [\n    p64(pop_rdi_ret),         # Pop 0 into RDI for our argument\n    p64(0),\n    p64(prepare_kernel_cred), # Call prepare_kernel_cred(0)\n    # ... more gadgets to move rax to rdi ...\n    p64(commit_creds),\n    p64(return_to_usermode)\n]\n"
                    }
                ]
            },
                "quiz": {
                    "passingScore": 75,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What does SMEP (Supervisor Mode Execution Prevention) prevent?",
                            "options": [
                                "The kernel from writing to user-space memory.",
                                "A user-space application from executing code on the stack.",
                                "The kernel (Ring 0) from executing code located in user-space memory (Ring 3).",
                                "The kernel from allocating memory."
                            ],
                            "correct": 2,
                            "explanation": "SMEP is a hardware-enforced boundary that stops the kernel from jumping to and executing code in user-space, which is a common technique in older, simpler kernel exploits."
                        },
                        {
                            "id": 2,
                            "question": "What is the most common technique to bypass SMEP?",
                            "options": [
                                "Guessing the address of shellcode.",
                                "Using a kernel-space ROP (kROP) chain that only uses gadgets from the kernel's own code.",
                                "Flooding the kernel with so much data that SMEP gets disabled.",
                                "Running the exploit from a virtual machine."
                            ],
                            "correct": 1,
                            "explanation": "Since the kernel cannot execute user-space code, the attacker is forced to work with the code already available in the kernel. A kernel ROP chain uses gadgets within the kernel image itself to achieve the desired outcome, never jumping to user-space."
                        },
                        {
                            "id": 3,
                            "question": "What is required to defeat KASLR (Kernel ASLR)?",
                            "options": [
                                "A powerful CPU.",
                                "A stack buffer overflow.",
                                "An information leak vulnerability that discloses a pointer into the randomized kernel memory region.",
                                "Disabling SMEP and SMAP first."
                            ],
                            "correct": 2,
                            "explanation": "KASLR is defeated just like user-space ASLR: an information leak provides an anchor point. By leaking any valid kernel address, an attacker can calculate the random offset (the KASLR slide) and then determine the location of all other code and data in the kernel."
                        }
                    ]
                }
            
        },
        {
            "id": "lesson-20",
            "title": "Capstone Challenge",
            "duration": "N/A",
            "objectives": [
                "Synthesize all learned skills to exploit a complex, real-world-style application",
                "Reverse engineer a binary to identify one or more vulnerabilities",
                "Develop a reliable exploit that bypasses multiple, modern security mitigations",
                "Produce a professional, detailed technical write-up of the entire exploitation process"
            ],
            "content": {
                "overview": "This final module is the culmination of the entire course. You will be provided with a custom-built application (either Linux or Windows) protected by a full suite of modern security mitigations. Your task is to apply everything you have learnedfrom static analysis to advanced exploitation techniquesto develop a full, reliable, remote-code-execution exploit.",
                "sections": [
                    {
                        "title": "The Target",
                        "content": "<p>You will be given a binary application and its source code (to simulate a white-box test). The application will be a network service protected by:</p><ul><li><strong>Stack Canaries</strong></li><li><strong>Data Execution Prevention (DEP / NX)</strong></li><li><strong>Address Space Layout Randomization (ASLR)</strong></li><li><strong>Position-Independent Executable (PIE)</strong> (for Linux targets)</li></ul><p>The application will contain one or more subtle vulnerabilities from the classes we have studied, such as heap overflows, use-after-frees, format string bugs, or integer overflows. The vulnerabilities may need to be chained together to achieve a successful exploit.</p>",
                        "image": "https://images.unsplash.com/photo-1555949963-aa79dcee981c?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Project Tasks",
                        "content": "<ol><li><strong>Reverse Engineering & Vulnerability Analysis:</strong> Statically analyze the source code and the binary in Ghidra/IDA Pro. Dynamically analyze the application with GDB/WinDbg to understand its behavior and confirm the vulnerabilities you have identified.</li><li><strong>Proof-of-Concept (PoC):</strong> Develop a simple script that triggers the vulnerability and reliably crashes the application. Use the debugger to analyze the crash state and confirm that you can control the instruction pointer or other critical program state.</li><li><strong>Exploit Development:</strong> Write a full exploit script using Python and Pwntools. Your exploit must be able to:<ul><li>Defeat ASLR using an information leak.</li><li>Bypass the stack canary if applicable.</li><li>Use a ROP chain to bypass DEP/NX.</li><li>Gain arbitrary code execution (e.g., pop a shell).</li></ul><li><strong>Technical Write-up:</strong> Produce a detailed, professional report. The report must clearly explain the vulnerability, your analysis process, the step-by-step logic of your exploit chain, and how each mitigation was bypassed. Include relevant code snippets, debugger screenshots, and diagrams.</li></ol>",
                        "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Submission and Grading",
                        "content": "<p>Your submission must include:</p><ul><li>Your final, working exploit script (`exploit.py`).</li><li>A detailed technical write-up in PDF format (`report.pdf`).</li></ul><p>Grading will be based on:</p><ul><li><strong>Reliability (40%):</strong> Does the exploit work consistently against the target?</li><li><strong>Technical Depth (30%):</strong> Does the write-up demonstrate a deep understanding of the vulnerability and exploitation techniques?</li><li><strong>Clarity (20%):</strong> Is the write-up well-structured, clear, and easy to follow?</li><li><strong>Code Quality (10%):</strong> Is the exploit script well-commented and organized?</li></ul><div class='info-box tip'><div class='info-box-header'><i class='fas fa-lightbulb'></i><strong>Final Advice</strong></div><p>Start by disabling mitigations like ASLR to develop parts of your exploit in isolation. Get a simple RIP overwrite first. Then, build a basic ROP chain. Then, add the info leak to defeat ASLR. Build your exploit incrementally. Good luck!</p></div>",
                        "image": "https://images.unsplash.com/photo-1587620962725-abab7fe55159?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [],
                "quiz": null
            }
        }
    ]
}

      // =====================================================
      // GLOBAL VARIABLES
      // =====================================================
      let currentUser = null;
      let currentLessonIndex = 0;
      let courseProgress = {};
      let userStats = {};
      let quizState = {
        currentQuestion: 0,
        answers: [],
        score: 0,
        isComplete: false,
        timeStarted: null,
        timeCompleted: null,
        currentQuestionIndex: 0,
      };

      // Enhanced session tracking
      let courseSession = {
        startTime: null,
        totalStudyTime: 0,
        lessonsStarted: 0,
        lessonsCompleted: 0,
        pageLoadTime: new Date(),
        lastActive: new Date(),
        interactions: 0,
        completedSections: [],
        totalTime: 0,
        interactionCount: 0,
        lastActivityTime: new Date(),
      };

      // Music Player Variables
      let audioPlayer = new Audio();

      // Achievement notification system
      let notificationQueue = [];
      let isShowingNotification = false;

      // =====================================================
      // INITIALIZATION
      // =====================================================
      document.addEventListener("DOMContentLoaded", async () => {
        try {
          showLoadingScreen();
          await checkAuth();

          if (currentUser) {
            // Initialize session tracking
            startCourseSession();

            // Load course data and progress
            await loadCourseData();
            await loadUserProfile();
            await loadProgress();

            // Initialize UI
            initializeEventListeners();
            renderSidebar();
            loadLesson(currentLessonIndex);

            // Initialize additional features
            initMusicPlayer();
            addMusicIndicator();
            initializeActivityTracking();

            hideLoadingScreen();
          } else {
            openAuthModal();
          }
        } catch (error) {
          console.error("Error initializing course:", error);
          hideLoadingScreen();
          showToast("Failed to initialize course system", "error");
        }
      });

      // =====================================================
      // AUTHENTICATION SYSTEM
      // =====================================================
      async function checkAuth() {
        try {
          const {
            data: { session },
            error,
          } = await supabase.auth.getSession();

          if (error) {
            console.error("Auth error:", error);
            currentUser = null;
            openAuthModal();
            return;
          }

          if (!session) {
            currentUser = null;
            openAuthModal();
            return;
          }

          currentUser = session.user;
          updateUIWithUser();
        } catch (error) {
          console.error("Error checking auth:", error);
          currentUser = null;
          openAuthModal();
        }
      }

      function updateUIWithUser() {
        if (!currentUser) return;

        const name =
          currentUser.user_metadata?.full_name ||
          currentUser.email.split("@")[0];
        const userElements = document.querySelectorAll("[data-user-name]");
        userElements.forEach((el) => (el.textContent = name));
      }

      // =====================================================
      // USER PROFILE & STATS MANAGEMENT
      // =====================================================
      async function loadUserProfile() {
        try {
          //  Step 1: Try to fetch existing profile
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("*")
            .eq("id", currentUser.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (!profile) {
            //  Step 2: Create new profile if missing
            await createUserProfile();
          } else {
            //  Step 3: Use existing profile
            userStats = profile;
            await updateLastActivity();
          }
        } catch (error) {
          console.error(" Error loading user profile:", error);
          showToast("Failed to load user profile", "error");
        }
      }
      async function createUserProfile() {
        try {
          const newProfile = {
            id: currentUser.id,
            full_name: currentUser.user_metadata?.full_name || "",
            email: currentUser.email,
            level: "Script Kiddie",
            total_points: 0,
            completed_courses: 0,
            current_streak: 0,
            total_certificates: 0,
            total_achievements: 0,
            sections_visited: 0,
            bonus_points: 0,
            in_progress_courses: 0,
            settings_changed: 0,
            midnight_sessions: 0,
            early_sessions: 0,
            weekend_sessions: 0,
            last_activity: new Date().toISOString(),
            created_at: new Date().toISOString(),
          };

          const { error } = await supabase
            .from("profiles")
            .insert([newProfile]);

          if (!error) {
            userStats = newProfile;
            // Award first login achievement
            setTimeout(() => checkAndUnlockAchievement("first_login"), 1000);
          }
        } catch (error) {
          console.error("Error creating user profile:", error);
        }
      }

      async function updateLastActivity() {
        try {
          const now = new Date();

          // Update activity tracking
          courseSession.lastActivityTime = now;

          // Update database
          await supabase
            .from("profiles")
            .update({
              last_activity: now.toISOString(),
            })
            .eq("id", currentUser.id);

          // Check time-based achievements
          await checkTimeBasedAchievements(now);
        } catch (error) {
          console.error("Error updating last activity:", error);
        }
      }

      // =====================================================
      // COURSE SESSION MANAGEMENT
      // =====================================================
      function startCourseSession() {
        courseSession.startTime = new Date();
        courseSession.pageLoadTime = new Date();

        logUserActivity("course_session_start", {
          course_id: COURSE_DATA.id,
          course_title: COURSE_DATA.title,
          user_agent: navigator.userAgent,
          screen_resolution: `${screen.width}x${screen.height}`,
        });

        // Check daily streak
        checkDailyStreak();
      }

      function initializeActivityTracking() {
        // Track page focus/blur for accurate study time
        document.addEventListener("visibilitychange", handleVisibilityChange);

        // Track user interactions
        ["click", "keydown", "scroll", "mousemove"].forEach((event) => {
          document.addEventListener(event, trackUserInteraction, {
            passive: true,
          });
        });

        // Periodic activity updates
        setInterval(updateStudyTime, 60000); // Every minute

        // Save session data before page unload
        window.addEventListener("beforeunload", saveSessionData);
      }

      function handleVisibilityChange() {
        if (document.hidden) {
          courseSession.lastActivityTime = new Date();
        } else {
          // Page became visible again - update activity
          updateLastActivity();
        }
      }

      function trackUserInteraction() {
        courseSession.interactionCount++;
        courseSession.lastActivityTime = new Date();

        // Throttle activity updates
        if (courseSession.interactionCount % 50 === 0) {
          updateLastActivity();
        }
      }

      function updateStudyTime() {
        if (!courseSession.startTime || document.hidden) return;

        const now = new Date();
        const sessionDuration = now - courseSession.startTime;
        courseSession.totalStudyTime = Math.floor(sessionDuration / 1000 / 60); // in minutes

        // Update progress with study time
        saveProgress();
      }

      function saveSessionData() {
        if (!currentUser || !courseSession.startTime) return;

        const sessionData = {
          user_id: currentUser.id,
          course_id: COURSE_DATA.id,
          session_duration: courseSession.totalStudyTime,
          lessons_viewed: courseSession.lessonsStarted,
          lessons_completed: courseSession.lessonsCompleted,
          interactions: courseSession.interactionCount,
          session_date: courseSession.startTime.toISOString().split("T")[0],
        };

        // Store in localStorage as backup
        localStorage.setItem(
          "course_session_backup",
          JSON.stringify(sessionData)
        );

        // Try to save to database
        logUserActivity("course_session_end", sessionData);
      }

      // =====================================================
      // COURSE DATA & PROGRESS MANAGEMENT
      // =====================================================
      async function loadCourseData() {
        try {
          // Update course info in UI
          document.getElementById("courseTitle").textContent =
            COURSE_DATA.title;
          document.getElementById("totalLessons").textContent =
            COURSE_DATA.lessons.length;

          // Log course access
          logUserActivity("course_access", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
          });
        } catch (error) {
          console.error("Error loading course data:", error);
        }
      }

      async function loadProgress() {
        try {
          // Get existing progress from database
          const { data, error } = await supabase
            .from("course_progress")
            .select("*")
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (data) {
            courseProgress = JSON.parse(data.lesson_progress || "{}");
            currentLessonIndex = data.current_lesson || 0;

            // Update session tracking
            courseSession.lessonsStarted = Object.keys(courseProgress).length;
            courseSession.lessonsCompleted = Object.values(
              courseProgress
            ).filter((p) => p.completed).length;
          } else {
            // Initialize new progress
            courseProgress = {};
            currentLessonIndex = 0;
            await saveProgress();

            // Award first course start achievement
            await checkAndUnlockAchievement("first_course_start");
          }

          updateProgressDisplay();
        } catch (error) {
          console.error("Error loading progress:", error);
          showToast("Failed to load progress", "error");
        }
      }

      async function saveProgress() {
        try {
          if (!currentUser) return;

          const now = new Date();
          const progressData = {
            user_id: currentUser.id,
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            current_lesson: currentLessonIndex,
            lesson_progress: JSON.stringify(courseProgress),
            progress: calculateOverallProgress(),
            lessons_completed: getCompletedLessonsCount(),
            lessons_started: Object.keys(courseProgress).length,
            study_time_minutes: courseSession.totalStudyTime,
            last_accessed: now.toISOString(),
            updated_at: now.toISOString(),
          };

          // Upsert progress
          const { error } = await supabase
            .from("course_progress")
            .upsert([progressData]);

          if (error) throw error;

          // Update user stats
          await updateUserStats();

          updateProgressDisplay();
        } catch (error) {
          console.error("Error saving progress:", error);
          showToast("Failed to save progress", "error");
        }
      }

      async function updateUserStats() {
        try {
          // Get all course progress for this user
          const { data: allProgress, error } = await supabase
            .from("course_progress")
            .select("progress, course_id, study_time_minutes")
            .eq("user_id", currentUser.id);

          if (error) throw error;

          // Calculate stats
          const completedCourses =
            allProgress?.filter((p) => p.progress >= 100).length || 0;
          const inProgressCourses =
            allProgress?.filter((p) => p.progress > 0 && p.progress < 100)
              .length || 0;
          const totalStudyTime =
            allProgress?.reduce(
              (sum, p) => sum + (p.study_time_minutes || 0),
              0
            ) || 0;

          // Calculate points (500 per completed course + achievement points)
          const coursePoints = completedCourses * 500;
          const bonusPoints = userStats.bonus_points || 0;
          const totalPoints = coursePoints + bonusPoints;

          // Update profile
          const updateData = {
            completed_courses: completedCourses,
            in_progress_courses: inProgressCourses,
            total_points: totalPoints,
            total_study_time: totalStudyTime,
            last_activity: new Date().toISOString(),
          };

          const { error: updateError } = await supabase
            .from("profiles")
            .update(updateData)
            .eq("id", currentUser.id);

          if (updateError) throw updateError;

          // Update local stats
          Object.assign(userStats, updateData);
        } catch (error) {
          console.error("Error updating user stats:", error);
        }
      }

      function calculateOverallProgress() {
        const completedLessons = getCompletedLessonsCount();
        return Math.round(
          (completedLessons / COURSE_DATA.lessons.length) * 100
        );
      }

      function getCompletedLessonsCount() {
        return Object.values(courseProgress).filter(
          (lesson) => lesson.completed
        ).length;
      }

      function updateProgressDisplay() {
        const completedCount = getCompletedLessonsCount();
        const progressPercent = calculateOverallProgress();

        // Update UI elements
        const elements = {
          completedLessons: completedCount,
          courseProgressPercent: `${progressPercent}%`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });

        // Update progress bar
        const progressBar = document.getElementById("courseProgressFill");
        if (progressBar) progressBar.style.width = `${progressPercent}%`;
      }

      // =====================================================
      // LESSON MANAGEMENT
      // =====================================================
      function loadLesson(index) {
        if (index < 0 || index >= COURSE_DATA.lessons.length) return;

        const lesson = COURSE_DATA.lessons[index];
        currentLessonIndex = index;

        // Mark lesson as started and track activity
        if (!courseProgress[lesson.id]) {
          courseProgress[lesson.id] = {
            started: true,
            completed: false,
            startedAt: new Date().toISOString(),
            timeSpent: 0,
          };

          courseSession.lessonsStarted++;
          saveProgress();

          // Log lesson start
          logUserActivity("lesson_start", {
            lesson_id: lesson.id,
            lesson_title: lesson.title,
            lesson_index: index,
          });
        }

        // Update lesson start time for time tracking
        courseProgress[lesson.id].currentSessionStart = new Date();

        // Update sidebar and navigation
        renderSidebar();
        updateNavigationButtons();

        // Update header info
        updateLessonHeader(lesson, index);

        // Render lesson content
        renderLessonContent(lesson);

        // Smooth scroll and animations
        window.scrollTo({ top: 0, behavior: "smooth" });
        document.getElementById("contentBody").scrollTop = 0;

        const contentBody = document.getElementById("contentBody");
        contentBody.classList.add("fade-in");
        setTimeout(() => contentBody.classList.remove("fade-in"), 500);

        // Check lesson-based achievements
        checkLessonAchievements(index + 1);
      }

      function updateLessonHeader(lesson, index) {
        const elements = {
          currentLessonNumber: index + 1,
          currentLessonTitle: lesson.title,
          navInfo: `Lesson ${index + 1} of ${COURSE_DATA.lessons.length}`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });
      }

      function renderSidebar() {
        const lessonNav = document.getElementById("lessonNav");
        if (!lessonNav) return;

        lessonNav.innerHTML = "";

        COURSE_DATA.lessons.forEach((lesson, index) => {
          const lessonItem = document.createElement("div");
          lessonItem.className = "lesson-item";

          // Determine lesson status
          const lessonProgress = courseProgress[lesson.id];
          const isCompleted = lessonProgress?.completed || false;
          const isInProgress = lessonProgress?.started || false;
          const isLocked = !isCompleted && !canAccessLesson(index);
          const isActive = index === currentLessonIndex;

          // Apply status classes
          if (isCompleted) lessonItem.classList.add("completed");
          if (isLocked) lessonItem.classList.add("locked");
          if (isActive) lessonItem.classList.add("active");

          // Determine status display
          let statusClass = "not-started";
          let statusIcon = index + 1;

          if (isCompleted) {
            statusClass = "completed";
            statusIcon = "";
          } else if (isInProgress) {
            statusClass = "in-progress";
            statusIcon = "";
          }

          // Create lesson item HTML
          lessonItem.innerHTML = `
            <div class="lesson-status ${statusClass}">${statusIcon}</div>
            <div class="lesson-info">
                <div class="lesson-title">${lesson.title}</div>
                <div class="lesson-meta">
                    ${
                      isCompleted
                        ? "Completed"
                        : isInProgress
                        ? "In Progress"
                        : isLocked
                        ? "Locked"
                        : "Not Started"
                    }
                </div>
            </div>
            <div class="lesson-duration">${lesson.duration}</div>
        `;

          // Add click handler if not locked
          if (!isLocked) {
            lessonItem.addEventListener("click", () => {
              if (index !== currentLessonIndex) {
                // Track lesson time before switching
                trackLessonTime();

                currentLessonIndex = index;
                loadLesson(index);
                closeSidebar();
              }
            });
          }

          lessonNav.appendChild(lessonItem);
        });
      }

      function canAccessLesson(index) {
        if (index === 0) return true; // First lesson always accessible

        // Can access if previous lesson is completed
        const previousLessonId = COURSE_DATA.lessons[index - 1].id;
        return courseProgress[previousLessonId]?.completed || false;
      }

      function trackLessonTime() {
        const currentLesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonProgress = courseProgress[currentLesson.id];

        if (lessonProgress?.currentSessionStart) {
          const sessionTime = Math.floor(
            (new Date() - new Date(lessonProgress.currentSessionStart)) /
              1000 /
              60
          );
          lessonProgress.timeSpent =
            (lessonProgress.timeSpent || 0) + sessionTime;
          delete lessonProgress.currentSessionStart;
        }
      }

      // =====================================================
      // LESSON CONTENT RENDERING
      // =====================================================
      function renderLessonContent(lesson) {
        const contentContainer = document.getElementById("lessonContent");
        if (!contentContainer) return;

        let contentHTML = `
        <div class="content-section">
            <h2>Learning Objectives</h2>
            <ul>
                ${lesson.objectives.map((obj) => `<li>${obj}</li>`).join("")}
            </ul>
        </div>
        
        <div class="content-section">
            <h2>Overview</h2>
            <p>${lesson.content.overview}</p>
        </div>
    `;

        // Render content sections
        lesson.content.sections.forEach((section) => {
          contentHTML += `
            <div class="content-section">
                <h2>${section.title}</h2>
                ${section.content}
                ${
                  section.image
                    ? `<img src="${section.image}" alt="${section.title}" class="content-image" loading="lazy">`
                    : ""
                }
            </div>
        `;
        });

        // Render code examples
        if (
          lesson.content.codeExamples &&
          lesson.content.codeExamples.length > 0
        ) {
          contentHTML += `<div class="content-section"><h2>Code Examples</h2></div>`;

          lesson.content.codeExamples.forEach((example, index) => {
            const codeId = `code-${lesson.id}-${index}`;
            contentHTML += `
                <div class="code-section">
                    <div class="code-header">
                        <span class="code-title">${example.title}</span>
                        <button class="copy-btn" onclick="copyCode('${codeId}')">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <pre class="code-block"><code id="${codeId}" class="language-${
              example.language
            }">${escapeHtml(example.code)}</code></pre>
                </div>
            `;
          });
        }

        // Render quiz
        contentHTML += renderQuiz(lesson.quiz);

        contentContainer.innerHTML = contentHTML;

        // Highlight code syntax if Prism is available
        setTimeout(() => {
          if (window.Prism) {
            Prism.highlightAll();
          }
        }, 100);
      }

      // =====================================================
      // QUIZ SYSTEM
      // =====================================================
      function renderQuiz(quiz) {
        const currentLessonProgress =
          courseProgress[COURSE_DATA.lessons[currentLessonIndex].id];
        const isCompleted = currentLessonProgress?.completed || false;

        let quizHTML = `
        <div class="quiz-section" id="quizSection">
            <div class="quiz-header">
                <h2 class="quiz-title">
                    <i class="fas fa-clipboard-check"></i>
                    Knowledge Check
                </h2>
                <p class="quiz-info">
                    Complete this quiz with ${quiz.passingScore}% or higher to unlock the next lesson.
                </p>
            </div>
    `;

        if (isCompleted) {
          const savedScore = currentLessonProgress.quizScore || 0;
          quizHTML += `
            <div class="quiz-results show">
                <div class="quiz-score pass">${savedScore}%</div>
                <div class="quiz-message">
                    <strong>Lesson Completed!</strong><br>
                    You've successfully passed this lesson's quiz.
                </div>
            </div>
        `;
        } else {
          // Render quiz questions
          quiz.questions.forEach((question, qIndex) => {
            quizHTML += `
                <div class="quiz-question ${
                  qIndex === 0 ? "active" : ""
                }" data-question="${qIndex}">
                    <div class="question-header">
                        <span class="question-number">Question ${
                          qIndex + 1
                        }</span>
                        <span class="question-progress">${qIndex + 1}/${
              quiz.questions.length
            }</span>
                    </div>
                    <div class="question-text">${question.question}</div>
                    <div class="question-options">
                        ${question.options
                          .map(
                            (option, oIndex) => `
                            <div class="option" data-option="${oIndex}" onclick="selectOption(${qIndex}, ${oIndex})">
                                <span class="option-letter">${String.fromCharCode(
                                  65 + oIndex
                                )}</span>
                                <span class="option-text">${option}</span>
                            </div>
                        `
                          )
                          .join("")}
                    </div>
                </div>
            `;
          });

          quizHTML += `
            <div class="quiz-controls">
                <button class="btn btn-secondary" id="prevQuestionBtn" onclick="previousQuestion()" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <div>
                    <button class="btn btn-secondary" id="nextQuestionBtn" onclick="nextQuestion()" disabled>
                        Next
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <button class="btn btn-primary" id="submitQuizBtn" onclick="submitQuiz()" style="display: none;">
                        <i class="fas fa-check"></i>
                        Submit Quiz
                    </button>
                </div>
            </div>

            <div class="quiz-results" id="quizResults">
                <div class="quiz-score" id="quizScore">0%</div>
                <div class="quiz-message" id="quizMessage"></div>
                <div class="quiz-actions">
                    <button class="btn btn-primary" id="continueBtn" onclick="completeLesson()" style="display: none;">
                        <i class="fas fa-arrow-right"></i>
                        Continue to Next Lesson
                    </button>
                    <button class="btn btn-secondary" onclick="retakeQuiz()">
                        <i class="fas fa-redo"></i>
                        Retake Quiz
                    </button>
                </div>
            </div>
        `;
        }

        quizHTML += "</div>";
        return quizHTML;
      }

      // Quiz interaction functions
      function selectOption(questionIndex, optionIndex) {
        // Clear previous selections
        document
          .querySelectorAll(`[data-question="${questionIndex}"] .option`)
          .forEach((opt) => {
            opt.classList.remove("selected");
          });

        // Select current option
        const selectedOption = document.querySelector(
          `[data-question="${questionIndex}"] [data-option="${optionIndex}"]`
        );
        selectedOption.classList.add("selected");

        // Store answer
        quizState.answers[questionIndex] = optionIndex;

        // Update navigation
        const isLastQuestion =
          questionIndex ===
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length - 1;
        if (isLastQuestion) {
          document.getElementById("submitQuizBtn").style.display =
            "inline-flex";
          document.getElementById("nextQuestionBtn").style.display = "none";
        } else {
          document.getElementById("nextQuestionBtn").disabled = false;
        }
      }

      function nextQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const nextQuestionEl = currentQuestionEl.nextElementSibling;

        if (
          nextQuestionEl &&
          nextQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          nextQuestionEl.classList.add("active");
          quizState.currentQuestion++;
          updateQuizNavigation();
        }
      }

      function previousQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const prevQuestionEl = currentQuestionEl.previousElementSibling;

        if (
          prevQuestionEl &&
          prevQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          prevQuestionEl.classList.add("active");
          quizState.currentQuestion--;
          updateQuizNavigation();
        }
      }

      function updateQuizNavigation() {
        const totalQuestions =
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length;
        const prevBtn = document.getElementById("prevQuestionBtn");
        const nextBtn = document.getElementById("nextQuestionBtn");
        const submitBtn = document.getElementById("submitQuizBtn");

        prevBtn.disabled = quizState.currentQuestion === 0;

        const hasAnswer =
          quizState.answers[quizState.currentQuestion] !== undefined;
        const isLastQuestion = quizState.currentQuestion === totalQuestions - 1;

        if (isLastQuestion) {
          nextBtn.style.display = "none";
          submitBtn.style.display = hasAnswer ? "inline-flex" : "none";
        } else {
          nextBtn.style.display = "inline-flex";
          nextBtn.disabled = !hasAnswer;
          submitBtn.style.display = "none";
        }
      }

      async function submitQuiz() {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const quiz = lesson.quiz;
        let correctAnswers = 0;

        // Hide questions and controls
        document
          .querySelectorAll(".quiz-question")
          .forEach((q) => (q.style.display = "none"));
        document.querySelector(".quiz-controls").style.display = "none";

        // Calculate score and highlight answers
        quiz.questions.forEach((question, index) => {
          const userAnswer = quizState.answers[index];
          const correctAnswer = question.correct;
          const isCorrect = userAnswer === correctAnswer;

          if (isCorrect) correctAnswers++;

          // Highlight answers
          const questionEl = document.querySelector(
            `[data-question="${index}"]`
          );
          const options = questionEl.querySelectorAll(".option");

          options[correctAnswer].classList.add("correct");
          if (userAnswer !== correctAnswer && userAnswer !== undefined) {
            options[userAnswer].classList.add("incorrect");
          }
        });

        const score = Math.round(
          (correctAnswers / quiz.questions.length) * 100
        );
        const passed = score >= quiz.passingScore;

        // Update quiz results UI
        const quizScore = document.getElementById("quizScore");
        const quizMessage = document.getElementById("quizMessage");
        const quizActions = document.querySelector(".quiz-actions");

        quizScore.textContent = `${score}%`;
        quizScore.className = `quiz-score ${passed ? "pass" : "fail"}`;

        if (passed) {
          quizMessage.innerHTML = `
            <strong>Congratulations!</strong><br>
            You passed with ${score}%. You can now proceed to the next lesson.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-primary" onclick="completeLesson()">
                <i class="fas fa-arrow-right"></i>
                Continue to Next Lesson
            </button>
        `;

          // Mark lesson as completed
          await markLessonComplete(score);
        } else {
          quizMessage.innerHTML = `
            <strong>Not quite there yet.</strong><br>
            You scored ${score}%. You need ${quiz.passingScore}% to pass. Review the material and try again.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-secondary" onclick="retakeQuiz()">
                <i class="fas fa-redo"></i>
                Retake Quiz
            </button>
        `;
        }

        document.getElementById("quizResults").classList.add("show");

        // Log quiz completion
        logUserActivity("quiz_completed", {
          lesson_id: lesson.id,
          lesson_title: lesson.title,
          score: score,
          passed: passed,
          attempts: (courseProgress[lesson.id]?.quizAttempts || 0) + 1,
        });

        // Scroll to results
        document
          .getElementById("quizResults")
          .scrollIntoView({ behavior: "smooth" });
      }

      function retakeQuiz() {
        // Reset quiz state
        quizState = {
          currentQuestion: 0,
          answers: [],
          score: 0,
          isComplete: false,
        };

        // Track quiz retry
        const lessonId = COURSE_DATA.lessons[currentLessonIndex].id;
        if (!courseProgress[lessonId]) courseProgress[lessonId] = {};
        courseProgress[lessonId].quizAttempts =
          (courseProgress[lessonId].quizAttempts || 0) + 1;

        // Reload lesson content
        loadLesson(currentLessonIndex);

        // Scroll to quiz
        setTimeout(() => {
          document
            .getElementById("quizSection")
            .scrollIntoView({ behavior: "smooth" });
        }, 500);
      }

      async function markLessonComplete(score) {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonId = lesson.id;

        // Track lesson completion time
        trackLessonTime();

        // Update lesson progress
        courseProgress[lessonId] = {
          ...courseProgress[lessonId],
          completed: true,
          quizScore: score,
          completedAt: new Date().toISOString(),
          finalScore: score,
        };

        // Update session tracking
        courseSession.lessonsCompleted++;

        // Save progress to database
        await saveProgress();

        // Update UI
        renderSidebar();
        updateNavigationButtons();

        // Check various achievements
        await checkLessonCompletionAchievements();
        await checkPerfectScoreAchievements(score);
        await checkStudyTimeAchievements();

        // Log lesson completion
        logUserActivity("lesson_completed", {
          lesson_id: lessonId,
          lesson_title: lesson.title,
          final_score: score,
          time_spent: courseProgress[lessonId].timeSpent || 0,
          lesson_number: currentLessonIndex + 1,
        });

        showToast("Lesson completed successfully!", "success");
      }

      async function completeLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          // Move to next lesson
          currentLessonIndex++;
          loadLesson(currentLessonIndex);
        } else {
          // Course completion
          await completeCourse();
        }
      }

      async function completeCourse() {
        try {
          const completionTime = courseSession.totalStudyTime;

          // Update course progress to 100% completed
          await supabase
            .from("course_progress")
            .update({
              progress: 100,
              completed_at: new Date().toISOString(),
              completion_time_minutes: completionTime,
            })
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Award course completion achievements
          await checkAndUnlockAchievement("course_completion_1");
          await checkSpeedCompletionAchievements(completionTime);
          await checkCourseStreakAchievements();

          // Update user stats
          await updateUserStats();

          // Show completion message
          showToast(
            "Congratulations! Course completed successfully!",
            "certificate"
          );

          // Log course completion
          logUserActivity("course_completed", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            completion_time_minutes: completionTime,
            total_lessons: COURSE_DATA.lessons.length,
            average_quiz_score: calculateAverageQuizScore(),
          });

          // Redirect to dashboard after delay
          setTimeout(() => {
            window.location.href = "/dashboard";
          }, 3000);
        } catch (error) {
          console.error("Error completing course:", error);
          showToast("Error marking course as complete", "error");
        }
      }

      // =====================================================
      // ACHIEVEMENT INTEGRATION SYSTEM
      // =====================================================
      async function checkAndUnlockAchievement(
        achievementId,
        skipNotification = false
      ) {
        try {
          // Prevent duplicate checks
          const cacheKey = `achievement_${achievementId}_${currentUser.id}`;
          if (sessionStorage.getItem(cacheKey)) return false;

          // Check if already unlocked
          const { data: existing, error } = await supabase
            .from("user_achievements")
            .select("id")
            .eq("user_id", currentUser.id)
            .eq("achievement_id", achievementId)
            .single();

          if (existing) {
            sessionStorage.setItem(cacheKey, "true");
            return false;
          }

          // Award achievement
          const achievementData = {
            user_id: currentUser.id,
            achievement_id: achievementId,
            unlocked_at: new Date().toISOString(),
            points_awarded: getAchievementPoints(achievementId),
            context: "course_system",
          };

          const { data, error: insertError } = await supabase
            .from("user_achievements")
            .insert([achievementData])
            .select()
            .single();

          if (insertError) {
            if (insertError.code === "23505") return false; // Already exists
            throw insertError;
          }

          // Update user points
 await supabase.rpc('increment_user_stats', {
  user_id_param: currentUser.id,
  points_to_add: achievementData.points_awarded,
  achievements_to_add: 1
});

          // Cache and queue notification
          sessionStorage.setItem(cacheKey, "true");

          if (!skipNotification) {
            queueAchievementNotification({
              id: achievementId,
              name: getAchievementName(achievementId),
              description: getAchievementDescription(achievementId),
              points: achievementData.points_awarded,
              rarity: getAchievementRarity(achievementId),
              icon: getAchievementIcon(achievementId),
            });
          }

          return true;
        } catch (error) {
          console.error("Error unlocking achievement:", error);
          return false;
        }
      }

      // Helper functions for achievement data (replace with your actual achievement definitions)
      function getAchievementPoints(id) {
        const pointsMap = {
          first_course_start: 75,
          first_lesson: 100,
          course_completion_1: 500,
          perfect_score: 250,
          speed_demon: 750,
          marathon_learner: 500,
          night_owl: 200,
          early_bird: 200,
          weekend_warrior: 150,
          // Add more as needed
        };
        return pointsMap[id] || 100;
      }

      function getAchievementName(id) {
        const nameMap = {
          first_course_start: "Learning Initiated",
          first_lesson: "First Steps",
          course_completion_1: "Course Conqueror",
          perfect_score: "Perfectionist",
          speed_demon: "Speed Demon",
          // Add more as needed
        };
        return nameMap[id] || "Achievement Unlocked";
      }

      function getAchievementDescription(id) {
        const descMap = {
          first_course_start: "Start your first cybersecurity course",
          first_lesson: "Complete your first lesson",
          course_completion_1: "Complete your first course",
          perfect_score: "Score 100% on any quiz",
          speed_demon: "Complete a course in under 2 hours",
          // Add more as needed
        };
        return descMap[id] || "Achievement description";
      }

      function getAchievementRarity(id) {
        const rarityMap = {
          first_course_start: "common",
          first_lesson: "bronze",
          course_completion_1: "silver",
          perfect_score: "gold",
          speed_demon: "legendary",
          // Add more as needed
        };
        return rarityMap[id] || "common";
      }

      function getAchievementIcon(id) {
        const iconMap = {
          first_course_start: "fas fa-play",
          first_lesson: "fas fa-baby",
          course_completion_1: "fas fa-trophy",
          perfect_score: "fas fa-star",
          speed_demon: "fas fa-rocket",
          // Add more as needed
        };
        return iconMap[id] || "fas fa-award";
      }

      async function checkLessonAchievements(lessonNumber) {
        if (lessonNumber === 1) {
          await checkAndUnlockAchievement("first_lesson");
        }

        // Check if user has completed multiple lessons in one day
        const today = new Date().toISOString().split("T")[0];
        const todayCompletions = Object.values(courseProgress).filter(
          (p) => p.completed && p.completedAt?.startsWith(today)
        ).length;

        if (todayCompletions >= 3) {
          await checkAndUnlockAchievement("lesson_marathon");
        }
      }

      async function checkLessonCompletionAchievements() {
        const completedCount = getCompletedLessonsCount();

        // Lesson-based achievements
        const lessonMilestones = [1, 5, 10, 25, 50, 100];
        for (const milestone of lessonMilestones) {
          if (completedCount >= milestone) {
            await checkAndUnlockAchievement(`lessons_${milestone}`);
          }
        }

        // Course completion achievements
        if (completedCount === COURSE_DATA.lessons.length) {
          await checkAndUnlockAchievement("course_completion_1");

          // Check for additional course completion achievements
          const { data: allCourses } = await supabase
            .from("course_progress")
            .select("course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100);

          const totalCompleted = allCourses?.length || 0;

          const courseMilestones = [1, 5, 10, 25];
          for (const milestone of courseMilestones) {
            if (totalCompleted >= milestone) {
              await checkAndUnlockAchievement(`course_completion_${milestone}`);
            }
          }
        }
      }

      async function checkPerfectScoreAchievements(score) {
        if (score === 100) {
          await checkAndUnlockAchievement("perfect_score");

          // Check for consecutive perfect scores
          const recentScores = Object.values(courseProgress)
            .filter((p) => p.completed && p.quizScore)
            .slice(-5) // Last 5 completed
            .map((p) => p.quizScore);

          if (
            recentScores.length >= 3 &&
            recentScores.every((s) => s === 100)
          ) {
            await checkAndUnlockAchievement("perfectionist_streak");
          }
        }
      }

      async function checkSpeedCompletionAchievements(completionTime) {
        // Speed demon: Complete course in under 2 hours (120 minutes)
        if (completionTime <= 120) {
          await checkAndUnlockAchievement("speed_demon");
        }

        // Quick learner: Complete course in under 4 hours (240 minutes)
        if (completionTime <= 240) {
          await checkAndUnlockAchievement("quick_learner");
        }
      }

      async function checkStudyTimeAchievements() {
        const totalTime = courseSession.totalStudyTime;

        // Marathon learner: Study for 8+ hours in a course session
        if (totalTime >= 480) {
          // 8 hours
          await checkAndUnlockAchievement("marathon_learner");
        }

        // Dedicated learner: Study for 4+ hours
        if (totalTime >= 240) {
          // 4 hours
          await checkAndUnlockAchievement("dedicated_learner");
        }
      }

      async function checkCourseStreakAchievements() {
        try {
          // Check for consecutive course completions
          const { data: recentCourses, error } = await supabase
            .from("course_progress")
            .select("completed_at, course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100)
            .order("completed_at", { ascending: false })
            .limit(10);

          if (error || !recentCourses) return;

          // Check for courses completed on consecutive days
          let consecutiveDays = 1;
          for (let i = 1; i < recentCourses.length; i++) {
            const prevDate = new Date(
              recentCourses[i - 1].completed_at
            ).toDateString();
            const currentDate = new Date(
              recentCourses[i].completed_at
            ).toDateString();
            const dayDiff =
              Math.abs(new Date(prevDate) - new Date(currentDate)) /
              (1000 * 60 * 60 * 24);

            if (dayDiff <= 1) {
              consecutiveDays++;
            } else {
              break;
            }
          }

          if (consecutiveDays >= 3) {
            await checkAndUnlockAchievement("learning_streak");
          }
        } catch (error) {
          console.error("Error checking course streak achievements:", error);
        }
      }

      // =====================================================
      // TIME-BASED ACHIEVEMENTS
      // =====================================================
      async function checkTimeBasedAchievements(timestamp) {
        const hour = timestamp.getHours();
        const dayOfWeek = timestamp.getDay();

        // Night owl (after midnight, before 6 AM)
        if (hour >= 0 && hour < 6) {
          await incrementTimeBasedCounter("midnight_sessions", "night_owl");
        }

        // Early bird (4 AM to 6 AM)
        if (hour >= 4 && hour < 6) {
          await incrementTimeBasedCounter("early_sessions", "early_bird");
        }

        // Weekend warrior (Saturday = 6, Sunday = 0)
        if (dayOfWeek === 0 || dayOfWeek === 6) {
          await incrementTimeBasedCounter(
            "weekend_sessions",
            "weekend_warrior"
          );
        }
      }

      async function incrementTimeBasedCounter(counterType, achievementId) {
        try {
          const dateStr = new Date().toISOString().split("T")[0];
          const cacheKey = `${counterType}_${currentUser.id}_${dateStr}`;

          // Prevent multiple increments per day
          if (sessionStorage.getItem(cacheKey)) return;

          // Update counter
         await supabase.rpc('increment_profile_counter', {
  user_id_param: currentUser.id,
  counter_field: counterType,
  increment_value: 1
});

          // Cache to prevent double counting
          sessionStorage.setItem(cacheKey, "true");

          // Check related achievement
          if (achievementId) {
            await checkAndUnlockAchievement(achievementId, true);
          }
        } catch (error) {
          console.error(`Error incrementing ${counterType}:`, error);
        }
      }

      async function checkDailyStreak() {
        try {
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("last_activity, current_streak, last_streak_date")
            .eq("id", currentUser.id)
            .single();

          if (error) throw error;

          const now = new Date();
          const today = now.toDateString();
          const lastActivity = profile.last_activity
            ? new Date(profile.last_activity)
            : null;
          const lastStreakDate = profile.last_streak_date
            ? new Date(profile.last_streak_date).toDateString()
            : null;

          let newStreak = profile.current_streak || 0;
          let shouldUpdateStreak = false;

          if (!lastActivity) {
            // First time user
            newStreak = 1;
            shouldUpdateStreak = true;
          } else {
            const daysSinceLastActivity = Math.floor(
              (now - lastActivity) / (1000 * 60 * 60 * 24)
            );

            if (lastStreakDate === today) {
              // Already counted today's streak
              return newStreak;
            } else if (
              daysSinceLastActivity === 1 ||
              (daysSinceLastActivity === 0 && lastStreakDate !== today)
            ) {
              // Consecutive day or same day but not counted yet
              newStreak += 1;
              shouldUpdateStreak = true;
            } else if (daysSinceLastActivity > 1) {
              // Streak broken
              newStreak = 1;
              shouldUpdateStreak = true;
            }
          }

          if (shouldUpdateStreak) {
            await supabase
              .from("profiles")
              .update({
                current_streak: newStreak,
                last_activity: now.toISOString(),
                last_streak_date: now.toISOString(),
              })
              .eq("id", currentUser.id);

            userStats.current_streak = newStreak;

            showToast(`Daily streak: ${newStreak} days!`, "success");
            await checkStreakAchievements(newStreak);
          }

          return newStreak;
        } catch (error) {
          console.error("Error checking daily streak:", error);
          return 0;
        }
      }

      async function checkStreakAchievements(currentStreak) {
        const streakMilestones = [3, 7, 14, 30, 100, 365];

        for (const milestone of streakMilestones) {
          if (currentStreak >= milestone) {
            await checkAndUnlockAchievement(`streak_${milestone}`);
          }
        }
      }

      // =====================================================
      // USER ACTIVITY LOGGING
      // =====================================================
      async function logUserActivity(activityType, metadata = {}) {
        try {
          const now = new Date();

          const activityData = {
            user_id: currentUser.id,
            activity_type: activityType,
            timestamp: now.toISOString(),
            course_id: COURSE_DATA.id,
            lesson_index: currentLessonIndex,
            session_duration: courseSession.totalStudyTime,
            metadata: JSON.stringify(metadata),
            created_at: now.toISOString(),
          };

          // Try to log to activities table
          const { error } = await supabase
            .from("user_activities")
            .insert([activityData]);

          if (error && error.code !== "42P01") {
            console.warn("Activity logging failed:", error.message);
          }

          // Always update last activity in profile
          await supabase
            .from("profiles")
            .update({ last_activity: now.toISOString() })
            .eq("id", currentUser.id);
        } catch (error) {
          console.error("Error logging user activity:", error);
        }
      }

      // =====================================================
      // NAVIGATION SYSTEM
      // =====================================================
      function updateNavigationButtons() {
        const prevBtn = document.getElementById("prevLessonBtn");
        const nextBtn = document.getElementById("nextLessonBtn");

        if (!prevBtn || !nextBtn) return;

        // Previous button
        prevBtn.disabled = currentLessonIndex === 0;

        // Next button logic
        const isLastLesson =
          currentLessonIndex === COURSE_DATA.lessons.length - 1;
        const canGoNext =
          currentLessonIndex < COURSE_DATA.lessons.length - 1 &&
          canAccessLesson(currentLessonIndex + 1);

        if (isLastLesson) {
          const isCurrentCompleted =
            courseProgress[COURSE_DATA.lessons[currentLessonIndex].id]
              ?.completed;
          nextBtn.disabled = !isCurrentCompleted;
          nextBtn.innerHTML = '<i class="fas fa-trophy"></i> Complete Course';
        } else {
          nextBtn.disabled = !canGoNext;
          nextBtn.innerHTML = 'Next <i class="fas fa-chevron-right"></i>';
        }
      }

      // Navigation button event handlers
      function goToPreviousLesson() {
        if (currentLessonIndex > 0) {
          trackLessonTime(); // Track time spent on current lesson
          currentLessonIndex--;
          loadLesson(currentLessonIndex);
        }
      }

      function goToNextLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          const canGoNext = canAccessLesson(currentLessonIndex + 1);
          if (canGoNext) {
            trackLessonTime();
            currentLessonIndex++;
            loadLesson(currentLessonIndex);
          } else {
            showToast("Complete the current lesson quiz to proceed", "warning");
          }
        } else {
          // Complete course
          completeCourse();
        }
      }

      // =====================================================
      // SIDEBAR FUNCTIONS
      // =====================================================
      function toggleSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.toggle("open");
        if (overlay) overlay.classList.toggle("active");
      }

      function closeSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.remove("open");
        if (overlay) overlay.classList.remove("active");
      }

      // =====================================================
      // ACHIEVEMENT NOTIFICATION SYSTEM
      // =====================================================
      function queueAchievementNotification(achievement) {
        notificationQueue.push(achievement);
        processNotificationQueue();
      }

      function processNotificationQueue() {
        if (isShowingNotification || notificationQueue.length === 0) return;

        isShowingNotification = true;
        const achievement = notificationQueue.shift();
        showAchievementNotification(achievement);

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          isShowingNotification = false;
          processNotificationQueue();
        }, duration + 500);
      }

      function showAchievementNotification(achievement) {
        const notification = document.getElementById("achievementNotification");
        if (!notification) return;

        const icon = document.getElementById("notificationIcon");
        const title = document.getElementById("notificationTitle");
        const description = document.getElementById("notificationDescription");
        const points = document.getElementById("notificationPoints");

        if (icon) {
          icon.innerHTML = `<i class="${achievement.icon}"></i>`;
          icon.className = `notification-icon ${achievement.rarity}`;
        }
        if (title) title.textContent = achievement.name;
        if (description) description.textContent = achievement.description;
        if (points) points.textContent = `+${achievement.points} Points`;

        notification.className = `achievement-notification ${achievement.rarity}`;
        notification.classList.add("show");

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          notification.classList.remove("show");
        }, duration);
      }

      // =====================================================
      // UTILITY FUNCTIONS
      // =====================================================
      function calculateAverageQuizScore() {
        const scores = Object.values(courseProgress)
          .filter((p) => p.completed && p.quizScore)
          .map((p) => p.quizScore);

        if (scores.length === 0) return 0;
        return Math.round(
          scores.reduce((sum, score) => sum + score, 0) / scores.length
        );
      }

      async function resetProgress() {
        if (
          !confirm(
            "Are you sure you want to reset your progress? This action cannot be undone."
          )
        ) {
          return;
        }

        try {
          // Track lesson time before reset
          trackLessonTime();

          // Reset local state
          courseProgress = {};
          currentLessonIndex = 0;
          courseSession = {
            startTime: new Date(),
            totalStudyTime: 0,
            lessonsStarted: 0,
            lessonsCompleted: 0,
            pageLoadTime: new Date(),
            interactionCount: 0,
            lastActivityTime: new Date(),
          };

          // Delete from database
          await supabase
            .from("course_progress")
            .delete()
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Log reset activity
          logUserActivity("progress_reset", {
            course_id: COURSE_DATA.id,
            reset_reason: "manual",
          });

          // Reinitialize
          await saveProgress();
          renderSidebar();
          loadLesson(0);

          showToast("Progress reset successfully", "success");
        } catch (error) {
          console.error("Error resetting progress:", error);
          showToast("Failed to reset progress", "error");
        }
      }

      function copyCode(codeId) {
        const codeElement = document.getElementById(codeId);
        if (!codeElement) return;

        const text = codeElement.textContent;

        navigator.clipboard
          .writeText(text)
          .then(() => {
            showToast("Code copied to clipboard!", "success");

            // Track code copy for achievements
            logUserActivity("code_copied", {
              code_section: codeId,
              lesson_id: COURSE_DATA.lessons[currentLessonIndex].id,
            });
          })
          .catch((err) => {
            console.error("Failed to copy code:", err);
            showToast("Failed to copy code", "error");

            // Fallback for older browsers
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            try {
              document.execCommand("copy");
              showToast("Code copied to clipboard!", "success");
            } catch (fallbackError) {
              showToast(
                "Copy failed - please select and copy manually",
                "error"
              );
            }
            document.body.removeChild(textArea);
          });
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // =====================================================
      // UI FEEDBACK SYSTEMS
      // =====================================================
      function showToast(message, type = "success") {
        const toast = document.getElementById("toast");
        const messageEl = document.getElementById("toastMessage");

        if (!toast || !messageEl) {
          console.log(`Toast: ${message} (${type})`);
          return;
        }

        messageEl.textContent = message;
        toast.className = `toast ${type} show`;

        setTimeout(() => {
          toast.classList.remove("show");
        }, 4000);
      }

      function showLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) loadingScreen.classList.remove("hidden");
      }

      function hideLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) {
          setTimeout(() => {
            loadingScreen.classList.add("hidden");
          }, 1000);
        }
      }

      // =====================================================
      // MUSIC PLAYER INTEGRATION
      // =====================================================
      function initMusicPlayer() {
        const btnText = document.getElementById("music-button-text");
        const icon = document.getElementById("music-icon");
        const dropdown = document.getElementById("music-dropdown-content");

        if (!btnText || !icon || !dropdown) return;

        function setUI(state) {
          btnText.textContent =
            state === "Playing" ? "PAUSE MUSIC" : "STUDY MUSIC";
          icon.className =
            state === "Playing"
              ? "fa-solid fa-circle-pause"
              : "fa-solid fa-music";
        }

        // Load saved music state
        const savedSrc = localStorage.getItem("cybersec_music_src");
        const savedTime = parseFloat(
          localStorage.getItem("cybersec_music_time") || 0
        );

        if (savedSrc) {
          audioPlayer.src = savedSrc;
          audioPlayer.currentTime = savedTime;
          audioPlayer
            .play()
            .then(() => setUI("Playing"))
            .catch(() => setUI("Stopped"));
        }

        // Music button click handler
        document
          .getElementById("music-dropdown")
          .querySelector("button")
          .addEventListener("click", (e) => {
            e.stopPropagation();
            dropdown.style.display =
              dropdown.style.display === "block" ? "none" : "block";

            if (audioPlayer.src && !audioPlayer.paused) {
              audioPlayer.pause();
              setUI("Stopped");
            } else if (audioPlayer.src) {
              audioPlayer.play().then(() => setUI("Playing"));
            }
          });

        // Music selection handlers
        dropdown.querySelectorAll("a[data-src]").forEach((link) => {
          link.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.src = link.dataset.src;
            audioPlayer.play().then(() => setUI("Playing"));
            localStorage.setItem("cybersec_music_src", link.dataset.src);
            dropdown.style.display = "none";
          });
        });

        // Stop music handler
        const stopLink = document.getElementById("stop-music-link");
        if (stopLink) {
          stopLink.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            audioPlayer.removeAttribute("src");
            setUI("Stopped");
            localStorage.removeItem("cybersec_music_src");
            localStorage.removeItem("cybersec_music_time");
            dropdown.style.display = "none";
          });
        }

        // Save music state before page unload
        window.addEventListener("beforeunload", () => {
          if (!audioPlayer.paused && audioPlayer.src) {
            localStorage.setItem("cybersec_music_src", audioPlayer.src);
            localStorage.setItem(
              "cybersec_music_time",
              audioPlayer.currentTime
            );
          }
        });

        // Close dropdown when clicking outside
        window.addEventListener("click", (e) => {
          if (!e.target.closest("#music-dropdown")) {
            dropdown.style.display = "none";
          }
        });
      }

      // Show initial music indicator
      function addMusicIndicator() {
        const musicBtn = document.querySelector("#music-dropdown");
        if (musicBtn) {
          const indicator = document.createElement("div");
          indicator.className = "music-indicator";
          indicator.innerHTML = `<i class="fa-solid fa-music"></i> Try Study Music!`;

          musicBtn.style.position = "relative";
          musicBtn.appendChild(indicator);

          setTimeout(() => indicator.remove(), 3000);
        }
      }

      // Initialize Event Listeners
      function initializeEventListeners() {
        // Navigation buttons
        document
          .getElementById("prevLessonBtn")
          ?.addEventListener("click", goToPreviousLesson);
        document
          .getElementById("nextLessonBtn")
          ?.addEventListener("click", goToNextLesson);

        // Reset progress button
        document
          .getElementById("resetProgressBtn")
          ?.addEventListener("click", resetProgress);

        // Mobile menu toggle
        document
          .getElementById("menuToggle")
          ?.addEventListener("click", toggleSidebar);
        document
          .getElementById("sidebarOverlay")
          ?.addEventListener("click", closeSidebar);

        // Keyboard shortcuts
        document.addEventListener("keydown", handleKeyboardShortcuts);

        // Window resize handler
        window.addEventListener("resize", handleWindowResize);

        // Content interaction tracking
        document.getElementById("contentBody")?.addEventListener(
          "scroll",
          debounce(() => {
            trackUserInteraction();
          }, 1000)
        );
      }

      // Keyboard Shortcuts
      function handleKeyboardShortcuts(e) {
        if (document.querySelector(".quiz-question.active")) return;

        if (e.key === "ArrowLeft" && e.ctrlKey) {
          e.preventDefault();
          goToPreviousLesson();
        } else if (e.key === "ArrowRight" && e.ctrlKey) {
          e.preventDefault();
          goToNextLesson();
        }
      }

      // Window Resize Handler
      function handleWindowResize() {
        if (window.innerWidth > 768) {
          closeSidebar();
        }
      }

      // Debounce Helper
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Initialize responsive behavior
      if (window.innerWidth <= 768) {
        document.getElementById("menuToggle").style.display = "inline-flex";
      }

      // Auto-save progress periodically
      setInterval(async () => {
        if (currentUser && Object.keys(courseProgress).length > 0) {
          await saveProgress();
        }
      }, 60000); // Save every minute

      // System initialization logging
      console.log("CyberSec Academy Course System Initialized");
      console.log("Current Course:", COURSE_DATA.title);
      console.log("Total Lessons:", COURSE_DATA.lessons.length);

      // Google OAuth Integration
      const googleBtn = document.querySelector(".btn-google");
      if (googleBtn) {
        googleBtn.addEventListener("click", async () => {
          const { data, error } = await supabase.auth.signInWithOAuth({
            provider: "google",
            options: {
              redirectTo:
                window.location.origin +
                "/courses/advanced-exploit-development",
            },
          });

          if (error) {
            console.error("Google login error:", error.message);
            showToast("Google login failed: " + error.message, "error");
          }
        });
      }

      // Check for existing session
      supabase.auth.getSession().then(({ data }) => {
        if (data.session) {
          console.log("User already logged in:", data.session.user);
          currentUser = data.session.user;
          startCourseSession();
        }
      });

      // Add missing auth modal functions
      function openAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "flex";
        }
      }

      function closeAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Add auth tab switching functionality
      document.getElementById("tabSignIn")?.addEventListener("click", () => {
        document.getElementById("tabSignIn").classList.add("active");
        document.getElementById("tabSignUp").classList.remove("active");
        document.getElementById("signInForm").style.display = "block";
        document.getElementById("signUpForm").style.display = "none";
      });

      document.getElementById("tabSignUp")?.addEventListener("click", () => {
        document.getElementById("tabSignUp").classList.add("active");
        document.getElementById("tabSignIn").classList.remove("active");
        document.getElementById("signUpForm").style.display = "block";
        document.getElementById("signInForm").style.display = "none";
      });

      document
        .getElementById("closeAuthModal")
        ?.addEventListener("click", closeAuthModal);

      // Improved error handling for auth session
      supabase.auth.onAuthStateChange((event, session) => {
        if (event === "SIGNED_IN") {
          currentUser = session.user;
          closeAuthModal();
          startCourseSession();
        } else if (event === "SIGNED_OUT") {
          currentUser = null;
          openAuthModal();
        }
      });

      // Add form submission handlers
      document
        .getElementById("emailSignInForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signInEmail").value;
          const password = document.getElementById("signInPassword").value;

          try {
            const { data, error } = await supabase.auth.signInWithPassword({
              email,
              password,
            });

            if (error) throw error;

            closeAuthModal();
          } catch (error) {
            showToast(error.message, "error");
          }
        });

      document
        .getElementById("emailSignUpForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signUpEmail").value;
          const password = document.getElementById("signUpPassword").value;
          const name = document.getElementById("signUpName").value;

          try {
            const { data, error } = await supabase.auth.signUp({
              email,
              password,
              options: {
                data: {
                  full_name: name,
                },
              },
            });

            if (error) throw error;

            showToast(
              "Account created successfully! Please check your email.",
              "success"
            );
          } catch (error) {
            showToast(error.message, "error");
          }
        });
    </script>
  </body>
</html>

