


<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- ========== Start: SEO & Schema Enhancement ========== -->
    <title>Blockchain Security Course | CipherHall</title>
    <meta name="description" content="A 50-lesson masterclass on blockchain security. Learn smart contract auditing, DeFi security, consensus mechanisms, cryptography, and more with hands-on labs.">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png" />
    <link rel="shortcut icon" href="/favicon.png" type="image/x-icon" />
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png" />
    <link rel="canonical" href="https://www.cipherhall.com/courses/blockchain-security.html" />
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Course",
      "name": "Blockchain Security - Complete Learning Roadmap",
      "description": "A comprehensive course covering the entire landscape of blockchain security, from cryptographic fundamentals to advanced threat analysis and mitigation.",
      "provider": {
        "@type": "Organization",
        "name": "CipherHall",
        "sameAs": "https://www.cipherhall.com"
      },
      "hasCourseInstance": {
        "@type": "CourseInstance",
        "courseMode": "Online",
        "instructor": {
          "@type": "Person",
          "name": "Dr. Evelyn Reed"
        }
      }
    }
    </script>
    <!-- ========== End: SEO & Schema Enhancement ========== -->

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Exo+2:wght@700;800;900&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css"
    />
    <link rel="stylesheet" href="assets/css/coursepages.css">
</head>
  <body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
      <div class="loader-icon">
        <i class="fas fa-graduation-cap"></i>
      </div>
      <div class="loader-text">Loading Course Content...</div>
    </div>

    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- Music Player (fixed at top right) -->
    <div class="header-controls">
      <div class="music-dropdown" id="music-dropdown">
        <button class="btn btn-secondary">
          <span id="music-button-text">STUDY MUSIC</span>
          <i id="music-icon" class="fa-solid fa-music"></i>
        </button>
        <div class="music-dropdown-content" id="music-dropdown-content">
          <a
            href="#"
            data-src="https://www.learningcontainer.com/wp-content/uploads/2020/02/Kalimba.mp3"
            >1. Coffee Shop Vibes</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3"
            >2. City Lights Lofi</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-15.mp3"
            >3. Mellow Thoughts</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-13.mp3"
            >4. Rainy Mood</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3"
            >5. Time Alone</a
          >
          <a href="#" id="stop-music-link"
            ><i class="fa-solid fa-stop-circle"></i> Stop Music</a
          >
        </div>
      </div>

      <button class="btn btn-secondary" id="resetProgressBtn">
        <i class="fas fa-redo"></i>
        Reset Progress
      </button>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal" style="display: none">
      <div class="modal-overlay"></div>
      <div class="modal-content">
        <span class="close" id="closeAuthModal">&times;</span>
        <div class="auth-tabs">
          <button id="tabSignIn" class="auth-tab active">Sign In</button>
          <button id="tabSignUp" class="auth-tab">Sign Up</button>
        </div>
        <div
          id="authLoader"
          style="display: none; text-align: center; padding: 2rem"
        >
          <i
            class="fas fa-spinner fa-spin fa-2x"
            style="color: var(--color-green)"
          ></i>
          <p style="margin-top: 0.5rem">Authenticating...</p>
        </div>
        <div id="signInForm" class="auth-form">
          <h2>Sign In to CipherHall</h2>
          <button id="googleSignIn" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignInForm">
            <input
              type="email"
              id="signInEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signInPassword"
              placeholder="Password"
              required
            />
            <button type="submit" class="btn btn-primary">Sign In</button>
          </form>
        </div>
        <div id="signUpForm" class="auth-form" style="display: none">
          <h2>Join CipherHall</h2>
          <button id="googleSignUp" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignUpForm">
            <input
              type="text"
              id="signUpName"
              placeholder="Full Name"
              required
            />
            <input
              type="email"
              id="signUpEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signUpPassword"
              placeholder="Password (min. 8 characters)"
              required
            />
            <button type="submit" class="btn btn-secondary">
              Create Account
            </button>
          </form>
        </div>
        <div id="authMessage"></div>
      </div>
    </div>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="course-info">
          <h1 class="course-title" id="courseTitle">Loading...</h1>
          <div class="course-progress">
            <div class="progress-header">
              <span class="progress-label">Course Progress</span>
              <span class="progress-percentage" id="courseProgressPercent"
                >0%</span
              >
            </div>
            <div class="progress-bar">
              <div
                class="progress-fill"
                id="courseProgressFill"
                style="width: 0%"
              ></div>
            </div>
            <div class="progress-stats">
              <span id="completedLessons">0</span>
              <span id="totalLessons">0</span>
            </div>
          </div>
          <a href="/dashboard.html" class="back-to-dashboard">
            <i class="fas fa-arrow-left"></i>
            Back to Dashboard
          </a>
        </div>
      </div>

      <nav class="lesson-nav" id="lessonNav">
        <!-- Lessons will be loaded dynamically -->
      </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <header class="content-header">
        <div class="lesson-header">
          <div class="lesson-header-left">
            <span class="lesson-number" id="currentLessonNumber">1</span>
            <h1 class="lesson-header-title" id="currentLessonTitle">
              Loading...
            </h1>
          </div>
          <div class="lesson-actions">
            <button class="mbtn btn-primary" id="menuToggle">
              <i class="fas fa-bars"></i>
            </button>
          </div>
        </div>
      </header>

      <div class="content-body" id="contentBody">
        <div class="lesson-content" id="lessonContent">
          <!-- Lesson content will be loaded dynamically -->
        </div>
      </div>

      <footer class="lesson-navigation">
        <div class="nav-info" id="navInfo">Lesson 1 of 10</div>
        <div class="nav-controls">
          <button class="btn btn-secondary" id="prevLessonBtn" disabled>
            <i class="fas fa-chevron-left"></i>
            Previous
          </button>
          <button class="btn btn-primary" id="nextLessonBtn" disabled>
            Next
            <i class="fas fa-chevron-right"></i>
          </button>
        </div>
      </footer>
    </main>

    <!-- Achievement Notification -->
    <div id="achievementNotification" class="achievement-notification">
      <div class="notification-header">
        <div class="notification-icon" id="notificationIcon">
          <i class="fas fa-trophy"></i>
        </div>
        <div class="notification-content">
          <h3 id="notificationTitle">Achievement Unlocked!</h3>
          <p id="notificationDescription">Description here...</p>
        </div>
      </div>
      <div class="notification-reward" id="notificationReward">
        <i class="fas fa-coins"></i>
        <span id="notificationPoints">+100 Points</span>
      </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast">
      <span id="toastMessage"></span>
    </div>

    <script>
      // =====================================================
      // SYNCHRONIZED COURSE SYSTEM WITH DASHBOARD INTEGRATION
      // =====================================================

      // Supabase Configuration - Replace with your config
      const supabaseUrl = "https://lzcmzulemfubjaksoqor.supabase.co";
      const supabaseKey =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx6Y216dWxlbWZ1Ympha3NvcW9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzMzM5MDgsImV4cCI6MjA3MDkwOTkwOH0.crhPH4YWtRsr1BJTpAQcmPbWSpwIWRbzoI4sRb2_fPI";
      const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

      // =====================================================
      // COURSE DATA STRUCTURE - REPLACE WITH YOUR COURSE JSON
      // =====================================================
     
const COURSE_DATA = 

{
    "id": "blockchain-security",
    "title": "Blockchain Security - Complete Learning Roadmap",
    "description": "A comprehensive course covering the entire landscape of blockchain security, from cryptographic fundamentals to advanced threat analysis and mitigation.",
    "category": "blockchain-security",
    "difficulty": "Intermediate to Advanced",
    "duration": "150 hours",
    "instructor": "Dr. Evelyn Reed",
    "lessons": [
        {
            "id": "lesson-1",
            "title": "Blockchain Fundamentals and Architecture",
            "duration": "90 min",
            "objectives": [
                "Define what a blockchain is and explain its core concepts",
                "Understand the principles of distributed ledger technology (DLT)",
                "Analyze the structure of a block and how blocks are organized into a chain",
                "Explain the role of hash functions and Merkle trees in ensuring data integrity",
                "Grasp the concepts of immutability and tamper resistance"
            ],
            "content": {
                "overview": "This foundational lesson introduces the core principles of blockchain technology. We will deconstruct what a blockchain is, how it works, and why its architecture provides inherent security features like immutability and decentralization.",
                "sections": [
                    {
                        "title": "Blockchain Definition and Core Concepts",
                        "content": "<p>A blockchain is a decentralized, distributed, and often public, digital ledger consisting of records called blocks that are used to record transactions across many computers so that any involved block cannot be altered retroactively, without the alteration of all subsequent blocks.</p><h3>Core Concepts:</h3><ul><li><strong>Decentralization:</strong> Control is distributed among all network participants rather than a central authority.</li><li><strong>Transparency:</strong> All transactions are typically visible to all participants.</li><li><strong>Immutability:</strong> Once a transaction is recorded on the blockchain, it cannot be changed or deleted.</li></ul><div class='info-box tip'><div class='info-box-header'><i class='fas fa-lightbulb'></i><strong>Analogy</strong></div><p>Think of a blockchain as a shared digital notebook where each page (block) is linked to the previous one with a unique seal (hash). Once a page is written, it's sealed and added, and changing it would require unsealing all subsequent pages, which is immediately noticeable to everyone sharing the notebook.</p></div>",
                        "image": "https://images.unsplash.com/photo-1518546305927-5a555bb7020d?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Block Structure and Chain Organization",
                        "content": "<p>Each block in a blockchain contains a set of transactions, a timestamp, and a reference (or hash) to the previous block. This linking of blocks is what forms the 'chain'.</p><h3>A Typical Block Contains:</h3><ul><li><strong>Block Hash:</strong> A unique identifier for the block itself.</li><li><strong>Previous Block Hash:</strong> A link to the hash of the preceding block in the chain.</li><li><strong>Timestamp:</strong> The time the block was created.</li><li><strong>Nonce:</strong> A number used in Proof-of-Work systems to find a valid block hash.</li><li><strong>Merkle Root:</strong> A hash that summarizes all transactions within the block.</li><li><strong>Transaction Data:</strong> The list of transactions included in the block.</li></ul>",
                        
                    },
                    {
                        "title": "Hash Functions and Merkle Trees",
                        "content": "<p>Cryptographic hash functions are the backbone of blockchain security. They take an input of any size and produce a fixed-size string of characters, the hash. This process is one-way and deterministic.</p><p>A <strong>Merkle Tree</strong> is a data structure used to efficiently verify the integrity of a large set of data. In a blockchain, the transactions in a block are hashed, then paired and hashed again, continuing until a single hash, the Merkle Root, is left. This root is stored in the block header, efficiently summarizing all transactions.</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Efficiency</strong></div><p>With a Merkle Tree, you can verify if a specific transaction is included in a block by only needing the Merkle Root and a small number of hashes, rather than downloading and hashing all transactions in the block.</p></div>",
                       
                    },
                    {
                        "title": "Immutability and Tamper Resistance",
                        "content": "<p>Immutability is the property that ensures blockchain data remains unchanged over time. This is achieved through the combination of hashing and linking blocks.</p><p>If an attacker tries to alter a transaction in a past block, the hash of that block will change. Since each subsequent block's hash includes the hash of the one before it, the change would create a cascading effect, altering every following block's hash. This makes tampering immediately evident to the entire network, as the attacker's chain would not match the majority's chain.</p>",
                        "image": "https://images.unsplash.com/photo-1639322537228-f710d846310a?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Basic Block and Blockchain Implementation (Python)",
                        "language": "python",
                        "code": "import hashlib\nimport time\n\nclass Block:\n    def __init__(self, index, transactions, timestamp, previous_hash):\n        self.index = index\n        self.transactions = transactions\n        self.timestamp = timestamp\n        self.previous_hash = previous_hash\n        self.nonce = 0\n        self.hash = self.compute_hash()\n\n    def compute_hash(self):\n        block_string = str(self.index) + str(self.transactions) + str(self.timestamp) + str(self.previous_hash) + str(self.nonce)\n        return hashlib.sha256(block_string.encode()).hexdigest()\n\nclass Blockchain:\n    def __init__(self):\n        self.chain = [self.create_genesis_block()]\n\n    def create_genesis_block(self):\n        return Block(0, [], time.time(), '0')\n\n    def get_last_block(self):\n        return self.chain[-1]\n\n    def add_block(self, new_block):\n        new_block.previous_hash = self.get_last_block().hash\n        new_block.hash = new_block.compute_hash()\n        self.chain.append(new_block)"
                    },
                    {
                        "title": "Chain Integrity Verification",
                        "language": "python",
                        "code": "def is_chain_valid(chain):\n    for i in range(1, len(chain)):\n        current_block = chain[i]\n        previous_block = chain[i-1]\n\n        # Check if the hash of the block is correct\n        if current_block.hash != current_block.compute_hash():\n            return False\n\n        # Check if the previous_hash link is correct\n        if current_block.previous_hash != previous_block.hash:\n            return False\n\n    return True"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary mechanism that makes a blockchain immutable?",
                        "options": [
                            "Centralized servers",
                            "Cryptographic hashing and chaining of blocks",
                            "User permissions",
                            "Encryption of all data"
                        ],
                        "correct": 1,
                        "explanation": "The linking of each block to the previous one using cryptographic hashes creates a dependency that makes it computationally infeasible to alter past blocks without invalidating the entire chain."
                    },
                    {
                        "id": 2,
                        "question": "What is the purpose of a Merkle Root in a block header?",
                        "options": [
                            "To encrypt the transaction data",
                            "To identify the creator of the block",
                            "To provide a summary of all transactions in the block for efficient verification",
                            "To store the total value of all transactions"
                        ],
                        "correct": 2,
                        "explanation": "The Merkle Root is a single hash that represents all transactions in a block, allowing for efficient verification of transaction inclusion without processing the entire set of transactions."
                    },
                    {
                        "id": 3,
                        "question": "Which of these is a core concept of blockchain technology?",
                        "options": [
                            "Central authority",
                            "Mutability",
                            "Decentralization",
                            "Data privacy by default"
                        ],
                        "correct": 2,
                        "explanation": "Decentralization, the distribution of control across a network, is a fundamental principle of blockchain, distinguishing it from traditional centralized systems."
                    }
                ]
            }
        },
        {
            "id": "lesson-2",
            "title": "Cryptographic Foundations for Blockchain",
            "duration": "75 min",
            "objectives": [
                "Understand the properties of cryptographic hash functions like SHA-256",
                "Explain how digital signatures provide authenticity and non-repudiation",
                "Describe the role of public key cryptography in managing blockchain identities",
                "Learn about advanced concepts like cryptographic commitments and proofs",
                "Recognize the importance of secure random number generation"
            ],
            "content": {
                "overview": "Cryptography is the science of secure communication. This lesson delves into the critical cryptographic primitives that form the security bedrock of any blockchain system, including the hash functions, digital signatures, and key pairs that protect assets and validate transactions.",
                "sections": [
                    {
                        "title": "Cryptographic Hash Functions (SHA-256)",
                        "content": "<p>A cryptographic hash function is a mathematical algorithm that maps data of arbitrary size to a bit array of a fixed size. They are one-way functions, meaning they are infeasible to invert.</p><h3>Essential Properties:</h3><ul><li><strong>Deterministic:</strong> The same input will always produce the same output.</li><li><strong>Pre-image Resistance:</strong> It should be infeasible to find the input from a given hash output.</li><li><strong>Second Pre-image Resistance:</strong> Given an input, it should be infeasible to find another different input that produces the same hash.</li><li><strong>Collision Resistance:</strong> It should be infeasible to find two different inputs that hash to the same output.</li></ul><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>SHA-256</strong></div><p>SHA-256 (Secure Hash Algorithm 256-bit) is a widely used hash function in blockchain, notably by Bitcoin. It produces a 256-bit (32-byte) hash, providing a high level of security.</p></div>",
                        "image": "https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Digital Signatures (ECDSA)",
                        "content": "<p>Digital signatures are a mathematical scheme for verifying the authenticity of digital messages or documents. In blockchain, they are used to prove ownership of a private key without revealing the key itself.</p><p>The process involves a user signing a transaction with their <strong>private key</strong>. Others on the network can then use the user's <strong>public key</strong> to verify that the signature is authentic and the transaction has not been tampered with. This provides:</p><ul><li><strong>Authenticity:</strong> Verifies who created the transaction.</li><li><strong>Integrity:</strong> Ensures the message was not altered.</li><li><strong>Non-repudiation:</strong> The signer cannot deny having signed the message.</li></ul><div class='info-box tip'><div class='info-box-header'><i class='fas fa-lightbulb'></i><strong>ECDSA</strong></div><p>The Elliptic Curve Digital Signature Algorithm (ECDSA) is commonly used in cryptocurrencies like Bitcoin and Ethereum because it provides high security with smaller key sizes compared to other algorithms.</p></div>",
                        "image": "https://plus.unsplash.com/premium_photo-1661420386736-df3569904b5d?q=80&w=1389&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D"
                    },
                    {
                        "title": "Public Key Cryptography in Blockchain",
                        "content": "<p>Public Key Cryptography (PKC), or asymmetric cryptography, uses a pair of keys: a public key and a private key.</p><ul><li><strong>Private Key:</strong> Kept secret by the owner. Used to create digital signatures and spend funds. Compromise of this key means loss of assets.</li><li><strong>Public Key:</strong> Shared freely. Used to verify digital signatures. It is also used to generate a public address, which is like a bank account number for receiving funds.</li></ul><p>This system allows anyone to send assets to an address and verify transactions, but only the holder of the corresponding private key can access and spend those assets.</p>",
                        "image": "https://plus.unsplash.com/premium_photo-1752801716800-3d936e5e4a72?q=80&w=774&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "SHA-256 Hashing Example (Python)",
                        "language": "python",
                        "code": "import hashlib\n\ndef sha256_hash(data):\n    # Helper function to compute a SHA-256 hash\n    return hashlib.sha256(data.encode('utf-8')).hexdigest()\n\nmessage = \"Hello, Blockchain!\"\nhashed_message = sha256_hash(message)\n\nprint(f\"Original Message: {message}\")\nprint(f\"SHA-256 Hash: {hashed_message}\")\n\n# A small change in input creates a completely different hash\nmessage_2 = \"Hello, blockchain!\"\nhashed_message_2 = sha256_hash(message_2)\nprint(f\"Hash of slightly different message: {hashed_message_2}\")"
                    },
                    {
                        "title": "Digital Signature Generation and Verification (Python)",
                        "language": "python",
                        "code": "from ecdsa import SigningKey, VerifyingKey, NIST384p\n\n# Generate a private key\nprivate_key = SigningKey.generate(curve=NIST384p)\n\n# Generate the corresponding public key\npublic_key = private_key.verifying_key\n\nmessage = b\"This transaction is authentic\"\n\n# Sign the message with the private key\nsignature = private_key.sign(message)\n\nprint(f\"Signature (hex): {signature.hex()}\")\n\n# Verification\ntry:\n    # Use the public key to verify the signature against the original message\n    assert public_key.verify(signature, message)\n    print(\"Signature is valid.\")\nexcept:\n    print(\"Signature is invalid.\")"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "In public key cryptography, which key is used to create a digital signature?",
                        "options": [
                            "Public Key",
                            "Shared Key",
                            "Private Key",
                            "Session Key"
                        ],
                        "correct": 2,
                        "explanation": "The private key is kept secret by the owner and is used to sign transactions, proving ownership of the assets."
                    },
                    {
                        "id": 2,
                        "question": "Which property of a hash function ensures that a small change in the input results in a drastically different output?",
                        "options": [
                            "Pre-image resistance",
                            "The Avalanche Effect",
                            "Collision resistance",
                            "Deterministic nature"
                        ],
                        "correct": 1,
                        "explanation": "The Avalanche Effect is the desirable property where a small change in the input (like flipping a single bit) produces a significant change in the output hash."
                    },
                    {
                        "id": 3,
                        "question": "What is the primary purpose of a digital signature in a blockchain transaction?",
                        "options": [
                            "To encrypt the transaction details for privacy",
                            "To prove the sender's identity and consent without revealing their private key",
                            "To speed up transaction processing",
                            "To reduce the size of the transaction data"
                        ],
                        "correct": 1,
                        "explanation": "Digital signatures provide authenticity, integrity, and non-repudiation, allowing the network to verify that the owner of the account authorized the transaction."
                    }
                ]
            }
        },
        {
            "id": "lesson-3",
            "title": "Bitcoin Security Model",
            "duration": "90 min",
            "objectives": [
                "Understand the fundamentals of the Bitcoin protocol",
                "Explain the UTXO (Unspent Transaction Output) model and its security implications",
                "Analyze the structure and validation process of a Bitcoin transaction",
                "Learn about Bitcoin's Script language and its security limitations",
                "Describe the role of mining and Proof-of-Work in securing the network"
            ],
            "content": {
                "overview": "As the first and most well-known blockchain, Bitcoin's security model is a crucial case study. This lesson dissects the Bitcoin protocol, focusing on its unique UTXO accounting model, transaction lifecycle, and the Proof-of-Work consensus mechanism that has secured it for over a decade.",
                "sections": [
                    {
                        "title": "UTXO (Unspent Transaction Output) Model",
                        "content": "<p>Unlike traditional account-based models (like a bank account), Bitcoin uses the Unspent Transaction Output (UTXO) model. Think of your Bitcoin balance not as a single number, but as a collection of discrete pieces of bitcoin you've received but not yet spent.</p><h3>How it Works:</h3><ol><li>Each transaction consumes one or more UTXOs as inputs.</li><li>It then creates one or more new UTXOs as outputs.</li><li>An output, once created, is 'unspent' until it is used as an input in a future transaction.</li></ol><div class='info-box tip'><div class='info-box-header'><i class='fas fa-lightbulb'></i><strong>Security Benefit</strong></div><p>The UTXO model helps prevent double-spending. Since each UTXO can only be spent once, the entire network can easily verify that the inputs for a new transaction have not already been consumed. It also enhances privacy, as users can use different addresses for each transaction.</p></div>",
                        "image": "https://media.geeksforgeeks.org/wp-content/uploads/20220221173228/hashdrawio.png"
                    },
                    {
                        "title": "Transaction Structure and Validation",
                        "content": "<p>A Bitcoin transaction is a data structure that transfers value between participants. It's a collection of inputs and outputs.</p><h3>Key Components:</h3><ul><li><strong>Version:</strong> The transaction version number.</li><li><strong>Inputs:</strong> A list of UTXOs to be consumed. Each input references a previous transaction's output and includes a digital signature (via a script) to prove ownership.</li><li><strong>Outputs:</strong> A list of new UTXOs being created. Each output specifies a value and the conditions (a script) required to spend it.</li><li><strong>Locktime:</strong> A parameter that specifies the earliest time or block number the transaction can be added to the blockchain.</li></ul><p>Nodes validate transactions by checking the signatures, ensuring the inputs exist and are unspent, and verifying that the sum of inputs is greater than or equal to the sum of outputs.</p>",
                        "image": "https://ik.imagekit.io/upgrad1/abroad-images/imageCompo/images/QQ8NJ8LG.png?pr-true"
                    },
                    {
                        "title": "Mining and Proof-of-Work Security",
                        "content": "<p>Proof-of-Work (PoW) is the consensus mechanism that allows the decentralized Bitcoin network to agree on the state of the ledger. 'Miners' compete to solve a computationally difficult puzzle.</p><p>The process involves repeatedly hashing the block's header while incrementing a 'nonce' value until the resulting hash is below a certain target difficulty. The first miner to find a valid hash gets to add their block to the chain and is rewarded with newly created bitcoin and transaction fees.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>51% Attack</strong></div><p>This computational work makes the blockchain secure. To alter a past block, an attacker would need to re-mine that block and all subsequent blocks faster than the rest of the network combined. This would require controlling over 50% of the network's total computational power, known as a 51% attack, which is prohibitively expensive.</p></div>",
                        "image": "https://wallstreetmojo-files.s3.ap-south-1.amazonaws.com/2023/07/Proof-Of-Work.png"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Pseudocode for Transaction Validation",
                        "language": "python",
                        "code": "def validate_transaction(transaction, utxo_set):\n    # 1. Check transaction syntax\n    if not is_syntactically_valid(transaction):\n        return False\n\n    # 2. Ensure inputs are not already spent\n    for tx_input in transaction.inputs:\n        if tx_input.previous_tx_hash not in utxo_set:\n            return False # Input doesn't exist or is spent\n\n    # 3. Verify digital signatures for each input\n    for i, tx_input in enumerate(transaction.inputs):\n        utxo = utxo_set[tx_input.previous_tx_hash]\n        if not verify_signature(tx_input.signature, utxo.public_key, transaction_data_for_signing(i)):\n            return False\n\n    # 4. Check if sum of outputs is not greater than sum of inputs\n    input_sum = sum(utxo_set[tx_input.previous_tx_hash].value for tx_input in transaction.inputs)\n    output_sum = sum(tx_output.value for tx_output in transaction.outputs)\n    if output_sum > input_sum:\n        return False # Trying to create money out of thin air\n\n    return True"
                    },
                    {
                        "title": "Proof-of-Work Mining Algorithm",
                        "language": "python",
                        "code": "import hashlib\n\ndef proof_of_work(block_header, difficulty_target):\n    nonce = 0\n    while True:\n        # Concatenate header and nonce\n        data_to_hash = str(block_header) + str(nonce)\n        \n        # Hash the data\n        hash_result = hashlib.sha256(data_to_hash.encode()).hexdigest()\n        \n        # Check if the hash meets the difficulty target\n        if int(hash_result, 16) < difficulty_target:\n            print(f\"Found valid hash: {hash_result}\")\n            return nonce, hash_result\n        \n        # Increment nonce and try again\n        nonce += 1"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is a UTXO in the context of Bitcoin?",
                        "options": [
                            "A type of cryptocurrency wallet",
                            "A transaction that has been broadcast but not yet confirmed",
                            "An unspent transaction output that can be used as an input in a new transaction",
                            "A unique transaction identifier"
                        ],
                        "correct": 2,
                        "explanation": "UTXO stands for Unspent Transaction Output. It represents a piece of bitcoin that has been received by a user but has not yet been spent."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary purpose of Proof-of-Work in the Bitcoin network?",
                        "options": [
                            "To generate new bitcoin for miners",
                            "To make transaction processing computationally expensive, thus securing the network from tampering",
                            "To verify the identity of users",
                            "To encrypt transaction data"
                        ],
                        "correct": 1,
                        "explanation": "Proof-of-Work makes it extremely costly and time-consuming to alter the blockchain, as an attacker would need to redo the work for all subsequent blocks, thus securing the ledger."
                    },
                    {
                        "id": 3,
                        "question": "What prevents a user from spending the same UTXO twice in Bitcoin?",
                        "options": [
                            "The user's wallet software prevents it",
                            "The network nodes reject transactions that try to use an already-spent UTXO as an input",
                            "The transaction fees are too high for double-spending",
                            "The block size limit"
                        ],
                        "correct": 1,
                        "explanation": "Every full node in the Bitcoin network maintains a set of all available UTXOs. When a new transaction is broadcast, nodes check to ensure its inputs correspond to valid, unspent UTXOs. If not, the transaction is rejected."
                    }
                ]
            }
        },
        {
            "id": "lesson-4",
            "title": "Consensus Mechanisms Security",
            "duration": "90 min",
            "objectives": [
                "Perform a security analysis of Proof of Work (PoW)",
                "Identify common vulnerabilities in Proof of Stake (PoS)",
                "Understand attack vectors in Delegated Proof of Stake (DPoS)",
                "Learn about Byzantine Fault Tolerance (pBFT) and its limitations",
                "Recognize various consensus attack vectors and their mitigations"
            ],
            "content": {
                "overview": "Consensus mechanisms are the protocols that allow decentralized networks to agree on a single version of the truth. This lesson explores the security trade-offs of major consensus algorithms like PoW and PoS, and examines the attacks they are designed to prevent—and those to which they are vulnerable.",
                "sections": [
                    {
                        "title": "Proof of Work (PoW) Security Analysis",
                        "content": "<p>PoW's security relies on the principle that honest work is more profitable than dishonest work. The primary threat is the <strong>51% Attack</strong>, where a single entity or colluding group controls the majority of the network's mining power.</p><h3>With 51% Hashrate, an Attacker Can:</h3><ul><li>Prevent new transactions from gaining confirmations.</li><li>Reverse their own transactions to double-spend coins.</li><li>Prevent other miners from finding blocks.</li></ul><h3>What They Cannot Do:</h3><ul><li>Create coins out of thin air.</li><li>Steal coins from other users' addresses.</li><li>Change the fundamental rules of the protocol.</li></ul><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Selfish Mining</strong></div><p>A more subtle attack is Selfish Mining, where a miner finds a block but keeps it secret, mining on their private chain. If they find another block before the public chain finds one, they can release their longer chain, orphan the public block, and claim the rewards, gaining an unfair share of mining revenue.</p></div>",
                        "image": "https://figures.semanticscholar.org/8deac2e093882f344771cfc91a463287141d96aa/1-Figure1-1.png"
                    },
                    {
                        "title": "Proof of Stake (PoS) Vulnerabilities",
                        "content": "<p>In PoS, validators are chosen to create new blocks based on the amount of cryptocurrency they hold and are willing to 'stake' as collateral. This removes the need for energy-intensive mining.</p><h3>Key Vulnerabilities:</h3><ul><li><strong>Nothing at Stake:</strong> In the event of a fork, a validator has nothing to lose by validating on both chains, which can hinder consensus. Modern PoS systems solve this with 'slashing' penalties, where validators lose part of their stake for misbehavior.</li><li><strong>Long-Range Attacks:</strong> An attacker could acquire the private keys of early validators and use them to create a long alternative chain from a very early point in the blockchain's history, potentially overwriting the legitimate chain. Checkpoints and other mechanisms are used as mitigation.</li><li><strong>Centralization:</strong> Wealthy stakeholders can have a disproportionate influence on the network, potentially leading to centralization over time.</li></ul>",
                        "image": "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTj9oe_4qKzPzu2FB3jyYwh7DcK0szVHTWU-A&s"
                    },
                    {
                        "title": "Practical Byzantine Fault Tolerance (pBFT)",
                        "content": "<p>pBFT is a consensus algorithm designed for permissioned (private) blockchains. It provides high-performance, low-latency consensus by having a set of known validators communicate with each other to agree on the state of the system.</p><h3>How it Works:</h3><p>The process involves multiple rounds of voting (pre-prepare, prepare, commit). A block is considered final once it has been agreed upon by more than two-thirds of the validators. This allows the system to function even if up to one-third of the validators are malicious or offline.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Scalability Limitation</strong></div><p>The main drawback of pBFT is its communication overhead. The number of messages required grows quadratically with the number of validators, making it unsuitable for large, permissionless networks like Bitcoin or Ethereum.</p></div>",
                        "image": "https://www.researchgate.net/publication/339123819/figure/fig6/AS:858760599851011@1581755890984/The-consensus-process-based-on-the-practical-Byzantine-fault-tolerance-PBFT-algorithm.png"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Byzantine Fault Simulation (Conceptual)",
                        "language": "python",
                        "code": "# Conceptual simulation of a Byzantine fault\n\nnum_generals = 4\ngenerals = {f'General_{i+1}': 'attack' for i in range(num_generals)}\n\n# One general is a traitor (Byzantine)\ngenerals['General_3'] = 'retreat'\n\ndef broadcast(sender, message, generals):\n    received_messages = {name: '' for name in generals}\n    for name in generals:\n        if name != sender:\n            if sender == 'General_3': # The traitor sends conflicting messages\n                if name == 'General_1':\n                    received_messages[name] = 'retreat' \n                else:\n                    received_messages[name] = 'attack'\n            else:\n                received_messages[name] = message\n    return received_messages\n\n# General 1 broadcasts 'attack'\nmessages_from_1 = broadcast('General_1', 'attack', generals)\nprint(f\"Messages received after General 1 broadcasts: {messages_from_1}\")\n\n# Traitorous General 3 broadcasts\nmessages_from_3 = broadcast('General_3', 'retreat', generals)\nprint(f\"Messages received after General 3 broadcasts: {messages_from_3}\")\n# The network now has conflicting information."
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary security threat to a Proof-of-Work blockchain?",
                        "options": [
                            "The Nothing at Stake problem",
                            "A 51% Attack",
                            "A Long-Range Attack",
                            "Validator collusion"
                        ],
                        "correct": 1,
                        "explanation": "A 51% attack, where a single entity controls the majority of the network's hashrate, is the most significant threat to PoW systems, as it allows for transaction reversal and censorship."
                    },
                    {
                        "id": 2,
                        "question": "The 'Nothing at Stake' problem is a key challenge for which type of consensus mechanism?",
                        "options": [
                            "Proof of Work (PoW)",
                            "Practical Byzantine Fault Tolerance (pBFT)",
                            "Proof of Stake (PoS)",
                            "Proof of Authority (PoA)"
                        ],
                        "correct": 2,
                        "explanation": "In early PoS designs, validators had no economic disincentive for voting on multiple forks, creating the 'Nothing at Stake' problem. Modern PoS systems address this with slashing penalties."
                    },
                    {
                        "id": 3,
                        "question": "Why is pBFT typically used in permissioned blockchains rather than public ones?",
                        "options": [
                            "It is not secure enough for public networks.",
                            "It requires too much energy.",
                            "Its high communication overhead does not scale to a large number of validators.",
                            "It does not provide instant finality."
                        ],
                        "correct": 2,
                        "explanation": "pBFT's messaging complexity increases quadratically with the number of validators, making it inefficient for large, decentralized, permissionless networks but suitable for smaller, controlled, permissioned environments."
                    }
                ]
            }
        },
        {
            "id": "lesson-5",
            "title": "Network Security and P2P Protocols",
            "duration": "75 min",
            "objectives": [
                "Understand the security implications of P2P network topology",
                "Learn how nodes discover and connect to each other",
                "Identify and understand Eclipse and Sybil attacks",
                "Recognize the vulnerabilities of network partitioning",
                "Appreciate the need for peer authentication and encryption"
            ],
            "content": {
                "overview": "A blockchain is only as secure as the peer-to-peer (P2P) network that supports it. This lesson moves beyond the blockchain data structure to the communication layer, exploring how nodes interact and the various network-level attacks that can isolate nodes, censor information, and undermine consensus.",
                "sections": [
                    {
                        "title": "P2P Network Topology and Node Discovery",
                        "content": "<p>Blockchain networks are typically unstructured P2P networks, where nodes randomly connect to a set of peers. There is no central server; instead, each node maintains a list of known peers.</p><h3>Node Discovery Process:</h3><ol><li>A new node first connects to a few hardcoded 'seed nodes'.</li><li>It then sends a 'getaddr' message to these seeds to request a list of other known peers on the network.</li><li>The node establishes outgoing connections to a subset of these peers.</li><li>Over time, it builds its own list of reliable peers.</li></ol><p>This ad-hoc topology is robust but can be vulnerable to attacks that manipulate a node's view of the network.</p>",
                        "image": "https://media.geeksforgeeks.org/wp-content/uploads/20240515175702/Peer-to-Peer-(P2P)-Architecture.webp"
                    },
                    {
                        "title": "Eclipse Attacks and Sybil Attacks",
                        "content": "<h3>Sybil Attack</h3><p>In a Sybil attack, an adversary creates a large number of pseudonymous identities (nodes) to gain a disproportionately large influence on the network. In a P2P network, this could be used to refuse to relay blocks or transactions, or to help launch other attacks.</p><h3>Eclipse Attack</h3><p>An Eclipse attack is a more targeted attack where an adversary isolates a specific node or group of nodes from the rest of the honest network. The attacker ensures that all of the victim's incoming and outgoing connections are to attacker-controlled nodes. </p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Consequences of an Eclipse Attack</strong></div><p>Once eclipsed, the victim node can be fed false information. The attacker can trick the node into accepting a fake blockchain, leading to double-spends, or censor transactions from reaching the victim.</p></div>",
                        "image": "https://www.researchgate.net/publication/364065206/figure/fig2/AS:11431281087459217@1664631790692/Eclipse-attack-example-in-blockchain-network.png"
                    },
                    {
                        "title": "Network Partitioning Vulnerabilities",
                        "content": "<p>A network partition, or 'netsplit', occurs when the P2P network is split into two or more disconnected groups of nodes that cannot communicate with each other. This can happen due to technical failures or be induced maliciously.</p><h3>Security Risks:</h3><ul><li><strong>Diverging Chains:</strong> Each partition will continue to operate independently, mining blocks and creating its own version of the blockchain.</li><li><strong>Double-Spending:</strong> When the partition is resolved and the network merges, the shorter chain will be discarded (orphaned). An attacker could spend coins on the side of the partition that is likely to be discarded, then spend them again on the main chain.</li></ul><p>Mitigations include increasing the number of node connections and monitoring network topology for signs of partitioning.</p>",
                        "image": "https://ars.els-cdn.com/content/image/3-s2.0-B9780124201378000081-f08-01-9780124201378.jpg"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Conceptual Eclipse Attack Implementation",
                        "language": "python",
                        "code": "# This is conceptual pseudocode for an Eclipse attack\n\nVICTIM_NODE = '192.168.1.100'\nATTACKER_IP_RANGE = '10.0.0.0/8'\n\nclass PeerManager:\n    def __init__(self):\n        self.peers = set()\n    \n    def add_peer(self, ip_address):\n        # In a real client, there would be checks on peer table size,\n        # IP ranges, etc., to mitigate this.\n        self.peers.add(ip_address)\n\n# Simulating the attack\nvictim_peer_manager = PeerManager()\n\n# 1. Attacker floods the victim with connection requests from controlled IPs\nfor i in range(1, 1025):\n    attacker_ip = f\"10.0.{i // 256}.{i % 256}\"\n    victim_peer_manager.add_peer(attacker_ip)\n\n# 2. Victim's peer table is now full of attacker nodes.\n#    The victim reboots.\n\n# 3. Upon restart, the victim only has attacker IPs in its database\n#    and will only connect to them, becoming eclipsed.\nprint(f\"Victim's peer table size: {len(victim_peer_manager.peers)}\")\nprint(f\"All peers are controlled by the attacker.\")"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary goal of an Eclipse attack?",
                        "options": [
                            "To crash the entire network",
                            "To steal a node's private keys",
                            "To isolate a specific node from the rest of the network",
                            "To create a large number of fake identities"
                        ],
                        "correct": 2,
                        "explanation": "An Eclipse attack aims to monopolize all of a victim node's connections, isolating it from honest peers and allowing the attacker to control the information it sees."
                    },
                    {
                        "id": 2,
                        "question": "A Sybil attack involves which of the following?",
                        "options": [
                            "Splitting the network into two partitions",
                            "Targeting a single node with a denial-of-service attack",
                            "Creating a large number of fake nodes or identities",
                            "Intercepting and modifying peer-to-peer traffic"
                        ],
                        "correct": 2,
                        "explanation": "The defining characteristic of a Sybil attack is the creation of numerous fake identities to undermine a system that relies on a one-entity-one-vote principle."
                    },
                    {
                        "id": 3,
                        "question": "What is a major security risk of a network partition?",
                        "options": [
                            "It can cause nodes to run out of memory",
                            "It allows for double-spending attacks when the partition heals",
                            "It permanently deletes transaction history",
                            "It increases transaction fees"
                        ],
                        "correct": 1,
                        "explanation": "During a partition, chains can diverge. An attacker can spend coins on the chain that will eventually be discarded, making the transaction invalid after the network merges, and then spend the same coins again on the main chain."
                    }
                ]
            }
        },
        {
            "id": "lesson-6",
            "title": "Transaction Pool and Mempool Security",
            "duration": "60 min",
            "objectives": [
                "Understand how transactions propagate through the network",
                "Learn the role and function of the mempool",
                "Identify risks of transaction fee market manipulation",
                "Analyze various double-spending attack vectors at the mempool level",
                "Explain the purpose and vulnerabilities of Replace-by-Fee (RBF)"
            ],
            "content": {
                "overview": "Before a transaction is immortalized in a block, it lives in a waiting area known as the mempool. This lesson explores the dynamics of this transaction pool, from propagation and fee markets to the attacks that can occur in this volatile, pre-consensus state, such as double-spending and censorship.",
                "sections": [
                    {
                        "title": "Transaction Propagation and the Mempool",
                        "content": "<p>When a user broadcasts a transaction, it doesn't go directly to a miner. It is sent to a few nodes, which validate it and then relay it to their peers. This process continues until the transaction has propagated throughout the network.</p><p>The <strong>Mempool</strong> (Memory Pool) is a node's local cache of unconfirmed but valid transactions waiting to be included in a block. Each node has its own mempool with its own policies for acceptance and eviction.</p><h3>Mempool Policies:</h3><ul><li><strong>Size Limits:</strong> Mempools have a maximum size. When full, nodes may evict transactions with the lowest fees.</li><li><strong>Fee Rate Threshold:</strong> Nodes will reject transactions with fees lower than a certain minimum threshold.</li></ul>",
                        "image": "https://www.researchgate.net/publication/348656743/figure/fig2/AS:984793512701953@1611804478520/Transaction-propagation-flow-in-normal-blockchain-network.png"
                    },
                    {
                        "title": "Double-Spending Attack Vectors",
                        "content": "<p>A double-spend is an attack where the same funds are spent in more than one transaction. While difficult to achieve once a transaction is confirmed, it is possible in the mempool stage.</p><h3>Common Types:</h3><ul><li><strong>Race Attack:</strong> The attacker sends two conflicting transactions in quick succession, one to a merchant and one to themselves. They hope the transaction to themselves gets mined first, invalidating the payment to the merchant.</li><li><strong>Finney Attack:</strong> A more complex attack requiring miner collusion. The attacker mines a block including a transaction that sends coins back to themselves, but does not broadcast the block. They then make a payment to a merchant. Once the merchant accepts the payment, the attacker broadcasts their pre-mined block, invalidating the merchant transaction.</li></ul><div class='info-box tip'><div class='info-box-header'><i class='fas fa-lightbulb'></i><strong>Zero-Confirmation Transactions</strong></div><p>These attacks primarily target merchants who accept 'zero-confirmation' transactions (i.e., they accept payment as soon as the transaction appears in the mempool, without waiting for it to be included in a block). The best defense is to wait for one or more confirmations.</p></div>",
                        "image": "https://www.researchgate.net/publication/351136583/figure/fig1/AS:1022945451335687@1620900609322/llustration-of-a-double-spending-attack.png"
                    },
                    {
                        "title": "Replace-by-Fee (RBF)",
                        "content": "<p>Replace-by-Fee is a feature that allows a user to replace their own unconfirmed transaction with a new one that pays a higher fee. This is useful if a transaction is stuck in the mempool due to low fees.</p><h3>How it Works:</h3><p>The new transaction must spend at least one of the same inputs as the original transaction. Nodes with RBF enabled will drop the original, lower-fee transaction from their mempool and accept the new one.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>RBF and Double-Spending</strong></div><p>RBF can be seen as a formalized way of double-spending. A user can send a payment to a merchant and then use RBF to create a conflicting transaction (e.g., sending the funds back to themselves) with a higher fee. This makes accepting zero-confirmation transactions even riskier on networks that allow RBF.</p></div>",
                        "image": "https://coincodecap.com/wp-content/uploads/2020/03/bitcoin-replace-by-fee.png"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Conceptual Mempool Implementation",
                        "language": "python",
                        "code": "MEMPOOL_MAX_SIZE = 300  # in MB\nMIN_FEE_RATE = 5      # in satoshis/vbyte\n\nclass Mempool:\n    def __init__(self):\n        self.transactions = {}\n\n    def add_transaction(self, tx):\n        fee_rate = tx.get_fee() / tx.get_size()\n        if fee_rate < MIN_FEE_RATE:\n            return False, \"Fee rate too low\"\n        \n        # Check for conflicts, etc.\n        if tx.id in self.transactions:\n             return False, \"Transaction already in mempool\"\n\n        self.transactions[tx.id] = tx\n        self.enforce_size_limit()\n        return True, \"Transaction added\"\n\n    def enforce_size_limit(self):\n        while self.get_current_size_mb() > MEMPOOL_MAX_SIZE:\n            # Find transaction with the lowest fee rate and remove it\n            lowest_fee_tx = min(self.transactions.values(), key=lambda t: t.get_fee() / t.get_size())\n            del self.transactions[lowest_fee_tx.id]\n            print(f\"Evicted transaction {lowest_fee_tx.id} due to low fee.\")"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary function of a mempool?",
                        "options": [
                            "To store a permanent record of all transactions",
                            "To act as a waiting area for valid, unconfirmed transactions",
                            "To validate the identity of new nodes joining the network",
                            "To store miners' private keys securely"
                        ],
                        "correct": 1,
                        "explanation": "The mempool is a node's local cache of unconfirmed transactions that are waiting to be selected by miners and included in a block."
                    },
                    {
                        "id": 2,
                        "question": "What is the best defense against race attacks and other mempool-level double-spends?",
                        "options": [
                            "Using a secure wallet",
                            "Only accepting transactions with high fees",
                            "Waiting for one or more block confirmations before accepting a payment",
                            "Connecting to more peers in the network"
                        ],
                        "correct": 2,
                        "explanation": "Once a transaction is included in a block (confirmed), it becomes vastly more difficult to reverse. Waiting for confirmations is the standard and most effective defense against double-spending."
                    },
                    {
                        "id": 3,
                        "question": "What does Replace-by-Fee (RBF) allow a user to do?",
                        "options": [
                            "Cancel a confirmed transaction",
                            "Replace an unconfirmed transaction with a new one that pays a higher fee",
                            "Split one transaction into multiple smaller ones",
                            "Send a transaction with no fee"
                        ],
                        "correct": 1,
                        "explanation": "RBF is a protocol feature that lets users 'bump' the fee on an unconfirmed transaction to increase its chances of being mined, but it can also be used to create a conflicting transaction."
                    }
                ]
            }
        },
        {
            "id": "lesson-7",
            "title": "Smart Contract Security Fundamentals",
            "duration": "90 min",
            "objectives": [
                "Understand smart contract execution models like the EVM",
                "Explain the purpose of gas mechanisms in preventing DoS attacks",
                "Describe how state is managed and stored in smart contracts",
                "Learn about common contract upgrade patterns and their inherent risks",
                "Grasp the concept of immutability in the context of contract code"
            ],
            "content": {
                "overview": "Smart contracts are programs that run on the blockchain, executing automatically when certain conditions are met. This lesson introduces the foundational concepts of smart contract platforms like Ethereum, including the execution environment, gas mechanics, and the critical security implications of their immutable nature.",
                "sections": [
                    {
                        "title": "Virtual Machine Security (EVM)",
                        "content": "<p>Smart contracts do not run directly on network nodes. They execute in a sandboxed virtual environment to prevent them from affecting the node's operating system. The most well-known is the <strong>Ethereum Virtual Machine (EVM)</strong>.</p><h3>Key Features of the EVM:</h3><ul><li><strong>Turing Complete (quasi):</strong> It can compute anything, given enough resources.</li><li><strong>Deterministic:</strong> The same transaction with the same state will always produce the same result on all nodes.</li><li><strong>Isolated:</strong> Code running inside the EVM has no access to the node's file system, network, or other processes.</li></ul><p>This isolated and deterministic environment is crucial for achieving network consensus on the outcome of smart contract execution.</p>",
                        "image": "https://www.researchgate.net/publication/341479753/figure/fig2/AS:892772580065280@1589864978550/rtual-Machine-Security.jpg"
                    },
                    {
                        "title": "Gas Mechanisms and DoS Prevention",
                        "content": "<p>Every operation in a smart contract, from a simple addition to storing data, has a cost associated with it, measured in units of 'gas'. To execute a transaction, a user must specify a gas limit and pay a fee (gas price * gas used).</p><h3>Security Purpose of Gas:</h3><p>Gas is a fundamental Denial-of-Service (DoS) prevention mechanism. Without it, an attacker could deploy a smart contract with an infinite loop, forcing all nodes in the network to execute it forever and grinding the network to a halt. With gas, the transaction would simply run out of its gas limit and fail, consuming the attacker's fee but not harming the network.</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Gas Limit vs. Gas Price</strong></div><p><strong>Gas Limit:</strong> The maximum amount of gas the user is willing to spend on a transaction. <strong>Gas Price:</strong> The price per unit of gas the user is willing to pay, typically denominated in Gwei (a fraction of an Ether).</p></div>",
                        "image": "https://www.researchgate.net/publication/333562044/figure/fig2/AS:765461474062337@1559511645894/Defense-mechanism-against-the-DDoS-attack.png"
                    },
                    {
                        "title": "Contract Upgrade Patterns and Risks",
                        "content": "<p>By default, smart contract code deployed on a blockchain is immutable and cannot be changed. This is a powerful security feature, but it also means bugs cannot be fixed. To address this, developers use 'upgrade patterns'.</p><h3>Proxy Patterns:</h3><p>The most common method is the proxy pattern. It splits a contract into two parts:</p><ol><li>A <strong>Proxy Contract</strong> that users interact with. This contract holds the state (data).</li><li>A <strong>Logic Contract</strong> that contains the actual code.</li></ol><p>The Proxy contract forwards all calls to the Logic contract. To 'upgrade', the administrator of the Proxy can simply point it to a new Logic contract address. </p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Centralization Risk</strong></div><p>While useful, upgradeability introduces a new trust assumption. Users must trust the administrator of the proxy not to maliciously change the logic. This can be mitigated by using a DAO or a multi-signature wallet to govern the upgrade process.</p></div>",
                        "image": "https://www.coinspect.com/_astro/upgradeable-smart-contract-diagram-transparent.BzZEiXa8_1cJRCe.webp"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Basic Smart Contract (Solidity)",
                        "language": "solidity",
                        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ncontract SimpleStorage {\n    uint256 private favoriteNumber;\n\n    // Storing a number costs gas\n    function store(uint256 _favoriteNumber) public {\n        favoriteNumber = _favoriteNumber;\n    }\n\n    // Reading data is free if it's a 'view' function called externally\n    function retrieve() public view returns (uint256) {\n        return favoriteNumber;\n    }\n}"
                    },
                    {
                        "title": "Upgradeable Contract (Proxy Pattern - Conceptual)",
                        "language": "solidity",
                        "code": "// This is a simplified conceptual example\n\ncontract MyLogicV1 {\n    function version() public pure returns (string memory) {\n        return \"Version 1\";\n    }\n}\n\ncontract MyLogicV2 {\n    function version() public pure returns (string memory) {\n        return \"Version 2 - Now with more features!\";\n    }\n}\n\ncontract MyProxy {\n    address public implementation;\n    address public admin;\n\n    constructor() {\n        admin = msg.sender;\n        implementation = address(new MyLogicV1());\n    }\n\n    function upgrade(address newImplementation) public {\n        require(msg.sender == admin, \"Not admin\");\n        implementation = newImplementation;\n    }\n\n    fallback() external payable {\n        (bool success, ) = implementation.delegatecall(msg.data);\n        require(success, \"Delegatecall failed\");\n    }\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary security purpose of the 'gas' mechanism in Ethereum?",
                        "options": [
                            "To pay miners for their work",
                            "To prevent infinite loops and Denial-of-Service (DoS) attacks",
                            "To encrypt smart contract data",
                            "To limit the number of smart contracts on the network"
                        ],
                        "correct": 1,
                        "explanation": "Gas attaches a cost to every computational step, making it economically infeasible for an attacker to run a contract in an infinite loop and bog down the network."
                    },
                    {
                        "id": 2,
                        "question": "Why are smart contracts executed inside a Virtual Machine like the EVM?",
                        "options": [
                            "To make them run faster",
                            "To allow them to be written in any programming language",
                            "To isolate their execution and prevent them from accessing the host node's system",
                            "To hide the source code of the contract"
                        ],
                        "correct": 2,
                        "explanation": "The VM acts as a sandbox, providing a deterministic and isolated environment that ensures contract execution is safe and uniform across all nodes in the network."
                    },
                    {
                        "id": 3,
                        "question": "What is the main security risk introduced by using upgradeable proxy patterns for smart contracts?",
                        "options": [
                            "They use significantly more gas than non-upgradeable contracts.",
                            "They can be easily hacked by anyone.",
                            "They introduce a point of centralization and trust in the administrator who can change the logic.",
                            "They are not compatible with most wallets."
                        ],
                        "correct": 2,
                        "explanation": "Proxy patterns require an owner or administrator who has the power to change the underlying logic contract. This reintroduces a level of trust that decentralized applications aim to minimize."
                    }
                ]
            }
        },
        {
            "id": "lesson-8",
            "title": "Solidity Security Vulnerabilities",
            "duration": "100 min",
            "objectives": [
                "Understand and identify reentrancy attacks",
                "Recognize and prevent integer overflow/underflow vulnerabilities",
                "Analyze access control and authorization flaws",
                "Explain the concepts of front-running and MEV",
                "Learn about the dangers of insecure randomness"
            ],
            "content": {
                "overview": "While smart contract platforms provide a secure foundation, the code written by developers is a major source of vulnerabilities. This lesson dives into specific, high-profile bugs commonly found in Solidity code, such as reentrancy and integer overflows, and explores the best practices to prevent them.",
                "sections": [
                    {
                        "title": "Reentrancy Attacks",
                        "content": "<p>A reentrancy attack occurs when an external contract call is allowed to make a recursive call back to the original function before the first invocation has finished updating its state. This can be used to drain funds from a contract.</p><h3>The DAO Hack:</h3><p>The infamous 2016 DAO hack was a reentrancy attack. The attacker's contract called the DAO's <code>withdraw</code> function. Before the DAO contract could update the attacker's balance, the attacker's contract's fallback function was triggered, which called the <code>withdraw</code> function again, and again, draining the contract.</p><div class='info-box tip'><div class='info-box-header'><i class='fas fa-lightbulb'></i><strong>Prevention: Checks-Effects-Interactions Pattern</strong></div><p>The best practice to prevent reentrancy is to follow the Checks-Effects-Interactions pattern: <ol><li><strong>Checks:</strong> Perform all validation (e.g., <code>require(msg.sender == owner)</code>).</li><li><strong>Effects:</strong> Write to storage / update the contract's state (e.g., <code>balances[msg.sender] = 0</code>).</li><li><strong>Interactions:</strong> Make calls to external contracts.</li></ol>By updating the state *before* the external call, the recursive call will fail the checks.</p></div>",
                        "image": "https://cdn.prod.website-files.com/5bf4437b68f8b29e67b7ebdc/5d5f772c0778364909b9ff8b_re%20entrant.png"
                    },
                    {
                        "title": "Integer Overflow/Underflow",
                        "content": "<p>An integer overflow occurs when an arithmetic operation results in a number that is larger than the maximum value the data type can store. An underflow is the opposite, trying to store a value smaller than the minimum. In early versions of Solidity, this would cause the number to 'wrap around'.</p><h3>Example Vulnerability:</h3><p>Imagine a token balance is stored as a <code>uint8</code> (max value 255). If a user with 200 tokens receives another 100, the result (300) overflows, wrapping around to <code>(300 - 256) = 44</code>, effectively stealing tokens.</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Modern Solidity & SafeMath</strong></div><p>Since Solidity version 0.8.0, integer arithmetic operations automatically revert on overflow or underflow, making this vulnerability much rarer in modern contracts. For older versions, libraries like OpenZeppelin's `SafeMath` were used to provide safe arithmetic functions.</p></div>",
                        "image": "https://miro.medium.com/v2/resize:fit:1400/1*HdHG8G58QqOa-yne6elrGw.png"
                    },
                    {
                        "title": "Front-running and MEV",
                        "content": "<p>Since all transactions are broadcast to the public mempool before they are mined, anyone can see them. This creates an opportunity for <strong>front-running</strong>.</p><p>An attacker can monitor the mempool for profitable transactions (e.g., a large purchase on a decentralized exchange). They can then copy that transaction and submit their own with a higher gas fee to get it mined first, profiting from the price change they know is coming.</p><p><strong>Maximal Extractable Value (MEV)</strong> is a broader term for the total value that can be extracted from block production by reordering, inserting, or censoring transactions. This includes front-running, sandwich attacks, and liquidations.</p>",
                        "image": "https://lh5.googleusercontent.com/af94AbGIB0woLmr5QoWHnbzKt0orbfy5bG5N9-9cXLox07r-czCHcan5z0VTEcEXXOLVbd-_B3b_qsUu-fzVfWlySiabllGp9Np8qJGCTehqgXPeMAkBQqlrdMdIyIi8PpOzXDnvlBupFMoJSuITriM"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Vulnerable Reentrancy Example (Solidity)",
                        "language": "solidity",
                        "code": "// VULNERABLE CODE - DO NOT USE\ncontract VulnerableEtherStore {\n    mapping(address => uint) public balances;\n\n    function withdraw() public {\n        uint bal = balances[msg.sender];\n        require(bal > 0);\n\n        // (bool sent, ) = msg.sender.call{value: bal}(\"\"); // Interaction\n        // require(sent, \"Failed to send Ether\");\n\n        balances[msg.sender] = 0; // Effect\n        // The state is updated AFTER the external call, which is bad.\n    }\n}"
                    },
                    {
                        "title": "Secure Reentrancy Example with CEI Pattern",
                        "language": "solidity",
                        "code": "// SECURE CODE\ncontract SecureEtherStore {\n    mapping(address => uint) public balances;\n\n    function withdraw() public {\n        uint bal = balances[msg.sender];\n        require(bal > 0); // Check\n\n        balances[msg.sender] = 0; // Effect\n\n        // (bool sent, ) = msg.sender.call{value: bal}(\"\"); // Interaction\n        // require(sent, \"Failed to send Ether\");\n        // State was updated before the call, so a re-entrant call would see a balance of 0.\n    }\n}"
                    },
                    {
                        "title": "Integer Underflow Example (Solidity <0.8.0)",
                        "language": "solidity",
                        "code": "// VULNERABLE CODE on Solidity <0.8.0\npragma solidity ^0.7.0;\n\ncontract TimeLock {\n    mapping(address => uint) public balances;\n    mapping(address => uint) public lockTime;\n\n    function withdraw(uint _amount) public {\n        require(balances[msg.sender] >= _amount);\n        require(block.timestamp > lockTime[msg.sender]);\n\n        balances[msg.sender] -= _amount; // This can underflow if balance is 0 and user withdraws 1\n        // On older versions, the balance would wrap around to a very large number.\n    }\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the core issue in a reentrancy vulnerability?",
                        "options": [
                            "The contract runs out of gas.",
                            "An external call allows a function to be recursively entered before the state has been updated.",
                            "A number becomes too large for its data type.",
                            "The contract's owner has too much power."
                        ],
                        "correct": 1,
                        "explanation": "Reentrancy happens when a contract's state is not updated before it interacts with another contract, allowing the second contract to call back and exploit the inconsistent state."
                    },
                    {
                        "id": 2,
                        "question": "How do Solidity versions 0.8.0 and newer help prevent integer overflows/underflows?",
                        "options": [
                            "They automatically use a larger data type.",
                            "They remove unsigned integers.",
                            "They automatically check for overflows/underflows and cause the transaction to revert.",
                            "They require the use of a SafeMath library."
                        ],
                        "correct": 2,
                        "explanation": "Starting with version 0.8.0, the Solidity compiler includes built-in checks for integer arithmetic, which makes contracts much safer by default."
                    },
                    {
                        "id": 3,
                        "question": "The Checks-Effects-Interactions pattern is a best practice for preventing which vulnerability?",
                        "options": [
                            "Front-running",
                            "Poor access control",
                            "Reentrancy",
                            "Insecure randomness"
                        ],
                        "correct": 2,
                        "explanation": "By ensuring that all state changes (Effects) are made before calling external contracts (Interactions), the Checks-Effects-Interactions pattern effectively mitigates reentrancy attacks."
                    }
                ]
            }
        },
        {
            "id": "lesson-9",
            "title": "Smart Contract Auditing Techniques",
            "duration": "75 min",
            "objectives": [
                "Understand the role and importance of a smart contract audit",
                "Learn about static analysis tools and techniques",
                "Explore dynamic analysis and fuzzing for finding bugs",
                "Grasp the concepts behind formal verification methods",
                "Recognize code review best practices for security"
            ],
            "content": {
                "overview": "Given the high stakes and immutable nature of smart contracts, security auditing is not a luxury—it's a necessity. This lesson covers the essential techniques used by security professionals to analyze smart contracts for vulnerabilities, from automated tools to manual code review and formal verification.",
                "sections": [
                    {
                        "title": "Static Analysis Tools",
                        "content": "<p>Static analysis involves examining the smart contract's code without actually executing it. Automated tools can scan the source code or bytecode for patterns that match known vulnerabilities.</p><h3>Common Tools:</h3><ul><li><strong>Slither:</strong> A popular static analysis framework that detects a wide range of vulnerabilities, such as reentrancy, unprotected functions, and incorrect logic.</li><li><strong>MythX:</strong> A powerful security analysis platform that uses static analysis, symbolic execution, and input fuzzing to detect vulnerabilities.</li><li><strong>Securify:</strong> A security scanner that provides formal guarantees about the absence of certain vulnerabilities.</li></ul><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Limitations</strong></div><p>Static analysis tools are excellent for catching common, low-hanging fruit, but they can produce false positives and cannot understand the business logic or intent of the contract, which may be flawed.</p></div>",
                        "image": "https://www.imperfectdev.com/wp-content/uploads/2023/03/who_uses_static_analysis.jpg"
                    },
                    {
                        "title": "Dynamic Analysis and Fuzzing",
                        "content": "<p>Dynamic analysis involves executing the smart contract with a wide range of inputs to see how it behaves and try to trigger unexpected states or errors.</p><p><strong>Fuzzing</strong> is a popular dynamic analysis technique where a 'fuzzer' tool automatically generates and feeds a massive number of random or semi-random inputs into the contract's functions. The goal is to find edge cases that cause the contract to behave incorrectly or crash.</p><h3>Common Fuzzing Tools:</h3><ul><li><strong>Echidna:</strong> A powerful property-based fuzzer that allows you to write security properties (invariants) and then tries to find inputs that would violate them.</li><li><strong>Foundry Fuzz:</strong> Integrated into the Foundry development toolkit, this fuzzer allows for easy setup of tests on contract functions.</li></ul>",
                        "image": "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQ4zmtlEjovXVmFJLDnstKtfKwQr5ska23_pQ&s"
                    },
                    {
                        "title": "Formal Verification",
                        "content": "<p>Formal verification is the most rigorous method of smart contract auditing. It involves using mathematical methods to prove or disprove the correctness of a contract's logic with respect to a formal specification.</p><p>Instead of just testing for bugs, formal verification can prove their absence. For example, you could mathematically prove that a token contract's total supply can never change, or that a particular function can never be called by an unauthorized user.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>High Effort, High Assurance</strong></div><p>Formal verification is highly complex, time-consuming, and requires specialized expertise. It is typically reserved for mission-critical contracts where the cost of failure is extremely high.</p></div>",
                        "image": "https://truscova.com/images/blog/21_Figure1.png"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Using Slither (Command Line)",
                        "language": "bash",
                        "code": "# Slither is a command-line tool. You run it against your project directory.\n\n# Navigate to your project folder\ncd /path/to/my/project\n\n# Run Slither on the project\nslither .\n\n# Example Output:\n# MyContract.sol:10:1: UnprotectedSelfdestruct: MyContract.kill() is not protected\n#   Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#unprotected-selfdestruct\n# MyContract.sol:15:5: Reentrancy: Reentrancy in MyContract.withdraw()\n#   Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities\n"
                    },
                    {
                        "title": "Echidna Property-Based Fuzzing Test (Solidity)",
                        "language": "solidity",
                        "code": "// This is a test contract for Echidna\n// It defines properties that should always be true for a simple counter contract.\n\ncontract CounterTest is Test {\n    Counter public counter;\n\n    function setUp() public {\n        counter = new Counter();\n    }\n\n    // Echidna will try to call increment() and decrement() with random inputs\n    // to see if it can ever make this property false.\n    function echidna_never_goes_below_zero() public returns (bool) {\n        return counter.count() >= 0;\n    }\n\n    function echidna_increment_increases_count() public returns (bool) {\n        uint256 initialCount = counter.count();\n        counter.increment();\n        return counter.count() > initialCount;\n    }\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "Which auditing technique involves analyzing source code for known vulnerability patterns without executing it?",
                        "options": [
                            "Dynamic Analysis",
                            "Formal Verification",
                            "Static Analysis",
                            "Fuzzing"
                        ],
                        "correct": 2,
                        "explanation": "Static analysis tools like Slither scan the contract's code for potential issues based on a set of predefined rules and known anti-patterns."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary goal of fuzzing?",
                        "options": [
                            "To prove a contract is 100% secure",
                            "To automatically generate a large number of inputs to try and find edge cases that cause failures",
                            "To check for correct syntax and style",
                            "To manually review the business logic of a contract"
                        ],
                        "correct": 1,
                        "explanation": "Fuzzing is a dynamic analysis technique that bombards a contract's functions with random or semi-random data to uncover unexpected behavior, crashes, or property violations."
                    },
                    {
                        "id": 3,
                        "question": "Which auditing method provides the highest level of security assurance by using mathematical proofs?",
                        "options": [
                            "Manual Code Review",
                            "Static Analysis",
                            "Fuzzing",
                            "Formal Verification"
                        ],
                        "correct": 3,
                        "explanation": "Formal verification uses mathematical models to prove that a system adheres to a specific set of properties, offering a level of assurance that testing alone cannot provide. However, it is very resource-intensive."
                    }
                ]
            }
        },
        {
            "id": "lesson-10",
            "title": "DeFi (Decentralized Finance) Security",
            "duration": "90 min",
            "objectives": [
                "Understand the architecture of common DeFi protocols",
                "Analyze the vulnerabilities of Automated Market Makers (AMMs)",
                "Explain how flash loan attacks work and how to prevent them",
                "Identify risks related to liquidity pool manipulation",
                "Recognize the security challenges in yield farming"
            ],
            "content": {
                "overview": "Decentralized Finance (DeFi) aims to rebuild traditional financial systems on the blockchain. While innovative, the complexity and composability of DeFi protocols create new and challenging attack surfaces. This lesson explores the security risks unique to DeFi, including flash loan exploits and economic manipulations.",
                "sections": [
                    {
                        "title": "Automated Market Maker (AMM) Vulnerabilities",
                        "content": "<p>AMMs, like Uniswap, are decentralized exchanges that allow users to trade assets using liquidity pools instead of traditional order books. Prices are determined by a mathematical formula based on the ratio of assets in the pool.</p><h3>Key Vulnerabilities:</h3><ul><li><strong>Impermanent Loss:</strong> This is a risk for liquidity providers (LPs). If the price of one asset in the pool changes significantly, the value of the LP's stake in the pool can be less than if they had simply held the assets in their wallet.</li><li><strong>Price Slippage:</strong> Large trades can significantly move the price in an AMM pool, which can be exploited by front-runners.</li><li><strong>Arbitrage:</strong> While a necessary function to keep prices in line with external markets, it can be exploited in combination with other attacks.</li></ul>",
                        "image": "https://shardeum.nyc3.cdn.digitaloceanspaces.com/shardeum/2022/08/how-does-AMMs-work.png"
                    },
                    {
                        "title": "Flash Loan Attacks",
                        "content": "<p>A <strong>flash loan</strong> is a type of uncollateralized loan that must be borrowed and repaid within the same blockchain transaction. If the loan is not repaid by the end of the transaction, the entire transaction (including the loan) is reverted.</p><p>While they have legitimate uses (e.g., arbitrage, collateral swaps), they are a powerful tool for attackers. An attacker can borrow a massive amount of capital for a single transaction, use it to manipulate the price of an asset on a vulnerable DeFi protocol, and then repay the loan, walking away with the profit.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Anatomy of an Attack</strong></div><p>A typical flash loan attack involves: <ol><li>Take out a huge flash loan (e.g., $50M of ETH).</li><li>Use the funds to manipulate an oracle or a liquidity pool (e.g., dump the ETH on an AMM to crash the price of ETH relative to another asset).</li><li>Exploit the manipulated price on a different, vulnerable protocol (e.g., borrow an excessive amount of the other asset).</li><li>Repay the flash loan. All within one atomic transaction.</p></div>",
                        "image": "https://thresh0ld.com/wp-content/uploads/2022/10/Flash-Loan-Attack2.png"
                    },
                    {
                        "title": "Oracle Manipulation",
                        "content": "<p>Many DeFi protocols rely on 'oracles' to bring real-world data, like asset prices, onto the blockchain. If a protocol uses an insecure oracle, it can be the weak link.</p><p>For example, if a lending protocol uses the price from a single, low-liquidity AMM as its price oracle, an attacker can use a flash loan to manipulate the price in that one AMM. This could trick the lending protocol into thinking an asset is much more valuable than it is, allowing the attacker to borrow far more than their collateral is actually worth.</p><div class='info-box tip'><div class='info-box-header'><i class='fas fa-lightbulb'></i><strong>Prevention</strong></div><p>Secure DeFi protocols use decentralized oracle networks (like Chainlink) or Time-Weighted Average Prices (TWAPs) from high-liquidity AMMs. A TWAP calculates the average price over a period of time, making it much more resilient to flash loan manipulation within a single block.</p></div>",
                        "image": "https://www.chainalysis.com/wp-content/uploads/2023/03/oracle-attacks-v2-1024x558.png"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Flash Loan Attack (Conceptual Pseudocode)",
                        "language": "solidity",
                        "code": "contract FlashLoanAttacker {\n    function attack(address lendingPool, address vulnerableProtocol) public {\n        // 1. Request a massive flash loan of Asset A from the lending pool\n        // The lending pool will call our `executeOperation` function\n        lendingPool.flashLoan(address(this), address(assetA), 1000000e18, \"0x\");\n    }\n\n    // This function is called by the lending pool after we receive the funds\n    function executeOperation(\n        address asset, \n        uint256 amount, \n        uint256 fee, \n        bytes calldata params\n    ) external {\n        // 2. We now have 1,000,000 of Asset A\n        // Use it to manipulate an oracle or liquidity pool in the vulnerable protocol\n        vulnerableProtocol.swap(assetA, assetB, amount);\n\n        // 3. The price of Asset A is now artificially low in the vulnerable protocol\n        // Exploit this by, for example, borrowing an unfair amount of assets\n        vulnerableProtocol.borrow(assetC);\n\n        // 4. Repay the flash loan + fee\n        IERC20(asset).approve(lendingPool, amount + fee);\n        \n        // The transaction completes, and we keep the profit.\n    }\n}"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is a flash loan?",
                        "options": [
                            "A loan that is processed very quickly",
                            "A loan that must be borrowed and repaid within the same transaction",
                            "A loan that is fully collateralized by another asset",
                            "A loan provided by a centralized exchange"
                        ],
                        "correct": 1,
                        "explanation": "Flash loans are a DeFi primitive that allows for uncollateralized borrowing, on the condition that the loan is repaid by the end of the same atomic transaction."
                    },
                    {
                        "id": 2,
                        "question": "How can price oracles be a major security vulnerability in DeFi?",
                        "options": [
                            "They are too slow to update prices.",
                            "They charge very high fees.",
                            "If they rely on a single, manipulable source, they can be exploited to trick a protocol.",
                            "They are not transparent."
                        ],
                        "correct": 2,
                        "explanation": "Protocols that rely on oracles with a single point of failure (like a low-liquidity DEX) are vulnerable to price manipulation, often facilitated by flash loans."
                    },
                    {
                        "id": 3,
                        "question": "What is 'impermanent loss' in the context of providing liquidity to an AMM?",
                        "options": [
                            "A permanent loss of funds due to a hack.",
                            "A temporary bug in the AMM's user interface.",
                            "The opportunity cost experienced by LPs when the price of the tokens in the pool diverges.",
                            "The fees paid by traders to the liquidity providers."
                        ],
                        "correct": 2,
                        "explanation": "Impermanent loss is the difference in value between holding tokens in an AMM pool versus simply holding them in a wallet. It's 'impermanent' because if the prices return to their original state, the loss disappears."
                    }
                ]
            }
        },
        {
            "id": "lesson-11",
            "title": "NFT and Token Security",
            "duration": "75 min",
            "objectives": [
                "Understand the security considerations of ERC token standards (ERC-20, ERC-721, ERC-1155)",
                "Analyze risks related to token economics and security models",
                "Identify metadata manipulation attacks on NFTs",
                "Recognize the vulnerabilities of cross-chain token bridges",
                "Learn about token standard compliance verification"
            ],
            "content": {
                "overview": "Tokens and NFTs (Non-Fungible Tokens) are more than just digital assets; they are smart contracts that must be securely implemented. This lesson covers the security specifics of common token standards like ERC-20 and ERC-721, and explores vulnerabilities from flawed tokenomics to the significant risks posed by cross-chain bridges.",
                "sections": [
                    {
                        "title": "ERC Token Standard Security",
                        "content": "<p>Token standards like ERC-20 (for fungible tokens) and ERC-721 (for NFTs) provide a common interface for applications to interact with tokens. However, implementing them correctly is crucial.</p><h3>Common Pitfalls:</h3><ul><li><strong>ERC-20 <code>approve</code> Front-Running:</strong> A classic issue where a user approves a spender for amount X, then decides to change it to Y. A front-runner could see the second transaction and spend the original X amount before the approval is updated. The modern solution is to use <code>increaseAllowance</code> and <code>decreaseAllowance</code>.</li><li><strong>Fake Tokens:</strong> Scammers can create tokens with the same name and symbol as legitimate ones to trick users into buying them or interacting with malicious dApps.</li><li><strong>Reentrancy in <code>onERC721Received</code>:</strong> When transferring an NFT to a contract, the ERC-721 standard requires calling an <code>onERC721Received</code> hook on the receiving contract. If not handled carefully, this can open a reentrancy vector similar to raw Ether transfers.</li></ul>",
                        "image": "https://miro.medium.com/v2/resize:fit:1200/1*xvkJGTFJ6-rk2SUjS7bHkQ.jpeg"
                    },
                    {
                        "title": "Metadata Manipulation Attacks",
                        "content": "<p>The 'value' of an NFT is often tied to its metadata—the name, description, and image associated with the token ID. This metadata is typically not stored on-chain due to cost.</p><p>Instead, the NFT's smart contract contains a <code>tokenURI</code> function that returns a URL pointing to a JSON file containing the metadata.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Centralized Metadata Risk</strong></div><p>If the <code>tokenURI</code> points to a centralized server controlled by the project owner, they can change the metadata at any time. They could change the image of a rare NFT after it has been sold. Secure NFT projects use decentralized storage like IPFS or Arweave, where the content is addressed by its hash, making it immutable.</p></div>",
                        "image": "https://storage.googleapis.com/gweb-cloudblog-publish/images/cloud-metadata-unc2903-fig1_dkaq.max-1700x1700.png"
                    },
                    {
                        "title": "Cross-Chain Token Bridge Vulnerabilities",
                        "content": "<p>Cross-chain bridges allow users to transfer tokens from one blockchain to another (e.g., from Ethereum to Solana). They are notoriously difficult to secure and have been the target of some of the largest hacks in crypto history.</p><h3>Common Bridge Designs & Risks:</h3><ul><li><strong>Lock and Mint:</strong> A user locks Token A on Chain 1, and the bridge mints a wrapped version, Token B, on Chain 2. The primary risk is a flaw in the Chain 1 smart contract that allows an attacker to withdraw the locked tokens without burning the wrapped version, or a flaw in the Chain 2 contract that allows minting unbacked tokens.</li><li><strong>Validator-based:</strong> A set of validators attest to events on both chains. The risk here is collusion or compromise of the validators. If a majority of validators are malicious, they can approve fraudulent transfers.</li></ul>",
                        "image": "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcT6YBzHNvyrfzhUChVPC8S5FYxNxcqFWfofwA&s"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "Unsafe ERC-20 `approve` Change",
                        "language": "javascript",
                        "code": "// A user wants to change an approval from 100 to 50 tokens\n// 1. User submits transaction: approve(spender, 50)\n\n// 2. An attacker sees this in the mempool and acts first:\n// Attacker submits transaction: transferFrom(user, attacker, 100) with higher gas\n// This transaction gets mined first, using the original 100 token approval.\n\n// 3. The user's transaction to set the approval to 50 gets mined.\n\n// 4. The spender STILL has an approval for 50 tokens and can take them.\n// Total loss for user: 150 tokens.\n\n// Secure way: first approve(spender, 0), then approve(spender, 50)"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is a primary security risk associated with NFT metadata?",
                        "options": [
                            "The metadata files are too large for the blockchain.",
                            "If stored on a centralized server, the project owner can alter it after the NFT is sold.",
                            "The metadata can contain malicious code.",
                            "The metadata is visible to everyone."
                        ],
                        "correct": 1,
                        "explanation": "If the URI in the NFT contract points to a mutable, centralized location, the 'art' or properties of the NFT can be changed, undermining its value and ownership."
                    },
                    {
                        "id": 2,
                        "question": "Cross-chain bridges are considered high-risk targets primarily because...",
                        "options": [
                            "They are a new and untested technology.",
                            "They often act as large, centralized honeypots of locked funds and have complex, multi-chain logic.",
                            "They are slower than normal transactions.",
                            "They are not regulated."
                        ],
                        "correct": 1,
                        "explanation": "Bridges combine smart contract risk on multiple chains with potential validator/oracle risk, and the contracts often hold immense value, making them prime targets for hackers."
                    },
                    {
                        "id": 3,
                        "question": "What is a secure way to store NFT metadata to prevent manipulation?",
                        "options": [
                            "On the company's private web server",
                            "In a centralized database like AWS S3",
                            "Using a decentralized storage network like IPFS or Arweave",
                            "Encrypting the metadata"
                        ],
                        "correct": 2,
                        "explanation": "Decentralized storage solutions use content-addressing (hashing) to ensure that if the data changes, its address also changes, thus making the metadata immutable and verifiable."
                    }
                ]
            }
        },
        {
            "id": "lesson-12",
            "title": "Layer 2 Scaling Security",
            "duration": "90 min",
            "objectives": [
                "Understand the security models of state channels",
                "Identify vulnerabilities in the Plasma framework",
                "Differentiate between the security of Optimistic and ZK-Rollups",
                "Analyze the security considerations for sidechains",
                "Recognize risks in cross-layer communication"
            ],
            "content": {
                "overview": "As blockchains face scalability challenges, Layer 2 (L2) solutions have emerged to increase transaction throughput. These solutions process transactions off the main chain (Layer 1) but inherit its security. This lesson explores the security models of different L2 technologies like rollups, state channels, and sidechains, and the unique risks they introduce.",
                "sections": [
                    {
                        "title": "State Channels",
                        "content": "<p>State channels allow participants to conduct numerous transactions off-chain, only settling the final state on the main chain. A multi-signature contract on L1 acts as a judge.</p><h3>Security Model:</h3><ul><li><strong>Setup:</strong> Participants lock funds in the L1 contract.</li><li><strong>Transact:</strong> They exchange signed transactions directly with each other off-chain.</li><li><strong>Exit:</strong> Either party can submit the final signed state to the L1 contract to close the channel and withdraw funds. There is a 'challenge period' where the other party can submit a more recent state if they believe the submitted one is outdated or fraudulent.</li></ul><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Liveness Requirement</strong></div><p>The main security risk is the need for participants to be online to monitor the channel. If a malicious party tries to close the channel with an old state, the honest party must submit a challenge within the dispute period. If they are offline and miss the window, they could lose funds.</p></div>",
                        "image": "https://ronan.eth.limo/images/blog/state_chans.png"
                    },
                    {
                        "title": "Optimistic vs. ZK-Rollups",
                        "content": "<p>Rollups are the leading L2 scaling solution. They execute transactions off-chain but post the transaction data back to the L1, inheriting its data availability and security.</p><h3>Optimistic Rollups:</h3><p>These rollups 'optimistically' assume all transactions are valid. They submit batches of transactions to L1 without proof of validity. There is a challenge period (e.g., one week) during which anyone can submit a 'fraud proof' if they spot an invalid state transition. If the proof is valid, the fraudulent batch is reverted, and the submitter is penalized.</p><ul><li><strong>Security Risk:</strong> Relies on at least one honest validator being online to challenge fraud. Also, L1 censorship could potentially prevent fraud proofs from being submitted in time.</li></ul><h3>ZK-Rollups (Zero-Knowledge Rollups):</h3><p>These rollups bundle hundreds of transactions and generate a cryptographic proof (a ZK-SNARK or ZK-STARK) that these transactions are valid. This proof is posted to L1. The L1 contract only needs to verify the proof, which is much cheaper than re-executing all the transactions.</p><ul><li><strong>Security Advantage:</strong> Does not require a long challenge period, as every state transition is proven to be valid. Withdrawals are much faster. The main security challenge is the complexity of the proving technology itself.</li></ul>",
                        "image": "https://www.nervos.org/_next/image?url=%2Feducation_hub_articles%2Fzk_rollup_vs_optimistic_rollup%2Fimages%2Fimage3.png&w=3840&q=75"
                    },
                    {
                        "title": "Sidechains",
                        "content": "<p>A sidechain is an independent blockchain that runs in parallel to a main chain (like Ethereum). It has its own consensus mechanism, validators, and security properties. A two-way peg or 'bridge' is used to transfer assets between the sidechain and the mainnet.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Independent Security</strong></div><p>Unlike rollups, sidechains do NOT inherit the security of the L1. The security of a sidechain depends entirely on its own consensus mechanism. If the sidechain's validators collude or are compromised, the funds on the sidechain can be stolen. The bridge is also a major point of failure and a frequent target for hackers.</p></div>",
                        "image": "https://bitcoinwiki.org/wp-content/uploads/2023/12/400px-Blockchain-side-chain.png"
                    }
                ],
                "codeExamples": []
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "Which Layer 2 solution relies on 'fraud proofs' and a challenge period to ensure security?",
                        "options": [
                            "ZK-Rollups",
                            "State Channels",
                            "Optimistic Rollups",
                            "Sidechains"
                        ],
                        "correct": 2,
                        "explanation": "Optimistic Rollups assume transactions are correct by default but provide a window of time for anyone to challenge an invalid state transition by submitting a fraud proof."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary security difference between a sidechain and a rollup?",
                        "options": [
                            "Sidechains are faster than rollups.",
                            "Rollups inherit the security of the L1 main chain, while sidechains have their own separate security model.",
                            "Only sidechains can run smart contracts.",
                            "Rollups are more centralized than sidechains."
                        ],
                        "correct": 1,
                        "explanation": "Rollups post transaction data to the L1, allowing them to be secured by the L1's consensus. Sidechains are independent blockchains and are only as secure as their own validator set and consensus mechanism."
                    },
                    {
                        "id": 3,
                        "question": "Which technology uses cryptographic validity proofs to ensure the correctness of off-chain transactions without a challenge period?",
                        "options": [
                            "Plasma",
                            "State Channels",
                            "Optimistic Rollups",
                            "ZK-Rollups"
                        ],
                        "correct": 3,
                        "explanation": "ZK-Rollups use zero-knowledge proofs (like ZK-SNARKs) to mathematically prove the validity of every transaction batch submitted to the L1, eliminating the need for a fraud proof mechanism."
                    }
                ]
            }
        },
        {
            "id": "lesson-13",
            "title": "Privacy and Anonymity in Blockchain",
            "duration": "75 min",
            "objectives": [
                "Analyze the privacy models of coins like Monero and Zcash",
                "Understand the mechanics of Ring Signatures and Stealth Addresses",
                "Explain the role of Zero-Knowledge Proofs in providing privacy",
                "Recognize the risks and functionalities of mixing services (tumblers)",
                "Learn about deanonymization techniques and countermeasures"
            ],
            "content": {
                "overview": "While blockchains like Bitcoin are often thought to be anonymous, they are actually pseudonymous—all transactions are public. This lesson explores the advanced cryptographic techniques used by privacy-focused blockchains to obscure senders, receivers, and transaction amounts, and the constant cat-and-mouse game between privacy technologies and chain analysis.",
                "sections": [
                    {
                        "title": "Privacy Coins: Monero (Ring Signatures)",
                        "content": "<p>Monero is a privacy coin that aims to provide strong anonymity by default. It uses several key technologies:</p><ul><li><strong>Ring Signatures:</strong> To obscure the sender, a transaction is signed by the true sender but is mixed with the public keys of several other users (decoys) from the blockchain. An outside observer can verify that *one* of the participants in the ring signed the transaction, but cannot tell which one.</li><li><strong>Stealth Addresses:</strong> To hide the receiver, a new, one-time public address is generated for every single transaction. This prevents linking different payments to the same recipient.</li><li><strong>RingCT (Ring Confidential Transactions):</strong> This technology hides the amount of the transaction.</li></ul>",
                        "image": "https://lh5.googleusercontent.com/JUTg55OW3tUCRDC-Ir2Rgh22idIACAymcsSPGGlZWpEr2eMZa5ZK0WXDu47rPjBPHQBE-m6mqSe--rcF7TWD3z4YtkEJTXBC_MzNZ8ee6SiCEBZKXSZNcj9EAmA3UAYZ_eB_N4Xo-7qtq7Kwa1JyeSpkYbntdfJpg39CkxvsmMkvUMyvPofhQEU2Hlg7_w"
                    },
                    {
                        "title": "Privacy Coins: Zcash (Zero-Knowledge Proofs)",
                        "content": "<p>Zcash offers a different, optional approach to privacy using a powerful form of cryptography called <strong>zk-SNARKs</strong> (Zero-Knowledge Succinct Non-Interactive Argument of Knowledge).</p><p>A zero-knowledge proof allows one party (the prover) to prove to another party (the verifier) that a statement is true, without revealing any information beyond the validity of the statement itself.</p><p>In Zcash, this means a user can prove they have the authority to spend some coins and that the transaction balances (inputs equal outputs) without revealing their address, the recipient's address, or the amount being sent. Zcash has both transparent addresses (like Bitcoin) and shielded 'z-addresses' that use zk-SNARKs for privacy.</p>",
                        "image": "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQC3g55MBj-fD5xYUplayXMCkvPomETa9KzMg&s"
                    },
                    {
                        "title": "Mixing Services and Deanonymization",
                        "content": "<p>For pseudonymous blockchains like Bitcoin, <strong>mixing services</strong> (or tumblers) are used to enhance privacy. Users send their coins to a mixer, which pools them with coins from many other users, and then sends out the appropriate amounts to new addresses, breaking the on-chain link between the sender's original address and the recipient.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Risks and Countermeasures</strong></div><p><strong>Risks of Mixers:</strong> Users must trust the mixer not to steal their funds or keep logs of the transactions. Some mixers are also scams.</p><p><strong>Deanonymization:</strong> Blockchain analysis firms use advanced heuristics and clustering algorithms to analyze the public transaction graph. They can link addresses to known entities (like exchanges that require KYC), track the flow of funds through mixers, and use off-chain data (like IP addresses) to deanonymize users.</p></div>",
                        "image": "https://media.springernature.com/lw685/springer-static/image/chp%3A10.1007%2F978-981-96-1414-1_7/MediaObjects/639454_1_En_7_Fig1_HTML.png"
                    }
                ],
                "codeExamples": []
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "Which technology does Monero use to obscure the sender of a transaction?",
                        "options": [
                            "zk-SNARKs",
                            "Stealth Addresses",
                            "Ring Signatures",
                            "CoinJoin"
                        ],
                        "correct": 2,
                        "explanation": "Ring signatures group the actual signer with a set of decoys, making it impossible for an observer to determine which participant was the true sender."
                    },
                    {
                        "id": 2,
                        "question": "What is the core principle of a zero-knowledge proof?",
                        "options": [
                            "To prove a statement is true while revealing no other information.",
                            "To encrypt data so only two parties can read it.",
                            "To mix transactions from multiple users together.",
                            "To create a one-time address for receiving funds."
                        ],
                        "correct": 0,
                        "explanation": "ZKP allows a prover to convince a verifier of a statement's validity without conveying any of the underlying data that makes the statement true."
                    },
                    {
                        "id": 3,
                        "question": "What is the main risk of using a centralized mixing service (tumbler)?",
                        "options": [
                            "The fees are too high.",
                            "The transactions take too long.",
                            "The user must trust the mixer not to steal funds or keep logs.",
                            "It does not work for large transaction amounts."
                        ],
                        "correct": 2,
                        "explanation": "Centralized mixers are custodial, meaning you give up control of your funds to a third party, trusting them to return the funds and protect your privacy."
                    }
                ]
            }
        },
        {
            "id": "lesson-14",
            "title": "Wallet Security",
            "duration": "75 min",
            "objectives": [
                "Understand the structure of Hierarchical Deterministic (HD) wallets",
                "Analyze the security benefits of multi-signature wallets",
                "Recognize the role and security architecture of hardware wallets",
                "Learn best practices for seed phrase generation and storage",
                "Describe secure wallet backup and recovery mechanisms"
            ],
            "content": {
                "overview": "Wallets are the primary interface for users to interact with the blockchain. Securing the private keys managed by these wallets is arguably the most critical aspect of user-level security. This lesson covers different wallet architectures, from hot and cold storage to multi-sig and hardware wallets, and the best practices for keeping funds safe.",
                "sections": [
                    {
                        "title": "Hierarchical Deterministic (HD) Wallets",
                        "content": "<p>HD wallets (defined by the BIP-32 standard) allow you to create a tree-like structure of keys, all derived from a single master seed. This master seed is typically represented as a mnemonic phrase of 12-24 words (BIP-39).</p><h3>Key Advantages:</h3><ul><li><strong>Simplicity:</strong> You only need to back up the single seed phrase to recover all keys and funds in the wallet.</li><li><strong>Privacy:</strong> You can easily generate a new address for every transaction, making it harder to link your activities.</li><li><strong>Structure:</strong> The hierarchical structure (BIP-44) allows for organizing keys by purpose, currency, and account, which is useful for managing multiple cryptocurrencies.</li></ul>",
                        "image": "https://river.com/learn/images/articles/BIP-32-Hierarchial-Deterministic-Wallets.png"
                    },
                    {
                        "title": "Multi-Signature Wallets",
                        "content": "<p>A multi-signature (multi-sig) wallet requires more than one key to authorize a transaction. For example, a '2-of-3' multi-sig wallet has three associated private keys, and any two of them are required to sign and broadcast a transaction.</p><h3>Security Benefits:</h3><ul><li><strong>No Single Point of Failure:</strong> An attacker would need to compromise multiple keys (often stored in different locations or by different people) to steal funds.</li><li><strong>Corporate Governance:</strong> Ideal for businesses, as it allows for shared control over a treasury. For example, a transaction might require signatures from the CEO, CFO, and a board member.</li><li><strong>Redundancy:</strong> If one key is lost, the funds are not lost, as the other keys can still be used to move them to a new secure wallet.</li></ul>",
                        "image": "https://cdn.sanity.io/images/s3y3vcno/production/f5d3afb4ddb1b0d9a9bc87c890fe587e3e6af224-1420x916.png?auto=format"
                    },
                    {
                        "title": "Hardware Wallets",
                        "content": "<p>Hardware wallets are physical devices designed to provide full isolation between your private keys and your internet-connected computer. They are a form of 'cold storage'.</p><h3>How They Work:</h3><ol><li>Private keys are generated and stored on a special-purpose micro-controller inside the device.</li><li>The keys never leave the device.</li><li>When you want to make a transaction, the wallet software sends the unsigned transaction to the hardware wallet.</li><li>You verify the transaction details on the device's screen and physically press a button to sign it using the private key stored on the device.</li><li>The signed transaction is then sent back to the computer to be broadcast.</li></ol><div class='info-box tip'><div class='info-box-header'><i class='fas fa-lightbulb'></i><strong>Malware Resistance</strong></div><p>This architecture ensures that even if your computer is infected with malware, the malware cannot access your private keys. The worst it could do is present a fake transaction to the hardware wallet, which you would then reject on the device's trusted display.</p></div>",
                        "image": "https://academy.bit2me.com/wp-content/uploads/2019/12/hadware-wallets-y-sus-distintos-modelos-y-marcas.webp"
                    },
                    {
                        "title": "Seed Phrase Generation and Storage",
                        "content": "<p>The seed phrase (or recovery phrase) is the master key to your entire wallet. Its security is paramount.</p><h3>Best Practices:</h3><ul><li><strong>Generation:</strong> Always generate the seed phrase on a secure, offline device. A hardware wallet is the best option. Never type it into a computer or phone.</li><li><strong>Storage:</strong> Never store your seed phrase digitally (e.g., in a text file, cloud drive, or password manager). Write it down on paper or, for better durability, stamp it into metal.</li><li><strong>Location:</strong> Store the physical backup in a secure, private location (like a safe). Consider creating multiple backups and storing them in different geographically separate locations.</li><li><strong>Verification:</strong> Double-check your backup to ensure every word is spelled correctly and in the right order.</li></ul>",
                        "image": "https://www.ellipal.com/cdn/shop/files/ellipal-seed-phrase-generator-backup-packellipal-seed-phrase-generator-backup-pack-527651.png?v=1713767328&width=1946"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "HD Wallet Derivation Path (BIP44)",
                        "language": "bash",
                        "code": "# BIP44 defines a standard derivation path structure:\n# m / purpose' / coin_type' / account' / change / address_index\n\n# Example for the first Ethereum account's first receiving address:\n# m/44'/60'/0'/0/0\n\n# m: master private key\n# 44': indicates BIP44 specification\n# 60': coin type for Ethereum (0' would be Bitcoin)\n# 0': the first account\n# 0: the chain for external (receiving) addresses\n# 0: the first address in that account"
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary security advantage of a hardware wallet?",
                        "options": [
                            "It is protected by a password.",
                            "It keeps private keys isolated from internet-connected devices.",
                            "It can store an unlimited number of cryptocurrencies.",
                            "It automatically backs up your keys to the cloud."
                        ],
                        "correct": 1,
                        "explanation": "Hardware wallets are designed so that private keys never leave the device, protecting them from online threats like malware and phishing."
                    },
                    {
                        "id": 2,
                        "question": "What is the most secure way to store a wallet's seed phrase?",
                        "options": [
                            "In a password manager",
                            "In a private file on your computer",
                            "In an encrypted email to yourself",
                            "Written down on paper or stamped in metal, stored in a safe place"
                        ],
                        "correct": 3,
                        "explanation": "Digital storage is vulnerable to hacking. A physical, offline backup is the gold standard for securing a seed phrase."
                    },
                    {
                        "id": 3,
                        "question": "What is the benefit of a 2-of-3 multi-signature wallet?",
                        "options": [
                            "It makes transactions faster.",
                            "It eliminates transaction fees.",
                            "It provides redundancy and prevents a single point of failure; an attacker needs two keys, and losing one key doesn't result in loss of funds.",
                            "It generates a new address for every transaction."
                        ],
                        "correct": 2,
                        "explanation": "Multi-sig wallets distribute control, making them more resilient to theft (requiring multiple compromises) and loss (allowing recovery if one key is lost)."
                    }
                ]
            }
        },
        {
            "id": "lesson-15",
            "title": "Exchange and Custodial Security",
            "duration": "75 min",
            "objectives": [
                "Understand the security architecture of a centralized exchange (CEX)",
                "Differentiate between hot and cold wallet management strategies",
                "Recognize order book manipulation techniques",
                "Learn the importance of KYC/AML compliance for security",
                "Compare the security models of centralized and decentralized exchanges (DEX)"
            ],
            "content": {
                "overview": "For many users, cryptocurrency exchanges are the primary on-ramp and off-ramp. Securing these platforms, which handle billions of dollars in assets, is a monumental task. This lesson covers the security practices of custodial exchanges, from wallet management to market surveillance, and contrasts them with the non-custodial nature of DEXs.",
                "sections": [
                    {
                        "title": "Centralized Exchange (CEX) Architecture",
                        "content": "<p>A CEX is a company that operates a platform for users to buy, sell, and trade cryptocurrencies. When you deposit funds to a CEX, you are giving custody of your private keys to the exchange. The trading happens on the exchange's private, centralized database, not on the blockchain itself.</p><h3>Key Security Components:</h3><ul><li><strong>Wallet Management System:</strong> Manages user deposits and withdrawals.</li><li><strong>Trading Engine:</strong> Matches buy and sell orders.</li><li><strong>User Account Security:</strong> Features like Two-Factor Authentication (2FA), withdrawal limits, and whitelisting.</li><li><strong>Infrastructure Security:</strong> Protecting servers and databases from intrusion.</li></ul>",
                        "image": "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSL8gL9Qsx-PCRCb0FZdaX7-imT5t5iRehhKA&s"
                    },
                    {
                        "title": "Hot and Cold Wallet Management",
                        "content": "<p>Exchanges manage vast sums of user funds and must balance liquidity with security. They do this by segregating funds into hot and cold wallets.</p><h3>Hot Wallets:</h3><ul><li><strong>Connected to the internet.</strong></li><li>Used to process user withdrawals quickly.</li><li>Hold only a small percentage of the exchange's total funds.</li><li>Higher risk of being compromised.</li></ul><h3>Cold Wallets:</h3><ul><li><strong>Kept completely offline (air-gapped).</strong></li><li>Store the vast majority (e.g., 95%+) of user funds.</li><li>Often use multi-signature and hardware-based solutions.</li><li>Moving funds out of cold storage is a slow, manual process requiring multiple approvals, which provides a high degree of security.</li></ul>",
                        "image": "https://d3lkc3n5th01x7.cloudfront.net/wp-content/uploads/2022/10/31072437/hot-wallet.png"
                    },
                    {
                        "title": "Decentralized Exchange (DEX) Security Models",
                        "content": "<p>A DEX allows for peer-to-peer trading directly from users' wallets via smart contracts. This is a non-custodial model.</p><h3>Security Differences:</h3><ul><li><strong>Custody:</strong> With a DEX, you always retain control of your private keys and funds. There is no risk of the exchange being hacked and losing your deposits.</li><li><strong>Risk Type:</strong> The risk shifts from the exchange's operational security to the security of the DEX's smart contracts. A bug in a DEX's smart contract can lead to a complete loss of funds in its liquidity pools.</li><li><strong>Anonymity:</strong> DEXs typically do not require KYC, which can enhance user privacy but also makes them a potential venue for money laundering.</li></ul><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>The Trade-off</strong></div><p>CEXs offer convenience and features like order books and customer support, but require trusting a third party. DEXs offer self-custody and transparency, but expose users directly to smart contract risk and can be less user-friendly.</p></div>",
                        "image": "https://www.coolwallet.io/cdn/shop/articles/Understanding_Centralized_Exchanges_CEXs.png?v=1729353575"
                    }
                ],
                "codeExamples": []
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary purpose of a 'cold wallet' for a cryptocurrency exchange?",
                        "options": [
                            "To process user withdrawals as quickly as possible.",
                            "To store the majority of user funds in a secure, offline environment.",
                            "To trade cryptocurrencies on behalf of users.",
                            "To provide a user-friendly interface for new customers."
                        ],
                        "correct": 1,
                        "explanation": "Cold wallets are air-gapped from the internet, making them immune to online hacking attempts. Exchanges use them to safeguard the bulk of their assets."
                    },
                    {
                        "id": 2,
                        "question": "When you use a decentralized exchange (DEX), who holds your private keys?",
                        "options": [
                            "The DEX's administrators",
                            "A third-party custodian",
                            "You, the user",
                            "The keys are split among the liquidity providers"
                        ],
                        "correct": 2,
                        "explanation": "DEXs are non-custodial. Users interact with the smart contracts directly from their own wallets (like MetaMask), meaning they never give up control of their keys."
                    },
                    {
                        "id": 3,
                        "question": "What is the main security risk when using a DEX?",
                        "options": [
                            "The exchange's servers could be hacked.",
                            "The company running the DEX could go bankrupt.",
                            "A vulnerability in the DEX's smart contracts could be exploited.",
                            "The government could shut down the DEX's website."
                        ],
                        "correct": 2,
                        "explanation": "Since all operations on a DEX are handled by smart contracts, any bug or vulnerability in that code can be exploited by hackers to drain funds from the liquidity pools."
                    }
                ]
            }
        },
        {
            "id": "lesson-16",
            "title": "Governance and DAO Security",
            "duration": "75 min",
            "objectives": [
                "Understand the structure of a Decentralized Autonomous Organization (DAO)",
                "Analyze the security models of governance tokens",
                "Identify vulnerabilities in on-chain voting mechanisms",
                "Recognize risks in the proposal and execution security pipeline",
                "Learn best practices for treasury management security"
            ],
            "content": {
                "overview": "DAOs use smart contracts to enable collective decision-making and management of resources. While powerful, this on-chain governance introduces new security challenges, from malicious proposals to economic attacks that manipulate voting power. This lesson explores how to secure the processes that govern decentralized protocols.",
                "sections": [
                    {
                        "title": "DAO Structure and Governance Tokens",
                        "content": "<p>A DAO is an organization represented by rules encoded as a computer program that is transparent, controlled by the organization members, and not influenced by a central government. Decision-making is typically done through proposals and voting by members who hold governance tokens.</p><p><strong>Governance Tokens</strong> grant holders the right to vote on proposals. The weight of a user's vote is often proportional to the number of tokens they hold.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Economic Attack Vector</strong></div><p>This model is vulnerable to governance attacks. If an attacker can accumulate enough governance tokens (often by borrowing them via flash loans), they can gain enough voting power to pass a malicious proposal, such as one that transfers all of the DAO's treasury funds to the attacker's address.</p></div>",
                        "image": "https://metana-website-rpd-3cgq.ue1.rapydapps.cloud/wp-content/uploads/2025/04/image-4.png"
                    },
                    {
                        "title": "Voting Mechanism Vulnerabilities",
                        "content": "<p>The design of the voting mechanism is critical to a DAO's security.</p><h3>Key Considerations:</h3><ul><li><strong>Quorum:</strong> The minimum percentage of total voting power that must participate for a vote to be valid. A low quorum could allow a minority to pass proposals.</li><li><strong>Voting Period:</strong> The length of time a proposal is open for voting. It must be long enough for members to review and vote, but not so long that it paralyzes the DAO.</li><li><strong>Vote Timing:</strong> Some systems are vulnerable to vote manipulation near the end of the voting period.</li><li><strong>Flash Loan Resistance:</strong> To prevent attackers from borrowing tokens just to vote, many DAOs now use a snapshot-based system, where voting power is determined by the token balance at the time the proposal was created, not at the time of voting.</li></ul>",
                        "image": "https://www.krungsri.com/getmedia/e6202f91-f01a-408d-a840-eff704f86d7e/ri-blockchain-voting-en-f1.png.aspx"
                    },
                    {
                        "title": "Proposal Execution and Treasury Security",
                        "content": "<p>After a proposal passes, its code must be executed. This is a critical point of failure.</p><p>A <strong>Time-lock</strong> contract is a common security feature. It introduces a mandatory delay between when a proposal is passed and when its code can be executed. This delay gives the community time to review the code and take emergency action (e.g., by exiting the protocol with their funds) if a malicious proposal somehow passes.</p><h3>Treasury Management:</h3><p>A DAO's treasury, which can hold billions of dollars, should never be controlled by a single private key. It should be managed by a multi-signature wallet controlled by trusted, elected community members or by the governance contract itself, protected by a time-lock.</p>",
                        "image": "https://cdn-resources.highradius.com/resources/wp-content/uploads/2024/07/5-Key-Benefits-of-the-Treasury-Management-System.jpg"
                    }
                ],
                "codeExamples": []
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary purpose of a time-lock in DAO governance?",
                        "options": [
                            "To speed up the voting process",
                            "To provide a delay between a vote passing and its execution, allowing for a last-chance review",
                            "To lock up governance tokens so they cannot be sold",
                            "To calculate the quorum for a vote"
                        ],
                        "correct": 1,
                        "explanation": "A time-lock acts as a crucial safeguard, giving the community a window to react and protect assets if a malicious proposal is approved."
                    },
                    {
                        "id": 2,
                        "question": "How can flash loans be used to attack a DAO's governance?",
                        "options": [
                            "By draining the DAO's treasury directly",
                            "By borrowing a large number of governance tokens to pass a malicious vote",
                            "By creating a denial-of-service attack on the voting contract",
                            "By bribing other voters"
                        ],
                        "correct": 1,
                        "explanation": "If voting power is calculated at the moment of voting, an attacker can use a flash loan to acquire temporary but massive voting power for a single transaction."
                    },
                    {
                        "id": 3,
                        "question": "What is the best practice for securing a large DAO treasury?",
                        "options": [
                            "Storing the funds in a single hardware wallet",
                            "Using a multi-signature wallet controlled by trusted community members or a time-locked governance contract",
                            "Depositing the funds into a centralized exchange for safekeeping",
                            "Converting all assets to a single stablecoin"
                        ],
                        "correct": 1,
                        "explanation": "A multi-sig or a governance-controlled contract with a time-lock eliminates single points of failure and ensures that no single individual can control the treasury."
                    }
                ]
            }
        },
        {
            "id": "lesson-17",
            "title": "Cross-Chain and Interoperability Security",
            "duration": "90 min",
            "objectives": [
                "Understand common cross-chain bridge architectures",
                "Analyze the security models of atomic swaps",
                "Learn about the security of relay chains like Polkadot and Cosmos",
                "Describe inter-blockchain communication (IBC) protocols",
                "Recognize the risks associated with cross-chain assets"
            ],
            "content": {
                "overview": "The future of blockchain is multi-chain, but connecting these disparate networks is fraught with security challenges. This lesson provides a deep dive into the world of interoperability, focusing on the design and common vulnerabilities of cross-chain bridges, which have become a primary target for hackers.",
                "sections": [
                    {
                        "title": "Cross-Chain Bridge Architectures",
                        "content": "<p>Bridges are protocols that enable the transfer of assets and data between different blockchains. They come in various designs, each with different trust assumptions.</p><h3>Common Types:</h3><ul><li><strong>Trusted / Centralized:</strong> A single entity or small federation acts as the custodian. Users trust this entity to process transfers correctly. This is efficient but has a central point of failure.</li><li><strong>Trust-Minimized (Light Client):</strong> These bridges use smart contracts on each chain to verify the state of the other chain. For example, a bridge on Ethereum might run a light client of the Solana blockchain to verify transactions. This is more decentralized but also more complex.</li><li><strong>Liquidity Networks:</strong> These act as a hub-and-spoke system, with liquidity pools on each connected chain, facilitated by routers.</li></ul><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>The Bridge Dilemma</strong></div><p>Bridges are often described as the weakest link in the multi-chain ecosystem. They combine smart contract risk, potential validator collusion risk, and complex off-chain logic, all while securing billions of dollars in assets.</p></div>",
                        "image": "https://coingape.com/wp-content/uploads/2023/02/cross-chain_bridges.jpg"
                    },
                    {
                        "title": "Relay Chain Security (Polkadot & Cosmos)",
                        "content": "<p>Platforms like Polkadot and Cosmos provide a framework for building and connecting application-specific blockchains (parachains or zones).</p><h3>Shared Security Model:</h3><p>In Polkadot, a central <strong>Relay Chain</strong> provides security for all connected <strong>Parachains</strong>. The parachains don't need their own validator sets; they 'rent' security from the Relay Chain's global set of validators. This shared security model means that an attack on one parachain is an attack on the entire Polkadot network, and the economic security of the whole system is used to protect each part.</p><p>Cosmos uses a different model where each chain (zone) is responsible for its own security, but can communicate with other zones via the <strong>Inter-Blockchain Communication (IBC)</strong> protocol.</p>",
                        "image": "https://miro.medium.com/v2/resize:fit:1400/0*r8RvZdibg4tR9CJG"
                    },
                    {
                        "title": "Atomic Swaps",
                        "content": "<p>An atomic swap is a smart contract-based technology that allows for the exchange of two different cryptocurrencies on different blockchains, without needing to trust a third party or intermediary.</p><p>It uses <strong>Hashed Time-lock Contracts (HTLCs)</strong> on both chains. The swap is 'atomic' because it either completes successfully on both chains, or it fails and both parties get their original funds back after a timeout. This eliminates counterparty risk.</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Limitations</strong></div><p>While very secure, atomic swaps are complex to set up, not suitable for all types of assets, and can be slower than using a centralized service.</p></div>",
                        "image": "https://bitpanda-academy.imgix.net/null1bc34fe8-19e0-4ab6-9cb0-6301bf37ed3c/bitpanda-academy-intermediate-24-atomic-swap-header-bg.png?auto=compress%2Cformat&fit=min&fm=jpg&q=80&w=2100"
                    }
                ],
                "codeExamples": []
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What has been the most common point of failure leading to the largest hacks in the blockchain space?",
                        "options": [
                            "Wallet software",
                            "Consensus mechanisms",
                            "Cross-chain bridges",
                            "Mining pools"
                        ],
                        "correct": 2,
                        "explanation": "Cross-chain bridges have consistently been the target of the largest exploits due to their complexity, the massive value they secure, and the combination of multiple potential failure points."
                    },
                    {
                        "id": 2,
                        "question": "What does the 'shared security' model of Polkadot mean?",
                        "options": [
                            "All parachains share the same source code.",
                            "All connected parachains are secured by the main Relay Chain's global set of validators.",
                            "Users must use the same wallet for all parachains.",
                            "All parachains share their revenue with each other."
                        ],
                        "correct": 1,
                        "explanation": "Polkadot's Relay Chain provides the economic security for the entire network, and parachains lease this security instead of having to build and secure their own validator communities."
                    },
                    {
                        "id": 3,
                        "question": "What is the key feature of an atomic swap using HTLCs?",
                        "options": [
                            "It is the fastest way to exchange assets.",
                            "It requires a trusted intermediary.",
                            "The swap either completes successfully for both parties, or it fails and both get their original funds back.",
                            "It allows for swapping multiple assets at once."
                        ],
                        "correct": 2,
                        "explanation": "The 'atomic' nature of the swap ensures that there is no risk of one party sending their funds and not receiving the other party's funds in return."
                    }
                ]
            }
        },
        {
            "id": "lesson-18",
            "title": "Oracle Security and External Data",
            "duration": "75 min",
            "objectives": [
                "Understand the 'Oracle Problem' and its security challenges",
                "Learn how decentralized oracle networks (DONs) work",
                "Analyze price manipulation attacks targeting oracles",
                "Describe data feed validation and aggregation mechanisms",
                "Recognize the risk of oracle front-running"
            ],
            "content": {
                "overview": "Smart contracts cannot access off-chain data on their own. Oracles are the bridges that connect blockchains to real-world data, such as asset prices, weather information, or sports results. Securing this bridge is critical, as a corrupted oracle can trigger catastrophic failures in the smart contracts that rely on it.",
                "sections": [
                    {
                        "title": "The Oracle Problem",
                        "content": "<p>Blockchains are deterministic, sandboxed systems. They need to achieve consensus, which means every node must get the exact same result when executing a transaction. If smart contracts could freely call external APIs, this determinism would be broken, as the API could be down, return different results at different times, or be manipulated.</p><p>The <strong>Oracle Problem</strong> is the challenge of getting external, real-world data onto the blockchain in a way that is secure, reliable, and trustworthy. A smart contract is only as secure as the oracle that feeds it data.</p>",
                        "image": "https://metana-website-rpd-3cgq.ue1.rapydapps.cloud/wp-content/uploads/2023/09/oracle-problem-1024x724.png"
                    },
                    {
                        "title": "Decentralized Oracle Networks (DONs)",
                        "content": "<p>Using a single, centralized oracle creates a single point of failure. If that oracle is hacked, goes offline, or provides bad data, the smart contract it serves will fail. <strong>Decentralized Oracle Networks</strong>, like Chainlink, solve this by decentralizing the data sourcing and reporting process.</p><h3>How DONs Work:</h3><ol><li>A smart contract requests data (e.g., the price of ETH/USD).</li><li>The request is picked up by a network of independent, geographically distributed oracle nodes.</li><li>Each node retrieves the data from multiple high-quality, off-chain sources (e.g., various exchange APIs).</li><li>The nodes' individual responses are aggregated on-chain by a smart contract.</li><li>This aggregation process filters out outliers and produces a single, highly reliable data point that is then fed to the requesting smart contract.</li></ol><p>This decentralization at both the node and data source level makes the system highly resistant to manipulation and downtime.</p>",
                        "image": "https://www.horizen.io/academy/assets/images/ZBF_academy_Decentralized-oracle-graphic-b639df1be6f1b82bf78aa346e352b6c7.jpg"
                    },
                    {
                        "title": "Price Manipulation Attacks",
                        "content": "<p>Even with oracles, DeFi protocols can be vulnerable if they are not configured correctly.</p><p>The most common attack vector is a protocol that relies on a price oracle sourced from a single, low-liquidity decentralized exchange (DEX). An attacker can use a flash loan to execute a large trade on that specific DEX, momentarily skewing the price. The oracle then reports this manipulated price to the vulnerable protocol, which could then allow the attacker to borrow more assets than their collateral is worth, or trigger unfair liquidations.</p><div class='info-box tip'><div class='info-box-header'><i class='fas fa-lightbulb'></i><strong>Defense Mechanisms</strong></div><p>The best defense is to use a robust, decentralized oracle network that aggregates data from many sources. Additionally, using a Time-Weighted Average Price (TWAP) oracle, which averages the price over a period of time, makes it much harder and more expensive to manipulate than a spot price oracle.</p></div>",
                        "image": "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQT1L6Nd_H5LjnEopVFojALuygsgYdTVLtj3g&s"
                    }
                ],
                "codeExamples": []
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the 'Oracle Problem' in the context of blockchain?",
                        "options": [
                            "The high cost of storing data on-chain.",
                            "The challenge of getting reliable and secure real-world data onto the blockchain.",
                            "The difficulty of writing secure smart contracts.",
                            "The inability of blockchains to communicate with each other."
                        ],
                        "correct": 1,
                        "explanation": "It's the fundamental issue that blockchains are isolated systems, and need a secure mechanism (an oracle) to interact with off-chain data and systems without compromising their security and determinism."
                    },
                    {
                        "id": 2,
                        "question": "How do Decentralized Oracle Networks (DONs) like Chainlink improve security over a single, centralized oracle?",
                        "options": [
                            "They are much faster.",
                            "They use decentralization at both the node and data source level to prevent a single point of failure.",
                            "They offer lower fees.",
                            "They can access data that centralized oracles cannot."
                        ],
                        "correct": 1,
                        "explanation": "By aggregating data from multiple independent nodes, which in turn pull from multiple data sources, DONs create a highly reliable and tamper-resistant data feed."
                    },
                    {
                        "id": 3,
                        "question": "Why is it insecure for a lending protocol to use the spot price from a single low-liquidity DEX as its price oracle?",
                        "options": [
                            "The DEX could go offline.",
                            "An attacker could use a flash loan to easily manipulate the price on that DEX.",
                            "The DEX's API might have high latency.",
                            "The DEX might not list all the necessary assets."
                        ],
                        "correct": 1,
                        "explanation": "Low-liquidity pools are highly susceptible to slippage, meaning a single large trade (easily funded by a flash loan) can drastically alter the price, which the oracle would then report as accurate."
                    }
                ]
            }
        },
        {
            "id": "lesson-19",
            "title": "MEV and Transaction Ordering Security",
            "duration": "75 min",
            "objectives": [
                "Define and analyze Maximal Extractable Value (MEV)",
                "Differentiate between front-running and back-running attacks",
                "Learn about common MEV extraction techniques like sandwich attacks",
                "Understand the concept of fair sequencing services",
                "Explore potential solutions like transaction privacy"
            ],
            "content": {
                "overview": "The public nature of blockchain mempools creates a dark forest where sophisticated bots compete to extract value by reordering, censoring, or inserting transactions within a block. This phenomenon, known as MEV, has profound implications for user experience and network security. This lesson explores the world of MEV, its common attack vectors, and the ongoing search for solutions.",
                "sections": [
                    {
                        "title": "Maximal Extractable Value (MEV) Analysis",
                        "content": "<p>MEV (formerly Miner Extractable Value, now Maximal Extractable Value) is the maximum value that can be extracted from block production in excess of the standard block reward and gas fees by including, excluding, and changing the order of transactions in a block.</p><p>Block producers (miners in PoW, validators in PoS) have the ultimate power to decide the order of transactions in a block. They can use this power for their own benefit or sell this right to independent 'searchers' who look for MEV opportunities.</p><h3>Examples of MEV:</h3><ul><li><strong>Arbitrage:</strong> Capturing price differences for an asset on two different DEXs.</li><li><strong>Liquidations:</strong> Being the first to liquidate an under-collateralized loan in a lending protocol to claim the reward.</li><li><strong>Sandwich Attacks:</strong> A particularly harmful form of MEV that targets users.</li></ul>",
                        "image": "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSSnas_sgvvhGSj5kKbl-fdW0qKA_gxRiWMkQ&s"
                    },
                    {
                        "title": "Front-running and Sandwich Attacks",
                        "content": "<h3>Front-running:</h3><p>This involves seeing a user's transaction in the mempool and paying a higher gas fee to get your own transaction included first. For example, seeing a large buy order for a token and buying it first to profit from the price increase.</p><h3>Sandwich Attack:</h3><p>This is a specific type of front-running that targets trades on AMMs. It works in three steps:<ol><li>A searcher bot sees a user's large buy transaction for Token X in the mempool.</li><li><strong>Front-running:</strong> The bot places its own buy order for Token X with a higher gas fee, causing the price to increase for the victim user (more slippage).</li><li>The victim's transaction now executes at a worse price.</li><li><strong>Back-running:</strong> The bot immediately sells Token X in the same block with a lower gas fee, profiting from the price difference it created.</li></ol>The victim's transaction is 'sandwiched' between the attacker's two trades.</p>",
                        "image": "https://www.researchgate.net/publication/394939848/figure/fig3/AS:11431281605573142@1756174175263/Front-running-attack-classification.png"
                    },
                    {
                        "title": "Mitigation Strategies and Fair Ordering",
                        "content": "<p>The MEV problem is complex and deeply ingrained in the architecture of many blockchains. Several strategies are being explored to mitigate its negative effects.</p><h3>Potential Solutions:</h3><ul><li><strong>MEV-Boost / Flashbots:</strong> Instead of fighting MEV, these solutions create a more transparent and efficient marketplace for it. Searchers bid for their transaction bundles to be included in a block, and validators are paid for including them. This helps prevent wasteful gas-price bidding wars but does not solve the underlying problem for users.</li><li><strong>Transaction Privacy / Encrypted Mempools:</strong> If the content of a transaction is not visible in the mempool, searchers cannot front-run it. Solutions like encrypted mempools or protocols that allow users to send transactions directly to block producers are being developed.</li><li><strong>Fair Sequencing Services (FSS):</strong> These are protocols that aim to order transactions based on a fair criterion, such as first-come, first-served, rather than by the highest gas price.</li></ul>",
                        "image": "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQYLvR714Qol09Qvzb00Tig3ZGI4wE9CgCRWQ&s"
                    }
                ],
                "codeExamples": []
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is Maximal Extractable Value (MEV)?",
                        "options": [
                            "The total value of all transactions in a block.",
                            "The value extracted by reordering, including, or excluding transactions in a block.",
                            "A type of consensus algorithm.",
                            "A vulnerability in the Ethereum Virtual Machine."
                        ],
                        "correct": 1,
                        "explanation": "MEV refers to the profit a block producer can make by using their power to arbitrarily order transactions within the block they produce."
                    },
                    {
                        "id": 2,
                        "question": "What happens in a 'sandwich attack'?",
                        "options": [
                            "Two attackers collude to steal funds.",
                            "An attacker places trades before and after a victim's trade to profit from the price slippage.",
                            "An attacker sends a transaction with invalid data to crash a node.",
                            "A transaction is split into two smaller parts."
                        ],
                        "correct": 1,
                        "explanation": "The attacker front-runs the victim to drive the price up, then back-runs them by selling immediately after, extracting value from the victim's trade."
                    },
                    {
                        "id": 3,
                        "question": "How can encrypted mempools help mitigate MEV?",
                        "options": [
                            "By making transactions process faster.",
                            "By hiding the content of transactions until they are included in a block, preventing front-running.",
                            "By lowering gas fees for all users.",
                            "By guaranteeing that transactions are processed in a specific order."
                        ],
                        "correct": 1,
                        "explanation": "If MEV searchers cannot see the details of a transaction (e.g., what tokens are being traded and for how much), they cannot devise a strategy to front-run it."
                    }
                ]
            }
        },
        {
            "id": "lesson-20",
            "title": "Regulatory Compliance and Legal Security",
            "duration": "60 min",
            "objectives": [
                "Understand the role of regulatory frameworks (e.g., SEC, FinCEN) in blockchain",
                "Learn about the importance of AML/KYC implementation in DeFi",
                "Analyze the trade-offs between privacy and compliance",
                "Recognize the function of regulatory sandboxes",
                "Identify legal risks associated with decentralized entities like DAOs"
            ],
            "content": {
                "overview": "As the blockchain industry matures, it increasingly intersects with the legal and regulatory world. Understanding compliance obligations is now a critical part of security, as regulatory action can pose an existential threat to projects. This lesson covers key compliance areas like AML/KYC and the legal challenges facing decentralized applications.",
                "sections": [
                    {
                        "title": "Regulatory Frameworks (AML/KYC)",
                        "content": "<p>Governments worldwide are applying existing financial regulations to the crypto space to prevent illicit activities.</p><h3>Key Regulations:</h3><ul><li><strong>Anti-Money Laundering (AML):</strong> A set of laws and regulations aimed at preventing criminals from disguising illegally obtained funds as legitimate income.</li><li><strong>Know Your Customer (KYC):</strong> A requirement for financial institutions to verify the identity of their clients. This is a crucial part of AML compliance.</li><li><strong>Counter-Financing of Terrorism (CFT):</strong> Regulations aimed at preventing the flow of funds to terrorist organizations.</li></ul><p>Centralized exchanges and other crypto businesses are typically required to implement robust AML/KYC programs, including customer identity verification and transaction monitoring for suspicious activity.</p>",
                        "image": "https://www.complycube.com/wp-content/uploads/2021/02/AML-vs-KYC-What-is-the-difference-1024x558.jpg.webp"
                    },
                    {
                        "title": "Compliance in DeFi and the Privacy Trade-off",
                        "content": "<p>Applying regulations like KYC to the decentralized, non-custodial world of DeFi is a major challenge. The ethos of DeFi often prioritizes privacy and permissionless access.</p><p>However, regulators have begun to focus on DeFi protocols, and solutions are emerging to bridge this gap. This includes 'permissioned' DeFi pools that are only accessible to KYC'd users, or the use of on-chain identity solutions and Zero-Knowledge Proofs to prove compliance with a rule (e.g., 'I am not on a sanctions list') without revealing one's full identity.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>The Tornado Cash Example</strong></div><p>The sanctioning of Tornado Cash, a decentralized privacy protocol, by the U.S. Treasury demonstrated that regulators are willing to take action against code itself, creating significant legal uncertainty for developers and users of privacy-enhancing technologies.</p></div>",
                        "image": "https://media.assettype.com/analyticsinsight%2F2025-05-19%2Focj7s0mq%2FPrivacy-in-DeFi.jpg"
                    },
                    {
                        "title": "Legal Security and DAO Liability",
                        "content": "<p>The legal status of decentralized entities like DAOs is largely untested and varies by jurisdiction. A key question is whether a DAO can be considered a 'general partnership'.</p><p>If so, every token-holding member of the DAO could potentially be held jointly and severally liable for the actions of the DAO. This creates significant legal risk for participants. To mitigate this, some DAOs are wrapping themselves in legal structures, such as creating a foundation or a limited liability company (LLC) in a crypto-friendly jurisdiction to act as a legal entity for the DAO.</p>",
                        "image": "https://strapi.aurum.law/uploads/Pic1_chart_4cedb79312.webp"
                    }
                ],
                "codeExamples": []
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What does KYC stand for in the context of financial regulation?",
                        "options": [
                            "Know Your Chain",
                            "Keep Your Coins",
                            "Know Your Customer",
                            "Key Yield Calculation"
                        ],
                        "correct": 2,
                        "explanation": "Know Your Customer (KYC) is the mandatory process of identifying and verifying the identity of clients when opening an account and periodically over time."
                    },
                    {
                        "id": 2,
                        "question": "What is a major legal uncertainty surrounding DAOs?",
                        "options": [
                            "Whether they are profitable.",
                            "Whether they could be legally classified as general partnerships, making all members liable.",
                            "Whether their smart contracts will work as intended.",
                            "Whether they can attract enough members to be effective."
                        ],
                        "correct": 1,
                        "explanation": "The lack of a clear legal framework for DAOs creates ambiguity about liability, which could expose individual members to significant legal and financial risk."
                    },
                    {
                        "id": 3,
                        "question": "The sanctioning of Tornado Cash by the U.S. Treasury was a significant event because it...",
                        "options": [
                            "demonstrated a technical flaw in a smart contract.",
                            "was the first time a DeFi protocol was hacked.",
                            "targeted immutable code and raised legal questions about developer liability and user privacy.",
                            "caused the price of Ethereum to fall."
                        ],
                        "correct": 2,
                        "explanation": "This action moved beyond targeting individuals or companies to sanctioning a decentralized tool, creating a chilling effect on the development of privacy technologies."
                    }
                ]
            }
        },
        {
            "id": "lesson-21",
            "title": "Quantum Computing Threats to Blockchain",
            "duration": "60 min",
            "objectives": [
                "Understand how quantum computers could break current cryptographic standards",
                "Learn about Shor's Algorithm and its impact on public key cryptography",
                "Explore the principles of Post-Quantum Cryptography (PQC)",
                "Identify quantum-resistant signature schemes",
                "Analyze migration strategies for existing blockchains"
            ],
            "content": {
                "overview": "Quantum computing represents a long-term, fundamental threat to the cryptography that underpins nearly all modern digital security, including blockchain. This lesson explains the nature of this threat, the development of quantum-resistant algorithms, and the strategies the blockchain industry is exploring to prepare for a post-quantum future.",
                "sections": [
                    {
                        "title": "Quantum Computing's Impact on Cryptography",
                        "content": "<p>Classical computers store information in bits, which can be either a 0 or a 1. Quantum computers use qubits, which can exist in a superposition of both 0 and 1 simultaneously. This allows them to perform certain types of calculations exponentially faster than classical computers.</p><h3>The Threat:</h3><p>The security of public key cryptography (like RSA and ECDSA, which is used by Bitcoin and Ethereum) relies on the fact that it is computationally infeasible for classical computers to derive a private key from a public key. This is based on the difficulty of problems like integer factorization and the discrete logarithm problem.</p><p>A sufficiently powerful quantum computer could solve these problems easily, breaking the security of nearly all existing blockchains.</p>",
                        
                    },
                    {
                        "title": "Shor's Algorithm",
                        "content": "<p><strong>Shor's Algorithm</strong>, developed by Peter Shor in 1994, is a quantum algorithm that can find the prime factors of an integer exponentially faster than any known classical algorithm. If a large-scale quantum computer is built, it could run Shor's Algorithm to break RSA encryption.</p><p>A similar quantum algorithm can solve the discrete logarithm problem, which would break Elliptic Curve Cryptography (ECC), including the ECDSA signatures used to secure transactions in Bitcoin and Ethereum. This would allow an attacker with a quantum computer to calculate a user's private key from their public key and steal their funds.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>When is the Public Key Revealed?</strong></div><p>In Bitcoin, the public key is not revealed until a user makes their first outgoing transaction from an address. This means funds in unused addresses are safe from this specific attack vector, but as soon as you spend from an address, its public key is on the blockchain, and its funds become theoretically vulnerable in a quantum future.</p></div>",
                        "image": "https://miro.medium.com/v2/resize:fit:1200/1*bkN-PgZ8DnC7-bCihS-Isg.png"
                    },
                    {
                        "title": "Post-Quantum Cryptography (PQC)",
                        "content": "<p>Post-Quantum Cryptography (PQC) refers to cryptographic algorithms that are thought to be secure against attacks by both classical and quantum computers. These algorithms are based on mathematical problems that are believed tobe difficult for even quantum computers to solve.</p><h3>Major PQC Families:</h3><ul><li><strong>Lattice-based cryptography:</strong> Based on the difficulty of problems related to geometric structures called lattices. (e.g., CRYSTALS-Kyber, CRYSTALS-Dilithium)</li><li><strong>Hash-based signatures:</strong> Use cryptographic hash functions as their only security assumption. They are well-understood but have limitations like a limited number of signatures per key. (e.g., SPHINCS+)</li><li><strong>Code-based cryptography:</strong> Based on the difficulty of decoding a general linear code.</li><li><strong>Multivariate cryptography:</strong> Based on the difficulty of solving systems of multivariate equations.</li></ul><p>Organizations like NIST are in the final stages of standardizing PQC algorithms that will be used to secure future digital systems.</p>",
                        
                    }
                ],
                "codeExamples": []
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary threat that quantum computing poses to current blockchains?",
                        "options": [
                            "It could mine blocks much faster.",
                            "It could break the public key cryptography (ECDSA) used for digital signatures.",
                            "It could create a denial-of-service attack on the network.",
                            "It could solve complex smart contract logic."
                        ],
                        "correct": 1,
                        "explanation": "A sufficiently powerful quantum computer running Shor's algorithm could derive a private key from a public key, allowing it to forge signatures and steal funds."
                    },
                    {
                        "id": 2,
                        "question": "What is Post-Quantum Cryptography (PQC)?",
                        "options": [
                            "A method for building quantum computers.",
                            "Cryptography that can only be run on a quantum computer.",
                            "A set of cryptographic algorithms designed to be secure against quantum computer attacks.",
                            "A way to encrypt the blockchain itself."
                        ],
                        "correct": 2,
                        "explanation": "PQC refers to new cryptographic approaches that are based on mathematical problems hard for both classical and quantum computers to solve, ensuring long-term security."
                    },
                    {
                        "id": 3,
                        "question": "Are the hash functions used in blockchains (like SHA-256) also vulnerable to Shor's Algorithm?",
                        "options": [
                            "Yes, they are easily broken.",
                            "No, hash functions are generally considered more resistant to quantum attacks, though their security is reduced.",
                            "Only some hash functions are vulnerable.",
                            "It is unknown if they are vulnerable."
                        ],
                        "correct": 1,
                        "explanation": "Shor's algorithm targets the specific mathematical structures of public-key cryptography. While another quantum algorithm (Grover's) can speed up hash collision searches, it does not 'break' them in the same way. The primary defense is to use a larger hash output size (e.g., SHA-256 is considered relatively safe)."
                    }
                ]
            }
        },
        {
            "id": "lesson-22",
            "title": "Advanced Cryptographic Primitives",
            "duration": "90 min",
            "objectives": [
                "Understand the difference between zk-SNARKs and zk-STARKs",
                "Explore potential applications of Homomorphic Encryption in blockchain",
                "Learn how Multi-Party Computation (MPC) can secure private keys",
                "Describe the function of threshold cryptography schemes",
                "Grasp the concept of Verifiable Delay Functions (VDFs)"
            ],
            "content": {
                "overview": "Beyond hashes and signatures, a new generation of advanced cryptographic primitives is enabling more powerful privacy and security features on the blockchain. This lesson explores cutting-edge technologies like zero-knowledge proofs, MPC, and homomorphic encryption that are pushing the boundaries of what's possible in a decentralized world.",
                "sections": [
                    {
                        "title": "Zero-Knowledge Proofs (zk-SNARKs vs. zk-STARKs)",
                        "content": "<p>Zero-Knowledge Proofs (ZKPs) allow one to prove knowledge of a secret without revealing the secret itself. They are a cornerstone of blockchain privacy and scaling.</p><h3>zk-SNARKs (Succinct Non-Interactive Argument of Knowledge):</h3><ul><li><strong>Succinct:</strong> The proofs are very small and quick to verify.</li><li><strong>Non-Interactive:</strong> The prover and verifier do not need to exchange messages back and forth.</li><li><strong>Drawback:</strong> Requires a 'trusted setup'. This is a cryptographic ceremony to generate a public parameter. If the secret data used in this ceremony is not destroyed, it could be used to create fake proofs.</li></ul><h3>zk-STARKs (Scalable Transparent Argument of Knowledge):</h3><ul><li><strong>Scalable:</strong> Proof generation and verification scales quasi-linearly with the complexity of the computation, which is better for very large computations.</li><li><strong>Transparent:</strong> Does not require a trusted setup, removing a significant trust assumption.</li><li><strong>Drawback:</strong> Proof sizes are much larger than SNARKs, making them more expensive to store and verify on-chain. They are also a newer technology.</li></ul>",
                        
                    },
                    {
                        "title": "Multi-Party Computation (MPC)",
                        "content": "<p>MPC is a cryptographic technique that allows multiple parties to jointly compute a function over their inputs, while keeping those inputs private. In the context of blockchain security, MPC is most often used for private key management.</p><p>Instead of a single private key being held by one person or device, the key is generated in pieces ('shares') held by multiple, non-trusting parties. To sign a transaction, a quorum of these parties must cooperate using an interactive protocol. The full private key is never reconstructed in a single place at any point, not even during key generation or signing.</p><div class='info-box tip'><div class='info-box-header'><i class='fas fa-lightbulb'></i><strong>MPC vs. Multi-Sig</strong></div><p>While similar in goal, MPC and multi-sig are different. Multi-sig is an on-chain solution that requires multiple signatures visible on the blockchain. MPC is an off-chain cryptographic protocol that produces a single standard signature, making it cheaper, faster, and more private as it looks like a normal transaction on-chain.</p></div>",
                        "image": "https://a.storyblok.com/f/136336/1774x1086/8732f1d97b/frame-58.png"
                    },
                    {
                        "title": "Verifiable Delay Functions (VDFs)",
                        "content": "<p>A VDF is a function that takes a certain, pre-defined amount of sequential time to compute, even on a parallel computer, but produces a unique output that can be very quickly verified by anyone.</p><p>VDFs are crucial for generating trustworthy, un-biasable randomness on a blockchain. Because the computation takes a known amount of time, a block producer cannot compute the VDF's output ahead of time and cannot influence the result to their benefit. This is a key component in the design of some modern Proof-of-Stake consensus mechanisms (like Ethereum's) to ensure fair validator selection.</p>",
                        
                    }
                ],
                "codeExamples": []
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is a major advantage of zk-STARKs over zk-SNARKs?",
                        "options": [
                            "They have smaller proof sizes.",
                            "They do not require a trusted setup ceremony.",
                            "They are faster to verify on-chain.",
                            "They are an older, more established technology."
                        ],
                        "correct": 1,
                        "explanation": "The lack of a trusted setup makes zk-STARKs 'transparent' and removes a significant security and trust assumption present in most zk-SNARK systems."
                    },
                    {
                        "id": 2,
                        "question": "How does Multi-Party Computation (MPC) improve private key security?",
                        "options": [
                            "It encrypts the private key.",
                            "It creates multiple backup copies of the private key.",
                            "It splits the key into shares held by different parties so the full key is never in one place.",
                            "It stores the private key on the blockchain."
                        ],
                        "correct": 2,
                        "explanation": "MPC ensures that the full key is never constructed, not even during the signing process, thus eliminating the single point of failure of a complete private key."
                    },
                    {
                        "id": 3,
                        "question": "What is the primary use case for Verifiable Delay Functions (VDFs) in blockchain?",
                        "options": [
                            "To speed up transaction processing",
                            "To generate provably unbiased randomness for things like validator selection",
                            "To encrypt communication between nodes",
                            "To create private transactions"
                        ],
                        "correct": 1,
                        "explanation": "VDFs provide a source of randomness that cannot be predicted or influenced by miners/validators, which is crucial for fair and secure protocol operations."
                    }
                ]
            }
        },
        {
            "id": "lesson-23",
            "title": "Blockchain Forensics and Investigation",
            "duration": "75 min",
            "objectives": [
                "Understand transaction graph analysis techniques",
                "Learn about address clustering algorithms",
                "Explore the capabilities of blockchain intelligence tools",
                "Describe criminal investigation methodologies in a blockchain context",
                "Recognize the importance of evidence preservation and chain of custody"
            ],
            "content": {
                "overview": "The transparent nature of most blockchains creates a permanent, public record of all transactions. This has given rise to the field of blockchain forensics, where investigators use specialized tools and techniques to trace the flow of illicit funds, deanonymize threat actors, and combat crypto-related crime.",
                "sections": [
                    {
                        "title": "Transaction Graph Analysis",
                        "content": "<p>Every transaction on a public blockchain can be viewed as a link between addresses in a massive graph. Transaction graph analysis is the process of mapping and analyzing these connections to follow the money trail.</p><p>Investigators start with a known address (e.g., from a ransomware attack) and trace its inputs and outputs. They look for patterns, such as funds moving through mixers, being consolidated into a single address, or being sent to a centralized exchange where the identity of the owner might be known through KYC records.</p>",
                        
                    },
                    {
                        "title": "Address Clustering and Heuristics",
                        "content": "<p>A single user or entity often controls multiple addresses. <strong>Address clustering</strong> is the process of using heuristics to group different addresses that are likely controlled by the same entity.</p><h3>Common Heuristics:</h3><ul><li><strong>Co-spending:</strong> If multiple addresses (UTXOs in Bitcoin) are used as inputs to the same transaction, it is almost certain they are all controlled by the same wallet/user. This is the most powerful clustering heuristic.</li><li><strong>Change Address Patterns:</strong> Identifying the 'change' address in a transaction can link it to the sender's cluster.</li></ul><p>By clustering addresses, investigators can get a much clearer picture of an entity's total holdings and financial activity, rather than just looking at isolated addresses.</p>",
                        "image": "https://ietresearch.onlinelibrary.wiley.com/cms/asset/8d4bbfaa-4b13-4b05-9dc2-0bae48621dd0/blc212014-fig-0001-m.jpg"
                    },
                    {
                        "title": "Blockchain Intelligence Tools",
                        "content": "<p>Performing this analysis manually is incredibly difficult. Specialized blockchain intelligence firms have developed sophisticated platforms that automate this process.</p><h3>Tools like Chainalysis, Elliptic, and TRM Labs provide:</h3><ul><li><strong>Transaction Visualization:</strong> Tools to visually map the flow of funds.</li><li><strong>Risk Scoring:</strong> Automatically assigning a risk score to addresses based on their transaction history (e.g., links to darknet markets, sanctioned entities, or scams).</li><li><strong>Entity Labeling:</strong> Maintaining a massive database that labels addresses belonging to known entities like exchanges, mixers, and criminal groups.</li><li><strong>Real-time Monitoring:</strong> Alerting services for when funds move from a monitored address.</li></ul><p>These tools are used extensively by law enforcement, regulators, and financial institutions to ensure compliance and investigate criminal activity.</p>",
                       
                    }
                ],
                "codeExamples": []
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the most powerful and reliable heuristic used for address clustering?",
                        "options": [
                            "Identifying addresses with similar transaction amounts",
                            "The co-spending heuristic (multiple addresses used as inputs in a single transaction)",
                            "Analyzing the timestamp of transactions",
                            "Guessing based on address format"
                        ],
                        "correct": 1,
                        "explanation": "To create a transaction that spends from multiple addresses, one must possess the private keys for all of them, providing very strong evidence that they are controlled by the same entity."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary goal of transaction graph analysis in a forensic investigation?",
                        "options": [
                            "To measure the speed of the network",
                            "To trace the flow of funds from a starting address to its ultimate destination",
                            "To find bugs in smart contracts",
                            "To calculate the total supply of a cryptocurrency"
                        ],
                        "correct": 1,
                        "explanation": "Investigators use the public ledger to follow the money, identifying associated addresses and looking for off-ramps like exchanges where the suspect's identity might be revealed."
                    },
                    {
                        "id": 3,
                        "question": "Blockchain intelligence firms like Chainalysis provide what kind of service?",
                        "options": [
                            "They build new blockchains.",
                            "They offer cryptocurrency wallets.",
                            "They provide tools for transaction monitoring, risk scoring, and tracing illicit funds.",
                            "They conduct smart contract audits."
                        ],
                        "correct": 2,
                        "explanation": "These firms specialize in analyzing public blockchain data to help law enforcement and financial institutions with compliance and criminal investigations."
                    }
                ]
            }
        },
        {
            "id": "lesson-24",
            "title": "Supply Chain Security on Blockchain",
            "duration": "60 min",
            "objectives": [
                "Understand how blockchain can be used for supply chain traceability",
                "Learn about provenance verification mechanisms",
                "Recognize the security challenges of integrating IoT devices",
                "Analyze how blockchain can be used for anti-counterfeiting",
                "Describe the complexities of multi-party supply chain protocols"
            ],
            "content": {
                "overview": "Blockchain offers a compelling solution to long-standing problems in supply chain management by providing a shared, immutable ledger for tracking goods from origin to consumer. This lesson explores the security benefits of blockchain in this domain, as well as the unique challenges, such as ensuring the data entered onto the blockchain is accurate in the first place.",
                "sections": [
                    {
                        "title": "Traceability and Provenance Verification",
                        "content": "<p>A blockchain can serve as a single, trusted source of truth for all participants in a supply chain (e.g., farmers, manufacturers, shippers, retailers). At each step of the journey, a product's status, location, and custody can be recorded as a transaction on the blockchain.</p><h3>Benefits:</h3><ul><li><strong>Transparency:</strong> All authorized parties can view the same data, reducing disputes.</li><li><strong>Immutability:</strong> Once a record is added, it cannot be altered, preventing fraud.</li><li><strong>Provenance:</strong> Consumers can scan a QR code on a product to see its entire journey, verifying its authenticity and origin (e.g., confirming that a coffee is 'fair trade' or a drug is not counterfeit).</li></ul>",
                       
                    },
                    {
                        "title": "IoT Integration Security",
                        "content": "<p>To automate data collection in a supply chain, companies often use Internet of Things (IoT) devices, such as GPS trackers, temperature sensors, or RFID scanners. These devices can automatically broadcast data to be recorded on the blockchain.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>The Oracle Problem for Physical Goods</strong></div><p>This introduces a critical security challenge often called the 'garbage in, garbage out' problem. The blockchain can guarantee that the data, once recorded, is immutable. But it cannot guarantee that the data was correct to begin with. If an IoT sensor is hacked or tampered with, it will faithfully record fraudulent data onto the immutable ledger. Securing the physical devices and ensuring data integrity *before* it gets on-chain is the most significant challenge.</p></div>",
                        "image": "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRUD6HDMUsLqUf4eucbZ8hJAcNC6npd10F11Q&s"
                    },
                    {
                        "title": "Anti-Counterfeiting Solutions",
                        "content": "<p>Blockchain is a powerful tool against counterfeit goods, especially for high-value items like luxury goods, pharmaceuticals, and electronics.</p><h3>How it Works:</h3><ol><li>A manufacturer creates a unique digital identity (e.g., an NFT) for each physical item, linked via a secure QR code or NFC chip.</li><li>The ownership of this digital token is recorded on the blockchain at the time of creation.</li><li>Every time the physical item changes hands (e.g., from manufacturer to distributor to retailer), the corresponding digital token is transferred on the blockchain.</li><li>A consumer can verify the authenticity of the item by checking the history of its digital twin on the blockchain, ensuring it originated from the legitimate manufacturer.</li></ol>",
                        
                    }
                ],
                "codeExamples": []
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary benefit of using a blockchain in a supply chain?",
                        "options": [
                            "It makes shipping faster.",
                            "It reduces the cost of goods.",
                            "It provides a shared, immutable record for enhanced transparency and traceability.",
                            "It eliminates the need for human workers."
                        ],
                        "correct": 2,
                        "explanation": "By creating a single, unchangeable ledger that all parties can see and trust, blockchain can drastically reduce fraud, errors, and disputes in a supply chain."
                    },
                    {
                        "id": 2,
                        "question": "What is the main security challenge when integrating IoT devices with a supply chain blockchain?",
                        "options": [
                            "The blockchain running out of storage space.",
                            "The 'garbage in, garbage out' problem; ensuring the data from physical sensors is accurate before it's recorded.",
                            "The high energy consumption of IoT devices.",
                            "The slow speed of blockchain transactions."
                        ],
                        "correct": 1,
                        "explanation": "This is a form of the 'Oracle Problem'. The blockchain cannot verify the authenticity of real-world data, so if a sensor is compromised, the immutable ledger will be permanently corrupted with false information."
                    },
                    {
                        "id": 3,
                        "question": "How can blockchain help combat counterfeit products?",
                        "options": [
                            "By making counterfeit products more expensive to produce.",
                            "By creating a unique, verifiable digital identity (like an NFT) for each physical product.",
                            "By automatically detecting and destroying counterfeit goods.",
                            "By making all supply chain data private."
                        ],
                        "correct": 1,
                        "explanation": "By linking a physical item to a unique digital token on the blockchain, anyone can verify the item's origin and ownership history, making it easy to spot fakes."
                    }
                ]
            }
        },
        {
            "id": "lesson-25",
            "title": "Identity and Authentication Security",
            "duration": "75 min",
            "objectives": [
                "Understand the principles of Self-Sovereign Identity (SSI)",
                "Learn about Decentralized Identifiers (DIDs)",
                "Describe how Verifiable Credentials work",
                "Analyze the security of biometric authentication on the blockchain",
                "Explore secure identity recovery mechanisms"
            ],
            "content": {
                "overview": "Traditional digital identity is fragmented and controlled by third parties, leading to security risks and a poor user experience. Blockchain technology enables a new paradigm called Self-Sovereign Identity (SSI), where individuals have ultimate control over their own digital identities. This lesson explores the core components of SSI, including DIDs and Verifiable Credentials.",
                "sections": [
                    {
                        "title": "Self-Sovereign Identity (SSI)",
                        "content": "<p>SSI is a model for digital identity that puts the user in control. Instead of relying on centralized identity providers (like Google or Facebook) who can revoke access or misuse data, an individual's identity is self-managed and independent of any single organization.</p><h3>The 10 Principles of SSI include:</h3><ul><li><strong>Existence:</strong> Users must have an independent existence.</li><li><strong>Control:</strong> Users must control their identities.</li><li><strong>Access:</strong> Users must have access to their own data.</li><li><strong>Transparency:</strong> The systems and algorithms must be transparent.</li><li><strong>Persistence:</strong> Identities should be long-lived.</li><li><strong>Portability:</strong> Information and services about identity must be transportable.</li></ul>",
                        
                    },
                    {
                        "title": "Decentralized Identifiers (DIDs)",
                        "content": "<p>A DID is a new type of globally unique identifier that is created and controlled by an individual or organization, independent of any centralized registry. A DID is like a phone number that you own and control forever, which can't be taken away by a phone company.</p><p>A DID (e.g., <code>did:example:123456789abcdefghi</code>) can be resolved to a 'DID Document'. This is a JSON file that contains the public keys associated with the DID, service endpoints, and other metadata. This allows others to look up the DID, find the correct public key, and securely communicate or verify signatures from the DID's owner.</p>",
                        "image": "https://i.ytimg.com/vi/vVN5YjU0eBw/maxresdefault.jpg"
                    },
                    {
                        "title": "Verifiable Credentials",
                        "content": "<p>Verifiable Credentials (VCs) are tamper-proof digital credentials that can be cryptographically verified. They allow individuals to prove things about themselves (like their age, qualifications, or nationality) without revealing unnecessary personal data.</p><h3>The SSI Triangle:</h3><ol><li><strong>Issuer:</strong> An entity (e.g., a university) issues a credential (a diploma) to a user. This credential is a set of claims digitally signed by the issuer.</li><li><strong>Holder:</strong> The user (the graduate) stores this VC in their private digital wallet.</li><li><strong>Verifier:</strong> The user can present this VC to a verifier (e.g., an employer). The verifier can cryptographically check the issuer's digital signature to confirm the credential is authentic, without needing to contact the issuer directly.</li></ol><div class='info-box tip'><div class='info-box-header'><i class='fas fa-lightbulb'></i><strong>Selective Disclosure</strong></div><p>Using Zero-Knowledge Proofs, a user could present a VC from the DMV to a bar to prove they are over 21, without revealing their name, address, or actual date of birth. This is a huge improvement for privacy.</p></div>",
                        
                    }
                ],
                "codeExamples": []
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the core principle of Self-Sovereign Identity (SSI)?",
                        "options": [
                            "All identity data should be stored on a single, secure government blockchain.",
                            "Individuals should have ultimate control over their own digital identity.",
                            "Companies should be responsible for securing user data.",
                            "Identity should be completely anonymous."
                        ],
                        "correct": 1,
                        "explanation": "SSI is a paradigm shift that moves away from centralized identity providers to a user-centric model where the individual owns and controls their identity data."
                    },
                    {
                        "id": 2,
                        "question": "What is a Decentralized Identifier (DID)?",
                        "options": [
                            "A user's public address on a blockchain.",
                            "A type of cryptocurrency.",
                            "A globally unique identifier that is controlled by the user, not a central authority.",
                            "A smart contract for managing identity."
                        ],
                        "correct": 2,
                        "explanation": "A DID is like a permanent, self-owned phone number for the digital world, which can be used to look up the public keys and other information needed to interact with the DID's owner."
                    },
                    {
                        "id": 3,
                        "question": "In the Verifiable Credential model, who is the 'Issuer'?",
                        "options": [
                            "The person who wants to verify a claim.",
                            "The person who holds the credential in their digital wallet.",
                            "The trusted entity that attests to a claim and issues the digital credential.",
                            "The blockchain that stores the credential."
                        ],
                        "correct": 2,
                        "explanation": "The Issuer is the authority that creates the credential. For example, a university is the Issuer of a diploma, and the government is the Issuer of a driver's license."
                },
              ],
            },
          },
          
        {
            "id": "lesson-26",
            "title": "Insurance and Risk Management",
            "duration": "60 min",
            "objectives": [
                "Understand the architecture of blockchain-based insurance protocols",
                "Learn how parametric insurance smart contracts work",
                "Explore risk assessment frameworks for DeFi",
                "Analyze the automation of claims processing",
                "Recognize security models for insurance pool management"
            ],
            "content": {
                "overview": "Blockchain technology is poised to revolutionize the insurance industry by enabling transparent, automated, and efficient risk management. This lesson explores the rise of decentralized insurance, focusing on parametric products, automated claims, and the security challenges of managing risk pools with smart contracts.",
                "sections": [
                    {
                        "title": "Parametric Insurance Smart Contracts",
                        "content": "<p>Traditional insurance involves lengthy and subjective claims processing. <strong>Parametric insurance</strong> simplifies this by paying out automatically based on a predefined, verifiable trigger event, rather than the magnitude of a loss.</p><p>For example, a crop insurance smart contract could automatically pay out to a farmer if a trusted oracle reports that rainfall in their region was below a certain threshold. The smart contract logic is simple: <code>if (trigger_event == true) { pay_claim() }</code>. This reduces administrative overhead and eliminates claim disputes.</p>",
                        
                    },
                    {
                        "title": "Risk Assessment and Claims Automation",
                        "content": "<p>DeFi insurance protocols allow users to buy coverage for specific risks, most commonly smart contract failure or stablecoin de-pegging. The premiums are often determined by a dynamic risk assessment model.</p><h3>Key Components:</h3><ul><li><strong>Risk Pooling:</strong> Users who want to earn yield can deposit capital into insurance pools, effectively acting as the underwriters.</li><li><strong>Dynamic Pricing:</strong> Premiums can be adjusted in real-time based on supply (capital in the pool) and demand (amount of coverage purchased).</li><li><strong>Claims Adjudication:</strong> When an event occurs, a claim is filed. The validity of the claim is typically decided by a vote of the protocol's governance token holders or a dedicated claims assessment DAO.</li></ul>",
                        "image": "https://www.zengrc.com/wp-content/uploads/2024/09/Risk-Management-Process-For-Insurance-Companies-1.png"
                    },
                    {
                        "title": "Security Risks in Decentralized Insurance",
                        "content": "<p>While innovative, these protocols have unique security challenges.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Key Vulnerabilities</strong></div><p><ul><li><strong>Oracle Manipulation:</strong> For parametric insurance, the entire system's integrity rests on the security of the oracle providing the trigger data.</li><li><strong>Claims Governance Attacks:</strong> Malicious actors could attempt to manipulate the claims voting process to approve fraudulent claims or deny legitimate ones.</li><li><strong>Capital Pool Exploits:</strong> The smart contracts managing the underwriting pools are a honeypot for hackers. A standard smart contract vulnerability could lead to a total loss of underwriter capital.</li></ul></p></div>",
                        
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the key feature of parametric insurance?",
                        "options": [
                            "It covers all possible risks.",
                            "It pays out based on the actual financial loss incurred.",
                            "It pays out a predetermined amount automatically when a specific, verifiable event occurs.",
                            "It is managed by a centralized insurance company."
                        ],
                        "correct": 2,
                        "explanation": "Parametric insurance is triggered by a specific parameter or event (e.g., hurricane wind speed, earthquake magnitude) reported by an oracle, which allows for instant and automated payouts."
                    },
                    {
                        "id": 2,
                        "question": "What is the most critical security component for a parametric crop insurance smart contract?",
                        "options": [
                            "The user interface",
                            "The governance token price",
                            "The security and reliability of the weather data oracle",
                            "The speed of the blockchain"
                        ],
                        "correct": 2,
                        "explanation": "The entire system relies on the integrity of the external data. If the oracle can be manipulated to report false weather data, the insurance contract can be wrongfully triggered or prevented from paying out."
                    },
                    {
                        "id": 3,
                        "question": "In a decentralized insurance protocol, what is a primary risk for capital providers in an underwriting pool?",
                        "options": [
                            "Forgetting their password.",
                            "Smart contract vulnerabilities that could lead to the loss of their deposited capital.",
                            "The protocol's website going down.",
                            "High transaction fees."
                        ],
                        "correct": 1,
                        "explanation": "Underwriters deposit their funds into smart contracts. Any bug or exploit in those contracts could allow an attacker to drain the entire pool, causing a total loss for the capital providers."
                    }
                ]
            }
        },
        {
            "id": "lesson-27",
            "title": "Gaming and Virtual Asset Security",
            "duration": "75 min",
            "objectives": [
                "Understand the security models of blockchain gaming",
                "Learn about virtual asset ownership verification using NFTs",
                "Analyze the security of in-game economies",
                "Recognize vulnerabilities in play-to-earn (P2E) mechanisms",
                "Explore the security of virtual world governance"
            ],
            "content": {
                "overview": "Blockchain is transforming the gaming industry by enabling true ownership of in-game assets and creating player-driven economies. This lesson explores the security architecture of Web3 games, the use of NFTs for virtual assets, and the unique economic and smart contract risks associated with play-to-earn models.",
                "sections": [
                    {
                        "title": "Virtual Asset Ownership via NFTs",
                        "content": "<p>In traditional games, the items you acquire (e.g., skins, weapons, characters) are stored on the game company's servers, and you don't truly own them. Blockchain games use NFTs to represent these in-game assets.</p><h3>Benefits of using NFTs:</h3><ul><li><strong>True Ownership:</strong> The asset is in your wallet, and you can hold, sell, or trade it on any NFT marketplace, even outside of the game itself.</li><li><strong>Interoperability:</strong> In the future, an NFT from one game might be usable in another, creating a persistent digital identity.</li><li><strong>Provable Scarcity:</strong> The blockchain provides a transparent record of how many of a particular item exist, preventing developers from arbitrarily changing its rarity.</li></ul>",
                        
                    },
                    {
                        "title": "In-Game Economy Security",
                        "content": "<p>Blockchain games often feature complex economies with in-game currencies (fungible tokens) and assets (NFTs). Securing this economy is vital.</p><h3>Economic Exploits:</h3><ul><li><strong>Inflation Bugs:</strong> A flaw in a smart contract could allow an attacker to mint an infinite amount of the in-game currency or a rare item, destroying the economy.</li><li><strong>Oracle Manipulation:</strong> If the game relies on oracles for any mechanic (e.g., generating random loot), manipulating the oracle could lead to unfair advantages.</li><li><strong>Botting:</strong> Automated bots can be used to farm resources or currency 24/7, which can unbalance the economy and devalue the assets for legitimate players.</li></ul>",
                        "image": "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQ-WeLP6i03fPxyZfjeMS4Cb6R3_ZUFcGP7LQ&s"
                    },
                    {
                        "title": "Play-to-Earn (P2E) Mechanism Security",
                        "content": "<p>P2E games reward players with cryptocurrency or NFTs for their activity in the game. This model creates a direct financial incentive for players, but also for hackers.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Bridge Exploits</strong></div><p>A very common and devastating attack vector for P2E games is the cross-chain bridge. Many games operate on a custom, high-speed blockchain or sidechain for a better user experience, and use a bridge to connect to a main blockchain like Ethereum. These bridges often become massive honeypots and are frequent targets of hackers, as seen in the Ronin Bridge hack associated with the game Axie Infinity.</p></div>",
                       
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary benefit of using NFTs to represent in-game assets?",
                        "options": [
                            "It makes the game run faster.",
                            "It provides players with true, verifiable ownership of their assets.",
                            "It lowers the cost of developing the game.",
                            "It allows developers to create more items."
                        ],
                        "correct": 1,
                        "explanation": "NFTs give players self-custody over their in-game items, allowing them to be freely traded on open markets and removing the risk of the game developer arbitrarily taking them away."
                    },
                    {
                        "id": 2,
                        "question": "What is a major economic security risk in a blockchain game?",
                        "options": [
                            "The game's graphics becoming outdated.",
                            "A bug that allows players to mint unlimited amounts of the in-game currency.",
                            "The game having a boring storyline.",
                            "Too many players joining the game at once."
                        ],
                        "correct": 1,
                        "explanation": "An inflation bug can instantly destroy the in-game economy by making the currency worthless, which is a critical risk in play-to-earn models where assets have real-world value."
                    },
                    {
                        "id": 3,
                        "question": "For play-to-earn games that use their own sidechain, what has historically been one of the most vulnerable components?",
                        "options": [
                            "The game's mobile app",
                            "The player leaderboard",
                            "The cross-chain bridge connecting the sidechain to a mainnet like Ethereum",
                            "The in-game chat system"
                        ],
                        "correct": 2,
                        "explanation": "Cross-chain bridges for games often secure hundreds of millions of dollars in assets, and their technical complexity makes them a prime target for hackers, leading to some of the largest exploits in history."
                    }
                ]
            }
        },
        {
            "id": "lesson-28",
            "title": "Central Bank Digital Currencies (CBDC)",
            "duration": "60 min",
            "objectives": [
                "Understand different CBDC architectures and security models",
                "Analyze the privacy vs. surveillance trade-offs",
                "Learn about the security challenges of offline payments",
                "Recognize the importance of interoperability with existing financial systems",
                "Describe how monetary policy could be implemented with a CBDC"
            ],
            "content": {
                "overview": "Central Bank Digital Currencies are a digital form of a country's fiat currency that is a direct liability of the central bank. This lesson explores the motivations behind CBDCs, the different technological models being considered, and the profound security, privacy, and policy challenges they present.",
                "sections": [
                    {
                        "title": "CBDC Architecture and Security Models",
                        "content": "<p>CBDCs are not cryptocurrencies like Bitcoin. They are centralized, permissioned systems controlled by a monetary authority. There are several proposed models:</p><ul><li><strong>Retail CBDC:</strong> A digital currency for use by the general public, like a digital version of cash. This can be 'direct' (accounts held at the central bank) or 'indirect' (accounts managed by commercial banks).</li><li><strong>Wholesale CBDC:</strong> A CBDC for use only by commercial banks and other financial institutions for interbank settlement.</li></ul><p>The underlying technology could be a centralized database or a permissioned distributed ledger (blockchain), chosen to meet policy goals for security, resilience, and scalability.</p>",
                        
                    },
                    {
                        "title": "Privacy vs. Surveillance Trade-offs",
                        "content": "<p>Physical cash offers a high degree of privacy. A CBDC, being digital, creates a permanent record of all transactions. This presents a major societal trade-off.</p><h3>The Spectrum of Privacy:</h3><ul><li><strong>Full Anonymity:</strong> Unlikely, as it would hinder law enforcement's ability to combat money laundering and illicit financing.</li><li><strong>Full Surveillance:</strong> Every transaction is visible to the government in real-time. This raises significant concerns about state surveillance and control.</li><li><strong>Privacy-Preserving Models:</strong> A balance can be sought using cryptographic techniques like Zero-Knowledge Proofs or tiered anonymity (e.g., small transactions are private, but larger ones require identity verification).</li></ul>",
                        "image": "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcS_vbFWDf1tyKdbVknCHhkgj4qvpnNpBEH_kA&s"
                    },
                    {
                        "title": "Programmable Money and Monetary Policy",
                        "content": "<p>A CBDC could enable 'programmable money', where rules are attached to the currency itself.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Policy and Security Implications</strong></div><p>A central bank could implement monetary policy directly. For example, stimulus payments could be programmed to only be spendable on certain goods or to expire after a certain date. While potentially powerful for policy, this also introduces new security risks. A bug in the programmability features could have catastrophic consequences for the national economy. It also raises profound questions about financial freedom and control.</p></div>",
                        
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the key difference between a CBDC and a cryptocurrency like Bitcoin?",
                        "options": [
                            "CBDCs are digital, while Bitcoin is physical.",
                            "CBDCs are centralized and controlled by a central bank, while Bitcoin is decentralized.",
                            "CBDCs are less secure than Bitcoin.",
                            "There is no difference."
                        ],
                        "correct": 1,
                        "explanation": "The defining characteristic of a CBDC is that it is a direct liability of a central authority (the central bank), making it a centralized system, in direct contrast to the decentralized nature of cryptocurrencies."
                    },
                    {
                        "id": 2,
                        "question": "What is the main societal challenge presented by the design of a retail CBDC?",
                        "options": [
                            "The speed of transactions.",
                            "The high cost of development.",
                            "The trade-off between user privacy and the government's ability to monitor transactions.",
                            "The environmental impact."
                        ],
                        "correct": 2,
                        "explanation": "Unlike physical cash, a digital currency leaves a trail. Designing a system that respects user privacy while still allowing for legitimate law enforcement is one of the most significant and debated challenges of CBDCs."
                    },
                    {
                        "id": 3,
                        "question": "What is meant by 'programmable money' in the context of a CBDC?",
                        "options": [
                            "The ability for anyone to write smart contracts on the CBDC platform.",
                            "The ability for the central authority to embed rules into the currency itself, such as an expiration date.",
                            "The source code of the CBDC is open source.",
                            "The CBDC can be used to pay for programming services."
                        ],
                        "correct": 1,
                        "explanation": "Programmability would give the central bank fine-grained control over how the currency is used, allowing for direct implementation of monetary policy, but also raising major security and social concerns."
                    }
                ]
            }
        },
        {
            "id": "lesson-29",
            "title": "Blockchain Infrastructure Security",
            "duration": "75 min",
            "objectives": [
                "Learn best practices for node security and hardening",
                "Understand the unique security requirements of validator infrastructure",
                "Analyze the risks of cloud deployment for blockchain nodes",
                "Describe disaster recovery and business continuity procedures",
                "Explore the role of infrastructure monitoring systems"
            ],
            "content": {
                "overview": "Beyond the blockchain protocol itself, the physical and cloud infrastructure that runs the nodes, validators, and APIs is a critical part of the security landscape. This lesson covers the operational security (OpSec) practices required to protect the servers and networks that form the backbone of a blockchain.",
                "sections": [
                    {
                        "title": "Node Security and Hardening",
                        "content": "<p>A full node is a server that stores the entire blockchain history and validates all new transactions and blocks. Securing these nodes is essential for the health of the network.</p><h3>Hardening Best Practices:</h3><ul><li><strong>Minimalist OS:</strong> Run the node on a minimal, hardened Linux server with no unnecessary services or open ports.</li><li><strong>Firewall Configuration:</strong> Use a strict firewall to only allow traffic on the necessary P2P and RPC ports, and only from trusted IP addresses if possible.</li><li><strong>Regular Updates:</strong> Keep the operating system and the node client software constantly updated to patch vulnerabilities.</li><li><strong>Access Control:</strong> Use strong, unique passwords and SSH keys for access, and disable root login.</li></ul>",
                       
                    },
                    {
                        "title": "Validator Infrastructure Security",
                        "content": "<p>Validator nodes in a Proof-of-Stake network have additional, heightened security requirements because they hold keys that sign new blocks and control staked funds. A compromise of a validator can lead to direct financial loss through slashing penalties.</p><h3>Key Security Measures:</h3><ul><li><strong>Sentry Node Architecture:</strong> The validator node itself should not be directly connected to the public internet. It should be in a private network, communicating only with a set of 'sentry nodes' which are publicly connected and act as a protective proxy.</li><li><strong>Key Management:</strong> The validator signing keys must be protected at all costs, often using a Hardware Security Module (HSM) or other dedicated key management solution.</li><li><strong>Redundancy and Failover:</strong> Professional validators run backup infrastructure to prevent downtime, as being offline can also lead to penalties.</li></ul>",
                        "image": "https://cpl.thalesgroup.com/sites/default/files/inline-images/blockchain-diagram_1.png"
                    },
                    {
                        "title": "Infrastructure Monitoring and Alerting",
                        "content": "<p>You cannot secure what you cannot see. Comprehensive monitoring is crucial for maintaining the health and security of blockchain infrastructure.</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Key Metrics to Monitor</strong></div><p><ul><li><strong>System Health:</strong> CPU usage, memory, disk space, and network I/O.</li><li><strong>Node Health:</strong> Block height (to detect if the node is stuck or on a fork), number of peers, and mempool size.</li><li><strong>Validator Performance:</strong> Missed blocks, slashing events, and rewards earned.</li><li><strong>Security Events:</strong> Failed login attempts, unusual network traffic, and critical software errors.</li></ul>Alerts should be configured to immediately notify the operations team of any anomalies.</p></div>",
                       
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is a 'sentry node architecture' used for?",
                        "options": [
                            "To store a backup of the blockchain.",
                            "To provide a public API for a dApp.",
                            "To protect a validator node by isolating it from the public internet.",
                            "To speed up transaction propagation."
                        ],
                        "correct": 2,
                        "explanation": "In this setup, the highly sensitive validator node only communicates with a set of trusted sentry nodes, which in turn connect to the broader P2P network. This shields the validator from direct network attacks."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary reason for heightened security on a PoS validator node compared to a regular full node?",
                        "options": [
                            "Validators store more of the blockchain history.",
                            "Validators consume more electricity.",
                            "Validators hold active signing keys, and their compromise or downtime can lead to direct financial penalties (slashing).",
                            "Validators are more likely to be targeted by phishing attacks."
                        ],
                        "correct": 2,
                        "explanation": "The active role of validators in proposing and signing blocks, backed by a financial stake, means their operational security is directly tied to financial outcomes, unlike a passive full node."
                    },
                    {
                        "id": 3,
                        "question": "In the context of infrastructure monitoring, what does checking the 'block height' of a node help you detect?",
                        "options": [
                            "How many transactions are in a block.",
                            "The current market price of the cryptocurrency.",
                            "If the node is correctly synchronized with the rest of the network.",
                            "The amount of disk space the blockchain is using."
                        ],
                        "correct": 2,
                        "explanation": "If a node's block height stops increasing or falls significantly behind the global block height, it's a clear indicator that the node is stuck, has a connectivity issue, or is on an incorrect fork."
                    }
                ]
            }
        },
        {
            "id": "lesson-30",
            "title": "Smart Contract Upgradeability Security",
            "duration": "75 min",
            "objectives": [
                "Perform a security analysis of various proxy patterns (e.g., Transparent, UUPS)",
                "Identify common vulnerabilities in upgrade mechanisms",
                "Understand the role of governance in controlling upgrades",
                "Analyze the function of emergency pause mechanisms",
                "Recognize the risks of version control and rollback"
            ],
            "content": {
                "overview": "While code immutability is a core feature of blockchain, it also means that bugs can't be fixed. Upgradeability patterns, especially proxies, have emerged as a solution, but they introduce new layers of complexity and significant security risks. This lesson provides a deep dive into how to securely manage the lifecycle of a smart contract.",
                "sections": [
                    {
                        "title": "Proxy Pattern Security Analysis",
                        "content": "<p>Proxy patterns separate a contract's state from its logic. A proxy contract holds the state and delegates all calls to a logic contract. An upgrade is performed by telling the proxy to point to a new logic contract.</p><h3>Common Vulnerabilities:</h3><ul><li><strong>Function Clashing:</strong> If a function in the proxy contract has the same signature as a function in the logic contract, the proxy's function might be called instead of the intended one. This is addressed by the Transparent Proxy Pattern (TPP).</li><li><strong>Storage Collisions:</strong> If the new logic contract doesn't have the exact same storage layout as the old one, the state can become corrupted. Variables can be overwritten or read incorrectly.</li><li><strong>Uninitialized Implementation:</strong> An attacker could find an uninitialized implementation contract, call its `initialize` function to take ownership of it, and then execute a `selfdestruct`, bricking the proxy.</li></ul>",
                       
                    },
                    {
                        "title": "Governance-Controlled Upgrades",
                        "content": "<p>Upgradeability introduces a powerful admin role. Who gets to be the admin? A single developer EOA (Externally Owned Account) is a huge centralization risk. Best practice is to hand over control of the upgrade process to a decentralized governance mechanism.</p><h3>Secure Upgrade Process:</h3><ol><li>A proposal to upgrade to a new implementation contract is submitted to the DAO.</li><li>Governance token holders vote on the proposal.</li><li>If the vote passes, the call to upgrade the proxy is sent to a Time-lock contract.</li><li>After a mandatory delay (e.g., 48 hours), the upgrade can be executed.</li></ol><p>This process ensures that upgrades are subject to community approval and gives users time to react if a malicious upgrade is passed.</p>",
                        "image": "https://www.coinspect.com/_astro/upgradeable-smart-contract-diagram-transparent.BzZEiXa8_1cJRCe.webp"
                    },
                    {
                        "title": "Emergency Pause Mechanisms",
                        "content": "<p>Many protocols include an 'emergency pause' or 'circuit breaker' function. This allows a designated admin (ideally a multi-sig or the DAO) to temporarily halt the core functions of the protocol in the event of a live exploit.</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>A Double-Edged Sword</strong></div><p>While a pause function can be a lifesaver during a hack, it also represents a significant centralization risk. The entity that can pause the contract can effectively censor users at will. The powers of this role must be clearly communicated to users and should be as limited as possible (e.g., can only pause, not unpause, with unpausing requiring a full governance vote).</p></div>",
                  
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is a 'storage collision' in the context of upgrading a proxy contract?",
                        "options": [
                            "Two users trying to write to the same variable at the same time.",
                            "The proxy contract running out of storage space.",
                            "The new logic contract having a different storage layout, causing state variables to be misinterpreted.",
                            "A bug in the EVM's storage mechanism."
                        ],
                        "correct": 2,
                        "explanation": "Because the proxy holds the state, it's critical that the new logic contract declares its state variables in the exact same order as the old one to avoid data corruption. This is a common and dangerous upgrade bug."
                    },
                    {
                        "id": 2,
                        "question": "What is the best practice for managing the admin role of an upgradeable contract?",
                        "options": [
                            "Give it to the lead developer.",
                            "Burn the admin key so no more upgrades are possible.",
                            "Transfer ownership to a multi-signature wallet or a governance contract with a time-lock.",
                            "Give it to a trusted third-party company."
                        ],
                        "correct": 2,
                        "explanation": "Centralizing the upgrade power in a single person or key is a major security risk. Decentralized control via a DAO or multi-sig ensures that changes require broad consensus."
                    },
                    {
                        "id": 3,
                        "question": "What is the primary purpose of an 'emergency pause' function in a smart contract?",
                        "options": [
                            "To allow the developers to perform server maintenance.",
                            "To temporarily halt critical functions of the contract in case a live hack is discovered.",
                            "To lower gas fees during periods of high network congestion.",
                            "To prevent users from withdrawing their funds."
                        ],
                        "correct": 1,
                        "explanation": "A pause function acts as a circuit breaker, giving the development or security team time to react to an exploit and prevent further fund drainage while a more permanent fix is prepared."
                    }
                ]
            }
        },
        {
            "id": "lesson-31",
            "title": "Flash Loan Security and Applications",
            "duration": "75 min",
            "objectives": [
                "Understand the core mechanics of flash loans",
                "Analyze legitimate use cases like arbitrage and collateral swaps",
                "Deconstruct common flash loan attack patterns",
                "Learn about defense mechanisms against flash loan exploits",
                "Assess the security of building applications that use flash loans"
            ],
            "content": {
                "overview": "Flash loans, which allow for the borrowing of massive amounts of capital with no collateral as long as it's repaid in the same transaction, are a powerful and unique DeFi primitive. This lesson delves into the mechanics of how they work, their legitimate uses, and how they have become the tool of choice for executing complex economic exploits.",
                "sections": [
                    {
                        "title": "Flash Loan Mechanism Analysis",
                        "content": "<p>A flash loan is an 'atomic' transaction. A user can borrow from a lending pool, perform a series of arbitrary actions, and then repay the loan plus a small fee. If the loan is not repaid by the end of the transaction, the blockchain state is reverted as if the transaction never happened.</p><h3>How it's Possible:</h3><p>The lending pool's smart contract makes the loan, calls a function on the borrower's contract, and at the end of that call, checks to ensure it has been repaid. Because this all happens in one transaction, there is zero risk for the lender. The lender either gets their money back with a fee, or the transaction fails and they never lost their money in the first place.</p>",
                       
                    },
                    {
                        "title": "Legitimate Use Cases",
                        "content": "<p>While notorious for their use in hacks, flash loans have many legitimate and capital-efficient applications.</p><h3>Examples:</h3><ul><li><strong>Arbitrage:</strong> If a token is trading for $1.00 on Uniswap and $1.02 on Sushiswap, an arbitrageur can use a flash loan to borrow millions, buy the token on Uniswap, sell it on Sushiswap, repay the loan, and pocket the difference, all with zero upfront capital.</li><li><strong>Collateral Swaps:</strong> A user has a loan on Compound collateralized with ETH, but wants to switch their collateral to WBTC without selling their ETH. They can use a flash loan to pay back the loan, withdraw their ETH, deposit WBTC, take out a new loan, and repay the flash loan.</li><li><strong>Liquidations:</strong> Quickly liquidating undercollateralized positions.</li></ul>",
                        "image": "https://www.mdpi.com/applsci/applsci-14-06361/article_deploy/html/images/applsci-14-06361-g001.png"
                    },
                    {
                        "title": "Defense Against Flash Loan Attacks",
                        "content": "<p>Flash loan attacks don't break the flash loan protocol itself; they exploit vulnerabilities in other protocols that are susceptible to manipulation by large amounts of capital. The key to defense is not to prevent flash loans, but to build resilient applications.</p><div class='info-box tip'><div class='info-box-header'><i class='fas fa-lightbulb'></i><strong>Best Practices</strong></div><p><ul><li><strong>Use Decentralized Oracles:</strong> Do not use a single, on-chain DEX as a price oracle. Use a robust oracle network like Chainlink or a Time-Weighted Average Price (TWAP) oracle, which are resistant to single-transaction manipulation.</li><li><strong>Reentrancy Guards:</strong> While not specific to flash loans, reentrancy is often a component of these complex attacks. Use proper guards.</li><li><strong>Don't Mix Business Logic and Price Calculation:</strong> Protocols should be skeptical of external price data that can change drastically within a single block.</li></ul></p></div>",
                        
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "Why is there no risk for a protocol that provides flash loans?",
                        "options": [
                            "They only lend to trusted users.",
                            "The loan amounts are very small.",
                            "The transaction is atomic; if the loan isn't repaid by the end, the entire transaction is reverted.",
                            "The loans are insured by a third party."
                        ],
                        "correct": 2,
                        "explanation": "The atomicity of blockchain transactions ensures that the lender either gets their funds back plus a fee, or the transaction fails entirely, meaning their funds never left their control in the first place."
                    },
                    {
                        "id": 2,
                        "question": "Which of the following is a legitimate use case for a flash loan?",
                        "options": [
                            "Stealing from a vulnerable protocol.",
                            "Performing arbitrage between two decentralized exchanges with zero upfront capital.",
                            "Manipulating a DAO vote.",
                            "Creating a denial-of-service attack."
                        ],
                        "correct": 1,
                        "explanation": "Arbitrage is a perfect use case for flash loans, as it often requires a large amount of capital to be profitable but the entire sequence of trades can be executed within a single transaction."
                    },
                    {
                        "id": 3,
                        "question": "What is the most effective defense for a DeFi protocol against flash loan-based price manipulation?",
                        "options": [
                            "Blocking addresses that have used flash loans.",
                            "Increasing transaction fees.",
                            "Using a secure, manipulation-resistant price oracle (like a TWAP or Chainlink) instead of a single DEX spot price.",
                            "Pausing the protocol whenever a flash loan is detected."
                        ],
                        "correct": 2,
                        "explanation": "Flash loan attacks almost always exploit a flawed price oracle. By using an oracle that is not susceptible to manipulation within a single transaction, the entire attack vector is closed."
                    }
                ]
            }
        },
        {
            "id": "lesson-32",
            "title": "Blockchain Scaling Security Challenges",
            "duration": "75 min",
            "objectives": [
                "Perform a comparative security analysis of different scaling solutions",
                "Understand the security models of sharding",
                "Revisit state and payment channel network security",
                "Analyze the security trade-offs of modular vs. monolithic blockchain design",
                "Explore the risks of increasing throughput on network decentralization"
            ],
            "content": {
                "overview": "The 'blockchain trilemma' suggests that it's difficult for a blockchain to be simultaneously decentralized, secure, and scalable. This lesson provides a higher-level look at various approaches to scaling, from Layer 1 solutions like sharding to the broader ecosystem of Layer 2s, and analyzes the security trade-offs inherent in each design.",
                "sections": [
                    {
                        "title": "Layer 1 Scaling: Sharding Security Models",
                        "content": "<p>Sharding is a technique to increase Layer 1 scalability by splitting the blockchain's state and transaction processing into smaller, parallel chains called 'shards'. Instead of every node processing every transaction, nodes are assigned to a specific shard.</p><h3>Security Challenges:</h3><ul><li><strong>1% Attack:</strong> If the network is split into 100 shards, an attacker might only need 1% of the total network stake/hashrate to control a single shard and execute fraudulent transactions within it.</li><li><strong>Cross-Shard Communication:</strong> Securely moving assets and data between shards is a complex cryptographic problem. A flaw in this communication protocol could compromise the entire network.</li><li><strong>Random Validator Assignment:</strong> To prevent the 1% attack, validators must be randomly and frequently reassigned to different shards to stop attackers from slowly taking over a single shard. The source of this randomness must be secure.</li></ul>",
                        
                    },
                    {
                        "title": "The Security Spectrum of Scaling Solutions",
                        "content": "<p>Different scaling solutions make different trade-offs between security, decentralization, and performance.</p><ul><li><strong>Monolithic (e.g., Solana):</strong> High-performance Layer 1s achieve scalability by requiring powerful hardware for nodes. This can lead to centralization as fewer people can afford to run a node.</li><li><strong>Rollups (e.g., Arbitrum, zkSync):</strong> These prioritize security by inheriting it from a decentralized L1 like Ethereum. They may make short-term decentralization trade-offs (e.g., using a centralized sequencer) but have a clear path to decentralization.</li><li><strong>Sidechains / Appchains (e.g., Polygon PoS):</strong> These offer high performance and sovereignty but have their own, often smaller and less secure, validator sets. They do not inherit L1 security.</li></ul>",
                        "image": "https://serokell.io/files/a7/a7m7jll.Scalability_in_Blockchain_pic1.jpg"
                    },
                    {
                        "title": "Modular vs. Monolithic Blockchains",
                        "content": "<p>A new paradigm in blockchain design is the 'modular' stack, where the core functions of a blockchain are handled by different, specialized layers.</p><div class='info-box tip'><div class='info-box-header'><i class='fas fa-lightbulb'></i><strong>The Modular Stack</strong></div><p><ul><li><strong>Execution Layer:</strong> Processes transactions (e.g., a rollup).</li><li><strong>Settlement Layer:</strong> Verifies proofs and resolves disputes (e.g., Ethereum).</li><li><strong>Data Availability Layer:</strong> Guarantees that the data for L2 blocks is available for anyone to check (e.g., Ethereum or specialized chains like Celestia).</li><li><strong>Consensus Layer:</strong> Orders transactions (e.g., Ethereum).</li></ul>This modular approach allows for greater specialization and scalability without compromising on the security and decentralization of the base layer. It contrasts with 'monolithic' chains that try to do everything on one layer.</p></div>",
                        
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary security risk of a sharded blockchain?",
                        "options": [
                            "It is too slow.",
                            "It uses too much electricity.",
                            "A single shard could be taken over with a fraction of the total network's hashrate/stake.",
                            "It is not compatible with smart contracts."
                        ],
                        "correct": 2,
                        "explanation": "By dividing the network's validators among many shards, the cost to corrupt a single shard is significantly lower than the cost to corrupt the entire network, a problem that must be mitigated with secure random validator assignment."
                    },
                    {
                        "id": 2,
                        "question": "From a security perspective, what is the key advantage of a rollup over a sidechain?",
                        "options": [
                            "Rollups have lower fees.",
                            "Rollups are faster.",
                            "Rollups inherit the security of their Layer 1 settlement chain (like Ethereum).",
                            "Rollups are easier to develop for."
                        ],
                        "correct": 2,
                        "explanation": "Sidechains are responsible for their own security, while rollups post transaction data to L1, allowing them to rely on the L1's much larger and more secure consensus for safety."
                    },
                    {
                        "id": 3,
                        "question": "In a modular blockchain design, what is the function of the 'Data Availability Layer'?",
                        "options": [
                            "To execute smart contracts.",
                            "To ensure that the data behind Layer 2 transactions is publicly available and cannot be hidden by a malicious operator.",
                            "To provide a user-friendly interface.",
                            "To manage the consensus process."
                        ],
                        "correct": 1,
                        "explanation": "Data availability is crucial for rollups. It guarantees that anyone can access the L2 transaction data to verify the chain's state and challenge fraudulent transactions, preventing the operator from stealing funds."
                    }
                ]
            }
        },
        {
            "id": "lesson-33",
            "title": "Decentralized Storage Security",
            "duration": "60 min",
            "objectives": [
                "Analyze the security model of IPFS (InterPlanetary File System)",
                "Understand the importance of encryption for distributed storage",
                "Recognize the risks of content addressing security",
                "Explore the security of storage provider incentives",
                "Learn about data availability guarantees and proofs"
            ],
            "content": {
                "overview": "Storing large amounts of data on a blockchain is prohibitively expensive. Decentralized storage networks like IPFS and Arweave provide a solution by creating distributed, peer-to-peer networks for data storage and retrieval. This lesson explores their security models, from content addressing to the crypto-economic incentives that ensure your data remains available and secure.",
                "sections": [
                    {
                        "title": "IPFS Security Model Analysis",
                        "content": "<p>IPFS is a peer-to-peer hypermedia protocol designed to make the web faster, safer, and more open. Instead of addressing content by its location (like a URL), IPFS addresses content by its hash. This is called <strong>Content Addressing</strong>.</p><p>For example, a file's address isn't `https://server.com/cat.jpg`, but rather its cryptographic hash, like `QmXo...`. When you request this hash, the IPFS network finds the node(s) storing that content and delivers it to you. You can then re-hash the content to verify that you received the correct file.</p><h3>Security Properties:</h3><ul><li><strong>Integrity:</strong> Content addressing guarantees data integrity. You can't be served a malicious file because its hash wouldn't match the one you requested.</li><li><strong>No Central Server:</strong> Data is stored across a distributed network, making it resilient to censorship and single points of failure.</li></ul>",
                        
                    },
                    {
                        "title": "Data Availability and Incentive Layers",
                        "content": "<p>A key challenge with a system like IPFS is that there is no built-in guarantee that a file will remain available. If all the nodes storing a piece of content go offline, the file becomes inaccessible. This is the <strong>data availability problem</strong>.</p><p>Incentive layers like <strong>Filecoin</strong> are built on top of IPFS to solve this. Filecoin is a blockchain-based marketplace for storage.<ul><li>Users pay storage providers (miners) to store their data for a certain period.</li><li>To earn block rewards, providers must submit cryptographic proofs (<strong>Proof-of-Replication</strong> and <strong>Proof-of-Spacetime</strong>) to the blockchain, proving that they are continuously and correctly storing the user's data.</li></ul>This crypto-economic model creates a strong financial incentive for providers to keep data safe and available.</p>",
                        "image": "https://d230m64oxp1vr8.cloudfront.net/blogs/codeZerosgtb9xxv91706101137492.jpg"
                    },
                    {
                        "title": "Privacy and Encryption",
                        "content": "<p>By default, all data on IPFS is public. Anyone who knows or can find the hash of a file can access it. Therefore, for sensitive data, encryption is not optional—it's essential.</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Client-Side Encryption</strong></div><p>The standard security practice is to encrypt data *before* adding it to a decentralized storage network. The user encrypts the file on their own machine, then uploads the encrypted blob to the network. They can then safely share the decryption key with authorized parties through a separate secure channel. This ensures that even the storage providers themselves cannot access the user's private data.</p></div>",
                        
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary security benefit of 'content addressing' in IPFS?",
                        "options": [
                            "It makes files smaller.",
                            "It guarantees data privacy.",
                            "It guarantees data integrity; you can verify you received the correct file by hashing it.",
                            "It guarantees data will be stored forever."
                        ],
                        "correct": 2,
                        "explanation": "Because a file's address is its hash, you can cryptographically verify that the file you receive is the exact one you requested. Any modification would change its hash and thus its address."
                    },
                    {
                        "id": 2,
                        "question": "How do incentive layers like Filecoin solve the 'data availability problem' of IPFS?",
                        "options": [
                            "By making all files permanent by default.",
                            "By creating a marketplace where storage providers are financially rewarded for proving they are storing data correctly over time.",
                            "By storing all data on a central, highly reliable server.",
                            "By encrypting all files."
                        ],
                        "correct": 1,
                        "explanation": "Filecoin provides the economic incentives that are missing from the base IPFS protocol. Storage providers must submit ongoing proofs to the blockchain to get paid, ensuring data persists."
                    },
                    {
                        "id": 3,
                        "question": "What is the correct way to store sensitive data on a public decentralized storage network like IPFS?",
                        "options": [
                            "Hope that no one finds the hash.",
                            "Ask the storage provider to keep it secret.",
                            "Encrypt the data on your own device before uploading it.",
                            "Store it with a file name that does not describe its contents."
                        ],
                        "correct": 2,
                        "explanation": "Public decentralized networks should be treated as untrusted environments. The only way to guarantee privacy is through client-side encryption, where the user holds the only key."
                    }
                ]
            }
        },
        {
            "id": "lesson-34",
            "title": "Blockchain-Based Voting Systems",
            "duration": "75 min",
            "objectives": [
                "Understand the core security requirements for electronic voting",
                "Learn about the properties of verifiable voting protocols",
                "Analyze strategies for voter privacy protection",
                "Recognize the importance of result tallying security",
                "Explore coercion resistance mechanisms"
            ],
            "content": {
                "overview": "Using blockchain for voting is often proposed as a way to increase transparency and security in elections. However, voting systems have a unique and challenging set of security requirements that go beyond what a simple blockchain can provide. This lesson explores the promise and peril of on-chain voting, focusing on critical properties like privacy, verifiability, and coercion resistance.",
                "sections": [
                    {
                        "title": "Electronic Voting Security Requirements",
                        "content": "<p>Secure voting systems, whether on a blockchain or not, must satisfy several strict properties:</p><ul><li><strong>Privacy/Secrecy:</strong> No one should be able to learn how a voter voted.</li><li><strong>Verifiability:</strong> Voters and observers should be able to independently verify that all votes were counted correctly.</li><li><strong>Robustness:</strong> The system should be able to produce a correct tally even if some voters or authorities are malicious or fail.</li><li><strong>Coercion Resistance:</strong> A voter should not be able to prove to a third party (a coercer) how they voted. This prevents vote buying and intimidation.</li></ul>",
                        
                    },
                    {
                        "title": "Verifiability vs. Privacy on a Blockchain",
                        "content": "<p>A public blockchain is inherently transparent, which is excellent for <strong>verifiability</strong>. Anyone can audit the smart contract and recount the encrypted ballots to ensure the tally is correct. However, this same transparency is terrible for <strong>privacy</strong>.</p><p>Simply putting votes on a public ledger creates a permanent, immutable record of who voted, and potentially how they voted if the link between a voter's identity and their address is ever revealed. This is a fundamental conflict. Advanced cryptographic techniques like zero-knowledge proofs or homomorphic encryption are required to build systems that are both verifiable and private.</p>",
                        "image": "https://www.researchgate.net/publication/357827345/figure/fig2/AS:1112149598449665@1642168535021/Blockchain-based-e-voting-system-architecture.jpg"
                    },
                    {
                        "title": "The Challenge of Coercion Resistance",
                        "content": "<p>Coercion resistance is perhaps the hardest property to achieve. If a voter can prove how they voted, they can be forced or paid to vote a certain way. A simple blockchain voting system fails this test badly.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Why Blockchain Fails</strong></div><p>A voter could simply show a coercer the transaction on a block explorer, proving they sent a vote from their address to a particular candidate's address. To solve this, systems must break the link between the voter and their vote, or provide a way for voters to cast a fake vote to show a coercer while secretly casting a different, real vote. These solutions are cryptographically complex and a subject of ongoing research.</p></div>",
                      
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What does 'coercion resistance' mean in a voting system?",
                        "options": [
                            "The system is resistant to hacking.",
                            "A voter cannot prove to someone else how they voted.",
                            "Only authorized citizens are able to vote.",
                            "The final vote tally is correct."
                        ],
                        "correct": 1,
                        "explanation": "Coercion resistance is crucial for preventing vote buying and voter intimidation. If a voter can't prove their vote, a coercer has no way of confirming if their demands were met."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary conflict when designing a blockchain-based voting system?",
                        "options": [
                            "The conflict between high fees and speed.",
                            "The conflict between ease of use and security.",
                            "The conflict between the blockchain's inherent transparency (good for verifiability) and the need for voter privacy.",
                            "The conflict between different blockchain platforms."
                        ],
                        "correct": 2,
                        "explanation": "A public ledger makes it easy to verify that votes are counted correctly, but it also makes it very difficult to protect the secrecy of a voter's ballot, which is a fundamental requirement of democratic elections."
                    },
                    {
                        "id": 3,
                        "question": "Which advanced cryptographic technique is often proposed to enable private but verifiable on-chain voting?",
                        "options": [
                            "SHA-256",
                            "Digital Signatures (ECDSA)",
                            "Zero-Knowledge Proofs",
                            "Proof-of-Work"
                        ],
                        "correct": 2,
                        "explanation": "Zero-knowledge proofs could allow a voter to prove they are eligible to vote and that their encrypted ballot is valid, without revealing their identity or how they voted, thus satisfying both privacy and verifiability."
                    }
                ]
            }
        },
        {
            "id": "lesson-35",
            "title": "Energy and Environmental Security",
            "duration": "60 min",
            "objectives": [
                "Analyze the energy consumption of Proof-of-Work (PoW)",
                "Understand the security implications of 'green' blockchain alternatives",
                "Learn about the tokenization of carbon offsets",
                "Explore the concept of energy trading on blockchain",
                "Assess the environmental impact as a potential attack vector or systemic risk"
            ],
            "content": {
                "overview": "The energy consumption of Proof-of-Work blockchains has sparked intense debate, raising questions about sustainability and the long-term viability of the consensus mechanism. This lesson examines the relationship between energy use and security, explores greener alternatives, and discusses how the environment itself is becoming a key factor in the security and social acceptance of blockchain technology.",
                "sections": [
                    {
                        "title": "Proof-of-Work Energy Consumption Analysis",
                        "content": "<p>Proof-of-Work secures the network by making attacks computationally expensive. This 'work' is the process of mining, which consumes vast amounts of electricity. The security of the network is directly proportional to the amount of energy (and therefore money) an attacker would have to spend to overpower the honest miners.</p><h3>The Security Argument:</h3><p>Proponents argue that this energy expenditure is not 'wasted' but is essential for creating a robust, decentralized, and censorship-resistant monetary system. It is the cost of securing the network without relying on a central authority.</p>",
                       
                    },
                    {
                        "title": "Green Blockchain Alternatives",
                        "content": "<p>The high energy use of PoW has driven the industry toward less energy-intensive consensus mechanisms.</p><ul><li><strong>Proof of Stake (PoS):</strong> This is the most popular alternative. Instead of computational power, validators stake the network's native currency to secure it. This reduces energy consumption by over 99.9% compared to PoW. Ethereum's move to PoS was a landmark event in sustainable blockchain technology.</li><li><strong>Other Mechanisms:</strong> Alternatives like Proof-of-Authority, Proof-of-History, and various BFT-based protocols also offer high security with low energy footprints, though often with different decentralization trade-offs.</li></ul>",
                        "image": "https://media.springernature.com/lw685/springer-static/image/chp%3A10.1007%2F978-3-030-63654-8_6/MediaObjects/487709_1_En_6_Fig5_HTML.png"
                    },
                    {
                        "title": "Environmental Impact as a Systemic Risk",
                        "content": "<p>The environmental debate is not just a public relations issue; it poses a potential systemic risk to PoW-based blockchains.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Regulatory and Social Risk</strong></div><p>Governments concerned about climate change and energy grid stability may impose regulations or outright bans on PoW mining, as has been seen in some jurisdictions. Furthermore, growing social and investor pressure (ESG investing) can make it difficult for PoW-based projects to gain mainstream adoption and corporate partnerships. This can be seen as a long-term threat to the security and economic viability of these networks.</p></div>",
                        
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "In a Proof-of-Work system, what is the relationship between energy consumption and security?",
                        "options": [
                            "There is no relationship.",
                            "Higher energy consumption generally leads to higher security, as it increases the cost of a 51% attack.",
                            "Higher energy consumption leads to lower security.",
                            "Security is based on the number of users, not energy use."
                        ],
                        "correct": 1,
                        "explanation": "The security of PoW is rooted in economics. The total energy expended by honest miners represents the economic barrier an attacker must overcome to rewrite the blockchain's history."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary reason Proof of Stake (PoS) is considered a 'green' alternative to PoW?",
                        "options": [
                            "It processes transactions faster.",
                            "It does not require computationally intensive mining, drastically reducing energy consumption.",
                            "It uses renewable energy sources by default.",
                            "It is more decentralized."
                        ],
                        "correct": 1,
                        "explanation": "PoS replaces the competition of computational work with the competition of economic stake, which removes the need for specialized, energy-intensive hardware and lowers electricity use by orders of magnitude."
                    },
                    {
                        "id": 3,
                        "question": "How can the environmental impact of PoW mining be considered a security risk?",
                        "options": [
                            "It can directly introduce bugs into the code.",
                            "It has no impact on security.",
                            "It can lead to regulatory crackdowns and social opposition that threaten the network's long-term viability.",
                            "It causes the price of the cryptocurrency to be more volatile."
                        ],
                        "correct": 2,
                        "explanation": "External pressures from governments and society can harm a network's growth, hash rate, and decentralization, which are all critical components of its overall security."
                    }
                ]
            }
        },
        {
            "id": "lesson-36",
            "title": "Regulatory Technology (RegTech) Security",
            "duration": "60 min",
            "objectives": [
                "Understand the role of RegTech in blockchain",
                "Learn about automated compliance monitoring systems",
                "Analyze how real-time transaction screening works",
                "Explore the integration of sanctions lists and watchlists",
                "Recognize the importance of privacy-preserving compliance techniques"
            ],
            "content": {
                "overview": "As regulation in the crypto space grows, Regulatory Technology (RegTech) is becoming essential for ensuring that exchanges, protocols, and businesses can comply with the law. This lesson explores the tools and techniques used to automate compliance, from real-time transaction screening to privacy-preserving reporting.",
                "sections": [
                    {
                        "title": "Automated Compliance and Transaction Screening",
                        "content": "<p>RegTech solutions for blockchain are designed to automate the process of complying with AML/CFT regulations. These platforms plug into blockchain data and help businesses monitor for risky activity.</p><h3>Key Features:</h3><ul><li><strong>Transaction Monitoring:</strong> Automatically flagging transactions that meet certain risk criteria (e.g., large amounts, unusual patterns, or interaction with high-risk addresses).</li><li><strong>Address Screening:</strong> Checking if a customer's deposit address has a history of interaction with illicit sources like darknet markets, mixers, or sanctioned entities.</li><li><strong>Risk Scoring:</strong> Assigning a dynamic risk score to addresses and transactions to help compliance officers prioritize their investigations.</li></ul>",
                        
                    },
                    {
                        "title": "Sanctions List Integration",
                        "content": "<p>Governments around the world maintain sanctions lists (e.g., the U.S. Treasury's OFAC list) of individuals, organizations, and even cryptocurrency addresses that are forbidden from participating in the financial system.</p><p>RegTech platforms constantly update their databases with these lists. When a user tries to deposit funds to or withdraw funds from a compliant exchange, their address (and the counterparty address) is automatically screened against these lists. If a match is found, the transaction is blocked and a report is filed with the authorities.</p>",
                        "image": "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcToncnWiM8GnlZmFV4ArUhf8Zgrp9vVFIi2yg&s"
                    },
                    {
                        "title": "Privacy-Preserving Compliance",
                        "content": "<p>A major challenge is how to achieve compliance in a way that respects the privacy ethos of blockchain. New cryptographic techniques are being developed to solve this.</p><div class='info-box tip'><div class='info-box-header'><i class='fas fa-lightbulb'></i><strong>Compliance with Zero Knowledge</strong></div><p>Using Zero-Knowledge Proofs, a user could prove to a DeFi protocol that they have been KYC'd by a trusted third party, or that their funds do not originate from an illicit source, *without* revealing their real-world identity or entire transaction history to the protocol. This allows for 'permissioned DeFi' where protocols can be compliant without becoming fully centralized surveillance systems.</p></div>",
                        
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary function of RegTech in the blockchain space?",
                        "options": [
                            "To help developers write more secure code.",
                            "To automate the process of complying with financial regulations like AML and KYC.",
                            "To create new regulations for cryptocurrencies.",
                            "To provide customer support for exchanges."
                        ],
                        "correct": 1,
                        "explanation": "RegTech companies provide the tools that allow crypto businesses to automatically monitor transactions and screen users to meet their legal obligations."
                    },
                    {
                        "id": 2,
                        "question": "What does a transaction monitoring system typically do?",
                        "options": [
                            "It tries to speed up transactions.",
                            "It flags transactions that match predefined risk rules, such as connections to sanctioned addresses.",
                            "It allows users to cancel their transactions.",
                            "It provides a discount on transaction fees."
                        ],
                        "correct": 1,
                        "explanation": "These systems are a core part of AML programs, helping to identify and report suspicious activity to compliance officers and regulatory bodies."
                    },
                    {
                        "id": 3,
                        "question": "How can Zero-Knowledge Proofs be used for 'privacy-preserving compliance'?",
                        "options": [
                            "By hiding all transaction data from everyone.",
                            "By allowing a user to prove a specific statement (e.g., 'I am not on a sanctions list') without revealing their underlying private data.",
                            "By encrypting the entire blockchain.",
                            "By deleting a user's transaction history."
                        ],
                        "correct": 1,
                        "explanation": "ZKPs offer a potential middle ground, enabling protocols to verify compliance-related facts about a user without needing to collect and store their sensitive personal information."
                    }
                ]
            }
        },
        {
            "id": "lesson-37",
            "title": "Blockchain Security Monitoring",
            "duration": "75 min",
            "objectives": [
                "Understand the importance of real-time attack detection",
                "Learn about on-chain anomaly detection algorithms",
                "Explore the role of threat intelligence integration",
                "Describe the components of a security incident response plan",
                "Analyze the potential of automated defense mechanisms"
            ],
            "content": {
                "overview": "The best defense is a proactive one. Security monitoring involves continuously observing on-chain and off-chain activity to detect threats and potential exploits before they can cause catastrophic damage. This lesson covers the tools and strategies used by security professionals to monitor smart contracts and blockchain networks in real-time.",
                "sections": [
                    {
                        "title": "Real-Time Attack Detection",
                        "content": "<p>Security monitoring platforms act like a real-time immune system for the blockchain ecosystem. They ingest a massive stream of data, including pending transactions from the mempool and confirmed on-chain transactions.</p><p>Specialized bots and machine learning models analyze this data to detect signatures of known attacks or suspicious behavior. For example, a bot could detect a transaction originating from an address associated with a known phishing scam, or a smart contract emitting an unusual number of error events.</p>",
                        
                    },
                    {
                        "title": "Anomaly Detection and Threat Intelligence",
                        "content": "<p><strong>Anomaly detection</strong> involves establishing a baseline of normal behavior for a protocol and then flagging any significant deviations. This can help detect novel, or 'zero-day', attacks. Examples include:<ul><li>A sudden, unusually large withdrawal from a DeFi protocol's reserves.</li><li>A governance vote where the voting power is highly concentrated from newly funded wallets.</li><li>A smart contract being called by an unusually high number of unique addresses in a short period.</li></ul><p><strong>Threat intelligence</strong> involves integrating external data feeds about the latest threats, known hacker addresses, and newly discovered vulnerabilities to enrich the monitoring system's detection capabilities.</p>",
                        "image": "https://cpl.thalesgroup.com/sites/default/files/inline-images/blockchain-diagram_1.png"
                    },
                    {
                        "title": "Automated Incident Response",
                        "content": "<p>Detection is only half the battle. Once a threat is identified, a rapid response is critical. While many responses require human intervention (e.g., a multi-sig team pausing a contract), there is a growing trend towards automation.</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Example: OpenZeppelin Defender</strong></div><p>Platforms like OpenZeppelin Defender allow teams to create automated response workflows. For example, if a monitoring bot detects a suspicious transaction that could drain a contract, it can trigger a 'Defender Autotask' to automatically front-run the malicious transaction with one that pauses the contract. This automated response can act within seconds, which is often faster than a human team can assemble to react.</p></div>",
                        
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary goal of a real-time security monitoring system for blockchain?",
                        "options": [
                            "To predict the future price of cryptocurrencies.",
                            "To analyze and detect potential attacks and threats as they are happening.",
                            "To provide customer support for dApp users.",
                            "To ensure the blockchain has 100% uptime."
                        ],
                        "correct": 1,
                        "explanation": "These systems act as an early warning mechanism, observing the mempool and on-chain data to identify exploits in progress, giving teams a chance to react before funds are lost."
                    },
                    {
                        "id": 2,
                        "question": "Which of the following would be an example of anomaly detection?",
                        "options": [
                            "Blocking a transaction from a known scammer's address.",
                            "Flagging a sudden, massive spike in transaction volume on a DeFi protocol that is normally quiet.",
                            "Verifying the correctness of a smart contract's code before deployment.",
                            "Updating a server with the latest security patches."
                        ],
                        "correct": 1,
                        "explanation": "Anomaly detection focuses on identifying deviations from a normal baseline, which can help catch new or unknown attack patterns, whereas signature-based detection looks for known threats."
                    },
                    {
                        "id": 3,
                        "question": "What is a key benefit of an automated incident response system?",
                        "options": [
                            "It is cheaper than hiring a security team.",
                            "It can act at machine speed, often faster than a human team can respond to a threat.",
                            "It can prevent all security incidents from ever happening.",
                            "It requires no configuration or maintenance."
                        ],
                        "correct": 1,
                        "explanation": "In the world of blockchain where exploits can happen in a single transaction, the ability to automatically pause a contract or take other defensive measures within seconds can be the difference between a close call and a catastrophic loss."
                    }
                ]
            }
        },
        {
            "id": "lesson-38",
            "title": "Cryptographic Agility in Blockchain",
            "duration": "60 min",
            "objectives": [
                "Define cryptographic agility",
                "Understand the need for algorithm transition strategies",
                "Analyze the challenges of implementing multi-algorithm support",
                "Recognize the importance of backward compatibility during an upgrade",
                "Explore future-proofing mechanisms for blockchain protocols"
            ],
            "content": {
                "overview": "The cryptographic algorithms we rely on today may not be secure forever. Advances in computing (like quantum computers) or new mathematical breakthroughs could break them. Cryptographic agility is the ability of a system to be easily upgraded to new, stronger cryptographic primitives without disrupting the entire network. This lesson explores why this is a critical, though often overlooked, aspect of long-term blockchain security.",
                "sections": [
                    {
                        "title": "The Need for Agility",
                        "content": "<p>Most blockchains hard-code a specific set of cryptographic algorithms into their protocol. For example, Bitcoin exclusively uses SHA-256 for hashing and ECDSA for signatures. If a critical vulnerability were to be discovered in one of these algorithms, the entire system would be at risk.</p><p><strong>Cryptographic agility</strong> is a design principle that acknowledges this risk and plans for it. It means designing the blockchain protocol in a way that allows for a smooth transition to new algorithms over time. This is especially important for the long-term threat of quantum computing.</p>",
                       
                    },
                    {
                        "title": "Algorithm Transition Strategies",
                        "content": "<p>Upgrading a core cryptographic algorithm in a live, decentralized network is extremely difficult and requires a hard fork.</p><h3>Potential Strategies:</h3><ul><li><strong>Hybrid Approach:</strong> A short-term strategy where transactions are required to have signatures from both the old algorithm (e.g., ECDSA) and a new, post-quantum one. This provides security as long as at least one of the algorithms remains unbroken.</li><li><strong>State Transition Fork:</strong> A planned hard fork where the entire state of the blockchain is migrated to a new format that uses quantum-resistant addresses and signatures. This would be a highly complex and risky undertaking.</li><li><strong>Abstracted Accounts:</strong> Systems like Ethereum's Account Abstraction make this easier. It allows users to define the validity of their own transactions, so a user could define their account to be secured by a new signature scheme without a network-wide protocol change.</li></ul>",
                        "image": "https://www.techtarget.com/rms/onlineimages/benefits_of_crypto_agility-f_mobile.png"
                    },
                    {
                        "title": "Challenges and Future-Proofing",
                        "content": "<p>Implementing cryptographic agility is not without its challenges.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Implementation Hurdles</strong></div><p><ul><li><strong>Increased Complexity:</strong> Supporting multiple signature schemes adds significant complexity to the protocol and client software.</li><li><strong>Data Bloat:</strong> New quantum-resistant signatures are often much larger than current ECDSA signatures, which would increase the size of the blockchain.</li><li><strong>Coordination:</strong> Getting the entire decentralized community to agree on and coordinate a major cryptographic upgrade is a massive social and technical challenge.</li></ul>Despite these difficulties, building with agility in mind is crucial for any blockchain that aims to exist for decades to come.</p></div>",
                       
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is cryptographic agility?",
                        "options": [
                            "A new, faster encryption algorithm.",
                            "The ability of a system to be easily updated to use new cryptographic algorithms.",
                            "A method for breaking cryptography.",
                            "A type of cryptocurrency wallet."
                        ],
                        "correct": 1,
                        "explanation": "It's a design principle that anticipates that cryptographic standards will need to be replaced over time and makes the transition process as smooth as possible."
                    },
                    {
                        "id": 2,
                        "question": "Why is cryptographic agility particularly important in the face of quantum computing?",
                        "options": [
                            "Quantum computers are more agile.",
                            "Quantum computers threaten to break the cryptographic algorithms (like ECDSA) currently used by most blockchains.",
                            "It helps blockchains consume less energy.",
                            "It is not important for quantum computing."
                        ],
                        "correct": 1,
                        "explanation": "The threat of quantum computers breaking current public-key cryptography is the most significant driver for needing to upgrade to Post-Quantum Cryptography (PQC) in the future."
                    },
                    {
                        "id": 3,
                        "question": "What is the biggest challenge to upgrading a core cryptographic algorithm on a decentralized blockchain?",
                        "options": [
                            "The cost of the new algorithms.",
                            "Lack of available developers.",
                            "The need for a network-wide coordinated hard fork, which is technically and socially difficult.",
                            "The new algorithms being too slow."
                        ],
                        "correct": 2,
                        "explanation": "Unlike a centralized system where a company can push an update, a decentralized network requires widespread consensus from developers, node operators, and the community to execute a major, non-backward-compatible change like a cryptographic transition."
                    }
                ]
            }
        },
        {
            "id": "lesson-39",
            "title": "Blockchain Penetration Testing",
            "duration": "75 min",
            "objectives": [
                "Understand blockchain-specific penetration testing methodologies",
                "Learn smart contract exploitation techniques",
                "Explore how to simulate network-level attacks",
                "Recognize the role of social engineering in blockchain contexts",
                "Describe the process of a red team exercise against a dApp"
            ],
            "content": {
                "overview": "A penetration test (pentest) is an authorized, simulated cyberattack on a system to evaluate its security. For blockchains and dApps, this goes beyond traditional web application testing to include the unique and complex attack surfaces of smart contracts, P2P networks, and consensus mechanisms. This lesson covers the methodologies used to proactively find and fix vulnerabilities.",
                "sections": [
                    {
                        "title": "Penetration Testing Methodology",
                        "content": "<p>A blockchain pentest typically involves several phases:</p><ol><li><strong>Reconnaissance:</strong> Gathering information about the target, including the system architecture, smart contracts deployed, off-chain infrastructure, and key personnel.</li><li><strong>Threat Modeling:</strong> Identifying potential threats and attack vectors based on the system's design. What are the most valuable assets, and how might an attacker try to compromise them?</li><li><strong>Vulnerability Analysis:</strong> Using automated tools (static/dynamic analysis) and manual review to find potential vulnerabilities in smart contracts and infrastructure.</li><li><strong>Exploitation:</strong> Actively trying to exploit the identified vulnerabilities in a controlled test environment to prove their impact.</li><li><strong>Reporting:</strong> Documenting all findings, including the vulnerability, its potential impact, and detailed recommendations for remediation.</li></ol>",
                        
                    },
                    {
                        "title": "Smart Contract Exploitation Techniques",
                        "content": "<p>This phase focuses on actively trying to break the business logic of the smart contracts. A tester will go beyond simple vulnerability scanning and attempt to chain together multiple actions to create an unexpected and harmful state.</p><h3>Examples:</h3><ul><li>Simulating a flash loan attack to manipulate oracles.</li><li>Testing for reentrancy by deploying a malicious attacker contract.</li><li>Probing access control functions to see if non-admin users can call privileged functions.</li><li>Fuzzing function inputs with extreme values to test for integer overflows or unexpected reverts.</li></ul>",
                        "image": "https://cdn-blog.getastra.com/2021/09/blockchain-penetration-testing-1.png"
                    },
                    {
                        "title": "Red Team Exercises",
                        "content": "<p>A red team exercise is a full-scope, objective-based assessment. Instead of just looking for a list of vulnerabilities, the red team is given a goal, such as 'Steal 1 ETH from the protocol' or 'Cause a governance vote to fail'.</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Simulating Real-World Attacks</strong></div><p>The red team is allowed to use any means necessary to achieve their objective, including not only technical exploitation of smart contracts, but also attacking off-chain components like web front-ends, APIs, and even using social engineering techniques (like phishing) against the development team. This provides a much more holistic view of the project's real-world security posture.</p></div>",
                       
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary goal of a penetration test?",
                        "options": [
                            "To cause damage to a system.",
                            "To publicly disclose vulnerabilities.",
                            "To proactively find and fix security vulnerabilities in an authorized and controlled manner.",
                            "To satisfy a regulatory requirement with minimal effort."
                        ],
                        "correct": 2,
                        "explanation": "A pentest is a defensive measure. Its purpose is to identify and understand weaknesses from an attacker's perspective so they can be remediated before a real attacker finds them."
                    },
                    {
                        "id": 2,
                        "question": "How does a red team exercise differ from a standard penetration test?",
                        "options": [
                            "It is less technical.",
                            "It is objective-based and simulates a real-world attacker, often targeting the entire organization including people and processes.",
                            "It only focuses on smart contract code.",
                            "It is performed by the internal development team."
                        ],
                        "correct": 1,
                        "explanation": "While a pentest might look for any and all vulnerabilities, a red team exercise is a more focused, goal-oriented simulation that tests the organization's detection and response capabilities in addition to its preventative controls."
                    },
                    {
                        "id": 3,
                        "question": "Which of the following is unique to a blockchain penetration test compared to a traditional web app test?",
                        "options": [
                            "Testing for SQL injection.",
                            "Checking for cross-site scripting (XSS).",
                            "Analyzing for smart contract vulnerabilities like reentrancy and simulating economic exploits.",
                            "Scanning for open ports on a web server."
                        ],
                        "correct": 2,
                        "explanation": "The analysis of smart contract logic, consensus mechanisms, and the potential for crypto-economic attacks are all unique and critical components of a blockchain-focused penetration test."
                    }
                ]
            }
        },
        {
            "id": "lesson-40",
            "title": "Incident Response and Recovery",
            "duration": "75 min",
            "objectives": [
                "Understand the phases of a blockchain incident response plan",
                "Learn about forensic analysis techniques for on-chain exploits",
                "Explore recovery mechanisms, including white-hat hacks",
                "Recognize the importance of clear communication strategies during a crisis",
                "Learn how to integrate lessons learned into future security practices"
            ],
            "content": {
                "overview": "Despite the best preventative measures, security incidents can still happen. A well-prepared incident response (IR) plan is crucial for minimizing damage, recovering funds if possible, and maintaining user trust. This lesson covers the key phases of responding to a blockchain security incident, from initial detection to post-mortem analysis.",
                "sections": [
                    {
                        "title": "Incident Response Procedures",
                        "content": "<p>A typical IR plan follows a structured lifecycle:</p><ol><li><strong>Preparation:</strong> Having a plan, a dedicated team, and the right tools in place *before* an incident occurs.</li><li><strong>Identification:</strong> Detecting the incident through monitoring, bug bounties, or community reports. A 'war room' is established to coordinate the response.</li><li><strong>Containment:</strong> The immediate priority is to stop the bleeding. This often involves pausing the vulnerable smart contract or upgrading a proxy to a safe implementation.</li><li><strong>Eradication:</strong> Identifying and understanding the root cause of the vulnerability.</li><li><strong>Recovery:</strong> Restoring the system to a secure state. This might involve redeploying patched contracts, attempting to negotiate with the attacker, or organizing a white-hat counter-exploit.</li><li><strong>Lessons Learned:</strong> Conducting a thorough post-mortem to ensure the same mistake doesn't happen again.</li></ol>",
                       
                    },
                    {
                        "title": "Forensic Analysis and Recovery",
                        "content": "<p>Once an attack is detected, a deep forensic analysis begins. This involves using blockchain explorers and analysis tools to trace the attacker's transactions, identify the exact vulnerability they exploited, and track the movement of the stolen funds.</p><h3>Recovery Options:</h3><ul><li><strong>Negotiation:</strong> In some cases, teams have successfully negotiated with the attacker (who is often a grey-hat hacker) to return the majority of the funds in exchange for a 'bounty'.</li><li><strong>White-Hat Hack:</strong> If a vulnerability is found that still contains user funds, an ethical hacking group might be employed to exploit the same bug to rescue the remaining funds before other malicious actors can steal them.</li><li><strong>Social Coordination:</strong> In extreme, protocol-level cases (like The DAO hack), a hard fork of the blockchain itself is a theoretical but highly controversial recovery option.</li></ul>",
                        "image": "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTTcPCRSFW1K27ys6-nXrdio9vuqhAInZJ2Ig&s"
                    },
                    {
                        "title": "Communication and Post-Mortem",
                        "content": "<p>How a team communicates during a crisis is critical for maintaining user trust. </p><div class='info-box tip'><div class='info-box-header'><i class='fas fa-lightbulb'></i><strong>Communication Best Practices</strong></div><p><ul><li><strong>Be Prompt and Transparent:</strong> Acknowledge the incident as quickly as possible. Don't try to hide it.</li><li><strong>Provide Regular Updates:</strong> Keep the community informed of the containment and recovery process.</li><li><strong>Be Factual:</strong> Clearly explain what happened, the impact, and the steps being taken. Avoid speculation.</li><li><strong>Publish a Detailed Post-Mortem:</strong> After the incident is resolved, publish a full report detailing the root cause, the response actions, and the long-term fixes being implemented. This helps the entire ecosystem learn from the mistake.</li></ul></p></div>",
                        
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "In an incident response plan, what is the primary goal of the 'Containment' phase?",
                        "options": [
                            "To find out who the attacker was.",
                            "To immediately stop the attack and prevent further losses.",
                            "To write a report about the incident.",
                            "To recover the stolen funds."
                        ],
                        "correct": 1,
                        "explanation": "Containment is the emergency first step. The priority is to stop the bleeding, typically by pausing the affected contracts, to limit the damage as much as possible."
                    },
                    {
                        "id": 2,
                        "question": "What is a 'white-hat hack' in the context of incident response?",
                        "options": [
                            "The original malicious hack.",
                            "An attempt by an ethical hacker to exploit a vulnerability to rescue funds before other attackers can steal them.",
                            "A hack that is funded by a government entity.",
                            "A theoretical attack that has not yet been executed."
                        ],
                        "correct": 1,
                        "explanation": "When a vulnerability is discovered in a contract that still holds user funds, a white-hat (ethical) hacking group may be called in to deliberately exploit the bug in a controlled way to move the funds to safety."
                    },
                    {
                        "id": 3,
                        "question": "What is the purpose of a post-mortem report after a security incident?",
                        "options": [
                            "To assign blame to specific developers.",
                            "To be used as evidence in a lawsuit.",
                            "To provide a transparent and detailed account of the incident and lessons learned to the community and other developers.",
                            "To fulfill a legal requirement."
                        ],
                        "correct": 2,
                        "explanation": "A good post-mortem is a crucial part of responsible disclosure and helps the entire ecosystem become more secure by sharing knowledge about the vulnerability and the response process."
                    }
                ]
            }
        },
        {
            "id": "lesson-41",
            "title": "Blockchain Security Education",
            "duration": "60 min",
            "objectives": [
                "Understand the importance of security awareness training for all stakeholders",
                "Identify key security education topics for developers",
                "Learn about user security best practices and how to promote them",
                "Explore methods for developing a strong security culture within an organization",
                "Recognize the role of continuous learning and staying updated on threats"
            ],
            "content": {
                "overview": "Technology and audits are crucial, but the human element is often the weakest link in the security chain. Effective security education for developers, employees, and end-users is essential for building a resilient ecosystem. This lesson focuses on the principles of creating and maintaining a strong security culture.",
                "sections": [
                    {
                        "title": "Developer Security Education",
                        "content": "<p>Secure protocols are built by security-minded developers. It's not enough for a team to rely on external auditors; security must be part of the development process from day one.</p><h3>Key Training Areas:</h3><ul><li><strong>Secure Coding Practices:</strong> Deep knowledge of common vulnerabilities (reentrancy, overflows, etc.) and mitigation patterns (Checks-Effects-Interactions).</li><li><strong>Threat Modeling:</strong> Training developers to think like an attacker and analyze their own code for potential exploits.</li><li><strong>Tooling:</strong> Proficiency with security tools like static analyzers (Slither), fuzzers (Echidna), and formal verification frameworks.</li><li><strong>Incident Response Drills:</strong> Regularly practicing the incident response plan so the team is prepared for a real event.</li></ul>",
                       
                    },
                    {
                        "title": "User Security Best Practices",
                        "content": "<p>Even the most secure protocol can't protect a user whose private keys are compromised. Projects have a responsibility to educate their users on how to stay safe.</p><h3>Essential User Advice:</h3><ul><li><strong>Key Management:</strong> Emphasize the importance of hardware wallets and secure seed phrase storage.</li><li><strong>Phishing Awareness:</strong> Teach users to be skeptical of unsolicited links, to always check URLs, and to never enter their seed phrase into a website.</li><li><strong>Signature Verification:</strong> Urge users to carefully read and understand what they are signing. A malicious signature can give a contract approval to drain all of a user's tokens.</li><li><strong>Revoke Approvals:</strong> Teach users how to use tools like Revoke.cash to clean up old or unnecessary token approvals.</li></ul>",
                        "image": "https://www.slideteam.net/media/catalog/product/cache/1280x720/b/l/blockchain_technology_impact_in_education_sector_training_ppt_slide01.jpg"
                    },
                    {
                        "title": "Developing a Security Culture",
                        "content": "<p>A strong security culture is one where security is a shared responsibility, not just the job of the security team. It's an environment where everyone feels empowered to raise security concerns.</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Elements of a Strong Culture</strong></div><p><ul><li><strong>Leadership Buy-in:</strong> Management must prioritize and fund security initiatives.</li><li><strong>Blameless Post-Mortems:</strong> After an incident, the focus should be on fixing the systemic issues, not on blaming individuals.</li><li><strong>Continuous Learning:</strong> The threat landscape is always changing. Encourage participation in security conferences, workshops, and competitive hacking events (CTFs).</li><li><strong>Bug Bounties:</strong> A well-funded bug bounty program signals a commitment to security and leverages the global community of ethical hackers to find vulnerabilities.</li></ul></p></div>",
                       
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary goal of threat modeling during the development process?",
                        "options": [
                            "To write code faster.",
                            "To think like an attacker and proactively identify potential security weaknesses in a system's design.",
                            "To formally verify that the code is bug-free.",
                            "To choose which programming language to use."
                        ],
                        "correct": 1,
                        "explanation": "Threat modeling is a structured process of identifying potential threats and vulnerabilities from an adversarial perspective, allowing them to be fixed early in the design phase."
                    },
                    {
                        "id": 2,
                        "question": "What is the single most important piece of security advice for a new cryptocurrency user?",
                        "options": [
                            "To use a strong password for their exchange account.",
                            "To buy a variety of different cryptocurrencies.",
                            "To securely store their seed phrase offline and never share it with anyone.",
                            "To follow trading signals on social media."
                        ],
                        "correct": 2,
                        "explanation": "The seed phrase is the master key to a user's funds. Its compromise leads to an immediate and irreversible loss of all assets in that wallet."
                    },
                    {
                        "id": 3,
                        "question": "What is a key component of a positive security culture?",
                        "options": [
                            "A large security team that handles everything.",
                            "Keeping all security information secret, even within the company.",
                            "A 'blameless' approach to incidents, focusing on systemic improvements rather than blaming individuals.",
                            "Punishing developers who write buggy code."
                        ],
                        "correct": 2,
                        "explanation": "A blameless culture encourages transparency and honesty. When people aren't afraid of being punished for mistakes, they are more likely to report issues early, which leads to better security outcomes."
                    }
                ]
            }
        },
        {
            "id": "lesson-42",
            "title": "Advanced Persistent Threats (APT) in Blockchain",
            "duration": "75 min",
            "objectives": [
                "Define the characteristics of an Advanced Persistent Threat (APT)",
                "Analyze nation-state attack vectors against blockchain projects",
                "Understand long-term infiltration and social engineering techniques",
                "Explore supply chain attacks targeting blockchain infrastructure",
                "Learn about attribution and investigation of sophisticated attacks"
            ],
            "content": {
                "overview": "While many blockchain hacks are carried out by individual hackers or small groups, the most sophisticated and damaging attacks often come from Advanced Persistent Threats (APTs). These are typically well-funded, state-sponsored groups with long-term objectives. This lesson explores the tactics, techniques, and procedures used by these high-level adversaries.",
                "sections": [
                    {
                        "title": "Characteristics of an APT",
                        "content": "<p>An APT is not a simple smash-and-grab hacker. They are defined by their advanced capabilities and their persistence.</p><ul><li><strong>Advanced:</strong> They use sophisticated, custom-built malware and exploits (including zero-days) and are highly skilled at evading detection.</li><li><strong>Persistent:</strong> Their goal is not a quick score, but to establish long-term access to a target network. They will remain quiet and hidden for months or even years, slowly gathering intelligence before acting.</li><li><strong>Well-Resourced:</strong> They are typically backed by a nation-state, giving them significant financial and human resources. Their objective is often geopolitical or to fund state activities, not just personal enrichment.</li></ul>",
                        
                    },
                    {
                        "title": "Nation-State Attack Vectors",
                        "content": "<p>State-sponsored groups have been responsible for some of the largest hacks in crypto history. Their methods often go beyond just attacking smart contracts.</p><h3>Tactics of Groups like Lazarus (North Korea):</h3><ul><li><strong>Spear Phishing:</strong> Highly targeted social engineering attacks. For example, creating a fake but convincing job offer for a senior developer at a target company. The 'job offer' PDF is actually a malware-laden document that compromises the developer's computer.</li><li><strong>Supply Chain Attacks:</strong> Compromising a software dependency that a project uses, allowing them to inject malicious code into the final product.</li><li><strong>Long-Term Infiltration:</strong> Once they gain a foothold in the company's network, they will move laterally, stealing credentials and mapping the infrastructure until they find the keys to the treasure—often the private keys controlling a cross-chain bridge.</li></ul>",
                        "image": "https://www.a10networks.com/wp-content/uploads/five-stages-of-an-advanced-persistent-threat-attack-1024x509.png"
                    },
                    {
                        "title": "Defense and Attribution",
                        "content": "<p>Defending against APTs requires a defense-in-depth strategy that goes far beyond a smart contract audit.</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Holistic Security Posture</strong></div><p><ul><li><strong>Corporate Security:</strong> Strong internal security policies, employee training on social engineering, and securing all internal systems and devices.</li><li><strong>Software Supply Chain Security:</strong> Auditing all dependencies and using secure build processes.</li><li><strong>Advanced Monitoring:</strong> Detecting the subtle signs of a persistent threat inside the network.</li></ul><strong>Attribution</strong> is the process of identifying the group behind an attack. This is done by blockchain forensics firms and government agencies by analyzing the on-chain flow of funds and comparing the malware and attack techniques to those used in previous known campaigns.</p></div>",
                        
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What does the 'Persistent' in Advanced Persistent Threat (APT) refer to?",
                        "options": [
                            "They persistently try to guess passwords.",
                            "Their goal is to establish long-term, undetected access to a target's network.",
                            "The attack is over very quickly.",
                            "They use malware that cannot be removed."
                        ],
                        "correct": 1,
                        "explanation": "Persistence is a key characteristic. APTs are not interested in a quick hit; they play a long game, remaining dormant within a network to maximize their intelligence gathering and eventual impact."
                    },
                    {
                        "id": 2,
                        "question": "What is a common infiltration method used by APTs targeting blockchain projects?",
                        "options": [
                            "Finding a bug in the blockchain's consensus algorithm.",
                            "Highly targeted spear-phishing campaigns against key employees, like developers.",
                            "Buying a large amount of the project's token to influence its price.",
                            "Launching a denial-of-service attack."
                        ],
                        "correct": 1,
                        "explanation": "Targeting the human element through sophisticated social engineering is a hallmark of APTs, as compromising a key developer's machine can provide a direct path to a project's most sensitive assets."
                    },
                    {
                        "id": 3,
                        "question": "Why are cross-chain bridges a common target for nation-state hacking groups?",
                        "options": [
                            "They are easy to hack.",
                            "They often secure immense amounts of capital and are controlled by a set of private keys that can be stolen through network infiltration.",
                            "They do not have bug bounty programs.",
                            "They process transactions very slowly."
                        ],
                        "correct": 1,
                        "explanation": "The operational security of the team and infrastructure that controls the bridge is often the weakest link. For an APT that excels at network infiltration, stealing the keys to a bridge is a more direct path than finding a zero-day bug in a smart contract."
                    }
                ]
            }
        },
        {
            "id": "lesson-43",
            "title": "Blockchain Security Standards",
            "duration": "60 min",
            "objectives": [
                "Learn about the role of ISO blockchain security standards (e.g., ISO/TC 307)",
                "Explore industry best practice frameworks like the CryptoCurrency Security Standard (CCSS)",
                "Understand the requirements for certifications and audits (e.g., SOC 2)",
                "Recognize the importance of developing an internal compliance framework",
                "Discuss the impact of international standardization efforts"
            ],
            "content": {
                "overview": "As the blockchain industry matures, the need for standardized security practices becomes increasingly important for building trust with users and enterprise adopters. This lesson provides an overview of the emerging security standards, frameworks, and certifications that are helping to professionalize the field of blockchain security.",
                "sections": [
                    {
                        "title": "ISO Blockchain Security Standards",
                        "content": "<p>The International Organization for Standardization (ISO) is a global body that develops and publishes international standards. The technical committee <strong>ISO/TC 307</strong> is specifically focused on blockchain and distributed ledger technologies.</p><p>These standards provide a formal framework and vocabulary for topics such as:<ul><li>Security, privacy, and identity management.</li><li>Governance models for blockchains.</li><li>Interoperability between different blockchain systems.</li></ul>While adoption is still in early stages, these standards are crucial for enterprise adoption, as they provide a recognized benchmark for security and risk management.</p>",
                       
                    },
                    {
                        "title": "Industry Best Practice Frameworks",
                        "content": "<p>Alongside formal standards, several industry-led frameworks provide actionable guidance for securing systems.</p><ul><li><strong>CryptoCurrency Security Standard (CCSS):</strong> An open standard designed to augment standard information security practices. It provides specific guidance for securing systems that interact with cryptocurrencies, covering topics like key management, wallet security, and operational security.</li><li><strong>Smart Contract Security Verification Standard (SCSVS):</strong> A community-driven effort (similar to OWASP's ASVS for web apps) to create a standardized checklist of security requirements for designing, developing, and testing secure smart contracts.</li></ul>",
                        "image": "https://www.nist.gov/sites/default/files/styles/2800_x_2800_limit/public/images/2019/02/13/blockchain_manufacturing_final.png?itok=RZUheXEs"
                    },
                    {
                        "title": "Certifications and Audits (SOC 2)",
                        "content": "<p>For crypto companies that act as custodians (like exchanges and institutional wallet providers), achieving recognized security certifications is essential for building trust.</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>SOC 2 Compliance</strong></div><p>A SOC 2 (Service Organization Control 2) report is an audit of a service organization's internal controls. It reports on how well the company protects customer data based on criteria like security, availability, processing integrity, confidentiality, and privacy. For an institutional client to entrust a crypto custodian with billions of dollars, a clean SOC 2 report is often a mandatory requirement.</p></div>",
                       
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the primary purpose of international standards like those from ISO/TC 307?",
                        "options": [
                            "To make blockchain development more difficult.",
                            "To provide a globally recognized framework for security, interoperability, and governance to promote trust and adoption.",
                            "To replace the need for smart contract audits.",
                            "To dictate which blockchain platform companies should use."
                        ],
                        "correct": 1,
                        "explanation": "Standards create a common language and set of expectations, which is essential for risk management, regulatory compliance, and building confidence, particularly among enterprise and institutional users."
                    },
                    {
                        "id": 2,
                        "question": "The CryptoCurrency Security Standard (CCSS) is best described as...",
                        "options": [
                            "A law that all crypto projects must follow.",
                            "A type of smart contract.",
                            "An industry framework that provides specific security guidance for systems that handle cryptocurrencies.",
                            "A new consensus algorithm."
                        ],
                        "correct": 2,
                        "explanation": "CCSS is a set of best practices designed to complement general security standards with specific controls relevant to the unique challenges of managing cryptographic keys and wallets."
                    },
                    {
                        "id": 3,
                        "question": "Why is a SOC 2 certification important for a cryptocurrency custodian?",
                        "options": [
                            "It guarantees their token price will increase.",
                            "It proves that their smart contracts are bug-free.",
                            "It is a mandatory requirement to launch a cryptocurrency.",
                            "It provides independent, third-party assurance to clients that the custodian has strong internal controls for protecting assets and data."
                        ],
                        "correct": 3,
                        "explanation": "For institutional clients, a SOC 2 report is a critical piece of due diligence, as it provides a detailed audit of the custodian's security posture, policies, and procedures."
                    }
                ]
            }
        },
        {
            "id": "lesson-44",
            "title": "Emerging Threat Landscape",
            "duration": "75 min",
            "objectives": [
                "Analyze how AI/ML could be used to attack blockchains",
                "Understand the threats of deepfakes and synthetic media in social engineering",
                "Explore the risks of social media manipulation and disinformation campaigns",
                "Recognize potential next-generation consensus attack vectors",
                "Learn about the evolution of threat modeling for complex systems"
            ],
            "content": {
                "overview": "The security landscape is not static. As technology evolves, so do the threats. This lesson looks to the future, exploring emerging attack vectors from AI-powered exploits to sophisticated disinformation campaigns, and how the security community is preparing to meet these next-generation challenges.",
                "sections": [
                    {
                        "title": "AI/ML Attacks on Blockchain",
                        "content": "<p>Artificial intelligence and machine learning can be a double-edged sword. While they can be used defensively for anomaly detection, attackers can also leverage them.</p><h3>Potential Offensive Uses of AI:</h3><ul><li><strong>Vulnerability Detection:</strong> AI models could be trained on massive codebases to automatically find complex or novel vulnerabilities in smart contracts much faster than human auditors.</li><li><strong>MEV Optimization:</strong> Sophisticated AI could be used to create highly efficient MEV searcher bots that can out-compete human-designed bots.</li><li><strong>Adaptive Malware:</strong> AI-powered malware that can change its behavior to evade detection within a project's off-chain infrastructure.</li></ul>",
                       
                    },
                    {
                        "title": "Deepfakes and Social Engineering",
                        "content": "<p>Social engineering remains one of the most effective attack vectors. The rise of convincing deepfake technology (synthetic video and audio) poses a significant new threat.</p><p>Imagine a scenario where an APT creates a deepfake video of a project's CEO instructing an employee to perform an urgent, out-of-band fund transfer for a 'secret partnership'. In a fast-moving startup environment, such a sophisticated and convincing social engineering attack could succeed. This threat requires organizations to implement strict, multi-channel verification procedures for any sensitive action.</p>",
                        "image": "https://www.consultia.co/wp-content/uploads/2023/11/IMG_4565.jpeg"
                    },
                    {
                        "title": "Disinformation and Governance Attacks",
                        "content": "<p>For projects governed by DAOs, the 'court of public opinion' can be a critical attack surface. A well-funded attacker could launch a sophisticated disinformation campaign across social media to damage a project's reputation or to influence the outcome of a contentious governance vote.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Narrative Warfare</strong></div><p>This involves creating fake narratives, using bot farms to amplify them, and swaying community sentiment to achieve a specific outcome, such as voting against a security upgrade or causing a bank run on a DeFi protocol. Defending against this requires strong community management and transparent communication to counter FUD (Fear, Uncertainty, and Doubt).</p></div>",
                       
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "How could an attacker potentially use AI/ML against a smart contract?",
                        "options": [
                            "To make the smart contract more efficient.",
                            "To train a model to automatically discover novel, complex vulnerabilities in the code.",
                            "To lower the gas fees of their transactions.",
                            "To create a user interface for the smart contract."
                        ],
                        "correct": 1,
                        "explanation": "By training on vast datasets of existing code and known vulnerabilities, an AI could potentially identify subtle and complex bugs that are difficult for human auditors to spot."
                    },
                    {
                        "id": 2,
                        "question": "What is the primary threat of deepfake technology in the context of blockchain security?",
                        "options": [
                            "Creating fake NFTs.",
                            "Its use in highly convincing social engineering attacks to trick employees into compromising security.",
                            "Slowing down the blockchain network.",
                            "Manipulating the price of cryptocurrencies."
                        ],
                        "correct": 1,
                        "explanation": "Deepfakes elevate social engineering from text-based phishing to believable audio and video impersonations, making it much harder for individuals to verify the identity of the person they are communicating with."
                    },
                    {
                        "id": 3,
                        "question": "How can a disinformation campaign pose a threat to a DAO?",
                        "options": [
                            "It can directly drain funds from the treasury.",
                            "It has no real impact.",
                            "It can't pose a threat to a DAO.",
                            "It can manipulate community sentiment to influence the outcome of important governance votes."
                        ],
                        "correct": 3,
                        "explanation": "DAO governance relies on informed token holders. A successful FUD campaign could trick the community into voting for a harmful proposal or voting against a necessary one, impacting the protocol's security and future."
                    }
                ]
            }
        },
        {
            "id": "lesson-45",
            "title": "Blockchain Security Research",
            "duration": "60 min",
            "objectives": [
                "Understand the methodology for blockchain security research",
                "Learn about the academic publication and peer review process",
                "Explore the role of industry-academia collaboration",
                "Recognize the importance of open-source security contributions",
                "Discuss research ethics and responsible disclosure"
            ],
            "content": {
                "overview": "The field of blockchain security is constantly advancing thanks to the dedicated work of researchers in both academia and industry. This lesson explores the world of security research, from the methodologies used to discover new vulnerabilities to the ethical guidelines for disclosing them responsibly.",
                "sections": [
                    {
                        "title": "Research Methodology",
                        "content": "<p>Discovering a new class of vulnerability or a novel defense mechanism often follows a structured research process:</p><ol><li><strong>Hypothesis Formulation:</strong> Identifying a potential weakness or a new area of concern (e.g., 'Can MEV be used to influence L2 sequencers?').</li><li><strong>Literature Review:</strong> Studying existing academic papers and industry reports to understand the current state of knowledge.</li><li><strong>Tooling and Experimentation:</strong> Developing new analysis tools or designing experiments to test the hypothesis on real-world blockchain data or in a simulated environment.</li><li><strong>Evaluation and Results:</strong> Analyzing the data from the experiments to prove or disprove the hypothesis.</li><li><strong>Publication and Disclosure:</strong> Writing up the findings for publication and responsibly disclosing any discovered vulnerabilities to the affected projects.</li></ol>",
                        
                    },
                    {
                        "title": "Responsible Disclosure",
                        "content": "<p>When a security researcher finds a critical vulnerability in a live protocol, they have an ethical responsibility to disclose it in a way that minimizes harm. This is known as <strong>responsible disclosure</strong>.</p><h3>The Process:</h3><ul><li><strong>Private Notification:</strong> The researcher first privately reports the vulnerability to the project's development team, providing them with all the technical details.</li><li><strong>Embargo Period:</strong> The researcher and the team agree on a reasonable amount of time (e.g., 30-90 days) for the team to develop and deploy a fix. During this time, the vulnerability is kept secret.</li><li><strong>Public Release:</strong> Once the fix is deployed and users are safe, the researcher is free to publish their findings. This allows the wider community to learn from the vulnerability and protect other projects from similar issues.</li></ul><p>This process ensures that vulnerabilities are fixed before they can be exploited by malicious actors.</p>",
                        "image": "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQSlogboya3cTk82L1D9mmXuGcnLsLe3042HQ&s"
                    },
                    {
                        "title": "Open Source and Community Collaboration",
                        "content": "<p>The security of the blockchain ecosystem is a collaborative, not a competitive, effort. Much of the most important security research and tooling is open source.</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>A Rising Tide Lifts All Boats</strong></div><p>When a security firm develops a new static analysis tool, they often open-source it. When an academic researcher discovers a new attack pattern, they publish it. This open sharing of knowledge and tools is vital. Every disclosed vulnerability, every published post-mortem, and every new open-source tool helps to raise the bar for security across the entire industry, making everyone safer.</p></div>",
                      
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the first step in a responsible disclosure process?",
                        "options": [
                            "Posting the vulnerability on Twitter.",
                            "Privately reporting the vulnerability to the affected project's team.",
                            "Requesting a large payment.",
                            "Exploiting the vulnerability to prove it is real."
                        ],
                        "correct": 1,
                        "explanation": "The cardinal rule of responsible disclosure is to give the project team a private, confidential opportunity to fix the issue before it is made public."
                    },
                    {
                        "id": 2,
                        "question": "What is the purpose of an 'embargo period' after a vulnerability is reported?",
                        "options": [
                            "To give the researcher time to write their report.",
                            "To keep the vulnerability a secret forever.",
                            "To give the development team time to create and deploy a patch before the vulnerability is publicly announced.",
                            "To negotiate the bounty payment."
                        ],
                        "correct": 2,
                        "explanation": "The embargo period is the crucial window where the project can fix the vulnerability without the pressure of it being actively exploited by malicious actors who learned about it from a public disclosure."
                    },
                    {
                        "id": 3,
                        "question": "Why is the open-source nature of many security tools and research important for the blockchain ecosystem?",
                        "options": [
                            "It allows anyone to copy the code and launch their own token.",
                            "It promotes collaboration and allows the entire community to benefit from and build upon new security knowledge.",
                            "It makes the tools free, which is the only consideration.",
                            "It helps hackers find vulnerabilities more easily."
                        ],
                        "correct": 1,
                        "explanation": "Open collaboration on security is a positive-sum game. By sharing research and tools, the community collectively raises its defenses, making the ecosystem as a whole stronger and more resilient."
                    }
                ]
            }
        },
        {
            "id": "lesson-46",
            "title": "Enterprise Blockchain Security",
            "duration": "75 min",
            "objectives": [
                "Understand the security model of permissioned (private) blockchains",
                "Explore the challenges of enterprise key management",
                "Analyze security considerations for integrating with legacy systems",
                "Recognize the importance of identity and access management",
                "Learn about enterprise-grade compliance and data privacy requirements"
            ],
            "content": {
                "overview": "Enterprises are increasingly adopting blockchain technology for applications like supply chain management, trade finance, and identity verification. These enterprise use cases typically involve permissioned blockchains, which have a different set of security challenges and considerations compared to their public, permissionless counterparts.",
                "sections": [
                    {
                        "title": "Permissioned Blockchain Security",
                        "content": "<p>In a permissioned blockchain, not everyone can join the network or act as a validator. Participants are known and must be explicitly granted access. This changes the security model significantly.</p><ul><li><strong>Known Actors:</strong> The consensus mechanism doesn't need to be protected from anonymous Sybil attacks. Instead, it uses protocols like Practical Byzantine Fault Tolerance (pBFT) that are efficient but assume a known, limited number of validators.</li><li><strong>No Cryptocurrency:</strong> Often, there is no native cryptocurrency, so the economic incentives are different. Security is based on the legal and business agreements between the participating organizations.</li><li><strong>Privacy by Default:</strong> Transactions are typically not public. Data privacy is a key requirement, and channels or private data collections are used to restrict visibility to only the transacting parties.</li></ul>",
                        
                    },
                    {
                        "title": "Enterprise Key Management",
                        "content": "<p>In an enterprise setting, managing cryptographic keys is a major operational challenge. Who holds the keys for the organization's identity on the blockchain? How are they secured? How are they rotated or revoked if an employee leaves?</p><p>Enterprises cannot rely on an individual employee's hardware wallet. They require robust <strong>key management solutions</strong>, such as:<ul><li><strong>Hardware Security Modules (HSMs):</strong> Dedicated, tamper-resistant hardware for generating, storing, and using private keys in a secure environment.</li><li><strong>Multi-Party Computation (MPC):</strong> MPC-based wallets are increasingly popular for distributing key shares among different individuals or systems to avoid a single point of failure.</li></ul></p>",
                        "image": "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQL-bEmf8lX-R4Vfxe7wvLap90XK7AI8Q4VGw&s"
                    },
                    {
                        "title": "Integration and Compliance",
                        "content": "<p>Enterprise blockchains do not exist in a vacuum. They must integrate with existing legacy systems (like ERPs and databases) and comply with strict industry regulations.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Key Challenges</strong></div><p><ul><li><strong>Secure Oracles:</strong> The 'oracle problem' is still a major issue. How does the blockchain securely get data from and send data to the company's internal systems? The oracle is a critical point of failure.</li><li><strong>Data Privacy:</strong> Regulations like GDPR must be respected. Storing personally identifiable information (PII) on an immutable ledger is highly problematic, so techniques for off-chain data storage and on-chain verification are essential.</li><li><strong>Identity and Access Management:</strong> The system needs to integrate with the enterprise's existing identity provider to manage user permissions and roles.</li></ul></p></div>",
                      
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is a key difference in the security model of a permissioned blockchain compared to a public one?",
                        "options": [
                            "Permissioned blockchains are less secure.",
                            "Participants are known and trusted, so the system doesn't need to defend against anonymous Sybil attacks.",
                            "Permissioned blockchains are fully transparent to the public.",
                            "There is no difference."
                        ],
                        "correct": 1,
                        "explanation": "In a permissioned network, access is restricted to a set of known entities. This allows for more efficient consensus algorithms and a security model based on legal agreements rather than purely crypto-economic incentives."
                    },
                    {
                        "id": 2,
                        "question": "Why is storing personal data (PII) directly on an immutable enterprise blockchain a bad idea?",
                        "options": [
                            "It uses too much storage.",
                            "It violates regulations like GDPR, which include a 'right to be forgotten' that is incompatible with immutability.",
                            "It slows down the network.",
                            "It is technically impossible."
                        ],
                        "correct": 1,
                        "explanation": "The immutable nature of blockchain directly conflicts with data privacy rights like the right to erasure. The best practice is to store PII off-chain and only record hashes or proofs on-chain."
                    },
                    {
                        "id": 3,
                        "question": "What kind of tool would a large enterprise use to securely manage the private keys for its blockchain identity?",
                        "options": [
                            "A browser extension wallet like MetaMask.",
                            "A text file on the CIO's computer.",
                            "A dedicated Hardware Security Module (HSM) or an MPC-based wallet solution.",
                            "A paper wallet stored in the office."
                        ],
                        "correct": 2,
                        "explanation": "Enterprises require institutional-grade security for key management that provides audit trails, access control, and eliminates single points of failure, which is what HSMs and MPC wallets are designed for."
                    }
                ]
            }
        },
        {
            "id": "lesson-47",
            "title": "Blockchain Security Economics",
            "duration": "75 min",
            "objectives": [
                "Understand the principles of security incentive design",
                "Learn how to perform an economic attack analysis",
                "Explore the role of mechanism design in protocol security",
                "Apply game theory concepts to blockchain security",
                "Analyze security investment and bug bounty optimization"
            ],
            "content": {
                "overview": "The security of public blockchains is not just about cryptography; it's a field of applied economics. These systems are designed to make honesty more profitable than dishonesty. This lesson delves into crypto-economics and game theory to analyze how economic incentives are used to secure the network and how attackers can try to exploit them.",
                "sections": [
                    {
                        "title": "Game Theory and Incentive Design",
                        "content": "<p>Blockchains can be viewed as a game with many rational, self-interested players (users, miners, validators). The protocol's rules are designed to align individual incentives with the overall health of the network.</p><p>For example, in Proof-of-Work, miners are rewarded for extending the honest chain and penalized (by wasting electricity) for mining on a dishonest one. In Proof-of-Stake, validators are rewarded for correct behavior and have their stake 'slashed' (taken away) for misbehavior like being offline or signing a fraudulent block. The security assumption is that the majority of players will act honestly because it is in their economic best interest.</p>",
                       
                    },
                    {
                        "title": "Economic Attack Analysis",
                        "content": "<p>An economic attack doesn't break the cryptography, but rather exploits the protocol's economic rules to the attacker's benefit. Analyzing a protocol's security involves calculating the cost and profit of potential attacks.</p><h3>Example: The 51% Attack Cost</h3><p>The cost to perform a 51% attack on Bitcoin isn't just the cost of acquiring the hardware; it's the ongoing electricity cost to overpower the entire rest of the network. Furthermore, a successful attack would likely crash the price of Bitcoin, destroying the value of the very asset the attacker is trying to manipulate and the mining hardware they acquired. A rational attacker must believe the profit from the double-spend will be greater than the immense cost of the attack and the resulting collapse in asset value.</p>",
                        "image": "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSJ_n5UFAjBJL2gDY_kUMqHFB5-0Kli5KxmUg&s"
                    },
                    {
                        "title": "Bug Bounties and Security Investment",
                        "content": "<p>The economics of defense are also critical. A bug bounty program is an economic tool designed to make it more profitable for a white-hat hacker to report a bug than to exploit it or sell it on the black market.</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>Optimizing Bounties</strong></div><p>If a protocol has $100 million in total value locked (TVL), offering a $10,000 bounty for a critical bug is not a sufficient incentive. The potential reward from exploiting the bug is far greater. The size of the bug bounty should be proportional to the value at risk. Projects like ImmuneFi have helped to standardize this, with critical bounties often reaching $1 million or more for major protocols, creating a strong economic incentive for ethical hacking.</p></div>",
                       
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is the core principle of crypto-economic security?",
                        "options": [
                            "Using the most advanced cryptography available.",
                            "Designing the protocol so that honest participation is more profitable than dishonest participation.",
                            "Hiring a large team of security auditors.",
                            "Keeping the source code of the protocol closed."
                        ],
                        "correct": 1,
                        "explanation": "Crypto-economics uses a combination of cryptography and economic incentives (rewards and penalties) to secure a network, assuming that most participants will act in their own rational self-interest."
                    },
                    {
                        "id": 2,
                        "question": "What is 'slashing' in a Proof-of-Stake network?",
                        "options": [
                            "A type of transaction.",
                            "A reward given to validators for good behavior.",
                            "An economic penalty where a misbehaving validator has a portion of their staked capital taken away.",
                            "A bug in the client software."
                        ],
                        "correct": 2,
                        "explanation": "Slashing is the primary disincentive against misbehavior in PoS. It makes attacks costly and ensures validators have a strong economic reason to follow the protocol rules."
                    },
                    {
                        "id": 3,
                        "question": "From an economic perspective, what is the purpose of a large bug bounty?",
                        "options": [
                            "To serve as a marketing expense.",
                            "To create a strong financial incentive for ethical hackers to report vulnerabilities responsibly rather than exploit them.",
                            "To fulfill a legal requirement.",
                            "To pay for a security audit."
                        ],
                        "correct": 1,
                        "explanation": "A bug bounty program is a competitive marketplace. To attract top talent and ensure bugs are reported, the reward for responsible disclosure must be competitive with the potential profit from exploitation."
                    }
                ]
            }
        },
        {
            "id": "lesson-48",
            "title": "Multi-Chain Security Architecture",
            "duration": "75 min",
            "objectives": [
                "Understand the security challenges of a multi-chain environment",
                "Analyze the security models of cross-chain communication protocols",
                "Explore the architecture of multi-chain wallets and their risks",
                "Learn about the concept of chain abstraction and its security implications",
                "Discuss the need for universal security frameworks and standards"
            ],
            "content": {
                "overview": "The blockchain world is no longer about a single chain, but a universe of interconnected networks. Users interact with dozens of L1s, L2s, and appchains, creating a fragmented and complex security environment. This lesson explores the challenges of securing assets and identity across a multi-chain landscape and the emerging architectures designed to solve them.",
                "sections": [
                    {
                        "title": "The Fragmented Security Landscape",
                        "content": "<p>As a user, interacting with multiple chains means managing multiple private keys, understanding different wallet software, paying gas in different native tokens, and being aware of the unique security risks of each ecosystem.</p><h3>User Challenges:</h3><ul><li><strong>Increased Attack Surface:</strong> Every new chain, bridge, and wallet a user interacts with is another potential point of failure.</li><li><strong>Bridge Risk:</strong> The security of an asset is only as strong as the bridge it has crossed. A wrapped BTC on a different chain is not Bitcoin; it is a claim on Bitcoin held by the bridge, and it carries the risk of that bridge being exploited.</li><li><strong>User Experience Complexity:</strong> The cognitive overhead of managing assets across so many networks can lead to user error, a major source of fund loss.</li></ul>",
                        
                    },
                    {
                        "title": "Multi-Chain Wallets and Key Management",
                        "content": "<p>Modern smart contract wallets are designed to improve the multi-chain user experience, but they also introduce new security considerations.</p><ul><li><strong>Smart Contract Wallets:</strong> These wallets are themselves smart contracts, enabling features like social recovery, daily spending limits, and batching transactions. However, this also means the wallet itself has smart contract risk.</li><li><strong>Multi-Party Computation (MPC):</strong> MPC wallets distribute key shares, which can provide excellent security without a single seed phrase. The security, however, is dependent on the security of the MPC provider and the protocol they use.</li><li><strong>Account Abstraction (ERC-4337):</strong> This standard allows users to have smart contract accounts with customizable verification logic, potentially enabling a single 'smart account' to control assets on multiple chains with a unified security policy.</li></ul>",
                        "image": "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQMW8JbUERGuarFYMGFL1rxvA-vPFAk5g471g&s"
                    },
                    {
                        "title": "Chain Abstraction",
                        "content": "<p><strong>Chain abstraction</strong> is the end-goal of the multi-chain user experience. It's the idea that a user shouldn't have to know or care which chain their transaction is happening on. They should be able to interact with any dApp on any chain from a single wallet, with gas fees and bridging handled automatically in the background.</p><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>The Security Challenge</strong></div><p>While powerful for usability, chain abstraction can obscure risk. If the background routing uses a new, insecure cross-chain bridge, the user's assets could be exposed without their direct knowledge. The security of a chain abstraction layer depends entirely on the security of the underlying messaging protocols and bridges it utilizes.</p></div>",
                       
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is a primary security risk for users in a multi-chain world?",
                        "options": [
                            "The user interface is too simple.",
                            "The security of their assets is only as strong as the weakest bridge they have used.",
                            "There are too few dApps to use.",
                            "Transaction fees are the same on every chain."
                        ],
                        "correct": 1,
                        "explanation": "When you bridge an asset, you are swapping it for a synthetic version backed by the bridge. If that bridge is hacked, the wrapped asset can become worthless, even if the original chain and the destination chain are perfectly secure."
                    },
                    {
                        "id": 2,
                        "question": "What is the main security benefit of a smart contract wallet?",
                        "options": [
                            "It has no private keys.",
                            "It enables advanced security features like social recovery and spending limits.",
                            "It is completely immune to hacking.",
                            "It is managed by a centralized company."
                        ],
                        "correct": 1,
                        "explanation": "Unlike a standard EOA, a smart contract wallet's logic is programmable, allowing for more sophisticated security policies beyond just a single seed phrase."
                    },
                    {
                        "id": 3,
                        "question": "What is the security challenge of 'chain abstraction'?",
                        "options": [
                            "It makes using dApps more difficult.",
                            "It can hide the underlying risks of the bridges and protocols being used to route transactions.",
                            "It requires users to manage many different seed phrases.",
                            "It only works with a single blockchain."
                        ],
                        "correct": 1,
                        "explanation": "By automating the multi-chain experience, chain abstraction layers might make it less obvious to a user when they are relying on a potentially insecure, third-party bridge, thus obscuring the true risk profile of their transaction."
                    }
                ]
            }
        },
        {
            "id": "lesson-49",
            "title": "Blockchain Security Automation",
            "duration": "75 min",
            "objectives": [
                "Understand the role of automated security testing in the development lifecycle",
                "Learn how to integrate security tools into CI/CD pipelines",
                "Explore the principles of Security-as-Code for blockchain",
                "Analyze the architecture of automated threat response systems",
                "Describe the function of security orchestration platforms"
            ],
            "content": {
                "overview": "As blockchain development becomes more professional, security is shifting from a one-off audit at the end of the cycle to a continuous, automated process. This lesson explores the principles of DevSecOps in a blockchain context, covering how to automate testing, monitoring, and even incident response to build more secure systems faster.",
                "sections": [
                    {
                        "title": "Continuous Security Integration (CI/CD)",
                        "content": "<p>A CI/CD (Continuous Integration/Continuous Deployment) pipeline automates the process of building, testing, and deploying code. Integrating security tools directly into this pipeline ensures that security checks are run automatically every time a developer commits new code.</p><h3>Example Pipeline Stages:</h3><ol><li>A developer pushes a code change to a smart contract.</li><li>The CI pipeline automatically triggers.</li><li>It compiles the code.</li><li>It runs unit tests and integration tests.</li><li><strong>Security Scan:</strong> It automatically runs a static analysis tool like Slither. If Slither finds a high-severity issue, the build fails, preventing the vulnerable code from being merged.</li><li>If all checks pass, the code is deployed to a testnet for further testing.</li></ol>",
                       
                    },
                    {
                        "title": "Security-as-Code Practices",
                        "content": "<p>Security-as-Code is the practice of managing and provisioning security policies using code and automation. Instead of manually configuring security settings, you define them in code that can be version-controlled, reviewed, and automatically applied.</p><ul><li><strong>Fuzzing Invariants:</strong> Writing the security properties for a fuzzing tool (like Echidna) as code that lives alongside the contract code.</li><li><strong>Monitoring Alerts:</strong> Defining the conditions for a security alert (e.g., 'alert if this contract's balance changes by more than 10% in one block') in a configuration file rather than a web UI.</li><li><strong>Infrastructure Configuration:</strong> Using tools like Terraform to define the security rules (e.g., firewall settings) for blockchain nodes as code.</li></ul>",
                        "image": "https://www.mdpi.com/sensors/sensors-22-07535/article_deploy/html/images/sensors-22-07535-g001.png"
                    },
                    {
                        "title": "Automated Threat Response",
                        "content": "<p>Automation is also becoming key to incident response, where speed is critical. Security Orchestration, Automation, and Response (SOAR) platforms are used to coordinate actions when a threat is detected.</p><div class='info-box note'><div class='info-box-header'><i class='fas fa-info-circle'></i><strong>SOAR Workflow Example</strong></div><p>_A monitoring bot detects a suspicious, large withdrawal transaction in the mempool._<ol><li>The bot sends an alert to a SOAR platform.</li><li>The platform automatically enriches the alert with threat intelligence data on the source address.</li><li>It executes a pre-defined 'playbook': it initiates a vote with a multi-sig wallet to pause the contract and pages the on-call engineer.</li><li>The engineer receives the alert with all the context and can approve the pause action with a single click.</li></ol>This combination of automation and human-in-the-loop approval allows for extremely rapid and controlled responses.</p></div>",
                        
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is a primary benefit of integrating a static analysis tool like Slither into a CI/CD pipeline?",
                        "options": [
                            "It guarantees the code is 100% bug-free.",
                            "It automatically fixes any bugs it finds.",
                            "It provides continuous, automated security checks on every code change, catching common vulnerabilities early.",
                            "It makes the deployment process slower."
                        ],
                        "correct": 2,
                        "explanation": "Automating security scans in the CI/CD pipeline is a core principle of DevSecOps. It helps to 'shift security left', catching issues early in the development cycle when they are cheaper and easier to fix."
                    },
                    {
                        "id": 2,
                        "question": "The practice of defining fuzzing properties and monitoring alerts in version-controlled configuration files is known as...?",
                        "options": [
                            "Agile development",
                            "Security-as-Code",
                            "Waterfall development",
                            "Manual testing"
                        ],
                        "correct": 1,
                        "explanation": "Security-as-Code treats security configuration with the same rigor as application code, allowing for peer review, versioning, and automated deployment of security policies."
                    },
                    {
                        "id": 3,
                        "question": "What is the role of a 'playbook' in an automated threat response system?",
                        "options": [
                            "A document explaining the project's security features to users.",
                            "A marketing plan for the project.",
                            "A set of pre-defined, automated steps to be executed when a specific type of security alert is triggered.",
                            "The source code of the smart contract."
                        ],
                        "correct": 2,
                        "explanation": "A playbook codifies the incident response process. For a given alert, it defines exactly what automated actions should be taken (e.g., enrich data, notify team, create multi-sig proposal) to ensure a fast and consistent response."
                    }
                ]
            }
        },
        {
            "id": "lesson-50",
            "title": "Future of Blockchain Security",
            "duration": "60 min",
            "objectives": [
                "Discuss emerging security paradigms and future challenges",
                "Analyze the long-term impact of post-quantum cryptography on blockchain design",
                "Explore the potential of AI-enhanced security systems (defensive and offensive)",
                "Consider the impact of evolving regulations on security practices",
                "Develop a mindset for long-term strategic security planning"
            ],
            "content": {
                "overview": "The only constant in security is change. This final lesson looks to the horizon, discussing the major technological and social trends that will shape the future of blockchain security. From the race to become quantum-resistant to the rise of AI, we will explore the challenges and opportunities that lie ahead for securing the decentralized web.",
                "sections": [
                    {
                        "title": "The Post-Quantum Transition",
                        "content": "<p>The transition to post-quantum cryptography (PQC) will be one of the most significant security upgrades in the history of the internet, and blockchains are no exception. The key challenge will be migrating live, multi-billion dollar networks to new signature and hashing algorithms.</p><p>Future blockchains will likely be designed with cryptographic agility from day one. For existing chains, the transition will be a multi-year process involving hard forks, hybrid signature schemes, and a massive coordination effort across the entire ecosystem, from client developers to wallet providers and end-users.</p>",
                        
                    },
                    {
                        "title": "AI-Enhanced Security Systems",
                        "content": "<p>The future of blockchain security will be an arms race increasingly dominated by AI. Defensively, AI will become indispensable for detecting novel threats.</p><ul><li><strong>AI Auditors:</strong> AI models will continuously scan smart contracts for vulnerabilities, acting as a tireless partner to human auditors.</li><li><strong>Proactive Threat Hunting:</strong> AI will be able to analyze vast on-chain datasets to predict which protocols are most at risk of an economic exploit before it happens.</li><li><strong>Adaptive Defense:</strong> Smart contracts or protocols could use AI to dynamically adjust their own risk parameters (like collateral ratios) in real-time based on observed market-wide threats.</li></ul><p>Simultaneously, attackers will use AI to find exploits and coordinate attacks, making the defensive use of AI a necessity, not a luxury.</p>",
                        "image": "https://nix-united.com/wp-content/uploads/2021/05/Blockchain_graphics8_02.jpg"
                    },
                    {
                        "title": "The Evolution of Trust and Strategy",
                        "content": "<p>As the technology matures, the definition of 'security' will continue to broaden. It will be less about preventing specific bugs and more about building resilient, adaptable systems that can gracefully handle failure.</p><div class='info-box tip'><div class='info-box-header'><i class='fas fa-lightbulb'></i><strong>Future Security Principles</strong></div><p><ul><li><strong>Assume Vulnerability:</strong> No system is perfect. Design for containment and rapid response.</li><li><strong>Formal Verification for Critical Components:</strong> As tools mature, formal verification will become standard for core protocol logic and DeFi primitives.</li><li><strong>Decentralization as a Social Defense:</strong> A truly decentralized and engaged community will remain the ultimate defense against censorship and malicious governance.</li><li><strong>Proactive Adaptation:</strong> The most secure projects will be those that can anticipate and adapt to new threats, regulations, and technological paradigms.</li></ul></p></div>",
                       
                    }
                ]
            },
            "quiz": {
                "passingScore": 75,
                "questions": [
                    {
                        "id": 1,
                        "question": "What is predicted to be the most significant, long-term technical challenge for blockchain security?",
                        "options": [
                            "Improving user interface design.",
                            "Migrating existing blockchains to be resistant to quantum computers.",
                            "Lowering transaction fees.",
                            "Increasing the block size."
                        ],
                        "correct": 1,
                        "explanation": "The transition to post-quantum cryptography is a massive and complex undertaking that will require fundamental changes to core blockchain protocols and years of coordinated effort."
                    },
                    {
                        "id": 2,
                        "question": "How is AI expected to impact blockchain security in the future?",
                        "options": [
                            "It will have no impact.",
                            "It will become a critical tool for both attackers (to find exploits) and defenders (to detect threats).",
                            "It will solve all security problems automatically.",
                            "It will only be used for defensive purposes."
                        ],
                        "correct": 1,
                        "explanation": "AI will likely become a key part of the security landscape on both sides, leading to an arms race where AI-powered defensive systems are required to counter AI-powered attacks."
                    },
                    {
                        "id": 3,
                        "question": "What is a key principle for building a secure blockchain protocol for the long term?",
                        "options": [
                            "Moving as fast as possible to capture market share.",
                            "Centralizing control for efficiency.",
                            "Assuming the protocol will never have a bug after it is audited once.",
                            "Designing the system to be resilient and adaptable, assuming that vulnerabilities will eventually be found."
                        ],
                        "correct": 3,
                        "explanation": "A mature approach to security acknowledges that no system is perfect and prioritizes resilience, rapid response, and the ability to adapt to new threats over the illusion of creating an 'unhackable' system."
                    }
                ]
            }
        }
    ]
}
      // =====================================================
      // GLOBAL VARIABLES
      // =====================================================
      let currentUser = null;
      let currentLessonIndex = 0;
      let courseProgress = {};
      let userStats = {};
      let quizState = {
        currentQuestion: 0,
        answers: [],
        score: 0,
        isComplete: false,
      };

      // Enhanced session tracking
      let courseSession = {
        startTime: null,
        totalStudyTime: 0,
        lessonsStarted: 0,
        lessonsCompleted: 0,
        pageLoadTime: new Date(),
        interactionCount: 0,
        lastActivityTime: new Date(),
      };

      // Music Player Variables
      let audioPlayer = new Audio();

      // Achievement notification system
      let notificationQueue = [];
      let isShowingNotification = false;

      // =====================================================
      // INITIALIZATION
      // =====================================================
      document.addEventListener("DOMContentLoaded", async () => {
        try {
          showLoadingScreen();
          await checkAuth();

          if (currentUser) {
            // Initialize session tracking
            startCourseSession();

            // Load course data and progress
            await loadCourseData();
            await loadUserProfile();
            await loadProgress();

            // Initialize UI
            initializeEventListeners();
            renderSidebar();
            loadLesson(currentLessonIndex);

            // Initialize additional features
            initMusicPlayer();
            addMusicIndicator();
            initializeActivityTracking();

            hideLoadingScreen();
          } else {
            openAuthModal();
          }
        } catch (error) {
          console.error("Error initializing course:", error);
          hideLoadingScreen();
          showToast("Failed to initialize course system", "error");
        }
      });

      // =====================================================
      // AUTHENTICATION SYSTEM
      // =====================================================
      async function checkAuth() {
        try {
          const {
            data: { session },
            error,
          } = await supabase.auth.getSession();

          if (error) {
            console.error("Auth error:", error);
            currentUser = null;
            openAuthModal();
            return;
          }

          if (!session) {
            currentUser = null;
            openAuthModal();
            return;
          }

          currentUser = session.user;
          updateUIWithUser();
        } catch (error) {
          console.error("Error checking auth:", error);
          currentUser = null;
          openAuthModal();
        }
      }

      function updateUIWithUser() {
        if (!currentUser) return;

        const name =
          currentUser.user_metadata?.full_name ||
          currentUser.email.split("@")[0];
        const userElements = document.querySelectorAll("[data-user-name]");
        userElements.forEach((el) => (el.textContent = name));
      }

      // =====================================================
      // USER PROFILE & STATS MANAGEMENT
      // =====================================================
      async function loadUserProfile() {
        try {
          // 🔍 Step 1: Try to fetch existing profile
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("*")
            .eq("id", currentUser.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (!profile) {
            // 🆕 Step 2: Create new profile if missing
            await createUserProfile();
          } else {
            // ✅ Step 3: Use existing profile
            userStats = profile;
            await updateLastActivity();
          }
        } catch (error) {
          console.error("❌ Error loading user profile:", error);
          showToast("Failed to load user profile", "error");
        }
      }
      async function createUserProfile() {
        try {
          const newProfile = {
            id: currentUser.id,
            full_name: currentUser.user_metadata?.full_name || "",
            email: currentUser.email,
            level: "Script Kiddie",
            total_points: 0,
            completed_courses: 0,
            current_streak: 0,
            total_certificates: 0,
            total_achievements: 0,
            sections_visited: 0,
            bonus_points: 0,
            in_progress_courses: 0,
            settings_changed: 0,
            midnight_sessions: 0,
            early_sessions: 0,
            weekend_sessions: 0,
            last_activity: new Date().toISOString(),
            created_at: new Date().toISOString(),
          };

          const { error } = await supabase
            .from("profiles")
            .insert([newProfile]);

          if (!error) {
            userStats = newProfile;
            // Award first login achievement
            setTimeout(() => checkAndUnlockAchievement("first_login"), 1000);
          }
        } catch (error) {
          console.error("Error creating user profile:", error);
        }
      }

      async function updateLastActivity() {
        try {
          const now = new Date();

          // Update activity tracking
          courseSession.lastActivityTime = now;

          // Update database
          await supabase
            .from("profiles")
            .update({
              last_activity: now.toISOString(),
            })
            .eq("id", currentUser.id);

          // Check time-based achievements
          await checkTimeBasedAchievements(now);
        } catch (error) {
          console.error("Error updating last activity:", error);
        }
      }

      // =====================================================
      // COURSE SESSION MANAGEMENT
      // =====================================================
      function startCourseSession() {
        courseSession.startTime = new Date();
        courseSession.pageLoadTime = new Date();

        logUserActivity("course_session_start", {
          course_id: COURSE_DATA.id,
          course_title: COURSE_DATA.title,
          user_agent: navigator.userAgent,
          screen_resolution: `${screen.width}x${screen.height}`,
        });

        // Check daily streak
        checkDailyStreak();
      }

      function initializeActivityTracking() {
        // Track page focus/blur for accurate study time
        document.addEventListener("visibilitychange", handleVisibilityChange);

        // Track user interactions
        ["click", "keydown", "scroll", "mousemove"].forEach((event) => {
          document.addEventListener(event, trackUserInteraction, {
            passive: true,
          });
        });

        // Periodic activity updates
        setInterval(updateStudyTime, 60000); // Every minute

        // Save session data before page unload
        window.addEventListener("beforeunload", saveSessionData);
      }

      function handleVisibilityChange() {
        if (document.hidden) {
          courseSession.lastActivityTime = new Date();
        } else {
          // Page became visible again - update activity
          updateLastActivity();
        }
      }

      function trackUserInteraction() {
        courseSession.interactionCount++;
        courseSession.lastActivityTime = new Date();

        // Throttle activity updates
        if (courseSession.interactionCount % 50 === 0) {
          updateLastActivity();
        }
      }

      function updateStudyTime() {
        if (!courseSession.startTime || document.hidden) return;

        const now = new Date();
        const sessionDuration = now - courseSession.startTime;
        courseSession.totalStudyTime = Math.floor(sessionDuration / 1000 / 60); // in minutes

        // Update progress with study time
        saveProgress();
      }

      function saveSessionData() {
        if (!currentUser || !courseSession.startTime) return;

        const sessionData = {
          user_id: currentUser.id,
          course_id: COURSE_DATA.id,
          session_duration: courseSession.totalStudyTime,
          lessons_viewed: courseSession.lessonsStarted,
          lessons_completed: courseSession.lessonsCompleted,
          interactions: courseSession.interactionCount,
          session_date: courseSession.startTime.toISOString().split("T")[0],
        };

        // Store in localStorage as backup
        localStorage.setItem(
          "course_session_backup",
          JSON.stringify(sessionData)
        );

        // Try to save to database
        logUserActivity("course_session_end", sessionData);
      }

      // =====================================================
      // COURSE DATA & PROGRESS MANAGEMENT
      // =====================================================
      async function loadCourseData() {
        try {
          // Update course info in UI
          document.getElementById("courseTitle").textContent =
            COURSE_DATA.title;
          document.getElementById("totalLessons").textContent =
            COURSE_DATA.lessons.length;

          // Log course access
          logUserActivity("course_access", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
          });
        } catch (error) {
          console.error("Error loading course data:", error);
        }
      }

      async function loadProgress() {
        try {
          // Get existing progress from database
          const { data, error } = await supabase
            .from("course_progress")
            .select("*")
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (data) {
            courseProgress = JSON.parse(data.lesson_progress || "{}");
            currentLessonIndex = data.current_lesson || 0;

            // Update session tracking
            courseSession.lessonsStarted = Object.keys(courseProgress).length;
            courseSession.lessonsCompleted = Object.values(
              courseProgress
            ).filter((p) => p.completed).length;
          } else {
            // Initialize new progress
            courseProgress = {};
            currentLessonIndex = 0;
            await saveProgress();

            // Award first course start achievement
            await checkAndUnlockAchievement("first_course_start");
          }

          updateProgressDisplay();
        } catch (error) {
          console.error("Error loading progress:", error);
          showToast("Failed to load progress", "error");
        }
      }

      async function saveProgress() {
        try {
          if (!currentUser) return;

          const now = new Date();
          const progressData = {
            user_id: currentUser.id,
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            current_lesson: currentLessonIndex,
            lesson_progress: JSON.stringify(courseProgress),
            progress: calculateOverallProgress(),
            lessons_completed: getCompletedLessonsCount(),
            lessons_started: Object.keys(courseProgress).length,
            study_time_minutes: courseSession.totalStudyTime,
            last_accessed: now.toISOString(),
            updated_at: now.toISOString(),
          };

          // Upsert progress
          const { error } = await supabase
            .from("course_progress")
            .upsert([progressData]);

          if (error) throw error;

          // Update user stats
          await updateUserStats();

          updateProgressDisplay();
        } catch (error) {
          console.error("Error saving progress:", error);
          showToast("Failed to save progress", "error");
        }
      }

      async function updateUserStats() {
        try {
          // Get all course progress for this user
          const { data: allProgress, error } = await supabase
            .from("course_progress")
            .select("progress, course_id, study_time_minutes")
            .eq("user_id", currentUser.id);

          if (error) throw error;

          // Calculate stats
          const completedCourses =
            allProgress?.filter((p) => p.progress >= 100).length || 0;
          const inProgressCourses =
            allProgress?.filter((p) => p.progress > 0 && p.progress < 100)
              .length || 0;
          const totalStudyTime =
            allProgress?.reduce(
              (sum, p) => sum + (p.study_time_minutes || 0),
              0
            ) || 0;

          // Calculate points (500 per completed course + achievement points)
          const coursePoints = completedCourses * 500;
          const bonusPoints = userStats.bonus_points || 0;
          const totalPoints = coursePoints + bonusPoints;

          // Update profile
          const updateData = {
            completed_courses: completedCourses,
            in_progress_courses: inProgressCourses,
            total_points: totalPoints,
            total_study_time: totalStudyTime,
            last_activity: new Date().toISOString(),
          };

          const { error: updateError } = await supabase
            .from("profiles")
            .update(updateData)
            .eq("id", currentUser.id);

          if (updateError) throw updateError;

          // Update local stats
          Object.assign(userStats, updateData);
        } catch (error) {
          console.error("Error updating user stats:", error);
        }
      }

      function calculateOverallProgress() {
        const completedLessons = getCompletedLessonsCount();
        return Math.round(
          (completedLessons / COURSE_DATA.lessons.length) * 100
        );
      }

      function getCompletedLessonsCount() {
        return Object.values(courseProgress).filter(
          (lesson) => lesson.completed
        ).length;
      }

      function updateProgressDisplay() {
        const completedCount = getCompletedLessonsCount();
        const progressPercent = calculateOverallProgress();

        // Update UI elements
        const elements = {
          completedLessons: completedCount,
          courseProgressPercent: `${progressPercent}%`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });

        // Update progress bar
        const progressBar = document.getElementById("courseProgressFill");
        if (progressBar) progressBar.style.width = `${progressPercent}%`;
      }

      // =====================================================
      // LESSON MANAGEMENT
      // =====================================================
      function loadLesson(index) {
        if (index < 0 || index >= COURSE_DATA.lessons.length) return;

        const lesson = COURSE_DATA.lessons[index];
        currentLessonIndex = index;

        // Mark lesson as started and track activity
        if (!courseProgress[lesson.id]) {
          courseProgress[lesson.id] = {
            started: true,
            completed: false,
            startedAt: new Date().toISOString(),
            timeSpent: 0,
          };

          courseSession.lessonsStarted++;
          saveProgress();

          // Log lesson start
          logUserActivity("lesson_start", {
            lesson_id: lesson.id,
            lesson_title: lesson.title,
            lesson_index: index,
          });
        }

        // Update lesson start time for time tracking
        courseProgress[lesson.id].currentSessionStart = new Date();

        // Update sidebar and navigation
        renderSidebar();
        updateNavigationButtons();

        // Update header info
        updateLessonHeader(lesson, index);

        // Render lesson content
        renderLessonContent(lesson);

        // Smooth scroll and animations
        window.scrollTo({ top: 0, behavior: "smooth" });
        document.getElementById("contentBody").scrollTop = 0;

        const contentBody = document.getElementById("contentBody");
        contentBody.classList.add("fade-in");
        setTimeout(() => contentBody.classList.remove("fade-in"), 500);

        // Check lesson-based achievements
        checkLessonAchievements(index + 1);
      }

      function updateLessonHeader(lesson, index) {
        const elements = {
          currentLessonNumber: index + 1,
          currentLessonTitle: lesson.title,
          navInfo: `Lesson ${index + 1} of ${COURSE_DATA.lessons.length}`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });
      }

      function renderSidebar() {
        const lessonNav = document.getElementById("lessonNav");
        if (!lessonNav) return;

        lessonNav.innerHTML = "";

        COURSE_DATA.lessons.forEach((lesson, index) => {
          const lessonItem = document.createElement("div");
          lessonItem.className = "lesson-item";

          // Determine lesson status
          const lessonProgress = courseProgress[lesson.id];
          const isCompleted = lessonProgress?.completed || false;
          const isInProgress = lessonProgress?.started || false;
          const isLocked = !isCompleted && !canAccessLesson(index);
          const isActive = index === currentLessonIndex;

          // Apply status classes
          if (isCompleted) lessonItem.classList.add("completed");
          if (isLocked) lessonItem.classList.add("locked");
          if (isActive) lessonItem.classList.add("active");

          // Determine status display
          let statusClass = "not-started";
          let statusIcon = index + 1;

          if (isCompleted) {
            statusClass = "completed";
            statusIcon = "✓";
          } else if (isInProgress) {
            statusClass = "in-progress";
            statusIcon = "◐";
          }

          // Create lesson item HTML
          lessonItem.innerHTML = `
            <div class="lesson-status ${statusClass}">${statusIcon}</div>
            <div class="lesson-info">
                <div class="lesson-title">${lesson.title}</div>
                <div class="lesson-meta">
                    ${
                      isCompleted
                        ? "Completed"
                        : isInProgress
                        ? "In Progress"
                        : isLocked
                        ? "Locked"
                        : "Not Started"
                    }
                </div>
            </div>
            <div class="lesson-duration">${lesson.duration}</div>
        `;

          // Add click handler if not locked
          if (!isLocked) {
            lessonItem.addEventListener("click", () => {
              if (index !== currentLessonIndex) {
                // Track lesson time before switching
                trackLessonTime();

                currentLessonIndex = index;
                loadLesson(index);
                closeSidebar();
              }
            });
          }

          lessonNav.appendChild(lessonItem);
        });
      }

      function canAccessLesson(index) {
        if (index === 0) return true; // First lesson always accessible

        // Can access if previous lesson is completed
        const previousLessonId = COURSE_DATA.lessons[index - 1].id;
        return courseProgress[previousLessonId]?.completed || false;
      }

      function trackLessonTime() {
        const currentLesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonProgress = courseProgress[currentLesson.id];

        if (lessonProgress?.currentSessionStart) {
          const sessionTime = Math.floor(
            (new Date() - new Date(lessonProgress.currentSessionStart)) /
              1000 /
              60
          );
          lessonProgress.timeSpent =
            (lessonProgress.timeSpent || 0) + sessionTime;
          delete lessonProgress.currentSessionStart;
        }
      }

      // =====================================================
      // LESSON CONTENT RENDERING
      // =====================================================
      function renderLessonContent(lesson) {
        const contentContainer = document.getElementById("lessonContent");
        if (!contentContainer) return;

        let contentHTML = `
        <div class="content-section">
            <h2>Learning Objectives</h2>
            <ul>
                ${lesson.objectives.map((obj) => `<li>${obj}</li>`).join("")}
            </ul>
        </div>
        
        <div class="content-section">
            <h2>Overview</h2>
            <p>${lesson.content.overview}</p>
        </div>
    `;

        // Render content sections
        lesson.content.sections.forEach((section) => {
          contentHTML += `
            <div class="content-section">
                <h2>${section.title}</h2>
                ${section.content}
                ${
                  section.image
                    ? `<img src="${section.image}" alt="${section.title}" class="content-image" loading="lazy">`
                    : ""
                }
            </div>
        `;
        });

        // Render code examples
        if (
          lesson.content.codeExamples &&
          lesson.content.codeExamples.length > 0
        ) {
          contentHTML += `<div class="content-section"><h2>Code Examples</h2></div>`;

          lesson.content.codeExamples.forEach((example, index) => {
            const codeId = `code-${lesson.id}-${index}`;
            contentHTML += `
                <div class="code-section">
                    <div class="code-header">
                        <span class="code-title">${example.title}</span>
                        <button class="copy-btn" onclick="copyCode('${codeId}')">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <pre class="code-block"><code id="${codeId}" class="language-${
              example.language
            }">${escapeHtml(example.code)}</code></pre>
                </div>
            `;
          });
        }

        // Render quiz
        contentHTML += renderQuiz(lesson.quiz);

        contentContainer.innerHTML = contentHTML;

        // Highlight code syntax if Prism is available
        setTimeout(() => {
          if (window.Prism) {
            Prism.highlightAll();
          }
        }, 100);
      }

      // =====================================================
      // QUIZ SYSTEM
      // =====================================================
      function renderQuiz(quiz) {
        const currentLessonProgress =
          courseProgress[COURSE_DATA.lessons[currentLessonIndex].id];
        const isCompleted = currentLessonProgress?.completed || false;

        let quizHTML = `
        <div class="quiz-section" id="quizSection">
            <div class="quiz-header">
                <h2 class="quiz-title">
                    <i class="fas fa-clipboard-check"></i>
                    Knowledge Check
                </h2>
                <p class="quiz-info">
                    Complete this quiz with ${quiz.passingScore}% or higher to unlock the next lesson.
                </p>
            </div>
    `;

        if (isCompleted) {
          const savedScore = currentLessonProgress.quizScore || 0;
          quizHTML += `
            <div class="quiz-results show">
                <div class="quiz-score pass">${savedScore}%</div>
                <div class="quiz-message">
                    <strong>Lesson Completed!</strong><br>
                    You've successfully passed this lesson's quiz.
                </div>
            </div>
        `;
        } else {
          // Render quiz questions
          quiz.questions.forEach((question, qIndex) => {
            quizHTML += `
                <div class="quiz-question ${
                  qIndex === 0 ? "active" : ""
                }" data-question="${qIndex}">
                    <div class="question-header">
                        <span class="question-number">Question ${
                          qIndex + 1
                        }</span>
                        <span class="question-progress">${qIndex + 1}/${
              quiz.questions.length
            }</span>
                    </div>
                    <div class="question-text">${question.question}</div>
                    <div class="question-options">
                        ${question.options
                          .map(
                            (option, oIndex) => `
                            <div class="option" data-option="${oIndex}" onclick="selectOption(${qIndex}, ${oIndex})">
                                <span class="option-letter">${String.fromCharCode(
                                  65 + oIndex
                                )}</span>
                                <span class="option-text">${option}</span>
                            </div>
                        `
                          )
                          .join("")}
                    </div>
                </div>
            `;
          });

          quizHTML += `
            <div class="quiz-controls">
                <button class="btn btn-secondary" id="prevQuestionBtn" onclick="previousQuestion()" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <div>
                    <button class="btn btn-secondary" id="nextQuestionBtn" onclick="nextQuestion()" disabled>
                        Next
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <button class="btn btn-primary" id="submitQuizBtn" onclick="submitQuiz()" style="display: none;">
                        <i class="fas fa-check"></i>
                        Submit Quiz
                    </button>
                </div>
            </div>

            <div class="quiz-results" id="quizResults">
                <div class="quiz-score" id="quizScore">0%</div>
                <div class="quiz-message" id="quizMessage"></div>
                <div class="quiz-actions">
                    <button class="btn btn-primary" id="continueBtn" onclick="completeLesson()" style="display: none;">
                        <i class="fas fa-arrow-right"></i>
                        Continue to Next Lesson
                    </button>
                    <button class="btn btn-secondary" onclick="retakeQuiz()">
                        <i class="fas fa-redo"></i>
                        Retake Quiz
                    </button>
                </div>
            </div>
        `;
        }

        quizHTML += "</div>";
        return quizHTML;
      }

      // Quiz interaction functions
      function selectOption(questionIndex, optionIndex) {
        // Clear previous selections
        document
          .querySelectorAll(`[data-question="${questionIndex}"] .option`)
          .forEach((opt) => {
            opt.classList.remove("selected");
          });

        // Select current option
        const selectedOption = document.querySelector(
          `[data-question="${questionIndex}"] [data-option="${optionIndex}"]`
        );
        selectedOption.classList.add("selected");

        // Store answer
        quizState.answers[questionIndex] = optionIndex;

        // Update navigation
        const isLastQuestion =
          questionIndex ===
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length - 1;
        if (isLastQuestion) {
          document.getElementById("submitQuizBtn").style.display =
            "inline-flex";
          document.getElementById("nextQuestionBtn").style.display = "none";
        } else {
          document.getElementById("nextQuestionBtn").disabled = false;
        }
      }

      function nextQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const nextQuestionEl = currentQuestionEl.nextElementSibling;

        if (
          nextQuestionEl &&
          nextQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          nextQuestionEl.classList.add("active");
          quizState.currentQuestion++;
          updateQuizNavigation();
        }
      }

      function previousQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const prevQuestionEl = currentQuestionEl.previousElementSibling;

        if (
          prevQuestionEl &&
          prevQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          prevQuestionEl.classList.add("active");
          quizState.currentQuestion--;
          updateQuizNavigation();
        }
      }

      function updateQuizNavigation() {
        const totalQuestions =
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length;
        const prevBtn = document.getElementById("prevQuestionBtn");
        const nextBtn = document.getElementById("nextQuestionBtn");
        const submitBtn = document.getElementById("submitQuizBtn");

        prevBtn.disabled = quizState.currentQuestion === 0;

        const hasAnswer =
          quizState.answers[quizState.currentQuestion] !== undefined;
        const isLastQuestion = quizState.currentQuestion === totalQuestions - 1;

        if (isLastQuestion) {
          nextBtn.style.display = "none";
          submitBtn.style.display = hasAnswer ? "inline-flex" : "none";
        } else {
          nextBtn.style.display = "inline-flex";
          nextBtn.disabled = !hasAnswer;
          submitBtn.style.display = "none";
        }
      }

      async function submitQuiz() {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const quiz = lesson.quiz;
        let correctAnswers = 0;

        // Hide questions and controls
        document
          .querySelectorAll(".quiz-question")
          .forEach((q) => (q.style.display = "none"));
        document.querySelector(".quiz-controls").style.display = "none";

        // Calculate score and highlight answers
        quiz.questions.forEach((question, index) => {
          const userAnswer = quizState.answers[index];
          const correctAnswer = question.correct;
          const isCorrect = userAnswer === correctAnswer;

          if (isCorrect) correctAnswers++;

          // Highlight answers
          const questionEl = document.querySelector(
            `[data-question="${index}"]`
          );
          const options = questionEl.querySelectorAll(".option");

          options[correctAnswer].classList.add("correct");
          if (userAnswer !== correctAnswer && userAnswer !== undefined) {
            options[userAnswer].classList.add("incorrect");
          }
        });

        const score = Math.round(
          (correctAnswers / quiz.questions.length) * 100
        );
        const passed = score >= quiz.passingScore;

        // Update quiz results UI
        const quizScore = document.getElementById("quizScore");
        const quizMessage = document.getElementById("quizMessage");
        const quizActions = document.querySelector(".quiz-actions");

        quizScore.textContent = `${score}%`;
        quizScore.className = `quiz-score ${passed ? "pass" : "fail"}`;

        if (passed) {
          quizMessage.innerHTML = `
            <strong>Congratulations!</strong><br>
            You passed with ${score}%. You can now proceed to the next lesson.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-primary" onclick="completeLesson()">
                <i class="fas fa-arrow-right"></i>
                Continue to Next Lesson
            </button>
        `;

          // Mark lesson as completed
          await markLessonComplete(score);
        } else {
          quizMessage.innerHTML = `
            <strong>Not quite there yet.</strong><br>
            You scored ${score}%. You need ${quiz.passingScore}% to pass. Review the material and try again.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-secondary" onclick="retakeQuiz()">
                <i class="fas fa-redo"></i>
                Retake Quiz
            </button>
        `;
        }

        document.getElementById("quizResults").classList.add("show");

        // Log quiz completion
        logUserActivity("quiz_completed", {
          lesson_id: lesson.id,
          lesson_title: lesson.title,
          score: score,
          passed: passed,
          attempts: (courseProgress[lesson.id]?.quizAttempts || 0) + 1,
        });

        // Scroll to results
        document
          .getElementById("quizResults")
          .scrollIntoView({ behavior: "smooth" });
      }

      function retakeQuiz() {
        // Reset quiz state
        quizState = {
          currentQuestion: 0,
          answers: [],
          score: 0,
          isComplete: false,
        };

        // Track quiz retry
        const lessonId = COURSE_DATA.lessons[currentLessonIndex].id;
        if (!courseProgress[lessonId]) courseProgress[lessonId] = {};
        courseProgress[lessonId].quizAttempts =
          (courseProgress[lessonId].quizAttempts || 0) + 1;

        // Reload lesson content
        loadLesson(currentLessonIndex);

        // Scroll to quiz
        setTimeout(() => {
          document
            .getElementById("quizSection")
            .scrollIntoView({ behavior: "smooth" });
        }, 500);
      }

      async function markLessonComplete(score) {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonId = lesson.id;

        // Track lesson completion time
        trackLessonTime();

        // Update lesson progress
        courseProgress[lessonId] = {
          ...courseProgress[lessonId],
          completed: true,
          quizScore: score,
          completedAt: new Date().toISOString(),
          finalScore: score,
        };

        // Update session tracking
        courseSession.lessonsCompleted++;

        // Save progress to database
        await saveProgress();

        // Update UI
        renderSidebar();
        updateNavigationButtons();

        // Check various achievements
        await checkLessonCompletionAchievements();
        await checkPerfectScoreAchievements(score);
        await checkStudyTimeAchievements();

        // Log lesson completion
        logUserActivity("lesson_completed", {
          lesson_id: lessonId,
          lesson_title: lesson.title,
          final_score: score,
          time_spent: courseProgress[lessonId].timeSpent || 0,
          lesson_number: currentLessonIndex + 1,
        });

        showToast("Lesson completed successfully!", "success");
      }

      async function completeLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          // Move to next lesson
          currentLessonIndex++;
          loadLesson(currentLessonIndex);
        } else {
          // Course completion
          await completeCourse();
        }
      }

      async function completeCourse() {
        try {
          const completionTime = courseSession.totalStudyTime;

          // Update course progress to 100% completed
          await supabase
            .from("course_progress")
            .update({
              progress: 100,
              completed_at: new Date().toISOString(),
              completion_time_minutes: completionTime,
            })
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Award course completion achievements
          await checkAndUnlockAchievement("course_completion_1");
          await checkSpeedCompletionAchievements(completionTime);
          await checkCourseStreakAchievements();

          // Update user stats
          await updateUserStats();

          // Show completion message
          showToast(
            "Congratulations! Course completed successfully!",
            "certificate"
          );

          // Log course completion
          logUserActivity("course_completed", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            completion_time_minutes: completionTime,
            total_lessons: COURSE_DATA.lessons.length,
            average_quiz_score: calculateAverageQuizScore(),
          });

          // Redirect to dashboard after delay
          setTimeout(() => {
            window.location.href = "/dashboard.html";
          }, 3000);
        } catch (error) {
          console.error("Error completing course:", error);
          showToast("Error marking course as complete", "error");
        }
      }

      // =====================================================
      // ACHIEVEMENT INTEGRATION SYSTEM
      // =====================================================
      async function checkAndUnlockAchievement(
        achievementId,
        skipNotification = false
      ) {
        try {
          // Prevent duplicate checks
          const cacheKey = `achievement_${achievementId}_${currentUser.id}`;
          if (sessionStorage.getItem(cacheKey)) return false;

          // Check if already unlocked
          const { data: existing, error } = await supabase
            .from("user_achievements")
            .select("id")
            .eq("user_id", currentUser.id)
            .eq("achievement_id", achievementId)
            .single();

          if (existing) {
            sessionStorage.setItem(cacheKey, "true");
            return false;
          }

          // Award achievement
          const achievementData = {
            user_id: currentUser.id,
            achievement_id: achievementId,
            unlocked_at: new Date().toISOString(),
            points_awarded: getAchievementPoints(achievementId),
            context: "course_system",
          };

          const { data, error: insertError } = await supabase
            .from("user_achievements")
            .insert([achievementData])
            .select()
            .single();

          if (insertError) {
            if (insertError.code === "23505") return false; // Already exists
            throw insertError;
          }

          // Update user points
          // --- CORRECTED CODE ---
// Update user points and achievements using the secure RPC function
await supabase.rpc('increment_user_stats', {
  user_id_param: currentUser.id,
  points_to_add: achievementData.points_awarded,
  achievements_to_add: 1
});
// --- END OF CORRECTED CODE ---

          // Cache and queue notification
          sessionStorage.setItem(cacheKey, "true");

          if (!skipNotification) {
            queueAchievementNotification({
              id: achievementId,
              name: getAchievementName(achievementId),
              description: getAchievementDescription(achievementId),
              points: achievementData.points_awarded,
              rarity: getAchievementRarity(achievementId),
              icon: getAchievementIcon(achievementId),
            });
          }

          return true;
        } catch (error) {
          console.error("Error unlocking achievement:", error);
          return false;
        }
      }

      // Helper functions for achievement data (replace with your actual achievement definitions)
      function getAchievementPoints(id) {
        const pointsMap = {
          first_course_start: 75,
          first_lesson: 100,
          course_completion_1: 500,
          perfect_score: 250,
          speed_demon: 750,
          marathon_learner: 500,
          night_owl: 200,
          early_bird: 200,
          weekend_warrior: 150,
          // Add more as needed
        };
        return pointsMap[id] || 100;
      }

      function getAchievementName(id) {
        const nameMap = {
          first_course_start: "Learning Initiated",
          first_lesson: "First Steps",
          course_completion_1: "Course Conqueror",
          perfect_score: "Perfectionist",
          speed_demon: "Speed Demon",
          // Add more as needed
        };
        return nameMap[id] || "Achievement Unlocked";
      }

      function getAchievementDescription(id) {
        const descMap = {
          first_course_start: "Start your first cybersecurity course",
          first_lesson: "Complete your first lesson",
          course_completion_1: "Complete your first course",
          perfect_score: "Score 100% on any quiz",
          speed_demon: "Complete a course in under 2 hours",
          // Add more as needed
        };
        return descMap[id] || "Achievement description";
      }

      function getAchievementRarity(id) {
        const rarityMap = {
          first_course_start: "common",
          first_lesson: "bronze",
          course_completion_1: "silver",
          perfect_score: "gold",
          speed_demon: "legendary",
          // Add more as needed
        };
        return rarityMap[id] || "common";
      }

      function getAchievementIcon(id) {
        const iconMap = {
          first_course_start: "fas fa-play",
          first_lesson: "fas fa-baby",
          course_completion_1: "fas fa-trophy",
          perfect_score: "fas fa-star",
          speed_demon: "fas fa-rocket",
          // Add more as needed
        };
        return iconMap[id] || "fas fa-award";
      }

      async function checkLessonAchievements(lessonNumber) {
        if (lessonNumber === 1) {
          await checkAndUnlockAchievement("first_lesson");
        }

        // Check if user has completed multiple lessons in one day
        const today = new Date().toISOString().split("T")[0];
        const todayCompletions = Object.values(courseProgress).filter(
          (p) => p.completed && p.completedAt?.startsWith(today)
        ).length;

        if (todayCompletions >= 3) {
          await checkAndUnlockAchievement("lesson_marathon");
        }
      }

      async function checkLessonCompletionAchievements() {
        const completedCount = getCompletedLessonsCount();

        // Lesson-based achievements
        const lessonMilestones = [1, 5, 10, 25, 50, 100];
        for (const milestone of lessonMilestones) {
          if (completedCount >= milestone) {
            await checkAndUnlockAchievement(`lessons_${milestone}`);
          }
        }

        // Course completion achievements
        if (completedCount === COURSE_DATA.lessons.length) {
          await checkAndUnlockAchievement("course_completion_1");

          // Check for additional course completion achievements
          const { data: allCourses } = await supabase
            .from("course_progress")
            .select("course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100);

          const totalCompleted = allCourses?.length || 0;

          const courseMilestones = [1, 5, 10, 25];
          for (const milestone of courseMilestones) {
            if (totalCompleted >= milestone) {
              await checkAndUnlockAchievement(`course_completion_${milestone}`);
            }
          }
        }
      }

      async function checkPerfectScoreAchievements(score) {
        if (score === 100) {
          await checkAndUnlockAchievement("perfect_score");

          // Check for consecutive perfect scores
          const recentScores = Object.values(courseProgress)
            .filter((p) => p.completed && p.quizScore)
            .slice(-5) // Last 5 completed
            .map((p) => p.quizScore);

          if (
            recentScores.length >= 3 &&
            recentScores.every((s) => s === 100)
          ) {
            await checkAndUnlockAchievement("perfectionist_streak");
          }
        }
      }

      async function checkSpeedCompletionAchievements(completionTime) {
        // Speed demon: Complete course in under 2 hours (120 minutes)
        if (completionTime <= 120) {
          await checkAndUnlockAchievement("speed_demon");
        }

        // Quick learner: Complete course in under 4 hours (240 minutes)
        if (completionTime <= 240) {
          await checkAndUnlockAchievement("quick_learner");
        }
      }

      async function checkStudyTimeAchievements() {
        const totalTime = courseSession.totalStudyTime;

        // Marathon learner: Study for 8+ hours in a course session
        if (totalTime >= 480) {
          // 8 hours
          await checkAndUnlockAchievement("marathon_learner");
        }

        // Dedicated learner: Study for 4+ hours
        if (totalTime >= 240) {
          // 4 hours
          await checkAndUnlockAchievement("dedicated_learner");
        }
      }

      async function checkCourseStreakAchievements() {
        try {
          // Check for consecutive course completions
          const { data: recentCourses, error } = await supabase
            .from("course_progress")
            .select("completed_at, course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100)
            .order("completed_at", { ascending: false })
            .limit(10);

          if (error || !recentCourses) return;

          // Check for courses completed on consecutive days
          let consecutiveDays = 1;
          for (let i = 1; i < recentCourses.length; i++) {
            const prevDate = new Date(
              recentCourses[i - 1].completed_at
            ).toDateString();
            const currentDate = new Date(
              recentCourses[i].completed_at
            ).toDateString();
            const dayDiff =
              Math.abs(new Date(prevDate) - new Date(currentDate)) /
              (1000 * 60 * 60 * 24);

            if (dayDiff <= 1) {
              consecutiveDays++;
            } else {
              break;
            }
          }

          if (consecutiveDays >= 3) {
            await checkAndUnlockAchievement("learning_streak");
          }
        } catch (error) {
          console.error("Error checking course streak achievements:", error);
        }
      }

      // =====================================================
      // TIME-BASED ACHIEVEMENTS
      // =====================================================
      async function checkTimeBasedAchievements(timestamp) {
        const hour = timestamp.getHours();
        const dayOfWeek = timestamp.getDay();

        // Night owl (after midnight, before 6 AM)
        if (hour >= 0 && hour < 6) {
          await incrementTimeBasedCounter("midnight_sessions", "night_owl");
        }

        // Early bird (4 AM to 6 AM)
        if (hour >= 4 && hour < 6) {
          await incrementTimeBasedCounter("early_sessions", "early_bird");
        }

        // Weekend warrior (Saturday = 6, Sunday = 0)
        if (dayOfWeek === 0 || dayOfWeek === 6) {
          await incrementTimeBasedCounter(
            "weekend_sessions",
            "weekend_warrior"
          );
        }
      }

      async function incrementTimeBasedCounter(counterType, achievementId) {
        try {
          const dateStr = new Date().toISOString().split("T")[0];
          const cacheKey = `${counterType}_${currentUser.id}_${dateStr}`;

          // Prevent multiple increments per day
          if (sessionStorage.getItem(cacheKey)) return;

          // Update counter
          await supabase
            .from("profiles")
            .update({
              [counterType]: supabase.sql`${counterType} + 1`,
            })
            .eq("id", currentUser.id);

          // Cache to prevent double counting
          sessionStorage.setItem(cacheKey, "true");

          // Check related achievement
          if (achievementId) {
            await checkAndUnlockAchievement(achievementId, true);
          }
        } catch (error) {
          console.error(`Error incrementing ${counterType}:`, error);
        }
      }

      async function checkDailyStreak() {
        try {
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("last_activity, current_streak, last_streak_date")
            .eq("id", currentUser.id)
            .single();

          if (error) throw error;

          const now = new Date();
          const today = now.toDateString();
          const lastActivity = profile.last_activity
            ? new Date(profile.last_activity)
            : null;
          const lastStreakDate = profile.last_streak_date
            ? new Date(profile.last_streak_date).toDateString()
            : null;

          let newStreak = profile.current_streak || 0;
          let shouldUpdateStreak = false;

          if (!lastActivity) {
            // First time user
            newStreak = 1;
            shouldUpdateStreak = true;
          } else {
            const daysSinceLastActivity = Math.floor(
              (now - lastActivity) / (1000 * 60 * 60 * 24)
            );

            if (lastStreakDate === today) {
              // Already counted today's streak
              return newStreak;
            } else if (
              daysSinceLastActivity === 1 ||
              (daysSinceLastActivity === 0 && lastStreakDate !== today)
            ) {
              // Consecutive day or same day but not counted yet
              newStreak += 1;
              shouldUpdateStreak = true;
            } else if (daysSinceLastActivity > 1) {
              // Streak broken
              newStreak = 1;
              shouldUpdateStreak = true;
            }
          }

          if (shouldUpdateStreak) {
            await supabase
              .from("profiles")
              .update({
                current_streak: newStreak,
                last_activity: now.toISOString(),
                last_streak_date: now.toISOString(),
              })
              .eq("id", currentUser.id);

            userStats.current_streak = newStreak;

            showToast(`Daily streak: ${newStreak} days!`, "success");
            await checkStreakAchievements(newStreak);
          }

          return newStreak;
        } catch (error) {
          console.error("Error checking daily streak:", error);
          return 0;
        }
      }

      async function checkStreakAchievements(currentStreak) {
        const streakMilestones = [3, 7, 14, 30, 100, 365];

        for (const milestone of streakMilestones) {
          if (currentStreak >= milestone) {
            await checkAndUnlockAchievement(`streak_${milestone}`);
          }
        }
      }

      // =====================================================
      // USER ACTIVITY LOGGING
      // =====================================================
      async function logUserActivity(activityType, metadata = {}) {
        try {
          const now = new Date();

          const activityData = {
            user_id: currentUser.id,
            activity_type: activityType,
            timestamp: now.toISOString(),
            course_id: COURSE_DATA.id,
            lesson_index: currentLessonIndex,
            session_duration: courseSession.totalStudyTime,
            metadata: JSON.stringify(metadata),
            created_at: now.toISOString(),
          };

          // Try to log to activities table
          const { error } = await supabase
            .from("user_activities")
            .insert([activityData]);

          if (error && error.code !== "42P01") {
            console.warn("Activity logging failed:", error.message);
          }

          // Always update last activity in profile
          await supabase
            .from("profiles")
            .update({ last_activity: now.toISOString() })
            .eq("id", currentUser.id);
        } catch (error) {
          console.error("Error logging user activity:", error);
        }
      }

      // =====================================================
      // NAVIGATION SYSTEM
      // =====================================================
      function updateNavigationButtons() {
        const prevBtn = document.getElementById("prevLessonBtn");
        const nextBtn = document.getElementById("nextLessonBtn");

        if (!prevBtn || !nextBtn) return;

        // Previous button
        prevBtn.disabled = currentLessonIndex === 0;

        // Next button logic
        const isLastLesson =
          currentLessonIndex === COURSE_DATA.lessons.length - 1;
        const canGoNext =
          currentLessonIndex < COURSE_DATA.lessons.length - 1 &&
          canAccessLesson(currentLessonIndex + 1);

        if (isLastLesson) {
          const isCurrentCompleted =
            courseProgress[COURSE_DATA.lessons[currentLessonIndex].id]
              ?.completed;
          nextBtn.disabled = !isCurrentCompleted;
          nextBtn.innerHTML = '<i class="fas fa-trophy"></i> Complete Course';
        } else {
          nextBtn.disabled = !canGoNext;
          nextBtn.innerHTML = 'Next <i class="fas fa-chevron-right"></i>';
        }
      }

      // Navigation button event handlers
      function goToPreviousLesson() {
        if (currentLessonIndex > 0) {
          trackLessonTime(); // Track time spent on current lesson
          currentLessonIndex--;
          loadLesson(currentLessonIndex);
        }
      }

      function goToNextLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          const canGoNext = canAccessLesson(currentLessonIndex + 1);
          if (canGoNext) {
            trackLessonTime();
            currentLessonIndex++;
            loadLesson(currentLessonIndex);
          } else {
            showToast("Complete the current lesson quiz to proceed", "warning");
          }
        } else {
          // Complete course
          completeCourse();
        }
      }

      // =====================================================
      // SIDEBAR FUNCTIONS
      // =====================================================
      function toggleSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.toggle("open");
        if (overlay) overlay.classList.toggle("active");
      }

      function closeSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.remove("open");
        if (overlay) overlay.classList.remove("active");
      }

      // =====================================================
      // ACHIEVEMENT NOTIFICATION SYSTEM
      // =====================================================
      function queueAchievementNotification(achievement) {
        notificationQueue.push(achievement);
        processNotificationQueue();
      }

      function processNotificationQueue() {
        if (isShowingNotification || notificationQueue.length === 0) return;

        isShowingNotification = true;
        const achievement = notificationQueue.shift();
        showAchievementNotification(achievement);

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          isShowingNotification = false;
          processNotificationQueue();
        }, duration + 500);
      }

      function showAchievementNotification(achievement) {
        const notification = document.getElementById("achievementNotification");
        if (!notification) return;

        const icon = document.getElementById("notificationIcon");
        const title = document.getElementById("notificationTitle");
        const description = document.getElementById("notificationDescription");
        const points = document.getElementById("notificationPoints");

        if (icon) {
          icon.innerHTML = `<i class="${achievement.icon}"></i>`;
          icon.className = `notification-icon ${achievement.rarity}`;
        }
        if (title) title.textContent = achievement.name;
        if (description) description.textContent = achievement.description;
        if (points) points.textContent = `+${achievement.points} Points`;

        notification.className = `achievement-notification ${achievement.rarity}`;
        notification.classList.add("show");

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          notification.classList.remove("show");
        }, duration);
      }

      // =====================================================
      // UTILITY FUNCTIONS
      // =====================================================
      function calculateAverageQuizScore() {
        const scores = Object.values(courseProgress)
          .filter((p) => p.completed && p.quizScore)
          .map((p) => p.quizScore);

        if (scores.length === 0) return 0;
        return Math.round(
          scores.reduce((sum, score) => sum + score, 0) / scores.length
        );
      }

      async function resetProgress() {
        if (
          !confirm(
            "Are you sure you want to reset your progress? This action cannot be undone."
          )
        ) {
          return;
        }

        try {
          // Track lesson time before reset
          trackLessonTime();

          // Reset local state
          courseProgress = {};
          currentLessonIndex = 0;
          courseSession = {
            startTime: new Date(),
            totalStudyTime: 0,
            lessonsStarted: 0,
            lessonsCompleted: 0,
            pageLoadTime: new Date(),
            interactionCount: 0,
            lastActivityTime: new Date(),
          };

          // Delete from database
          await supabase
            .from("course_progress")
            .delete()
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Log reset activity
          logUserActivity("progress_reset", {
            course_id: COURSE_DATA.id,
            reset_reason: "manual",
          });

          // Reinitialize
          await saveProgress();
          renderSidebar();
          loadLesson(0);

          showToast("Progress reset successfully", "success");
        } catch (error) {
          console.error("Error resetting progress:", error);
          showToast("Failed to reset progress", "error");
        }
      }

      function copyCode(codeId) {
        const codeElement = document.getElementById(codeId);
        if (!codeElement) return;

        const text = codeElement.textContent;

        navigator.clipboard
          .writeText(text)
          .then(() => {
            showToast("Code copied to clipboard!", "success");

            // Track code copy for achievements
            logUserActivity("code_copied", {
              code_section: codeId,
              lesson_id: COURSE_DATA.lessons[currentLessonIndex].id,
            });
          })
          .catch((err) => {
            console.error("Failed to copy code:", err);
            showToast("Failed to copy code", "error");

            // Fallback for older browsers
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            try {
              document.execCommand("copy");
              showToast("Code copied to clipboard!", "success");
            } catch (fallbackError) {
              showToast(
                "Copy failed - please select and copy manually",
                "error"
              );
            }
            document.body.removeChild(textArea);
          });
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // =====================================================
      // UI FEEDBACK SYSTEMS
      // =====================================================
      function showToast(message, type = "success") {
        const toast = document.getElementById("toast");
        const messageEl = document.getElementById("toastMessage");

        if (!toast || !messageEl) {
          console.log(`Toast: ${message} (${type})`);
          return;
        }

        messageEl.textContent = message;
        toast.className = `toast ${type} show`;

        setTimeout(() => {
          toast.classList.remove("show");
        }, 4000);
      }

      function showLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) loadingScreen.classList.remove("hidden");
      }

      function hideLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) {
          setTimeout(() => {
            loadingScreen.classList.add("hidden");
          }, 1000);
        }
      }

      // =====================================================
      // MUSIC PLAYER INTEGRATION
      // =====================================================
      function initMusicPlayer() {
        const btnText = document.getElementById("music-button-text");
        const icon = document.getElementById("music-icon");
        const dropdown = document.getElementById("music-dropdown-content");

        if (!btnText || !icon || !dropdown) return;

        function setUI(state) {
          btnText.textContent =
            state === "Playing" ? "PAUSE MUSIC" : "STUDY MUSIC";
          icon.className =
            state === "Playing"
              ? "fa-solid fa-circle-pause"
              : "fa-solid fa-music";
        }

        // Load saved music state
        const savedSrc = localStorage.getItem("cybersec_music_src");
        const savedTime = parseFloat(
          localStorage.getItem("cybersec_music_time") || 0
        );

        if (savedSrc) {
          audioPlayer.src = savedSrc;
          audioPlayer.currentTime = savedTime;
          audioPlayer
            .play()
            .then(() => setUI("Playing"))
            .catch(() => setUI("Stopped"));
        }

        // Music button click handler
        document
          .getElementById("music-dropdown")
          .querySelector("button")
          .addEventListener("click", (e) => {
            e.stopPropagation();
            dropdown.style.display =
              dropdown.style.display === "block" ? "none" : "block";

            if (audioPlayer.src && !audioPlayer.paused) {
              audioPlayer.pause();
              setUI("Stopped");
            } else if (audioPlayer.src) {
              audioPlayer.play().then(() => setUI("Playing"));
            }
          });

        // Music selection handlers
        dropdown.querySelectorAll("a[data-src]").forEach((link) => {
          link.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.src = link.dataset.src;
            audioPlayer.play().then(() => setUI("Playing"));
            localStorage.setItem("cybersec_music_src", link.dataset.src);
            dropdown.style.display = "none";
          });
        });

        // Stop music handler
        const stopLink = document.getElementById("stop-music-link");
        if (stopLink) {
          stopLink.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            audioPlayer.removeAttribute("src");
            setUI("Stopped");
            localStorage.removeItem("cybersec_music_src");
            localStorage.removeItem("cybersec_music_time");
            dropdown.style.display = "none";
          });
        }

        // Save music state before page unload
        window.addEventListener("beforeunload", () => {
          if (!audioPlayer.paused && audioPlayer.src) {
            localStorage.setItem("cybersec_music_src", audioPlayer.src);
            localStorage.setItem(
              "cybersec_music_time",
              audioPlayer.currentTime
            );
          }
        });

        // Close dropdown when clicking outside
        window.addEventListener("click", (e) => {
          if (!e.target.closest("#music-dropdown")) {
            dropdown.style.display = "none";
          }
        });
      }

      // Show initial music indicator
      function addMusicIndicator() {
        const musicBtn = document.querySelector("#music-dropdown");
        if (musicBtn) {
          const indicator = document.createElement("div");
          indicator.className = "music-indicator";
          indicator.innerHTML = `<i class="fa-solid fa-music"></i> Try Study Music!`;

          musicBtn.style.position = "relative";
          musicBtn.appendChild(indicator);

          setTimeout(() => indicator.remove(), 3000);
        }
      }

      // Initialize Event Listeners
      function initializeEventListeners() {
        // Navigation buttons
        document
          .getElementById("prevLessonBtn")
          ?.addEventListener("click", goToPreviousLesson);
        document
          .getElementById("nextLessonBtn")
          ?.addEventListener("click", goToNextLesson);

        // Reset progress button
        document
          .getElementById("resetProgressBtn")
          ?.addEventListener("click", resetProgress);

        // Mobile menu toggle
        document
          .getElementById("menuToggle")
          ?.addEventListener("click", toggleSidebar);
        document
          .getElementById("sidebarOverlay")
          ?.addEventListener("click", closeSidebar);

        // Keyboard shortcuts
        document.addEventListener("keydown", handleKeyboardShortcuts);

        // Window resize handler
        window.addEventListener("resize", handleWindowResize);

        // Content interaction tracking
        document.getElementById("contentBody")?.addEventListener(
          "scroll",
          debounce(() => {
            trackUserInteraction();
          }, 1000)
        );
      }

      // Keyboard Shortcuts
      function handleKeyboardShortcuts(e) {
        if (document.querySelector(".quiz-question.active")) return;

        if (e.key === "ArrowLeft" && e.ctrlKey) {
          e.preventDefault();
          goToPreviousLesson();
        } else if (e.key === "ArrowRight" && e.ctrlKey) {
          e.preventDefault();
          goToNextLesson();
        }
      }

      // Window Resize Handler
      function handleWindowResize() {
        if (window.innerWidth > 768) {
          closeSidebar();
        }
      }

      // Debounce Helper
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Initialize responsive behavior
      if (window.innerWidth <= 768) {
        document.getElementById("menuToggle").style.display = "inline-flex";
      }

      // Auto-save progress periodically
      setInterval(async () => {
        if (currentUser && Object.keys(courseProgress).length > 0) {
          await saveProgress();
        }
      }, 60000); // Save every minute

      // System initialization logging
      console.log("CyberSec Academy Course System Initialized");
      console.log("Current Course:", COURSE_DATA.title);
      console.log("Total Lessons:", COURSE_DATA.lessons.length);

      // Google OAuth Integration
      const googleBtn = document.querySelector(".btn-google");
      if (googleBtn) {
        googleBtn.addEventListener("click", async () => {
          const { data, error } = await supabase.auth.signInWithOAuth({
            provider: "google",
            options: {
              redirectTo: window.location.origin + "/courses/blockchain-security.html",
            },
          });

          if (error) {
            console.error("Google login error:", error.message);
            showToast("Google login failed: " + error.message, "error");
          }
        });
      }

      // Check for existing session
      supabase.auth.getSession().then(({ data }) => {
        if (data.session) {
          console.log("User already logged in:", data.session.user);
          currentUser = data.session.user;
          startCourseSession();
        }
      });

      // Add missing auth modal functions
      function openAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "flex";
        }
      }

      function closeAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Add auth tab switching functionality
      document.getElementById("tabSignIn")?.addEventListener("click", () => {
        document.getElementById("tabSignIn").classList.add("active");
        document.getElementById("tabSignUp").classList.remove("active");
        document.getElementById("signInForm").style.display = "block";
        document.getElementById("signUpForm").style.display = "none";
      });

      document.getElementById("tabSignUp")?.addEventListener("click", () => {
        document.getElementById("tabSignUp").classList.add("active");
        document.getElementById("tabSignIn").classList.remove("active");
        document.getElementById("signUpForm").style.display = "block";
        document.getElementById("signInForm").style.display = "none";
      });

      document
        .getElementById("closeAuthModal")
        ?.addEventListener("click", closeAuthModal);

      // Improved error handling for auth session
      supabase.auth.onAuthStateChange((event, session) => {
        if (event === "SIGNED_IN") {
          currentUser = session.user;
          closeAuthModal();
          startCourseSession();
        } else if (event === "SIGNED_OUT") {
          currentUser = null;
          openAuthModal();
        }
      });

      // Add form submission handlers
      document
        .getElementById("emailSignInForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signInEmail").value;
          const password = document.getElementById("signInPassword").value;

          try {
            const { data, error } = await supabase.auth.signInWithPassword({
              email,
              password,
            });

            if (error) throw error;

            closeAuthModal();
          } catch (error) {
            showToast(error.message, "error");
          }
        });

      document
        .getElementById("emailSignUpForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signUpEmail").value;
          const password = document.getElementById("signUpPassword").value;
          const name = document.getElementById("signUpName").value;

          try {
            const { data, error } = await supabase.auth.signUp({
              email,
              password,
              options: {
                data: {
                  full_name: name,
                },
              },
            });

            if (error) throw error;

            showToast(
              "Account created successfully! Please check your email.",
              "success"
            );
          } catch (error) {
            showToast(error.message, "error");
          }
        });
    </script>
  </body>
</html>

