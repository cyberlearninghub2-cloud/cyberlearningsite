



<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- ========== Start: SEO & Schema Enhancement ========== -->
    <title>Android Application Security Course | CipherHall</title>
    <meta name="description" content="A 50-lesson masterclass in Android application security. Learn static/dynamic analysis, Frida, malware analysis, native code exploitation, and more.">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png" />
    <link rel="shortcut icon" href="/favicon.png" type="image/x-icon" />
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png" />
    <link rel="canonical" href="https://www.cipherhall.com/courses/android-app-security" />
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Course",
      "name": "Android Application Security: From Foundations to Advanced Exploitation",
      "description": "A comprehensive 50-lesson masterclass that takes you from the core principles of the Android security model to advanced, real-world exploitation of mobile application vulnerabilities, covering static and dynamic analysis, reverse engineering, and enterprise mobile security.",
      "provider": {
        "@type": "Organization",
        "name": "CipherHall",
        "sameAs": "https://www.cipherhall.com"
      },
      "hasCourseInstance": {
        "@type": "CourseInstance",
        "courseMode": "Online",
        "instructor": {
          "@type": "Person",
          "name": "Dr. 'Frida' Chen"
        }
      }
    }
    </script>
    <!-- ========== End: SEO & Schema Enhancement ========== -->
    
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Exo+2:wght@700;800;900&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css"
    />
    <link rel="stylesheet" href="assets/css/coursepages.css">
</head>
  <body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
      <div class="loader-icon">
        <i class="fas fa-graduation-cap"></i>
      </div>
      <div class="loader-text">Loading Course Content...</div>
    </div>

    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- Music Player (fixed at top right) -->
    <div class="header-controls">
      <div class="music-dropdown" id="music-dropdown">
        <button class="btn btn-secondary">
          <span id="music-button-text">STUDY MUSIC</span>
          <i id="music-icon" class="fa-solid fa-music"></i>
        </button>
        <div class="music-dropdown-content" id="music-dropdown-content">
          <a
            href="#"
            data-src="https://www.learningcontainer.com/wp-content/uploads/2020/02/Kalimba.mp3"
            >1. Coffee Shop Vibes</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3"
            >2. City Lights Lofi</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-15.mp3"
            >3. Mellow Thoughts</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-13.mp3"
            >4. Rainy Mood</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3"
            >5. Time Alone</a
          >
          <a href="#" id="stop-music-link"
            ><i class="fa-solid fa-stop-circle"></i> Stop Music</a
          >
        </div>
      </div>

      <button class="btn btn-secondary" id="resetProgressBtn">
        <i class="fas fa-redo"></i>
        Reset Progress
      </button>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal" style="display: none">
      <div class="modal-overlay"></div>
      <div class="modal-content">
        <span class="close" id="closeAuthModal">&times;</span>
        <div class="auth-tabs">
          <button id="tabSignIn" class="auth-tab active">Sign In</button>
          <button id="tabSignUp" class="auth-tab">Sign Up</button>
        </div>
        <div
          id="authLoader"
          style="display: none; text-align: center; padding: 2rem"
        >
          <i
            class="fas fa-spinner fa-spin fa-2x"
            style="color: var(--color-green)"
          ></i>
          <p style="margin-top: 0.5rem">Authenticating...</p>
        </div>
        <div id="signInForm" class="auth-form">
          <h2>Sign In to CipherHall</h2>
          <button id="googleSignIn" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignInForm">
            <input
              type="email"
              id="signInEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signInPassword"
              placeholder="Password"
              required
            />
            <button type="submit" class="btn btn-primary">Sign In</button>
          </form>
        </div>
        <div id="signUpForm" class="auth-form" style="display: none">
          <h2>Join CipherHall</h2>
          <button id="googleSignUp" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignUpForm">
            <input
              type="text"
              id="signUpName"
              placeholder="Full Name"
              required
            />
            <input
              type="email"
              id="signUpEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signUpPassword"
              placeholder="Password (min. 8 characters)"
              required
            />
            <button type="submit" class="btn btn-secondary">
              Create Account
            </button>
          </form>
        </div>
        <div id="authMessage"></div>
      </div>
    </div>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="course-info">
          <h1 class="course-title" id="courseTitle">Loading...</h1>
          <div class="course-progress">
            <div class="progress-header">
              <span class="progress-label">Course Progress</span>
              <span class="progress-percentage" id="courseProgressPercent"
                >0%</span
              >
            </div>
            <div class="progress-bar">
              <div
                class="progress-fill"
                id="courseProgressFill"
                style="width: 0%"
              ></div>
            </div>
            <div class="progress-stats">
              <span id="completedLessons">0</span>
              <span id="totalLessons">0</span>
            </div>
          </div>
          <a href="/dashboard" class="back-to-dashboard">
            <i class="fas fa-arrow-left"></i>
            Back to Dashboard
          </a>
        </div>
      </div>

      <nav class="lesson-nav" id="lessonNav">
        <!-- Lessons will be loaded dynamically -->
      </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <header class="content-header">
        <div class="lesson-header">
          <div class="lesson-header-left">
            <span class="lesson-number" id="currentLessonNumber">1</span>
            <h1 class="lesson-header-title" id="currentLessonTitle">
              Loading...
            </h1>
          </div>
          <div class="lesson-actions">
            <button class="mbtn btn-primary" id="menuToggle">
              <i class="fas fa-bars"></i>
            </button>
          </div>
        </div>
      </header>

      <div class="content-body" id="contentBody">
        <div class="lesson-content" id="lessonContent">
          <!-- Lesson content will be loaded dynamically -->
        </div>
      </div>

      <footer class="lesson-navigation">
        <div class="nav-info" id="navInfo">Lesson 1 of 10</div>
        <div class="nav-controls">
          <button class="btn btn-secondary" id="prevLessonBtn" disabled>
            <i class="fas fa-chevron-left"></i>
            Previous
          </button>
          <button class="btn btn-primary" id="nextLessonBtn" disabled>
            Next
            <i class="fas fa-chevron-right"></i>
          </button>
        </div>
      </footer>
    </main>

    <!-- Achievement Notification -->
    <div id="achievementNotification" class="achievement-notification">
      <div class="notification-header">
        <div class="notification-icon" id="notificationIcon">
          <i class="fas fa-trophy"></i>
        </div>
        <div class="notification-content">
          <h3 id="notificationTitle">Achievement Unlocked!</h3>
          <p id="notificationDescription">Description here...</p>
        </div>
      </div>
      <div class="notification-reward" id="notificationReward">
        <i class="fas fa-coins"></i>
        <span id="notificationPoints">+100 Points</span>
      </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast">
      <span id="toastMessage"></span>
    </div>

    <script>
      // =====================================================
      // SYNCHRONIZED COURSE SYSTEM WITH DASHBOARD INTEGRATION
      // =====================================================

      // Supabase Configuration - Replace with your config
      const supabaseUrl = "https://lzcmzulemfubjaksoqor.supabase.co";
      const supabaseKey =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx6Y216dWxlbWZ1Ympha3NvcW9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzMzM5MDgsImV4cCI6MjA3MDkwOTkwOH0.crhPH4YWtRsr1BJTpAQcmPbWSpwIWRbzoI4sRb2_fPI";
      const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

      // =====================================================
      // COURSE DATA STRUCTURE - REPLACE WITH YOUR COURSE JSON
      // =====================================================
      const COURSE_DATA = {
        "id": "android-application-security",
        "title": "Android Application Security: From Foundations to Advanced Exploitation",
        "description": "A comprehensive 50-lesson masterclass that takes you from the core principles of the Android security model to advanced, real-world exploitation of mobile application vulnerabilities, covering static and dynamic analysis, reverse engineering, and enterprise mobile security.",
        "category": "mobile-security",
        "difficulty": "Intermediate to Advanced",
        "duration": "100 hours",
        "instructor": "Dr. 'Frida' Chen",
        "lessons": [
            {
                "id": "lesson-1-android-security-architecture",
                "title": "Lesson 1: Android Security Architecture",
                "duration": "120 min",
                "objectives": [
                    "Understand the core principles of the Android Security Model, including the Application Sandbox",
                    "Define the role and function of the Android permission system (install-time vs. runtime)",
                    "Explain how SELinux is used to enforce mandatory access control at the kernel level",
                    "Recognize key hardware-backed security features like the Keystore and Verified Boot"
                ],
                "content": {
                    "overview": "This foundational lesson deconstructs the multi-layered security architecture of the Android operating system. We will explore the core principle of the Application Sandbox, which provides process isolation, and understand how the permission system and SELinux work together to create a robust, defense-in-depth environment.",
                    "sections": [
                        {
                            "title": "The Application Sandbox",
                            "content": "<p>The cornerstone of Android security is the Application Sandbox. At the Linux kernel level, every application is assigned a unique User ID (UID). This means each application runs as its own separate user in its own isolated process.</p><h3>Key Principles:</h3><ul><li><strong>Process Isolation:</strong> An application's process cannot access the memory or resources of another application's process.</li><li><strong>Data Isolation:</strong> By default, an application's data (stored in its private directory, e.g., `/data/data/com.example.app`) is protected by standard Linux file permissions. Only the application with the matching UID can access its own data.</li></ul><p>This sandbox model is the primary defense against malicious applications trying to steal data from legitimate applications on the same device.</p>",
                            "image": "https://images.unsplash.com/photo-1599691888286-93e433f064b8?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Permission System Fundamentals",
                            "content": "<p>For an application to do anything outside its own sandbox (like access the camera, read contacts, or connect to the internet), it must first request permission from the user. Android has evolved its permission model significantly.</p><ul><li><strong>Install-time Permissions:</strong> The legacy model. The user was presented with a list of all requested permissions at install time and had to accept them all to install the app.</li><li><strong>Runtime Permissions (Modern):</strong> For dangerous permissions, the application must ask the user for permission the first time it needs to access the resource (e.g., a pop-up asking for camera access). This provides much more granular control to the user.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1548092372-6a7e3206a5a2?w=800&h=400&fit-crop"
                        },
                        {
                            "title": "SELinux in Android",
                            "content": "<p>Security-Enhanced Linux (SELinux) enforces Mandatory Access Control (MAC) at the kernel level. It goes beyond the standard UID/GID file permissions. Every process and resource is assigned a 'security context' label. SELinux policies, defined by the device manufacturer, then dictate exactly which process contexts are allowed to interact with which resource contexts. This provides an incredibly strong second layer of defense, even if a process is running as root.</p>",
                            "image": "https://images.unsplash.com/photo-1629654297299-c8506221ca97?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary purpose of the Android Application Sandbox?", "options": ["To make applications run faster", "To isolate each application in its own process with its own User ID, preventing it from accessing other apps' data", "To manage user permissions", "To scan for viruses"], "correct": 1, "explanation": "The sandbox, enforced by the Linux kernel, is the fundamental security boundary that provides both process and data isolation for all applications." },
                        { "id": 2, "question": "An app that requests access to your camera the first time you try to use that feature is using what kind of permission model?", "options": ["Install-time permissions", "Runtime permissions", "SELinux context permissions", "No permissions"], "correct": 1, "explanation": "The modern runtime permission model provides more context and control to the user by asking for permissions as they are needed, rather than all at once during installation." }
                    ]
                }
            },
            {
                "id": "lesson-2-android-dev-basics",
                "title": "Lesson 2: Android Development Basics for Pentesters",
                "duration": "120 min",
                "objectives": [
                    "Identify the four main Android app components: Activities, Services, Broadcast Receivers, and Content Providers",
                    "Understand the Activity and Service lifecycle and their security implications",
                    "Deconstruct the AndroidManifest.xml file to understand an app's structure and permissions",
                    "Explain the role of the Intent system for Inter-Process Communication (IPC)"
                ],
                "content": {
                    "overview": "To break an Android app, you must first understand how it is built. This lesson provides a crash course in the core components and concepts of Android development from a security tester's perspective. We will focus on the architectural components that form the primary attack surface.",
                    "sections": [
                        {
                            "title": "The Four Main App Components",
                            "content": "<p>An Android app is not a single, monolithic program. It is a collection of components that can be activated as needed.</p><ul><li><strong>Activity:</strong> A single screen with a user interface. This is what the user sees and interacts with.</li><li><strong>Service:</strong> A component that runs in the background to perform long-running operations, like playing music or fetching data. It has no UI.</li><li><strong>Broadcast Receiver:</strong> A component that listens for and responds to system-wide broadcast messages (events), such as 'the battery is low' or 'a new SMS has arrived'.</li><li><strong>Content Provider:</strong> A component that manages a shared set of application data, providing a structured interface to its database (often SQLite).</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit-crop"
                        },
                        {
                            "title": "The AndroidManifest.xml File",
                            "content": "<p>This is the single most important file for a security reviewer to analyze first. It is the 'blueprint' of the application. Before any code is run, the Android OS reads this XML file to understand the app's structure and capabilities.</p><h3>What the Manifest Declares:</h3><ul><li><strong>Package Name:</strong> The app's unique identifier.</li><li><strong>Permissions:</strong> All permissions the app requests.</li><li><strong>Components:</strong> It must declare every Activity, Service, Broadcast Receiver, and Content Provider.</li><li><strong>Exported Status:</strong> Critically, it declares which of these components are `exported`. An exported component can be launched or accessed by other applications on the device. An unexported component cannot. Any exported component is part of the application's attack surface.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1517694712202-14261e80e3a5?w=800&h=400&fit-crop"
                        },
                        {
                            "title": "The Intent System (IPC)",
                            "content": "<p>Intents are the messaging objects used for communication between app components. It is the primary method of Inter-Process Communication (IPC) on Android. For example, an Activity can send an Intent to start a Service. An insecurely configured component that accepts an Intent from any other app can be a major source of vulnerabilities.</p>",
                            "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the core function of the AndroidManifest.xml file?", "options": ["To store user data", "To present essential information about the application to the Android system before the app runs", "To contain the application's compiled code", "To handle user interface events"], "correct": 1, "explanation": "The manifest is the blueprint, declaring the app's components, permissions, and other essential metadata required by the Android OS." },
                        { "id": 2, "question": "An `exported` component in the manifest file signifies what?", "options": ["It is not a part of the application", "It is only used for debugging", "It can be launched or accessed by other applications on the same device, making it part of the attack surface", "It has been deleted from the app"], "correct": 2, "explanation": "The `android:exported` attribute is a critical security control. Any exported component is a potential entry point for a malicious application to interact with the vulnerable app." },
                        { "id": 3, "question": "Which component is responsible for providing a user interface?", "options": ["Service", "Activity", "Broadcast Receiver", "Content Provider"], "correct": 1, "explanation": "An Activity represents a single screen that the user can interact with." }
                    ]
                }
            },
            {
                "id": "lesson-3-testing-environment-setup",
                "title": "Lesson 3: Mobile Security Testing Environment",
                "duration": "180 min",
                "objectives": [
                    "Set up the Android Debug Bridge (ADB) for device interaction",
                    "Configure and use the Android Studio emulator for dynamic analysis",
                    "Understand the benefits and risks of using a rooted physical device",
                    "Install and configure essential testing tools like Frida and Burp Suite for mobile testing"
                ],
                "content": {
                    "overview": "You cannot test what you cannot see. A properly configured testing environment is non-negotiable for mobile security. This lesson provides a complete, hands-on guide to setting up a professional mobile testing lab, including emulators, rooted devices, and the core tools you will use for the rest of the course.",
                    "sections": [
                        {
                            "title": "The Android Debug Bridge (ADB)",
                            "content": "<p>ADB is the essential command-line tool for interacting with an Android device, whether it's an emulator or a physical device. It is part of the Android SDK Platform-Tools.</p><h3>Key ADB Commands:</h3><ul><li><strong>`adb devices`:</strong> Lists all connected devices and emulators.</li><li><strong>`adb shell`:</strong> Gives you a command-line shell *inside* the Android device.</li><li><strong>`adb push [local_path] [remote_path]`:</strong> Pushes a file from your computer to the device.</li><li><strong>`adb pull [remote_path] [local_path]`:</strong> Pulls a file from the device to your computer.</li><li><strong>`adb install [app.apk]`:</strong> Installs an application.</li><li><strong>`adb logcat`:</strong> Shows the live system log from the device, which is invaluable for debugging.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=800&h=400&fit-crop"
                        },
                        {
                            "title": "Emulator vs. Rooted Device",
                            "content": "<p>Dynamic analysis requires an environment with root access. You have two main choices.</p><ul><li><strong>Android Emulator (from Android Studio):</strong> The safest and easiest option. It's a virtual Android device that runs on your computer. You can create emulators for any Android version and device type, and they provide root access by default.</li><li><strong>Rooted Physical Device:</strong> This gives you a real-world testing environment. Rooting is the process of gaining privileged (root) access to the Android OS. This is often necessary for testing features that require specific hardware (like NFC or biometrics) that an emulator can't provide. However, it can be a complex process and risks 'bricking' the device if done incorrectly.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1607252650355-f7fd0460ccdb?w=800&h=400&fit-crop"
                        },
                        {
                            "title": "Configuring Burp Suite for Mobile",
                            "content": "<p>To intercept and analyze an application's network traffic, you need to configure your device to proxy its traffic through Burp Suite.</p><h3>The Setup Steps:</h3><ol><li>Configure Burp to listen on all interfaces (not just localhost).</li><li>Configure the Wi-Fi settings on your Android device to use your computer's IP address and Burp's port (e.g., 8080) as its proxy.</li><li>Install Burp's CA certificate on the Android device so that Burp can intercept and decrypt HTTPS traffic. Note: On modern Android versions, this has become more difficult and often requires root access and tools like Magisk to install the certificate into the system's trusted store.</li></ol>",
                            "image": "https://images.unsplash.com/photo-1555949963-aa79dcee981c?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Basic ADB Shell Interaction",
                        "language": "bash",
                        "code": "# Connect to a device and get a shell\nadb shell\n\n# Inside the shell, you can run Linux commands\n# List the contents of the SD card\nls /sdcard/\n\n# Become root (on a rooted device or emulator)\nsu\n\n# List the contents of an app's private data directory\nls /data/data/com.example.app"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary command-line tool used to interface with an Android device?", "options": ["fastboot", "ssh", "The Android Debug Bridge (ADB)", "telnet"], "correct": 2, "explanation": "ADB is the fundamental tool that allows a security tester to install apps, get a shell, transfer files, and view logs on a device." },
                        { "id": 2, "question": "For a security researcher, what is the primary advantage of using a rooted device or an emulator?", "options": ["It has better battery life", "It provides the privileged (root) access necessary to inspect an application's private data and use advanced dynamic analysis tools", "It is more secure", "It cannot be infected with malware"], "correct": 1, "explanation": "Root access is essential for deep dynamic analysis and for bypassing many of the standard OS protections to see what an application is truly doing." },
                        { "id": 3, "question": "To intercept and decrypt HTTPS traffic from a mobile app, you must do what?", "options": ["Ask the app developer for the data", "Use a faster Wi-Fi network", "Configure the device to proxy through a tool like Burp Suite and install Burp's CA certificate on the device", "It is not possible to decrypt HTTPS traffic"], "correct": 2, "explanation": "This allows your proxy tool to perform a man-in-the-middle on the app's traffic, which is the core of network traffic analysis for mobile security." }
                    ]
                }
            },
            {
                "id": "lesson-4-android-app-structure",
                "title": "Lesson 4: Android Application Structure",
                "duration": "120 min",
                "objectives": [
                    "Deconstruct the structure of an Android Application Package (APK) file",
                    "Understand the role of the `classes.dex` file and Dalvik bytecode",
                    "Analyze an app's resource files, assets, and native libraries",
                    "Begin the process of reverse engineering with a hands-on lab"
                ],
                "content": {
                    "overview": "An Android app is delivered as a single file with a `.apk` extension. This lesson covers how to unpack and deconstruct this file to understand its internal structure, laying the groundwork for static analysis. You will learn about the key files inside an APK, from the compiled code to the resource files.",
                    "sections": [
                        {
                            "title": "APK File Format Analysis",
                            "content": "<p>An APK file is simply a ZIP archive. You can unzip it to see its contents.</p><h3>Key Files Inside an APK:</h3><ul><li><strong>`AndroidManifest.xml`:</strong> The app's blueprint, in a compiled binary XML format.</li><li><strong>`classes.dex`:</strong> The application's compiled code, in the Dalvik Executable (DEX) bytecode format. There may be multiple `classes.dex` files.</li><li><strong>`resources.arsc`:</strong> A file containing pre-compiled resources.</li><li><strong>`res/`:</strong> A directory containing resources that were not compiled into `resources.arsc`.</li><li><strong>`assets/`:</strong> A directory for raw asset files, like a web page to be shown in a WebView.</li><li><strong>`lib/`:</strong> A directory containing compiled native code (C/C++) for different CPU architectures (e.g., `armeabi-v7a`, `arm64-v8a`, `x86_64`).</li><li><strong>`META-INF/`:</strong> A directory containing the application's signature, which verifies its integrity.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "An APK file is actually a standard _____ file.", "options": ["TAR", "RAR", "ZIP", "GZ"], "correct": 2, "explanation": "Understanding that an APK is just a zip archive is the first step in reverse engineering, as you can simply unzip it to start exploring its contents." },
                        { "id": 2, "question": "The compiled Java/Kotlin code of an Android application is stored in which file?", "options": ["AndroidManifest.xml", "resources.arsc", "classes.dex", "lib/"], "correct": 2, "explanation": "The `.dex` files contain the Dalvik bytecode that will be executed by the Android runtime. They are the primary target for disassembly and decompilation." }
                    ]
                }
            },
            {
                "id": "lesson-5-apk-disassembly",
                "title": "Lesson 5: APK Disassembly and Decompilation",
                "duration": "150 min",
                "objectives": [
                    "Master the use of `apktool` to correctly disassemble and rebuild an APK",
                    "Analyze the human-readable Smali code generated by disassembly",
                    "Use tools like `dex2jar` and `jd-gui` to decompile DEX bytecode back to Java source code",
                    "Extract and analyze application resources"
                ],
                "content": {
                    "overview": "This is the first hands-on reverse engineering lesson. You will learn how to take a compiled APK and convert its contents back into a human-readable format. We will cover the two main approaches: disassembly (to low-level but accurate Smali code) and decompilation (to higher-level but sometimes imperfect Java code).",
                    "sections": [
                        {
                            "title": "`apktool` for Disassembly",
                            "content": "<p>`apktool` is the essential tool for APK reverse engineering. It correctly disassembles the APK's resources and code.</p><h3>What `apktool` Does:</h3><ul><li>It decodes the binary `AndroidManifest.xml` back into a readable XML file.</li><li>It decodes the `resources.arsc` file.</li><li>Most importantly, it disassembles the `classes.dex` file into a set of `.smali` files. Smali is a human-readable assembly language for the Dalvik virtual machine. Analyzing Smali is more complex than Java, but it is a more accurate representation of the original compiled code.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1517694712202-14261e80e3a5?w=800&h=400&fit-crop"
                        },
                        {
                            "title": "Decompilation to Java",
                            "content": "<p>While Smali is accurate, it's difficult to read. For a higher-level understanding, we can decompile the DEX bytecode back to Java source code. This is a multi-step process.</p><h3>The Decompilation Workflow:</h3><ol><li>Use a tool like `dex2jar`. It takes the `classes.dex` file as input and converts it into a standard Java Archive (`.jar`) file.</li><li>Open this new `.jar` file with a Java decompiler, such as `jd-gui` or `Jadx`. These tools will show you the decompiled Java source code.</li></ol><div class='info-box warning'><div class='info-box-header'><i class='fas fa-exclamation-triangle'></i><strong>Imperfect Results</strong></div><p>Decompilation is not a perfect process. If the application has been obfuscated, the decompiled code may be difficult or impossible to read. The code you see is the decompiler's best guess, not the original source code. For 100% accuracy, you must refer to the Smali code.</p></div>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Disassemble an APK with `apktool`",
                        "language": "bash",
                        "code": "# This command will take myapp.apk and create a directory 'myapp' with the disassembled code and resources.\napktool d myapp.apk"
                    },
                    {
                        "title": "Decompile DEX to JAR and View",
                        "language": "bash",
                        "code": "# Step 1: Convert the classes.dex file to a JAR file.\n# The dex2jar tool is often available as `d2j-dex2jar`.\nd2j-dex2jar classes.dex\n\n# This will produce a file named 'classes-dex2jar.jar'\n\n# Step 2: Open the JAR file with a graphical decompiler to view the Java code.\njd-gui classes-dex2jar.jar"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Which tool is primarily used to disassemble an APK into Smali code and readable XML?", "options": ["adb", "`apktool`", "`dex2jar`", "`jd-gui`"], "correct": 1, "explanation": "`apktool` is the foundational tool for APK disassembly." },
                        { "id": 2, "question": "The purpose of a Java decompiler like `jd-gui` is to:", "options": ["Disassemble code to Smali", "Convert a `.jar` file into human-readable (but not always perfect) Java source code", "Install an APK", "Sign an APK"], "correct": 1, "explanation": "Decompilers reverse the compilation process to provide a higher-level view of the application's logic, which is much easier for a human to understand than bytecode." }
                    ]
                }
            },
            {
                "id": "lesson-6-manifest-security-analysis",
                "title": "Lesson 6: Manifest Security Analysis",
                "duration": "120 min",
                "objectives": [
                    "Perform a thorough security review of the AndroidManifest.xml file",
                    "Identify overly permissive permission declarations",
                    "Assess the risk of exported components that could be attacked by other apps",
                    "Verify the integrity of the application's signature"
                ],
                "content": {
                    "overview": "The `AndroidManifest.xml` is the first and most important file to analyze in a security review. It provides a complete map of the application's attack surface. This lesson covers how to perform a systematic security analysis of a decompiled manifest file to find common and critical misconfigurations.",
                    "sections": [
                        {
                            "title": "Component Exposure Assessment",
                            "content": "<p>The single most important part of a manifest review is to identify all exported components. An exported Activity, Service, or Broadcast Receiver is a potential entry point for a malicious app to attack your app.</p><h3>The `android:exported` Attribute:</h3><ul><li>If a component has an `intent-filter`, the default value of `exported` is `true`. This is a common source of vulnerabilities.</li><li>A developer must explicitly set `android:exported=\"false\"` for any component that is meant for internal use only.</li><li>Any component you find that is exported is a part of the attack surface and must be closely examined to see how it handles incoming intents from other apps.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1517694712202-14261e80e3a5?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Permission Declaration Review",
                            "content": "<p>Review the `<uses-permission>` tags. Does the application follow the principle of least privilege? Does a simple calculator app really need permission to read your contacts and send SMS messages? Overly broad permission requests can be a sign of a malicious app or just sloppy development, but in either case, they create unnecessary risk.</p>",
                            "image": "https://images.unsplash.com/photo-1548092372-6a7e3206a5a2?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary security concern with an `exported` Android component?", "options": ["It is not a concern", "It can be launched or accessed by any other app on the device, making it an entry point for an attack", "It makes the app run slower", "It uses too much memory"], "correct": 1, "explanation": "Exported components are the 'front doors' of your application that other apps can knock on. You must ensure they are properly secured." }
                    ]
                }
            },
            {
                "id": "lesson-7-source-code-review",
                "title": "Lesson 7: Source Code Security Review",
                "duration": "180 min",
                "objectives": [
                    "Perform a manual security review of decompiled Java/Kotlin code",
                    "Identify common vulnerabilities like hard-coded secrets and insecure data storage",
                    "Assess the security of third-party libraries and SDKs",
                    "Understand how code obfuscation attempts to thwart reverse engineering"
                ],
                "content": {
                    "overview": "With the code now in a readable format, we can begin the white-box analysis. This lesson covers how to perform a manual source code security review on the decompiled Java/Kotlin code, looking for common vulnerabilities and security anti-patterns that automated scanners might miss.",
                    "sections": [
                        {
                            "title": "Finding Vulnerabilities in Code",
                            "content": "<p>Reading decompiled code requires patience, but it can reveal critical flaws.</p><h3>What to Grep For:</h3><ul><li><strong>Hard-coded Secrets:</strong> Search for keywords like `password`, `apiKey`, `secret`, `token`. Developers often make the mistake of embedding sensitive credentials directly in the code.</li><li><strong>Insecure Data Storage:</strong> Look for code that writes sensitive data to insecure locations, like a plain text file on the SD card (which is accessible to any app with storage permission).</li><li><strong>Weak Cryptography:</strong> Look for the use of weak or deprecated crypto algorithms (like DES) or hard-coded encryption keys.</li><li><strong>Logging:</strong> Look at what the application is logging with `Log.d()`. Developers often accidentally log sensitive user data (like passwords or session tokens), which can be read by any app with `READ_LOGS` permission or via `adb logcat`.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit-crop"
                        },
                        {
                            "title": "Code Obfuscation",
                            "content": "<p>Developers will often use a tool like ProGuard to obfuscate their code before release. Obfuscation renames classes, methods, and variables to short, meaningless names (like `a.a.a()`). This does not change how the code works, but it makes it much harder for a human to read and understand during reverse engineering. De-obfuscation is a complex, manual process of re-naming variables and functions based on their context to try and reconstruct the original logic.</p>",
                            "image": "https://images.unsplash.com/photo-1555099962-4199c345e541?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Searching the source code for the string 'apiKey' would be an attempt to find what kind of vulnerability?", "options": ["An exported component", "Hard-coded secrets", "Weak encryption", "Insufficient logging"], "correct": 1, "explanation": "Finding sensitive keys, passwords, or tokens hard-coded directly in the source code is a very common and critical vulnerability." },
                        { "id": 2, "question": "The process of renaming classes and methods to meaningless letters to make reverse engineering more difficult is called:", "options": ["Compilation", "Encryption", "Obfuscation", "Decompilation"], "correct": 2, "explanation": "Obfuscation is a defensive technique that acts as a roadblock for manual source code review, but it does not make exploitation impossible for a dedicated attacker." }
                    ]
                }
            },
            {
                "id": "lesson-8-automated-static-analysis",
                "title": "Lesson 8: Automated Static Analysis (SAST)",
                "duration": "120 min",
                "objectives": [
                    "Leverage Static Application Security Testing (SAST) tools to find vulnerabilities automatically",
                    "Configure and run tools like MobSF and QARK against an APK",
                    "Analyze and triage the results from a SAST scanner",
                    "Understand how to integrate SAST into a DevSecOps pipeline"
                ],
                "content": {
                    "overview": "Manual code review is powerful but slow. Automated static analysis (SAST) is essential for finding common vulnerabilities at scale. This lesson covers how to use automated tools to scan an application's source code and compiled package for security flaws.",
                    "sections": [
                        {
                            "title": "Mobile Security Framework (MobSF)",
                            "content": "<p>MobSF is an incredibly powerful, all-in-one open-source mobile security assessment framework. You can upload an APK, and it will automatically perform a full static analysis, including:</p><ul><li>Unpacking the APK and decompiling the code.</li><li>Analyzing the manifest for misconfigurations.</li><li>Scanning the code for hard-coded secrets, insecure permissions, and other common vulnerabilities.</li><li>Generating a comprehensive HTML report with all its findings.</li></ul><p>MobSF can also perform dynamic analysis, which we will explore later.</p>",
                            "image": "https://images.unsplash.com/photo-1518770660439-4636190af475?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary function of a SAST tool?", "options": ["To attack a running application", "To analyze an application's source code or binary for security vulnerabilities without executing it", "To monitor network traffic", "To manage user permissions"], "correct": 1, "explanation": "Static analysis (SAST) is a 'white-box' testing methodology that looks for vulnerability patterns in the code itself." }
                    ]
                }
            },
            {
                "id": "lesson-9-runtime-analysis-fundamentals",
                "title": "Lesson 9: Runtime Analysis Fundamentals with Frida",
                "duration": "150 min",
                "objectives": [
                    "Understand the principles of dynamic instrumentation",
                    "Set up and use the Frida framework for runtime analysis",
                    "Write basic Frida scripts to hook into a running application's methods",
                    "Monitor and modify an application's behavior in real time"
                ],
                "content": {
                    "overview": "Static analysis only shows you what the code *can* do. Dynamic analysis shows you what it *is* doing. This lesson introduces Frida, the most powerful and popular dynamic instrumentation toolkit for mobile security. You will learn how to inject your own code into a running application to observe and manipulate its behavior in real time.",
                    "sections": [
                        {
                            "title": "Dynamic Instrumentation",
                            "content": "<p>Dynamic instrumentation is the process of modifying a program's behavior while it is running. Frida works by injecting a JavaScript engine into the target application's process. You can then write JavaScript scripts that execute within the application's memory space. This gives you god-like control over the app.",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit-crop"
                        },
                        {
                            "title": "Hooking with Frida",
                            "content": "<p>The core technique is 'hooking'. You can write a Frida script to find a specific class and method in the application's code and 'hook' it. This means your script will run *instead of* the original method, or *before* and *after* it. You can inspect the arguments passed to the method, view its return value, or even change the arguments and return value on the fly.</p><p>This is incredibly powerful for bypassing client-side security controls, analyzing encryption routines, and understanding what an application is doing at a very deep level.</p>",
                            "image": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Launching an App with Frida",
                        "language": "bash",
                        "code": "# This command uses Frida to start the 'com.example.app' application on a connected device\n# and inject the 'myscript.js' script into it. The '--no-pause' tells it to run immediately.\nfrida -U -f com.example.app -l myscript.js --no-pause"
                    },
                    {
                        "title": "Basic Frida Hooking Script (JavaScript)",
                        "language": "javascript",
                        "code": "/* myscript.js */\n// This script waits for the app to load and then hooks a method.\nJava.perform(function() {\n    // Find the class we want to hook\n    var TargetClass = Java.use('com.example.app.SecurityUtils');\n    \n    // Hook the 'checkPin' method\n    TargetClass.checkPin.implementation = function(pin) {\n        console.log(\"[+] Intercepted PIN check. Argument was: \" + pin);\n        \n        // Bypass the check by always calling the original method with the correct PIN\n        var result = this.checkPin(\"1337\");\n        \n        console.log(\"[+] Pin check bypassed. Original result was: \" + result);\n        return true; // Always return true\n    };\n});"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary function of Frida?", "options": ["To decompile an APK", "To provide a dynamic instrumentation framework that allows you to inject JavaScript into running applications to modify their behavior", "To analyze an app's manifest file", "To sign an APK"], "correct": 1, "explanation": "Frida is the essential tool for runtime analysis and manipulation, giving a tester deep control over a running application." },
                        { "id": 2, "question": "'Hooking' a method with Frida allows you to do what?", "options": ["Delete the method from the application", "Intercept calls to that method, inspect its arguments and return value, and even change them", "Make the method run faster", "Recompile the application"], "correct": 1, "explanation": "Hooking is the core technique in dynamic instrumentation, giving you a powerful interception point to analyze and control the application's logic at runtime." }
                    ]
                }
            },
            {
                "id": "lesson-10-network-traffic-analysis",
                "title": "Lesson 10: Network Traffic Analysis",
                "duration": "120 min",
                "objectives": [
                    "Configure a device or emulator to proxy traffic through Burp Suite or OWASP ZAP",
                    "Bypass SSL/TLS certificate pinning to intercept encrypted traffic",
                    "Analyze API communication for vulnerabilities and data leakage",
                    "Understand how to test for insecure network protocols"
                ],
                "content": {
                    "overview": "Analyzing an application's network traffic is a core dynamic analysis task. It reveals what data the app is sending and receiving, how it communicates with its backend APIs, and whether it is doing so securely. This lesson covers how to set up an interception proxy and how to bypass the most common anti-interception defense: certificate pinning.",
                    "sections": [
                        {
                            "title": "Certificate Pinning Bypass",
                            "content": "<p>Many security-conscious applications implement 'SSL/TLS certificate pinning'. This is a security control where the application is coded to *only* trust the server's specific, hard-coded SSL certificate. If the app detects any other certificate (like the one generated by Burp Suite during a man-in-the-middle attack), it will refuse to connect. This is a powerful defense.</p><h3>Bypassing with Frida:</h3><p>We can use Frida to bypass this. An attacker can write a Frida script to hook the low-level library functions responsible for certificate validation within the application. The script can be designed to always return 'true', effectively tricking the application into trusting the Burp Suite certificate and allowing the traffic to be intercepted and decrypted.</p>",
                            "image": "https://images.unsplash.com/photo-1544890225-2fde1e46f71b?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is SSL/TLS Certificate Pinning?", "options": ["A way to make HTTPS connections faster", "A security mechanism where an application is hard-coded to only trust a specific server certificate, which can prevent man-in-the-middle attacks from proxies like Burp Suite", "A feature of the Android OS", "A type of firewall"], "correct": 1, "explanation": "Certificate pinning is a strong security control that is specifically designed to thwart network interception by tools like Burp and ZAP." },
                        { "id": 2, "question": "What is the most common and effective way to bypass certificate pinning for a security assessment?", "options": ["Using an older version of the app", "Using Frida to hook the application's certificate validation functions at runtime and force them to trust your proxy's certificate", "Connecting to a different Wi-Fi network", "Asking the developer to remove it"], "correct": 1, "explanation": "This is a classic use case for Frida. Bypassing certificate pinning is often one of the first steps in a mobile application penetration test." }
                    ]
                }
            },
            {
                "id": "lesson-11-filesystem-database-analysis",
                "title": "Lesson 11: File System and Database Analysis",
                "duration": "120 min",
                "objectives": [
                    "Navigate the Android file system on a rooted device",
                    "Analyze an application's local data storage for insecure practices",
                    "Extract and analyze data from SQLite databases and Shared Preferences files"
                ],
                "content": {
                    "overview": "This lesson focuses on the data at rest. You will learn how to navigate the Android file system on a rooted device and inspect an application's private data directory. The goal is to find sensitive data that is being stored insecurely.",
                    "sections": [
                        {
                            "title": "Key Storage Locations",
                            "content": "<p>On a rooted device, you can use the `adb shell` to explore an app's private data directory, typically found at `/data/data/[package_name]`. Within this directory, you will find several key subdirectories:</p><ul><li><strong>`databases/`:</strong> This is where SQLite databases are stored. You can `adb pull` the database files to your computer and use a tool like `DB Browser for SQLite` to inspect their contents.</li><li><strong>`shared_prefs/`:</strong> This contains Shared Preferences, which are simple XML files used for storing key-value pairs of data.</li><li><strong>`files/`:</strong> For general file storage.</li></ul><p>The goal is to look for sensitive information (passwords, API keys, user PII) stored in these locations without encryption.</p>",
                            "image": "https://images.unsplash.com/photo-1542382156942-0268579cf259?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "On a rooted device, an application's private data, including its databases, is typically stored where?", "options": ["On the SD card (`/sdcard/`)", "In the `/system/app/` directory", "In the `/data/data/[package_name]/` directory", "It is not stored on the device"], "correct": 2, "explanation": "This directory is protected by file system permissions. Root access is required to bypass these permissions and inspect the app's private data." }
                    ]
                }
            },
            {
                "id": "lesson-12-protection-bypass",
                "title": "Lesson 12: Runtime Application Protection Bypass",
                "duration": "120 min",
                "objectives": [
                    "Bypass common anti-debugging and anti-tampering checks",
                    "Use various techniques to evade root detection",
                    "Understand how applications detect emulators and how to bypass it"
                ],
                "content": {
                    "overview": "Many high-security applications (like banking apps) include their own built-in runtime protections. They will try to detect if they are running on a rooted device, in an emulator, or if a debugger is attached, and will refuse to run if they find these conditions. This lesson covers how to use dynamic instrumentation to bypass these checks.",
                    "sections": [
                        {
                            "title": "Bypassing Root Detection",
                            "content": "<p>Applications use several methods to check for root, such as looking for the presence of the `su` binary or checking for common root management app packages. A common technique to bypass this is to use Frida to hook the function in the app's code that performs these checks and force it to always return `false`. This tricks the application into believing it is running on a non-rooted device.</p>",
                            "image": "https://images.unsplash.com/photo-1614064548237-02f8f17374b2?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary tool a security researcher would use to bypass an application's root detection mechanism at runtime?", "options": ["ADB", "`apktool`", "Frida", "A text editor"], "correct": 2, "explanation": "Frida's ability to hook and modify the return values of methods is perfectly suited for this task. You find the method that returns `isDeviceRooted()` and use Frida to make it always return `false`." }
                    ]
                }
            },
            {
                "id": "lesson-13-permission-model",
                "title": "Lesson 13: Android Permission Model",
                "duration": "120 min",
                "objectives": [
                    "Differentiate between normal, dangerous, and signature permissions",
                    "Understand how to test the runtime permission request flow",
                    "Identify risks associated with creating and using custom permissions"
                ],
                "content": {
                    "overview": "This lesson provides a deep dive into the Android permission model, a core component of the security architecture. We will explore the different protection levels and the security implications of each.",
                    "sections": [
                        {
                            "title": "Permission Protection Levels",
                            "content": "<ul><li><strong>Normal:</strong> Low-risk permissions that are granted automatically at install time (e.g., `ACCESS_NETWORK_STATE`).</li><li><strong>Dangerous:</strong> High-risk permissions that give an app access to user private data or control over the device. The app must prompt the user for these at runtime (e.g., `READ_CONTACTS`, `CAMERA`).</li><li><strong>Signature:</strong> The most restrictive. A permission with this level is only granted to another app if it is signed with the *same cryptographic key* as the app that defined the permission. This is used to securely share data between a company's own suite of applications.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1548092372-6a7e3206a5a2?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is a 'signature' level permission used for?", "options": ["To grant a permission to any app", "To grant a permission only to other apps signed by the same developer", "To request a dangerous permission at runtime", "To request access to the internet"], "correct": 1, "explanation": "Signature permissions provide a secure, high-trust mechanism for a developer's own apps to share data and functionality with each other, without exposing those components to other third-party apps." }
                    ]
                }
            },
            {
                "id": "lesson-14-component-security",
                "title": "Lesson 14: Component Security Testing",
                "duration": "120 min",
                "objectives": [
                    "Test for vulnerabilities in exported Activities, Services, Broadcast Receivers, and Content Providers",
                    "Use ADB to manually interact with exported components",
                    "Understand how to abuse unprotected components to cause denial of service or data leakage"
                ],
                "content": {
                    "overview": "Any 'exported' component is an entry point to your application. This lesson covers how to test these exported components to see if they can be abused by a malicious application installed on the same device.",
                    "sections": [
                        {
                            "title": "Testing with ADB Activity Manager (`am`)",
                            "content": "<p>You can use the ADB `am` (Activity Manager) tool to manually craft and send intents to exported components to test their security.</p><p>For example, if you find an exported Activity, you can try to launch it directly from the ADB shell. If it launches and it's a sensitive page that should only be accessible after logging in, you have found an access control bypass. A well-secured Activity should perform an authorization check in its `onCreate()` method before displaying any sensitive UI.</p>",
                            "image": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Launch an Exported Activity via ADB",
                        "language": "bash",
                        "code": "# This command uses the Activity Manager (`am`) to start a specific component.\nadb shell am start -n com.victim.app/.SecretActivity"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary risk of exporting an Activity that displays sensitive information?", "options": ["It is not a risk", "A malicious app on the same device can directly launch that Activity, bypassing any preceding login or navigation flow, to access the sensitive data", "It uses more battery", "It requires a special permission"], "correct": 1, "explanation": "This is a classic broken access control vulnerability. Any exported Activity must perform its own authorization checks to ensure the user is allowed to see it." }
                    ]
                }
            },
            {
                "id": "lesson-15-intent-security",
                "title": "Lesson 15: Intent Security",
                "duration": "120 min",
                "objectives": [
                    "Identify and exploit vulnerabilities related to Intent handling",
                    "Understand the risks of Intent hijacking and spoofing",
                    "Differentiate between implicit and explicit Intents and their security implications"
                ],
                "content": {
                    "overview": "Intents are the messaging system of Android, but if not used securely, they can be a source of data leakage and other vulnerabilities. This lesson focuses on the security of the Intent system itself.",
                    "sections": [
                        {
                            "title": "Implicit vs. Explicit Intents",
                            "content": "<ul><li><strong>Explicit Intent:</strong> You explicitly name the target component (e.g., `startActivity(new Intent(this, TargetActivity.class))`). This is secure because only that specific component can receive the intent.</li><li><strong>Implicit Intent:</strong> You do not name the target. Instead, you specify an 'action' (e.g., `ACTION_SEND`). The Android system then finds a component on the device that has an `intent-filter` registered for that action. This is less secure. If two apps can handle the same action, the user might be shown a chooser. This can lead to vulnerabilities like Intent hijacking if a malicious app can register for the same action as a legitimate app.</li></ul><p>Best practice is to always use explicit intents for communication between components inside your own application.</p>",
                            "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "For internal communication within your own app, which type of Intent is more secure?", "options": ["Implicit Intent", "Explicit Intent", "Both are equally secure", "Neither is secure"], "correct": 1, "explanation": "An explicit Intent ensures that the message can only be delivered to the specific component you named, preventing any other malicious app from intercepting it." }
                    ]
                }
            },
            {
                "id": "lesson-16-ipc-security",
                "title": "Lesson 16: IPC Security Analysis",
                "duration": "120 min",
                "objectives": [
                    "Test for vulnerabilities in Inter-Process Communication (IPC) mechanisms",
                    "Assess the security of Binder, the core IPC framework",
                    "Identify flaws in AIDL interface implementations",
                    "Exploit insecure Messenger services"
                ],
                "content": {
                    "overview": "This advanced lesson provides a deeper look at Android's core Inter-Process Communication (IPC) mechanism, Binder. We will explore how vulnerabilities can arise in the complex, low-level communication between different processes on the system.",
                    "sections": [
                        {
                            "title": "Binder Security",
                            "content": "<p>Binder is the high-performance kernel driver that facilitates most IPC on Android. The AIDL (Android Interface Definition Language) is used to define the interface for a remote service that other processes can interact with via Binder. Vulnerabilities in how these AIDL interfaces are implemented (e.g., failing to check the calling UID of a process trying to access a method) can lead to critical access control bypasses.</p>",
                            "image": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is Binder?", "options": ["A type of user account", "The core, kernel-level Inter-Process Communication (IPC) framework in Android", "A security vulnerability", "A mobile application"], "correct": 1, "explanation": "Understanding Binder is key to understanding the deep internals of Android IPC and how its security is enforced at a low level." }
                    ]
                }
            },
            {
                "id": "lesson-17-data-storage-security",
                "title": "Lesson 17: Data Storage Security",
                "duration": "120 min",
                "objectives": [
                    "Assess the security of data stored in internal and external storage",
                    "Identify sensitive data stored without encryption in databases and preference files",
                    "Test the application's use of the Android Keystore for cryptographic operations"
                ],
                "content": {
                    "overview": "This lesson is a deep dive into data-at-rest security. We will systematically explore the different places an application can store data and assess whether that data is being stored securely.",
                    "sections": [
                        {
                            "title": "External vs. Internal Storage",
                            "content": "<ul><li><strong>Internal Storage:</strong> The default and secure location. Data stored in `/data/data/[package_name]` is protected by the application sandbox.</li><li><strong>External Storage (SD Card):</strong> This is globally readable and writable by any application that has the `WRITE_EXTERNAL_STORAGE` permission. Storing sensitive, unencrypted data on external storage is a major vulnerability, as any other app can read it.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542382156942-0268579cf259?w=800&h=400&fit-crop"
                        },
                        {
                            "title": "Android Keystore",
                            "content": "<p>The Android Keystore is the correct place to store cryptographic keys. The Keystore provides a secure, hardware-backed container (often in the Trusted Execution Environment - TEE) that protects key material from being extracted. An application can use the Keystore to generate a key and then use that key for encryption and decryption, but the application can never see the raw key material itself.</p>",
                            "image": "https://images.unsplash.com/photo-1599373922312-5b9340d8a5a5?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Why is it insecure to store sensitive, unencrypted data on external storage?", "options": ["It is not insecure", "External storage is globally readable, meaning any app with storage permission can read the data", "External storage is too slow", "External storage is not big enough"], "correct": 1, "explanation": "The lack of sandboxing on external storage makes it an unsafe place for any sensitive information." },
                        { "id": 2, "question": "What is the primary function of the Android Keystore?", "options": ["To store user contacts", "To provide a secure, hardware-backed container for cryptographic keys, protecting them from extraction", "To store the application's code", "To manage user passwords"], "correct": 1, "explanation": "The Keystore is the fundamental building block for strong, hardware-backed cryptography on the Android platform." }
                    ]
                }
            },
            {
                "id": "lesson-18-cryptography-testing",
                "title": "Lesson 18: Cryptographic Implementation Testing",
                "duration": "120 min",
                "objectives": [
                    "Review the application's use of cryptographic APIs and the Android Keystore",
                    "Identify the use of weak or deprecated encryption algorithms (e.g., DES)",
                    "Test for hard-coded keys and other insecure key management practices"
                ],
                "content": {
                    "overview": "Implementing cryptography correctly is notoriously difficult. This lesson covers how to assess an application's cryptographic code, looking for common mistakes that can completely undermine the security of its data protection.",
                    "sections": [
                        {
                            "title": "Common Crypto Flaws",
                            "content": "<p>Even if an app uses encryption, it may do so insecurely.</p><ul><li><strong>Hard-coded Keys:</strong> The most common flaw. The encryption key is stored as a string literal directly in the source code. A reverse engineer can easily find this key and decrypt all the data.</li><li><strong>Weak Algorithms:</strong> Using outdated and broken algorithms like MD5 for hashing passwords or DES for encryption.</li><li><strong>Insecure Randomness:</strong> Using a predictable random number generator (instead of a cryptographically secure one) to generate keys or initialization vectors.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the most common and critical vulnerability when reviewing an application's custom cryptography code?", "options": ["Using AES-256", "Using a long key", "Finding a hard-coded encryption key embedded directly in the source code", "Storing the encrypted data in a database"], "correct": 2, "explanation": "A hard-coded key completely defeats the purpose of encryption, as anyone who can reverse engineer the application now has the key to decrypt all of its data." }
                    ]
                }
            },
            {
                "id": "lesson-19-backup-security",
                "title": "Lesson 19: Backup and Recovery Security",
                "duration": "120 min",
                "objectives": [
                    "Understand how the Android Auto Backup feature can expose application data",
                    "Use ADB to create and inspect an application's backup",
                    "Implement measures to prevent sensitive data from being included in backups"
                ],
                "content": {
                    "overview": "Application backups, while useful for users, can be a major security risk if they contain unencrypted sensitive data. This lesson covers how to test the security of an application's backup and recovery mechanisms.",
                    "sections": [
                        {
                            "title": "The `allowBackup` Flag",
                            "content": "<p>In the `AndroidManifest.xml`, the `android:allowBackup` flag controls whether the application's private data can be backed up using tools like `adb backup` or the cloud-based Auto Backup feature. By default, this flag is set to `true`.</p><p>If an attacker gains physical access to an unlocked device, they can use `adb backup` to exfiltrate the private data of any application where this flag is true, even without root access. The best practice for an application that handles sensitive data is to set `android:allowBackup=\"false\"` in its manifest to disable this functionality entirely.</p>",
                            "image": "https://images.unsplash.com/photo-1579548122216-3841a12d1b5a?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Setting `android:allowBackup=\"false\"` in the manifest does what?", "options": ["Prevents the app from being installed", "Disables the ability for the app's data to be backed up via `adb backup`, preventing a physical attacker from easily stealing its data", "Deletes the application's data", "Makes the application run faster"], "correct": 1, "explanation": "This is a simple but important security control to prevent data exfiltration from a physically compromised device." }
                    ]
                }
            },
            {
                "id": "lesson-20-sensitive-data-exposure",
                "title": "Lesson 20: Sensitive Data Exposure",
                "duration": "120 min",
                "objectives": [
                    "Find sensitive data being written to system logs (logcat)",
                    "Analyze memory dumps for sensitive information",
                    "Test for vulnerabilities related to screenshot and clipboard caching"
                ],
                "content": {
                    "overview": "Sensitive data can leak in many ways beyond insecure storage on the file system. This lesson covers how to find data exposure in more transient locations, such as system logs, memory, and the Android UI.",
                    "sections": [
                        {
                            "title": "Logging Sensitive Data",
                            "content": "<p>A very common developer mistake is to log sensitive data for debugging purposes and then forget to remove the logging statements in the release version of the app. An attacker with access to the device (either physical or through a malicious app with `READ_LOGS` permission) can use `adb logcat` to view the system log. If the application is logging a user's password, session token, or other PII, the attacker can easily capture it.</p>",
                            "image": "https://images.unsplash.com/photo-1542438408-abb2021e1837?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "UI-based Leakage",
                            "content": "<ul><li><strong>Screenshot Caching:</strong> When an app goes into the background, Android takes a screenshot of its last state to display in the task switcher. If this screen contains sensitive data, that data will be stored as an image on the file system. Developers can set the `FLAG_SECURE` layout parameter to prevent screenshots of sensitive activities.</li><li><strong>Clipboard Caching:</strong> Data copied to the clipboard can be read by any other application. Sensitive data should not be copyable.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1543286386-2e659306cd6c?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary risk of an application logging a user's password?", "options": ["It can make the logs too large", "An attacker or another malicious app can read the logs and steal the password in cleartext", "It is not a risk", "It can slow down the application"], "correct": 1, "explanation": "The system log is often accessible to many different applications and tools, making it a completely insecure place to store sensitive data." },
                        { "id": 2, "question": "The `FLAG_SECURE` is used to prevent what?", "options": ["Insecure data storage", "Network traffic interception", "The Android OS from taking screenshots of a sensitive activity", "The app from being installed"], "correct": 2, "explanation": "This is an important control to prevent sensitive data from being cached as an image on the device." }
                    ]
                }
            },
            {
                "id": "lesson-21-tls-testing",
                "title": "Lesson 21: SSL/TLS Implementation Testing",
                "duration": "120 min",
                "objectives": [
                    "Perform a thorough assessment of an application's SSL/TLS implementation",
                    "Detect failures to validate server certificates",
                    "Assess the strength of the implemented certificate pinning",
                    "Identify the use of weak cipher suites and legacy TLS versions"
                ],
                "content": {
                    "overview": "This lesson focuses entirely on the security of data in transit. We will go beyond basic traffic interception to cover the common flaws in how mobile applications implement (or fail to implement) SSL/TLS, leading to vulnerabilities that allow for man-in-the-middle attacks.",
                    "sections": [
                        {
                            "title": "Certificate Validation Failures",
                            "content": "<p>A common and critical mistake is for an application to accept *any* SSL certificate presented by the server, without properly validating it. This can happen if a developer, trying to debug a connection issue, implements a custom `TrustManager` that blindly trusts all certificates. This completely defeats the purpose of HTTPS and allows an attacker to perform a man-in-the-middle attack with any self-signed certificate. You can test for this by setting up your Burp proxy with an untrusted certificate and seeing if the application still connects.</p>",
                            "image": "https://images.unsplash.com/photo-1544890225-2fde1e46f71b?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the impact if an application fails to properly validate the server's SSL certificate?", "options": ["There is no impact", "An attacker can perform a man-in-the-middle attack and decrypt all the application's network traffic", "The application will run faster", "The application will crash"], "correct": 1, "explanation": "Proper certificate validation is the cornerstone of TLS. A failure to do so means the application cannot be sure who it is talking to, making interception trivial." }
                    ]
                }
            },
            {
                "id": "lesson-22-api-security-testing",
                "title": "Lesson 22: API Security Testing",
                "duration": "120 min",
                "objectives": [
                    "Apply the OWASP API Security Top 10 to mobile backend APIs",
                    "Test for authentication and authorization bypass vulnerabilities",
                    "Identify flaws like BOLA, Mass Assignment, and excessive data exposure"
                ],
                "content": {
                    "overview": "The security of a mobile application is only as strong as the security of its backend APIs. This lesson focuses on using your interception proxy to test for common API vulnerabilities, which are often the root cause of mobile app security failures.",
                    "sections": [
                        {
                            "title": "Applying Web Security to Mobile APIs",
                            "content": "<p>Once you are successfully intercepting the application's traffic with your proxy, you can test its REST APIs for all the classic web vulnerabilities we've discussed elsewhere: Broken Object Level Authorization (BOLA/IDOR), Mass Assignment, SQL Injection, etc. You can use Burp Repeater to manipulate the API requests, change IDs, add parameters, and probe for these common flaws.</p>",
                            "image": "https://images.unsplash.com/photo-1596003906915-013661138ae2?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "You intercept an API request `GET /api/v1/users/123/profile`. You change the ID to `124` and successfully retrieve another user's profile. This is an example of what vulnerability?", "options": ["Weak encryption", "Broken Object Level Authorization (BOLA) / IDOR", "Session fixation", "A manifest misconfiguration"], "correct": 1, "explanation": "This is the classic BOLA/IDOR flaw. The API endpoint failed to perform an authorization check to verify that the authenticated user was actually allowed to view the profile for user ID 124." }
                    ]
                }
            },
            {
                "id": "lesson-23-webview-security",
                "title": "Lesson 23: WebView Security",
                "duration": "120 min",
                "objectives": [
                    "Perform a security assessment of an application's WebView implementation",
                    "Exploit insecure JavaScript bridge interfaces to call native code from JavaScript",
                    "Identify file access vulnerabilities in WebViews"
                ],
                "content": {
                    "overview": "WebViews are an embedded browser component within your native app. They are also a major source of vulnerabilities. An insecurely configured WebView can completely break the security boundary between the web content and the native application, leading to critical exploits.",
                    "sections": [
                        {
                            "title": "JavaScript Bridge Security",
                            "content": "<p>A 'JavaScript bridge' is a feature that allows the native Java/Kotlin code of the app to expose its methods to the JavaScript running inside a WebView. For example, a developer might expose a native method `Android.getGpsLocation()` to the JavaScript.</p><h3>The Vulnerability:</h3><p>This is extremely dangerous if the WebView is also configured to load untrusted web content. An attacker who finds an XSS vulnerability in the web content could then use that XSS to call the exposed native `getGpsLocation()` method, completely bypassing the Android permission system and stealing the user's location. Any exposed JavaScript bridge interface must be considered a highly critical attack surface.</p>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary risk of an insecure JavaScript bridge in a WebView?", "options": ["It can make the app slow", "It can allow a malicious script running in the WebView to call the native code of the application, potentially bypassing Android's security controls", "It can drain the battery", "It increases the app's size"], "correct": 1, "explanation": "The bridge breaks the sandbox, creating a high-risk connection between the untrusted web world and the trusted native application code." }
                    ]
                }
            },
            {
                "id": "lesson-24-deep-link-security",
                "title": "Lesson 24: Deep Link Security",
                "duration": "120 min",
                "objectives": [
                    "Understand how deep links and custom URL schemes are used",
                    "Exploit insecure deep link handling to perform actions or steal data",
                    "Test for App Link / Universal Link validation failures"
                ],
                "content": {
                    "overview": "Deep links are URIs that can launch a native application. If the application does not properly validate the data passed in via a deep link, it can be a significant vulnerability. This lesson covers how to test for and exploit insecure deep link handling.",
                    "sections": [
                        {
                            "title": "Custom URL Scheme Hijacking",
                            "content": "<p>An app can register a custom scheme, like `myapp://`. If two different apps on a phone register the same scheme, the OS may not know which one to launch. A malicious app can try to register a popular app's scheme to try and hijack intents intended for that app.</p><h3>Insecure Data Handling:</h3><p>The bigger risk is when the application blindly trusts the data from the link. For example, if the app `myapp://product?url=http://example.com` will open a WebView to the provided URL, an attacker can craft a link `myapp://product?url=http://attacker.com/malicious.html` to force the app to open their malicious site in its trusted WebView.</p>",
                            "image": "https://images.unsplash.com/photo-1585250184288-5175908b083c?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary security risk of deep links?", "options": ["They are too long", "If the receiving application does not properly validate the data passed in the URI, it can lead to vulnerabilities like XSS, SSRF, or open redirects", "They require a special permission", "They only work on older Android versions"], "correct": 1, "explanation": "A deep link is another form of untrusted user input and must be validated just as rigorously as any input from a web form." }
                    ]
                }
            },
            {
                "id": "lesson-25-authentication-testing",
                "title": "Lesson 25: Authentication Mechanism Testing",
                "duration": "120 min",
                "objectives": [
                    "Test for vulnerabilities in biometric authentication implementations",
                    "Identify weaknesses in PIN and pattern security logic",
                    "Perform a thorough security assessment of OAuth and JWT implementations"
                ],
                "content": {
                    "overview": "This lesson focuses on testing the application's authentication mechanisms themselves. We will cover common flaws in how applications implement biometric, PIN, and modern token-based authentication.",
                    "sections": [
                        {
                            "title": "Biometric Authentication Flaws",
                            "content": "<p>A common mistake in biometric authentication is how the app handles a successful authentication. A poorly implemented app might have its check simply return a `true` or `false`. An attacker with root access can use Frida to hook this method and force it to always return `true`, completely bypassing the fingerprint or face ID check.</p><p>A correct implementation should not rely on a simple boolean. It should use the Android Keystore to create a key that requires biometric authentication to be unlocked. The app can then perform a cryptographic operation with that key. This is much harder to bypass, as the attacker cannot easily fake the cryptographic result without the key, which is protected by the hardware.</p>",
                            "image": "https://images.unsplash.com/photo-1614064548237-02f8f17374b2?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is a common way to bypass a poorly implemented biometric check?", "options": ["Using a photograph of the user", "Using Frida to hook the authentication method and force it to return 'true'", "Guessing the user's PIN", "It cannot be bypassed"], "correct": 1, "explanation": "If the logic relies on a simple boolean flag, a runtime instrumentation tool like Frida can easily manipulate this logic flow and bypass the check." }
                    ]
                }
            },
            
            {
                "id": "lesson-26-session-management",
                "title": "Lesson 26: Session Management Security",
                "duration": "120 min",
                "objectives": [
                    "Perform deep analysis of session token generation and entropy",
                    "Identify and exploit insecure session handling (e.g., token in URL)",
                    "Test for proper session timeout and invalidation after logout",
                    "Understand and exploit session fixation vulnerabilities in a mobile context"
                ],
                "content": {
                    "overview": "The session token is the key to the user's account after they've authenticated. This lesson focuses on the vulnerabilities that arise from how these tokens are created, transmitted, and destroyed. A single flaw in session management can lead to a full account takeover.",
                    "sections": [
                        {
                            "title": "Session Token Analysis",
                            "content": "<p>A session token must be long, random, and unpredictable. A tester should capture multiple session tokens and analyze them for weaknesses.</p><h3>What to Test For:</h3><ul><li><strong>Entropy/Randomness:</strong> Use a tool like Burp Sequencer to analyze the randomness of tokens. A predictable token can be guessed by an attacker.</li><li><strong>Information Content:</strong> Decode the token (if it's Base64 or JWT). Does it contain easily guessable or sequential information like the username or user ID? An attacker might be able to craft tokens for other users.</li><li><strong>Insecure Transmission:</strong> The session token must ONLY be transmitted over an HTTPS connection. If the app ever sends the token over plain HTTP, it can be easily intercepted. It should also never be sent in the URL, as it can be logged in browser history and server logs.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Session Invalidation",
                            "content": "<p>A critical, often overlooked aspect. When a user logs out, their session token must be invalidated on the **server-side**. Simply deleting the token from the mobile app is not enough. An attacker who has already stolen the token could continue to use it. A tester must capture a token, perform a logout in the app, and then try to replay the request with the old token. If it still works, there is a session invalidation vulnerability.</p>",
                            "image": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Why is it insecure to transmit a session token in a URL parameter?", "options": ["URLs are not long enough", "The token will be logged in browser history, proxy logs, and server logs, increasing its exposure", "URLs cannot contain special characters", "It makes the app slower"], "correct": 1, "explanation": "Transmitting any sensitive token in a URL is a major security anti-pattern because of the wide visibility of URLs in logs and browser history." },
                        { "id": 2, "question": "What is the correct way to handle a session upon logout?", "options": ["Delete the token from the client-side only", "Invalidate the session token on the server-side", "Tell the user their session is over but keep the token active", "Do nothing"], "correct": 1, "explanation": "Server-side invalidation is the only way to ensure that a stolen token cannot be replayed after a user has logged out." }
                    ]
                }
            },
            {
                "id": "lesson-27-mfa",
                "title": "Lesson 27: Multi-Factor Authentication Testing",
                "duration": "120 min",
                "objectives": [
                    "Analyze MFA implementation workflows for logical flaws",
                    "Test for bypasses in the 2nd factor implementation (e.g., OTP brute force)",
                    "Assess the security of TOTP implementations and SMS-based 2FA"
                ],
                "content": {
                    "overview": "Multi-Factor Authentication (MFA) is a critical security control, but it can be implemented insecurely. This lesson covers how to test an application's MFA workflow for common vulnerabilities and bypass techniques.",
                    "sections": [
                        {
                            "title": "Logical Flow Bypass",
                            "content": "<p>A common vulnerability is a flaw in the application's logic. An attacker logs in with a valid username and password (the first factor). The application then prompts them for their One-Time Password (OTP). Instead of providing the OTP, the attacker might try to directly browse to the application's main dashboard URL. If the application does not properly check that the 'MFA complete' step has been successfully passed, it might grant the attacker access. The MFA check has been completely bypassed.</p>",
                            "image": "https://images.unsplash.com/photo-1542626991-cbc4e32524cc?w=800&h=400&fit-crop"
                        },
                        {
                            "title": "OTP Brute-Forcing",
                            "content": "<p>An attacker who has a user's password must also defeat the second factor. If the second factor is a 4 or 6-digit OTP, the attacker can try to brute-force it. A secure application must implement rate limiting on the OTP submission endpoint, locking the account after a small number of incorrect attempts (e.g., 5-10 tries).</p>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "An attacker logs in with a valid password, is presented with an MFA prompt, and then simply browses to `https://app.com/dashboard` and gains access. This is a:", "options": ["Successful MFA implementation", "A logical flaw in the authentication workflow", "An SQL Injection", "A weak password"], "correct": 1, "explanation": "This is a classic MFA bypass. The application must enforce that the MFA step has been successfully completed for the session before allowing access to any authenticated parts of the site." }
                    ]
                }
            },
            {
                "id": "lesson-28-social-login-integration",
                "title": "Lesson 28: Social Login Integration Security",
                "duration": "120 min",
                "objectives": [
                    "Perform a security assessment of an OAuth 2.0 implementation ('Log in with Google/Facebook')",
                    "Test for flaws in the OAuth redirect and token exchange flow",
                    "Assess the privacy implications of requested permissions (scopes)"
                ],
                "content": {
                    "overview": "Allowing users to log in with a third-party identity provider (like Google or Apple) is convenient, but the underlying OAuth 2.0 flow is complex and often implemented incorrectly. This lesson covers how to test these social login implementations for common security flaws.",
                    "sections": [
                        {
                            "title": "The OAuth 2.0 Flow and CSRF",
                            "content": "<p>The OAuth 2.0 authorization code flow involves a series of redirects between your application and the identity provider. A key part of this is the `state` parameter. Your application should generate a random, unguessable `state` parameter and send it in the initial request to the identity provider. The provider will then include this same `state` parameter in the redirect back to your application. Your application must validate that the `state` parameter it receives back is the same one it originally sent. This `state` parameter acts as an anti-CSRF token for the login process, preventing an attacker from tricking a victim into logging in with the attacker's own social account.</p>",
                            "image": "https://images.unsplash.com/photo-1556742044-15b56a42a033?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "In the OAuth 2.0 flow, what is the primary purpose of the `state` parameter?", "options": ["To tell the IdP which user is logging in", "To act as an anti-CSRF token, preventing login CSRF attacks", "To store the user's password", "To make the login process slower"], "correct": 1, "explanation": "The `state` parameter is a critical security feature of the OAuth 2.0 spec designed specifically to mitigate Cross-Site Request Forgery attacks against the login flow." }
                    ]
                }
            },
            {
                "id": "lesson-29-native-code-exploitation",
                "title": "Lesson 29: Native Code Exploitation",
                "duration": "180 min",
                "objectives": [
                    "Understand how Android apps use native code via the Java Native Interface (JNI)",
                    "Use tools like IDA Pro or Ghidra to reverse engineer native ARM libraries",
                    "Identify and test for classic memory corruption vulnerabilities (e.g., buffer overflows) in native code"
                ],
                "content": {
                    "overview": "Many high-performance Android apps (especially games) use native C/C++ libraries for performance-critical code. This native code runs directly on the device's CPU and is susceptible to classic memory corruption vulnerabilities. This is an advanced topic that bridges mobile security with traditional binary exploitation.",
                    "sections": [
                        {
                            "title": "Reversing Native Libraries (`.so` files)",
                            "content": "<p>Native libraries are stored as `.so` (shared object) files in the `lib/` directory of the APK. To analyze them, you must use a disassembler and decompiler for native code, like the industry-standard IDA Pro or the free, open-source Ghidra from the NSA. These tools allow you to view the ARM assembly code and a decompiled C-like representation. The goal is to find classic vulnerabilities like:</p><ul><li><strong>Buffer Overflows:</strong> Especially in functions that handle user input, like `strcpy` or `gets`.</li><li><strong>Hard-coded Secrets:</strong> Developers sometimes hard-code keys or other secrets in native code, mistakenly believing it is harder to reverse engineer than Java.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "A tool like Ghidra or IDA Pro is used to do what?", "options": ["Decompile DEX bytecode to Java", "Analyze network traffic", "Reverse engineer compiled native code (like `.so` files) into assembly and C-like pseudocode", "Install an application"], "correct": 2, "explanation": "These are specialized tools for binary reverse engineering, essential for assessing the security of native libraries." }
                    ]
                }
            },
            {
                "id": "lesson-30-root-detection-bypass",
                "title": "Lesson 30: Root Detection Bypass",
                "duration": "120 min",
                "objectives": [
                    "Understand common techniques applications use to detect root",
                    "Use root-hiding tools like Magisk Hide",
                    "Use Frida to dynamically hook and bypass root detection methods in code"
                ],
                "content": {
                    "overview": "As a security tester, you need a rooted environment. But many apps will refuse to run on one. This lesson covers the cat-and-mouse game of root detection and bypass, a fundamental prerequisite for dynamic analysis of many high-security apps.",
                    "sections": [
                        {
                            "title": "Bypass Methods",
                            "content": "<p>An application might check for the existence of the `su` binary, or look for common rooting app package names. You have two main ways to bypass this:</p><ol><li><strong>Hiding Root (e.g., Magisk Hide):</strong> Tools like Magisk can try to 'hide' the signs of root from specific applications, often being successful against simple checks.</li><li><strong>Hooking the Check (Frida):</strong> The most reliable method. You first reverse engineer the application to find the exact method that performs the root check. Then, you write a Frida script to hook that method and force it to always return `false`. This tricks the application into thinking the device is not rooted, even when it is.</li></ol>",
                            "image": "https://images.unsplash.com/photo-1614064548237-02f8f17374b2?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "If a root-hiding tool like Magisk is not sufficient to bypass an app's root detection, what is the next step a researcher would take?", "options": ["Give up", "Use Frida to dynamically hook the specific root detection methods within the application's code and manipulate their return values", "Try a different phone", "Report a bug to the app developer"], "correct": 1, "explanation": "Dynamic instrumentation with Frida provides the ultimate level of control, allowing a researcher to surgically bypass the exact checks the application is performing, no matter how obscure." }
                    ]
                }
            },
            {
                "id": "lesson-31-anti-analysis-evasion",
                "title": "Lesson 31: Anti-Analysis Evasion",
                "duration": "120 min",
                "objectives": [
                    "Bypass debugger detection mechanisms",
                    "Evade emulator detection to run the app in a controlled environment",
                    "Understand and reverse code obfuscation and packing techniques"
                ],
                "content": {
                    "overview": "Beyond root detection, some apps employ a range of anti-analysis techniques to make a security researcher's job harder. This lesson covers how to recognize and bypass these defenses.",
                    "sections": [
                        {
                            "title": "Emulator Detection",
                            "content": "<p>An app might try to detect if it's running in an emulator (which has no real telephony hardware or certain sensors) and behave differently or crash. Again, a tester would reverse engineer the app to find the specific checks it's performing and use a tool like Frida to hook those methods and return values that make the app think it's running on a real, physical device.</p>",
                            "image": "https://images.unsplash.com/photo-1607252650355-f7fd0460ccdb?w=800&h=400&fit-crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Anti-analysis techniques are primarily designed to do what?", "options": ["Make an application more secure", "Frustrate and slow down a security researcher who is trying to reverse engineer and dynamically analyze the application", "Make the application smaller", "Help the user"], "correct": 1, "explanation": "These are essentially anti-reversing controls designed to protect the application's intellectual property and make it harder to find vulnerabilities." }
                    ]
                }
            },
            {
                "id": "lesson-32-advanced-hooking",
                "title": "Lesson 32: Advanced Hooking Techniques with Frida",
                "duration": "120 min",
                "objectives": [
                    "Use Frida to hook native functions in `.so` libraries",
                    "Intercept low-level system calls",
                    "Perform dynamic patching of an application's code in memory"
                ],
                "content": {
                    "overview": "This advanced lesson unlocks the full power of Frida. You will learn to go beyond hooking simple Java methods to intercepting low-level native functions and even changing an application's logic on the fly, directly in memory.",
                    "sections": [
                        {
                            "title": "Native Function Hooking",
                            "content": "<p>Frida can not only hook Java methods, but also any exported function in a native `.so` library. You can use Frida's `Interceptor` API to attach to a native function (e.g., `strcmp` in `libc.so`) and inspect or modify the arguments being passed to it. This is essential for analyzing native code and for bypassing certain anti-debugging checks that are implemented in C/C++.</p>",
                            "image": "https://images.unsplash.com/photo-1542831371-d531d209121f?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "codeExamples": [
                    {
                        "title": "Frida Script to Hook a Native Function (`libc.so`)",
                        "language": "javascript",
                        "code": "// This script intercepts calls to the 'open' system call from libc.so\n// and prints the file path that the application is trying to open.\n\nInterceptor.attach(Module.findExportByName(\"libc.so\", \"open\"), {\n    onEnter: function(args) {\n        var path = args[0].readUtf8String();\n        console.log(\"[+] File opened: \" + path);\n    }\n});"
                    }
                ],
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Frida's `Interceptor.attach()` function is used for what?", "options": ["Hooking Java methods", "Hooking low-level native functions by their memory address or exported name", "Decompiling an application", "Analyzing network traffic"], "correct": 1, "explanation": "The Interceptor API is what gives Frida its power to operate at the native code level, which is a significant step beyond standard Java-level hooking." }
                    ]
                }
            },
            {
                "id": "lesson-33-android-malware",
                "title": "Lesson 33: Android Malware Analysis",
                "duration": "120 min",
                "objectives": [
                    "Apply static and dynamic analysis techniques to a real Android malware sample",
                    "Identify the malware's command-and-control (C2) infrastructure",
                    "Determine its persistence mechanism",
                    "Extract Indicators of Compromise (IOCs)"
                ],
                "content": {
                    "overview": "This lesson applies all the skills you've learned so far to a new target: Android malware. You will perform a complete static and dynamic analysis of a real malware sample to understand what it does and how it works.",
                    "sections": [
                        {
                            "title": "The Malware Analysis Process",
                            "content": "<p>The process is nearly identical to a standard application security test, but the goals are different. The focus is on:</p><ul><li><strong>Understanding its capabilities:</strong> Is it a banking trojan? Spyware? Ransomware?</li><li><strong>Finding its C2 infrastructure:</strong> What IP addresses and domains does it connect to?</li><li><strong>Identifying its persistence mechanism:</strong> How does it ensure it survives a reboot?</li><li><strong>Extracting IOCs:</strong> Collect all the file hashes, domains, IPs, and other artifacts that can be used to detect this malware on other devices.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1547756536-cde55c3f2c65?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is an Indicator of Compromise (IOC) in the context of malware analysis?", "options": ["A feature of the malware", "A technical artifact (like a file hash or a C2 domain) that can be used to detect the malware", "The person who wrote the malware", "The cost of the malware"], "correct": 1, "explanation": "IOCs are the actionable intelligence derived from the analysis that can be fed into security tools for broad-scale detection and blocking." }
                    ]
                }
            },
            {
                "id": "lesson-34-banking-trojans",
                "title": "Lesson 34: Banking Trojan Analysis",
                "duration": "120 min",
                "objectives": [
                    "Understand the mechanics of overlay attacks for credential theft",
                    "Analyze how Trojans intercept SMS messages to defeat 2FA",
                    "Recognize the abuse of Android's Accessibility Services"
                ],
                "content": {
                    "overview": "Android banking Trojans are a major and highly sophisticated category of malware. This lesson provides a deep dive into the specific techniques these Trojans use to steal users' banking credentials and defeat two-factor authentication.",
                    "sections": [
                        {
                            "title": "Overlay Attacks",
                            "content": "<p>This is the primary technique. The malware monitors the running processes on the device. When it sees the user open their legitimate banking app, the malware instantly draws a fake 'WebView' login window *over* the real app. The user, thinking they are on the real login screen, enters their username and password into the fake window, and the credentials are sent to the attacker. To the user, this is almost undetectable.</p>",
                            "image": "https://images.unsplash.com/photo-1556741533-4020f1b29a28?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Abuse of Accessibility Services",
                            "content": "<p>The Accessibility Service in Android is a powerful API designed to assist users with disabilities by allowing an app to read the screen content and simulate user clicks. Banking Trojans trick the user into granting them Accessibility Service permissions. The malware can then use this permission to read OTP codes from authenticator apps directly off the screen, automatically click 'allow' on permission pop-ups, and perform a wide range of highly privileged actions.</p>",
                            "image": "https://images.unsplash.com/photo-1614064548237-02f8f17374b2?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is an overlay attack?", "options": ["An attack that deletes data", "An attack where a banking trojan draws a fake login window over the top of the legitimate banking app to steal credentials", "An attack on the network", "A denial-of-service attack"], "correct": 1, "explanation": "Overlay attacks are the signature technique of modern Android banking Trojans." },
                        { "id": 2, "question": "Why is tricking a user into granting 'Accessibility Service' permissions so dangerous?", "options": ["It is not dangerous", "It gives the malware the ability to read the content of the screen and programmatically click buttons, allowing it to defeat many security controls", "It lets the malware change the phone's wallpaper", "It allows the malware to send one SMS message"], "correct": 1, "explanation": "The Accessibility Service is one of the most powerful and privileged APIs on Android, and its abuse is a hallmark of sophisticated malware." }
                    ]
                }
            },
            {
                "id": "lesson-35-spyware-stalkerware",
                "title": "Lesson 35: Spyware and Stalkerware",
                "duration": "120 min",
                "objectives": [
                    "Analyze the techniques used by spyware to exfiltrate user data (contacts, location, messages)",
                    "Understand how spyware monitors communications and tracks location",
                    "Recognize the unique privacy and ethical implications of stalkerware"
                ],
                "content": {
                    "overview": "This lesson covers the insidious categories of spyware and stalkerwareapplications whose sole purpose is to covertly monitor a user and exfiltrate their private data to a remote attacker.",
                    "sections": [
                        {
                            "title": "Covert Data Collection",
                            "content": "<p>These applications often request a huge number of dangerous permissions during installation (e.g., read contacts, read SMS, access fine location). They will then use background services to periodically collect this data and upload it to a remote command-and-control server. Analysis involves identifying the C2 server and decrypting the exfiltrated data to understand the full scope of the privacy invasion.</p>",
                            "image": "https://images.unsplash.com/photo-1599373922312--5b9340d8a5a5?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Spyware is primarily designed to do what?", "options": ["Encrypt a user's files", "Show advertisements", "Covertly collect and exfiltrate a user's private data", "Mine cryptocurrency"], "correct": 2, "explanation": "Spyware's goal is espionage and the theft of personal information." }
                    ]
                }
            },
            {
                "id": "lesson-36-ransomware-lockers",
                "title": "Lesson 36: Ransomware and Locker Analysis",
                "duration": "120 min",
                "objectives": [
                    "Differentiate between crypto-ransomware and screen lockers",
                    "Analyze the file encryption techniques used by Android ransomware",
                    "Identify screen locking mechanisms and potential bypasses"
                ],
                "content": {
                    "overview": "Ransomware is not just a problem for PCs. This lesson covers the two main types of ransomware seen on Android: crypto-ransomware that encrypts files, and screen lockers that simply prevent the user from accessing their device.",
                    "sections": [
                        {
                            "title": "Screen Lockers",
                            "content": "<p>A screen locker is a simpler form of ransomware. It doesn't encrypt any files. Instead, it uses a trick to constantly draw its own window on top of everything else, including the home screen and system menus. It then displays a ransom note. Because the user cannot access any other part of the UI, their device is effectively locked. Bypassing these often involves booting into safe mode to uninstall the malicious application or using ADB if debugging was enabled.</p>",
                            "image": "https://images.unsplash.com/photo-1614064548237-02f8f17374b2?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the key difference between crypto-ransomware and a screen locker?", "options": ["There is no difference", "A screen locker only blocks access to the UI, while crypto-ransomware actually encrypts the user's files on storage", "Screen lockers are more dangerous", "Crypto-ransomware is easier to remove"], "correct": 1, "explanation": "While both are extortion tools, crypto-ransomware is far more destructive as it can lead to permanent data loss." }
                    ]
                }
            },
            {
                "id": "lesson-37-mdm",
                "title": "Lesson 37: Mobile Device Management (MDM) Security",
                "duration": "120 min",
                "objectives": [
                    "Understand the architecture of an Enterprise Mobility Management (EMM/MDM) solution",
                    "Assess the security policies enforced by an MDM",
                    "Test for bypasses or weaknesses in the MDM implementation"
                ],
                "content": {
                    "overview": "In a corporate environment, Mobile Device Management (MDM) or Enterprise Mobility Management (EMM) solutions are the primary tool for securing devices. This lesson covers the security assessment of these enterprise mobile environments.",
                    "sections": [
                        {
                            "title": "MDM Security Assessment",
                            "content": "<p>A security assessment would involve checking the MDM's configuration for security best practices. Does it enforce a strong device passcode? Does it enforce full-disk encryption? Does it have the ability to remotely wipe the device if it is lost or stolen? It also involves testing to see if a clever user or a piece of malware can find a way to un-enroll from the MDM or bypass its policy controls.</p>",
                            "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is a primary security function of an MDM solution?", "options": ["To make the phone run faster", "To enforce corporate security policies on mobile devices, such as requiring a passcode and encryption", "To give users root access", "To provide a mobile app store"], "correct": 1, "explanation": "MDM is a policy enforcement engine for mobile devices." }
                    ]
                }
            },
            {
                "id": "lesson-38-byod-security",
                "title": "Lesson 38: BYOD Security Testing",
                "duration": "120 min",
                "objectives": [
                    "Understand the privacy and legal challenges of Bring Your Own Device (BYOD)",
                    "Assess the security of containerization and app wrapping solutions",
                    "Test for data leakage between personal and corporate applications"
                ],
                "content": {
                    "overview": "BYOD policies introduce a major security challenge: how do you secure corporate data on a device you don't own? This lesson covers the security testing of the technologies used to solve this problem, primarily containerization.",
                    "sections": [
                        {
                            "title": "Containerization Security",
                            "content": "<p>The standard solution for BYOD is containerization. The MDM creates a secure, encrypted 'work profile' or container on the employee's personal device. All corporate apps and data live inside this container. A security assessment involves testing the strength of this container. Is it possible for a malicious personal app to access data inside the corporate container? Are there weaknesses in the copy/paste controls between the personal and work profiles that could lead to data leakage?</p>",
                            "image": "https://images.unsplash.com/photo-1544228943-8588824f19b2?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary security goal of a containerization solution in a BYOD environment?", "options": ["To make the personal device slower", "To securely isolate corporate data and apps from the user's personal data and apps", "To allow all apps to share data freely", "To delete the user's personal photos"], "correct": 1, "explanation": "The container creates a strong logical boundary on the device, allowing the company to secure its data without intruding on the employee's privacy." }
                    ]
                }
            },
            {
                "id": "lesson-39-android-for-work",
                "title": "Lesson 39: Android Enterprise Security",
                "duration": "120 min",
                "objectives": [
                    "Understand the features of the Android Enterprise platform",
                    "Test the security of a device in 'Work Profile' mode and 'Fully Managed' mode",
                    "Assess the enforcement of Data Loss Prevention (DLP) policies"
                ],
                "content": {
                    "overview": "Android Enterprise is a Google-led program that provides a set of APIs and tools for developers and EMM vendors to build enterprise-grade Android solutions. This lesson covers how to assess the security of devices managed under this framework.",
                    "sections": [
                        {
                            "title": "Work Profile vs. Fully Managed",
                            "content": "<ul><li><strong>Work Profile:</strong> This is the solution for BYOD. It creates the secure container on the user's personal device.</li><li><strong>Fully Managed Device:</strong> This is for company-owned devices. The entire device is managed by the organization. They have full control, can restrict what apps are installed, and can perform a full factory reset.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1521791136064-7986c2920216?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Which Android Enterprise deployment model is designed for company-owned, single-use devices (like a kiosk)?", "options": ["Work Profile", "Fully Managed Device with a Dedicated (COSU) profile", "Bring Your Own Device (BYOD)", "None"], "correct": 1, "explanation": "COSU (Corporate-Owned, Single-Use) is a specific profile within the 'Fully Managed' model that allows an administrator to lock a device down to a single application or a small set of applications." }
                    ]
                }
            },
            {
                "id": "lesson-40-mam",
                "title": "Lesson 40: Mobile Application Management (MAM)",
                "duration": "120 min",
                "objectives": [
                    "Differentiate between MDM and MAM",
                    "Assess the security of app-level security controls without full device enrollment",
                    "Test Data Loss Prevention policies in MAM-enabled applications"
                ],
                "content": {
                    "overview": "Mobile Application Management (MAM) offers a lighter-touch approach than full MDM. This lesson covers how MAM works and how to test its security.",
                    "sections": [
                        {
                            "title": "MDM vs. MAM",
                            "content": "<ul><li><strong>MDM (Mobile Device Management):</strong> The company 'manages' the entire device by enrolling it.</li><li><strong>MAM (Mobile Application Management):</strong> The company manages only its own specific applications, without enrolling or managing the user's entire device. This is often used for BYOD scenarios where users are hesitant to give their company full control over their personal phone. An example is the Microsoft Intune MAM policies that can apply to the Outlook mobile app, allowing a company to enforce policies (like preventing copy/paste) on just that one app.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1544228943-8588824f19b2?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the key difference between MDM and MAM?", "options": ["There is no difference", "MDM manages the whole device, while MAM manages only specific corporate applications without taking full control of the device", "MDM is for iOS, MAM is for Android", "MAM is more expensive"], "correct": 1, "explanation": "MAM provides a less intrusive alternative for BYOD, focusing on securing the corporate apps and data, not the device itself." }
                    ]
                }
            },
            {
                "id": "lesson-41-android-things-iot",
                "title": "Lesson 41: Android Things Security",
                "duration": "120 min",
                "objectives": [
                    "Understand the Android Things platform for building IoT devices",
                    "Assess the security of peripheral I/O interfaces (GPIO, I2C)",
                    "Test the security of the over-the-air (OTA) update mechanism"
                ],
                "content": {
                    "overview": "Android Things was a modified version of Android designed for IoT devices. While its adoption is limited, the principles of securing an Android-based embedded system are important. This lesson explores the unique attack surface of these devices.",
                    "sections": [
                        {
                            "title": "IoT Attack Surface",
                            "content": "<p>Beyond the standard Android application attack surface, IoT devices have new ones:</p><ul><li><strong>Hardware Interfaces:</strong> The peripheral interfaces (like GPIO pins or UART serial ports) on the device's board can become an attack vector if they are not properly secured.</li><li><strong>Over-the-Air (OTA) Updates:</strong> The mechanism used to deliver software updates to the device must be secure. An attacker who can hijack the OTA process could push malicious firmware to the entire fleet of devices.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1544890225-2fde1e46f71b?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is a major new security concern for an Android-based IoT device compared to a standard mobile phone?", "options": ["The screen is too small", "The security of the physical hardware interfaces and the over-the-air (OTA) update mechanism", "It doesn't have a phone number", "It is not connected to the internet"], "correct": 1, "explanation": "These new interfaces expand the attack surface beyond what a typical mobile application pentester would look at." }
                    ]
                }
            },
            {
                "id": "lesson-42-automotive-android",
                "title": "Lesson 42: Automotive Android Security",
                "duration": "120 min",
                "objectives": [
                    "Understand the architecture of Android Automotive and its security model",
                    "Assess the security of the CAN bus integration",
                    "Test for vulnerabilities in infotainment and telematics systems"
                ],
                "content": {
                    "overview": "Android is now a major player in the automotive world, with Android Automotive being a full operating system that runs a car's infotainment and other systems. This lesson explores the unique and safety-critical security considerations of a car.",
                    "sections": [
                        {
                            "title": "The CAN Bus",
                            "content": "<p>The Controller Area Network (CAN) bus is the internal network that all the car's electronic control units (ECUs) use to communicate (for things like brakes, steering, and engine control). The infotainment system often has a gateway to the CAN bus. A security assessment must rigorously test this gateway to ensure that a compromise of the Android infotainment system cannot be used to send malicious messages onto the safety-critical CAN bus.</p>",
                            "image": "https://images.unsplash.com/photo-1549399542-7e692a716530?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary security concern in an Android Automotive system?", "options": ["The music player crashing", "Ensuring that a compromise of the infotainment system cannot be used to affect the car's safety-critical systems via the CAN bus", "The navigation system being slow", "The color of the icons"], "correct": 1, "explanation": "This is a safety-critical boundary. Preventing an attacker from pivoting from the infotainment system (which runs Android apps) to the vehicle control system is the highest priority." }
                    ]
                }
            },
            {
                "id": "lesson-43-wearable-security",
                "title": "Lesson 43: Wearable Device Security",
                "duration": "120 min",
                "objectives": [
                    "Assess the security of Wear OS applications",
                    "Test the security of Bluetooth and other wireless communication channels",
                    "Analyze the privacy and security of health and sensor data"
                ],
                "content": {
                    "overview": "Wearable devices like smartwatches introduce new security challenges, primarily related to their wireless communication and the highly sensitive health data they collect. This lesson covers how to assess the security of these devices.",
                    "sections": [
                        {
                            "title": "Bluetooth Security",
                            "content": "<p>A smartwatch is almost always connected to a phone via a Bluetooth Low Energy (BLE) link. A security assessment must test this link. Is the communication encrypted? Are there weaknesses in the pairing process? Can an attacker perform a man-in-the-middle attack on the BLE communication to sniff or inject data between the watch and the phone?</p>",
                            "image": "https://images.unsplash.com/photo-1544228943-8588824f19b2?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary network attack surface for a wearable device like a smartwatch?", "options": ["The USB charging cable", "The Ethernet port", "The Bluetooth communication link to the paired phone", "The screen"], "correct": 2, "explanation": "This wireless channel is the main data path for the device and a primary focus for a security assessment." }
                    ]
                }
            },
            {
                "id": "lesson-44-smart-tv-security",
                "title": "Lesson 44: Smart TV and Media Device Security",
                "duration": "120 min",
                "objectives": [
                    "Assess the security of Android TV applications",
                    "Test the security of media streaming protocols",
                    "Identify vulnerabilities in the protocols used for casting and remote control"
                ],
                "content": {
                    "overview": "Smart TVs and media streaming sticks running Android TV are now common in millions of homes. This lesson covers the security assessment of these devices.",
                    "sections": [
                        {
                            "title": "Network and Protocol Security",
                            "content": "<p>These devices often use a variety of network protocols for discovering and communicating with other devices, such as UPnP (Universal Plug and Play) and DIAL. A security assessment involves fuzzing these protocols to look for vulnerabilities and testing how they handle malformed input. Additionally, the remote control applications that pair with the TV are a key area to test for authentication and authorization flaws.</p>",
                            "image": "https://images.unsplash.com/photo-1593784959329-3a36c8da6375?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "Assessing the security of a smart TV would heavily focus on what?", "options": ["The quality of the picture", "The security of its network services and discovery protocols (like UPnP)", "The material of the remote control", "The brand of the TV"], "correct": 1, "explanation": "Smart TVs are network-connected devices, and their custom network protocols are a major part of their unique attack surface." }
                    ]
                }
            },
            {
                "id": "lesson-45-android-kernel-security",
                "title": "Lesson 45: Android Kernel Security",
                "duration": "180 min",
                "objectives": [
                    "Understand the role of the Linux kernel in Android security",
                    "Learn the basics of kernel vulnerability research",
                    "Explore how kernel exploits can be used to achieve a full device root"
                ],
                "content": {
                    "overview": "This is an expert-level lesson on the ultimate security boundary in Android: the Linux kernel itself. We will explore how security researchers find vulnerabilities in the kernel that can be used to bypass all of the application-level and OS-level security controls.",
                    "sections": [
                        {
                            "title": "Kernel Exploitation",
                            "content": "<p>Finding a vulnerability in the kernel (e.g., a buffer overflow in a device driver) can allow a malicious application to execute code in the context of the kernel (Ring 0). This is the highest level of privilege on the system. An attacker who achieves this can bypass the application sandbox, disable SELinux, and gain complete control over the entire device. This is often the goal of rooting exploits.</p>",
                            "image": "https://images.unsplash.com/photo-1629654297299-c8506221ca97?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "A vulnerability in the Android kernel can be used to bypass which security control?", "options": ["A single application's permissions", "The network firewall", "The application sandbox and SELinux", "The user's password"], "correct": 2, "explanation": "The kernel is the ultimate security boundary. A compromise of the kernel means a full compromise of the entire system's security model." }
                    ]
                }
            },
            {
                "id": "lesson-46-hardware-security-testing",
                "title": "Lesson 46: Hardware Security Testing",
                "duration": "180 min",
                "objectives": [
                    "Understand the role of the Trusted Execution Environment (TEE) and TrustZone",
                    "Explore hardware attack techniques like fault injection and side-channel analysis",
                    "Assess the security of secure boot implementations"
                ],
                "content": {
                    "overview": "This expert-level lesson moves beyond software to the hardware itself. We will explore the hardware-backed security features of modern mobile chipsets and the advanced techniques used to attack them.",
                    "sections": [
                        {
                            "title": "The Trusted Execution Environment (TEE)",
                            "content": "<p>Modern mobile CPUs have a special, hardware-isolated mode called the Trusted Execution Environment (e.g., ARM TrustZone). The main Android OS runs in the 'normal world'. A small, highly secure OS runs in the 'secure world' (the TEE). The Android Keystore uses the TEE to protect cryptographic key material. Even if the main Android kernel is compromised, the attacker should not be able to access the keys stored inside the TEE.</p>",
                            "image": "https://images.unsplash.com/photo-1593110022831-292911b3b194?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "What is the primary function of the Trusted Execution Environment (TEE)?", "options": ["To run the user interface", "To provide a hardware-isolated environment for processing the most sensitive data and protecting cryptographic keys", "To connect to the internet", "To store user photos"], "correct": 1, "explanation": "The TEE provides hardware-level isolation, which is a much stronger security boundary than software-level sandboxing." }
                    ]
                }
            },
            {
                "id": "lesson-47-ml-security",
                "title": "Lesson 47: Machine Learning Security on Android",
                "duration": "120 min",
                "objectives": [
                    "Assess the security of on-device ML models and their implementation",
                    "Understand the risks of model extraction and adversarial attacks",
                    "Secure TensorFlow Lite and other on-device ML frameworks"
                ],
                "content": {
                    "overview": "Machine learning is now happening directly on mobile devices. This lesson explores the new attack surface created by these on-device ML models.",
                    "sections": [
                        {
                            "title": "Model Extraction and Adversarial Attacks",
                            "content": "<ul><li><strong>Model Extraction:</strong> Your trained ML model is a valuable piece of intellectual property. An attacker who can extract the model file from your application can steal it.</li><li><strong>Adversarial Attacks:</strong> An attacker can craft a special, subtly modified input that is designed to fool your ML model. For example, they might be able to create an image that looks like a cat to a human but that your on-device image recognition model classifies as a dog.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1620712943543-959bab121695?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "An attack where a malicious, specially-crafted input is used to fool an ML model is called a(n):", "options": ["SQL Injection", "Adversarial Attack", "Cross-Site Scripting", "A hardware attack"], "correct": 1, "explanation": "Adversarial ML is an emerging and complex field of security research focused on the security and robustness of machine learning models themselves." }
                    ]
                }
            },
            {
                "id": "lesson-48-blockchain-crypto",
                "title": "Lesson 48: Blockchain and Cryptocurrency Security",
                "duration": "120 min",
                "objectives": [
                    "Assess the security of mobile cryptocurrency wallets",
                    "Test for flaws in how an app handles private key storage and management",
                    "Understand the risks of interacting with smart contracts from a mobile app"
                ],
                "content": {
                    "overview": "Mobile phones are now a primary platform for managing cryptocurrency. This lesson covers the security assessment of mobile crypto wallets and DeFi applications, where the stakes are incredibly high.",
                    "sections": [
                        {
                            "title": "Private Key Protection",
                            "content": "<p>The single most important security concern is how the application stores the user's private key. The private key *is* the money. It must be protected by the hardware-backed Android Keystore and require a strong user authentication (like biometrics) to be used for signing a transaction. A vulnerability that leaks the private key results in a direct and irreversible loss of all the user's funds.</p>",
                            "image": "https://images.unsplash.com/photo-1631603090989-821237a349b8?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "In a cryptocurrency wallet app, what is the single most critical asset to protect?", "options": ["The application's icon", "The user's public address", "The user's private key", "The list of transactions"], "correct": 2, "explanation": "The private key is the only thing that can authorize a transaction. If it is compromised, all funds in the wallet are permanently lost." }
                    ]
                }
            },
            {
                "id": "lesson-49-assessment-methodology",
                "title": "Lesson 49: Mobile Security Assessment Methodology",
                "duration": "120 min",
                "objectives": [
                    "Develop a professional, repeatable framework for testing any mobile application",
                    "Combine static and dynamic analysis into a cohesive workflow",
                    "Use risk rating systems to score and prioritize findings"
                ],
                "content": {
                    "overview": "This lesson brings everything together into a professional methodology, based on the OWASP Mobile Application Security Verification Standard (MASVS). You will learn how to approach any application as a professional pentester, combining automated and manual techniques into a repeatable process that ensures thorough coverage and high-quality results.",
                    "sections": [
                        {
                            "title": "The OWASP MASVS",
                            "content": "<p>The MASVS provides a structured framework for mobile security. It defines several verification levels, from L1 (standard security) to L2 (defense-in-depth), and a set of detailed security requirements for each. Basing your assessment on the MASVS provides a clear, industry-standard methodology for your work.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        { "id": 1, "question": "The industry-standard framework from OWASP that provides a set of detailed security requirements for mobile applications is the:", "options": ["OWASP Top 10", "OWASP MASVS", "OWASP ZAP", "OWASP WebGoat"], "correct": 1, "explanation": "The Mobile Application Security Verification Standard (MASVS) is the key methodological document for any professional mobile security assessment." }
                    ]
                }
            },
            {
                "id": "lesson-50-final-capstone-project",
                "title": "Lesson 50: Final Capstone Project",
                "duration": "240 min",
                "objectives": [
                    "Conduct a comprehensive, end-to-end security assessment of a complex mobile application",
                    "Perform static analysis, dynamic analysis, and reverse engineering",
                    "Chain multiple vulnerabilities together to demonstrate maximum impact",
                    "Produce a professional-quality, enterprise-ready penetration test report"
                ],
                "content": {
                    "overview": "The final capstone is a comprehensive, master's level assessment that requires you to synthesize every skill learned in this program. You will be given a complex, multi-functional vulnerable Android application. Your mission is to perform a full security assessment from start to finish, identify and chain multiple vulnerabilities to achieve a critical business impact, and produce a professional report suitable for a major enterprise client.",
                    "sections": [
                        {
                            "title": "The Master's Level Assessment",
                            "content": "<p><strong>The Task:</strong> You are the lead mobile penetration tester hired to assess a new mobile banking application. The application uses a native code library for its cryptographic functions, interacts with a REST API backend, and has features for biometric login and funds transfer.</p><h3>Your Mission:</h3><ol><li><strong>Static Analysis & Reversing:</strong> Decompile the app, reverse engineer the native library to find a hard-coded key, and analyze the manifest for insecure components.</li><li><strong>Dynamic Analysis:</strong> Bypass the app's root detection and certificate pinning. Intercept the network traffic to find an API vulnerability. Use Frida to bypass the biometric login.</li><li><strong>Chain the Attack:</strong> Combine these vulnerabilities to demonstrate a full account takeover and an unauthorized fund transfer.</li><li><strong>Reporting:</strong> Produce a single, comprehensive penetration test report that details all your findings, provides a narrative for your attack chain, and offers a prioritized, strategic remediation plan.</li></ol>",
                            "image": "https://images.unsplash.com/photo-1498050108023-c5249f4df085?w=800&h=400&fit=crop"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 100,
                    "questions": [
                        { "id": 1, "question": "The capstone project assesses your ability to:", "options": ["Run a single automated scan", "Answer multiple choice questions", "Synthesize knowledge from the entire course to conduct a comprehensive, multi-faceted, professional-grade security assessment of a realistic mobile application", "Write a simple 'hello world' application"], "correct": 2, "explanation": "This project is the ultimate test of your practical skills, requiring you to apply your full knowledge base to solve a complex, multi-stage security engagement." }
                    ]
                }
            }
        ]
    }


      // =====================================================
      // GLOBAL VARIABLES
      // =====================================================
      let currentUser = null;
      let currentLessonIndex = 0;
      let courseProgress = {};
      let userStats = {};
      let quizState = {
        currentQuestion: 0,
        answers: [],
        score: 0,
        isComplete: false,
      };

      // Enhanced session tracking
      let courseSession = {
        startTime: null,
        totalStudyTime: 0,
        lessonsStarted: 0,
        lessonsCompleted: 0,
        pageLoadTime: new Date(),
        interactionCount: 0,
        lastActivityTime: new Date(),
      };

      // Music Player Variables
      let audioPlayer = new Audio();

      // Achievement notification system
      let notificationQueue = [];
      let isShowingNotification = false;

      // =====================================================
      // INITIALIZATION
      // =====================================================
      document.addEventListener("DOMContentLoaded", async () => {
        try {
          showLoadingScreen();
          await checkAuth();

          if (currentUser) {
            // Initialize session tracking
            startCourseSession();

            // Load course data and progress
            await loadCourseData();
            await loadUserProfile();
            await loadProgress();

            // Initialize UI
            initializeEventListeners();
            renderSidebar();
            loadLesson(currentLessonIndex);

            // Initialize additional features
            initMusicPlayer();
            addMusicIndicator();
            initializeActivityTracking();

            hideLoadingScreen();
          } else {
            openAuthModal();
          }
        } catch (error) {
          console.error("Error initializing course:", error);
          hideLoadingScreen();
          showToast("Failed to initialize course system", "error");
        }
      });

      // =====================================================
      // AUTHENTICATION SYSTEM
      // =====================================================
      async function checkAuth() {
        try {
          const {
            data: { session },
            error,
          } = await supabase.auth.getSession();

          if (error) {
            console.error("Auth error:", error);
            currentUser = null;
            openAuthModal();
            return;
          }

          if (!session) {
            currentUser = null;
            openAuthModal();
            return;
          }

          currentUser = session.user;
          updateUIWithUser();
        } catch (error) {
          console.error("Error checking auth:", error);
          currentUser = null;
          openAuthModal();
        }
      }

      function updateUIWithUser() {
        if (!currentUser) return;

        const name =
          currentUser.user_metadata?.full_name ||
          currentUser.email.split("@")[0];
        const userElements = document.querySelectorAll("[data-user-name]");
        userElements.forEach((el) => (el.textContent = name));
      }

      // =====================================================
      // USER PROFILE & STATS MANAGEMENT
      // =====================================================
      async function loadUserProfile() {
        try {
          //  Step 1: Try to fetch existing profile
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("*")
            .eq("id", currentUser.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (!profile) {
            //  Step 2: Create new profile if missing
            await createUserProfile();
          } else {
            //  Step 3: Use existing profile
            userStats = profile;
            await updateLastActivity();
          }
        } catch (error) {
          console.error(" Error loading user profile:", error);
          showToast("Failed to load user profile", "error");
        }
      }
      async function createUserProfile() {
        try {
          const newProfile = {
            id: currentUser.id,
            full_name: currentUser.user_metadata?.full_name || "",
            email: currentUser.email,
            level: "Script Kiddie",
            total_points: 0,
            completed_courses: 0,
            current_streak: 0,
            total_certificates: 0,
            total_achievements: 0,
            sections_visited: 0,
            bonus_points: 0,
            in_progress_courses: 0,
            settings_changed: 0,
            midnight_sessions: 0,
            early_sessions: 0,
            weekend_sessions: 0,
            last_activity: new Date().toISOString(),
            created_at: new Date().toISOString(),
          };

          const { error } = await supabase
            .from("profiles")
            .insert([newProfile]);

          if (!error) {
            userStats = newProfile;
            // Award first login achievement
            setTimeout(() => checkAndUnlockAchievement("first_login"), 1000);
          }
        } catch (error) {
          console.error("Error creating user profile:", error);
        }
      }

      async function updateLastActivity() {
        try {
          const now = new Date();

          // Update activity tracking
          courseSession.lastActivityTime = now;

          // Update database
          await supabase
            .from("profiles")
            .update({
              last_activity: now.toISOString(),
            })
            .eq("id", currentUser.id);

          // Check time-based achievements
          await checkTimeBasedAchievements(now);
        } catch (error) {
          console.error("Error updating last activity:", error);
        }
      }

      // =====================================================
      // COURSE SESSION MANAGEMENT
      // =====================================================
      function startCourseSession() {
        courseSession.startTime = new Date();
        courseSession.pageLoadTime = new Date();

        logUserActivity("course_session_start", {
          course_id: COURSE_DATA.id,
          course_title: COURSE_DATA.title,
          user_agent: navigator.userAgent,
          screen_resolution: `${screen.width}x${screen.height}`,
        });

        // Check daily streak
        checkDailyStreak();
      }

      function initializeActivityTracking() {
        // Track page focus/blur for accurate study time
        document.addEventListener("visibilitychange", handleVisibilityChange);

        // Track user interactions
        ["click", "keydown", "scroll", "mousemove"].forEach((event) => {
          document.addEventListener(event, trackUserInteraction, {
            passive: true,
          });
        });

        // Periodic activity updates
        setInterval(updateStudyTime, 60000); // Every minute

        // Save session data before page unload
        window.addEventListener("beforeunload", saveSessionData);
      }

      function handleVisibilityChange() {
        if (document.hidden) {
          courseSession.lastActivityTime = new Date();
        } else {
          // Page became visible again - update activity
          updateLastActivity();
        }
      }

      function trackUserInteraction() {
        courseSession.interactionCount++;
        courseSession.lastActivityTime = new Date();

        // Throttle activity updates
        if (courseSession.interactionCount % 50 === 0) {
          updateLastActivity();
        }
      }

      function updateStudyTime() {
        if (!courseSession.startTime || document.hidden) return;

        const now = new Date();
        const sessionDuration = now - courseSession.startTime;
        courseSession.totalStudyTime = Math.floor(sessionDuration / 1000 / 60); // in minutes

        // Update progress with study time
        saveProgress();
      }

      function saveSessionData() {
        if (!currentUser || !courseSession.startTime) return;

        const sessionData = {
          user_id: currentUser.id,
          course_id: COURSE_DATA.id,
          session_duration: courseSession.totalStudyTime,
          lessons_viewed: courseSession.lessonsStarted,
          lessons_completed: courseSession.lessonsCompleted,
          interactions: courseSession.interactionCount,
          session_date: courseSession.startTime.toISOString().split("T")[0],
        };

        // Store in localStorage as backup
        localStorage.setItem(
          "course_session_backup",
          JSON.stringify(sessionData)
        );

        // Try to save to database
        logUserActivity("course_session_end", sessionData);
      }

      // =====================================================
      // COURSE DATA & PROGRESS MANAGEMENT
      // =====================================================
      async function loadCourseData() {
        try {
          // Update course info in UI
          document.getElementById("courseTitle").textContent =
            COURSE_DATA.title;
          document.getElementById("totalLessons").textContent =
            COURSE_DATA.lessons.length;

          // Log course access
          logUserActivity("course_access", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
          });
        } catch (error) {
          console.error("Error loading course data:", error);
        }
      }

      async function loadProgress() {
        try {
          // Get existing progress from database
          const { data, error } = await supabase
            .from("course_progress")
            .select("*")
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (data) {
            courseProgress = JSON.parse(data.lesson_progress || "{}");
            currentLessonIndex = data.current_lesson || 0;

            // Update session tracking
            courseSession.lessonsStarted = Object.keys(courseProgress).length;
            courseSession.lessonsCompleted = Object.values(
              courseProgress
            ).filter((p) => p.completed).length;
          } else {
            // Initialize new progress
            courseProgress = {};
            currentLessonIndex = 0;
            await saveProgress();

            // Award first course start achievement
            await checkAndUnlockAchievement("first_course_start");
          }

          updateProgressDisplay();
        } catch (error) {
          console.error("Error loading progress:", error);
          showToast("Failed to load progress", "error");
        }
      }

      async function saveProgress() {
        try {
          if (!currentUser) return;

          const now = new Date();
          const progressData = {
            user_id: currentUser.id,
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            current_lesson: currentLessonIndex,
            lesson_progress: JSON.stringify(courseProgress),
            progress: calculateOverallProgress(),
            lessons_completed: getCompletedLessonsCount(),
            lessons_started: Object.keys(courseProgress).length,
            study_time_minutes: courseSession.totalStudyTime,
            last_accessed: now.toISOString(),
            updated_at: now.toISOString(),
          };

          // Upsert progress
          const { error } = await supabase
            .from("course_progress")
            .upsert([progressData]);

          if (error) throw error;

          // Update user stats
          await updateUserStats();

          updateProgressDisplay();
        } catch (error) {
          console.error("Error saving progress:", error);
          showToast("Failed to save progress", "error");
        }
      }

      async function updateUserStats() {
        try {
          // Get all course progress for this user
          const { data: allProgress, error } = await supabase
            .from("course_progress")
            .select("progress, course_id, study_time_minutes")
            .eq("user_id", currentUser.id);

          if (error) throw error;

          // Calculate stats
          const completedCourses =
            allProgress?.filter((p) => p.progress >= 100).length || 0;
          const inProgressCourses =
            allProgress?.filter((p) => p.progress > 0 && p.progress < 100)
              .length || 0;
          const totalStudyTime =
            allProgress?.reduce(
              (sum, p) => sum + (p.study_time_minutes || 0),
              0
            ) || 0;

          // Calculate points (500 per completed course + achievement points)
          const coursePoints = completedCourses * 500;
          const bonusPoints = userStats.bonus_points || 0;
          const totalPoints = coursePoints + bonusPoints;

          // Update profile
          const updateData = {
            completed_courses: completedCourses,
            in_progress_courses: inProgressCourses,
            total_points: totalPoints,
            total_study_time: totalStudyTime,
            last_activity: new Date().toISOString(),
          };

          const { error: updateError } = await supabase
            .from("profiles")
            .update(updateData)
            .eq("id", currentUser.id);

          if (updateError) throw updateError;

          // Update local stats
          Object.assign(userStats, updateData);
        } catch (error) {
          console.error("Error updating user stats:", error);
        }
      }

      function calculateOverallProgress() {
        const completedLessons = getCompletedLessonsCount();
        return Math.round(
          (completedLessons / COURSE_DATA.lessons.length) * 100
        );
      }

      function getCompletedLessonsCount() {
        return Object.values(courseProgress).filter(
          (lesson) => lesson.completed
        ).length;
      }

      function updateProgressDisplay() {
        const completedCount = getCompletedLessonsCount();
        const progressPercent = calculateOverallProgress();

        // Update UI elements
        const elements = {
          completedLessons: completedCount,
          courseProgressPercent: `${progressPercent}%`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });

        // Update progress bar
        const progressBar = document.getElementById("courseProgressFill");
        if (progressBar) progressBar.style.width = `${progressPercent}%`;
      }

      // =====================================================
      // LESSON MANAGEMENT
      // =====================================================
      function loadLesson(index) {
        if (index < 0 || index >= COURSE_DATA.lessons.length) return;

        const lesson = COURSE_DATA.lessons[index];
        currentLessonIndex = index;

        // Mark lesson as started and track activity
        if (!courseProgress[lesson.id]) {
          courseProgress[lesson.id] = {
            started: true,
            completed: false,
            startedAt: new Date().toISOString(),
            timeSpent: 0,
          };

          courseSession.lessonsStarted++;
          saveProgress();

          // Log lesson start
          logUserActivity("lesson_start", {
            lesson_id: lesson.id,
            lesson_title: lesson.title,
            lesson_index: index,
          });
        }

        // Update lesson start time for time tracking
        courseProgress[lesson.id].currentSessionStart = new Date();

        // Update sidebar and navigation
        renderSidebar();
        updateNavigationButtons();

        // Update header info
        updateLessonHeader(lesson, index);

        // Render lesson content
        renderLessonContent(lesson);

        // Smooth scroll and animations
        window.scrollTo({ top: 0, behavior: "smooth" });
        document.getElementById("contentBody").scrollTop = 0;

        const contentBody = document.getElementById("contentBody");
        contentBody.classList.add("fade-in");
        setTimeout(() => contentBody.classList.remove("fade-in"), 500);

        // Check lesson-based achievements
        checkLessonAchievements(index + 1);
      }

      function updateLessonHeader(lesson, index) {
        const elements = {
          currentLessonNumber: index + 1,
          currentLessonTitle: lesson.title,
          navInfo: `Lesson ${index + 1} of ${COURSE_DATA.lessons.length}`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });
      }

      function renderSidebar() {
        const lessonNav = document.getElementById("lessonNav");
        if (!lessonNav) return;

        lessonNav.innerHTML = "";

        COURSE_DATA.lessons.forEach((lesson, index) => {
          const lessonItem = document.createElement("div");
          lessonItem.className = "lesson-item";

          // Determine lesson status
          const lessonProgress = courseProgress[lesson.id];
          const isCompleted = lessonProgress?.completed || false;
          const isInProgress = lessonProgress?.started || false;
          const isLocked = !isCompleted && !canAccessLesson(index);
          const isActive = index === currentLessonIndex;

          // Apply status classes
          if (isCompleted) lessonItem.classList.add("completed");
          if (isLocked) lessonItem.classList.add("locked");
          if (isActive) lessonItem.classList.add("active");

          // Determine status display
          let statusClass = "not-started";
          let statusIcon = index + 1;

          if (isCompleted) {
            statusClass = "completed";
            statusIcon = "";
          } else if (isInProgress) {
            statusClass = "in-progress";
            statusIcon = "";
          }

          // Create lesson item HTML
          lessonItem.innerHTML = `
            <div class="lesson-status ${statusClass}">${statusIcon}</div>
            <div class="lesson-info">
                <div class="lesson-title">${lesson.title}</div>
                <div class="lesson-meta">
                    ${
                      isCompleted
                        ? "Completed"
                        : isInProgress
                        ? "In Progress"
                        : isLocked
                        ? "Locked"
                        : "Not Started"
                    }
                </div>
            </div>
            <div class="lesson-duration">${lesson.duration}</div>
        `;

          // Add click handler if not locked
          if (!isLocked) {
            lessonItem.addEventListener("click", () => {
              if (index !== currentLessonIndex) {
                // Track lesson time before switching
                trackLessonTime();

                currentLessonIndex = index;
                loadLesson(index);
                closeSidebar();
              }
            });
          }

          lessonNav.appendChild(lessonItem);
        });
      }

      function canAccessLesson(index) {
        if (index === 0) return true; // First lesson always accessible

        // Can access if previous lesson is completed
        const previousLessonId = COURSE_DATA.lessons[index - 1].id;
        return courseProgress[previousLessonId]?.completed || false;
      }

      function trackLessonTime() {
        const currentLesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonProgress = courseProgress[currentLesson.id];

        if (lessonProgress?.currentSessionStart) {
          const sessionTime = Math.floor(
            (new Date() - new Date(lessonProgress.currentSessionStart)) /
              1000 /
              60
          );
          lessonProgress.timeSpent =
            (lessonProgress.timeSpent || 0) + sessionTime;
          delete lessonProgress.currentSessionStart;
        }
      }

      // =====================================================
      // LESSON CONTENT RENDERING
      // =====================================================
      function renderLessonContent(lesson) {
        const contentContainer = document.getElementById("lessonContent");
        if (!contentContainer) return;

        let contentHTML = `
        <div class="content-section">
            <h2>Learning Objectives</h2>
            <ul>
                ${lesson.objectives.map((obj) => `<li>${obj}</li>`).join("")}
            </ul>
        </div>
        
        <div class="content-section">
            <h2>Overview</h2>
            <p>${lesson.content.overview}</p>
        </div>
    `;

        // Render content sections
        lesson.content.sections.forEach((section) => {
          contentHTML += `
            <div class="content-section">
                <h2>${section.title}</h2>
                ${section.content}
                ${
                  section.image
                    ? `<img src="${section.image}" alt="${section.title}" class="content-image" loading="lazy">`
                    : ""
                }
            </div>
        `;
        });

        // Render code examples
        if (
          lesson.content.codeExamples &&
          lesson.content.codeExamples.length > 0
        ) {
          contentHTML += `<div class="content-section"><h2>Code Examples</h2></div>`;

          lesson.content.codeExamples.forEach((example, index) => {
            const codeId = `code-${lesson.id}-${index}`;
            contentHTML += `
                <div class="code-section">
                    <div class="code-header">
                        <span class="code-title">${example.title}</span>
                        <button class="copy-btn" onclick="copyCode('${codeId}')">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <pre class="code-block"><code id="${codeId}" class="language-${
              example.language
            }">${escapeHtml(example.code)}</code></pre>
                </div>
            `;
          });
        }

        // Render quiz
        contentHTML += renderQuiz(lesson.quiz);

        contentContainer.innerHTML = contentHTML;

        // Highlight code syntax if Prism is available
        setTimeout(() => {
          if (window.Prism) {
            Prism.highlightAll();
          }
        }, 100);
      }

      // =====================================================
      // QUIZ SYSTEM
      // =====================================================
      function renderQuiz(quiz) {
        const currentLessonProgress =
          courseProgress[COURSE_DATA.lessons[currentLessonIndex].id];
        const isCompleted = currentLessonProgress?.completed || false;

        let quizHTML = `
        <div class="quiz-section" id="quizSection">
            <div class="quiz-header">
                <h2 class="quiz-title">
                    <i class="fas fa-clipboard-check"></i>
                    Knowledge Check
                </h2>
                <p class="quiz-info">
                    Complete this quiz with ${quiz.passingScore}% or higher to unlock the next lesson.
                </p>
            </div>
    `;

        if (isCompleted) {
          const savedScore = currentLessonProgress.quizScore || 0;
          quizHTML += `
            <div class="quiz-results show">
                <div class="quiz-score pass">${savedScore}%</div>
                <div class="quiz-message">
                    <strong>Lesson Completed!</strong><br>
                    You've successfully passed this lesson's quiz.
                </div>
            </div>
        `;
        } else {
          // Render quiz questions
          quiz.questions.forEach((question, qIndex) => {
            quizHTML += `
                <div class="quiz-question ${
                  qIndex === 0 ? "active" : ""
                }" data-question="${qIndex}">
                    <div class="question-header">
                        <span class="question-number">Question ${
                          qIndex + 1
                        }</span>
                        <span class="question-progress">${qIndex + 1}/${
              quiz.questions.length
            }</span>
                    </div>
                    <div class="question-text">${question.question}</div>
                    <div class="question-options">
                        ${question.options
                          .map(
                            (option, oIndex) => `
                            <div class="option" data-option="${oIndex}" onclick="selectOption(${qIndex}, ${oIndex})">
                                <span class="option-letter">${String.fromCharCode(
                                  65 + oIndex
                                )}</span>
                                <span class="option-text">${option}</span>
                            </div>
                        `
                          )
                          .join("")}
                    </div>
                </div>
            `;
          });

          quizHTML += `
            <div class="quiz-controls">
                <button class="btn btn-secondary" id="prevQuestionBtn" onclick="previousQuestion()" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <div>
                    <button class="btn btn-secondary" id="nextQuestionBtn" onclick="nextQuestion()" disabled>
                        Next
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <button class="btn btn-primary" id="submitQuizBtn" onclick="submitQuiz()" style="display: none;">
                        <i class="fas fa-check"></i>
                        Submit Quiz
                    </button>
                </div>
            </div>

            <div class="quiz-results" id="quizResults">
                <div class="quiz-score" id="quizScore">0%</div>
                <div class="quiz-message" id="quizMessage"></div>
                <div class="quiz-actions">
                    <button class="btn btn-primary" id="continueBtn" onclick="completeLesson()" style="display: none;">
                        <i class="fas fa-arrow-right"></i>
                        Continue to Next Lesson
                    </button>
                    <button class="btn btn-secondary" onclick="retakeQuiz()">
                        <i class="fas fa-redo"></i>
                        Retake Quiz
                    </button>
                </div>
            </div>
        `;
        }

        quizHTML += "</div>";
        return quizHTML;
      }

      // Quiz interaction functions
      function selectOption(questionIndex, optionIndex) {
        // Clear previous selections
        document
          .querySelectorAll(`[data-question="${questionIndex}"] .option`)
          .forEach((opt) => {
            opt.classList.remove("selected");
          });

        // Select current option
        const selectedOption = document.querySelector(
          `[data-question="${questionIndex}"] [data-option="${optionIndex}"]`
        );
        selectedOption.classList.add("selected");

        // Store answer
        quizState.answers[questionIndex] = optionIndex;

        // Update navigation
        const isLastQuestion =
          questionIndex ===
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length - 1;
        if (isLastQuestion) {
          document.getElementById("submitQuizBtn").style.display =
            "inline-flex";
          document.getElementById("nextQuestionBtn").style.display = "none";
        } else {
          document.getElementById("nextQuestionBtn").disabled = false;
        }
      }

      function nextQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const nextQuestionEl = currentQuestionEl.nextElementSibling;

        if (
          nextQuestionEl &&
          nextQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          nextQuestionEl.classList.add("active");
          quizState.currentQuestion++;
          updateQuizNavigation();
        }
      }

      function previousQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const prevQuestionEl = currentQuestionEl.previousElementSibling;

        if (
          prevQuestionEl &&
          prevQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          prevQuestionEl.classList.add("active");
          quizState.currentQuestion--;
          updateQuizNavigation();
        }
      }

      function updateQuizNavigation() {
        const totalQuestions =
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length;
        const prevBtn = document.getElementById("prevQuestionBtn");
        const nextBtn = document.getElementById("nextQuestionBtn");
        const submitBtn = document.getElementById("submitQuizBtn");

        prevBtn.disabled = quizState.currentQuestion === 0;

        const hasAnswer =
          quizState.answers[quizState.currentQuestion] !== undefined;
        const isLastQuestion = quizState.currentQuestion === totalQuestions - 1;

        if (isLastQuestion) {
          nextBtn.style.display = "none";
          submitBtn.style.display = hasAnswer ? "inline-flex" : "none";
        } else {
          nextBtn.style.display = "inline-flex";
          nextBtn.disabled = !hasAnswer;
          submitBtn.style.display = "none";
        }
      }

      async function submitQuiz() {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const quiz = lesson.quiz;
        let correctAnswers = 0;

        // Hide questions and controls
        document
          .querySelectorAll(".quiz-question")
          .forEach((q) => (q.style.display = "none"));
        document.querySelector(".quiz-controls").style.display = "none";

        // Calculate score and highlight answers
        quiz.questions.forEach((question, index) => {
          const userAnswer = quizState.answers[index];
          const correctAnswer = question.correct;
          const isCorrect = userAnswer === correctAnswer;

          if (isCorrect) correctAnswers++;

          // Highlight answers
          const questionEl = document.querySelector(
            `[data-question="${index}"]`
          );
          const options = questionEl.querySelectorAll(".option");

          options[correctAnswer].classList.add("correct");
          if (userAnswer !== correctAnswer && userAnswer !== undefined) {
            options[userAnswer].classList.add("incorrect");
          }
        });

        const score = Math.round(
          (correctAnswers / quiz.questions.length) * 100
        );
        const passed = score >= quiz.passingScore;

        // Update quiz results UI
        const quizScore = document.getElementById("quizScore");
        const quizMessage = document.getElementById("quizMessage");
        const quizActions = document.querySelector(".quiz-actions");

        quizScore.textContent = `${score}%`;
        quizScore.className = `quiz-score ${passed ? "pass" : "fail"}`;

        if (passed) {
          quizMessage.innerHTML = `
            <strong>Congratulations!</strong><br>
            You passed with ${score}%. You can now proceed to the next lesson.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-primary" onclick="completeLesson()">
                <i class="fas fa-arrow-right"></i>
                Continue to Next Lesson
            </button>
        `;

          // Mark lesson as completed
          await markLessonComplete(score);
        } else {
          quizMessage.innerHTML = `
            <strong>Not quite there yet.</strong><br>
            You scored ${score}%. You need ${quiz.passingScore}% to pass. Review the material and try again.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-secondary" onclick="retakeQuiz()">
                <i class="fas fa-redo"></i>
                Retake Quiz
            </button>
        `;
        }

        document.getElementById("quizResults").classList.add("show");

        // Log quiz completion
        logUserActivity("quiz_completed", {
          lesson_id: lesson.id,
          lesson_title: lesson.title,
          score: score,
          passed: passed,
          attempts: (courseProgress[lesson.id]?.quizAttempts || 0) + 1,
        });

        // Scroll to results
        document
          .getElementById("quizResults")
          .scrollIntoView({ behavior: "smooth" });
      }

      function retakeQuiz() {
        // Reset quiz state
        quizState = {
          currentQuestion: 0,
          answers: [],
          score: 0,
          isComplete: false,
        };

        // Track quiz retry
        const lessonId = COURSE_DATA.lessons[currentLessonIndex].id;
        if (!courseProgress[lessonId]) courseProgress[lessonId] = {};
        courseProgress[lessonId].quizAttempts =
          (courseProgress[lessonId].quizAttempts || 0) + 1;

        // Reload lesson content
        loadLesson(currentLessonIndex);

        // Scroll to quiz
        setTimeout(() => {
          document
            .getElementById("quizSection")
            .scrollIntoView({ behavior: "smooth" });
        }, 500);
      }

      async function markLessonComplete(score) {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonId = lesson.id;

        // Track lesson completion time
        trackLessonTime();

        // Update lesson progress
        courseProgress[lessonId] = {
          ...courseProgress[lessonId],
          completed: true,
          quizScore: score,
          completedAt: new Date().toISOString(),
          finalScore: score,
        };

        // Update session tracking
        courseSession.lessonsCompleted++;

        // Save progress to database
        await saveProgress();

        // Update UI
        renderSidebar();
        updateNavigationButtons();

        // Check various achievements
        await checkLessonCompletionAchievements();
        await checkPerfectScoreAchievements(score);
        await checkStudyTimeAchievements();

        // Log lesson completion
        logUserActivity("lesson_completed", {
          lesson_id: lessonId,
          lesson_title: lesson.title,
          final_score: score,
          time_spent: courseProgress[lessonId].timeSpent || 0,
          lesson_number: currentLessonIndex + 1,
        });

        showToast("Lesson completed successfully!", "success");
      }

      async function completeLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          // Move to next lesson
          currentLessonIndex++;
          loadLesson(currentLessonIndex);
        } else {
          // Course completion
          await completeCourse();
        }
      }

      async function completeCourse() {
        try {
          const completionTime = courseSession.totalStudyTime;

          // Update course progress to 100% completed
          await supabase
            .from("course_progress")
            .update({
              progress: 100,
              completed_at: new Date().toISOString(),
              completion_time_minutes: completionTime,
            })
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Award course completion achievements
          await checkAndUnlockAchievement("course_completion_1");
          await checkSpeedCompletionAchievements(completionTime);
          await checkCourseStreakAchievements();

          // Update user stats
          await updateUserStats();

          // Show completion message
          showToast(
            "Congratulations! Course completed successfully!",
            "certificate"
          );

          // Log course completion
          logUserActivity("course_completed", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            completion_time_minutes: completionTime,
            total_lessons: COURSE_DATA.lessons.length,
            average_quiz_score: calculateAverageQuizScore(),
          });

          // Redirect to dashboard after delay
          setTimeout(() => {
            window.location.href = "/dashboard";
          }, 3000);
        } catch (error) {
          console.error("Error completing course:", error);
          showToast("Error marking course as complete", "error");
        }
      }

      // =====================================================
      // ACHIEVEMENT INTEGRATION SYSTEM
      // =====================================================
      async function checkAndUnlockAchievement(
        achievementId,
        skipNotification = false
      ) {
        try {
          // Prevent duplicate checks
          const cacheKey = `achievement_${achievementId}_${currentUser.id}`;
          if (sessionStorage.getItem(cacheKey)) return false;

          // Check if already unlocked
          const { data: existing, error } = await supabase
            .from("user_achievements")
            .select("id")
            .eq("user_id", currentUser.id)
            .eq("achievement_id", achievementId)
            .single();

          if (existing) {
            sessionStorage.setItem(cacheKey, "true");
            return false;
          }

          // Award achievement
          const achievementData = {
            user_id: currentUser.id,
            achievement_id: achievementId,
            unlocked_at: new Date().toISOString(),
            points_awarded: getAchievementPoints(achievementId),
            context: "course_system",
          };

          const { data, error: insertError } = await supabase
            .from("user_achievements")
            .insert([achievementData])
            .select()
            .single();

          if (insertError) {
            if (insertError.code === "23505") return false; // Already exists
            throw insertError;
          }

          // Update user points
await supabase.rpc('increment_user_stats', {
  user_id_param: currentUser.id,
  points_to_add: achievementData.points_awarded,
  achievements_to_add: 1
});

          // Cache and queue notification
          sessionStorage.setItem(cacheKey, "true");

          if (!skipNotification) {
            queueAchievementNotification({
              id: achievementId,
              name: getAchievementName(achievementId),
              description: getAchievementDescription(achievementId),
              points: achievementData.points_awarded,
              rarity: getAchievementRarity(achievementId),
              icon: getAchievementIcon(achievementId),
            });
          }

          return true;
        } catch (error) {
          console.error("Error unlocking achievement:", error);
          return false;
        }
      }

      // Helper functions for achievement data (replace with your actual achievement definitions)
      function getAchievementPoints(id) {
        const pointsMap = {
          first_course_start: 75,
          first_lesson: 100,
          course_completion_1: 500,
          perfect_score: 250,
          speed_demon: 750,
          marathon_learner: 500,
          night_owl: 200,
          early_bird: 200,
          weekend_warrior: 150,
          // Add more as needed
        };
        return pointsMap[id] || 100;
      }

      function getAchievementName(id) {
        const nameMap = {
          first_course_start: "Learning Initiated",
          first_lesson: "First Steps",
          course_completion_1: "Course Conqueror",
          perfect_score: "Perfectionist",
          speed_demon: "Speed Demon",
          // Add more as needed
        };
        return nameMap[id] || "Achievement Unlocked";
      }

      function getAchievementDescription(id) {
        const descMap = {
          first_course_start: "Start your first cybersecurity course",
          first_lesson: "Complete your first lesson",
          course_completion_1: "Complete your first course",
          perfect_score: "Score 100% on any quiz",
          speed_demon: "Complete a course in under 2 hours",
          // Add more as needed
        };
        return descMap[id] || "Achievement description";
      }

      function getAchievementRarity(id) {
        const rarityMap = {
          first_course_start: "common",
          first_lesson: "bronze",
          course_completion_1: "silver",
          perfect_score: "gold",
          speed_demon: "legendary",
          // Add more as needed
        };
        return rarityMap[id] || "common";
      }

      function getAchievementIcon(id) {
        const iconMap = {
          first_course_start: "fas fa-play",
          first_lesson: "fas fa-baby",
          course_completion_1: "fas fa-trophy",
          perfect_score: "fas fa-star",
          speed_demon: "fas fa-rocket",
          // Add more as needed
        };
        return iconMap[id] || "fas fa-award";
      }

      async function checkLessonAchievements(lessonNumber) {
        if (lessonNumber === 1) {
          await checkAndUnlockAchievement("first_lesson");
        }

        // Check if user has completed multiple lessons in one day
        const today = new Date().toISOString().split("T")[0];
        const todayCompletions = Object.values(courseProgress).filter(
          (p) => p.completed && p.completedAt?.startsWith(today)
        ).length;

        if (todayCompletions >= 3) {
          await checkAndUnlockAchievement("lesson_marathon");
        }
      }

      async function checkLessonCompletionAchievements() {
        const completedCount = getCompletedLessonsCount();

        // Lesson-based achievements
        const lessonMilestones = [1, 5, 10, 25, 50, 100];
        for (const milestone of lessonMilestones) {
          if (completedCount >= milestone) {
            await checkAndUnlockAchievement(`lessons_${milestone}`);
          }
        }

        // Course completion achievements
        if (completedCount === COURSE_DATA.lessons.length) {
          await checkAndUnlockAchievement("course_completion_1");

          // Check for additional course completion achievements
          const { data: allCourses } = await supabase
            .from("course_progress")
            .select("course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100);

          const totalCompleted = allCourses?.length || 0;

          const courseMilestones = [1, 5, 10, 25];
          for (const milestone of courseMilestones) {
            if (totalCompleted >= milestone) {
              await checkAndUnlockAchievement(`course_completion_${milestone}`);
            }
          }
        }
      }

      async function checkPerfectScoreAchievements(score) {
        if (score === 100) {
          await checkAndUnlockAchievement("perfect_score");

          // Check for consecutive perfect scores
          const recentScores = Object.values(courseProgress)
            .filter((p) => p.completed && p.quizScore)
            .slice(-5) // Last 5 completed
            .map((p) => p.quizScore);

          if (
            recentScores.length >= 3 &&
            recentScores.every((s) => s === 100)
          ) {
            await checkAndUnlockAchievement("perfectionist_streak");
          }
        }
      }

      async function checkSpeedCompletionAchievements(completionTime) {
        // Speed demon: Complete course in under 2 hours (120 minutes)
        if (completionTime <= 120) {
          await checkAndUnlockAchievement("speed_demon");
        }

        // Quick learner: Complete course in under 4 hours (240 minutes)
        if (completionTime <= 240) {
          await checkAndUnlockAchievement("quick_learner");
        }
      }

      async function checkStudyTimeAchievements() {
        const totalTime = courseSession.totalStudyTime;

        // Marathon learner: Study for 8+ hours in a course session
        if (totalTime >= 480) {
          // 8 hours
          await checkAndUnlockAchievement("marathon_learner");
        }

        // Dedicated learner: Study for 4+ hours
        if (totalTime >= 240) {
          // 4 hours
          await checkAndUnlockAchievement("dedicated_learner");
        }
      }

      async function checkCourseStreakAchievements() {
        try {
          // Check for consecutive course completions
          const { data: recentCourses, error } = await supabase
            .from("course_progress")
            .select("completed_at, course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100)
            .order("completed_at", { ascending: false })
            .limit(10);

          if (error || !recentCourses) return;

          // Check for courses completed on consecutive days
          let consecutiveDays = 1;
          for (let i = 1; i < recentCourses.length; i++) {
            const prevDate = new Date(
              recentCourses[i - 1].completed_at
            ).toDateString();
            const currentDate = new Date(
              recentCourses[i].completed_at
            ).toDateString();
            const dayDiff =
              Math.abs(new Date(prevDate) - new Date(currentDate)) /
              (1000 * 60 * 60 * 24);

            if (dayDiff <= 1) {
              consecutiveDays++;
            } else {
              break;
            }
          }

          if (consecutiveDays >= 3) {
            await checkAndUnlockAchievement("learning_streak");
          }
        } catch (error) {
          console.error("Error checking course streak achievements:", error);
        }
      }

      // =====================================================
      // TIME-BASED ACHIEVEMENTS
      // =====================================================
      async function checkTimeBasedAchievements(timestamp) {
        const hour = timestamp.getHours();
        const dayOfWeek = timestamp.getDay();

        // Night owl (after midnight, before 6 AM)
        if (hour >= 0 && hour < 6) {
          await incrementTimeBasedCounter("midnight_sessions", "night_owl");
        }

        // Early bird (4 AM to 6 AM)
        if (hour >= 4 && hour < 6) {
          await incrementTimeBasedCounter("early_sessions", "early_bird");
        }

        // Weekend warrior (Saturday = 6, Sunday = 0)
        if (dayOfWeek === 0 || dayOfWeek === 6) {
          await incrementTimeBasedCounter(
            "weekend_sessions",
            "weekend_warrior"
          );
        }
      }

      async function incrementTimeBasedCounter(counterType, achievementId) {
        try {
          const dateStr = new Date().toISOString().split("T")[0];
          const cacheKey = `${counterType}_${currentUser.id}_${dateStr}`;

          // Prevent multiple increments per day
          if (sessionStorage.getItem(cacheKey)) return;

          // Update counter
          await supabase.rpc('increment_profile_counter', {
  user_id_param: currentUser.id,
  counter_field: counterType,
  increment_value: 1
});

          // Cache to prevent double counting
          sessionStorage.setItem(cacheKey, "true");

          // Check related achievement
          if (achievementId) {
            await checkAndUnlockAchievement(achievementId, true);
          }
        } catch (error) {
          console.error(`Error incrementing ${counterType}:`, error);
        }
      }

      async function checkDailyStreak() {
        try {
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("last_activity, current_streak, last_streak_date")
            .eq("id", currentUser.id)
            .single();

          if (error) throw error;

          const now = new Date();
          const today = now.toDateString();
          const lastActivity = profile.last_activity
            ? new Date(profile.last_activity)
            : null;
          const lastStreakDate = profile.last_streak_date
            ? new Date(profile.last_streak_date).toDateString()
            : null;

          let newStreak = profile.current_streak || 0;
          let shouldUpdateStreak = false;

          if (!lastActivity) {
            // First time user
            newStreak = 1;
            shouldUpdateStreak = true;
          } else {
            const daysSinceLastActivity = Math.floor(
              (now - lastActivity) / (1000 * 60 * 60 * 24)
            );

            if (lastStreakDate === today) {
              // Already counted today's streak
              return newStreak;
            } else if (
              daysSinceLastActivity === 1 ||
              (daysSinceLastActivity === 0 && lastStreakDate !== today)
            ) {
              // Consecutive day or same day but not counted yet
              newStreak += 1;
              shouldUpdateStreak = true;
            } else if (daysSinceLastActivity > 1) {
              // Streak broken
              newStreak = 1;
              shouldUpdateStreak = true;
            }
          }

          if (shouldUpdateStreak) {
            await supabase
              .from("profiles")
              .update({
                current_streak: newStreak,
                last_activity: now.toISOString(),
                last_streak_date: now.toISOString(),
              })
              .eq("id", currentUser.id);

            userStats.current_streak = newStreak;

            showToast(`Daily streak: ${newStreak} days!`, "success");
            await checkStreakAchievements(newStreak);
          }

          return newStreak;
        } catch (error) {
          console.error("Error checking daily streak:", error);
          return 0;
        }
      }

      async function checkStreakAchievements(currentStreak) {
        const streakMilestones = [3, 7, 14, 30, 100, 365];

        for (const milestone of streakMilestones) {
          if (currentStreak >= milestone) {
            await checkAndUnlockAchievement(`streak_${milestone}`);
          }
        }
      }

      // =====================================================
      // USER ACTIVITY LOGGING
      // =====================================================
      async function logUserActivity(activityType, metadata = {}) {
        try {
          const now = new Date();

          const activityData = {
            user_id: currentUser.id,
            activity_type: activityType,
            timestamp: now.toISOString(),
            course_id: COURSE_DATA.id,
            lesson_index: currentLessonIndex,
            session_duration: courseSession.totalStudyTime,
            metadata: JSON.stringify(metadata),
            created_at: now.toISOString(),
          };

          // Try to log to activities table
          const { error } = await supabase
            .from("user_activities")
            .insert([activityData]);

          if (error && error.code !== "42P01") {
            console.warn("Activity logging failed:", error.message);
          }

          // Always update last activity in profile
          await supabase
            .from("profiles")
            .update({ last_activity: now.toISOString() })
            .eq("id", currentUser.id);
        } catch (error) {
          console.error("Error logging user activity:", error);
        }
      }

      // =====================================================
      // NAVIGATION SYSTEM
      // =====================================================
      function updateNavigationButtons() {
        const prevBtn = document.getElementById("prevLessonBtn");
        const nextBtn = document.getElementById("nextLessonBtn");

        if (!prevBtn || !nextBtn) return;

        // Previous button
        prevBtn.disabled = currentLessonIndex === 0;

        // Next button logic
        const isLastLesson =
          currentLessonIndex === COURSE_DATA.lessons.length - 1;
        const canGoNext =
          currentLessonIndex < COURSE_DATA.lessons.length - 1 &&
          canAccessLesson(currentLessonIndex + 1);

        if (isLastLesson) {
          const isCurrentCompleted =
            courseProgress[COURSE_DATA.lessons[currentLessonIndex].id]
              ?.completed;
          nextBtn.disabled = !isCurrentCompleted;
          nextBtn.innerHTML = '<i class="fas fa-trophy"></i> Complete Course';
        } else {
          nextBtn.disabled = !canGoNext;
          nextBtn.innerHTML = 'Next <i class="fas fa-chevron-right"></i>';
        }
      }

      // Navigation button event handlers
      function goToPreviousLesson() {
        if (currentLessonIndex > 0) {
          trackLessonTime(); // Track time spent on current lesson
          currentLessonIndex--;
          loadLesson(currentLessonIndex);
        }
      }

      function goToNextLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          const canGoNext = canAccessLesson(currentLessonIndex + 1);
          if (canGoNext) {
            trackLessonTime();
            currentLessonIndex++;
            loadLesson(currentLessonIndex);
          } else {
            showToast("Complete the current lesson quiz to proceed", "warning");
          }
        } else {
          // Complete course
          completeCourse();
        }
      }

      // =====================================================
      // SIDEBAR FUNCTIONS
      // =====================================================
      function toggleSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.toggle("open");
        if (overlay) overlay.classList.toggle("active");
      }

      function closeSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.remove("open");
        if (overlay) overlay.classList.remove("active");
      }

      // =====================================================
      // ACHIEVEMENT NOTIFICATION SYSTEM
      // =====================================================
      function queueAchievementNotification(achievement) {
        notificationQueue.push(achievement);
        processNotificationQueue();
      }

      function processNotificationQueue() {
        if (isShowingNotification || notificationQueue.length === 0) return;

        isShowingNotification = true;
        const achievement = notificationQueue.shift();
        showAchievementNotification(achievement);

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          isShowingNotification = false;
          processNotificationQueue();
        }, duration + 500);
      }

      function showAchievementNotification(achievement) {
        const notification = document.getElementById("achievementNotification");
        if (!notification) return;

        const icon = document.getElementById("notificationIcon");
        const title = document.getElementById("notificationTitle");
        const description = document.getElementById("notificationDescription");
        const points = document.getElementById("notificationPoints");

        if (icon) {
          icon.innerHTML = `<i class="${achievement.icon}"></i>`;
          icon.className = `notification-icon ${achievement.rarity}`;
        }
        if (title) title.textContent = achievement.name;
        if (description) description.textContent = achievement.description;
        if (points) points.textContent = `+${achievement.points} Points`;

        notification.className = `achievement-notification ${achievement.rarity}`;
        notification.classList.add("show");

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          notification.classList.remove("show");
        }, duration);
      }

      // =====================================================
      // UTILITY FUNCTIONS
      // =====================================================
      function calculateAverageQuizScore() {
        const scores = Object.values(courseProgress)
          .filter((p) => p.completed && p.quizScore)
          .map((p) => p.quizScore);

        if (scores.length === 0) return 0;
        return Math.round(
          scores.reduce((sum, score) => sum + score, 0) / scores.length
        );
      }

      async function resetProgress() {
        if (
          !confirm(
            "Are you sure you want to reset your progress? This action cannot be undone."
          )
        ) {
          return;
        }

        try {
          // Track lesson time before reset
          trackLessonTime();

          // Reset local state
          courseProgress = {};
          currentLessonIndex = 0;
          courseSession = {
            startTime: new Date(),
            totalStudyTime: 0,
            lessonsStarted: 0,
            lessonsCompleted: 0,
            pageLoadTime: new Date(),
            interactionCount: 0,
            lastActivityTime: new Date(),
          };

          // Delete from database
          await supabase
            .from("course_progress")
            .delete()
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Log reset activity
          logUserActivity("progress_reset", {
            course_id: COURSE_DATA.id,
            reset_reason: "manual",
          });

          // Reinitialize
          await saveProgress();
          renderSidebar();
          loadLesson(0);

          showToast("Progress reset successfully", "success");
        } catch (error) {
          console.error("Error resetting progress:", error);
          showToast("Failed to reset progress", "error");
        }
      }

      function copyCode(codeId) {
        const codeElement = document.getElementById(codeId);
        if (!codeElement) return;

        const text = codeElement.textContent;

        navigator.clipboard
          .writeText(text)
          .then(() => {
            showToast("Code copied to clipboard!", "success");

            // Track code copy for achievements
            logUserActivity("code_copied", {
              code_section: codeId,
              lesson_id: COURSE_DATA.lessons[currentLessonIndex].id,
            });
          })
          .catch((err) => {
            console.error("Failed to copy code:", err);
            showToast("Failed to copy code", "error");

            // Fallback for older browsers
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            try {
              document.execCommand("copy");
              showToast("Code copied to clipboard!", "success");
            } catch (fallbackError) {
              showToast(
                "Copy failed - please select and copy manually",
                "error"
              );
            }
            document.body.removeChild(textArea);
          });
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // =====================================================
      // UI FEEDBACK SYSTEMS
      // =====================================================
      function showToast(message, type = "success") {
        const toast = document.getElementById("toast");
        const messageEl = document.getElementById("toastMessage");

        if (!toast || !messageEl) {
          console.log(`Toast: ${message} (${type})`);
          return;
        }

        messageEl.textContent = message;
        toast.className = `toast ${type} show`;

        setTimeout(() => {
          toast.classList.remove("show");
        }, 4000);
      }

      function showLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) loadingScreen.classList.remove("hidden");
      }

      function hideLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) {
          setTimeout(() => {
            loadingScreen.classList.add("hidden");
          }, 1000);
        }
      }

      // =====================================================
      // MUSIC PLAYER INTEGRATION
      // =====================================================
      function initMusicPlayer() {
        const btnText = document.getElementById("music-button-text");
        const icon = document.getElementById("music-icon");
        const dropdown = document.getElementById("music-dropdown-content");

        if (!btnText || !icon || !dropdown) return;

        function setUI(state) {
          btnText.textContent =
            state === "Playing" ? "PAUSE MUSIC" : "STUDY MUSIC";
          icon.className =
            state === "Playing"
              ? "fa-solid fa-circle-pause"
              : "fa-solid fa-music";
        }

        // Load saved music state
        const savedSrc = localStorage.getItem("cybersec_music_src");
        const savedTime = parseFloat(
          localStorage.getItem("cybersec_music_time") || 0
        );

        if (savedSrc) {
          audioPlayer.src = savedSrc;
          audioPlayer.currentTime = savedTime;
          audioPlayer
            .play()
            .then(() => setUI("Playing"))
            .catch(() => setUI("Stopped"));
        }

        // Music button click handler
        document
          .getElementById("music-dropdown")
          .querySelector("button")
          .addEventListener("click", (e) => {
            e.stopPropagation();
            dropdown.style.display =
              dropdown.style.display === "block" ? "none" : "block";

            if (audioPlayer.src && !audioPlayer.paused) {
              audioPlayer.pause();
              setUI("Stopped");
            } else if (audioPlayer.src) {
              audioPlayer.play().then(() => setUI("Playing"));
            }
          });

        // Music selection handlers
        dropdown.querySelectorAll("a[data-src]").forEach((link) => {
          link.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.src = link.dataset.src;
            audioPlayer.play().then(() => setUI("Playing"));
            localStorage.setItem("cybersec_music_src", link.dataset.src);
            dropdown.style.display = "none";
          });
        });

        // Stop music handler
        const stopLink = document.getElementById("stop-music-link");
        if (stopLink) {
          stopLink.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            audioPlayer.removeAttribute("src");
            setUI("Stopped");
            localStorage.removeItem("cybersec_music_src");
            localStorage.removeItem("cybersec_music_time");
            dropdown.style.display = "none";
          });
        }

        // Save music state before page unload
        window.addEventListener("beforeunload", () => {
          if (!audioPlayer.paused && audioPlayer.src) {
            localStorage.setItem("cybersec_music_src", audioPlayer.src);
            localStorage.setItem(
              "cybersec_music_time",
              audioPlayer.currentTime
            );
          }
        });

        // Close dropdown when clicking outside
        window.addEventListener("click", (e) => {
          if (!e.target.closest("#music-dropdown")) {
            dropdown.style.display = "none";
          }
        });
      }

      // Show initial music indicator
      function addMusicIndicator() {
        const musicBtn = document.querySelector("#music-dropdown");
        if (musicBtn) {
          const indicator = document.createElement("div");
          indicator.className = "music-indicator";
          indicator.innerHTML = `<i class="fa-solid fa-music"></i> Try Study Music!`;

          musicBtn.style.position = "relative";
          musicBtn.appendChild(indicator);

          setTimeout(() => indicator.remove(), 3000);
        }
      }

      // Initialize Event Listeners
      function initializeEventListeners() {
        // Navigation buttons
        document
          .getElementById("prevLessonBtn")
          ?.addEventListener("click", goToPreviousLesson);
        document
          .getElementById("nextLessonBtn")
          ?.addEventListener("click", goToNextLesson);

        // Reset progress button
        document
          .getElementById("resetProgressBtn")
          ?.addEventListener("click", resetProgress);

        // Mobile menu toggle
        document
          .getElementById("menuToggle")
          ?.addEventListener("click", toggleSidebar);
        document
          .getElementById("sidebarOverlay")
          ?.addEventListener("click", closeSidebar);

        // Keyboard shortcuts
        document.addEventListener("keydown", handleKeyboardShortcuts);

        // Window resize handler
        window.addEventListener("resize", handleWindowResize);

        // Content interaction tracking
        document.getElementById("contentBody")?.addEventListener(
          "scroll",
          debounce(() => {
            trackUserInteraction();
          }, 1000)
        );
      }

      // Keyboard Shortcuts
      function handleKeyboardShortcuts(e) {
        if (document.querySelector(".quiz-question.active")) return;

        if (e.key === "ArrowLeft" && e.ctrlKey) {
          e.preventDefault();
          goToPreviousLesson();
        } else if (e.key === "ArrowRight" && e.ctrlKey) {
          e.preventDefault();
          goToNextLesson();
        }
      }

      // Window Resize Handler
      function handleWindowResize() {
        if (window.innerWidth > 768) {
          closeSidebar();
        }
      }

      // Debounce Helper
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Initialize responsive behavior
      if (window.innerWidth <= 768) {
        document.getElementById("menuToggle").style.display = "inline-flex";
      }

      // Auto-save progress periodically
      setInterval(async () => {
        if (currentUser && Object.keys(courseProgress).length > 0) {
          await saveProgress();
        }
      }, 60000); // Save every minute

      // System initialization logging
      console.log("CyberSec Academy Course System Initialized");
      console.log("Current Course:", COURSE_DATA.title);
      console.log("Total Lessons:", COURSE_DATA.lessons.length);

      // Google OAuth Integration
      const googleBtn = document.querySelector(".btn-google");
      if (googleBtn) {
        googleBtn.addEventListener("click", async () => {
          const { data, error } = await supabase.auth.signInWithOAuth({
            provider: "google",
            options: {
              redirectTo:
                window.location.origin +
                "/courses/android-app-security",
            },
          });

          if (error) {
            console.error("Google login error:", error.message);
            showToast("Google login failed: " + error.message, "error");
          }
        });
      }

      // Check for existing session
      supabase.auth.getSession().then(({ data }) => {
        if (data.session) {
          console.log("User already logged in:", data.session.user);
          currentUser = data.session.user;
          startCourseSession();
        }
      });

      // Add missing auth modal functions
      function openAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "flex";
        }
      }

      function closeAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Add auth tab switching functionality
      document.getElementById("tabSignIn")?.addEventListener("click", () => {
        document.getElementById("tabSignIn").classList.add("active");
        document.getElementById("tabSignUp").classList.remove("active");
        document.getElementById("signInForm").style.display = "block";
        document.getElementById("signUpForm").style.display = "none";
      });

      document.getElementById("tabSignUp")?.addEventListener("click", () => {
        document.getElementById("tabSignUp").classList.add("active");
        document.getElementById("tabSignIn").classList.remove("active");
        document.getElementById("signUpForm").style.display = "block";
        document.getElementById("signInForm").style.display = "none";
      });

      document
        .getElementById("closeAuthModal")
        ?.addEventListener("click", closeAuthModal);

      // Improved error handling for auth session
      supabase.auth.onAuthStateChange((event, session) => {
        if (event === "SIGNED_IN") {
          currentUser = session.user;
          closeAuthModal();
          startCourseSession();
        } else if (event === "SIGNED_OUT") {
          currentUser = null;
          openAuthModal();
        }
      });

      // Add form submission handlers
      document
        .getElementById("emailSignInForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signInEmail").value;
          const password = document.getElementById("signInPassword").value;

          try {
            const { data, error } = await supabase.auth.signInWithPassword({
              email,
              password,
            });

            if (error) throw error;

            closeAuthModal();
          } catch (error) {
            showToast(error.message, "error");
          }
        });

      document
        .getElementById("emailSignUpForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signUpEmail").value;
          const password = document.getElementById("signUpPassword").value;
          const name = document.getElementById("signUpName").value;

          try {
            const { data, error } = await supabase.auth.signUp({
              email,
              password,
              options: {
                data: {
                  full_name: name,
                },
              },
            });

            if (error) throw error;

            showToast(
              "Account created successfully! Please check your email.",
              "success"
            );
          } catch (error) {
            showToast(error.message, "error");
          }
        });
    </script>
  </body>
</html>

