




<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>SSL/TLS Basics Course Curriculum | CipherHall</title>
    <meta name="description" content="Begin your free SSL/TLS course. This curriculum covers the TLS handshake, digital certificates, public key cryptography, and secure server configuration." />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png" />
    <link rel="shortcut icon" href="/favicon.png" type="image/x-icon" />
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png" />
    <link rel="canonical" href="https://www.cipherhall.com/courses/ssl-tls-basics.html" />

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Course",
      "name": "SSL/TLS Basics",
      "description": "A comprehensive, 20-lesson course on the principles of secure communication, digital certificates, and the TLS protocol.",
      "provider": {
        "@type": "Organization",
        "name": "CipherHall",
        "sameAs": "https://www.cipherhall.com"
      },
      "hasCourseInstance": {
        "@type": "CourseInstance",
        "courseMode": "Online",
        "instructor": {
          "@type": "Person",
          "name": "Dr. Evelyn Reed"
        }
      }
    }
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Exo+2:wght@700;800;900&display=swap" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" />
    <link rel="stylesheet" href="assets/css/coursepages.css">
</head>
<body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
        <div class="loader-icon">
            <i class="fas fa-graduation-cap"></i>
        </div>
        <div class="loader-text">Loading Course Content...</div>
    </div>
    
    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>
    
    <!-- Music Player (fixed at top right) -->
    <div class="header-controls">
        <div class="music-dropdown" id="music-dropdown">
            <button class="btn btn-secondary">
                <span id="music-button-text">STUDY MUSIC</span>
                <i id="music-icon" class="fa-solid fa-music"></i>
            </button>
            <div class="music-dropdown-content" id="music-dropdown-content">
                <a href="#" data-src="https://www.learningcontainer.com/wp-content/uploads/2020/02/Kalimba.mp3">1. Coffee Shop Vibes</a>
                <a href="#" data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3">2. City Lights Lofi</a>
                <a href="#" data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-15.mp3">3. Mellow Thoughts</a>
                <a href="#" data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-13.mp3">4. Rainy Mood</a>
                <a href="#" data-src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3">5. Time Alone</a>
                <a href="#" id="stop-music-link"><i class="fa-solid fa-stop-circle"></i> Stop Music</a>
            </div>
        </div>
        
        <button class="btn btn-secondary" id="resetProgressBtn">
            <i class="fas fa-redo"></i>
            Reset Progress
        </button>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal" style="display: none">
        <div class="modal-overlay"></div>
        <div class="modal-content">
            <span class="close" id="closeAuthModal">&times;</span>
            <div class="auth-tabs">
                <button id="tabSignIn" class="auth-tab active">Sign In</button>
                <button id="tabSignUp" class="auth-tab">Sign Up</button>
            </div>
            <div id="authLoader" style="display: none; text-align: center; padding: 2rem">
                <i class="fas fa-spinner fa-spin fa-2x" style="color: var(--color-green)"></i>
                <p style="margin-top: 0.5rem">Authenticating...</p>
            </div>
            <div id="signInForm" class="auth-form">
                <h2>Sign In to CipherHall</h2>
                <button id="googleSignIn" class="btn btn-google">
                    <i class="fab fa-google"></i> Continue with Google
                </button>
                <div class="divider"><span>or</span></div>
                <form id="emailSignInForm">
                    <input type="email" id="signInEmail" placeholder="Email Address" required>
                    <input type="password" id="signInPassword" placeholder="Password" required>
                    <button type="submit" class="btn btn-primary">Sign In</button>
                </form>
            </div>
            <div id="signUpForm" class="auth-form" style="display: none">
                <h2>Join CipherHall</h2>
                <button id="googleSignUp" class="btn btn-google">
                    <i class="fab fa-google"></i> Continue with Google
                </button>
                <div class="divider"><span>or</span></div>
                <form id="emailSignUpForm">
                    <input type="text" id="signUpName" placeholder="Full Name" required>
                    <input type="email" id="signUpEmail" placeholder="Email Address" required>
                    <input type="password" id="signUpPassword" placeholder="Password (min. 8 characters)" required>
                    <button type="submit" class="btn btn-secondary">Create Account</button>
                </form>
            </div>
            <div id="authMessage"></div>
        </div>
    </div>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <div class="course-info">
                <h1 class="course-title" id="courseTitle">Loading...</h1>
                <div class="course-progress">
                    <div class="progress-header">
                        <span class="progress-label">Course Progress</span>
                        <span class="progress-percentage" id="courseProgressPercent">0%</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="courseProgressFill" style="width: 0%"></div>
                    </div>
                    <div class="progress-stats">
                        <span id="completedLessons">0</span>
                        <span id="totalLessons">0</span>
                    </div>
                </div>
                <a href="/dashboard.html" class="back-to-dashboard">
                    <i class="fas fa-arrow-left"></i>
                    Back to Dashboard
                </a>
            </div>
        </div>

        <nav class="lesson-nav" id="lessonNav">
            <!-- Lessons will be loaded dynamically -->
        </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
        <header class="content-header">
            <div class="lesson-header">
                <div class="lesson-header-left">
                    <span class="lesson-number" id="currentLessonNumber">1</span>
                    <h1 class="lesson-header-title" id="currentLessonTitle">Loading...</h1>
                </div>
                <div class="lesson-actions">
                    <button class="mbtn btn-primary" id="menuToggle">
                        <i class="fas fa-bars"></i>
                       
                    </button>
                </div>
            </div>
        </header>

        <div class="content-body" id="contentBody">
            <div class="lesson-content" id="lessonContent">
                <!-- Lesson content will be loaded dynamically -->
            </div>
        </div>

        <footer class="lesson-navigation">
            <div class="nav-info" id="navInfo">
                Lesson 1 of 10
            </div>
            <div class="nav-controls">
                <button class="btn btn-secondary" id="prevLessonBtn" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <button class="btn btn-primary" id="nextLessonBtn" disabled>
                    Next
                    <i class="fas fa-chevron-right"></i>
                </button>
            </div>
        </footer>
    </main>

    <!-- Achievement Notification -->
    <div id="achievementNotification" class="achievement-notification">
        <div class="notification-header">
            <div class="notification-icon" id="notificationIcon">
                <i class="fas fa-trophy"></i>
            </div>
            <div class="notification-content">
                <h3 id="notificationTitle">Achievement Unlocked!</h3>
                <p id="notificationDescription">Description here...</p>
            </div>
        </div>
        <div class="notification-reward" id="notificationReward">
            <i class="fas fa-coins"></i>
            <span id="notificationPoints">+100 Points</span>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast">
        <span id="toastMessage"></span>
    </div>

    <script>
       // =====================================================
// SYNCHRONIZED COURSE SYSTEM WITH DASHBOARD INTEGRATION
// =====================================================

// Supabase Configuration - Replace with your config
const supabaseUrl = 'https://lzcmzulemfubjaksoqor.supabase.co';
const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx6Y216dWxlbWZ1Ympha3NvcW9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzMzM5MDgsImV4cCI6MjA3MDkwOTkwOH0.crhPH4YWtRsr1BJTpAQcmPbWSpwIWRbzoI4sRb2_fPI';
const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

// =====================================================
// COURSE DATA STRUCTURE - REPLACE WITH YOUR COURSE JSON
// =====================================================
const COURSE_DATA =
{
  "id": "ssl-tls-basics",
  "title": "SSL/TLS Basics",
  "description": "A comprehensive, 20-lesson course on the principles of secure communication, digital certificates, and the TLS protocol.",
  "category": "networking-security",
  "difficulty": "Beginner to Intermediate",
  "duration": "40 hours",
  "instructor": "Dr. Evelyn Reed",
  "lessons": [
    {
      "id": "lesson-1",
      "title": "Introduction to Secure Communication",
      "duration": "90 min",
      "objectives": [
        "Understand the difference between HTTP and HTTPS",
        "Recognize the need for encryption in modern communication",
        "Define the roles of SSL and TLS",
        "Analyze network traffic to identify secure vs. insecure connections"
      ],
      "content": {
        "overview": "This foundational lesson explores why secure communication is essential in today's digital world. We will compare the insecure nature of HTTP with the encrypted security of HTTPS, laying the groundwork for understanding the critical role of SSL/TLS protocols. [22, 24, 30]",
        "sections": [
          {
            "title": "The Dangers of Plaintext: HTTP",
            "content": "<p>Hypertext Transfer Protocol (HTTP) is the foundation of data communication for the World Wide Web. However, it is a plaintext protocol. This means any data sent over HTTP—passwords, credit card numbers, personal messages—is transmitted as clear, readable text. Anyone positioned between your computer and the server (like someone on the same Wi-Fi network) can intercept and read this information. This vulnerability leads to significant security risks, including eavesdropping, data theft, and session hijacking.</p><h3>Key Risks of HTTP:</h3><ul><li><strong>Eavesdropping:</strong> Attackers can easily 'listen in' on the data being exchanged.</li><li><strong>Man-in-the-Middle (MITM) Attacks:</strong> An attacker can intercept, read, and even modify the communication between you and the website without either party knowing.</li><li><strong>No Data Integrity:</strong> There is no guarantee that the data you receive is what the server originally sent. It could have been altered in transit.</li></ul>",
            "image": "https://images.unsplash.com/photo-1593495147558-c1143a5390a8?w=800&h=400&fit=crop"
          },
          {
            "title": "Introducing Security: HTTPS",
            "content": "<p>HTTPS (HTTP Secure) is the solution to HTTP's security flaws. [30] When you see a padlock icon in your browser's address bar, you're using HTTPS. [22] It is essentially the same HTTP protocol but with a crucial addition: a security layer provided by SSL (Secure Sockets Layer) or its modern successor, TLS (Transport Layer Security). This layer encrypts the data, ensuring that even if it's intercepted, it remains a scrambled, unreadable mess to anyone without the correct decryption key.</p><h3>The Three Pillars of HTTPS Security:</h3><ol><li><strong>Encryption:</strong> Keeps your data private and confidential as it travels across the internet. [24]</li><li><strong>Integrity:</strong> Ensures that the data has not been tampered with or corrupted during transmission. [24]</li><li><strong>Authentication:</strong> Verifies that you are communicating with the legitimate, intended website and not an imposter. [24]</li></ol><div class=\"info-box note\"><div class=\"info-box-header\"><i class=\"fas fa-info-circle\"></i><strong>Note</strong></div><p>While often used interchangeably, SSL is the predecessor to TLS. Modern secure connections almost exclusively use TLS, although the term 'SSL certificate' remains common. [24]</p></div>",
            "image": "https://images.unsplash.com/photo-1555949963-aa79dcee981c?w=800&h=400&fit=crop"
          }
        ],
        "codeExamples": [
          {
            "title": "Lab: Capturing HTTP vs. HTTPS Traffic in Wireshark",
            "language": "bash",
            "code": "# Step 1: Install Wireshark on your system.\n# (On Debian/Ubuntu: sudo apt-get update && sudo apt-get install wireshark)\n\n# Step 2: Launch Wireshark and start capturing on your main network interface (e.g., eth0 or wlan0).\n\n# Step 3: Capture HTTP traffic.\n# In the Wireshark filter bar, type 'http'.\n# In your browser, visit a site that uses HTTP (e.g., http://neverssl.com).\n# Observe the Wireshark capture. You will see packets with the HTTP protocol. Right-click one, and select 'Follow > TCP Stream'. You'll see the full request and response in clear, readable text.\n\n# Step 4: Capture HTTPS traffic.\n# Clear the filter. In a new browser tab, visit a secure site (e.g., https://google.com).\n# In the Wireshark filter bar, type 'tls'.\n# You will see TLS handshake packets followed by 'Application Data' packets. Right-click an 'Application Data' packet and select 'Follow > TCP Stream'. The content will be encrypted and unreadable.\n\n# This lab demonstrates visually that HTTP is sent in the clear, while HTTPS traffic is encrypted and protected."
          }
        ]
      },
      "quiz": {
        "passingScore": 75,
        "questions": [
          {
            "id": 1,
            "question": "What is the primary risk of using the HTTP protocol?",
            "options": [
              "It is too slow for modern websites.",
              "Data is sent in plaintext and can be easily intercepted.",
              "It is not compatible with modern browsers.",
              "It consumes too much bandwidth."
            ],
            "correct": 1,
            "explanation": "HTTP sends all data as clear, readable text, making it vulnerable to eavesdropping and man-in-the-middle attacks."
          },
          {
            "id": 2,
            "question": "What does the 'S' in HTTPS stand for?",
            "options": [
              "Standard",
              "Simple",
              "Secure",
              "Server"
            ],
            "correct": 2,
            "explanation": "The 'S' stands for Secure, indicating that the connection is encrypted using SSL/TLS. [22]"
          },
          {
            "id": 3,
            "question": "Which of the following is NOT a core security guarantee of HTTPS?",
            "options": [
              "Encryption",
              "Authentication",
              "Anonymity",
              "Integrity"
            ],
            "correct": 2,
            "explanation": "While HTTPS encrypts your data, it does not make your connection anonymous. Your IP address is still visible. Authentication, Encryption, and Integrity are the three pillars of TLS. [24]"
          },
          {
            "id": 4,
            "question": "In Wireshark, what protocol name would you filter for to see encrypted web traffic?",
            "options": [
              "HTTP",
              "TCP",
              "TLS",
              "HTML"
            ],
            "correct": 2,
            "explanation": "TLS (Transport Layer Security) is the protocol that provides encryption for HTTPS, so you would filter by 'tls' to observe the encrypted session packets."
          }
        ]
      }
    },
    {
      "id": "lesson-2",
      "title": "SSL vs. TLS",
      "duration": "60 min",
      "objectives": [
        "Trace the history and evolution from SSL to TLS",
        "Understand the key differences between SSL and TLS versions",
        "Compare the security features of TLS 1.2 and TLS 1.3",
        "Recognize deprecated and insecure protocols"
      ],
      "content": {
        "overview": "Delve into the history and technical evolution from the original SSL protocols to the modern TLS standards. This lesson will clarify the distinction between the two, highlight the security enhancements in each version, and explain why using the latest protocols like TLS 1.3 is critical. [22]",
        "sections": [
          {
            "title": "A Brief History: From SSL to TLS",
            "content": "<p>Secure Sockets Layer (SSL) was the original cryptographic protocol developed by Netscape in the mid-1990s to secure internet communications. SSL 1.0 was never publicly released due to security flaws. SSL 2.0 and 3.0 were subsequently released but were also found to have significant vulnerabilities over time.</p><p>Transport Layer Security (TLS) was introduced as the successor to SSL in 1999. It was developed by the Internet Engineering Task Force (IETF) and is based on the SSL 3.0 specification but with significant improvements to security. For this reason, you can think of TLS 1.0 as SSL 3.1. All versions of SSL are now considered insecure and have been deprecated.</p><h3>Key Milestones:</h3><ul><li><strong>SSL 2.0 (1995):</strong> Released with several flaws, quickly deprecated.</li><li><strong>SSL 3.0 (1996):</strong> An improvement, but later found vulnerable to attacks like POODLE.</li><li><strong>TLS 1.0 (1999):</strong> The first version of the new standard. Deprecated in 2021.</li><li><strong>TLS 1.1 (2006):</strong> Minor improvements. Deprecated in 2021.</li><li><strong>TLS 1.2 (2008):</strong> A major leap in security, introducing modern ciphers. It remains widely used and secure.</li><li><strong>TLS 1.3 (2018):</strong> The current standard, offering a faster handshake and improved security by removing obsolete features.</li></ul>",
            "image": "https://images.unsplash.com/photo-1526374965328-5f61d25c0e40?w=800&h=400&fit=crop"
          },
          {
            "title": "Key Differences: TLS 1.2 vs. TLS 1.3",
            "content": "<p>While TLS 1.2 is still a secure and widely adopted protocol, TLS 1.3 represents a significant evolution, focusing on both speed and security. It streamlines the connection process and removes legacy, vulnerable options.</p><h3>Major Improvements in TLS 1.3:</h3><ul><li><strong>Faster Handshake:</strong> TLS 1.3 reduces the number of round-trips needed to establish a secure connection from two to one (and zero for resumed sessions). This results in lower latency and faster page load times.</li><li><strong>Mandatory Perfect Forward Secrecy (PFS):</strong> PFS ensures that even if a server's long-term private key is compromised, past session keys cannot be calculated, and past conversations remain secure. While possible in TLS 1.2, it's mandatory in 1.3.</li><li><strong>Simplified Cipher Suites:</strong> TLS 1.3 removes older, less secure cryptographic algorithms (like RSA key exchange, CBC mode ciphers, SHA-1, MD5). It mandates the use of modern Authenticated Encryption with Associated Data (AEAD) ciphers like AES-GCM and ChaCha20-Poly1305.</li><li><strong>Encrypted Handshake Messages:</strong> More of the initial handshake process is encrypted in TLS 1.3, providing greater privacy and protection against traffic analysis.</li></ul><div class=\"info-box warning\"><div class=\"info-box-header\"><i class=\"fas fa-exclamation-triangle\"></i><strong>Warning</strong></div><p>All versions of SSL (2.0, 3.0) and early TLS (1.0, 1.1) are deprecated and must not be used. Enabling them on a modern server is a serious security misconfiguration.</p></div>",
            "image": "https://images.unsplash.com/photo-1599507578794-279213135e13?w=800&h=400&fit=crop"
          }
        ],
        "codeExamples": [
          {
            "title": "Lab: Test Protocol Support with openssl s_client",
            "language": "bash",
            "code": "# The openssl s_client command is a powerful tool to test a server's TLS configuration. [1]\n\n# Step 1: Test for TLS 1.2 support\n# The -tls1_2 flag forces the client to offer only TLS 1.2.\n# A successful connection will show the server's certificate and handshake details. [15, 37]\nopenssl s_client -connect google.com:443 -tls1_2\n\n# Step 2: Test for TLS 1.3 support\n# Similarly, the -tls1_3 flag tests for the latest standard. [37, 43]\nopenssl s_client -connect google.com:443 -tls1_3\n\n# Step 3: Test for outdated SSLv3 support (this should fail on a secure server)\n# A secure server will reject the connection, resulting in a 'handshake failure'.\nopenssl s_client -connect google.com:443 -ssl3\n\n# By observing the output, you can determine which protocols a server supports. \n# A modern, secure server should support TLS 1.2 and TLS 1.3, and reject older protocols."
          }
        ]
      },
      "quiz": {
        "passingScore": 75,
        "questions": [
          {
            "id": 1,
            "question": "Which protocol is the direct, modern successor to SSL?",
            "options": [
              "HTTP",
              "SSH",
              "TLS",
              "IPSec"
            ],
            "correct": 2,
            "explanation": "Transport Layer Security (TLS) was developed by the IETF as the secure and standardized successor to SSL. [22]"
          },
          {
            "id": 2,
            "question": "Which of these protocols is considered secure for modern use?",
            "options": [
              "SSL 3.0",
              "TLS 1.0",
              "TLS 1.1",
              "TLS 1.2"
            ],
            "correct": 3,
            "explanation": "TLS 1.2 and TLS 1.3 are the current secure standards. All versions of SSL, as well as TLS 1.0 and 1.1, are deprecated due to known vulnerabilities."
          },
          {
            "id": 3,
            "question": "What is a major advantage of TLS 1.3 over TLS 1.2?",
            "options": [
              "It is compatible with older browsers.",
              "It uses MD5 for hashing.",
              "It has a faster handshake process.",
              "It supports SSL 2.0 interoperability."
            ],
            "correct": 2,
            "explanation": "TLS 1.3 reduces the number of round trips required for the handshake from two to one, significantly improving connection speed and latency."
          },
          {
            "id": 4,
            "question": "What `openssl s_client` flag would you use to specifically test for TLS 1.2 support?",
            "options": [
              "-tls1_2",
              "-version 1.2",
              "-test TLSv1.2",
              "-ssl_version 2"
            ],
            "correct": 0,
            "explanation": "The `-tls1_2` flag instructs the openssl s_client tool to attempt a connection using only the TLS 1.2 protocol. [15]"
          }
        ]
      }
    },
    {
      "id": "lesson-3",
      "title": "TLS Handshake Process",
      "duration": "75 min",
      "objectives": [
        "Understand the purpose of the TLS handshake",
        "List the main steps of a TLS 1.2 handshake",
        "Identify the key messages: ClientHello, ServerHello, and Certificate",
        "Explain the concept of key exchange to create a symmetric session key"
      ],
      "content": {
        "overview": "The TLS handshake is a fundamental process where the client and server establish a secure connection before any application data is exchanged. This lesson breaks down the sequence of messages, from negotiating cipher suites to authenticating the server and generating a shared secret key. [22]",
        "sections": [
          {
            "title": "The Purpose of the Handshake",
            "content": "<p>Before a client and server can exchange encrypted information, they must perform a TLS handshake. This is an initial negotiation that establishes the parameters of their secure session. [22] Think of it as a secure greeting and secret password exchange before the main conversation begins.</p><h3>The primary goals of the handshake are:</h3><ul><li><strong>Protocol Negotiation:</strong> To agree on the version of TLS (e.g., 1.2 or 1.3) and the specific set of cryptographic algorithms (the cipher suite) they will use.</li><li><strong>Server Authentication:</strong> For the client to verify the identity of the server using its public key certificate.</li><li><strong>Key Exchange:</strong> To securely generate and share a symmetric session key that will be used to encrypt all application data for the remainder of the session.</li></ul>",
            "image": "https://images.unsplash.com/photo-1544197150-b2c4c47b0a34?w=800&h=400&fit=crop"
          },
          {
            "title": "Steps of the TLS 1.2 Handshake",
            "content": "<p>The TLS 1.2 handshake involves a sequence of messages exchanged between the client (your browser) and the server.</p><ol><li><strong>ClientHello:</strong> The client initiates the handshake by sending a `ClientHello` message. This message includes the TLS versions the client supports, a list of cipher suites it can use, and a random string of bytes known as the 'Client Random'.</li><li><strong>ServerHello:</strong> The server responds with a `ServerHello` message. It chooses a TLS version and a cipher suite from the lists provided by the client. It also includes its own random string of bytes, the 'Server Random'.</li><li><strong>Certificate:</strong> The server sends its SSL/TLS certificate to the client. The certificate contains the server's public key and is signed by a trusted Certificate Authority (CA), allowing the client to verify the server's identity.</li><li><strong>ServerKeyExchange (optional) & ServerHelloDone:</strong> Depending on the key exchange algorithm chosen, the server may send additional information. It concludes with a `ServerHelloDone` message.</li><li><strong>ClientKeyExchange:</strong> The client generates a 'pre-master secret' and encrypts it using the server's public key (from the certificate). It sends this encrypted value to the server. Only the server, with its private key, can decrypt it.</li><li><strong>ChangeCipherSpec & Finished:</strong> The client uses the Client Random, Server Random, and pre-master secret to calculate the symmetric session key. It sends a `ChangeCipherSpec` message to indicate it will start encrypting, followed by an encrypted `Finished` message.</li><li><strong>ChangeCipherSpec & Finished:</strong> The server decrypts the pre-master secret, calculates the same session key, and sends its own `ChangeCipherSpec` and encrypted `Finished` messages.</li></ol><p>At this point, the handshake is complete, and both parties can securely exchange encrypted application data using the shared session key.</p>",
            "image": "https://images.unsplash.com/photo-1584988228221-82dd9848521a?w=800&h=400&fit=crop"
          }
        ],
        "codeExamples": [
          {
            "title": "Lab: Capture and Analyze a TLS Handshake in Wireshark",
            "language": "bash",
            "code": "# This lab requires Wireshark.\n\n# Step 1: Launch Wireshark and start capturing traffic on your network interface.\n\n# Step 2: In your web browser, navigate to any HTTPS-enabled website (e.g., https://www.openssl.org).\n\n# Step 3: Stop the Wireshark capture. In the filter bar, type 'tls.handshake' and press Enter. This will isolate the handshake packets from the rest of the traffic.\n\n# Step 4: Examine the packets in sequence.\n# - Look for the 'Client Hello' packet. Click on it and expand the 'Transport Layer Security' section in the packet details pane below. You can inspect the list of cipher suites offered by your browser.\n# - Find the 'Server Hello' packet. Inspect the 'Cipher Suite' field to see which one the server selected.\n# - Locate the 'Certificate' packet. You can see the server's certificate being sent to your client for verification.\n# - Observe the 'Client Key Exchange' and 'Change Cipher Spec' packets as the negotiation concludes.\n\n# This provides a real-world view of the handshake messages being exchanged to establish a secure session."
          }
        ]
      },
      "quiz": {
        "passingScore": 75,
        "questions": [
          {
            "id": 1,
            "question": "Which message begins the TLS handshake process?",
            "options": [
              "ServerHello",
              "ClientHello",
              "Certificate",
              "Finished"
            ],
            "correct": 1,
            "explanation": "The client always initiates the connection by sending a ClientHello message to the server."
          },
          {
            "id": 2,
            "question": "What is the primary purpose of the 'Certificate' message from the server?",
            "options": [
              "To choose a cipher suite",
              "To encrypt all the data",
              "To allow the client to authenticate the server's identity",
              "To provide a random number"
            ],
            "correct": 2,
            "explanation": "The server sends its certificate so the client can verify its identity against a trusted Certificate Authority and obtain the server's public key."
          },
          {
            "id": 3,
            "question": "What is the final outcome of a successful key exchange?",
            "options": [
              "A shared symmetric session key",
              "A public key for the client",
              "A list of supported protocols",
              "An unencrypted channel"
            ],
            "correct": 0,
            "explanation": "The entire key exchange process is designed for the client and server to independently arrive at the exact same symmetric session key, which is then used for encrypting application data."
          },
          {
            "id": 4,
            "question": "In a TLS handshake, what is a 'cipher suite'?",
            "options": [
              "A brand of security software",
              "A collection of website encryption settings",
              "A set of cryptographic algorithms for key exchange, authentication, and encryption",
              "The server's SSL certificate"
            ],
            "correct": 2,
            "explanation": "A cipher suite is a named combination of algorithms used to negotiate security settings, including the key exchange algorithm, bulk encryption cipher, and message authentication code."
          }
        ]
      }
    },
    {
      "id": "lesson-4",
      "title": "Certificates and Trust",
      "duration": "75 min",
      "objectives": [
        "Understand the structure and purpose of X.509 certificates",
        "Identify key fields within a certificate, such as issuer and subject",
        "Explain the role of Certificate Authorities (CAs) in establishing trust",
        "Recognize the importance of certificate validity periods and expiration"
      ],
      "content": {
        "overview": "Digital certificates are the cornerstone of trust on the internet. This lesson explores the X.509 certificate standard, explaining how these digital documents bind an identity to a public key. We will cover the vital role of Certificate Authorities (CAs) as trusted third parties and why certificate expiration is a critical security feature.",
        "sections": [
          {
            "title": "What is an X.509 Certificate?",
            "content": "<p>An X.509 certificate is a standardized digital document used in TLS/SSL to verify the identity of a public key's owner. Think of it as a digital passport. It contains information about the subject (the owner), the subject's public key, and is digitally signed by a trusted third party, known as a Certificate Authority (CA).</p><h3>Key Fields in an X.509 Certificate:</h3><ul><li><strong>Version:</strong> The version of the X.509 standard used.</li><li><strong>Serial Number:</strong> A unique number assigned to the certificate by the CA.</li><li><strong>Signature Algorithm:</strong> The algorithm used by the CA to sign the certificate.</li><li><strong>Issuer:</strong> The name of the Certificate Authority that issued the certificate.</li><li><strong>Validity Period:</strong> The start and end dates for which the certificate is valid ('Not Before' and 'Not After').</li><li><strong>Subject:</strong> The identity of the certificate owner (e.g., a domain name like `www.google.com`).</li><li><strong>Subject Public Key Info:</strong> The public key of the subject, along with the algorithm used to create it.</li><li><strong>Issuer's Digital Signature:</strong> The signature of the issuer, which confirms the authenticity of the certificate's contents.</li></ul>",
            "image": "https://images.unsplash.com/photo-1585224322384-0613531b78b0?w=800&h=400&fit=crop"
          },
          {
            "title": "The Role of Certificate Authorities (CAs) and the Chain of Trust",
            "content": "<p>How does your browser know whether to trust a certificate presented by a website? It's because the certificate is signed by a Certificate Authority (CA) that your browser and operating system already trust. CAs like Let's Encrypt, DigiCert, and GlobalSign are entities that verify the identity of organizations and issue certificates to them.</p><p>This system works on a 'Chain of Trust'. Your computer has a list of pre-installed 'Root CA' certificates. When a server presents its certificate, your browser checks the issuer's signature. If that issuer is an 'Intermediate CA', the browser then checks the certificate of the Intermediate CA, and so on, until it reaches a Root CA that is in its trusted list. This chain ensures that every certificate can be traced back to a trusted source. [35, 41]</p><h3>Certificate Expiration:</h3><p>Certificates are not valid forever. The 'Validity Period' field defines their lifespan. Certificate expiration is a crucial security mechanism. It ensures that cryptographic keys are rotated regularly and helps mitigate the risk of a compromised key being used indefinitely. It also ensures that the information about the certificate owner is periodically re-validated.</p>",
            "image": "https://images.unsplash.com/photo-1550645612-82f5d2d0b642?w=800&h=400&fit=crop"
          }
        ],
        "codeExamples": [
          {
            "title": "Lab: View Certificate in a Browser and Decode with OpenSSL",
            "language": "bash",
            "code": "# Part 1: View Certificate in Your Browser\n# 1. Navigate to any HTTPS site (e.g., https://www.google.com).\n# 2. Click the padlock icon in the address bar.\n# 3. Select 'Connection is secure' and then 'Certificate is valid'.\n# 4. A window will pop up. Explore the 'Details' and 'Certification Path' tabs. You can see the fields discussed (Subject, Issuer, Validity) and view the chain of trust.\n\n# Part 2: Fetch and Decode a Certificate with OpenSSL\n\n# First, connect to the server and save its certificate to a file.\n# The 'openssl s_client' command can do this. The '-showcerts' flag displays the whole chain. [48]\n# We pipe the output to 'openssl x509' to format it.\n\nopenssl s_client -connect www.google.com:443 -servername www.google.com < /dev/null | openssl x509 -outform PEM > google_cert.pem\n\n# Now, decode the saved certificate file and view its contents in a human-readable format.\nopenssl x509 -in google_cert.pem -text -noout\n\n# This command will display all the fields of the X.509 certificate, allowing you to inspect them from the command line."
          }
        ]
      },
      "quiz": {
        "passingScore": 75,
        "questions": [
          {
            "id": 1,
            "question": "What is the primary function of an X.509 certificate?",
            "options": [
              "To encrypt website data directly",
              "To bind a public key to a specific identity",
              "To replace the need for a firewall",
              "To assign an IP address to a server"
            ],
            "correct": 1,
            "explanation": "An X.509 certificate's main purpose is to attest that a specific public key belongs to a specific entity (the 'Subject'), as verified by an 'Issuer' (the CA)."
          },
          {
            "id": 2,
            "question": "Who signs a server's certificate to make it trustworthy?",
            "options": [
              "The server's administrator",
              "A Certificate Authority (CA)",
              "The user's browser",
              "The Internet Service Provider (ISP)"
            ],
            "correct": 1,
            "explanation": "A trusted third-party Certificate Authority (CA) verifies the identity of the certificate requester and then digitally signs the certificate to vouch for its authenticity."
          },
          {
            "id": 3,
            "question": "Which field in a certificate specifies its valid lifespan?",
            "options": [
              "Serial Number",
              "Subject",
              "Issuer",
              "Validity Period"
            ],
            "correct": 3,
            "explanation": "The 'Validity Period' contains the 'Not Before' and 'Not After' dates, which define the timeframe during which the certificate is considered valid."
          },
          {
            "id": 4,
            "question": "What is meant by the 'Chain of Trust'?",
            "options": [
              "A list of secure passwords",
              "A verifiable path from a server's certificate back to a trusted Root CA",
              "An encrypted chat protocol",
              "A sequence of handshake messages"
            ],
            "correct": 1,
            "explanation": "The Chain of Trust refers to the hierarchy of certificates (End-entity -> Intermediate(s) -> Root) that allows a browser to verify an unknown server certificate by tracing it back to a pre-trusted root certificate. [35]"
          }
        ]
      }
    },
    {
      "id": "lesson-5",
      "title": "Public & Private Keys in TLS",
      "duration": "75 min",
      "objectives": [
        "Understand the principles of asymmetric cryptography",
        "Explain the role of public and private keys in the TLS handshake",
        "Describe how RSA and ECC are used for authentication and key exchange",
        "Generate a key pair and a self-signed certificate using OpenSSL"
      ],
      "content": {
        "overview": "Asymmetric cryptography, with its use of public and private key pairs, is the magic behind the initial stages of a TLS session. This lesson covers how these keys are used to authenticate the server and to securely establish a shared secret, setting the stage for fast, symmetric encryption.",
        "sections": [
          {
            "title": "The Fundamentals of Asymmetric Cryptography",
            "content": "<p>Asymmetric cryptography (or public-key cryptography) uses a pair of mathematically related keys: a <strong>public key</strong> and a <strong>private key</strong>. The public key can be shared freely, while the private key must be kept secret by its owner.</p><h3>The core principles are:</h3><ul><li>Data encrypted with the public key can <strong>only</strong> be decrypted by the corresponding private key.</li><li>A digital signature created with a private key can be <strong>verified</strong> by anyone who has the public key.</li></ul><p>This dual-functionality is what makes it so powerful for secure communication. It allows for both confidentiality (encryption) and authenticity (digital signatures).</p>",
            "image": "https://images.unsplash.com/photo-1526374965328-5f61d25c0e40?w=800&h=400&fit=crop"
          },
          {
            "title": "How TLS Uses Asymmetric Keys",
            "content": "<p>During the TLS handshake, asymmetric cryptography is used for two critical functions: authenticating the server and securely exchanging the session key.</p><h3>1. Authentication (via Digital Signatures):</h3><p>The server's certificate, which contains its public key, is signed by a Certificate Authority's private key. Your browser uses the CA's public key (which it already trusts) to verify this signature. This proves that the certificate is authentic and has not been tampered with. The server proves it possesses the corresponding private key by performing an operation during the handshake that can only be done with that key.</p><h3>2. Key Exchange:</h3><p>The goal is to create a shared secret (a symmetric session key) that both the client and server can use for fast encryption. This can be done in two main ways:</p><ul><li><strong>RSA Key Exchange (Legacy):</strong> The client generates a random secret (the pre-master secret), encrypts it with the server's public key from its certificate, and sends it to the server. Only the server, with its private key, can decrypt it. Both sides then use this shared secret to derive the actual session key. This method is no longer recommended because it does not provide Perfect Forward Secrecy.</li><li><strong>Elliptic Curve Diffie-Hellman (ECDHE):</strong> This is the modern standard. Both the client and server generate temporary, single-use key pairs and exchange their public parts. Through some clever mathematics, both sides can independently calculate the same shared secret without ever transmitting it over the wire. This method provides Perfect Forward Secrecy.</li></ul><div class=\"info-box tip\"><div class=\"info-box-header\"><i class=\"fas fa-lightbulb\"></i><strong>Perfect Forward Secrecy</strong></div><p>Forward secrecy ensures that if the server's long-term private key is ever compromised, past communications cannot be decrypted. Because ECDHE generates ephemeral (temporary) keys for each session, compromising the server's main key does not reveal past session keys.</p></div>",
            "image": "https://images.unsplash.com/photo-1631853609341-f58428549301?w=800&h=400&fit=crop"
          }
        ],
        "codeExamples": [
          {
            "title": "Lab: Generate a Key Pair and a Self-Signed Certificate",
            "language": "bash",
            "code": "# A self-signed certificate is one that is signed with its own private key, rather than by a trusted CA. \n# It is useful for testing and development but should not be used in production. [3]\n\n# This single OpenSSL command generates a new private key and a corresponding self-signed certificate.\n\n# openssl req: The command for certificate requests and generation.\n# -x509: Specifies to create a self-signed certificate instead of a CSR. [11]\n# -newkey rsa:2048: Generates a new 2048-bit RSA private key. [5]\n# -nodes: 'No DES', means don't encrypt the private key with a passphrase.\n# -keyout server.key: Specifies the filename for the new private key.\n# -out server.crt: Specifies the filename for the new certificate.\n# -days 365: Sets the validity period to 365 days.\n\nopenssl req -x509 -newkey rsa:2048 -nodes -keyout server.key -out server.crt -days 365\n\n# You will be prompted to fill in certificate details like Country, Organization, and Common Name.\n# For the 'Common Name', use 'localhost' or the server name you intend to use for testing. [5]\n\n# After running the command, you will have two files:\n# - server.key: Your new private key. KEEP THIS SECRET.\n# - server.crt: Your self-signed public certificate."
          }
        ]
      },
      "quiz": {
        "passingScore": 75,
        "questions": [
          {
            "id": 1,
            "question": "In asymmetric cryptography, which key should be kept secret?",
            "options": [
              "Public Key",
              "Session Key",
              "Private Key",
              "Shared Key"
            ],
            "correct": 2,
            "explanation": "The private key must always be kept secret by its owner, as it is used to decrypt data and create digital signatures."
          },
          {
            "id": 2,
            "question": "Data encrypted with a public key can only be decrypted by...",
            "options": [
              "any other public key.",
              "the same public key.",
              "the corresponding private key.",
              "a symmetric key."
            ],
            "correct": 2,
            "explanation": "This is the fundamental principle of asymmetric encryption. The public key locks the data, and only the matching private key can unlock it."
          },
          {
            "id": 3,
            "question": "What is the primary role of the server's private key during the TLS handshake?",
            "options": [
              "To encrypt the data sent to the client.",
              "To prove its identity and/or decrypt the pre-master secret (in RSA key exchange).",
              "To sign the client's certificate.",
              "To be shared with the client for faster encryption."
            ],
            "correct": 1,
            "explanation": "The server uses its private key to perform an operation (like decrypting a key exchange message) that proves it owns the certificate, thus authenticating itself."
          },
          {
            "id": 4,
            "question": "What is the main security advantage of using a Diffie-Hellman (DHE/ECDHE) key exchange?",
            "options": [
              "It is faster than RSA.",
              "It is easier to implement.",
              "It provides Perfect Forward Secrecy.",
              "It uses a smaller key size."
            ],
            "correct": 2,
            "explanation": "Diffie-Hellman Ephemeral (DHE/ECDHE) key exchanges generate temporary keys for each session, meaning that even if the server's main private key is compromised, past encrypted sessions cannot be deciphered."
          }
        ]
      }
    },
    {
      "id": "lesson-6",
      "title": "Symmetric Encryption in TLS",
      "duration": "60 min",
      "objectives": [
        "Understand the role and advantages of symmetric encryption",
        "Explain why TLS uses a hybrid encryption system",
        "Identify modern symmetric ciphers like AES-GCM and ChaCha20",
        "Understand the concept of Authenticated Encryption with Associated Data (AEAD)"
      ],
      "content": {
        "overview": "Once the TLS handshake is complete, the heavy lifting of encryption is handed over to symmetric algorithms. This lesson explains why this switch occurs, introducing the fast and secure symmetric ciphers used in modern TLS sessions, such as AES-GCM, and the importance of authenticated encryption.",
        "sections": [
          {
            "title": "Why Symmetric Encryption?",
            "content": "<p>Symmetric encryption, also known as shared key encryption, uses a single key for both encrypting and decrypting data. Unlike asymmetric encryption, which is computationally intensive and relatively slow, symmetric encryption is extremely fast and efficient. This makes it ideal for encrypting the large amounts of data that are exchanged during a web session after the initial handshake.</p><h3>The Hybrid Approach of TLS:</h3><p>TLS uses a clever hybrid encryption system that leverages the strengths of both asymmetric and symmetric cryptography:</p><ol><li><strong>Asymmetric Cryptography (Handshake):</strong> Used at the beginning to authenticate the server and securely exchange a shared secret (the session key). It's secure but slow.</li><li><strong>Symmetric Cryptography (Application Data):</strong> The shared session key generated during the handshake is then used with a fast symmetric cipher to encrypt all the actual application data (the content of the website). It's fast and secure for bulk data.</li></ol><p>This hybrid model provides the best of both worlds: the secure key exchange of asymmetric cryptography and the high performance of symmetric cryptography.</p>",
            "image": "https://images.unsplash.com/photo-1550751827-463d1a88439e?w=800&h=400&fit=crop"
          },
          {
            "title": "Modern Ciphers: AES-GCM and ChaCha20",
            "content": "<p>Modern TLS versions, especially TLS 1.3, have deprecated older, weaker ciphers and now rely on a small set of highly secure and efficient algorithms. These are known as Authenticated Encryption with Associated Data (AEAD) ciphers.</p><p>An <strong>AEAD cipher</strong> is a type of symmetric algorithm that simultaneously provides both confidentiality (encryption) and integrity/authenticity (a message authentication code). This is crucial because it not only hides the data but also prevents it from being secretly modified in transit.</p><h3>The Two Dominant AEAD Ciphers in TLS:</h3><ul><li><strong>AES-GCM (Advanced Encryption Standard - Galois/Counter Mode):</strong> AES is the world standard for symmetric encryption. When combined with GCM, it becomes a high-performance AEAD cipher. Most modern computers have hardware acceleration for AES, making it incredibly fast.</li><li><strong>ChaCha20-Poly1305:</strong> This is a newer cipher that offers excellent security and performance, especially on devices that lack dedicated hardware acceleration for AES (like some mobile phones and older IoT devices). It provides a strong alternative to ensure high performance across all platforms.</li></ul><p>By restricting the cipher choices to these robust AEAD algorithms, TLS 1.3 simplifies the protocol and significantly enhances its baseline security.</p>",
            "image": "https://images.unsplash.com/photo-1516110833953-7a916730302b?w=800&h=400&fit=crop"
          }
        ],
        "codeExamples": [
          {
            "title": "Lab: Force TLS to Use a Specific Cipher with OpenSSL",
            "language": "bash",
            "code": "# You can use openssl s_client to request that the server use a specific cipher suite. \n# This is useful for testing if a server supports a particular cipher.\n\n# Note: TLS 1.3 uses a different syntax (-ciphersuites) than TLS 1.2 (-cipher).\n\n# Test a connection to a server, offering only the AES-GCM cipher suite for TLS 1.2\n# This command will likely succeed on any modern server.\nopenssl s_client -connect www.google.com:443 -tls1_2 -cipher 'ECDHE-ECDSA-AES128-GCM-SHA256'\n\n# Now, test for a TLS 1.3 cipher suite (e.g., TLS_AES_256_GCM_SHA384)\n# Note the different flag and cipher naming convention for TLS 1.3\nopenssl s_client -connect www.google.com:443 -tls1_3 -ciphersuites 'TLS_AES_256_GCM_SHA384'\n\n# Finally, try to force an old, insecure cipher (this command should fail on a properly configured server).\n# For example, attempting to use a legacy DES cipher should result in a handshake failure.\nopenssl s_client -connect www.google.com:443 -tls1_2 -cipher 'DES-CBC3-SHA'\n\n# Look for the 'Cipher is' or 'Cipher    :' line in the successful connection output to see which cipher was negotiated."
          }
        ]
      },
      "quiz": {
        "passingScore": 75,
        "questions": [
          {
            "id": 1,
            "question": "Why does TLS switch from asymmetric to symmetric encryption after the handshake?",
            "options": [
              "Symmetric encryption is more secure for authentication.",
              "Asymmetric encryption cannot be used for websites.",
              "Symmetric encryption is significantly faster for encrypting large amounts of data.",
              "Browsers do not support asymmetric encryption."
            ],
            "correct": 2,
            "explanation": "Asymmetric cryptography is too slow for bulk data encryption. TLS uses it only for the initial, secure exchange of a symmetric session key, then uses the much faster symmetric key for the rest of the session."
          },
          {
            "id": 2,
            "question": "What is the key characteristic of an AEAD (Authenticated Encryption with Associated Data) cipher?",
            "options": [
              "It uses two different keys for encryption and decryption.",
              "It only provides data integrity but not confidentiality.",
              "It provides both confidentiality (encryption) and authenticity (integrity check) in one operation.",
              "It is an old cipher type deprecated in TLS 1.3."
            ],
            "correct": 2,
            "explanation": "AEAD ciphers are modern algorithms that combine encryption and message authentication, protecting against both eavesdropping and tampering simultaneously."
          },
          {
            "id": 3,
            "question": "Which of the following is a modern, widely used AEAD cipher in TLS?",
            "options": [
              "RC4",
              "Triple DES (3DES)",
              "AES-GCM",
              "MD5"
            ],
            "correct": 2,
            "explanation": "AES-GCM (Advanced Encryption Standard - Galois/Counter Mode) is a high-performance, secure AEAD cipher that is a cornerstone of modern TLS deployments."
          },
          {
            "id": 4,
            "question": "What is the primary benefit of the ChaCha20-Poly1305 cipher?",
            "options": [
              "It is the only cipher supported in TLS 1.3.",
              "It offers strong security and high performance on devices without hardware AES acceleration.",
              "It uses a very large key size for ultimate security.",
              "It is designed for encrypting only small amounts of data."
            ],
            "correct": 1,
            "explanation": "ChaCha20-Poly1305 provides an excellent software-based alternative to AES, ensuring that mobile and embedded systems can also perform high-speed, secure encryption without specialized hardware."
          }
        ]
      }
    },
    {
      "id": "lesson-7",
      "title": "TLS Record Protocol",
      "duration": "60 min",
      "objectives": [
        "Understand the purpose and function of the TLS Record Protocol",
        "Describe how data is fragmented, compressed (legacy), and encrypted",
        "Explain how Message Authentication Codes (MACs) ensure data integrity",
        "Analyze a TLS record in a packet capture tool"
      ],
      "content": {
        "overview": "Sitting below the handshake and application data layers, the TLS Record Protocol is responsible for the actual securing of data. This lesson covers how the record protocol takes chunks of data, prepares them for secure transmission by adding integrity checks and encrypting them, and then passes them to the transport layer.",
        "sections": [
          {
            "title": "The Role of the Record Protocol",
            "content": "<p>The TLS Record Protocol is the workhorse of TLS. Once the handshake has established a secure session with a shared key, the Record Protocol takes over. Its job is to take the data from higher-level protocols (like HTTP), prepare it for secure transmission, and send it. On the receiving end, it performs the reverse process: decrypting, verifying, and reassembling the data.</p><h3>The process involves several steps for each piece of data (a 'record'):</h3><ol><li><strong>Fragmentation:</strong> The protocol takes the stream of application data and breaks it down into manageable blocks, typically no larger than 16 KB.</li><li><strong>Compression (Legacy):</strong> In older versions of TLS, this data could be compressed. However, this feature was found to be vulnerable to attacks (like CRIME) and is now removed and forbidden in TLS 1.3.</li><li><strong>Adding a MAC and Encrypting:</strong> The protocol calculates a Message Authentication Code (MAC) for the data to ensure integrity, appends it, and then encrypts the entire payload (data + MAC) using the symmetric session key. In modern AEAD ciphers like AES-GCM, this is a single, integrated step.</li><li><strong>Appending a Header:</strong> Finally, a record header is added, containing information like the content type, protocol version, and the length of the payload.</li></ol><p>The resulting secure packet, known as a 'TLS record', is then ready to be sent over the network via TCP.</p>",
            "image": "https://images.unsplash.com/photo-1542382257-80ded13c79c8?w=800&h=400&fit=crop"
          },
          {
            "title": "Ensuring Integrity with Message Authentication Codes (MACs)",
            "content": "<p>One of the most critical jobs of the record protocol is to ensure that data is not altered in transit. This is the 'Integrity' pillar of TLS. It's achieved using a Message Authentication Code (MAC).</p><p>A MAC is a short piece of information generated from a secret key and the message content. It's like a cryptographic checksum. Before encryption, the sender calculates a MAC for the data. The receiver decrypts the payload and independently calculates its own MAC on the received data. If the receiver's calculated MAC matches the MAC that was sent, it proves two things:</p><ul><li><strong>Integrity:</strong> The data has not been changed or corrupted along the way. Any modification to the data would result in a different MAC.</li><li><strong>Authenticity:</strong> The message must have come from someone who possesses the secret key, as the MAC could not be correctly generated otherwise.</li></ul><div class=\"info-box note\"><div class=\"info-box-header\"><i class=\"fas fa-info-circle\"></i><strong>AEAD Ciphers and MACs</strong></div><p>As mentioned in the previous lesson, modern Authenticated Encryption (AEAD) ciphers seamlessly combine the encryption and MAC steps. They produce an encrypted ciphertext and an 'authentication tag' (which serves the same purpose as a MAC) in one atomic operation. This integrated approach is more secure and efficient than the older encrypt-then-MAC method used in legacy TLS versions.</p></div>",
            "image": "https://images.unsplash.com/photo-1579566346927-2b21703ba891?w=800&h=400&fit=crop"
          }
        ],
        "codeExamples": [
          {
            "title": "Lab: Analyze TLS Records in Wireshark",
            "language": "bash",
            "code": "# This lab builds on the skills from the handshake analysis lab.\n\n# Step 1: Start a new Wireshark capture and browse to an HTTPS site.\n\n# Step 2: Stop the capture. In the filter bar, instead of filtering for handshakes, simply filter by 'tls'.\n\n# Step 3: Look for packets that Wireshark labels with the protocol 'TLSv1.2' or 'TLSv1.3' and have 'Application Data' in the Info column. These are TLS records containing encrypted HTTP data.\n\n# Step 4: Click on one of these 'Application Data' packets. In the packet details pane, expand the 'Transport Layer Security' layer.\n# You will see the structure of the TLS Record:\n# - Content Type: Will be listed as 'Application Data' (value 23).\n# - Version: The TLS protocol version being used.\n# - Length: The length of the encrypted data.\n# - Encrypted Application Data: A blob of hexadecimal characters representing the encrypted payload. This is the actual website content, but it's unreadable.\n\n# This exercise shows how application data is encapsulated inside TLS records for secure transport."
          }
        ]
      },
      "quiz": {
        "passingScore": 75,
        "questions": [
          {
            "id": 1,
            "question": "What is the primary responsibility of the TLS Record Protocol?",
            "options": [
              "Negotiating which cipher suite to use.",
              "Authenticating the server's certificate.",
              "Fragmenting, encrypting, and adding integrity checks to application data.",
              "Managing TCP connections."
            ],
            "correct": 2,
            "explanation": "The Record Protocol handles the ongoing work of securing application data after the initial handshake is complete."
          },
          {
            "id": 2,
            "question": "Why was data compression removed from modern TLS versions?",
            "options": [
              "It made the packets too large.",
              "It was too slow.",
              "It was found to be vulnerable to security attacks like CRIME.",
              "It was never a popular feature."
            ],
            "correct": 2,
            "explanation": "Security researchers discovered that by observing how the size of encrypted data changed, an attacker could potentially infer information about the secret content, making compression a security risk."
          },
          {
            "id": 3,
            "question": "What does a Message Authentication Code (MAC) provide?",
            "options": [
              "Confidentiality only",
              "Data integrity and authenticity",
              "Protocol negotiation",
              "Server authentication"
            ],
            "correct": 1,
            "explanation": "A MAC ensures that a message has not been altered (integrity) and that it originated from a party holding the shared secret key (authenticity)."
          },
          {
            "id": 4,
            "question": "In a Wireshark capture, encrypted HTTP data is typically found inside a TLS record with what Content Type?",
            "options": [
              "Handshake",
              "Alert",
              "Change Cipher Spec",
              "Application Data"
            ],
            "correct": 3,
            "explanation": "The 'Application Data' content type signifies a TLS record that contains the encrypted payload from the upper-level application (e.g., HTTP GET requests or HTML responses)."
          }
        ]
      }
    },
    {
      "id": "lesson-8",
      "title": "TLS Alert & Error Handling",
      "duration": "45 min",
      "objectives": [
        "Understand the purpose of the TLS Alert Protocol",
        "Differentiate between warning and fatal alerts",
        "Recognize common handshake failure alerts",
        "Understand how alerts contribute to secure session termination"
      ],
      "content": {
        "overview": "When something goes wrong in a TLS session, the communication needs a way to fail safely. This lesson introduces the TLS Alert Protocol, which is used to signal errors, warnings, and the closure of a session. Understanding these alerts is key to diagnosing connection problems and recognizing potential security issues.",
        "sections": [
          {
            "title": "The TLS Alert Protocol",
            "content": "<p>The TLS Alert Protocol is a component of TLS responsible for signaling status changes and errors. Alert messages are conveyed by the TLS Record Protocol, just like handshake or application data, but they have their own specific content type.</p><p>Each alert message contains two pieces of information:</p><ul><li><strong>Level:</strong> This indicates the severity of the alert. It can be either `warning` (1) or `fatal` (2).</li><li><strong>Description:</strong> A code that specifies the exact nature of the alert.</li></ul><h3>Severity Levels:</h3><ul><li>A <strong>warning</strong> alert indicates a non-critical issue. The session can often continue, but some parameters might have changed or a minor problem was noted. However, some warning alerts can prompt the recipient to terminate the connection if they deem it necessary. An example is `close_notify`, which is a friendly way to signal the end of a session.</li><li>A <strong>fatal</strong> alert signifies a critical error that has rendered the session insecure or invalid. Upon sending or receiving a fatal alert, both parties must immediately terminate the connection, and all session state is discarded. Attempting to resume such a session is not allowed.</li></ul>",
            "image": "https://images.unsplash.com/photo-1554867375-3c1397f3957f?w=800&h=400&fit=crop"
          },
          {
            "title": "Common TLS Alerts and Handshake Failures",
            "content": "<p>Alerts are most commonly seen during the handshake phase when client and server configurations don't align, or a security issue is detected.</p><h3>Examples of Common Fatal Alerts:</h3><ul><li><strong>`handshake_failure` (40):</strong> A generic but very common error indicating that the client and server could not negotiate a common set of security parameters. This could be due to no matching cipher suites, a protocol version mismatch, or other handshake inconsistencies.</li><li><strong>`bad_certificate` (42):</strong> The certificate presented was corrupt, contained invalid signatures, or could not be validated for some reason.</li><li><strong>`unsupported_certificate` (43):</strong> The server or client does not support the type of certificate that was received (e.g., it might not support an ECC certificate).</li><li><strong>`certificate_expired` (45):</strong> The certificate's validity period has ended.</li><li><strong>`certificate_unknown` (46):</strong> This alert is sent when the certificate is valid in format, but the receiver cannot validate it against a trusted CA (e.g., a self-signed certificate presented to a client that doesn't trust it).</li><li><strong>`protocol_version` (70):</strong> Sent when a peer offers a TLS version that is not supported or is disallowed (e.g., a server configured to disallow TLS 1.0 receives a TLS 1.0 ClientHello).</li><li><strong>`decrypt_error` (51):</strong> A cryptographic operation failed, suggesting a potential data corruption or a serious mismatch in keys. This can sometimes indicate a security attack in progress.</li></ul>",
            "image": "https://images.unsplash.com/photo-1594402633342-a08b3c31fad1?w=800&h=400&fit=crop"
          }
        ],
        "codeExamples": [
          {
            "title": "Lab: Simulate an Expired Certificate Error",
            "language": "bash",
            "code": "# To simulate a certificate error, we can use a special flag in `openssl s_client` that connects to a server specifically designed to present a bad certificate, like one that is expired.\n\n# The website badssl.com provides various subdomains to test different TLS client behaviors.\n\n# Step 1: Connect to a host that serves an expired certificate.\n# Notice that the connection fails immediately during the handshake.\nopenssl s_client -connect expired.badssl.com:443 -servername expired.badssl.com\n\n# Step 2: Examine the output.\n# You should see a line near the end that says 'verify error:num=10:certificate has expired'. \n# This is the local verification check from the OpenSSL client itself.\n# Following this, the TLS/SSL session details will show an alert being sent or received, often a 'handshake failure' as the server terminates the invalid connection attempt.\n\n\n# Step 3: Connect to a host with a self-signed certificate.\n# This simulates a 'certificate_unknown' or 'untrusted' scenario.\nopenssl s_client -connect self-signed.badssl.com:443 -servername self-signed.badssl.com\n\n# Observe the 'verify error:num=18:self signed certificate' error message. The server is correctly configured from a technical standpoint, but our client correctly rejects it because the certificate is not signed by a trusted authority."
          }
        ]
      },
      "quiz": {
        "passingScore": 75,
        "questions": [
          {
            "id": 1,
            "question": "What is the primary purpose of the TLS Alert Protocol?",
            "options": [
              "To exchange application data",
              "To signal errors, warnings, and the closure of a session",
              "To negotiate cipher suites",
              "To transfer the server's certificate"
            ],
            "correct": 1,
            "explanation": "The Alert Protocol is the designated channel within TLS for communicating problems and session state changes like termination."
          },
          {
            "id": 2,
            "question": "What is the consequence of a 'fatal' alert?",
            "options": [
              "The session continues with reduced security.",
              "A warning is logged, but the connection proceeds.",
              "Both parties must immediately terminate the connection.",
              "The client is prompted to try a different protocol."
            ],
            "correct": 2,
            "explanation": "A fatal alert signifies an unrecoverable error, and for security reasons, the connection must be completely torn down immediately."
          },
          {
            "id": 3,
            "question": "If a server's certificate has passed its 'Not After' date, which alert should be triggered?",
            "options": [
              "handshake_failure",
              "bad_certificate",
              "certificate_expired",
              "protocol_version"
            ],
            "correct": 2,
            "explanation": "The `certificate_expired` alert (code 45) is specifically designed to signal that the certificate's validity period has ended."
          },
          {
            "id": 4,
            "question": "The generic `handshake_failure` alert often means what?",
            "options": [
              "The network connection was lost.",
              "The server is too busy to respond.",
              "The server and client could not agree on a common set of security parameters (e.g., cipher suites).",
              "The server sent too much data."
            ],
            "correct": 2,
            "explanation": "A handshake failure is a catch-all for when the initial negotiation fails. A very common cause is that the client's list of supported cipher suites has no overlap with the server's list of enabled cipher suites."
          }
        ]
      }
    },
    {
      "id": "lesson-9",
      "title": "TLS Session Resumption",
      "duration": "60 min",
      "objectives": [
        "Understand the performance overhead of a full TLS handshake",
        "Explain the concept and process of session resumption",
        "Differentiate between Session IDs and Session Tickets",
        "Recognize the security and privacy implications of session resumption"
      ],
      "content": {
        "overview": "A full TLS handshake involves several network round-trips and computationally expensive cryptographic operations. To improve performance for repeat visitors, TLS provides mechanisms for session resumption, allowing a client and server to bypass the full handshake and quickly establish a secure connection. This lesson covers the two main methods: Session IDs and Session Tickets.",
        "sections": [
          {
            "title": "The Need for Speed: Avoiding the Full Handshake",
            "content": "<p>Establishing a new TLS session from scratch is relatively expensive. It involves:</p><ul><li><strong>Network Latency:</strong> Multiple round-trips between the client and server to exchange handshake messages. For users far from the server, this can add noticeable delay.</li><li><strong>Computational Cost:</strong> The asymmetric cryptography used for the key exchange is resource-intensive for the server.</li></ul><p>For a client that has recently connected to a server, performing this full handshake every single time for every resource (images, CSS files, etc.) would be very inefficient. Session resumption techniques were created to solve this problem by allowing the client and server to reuse a previously negotiated session state.</p>",
            "image": "https://images.unsplash.com/photo-1504292152865-b91c13697e2d?w=800&h=400&fit=crop"
          },
          {
            "title": "Method 1: Session IDs",
            "content": "<p>Session IDs were the original mechanism for session resumption. The process works as follows:</p><ol><li>During the initial full handshake, the server creates a unique <strong>Session ID</strong> and sends it to the client in the `ServerHello` message.</li><li>The server stores the session information (including the master secret and cipher suite) in its local cache, keyed by the Session ID.</li><li>The client also stores the Session ID along with the session information.</li><li>On a subsequent connection, the client includes the saved Session ID in its `ClientHello` message.</li><li>If the server finds the Session ID in its cache and is willing to resume the session, it responds with the same Session ID in its `ServerHello` and proceeds to a shortened handshake. Both parties can then immediately calculate the session keys from the saved master secret.</li></ol><h3>Drawbacks of Session IDs:</h3><ul><li><strong>Server-Side State:</strong> The server must maintain a cache of session information for every client. For large-scale sites with millions of visitors, this can consume significant memory and processing resources.</li><li><strong>Load Balancer Issues:</strong> If a client's resumed request goes to a different server behind a load balancer, that server won't have the session information in its cache, forcing a full handshake. This requires complex shared session caches between servers.</li></ul>",
            "image": "https://images.unsplash.com/photo-1522199670076-2852f80289c3?w=800&h=400&fit=crop"
          },
          {
            "title": "Method 2: Session Tickets (RFC 5077)",
            "content": "<p>Session Tickets were designed to overcome the server-side scaling issues of Session IDs. This method shifts the responsibility of storing the session state to the client.</p><ol><li>During the initial full handshake, after the `Finished` messages are exchanged, the server encrypts the entire session state (master secret, cipher suite, etc.) using a secret key known only to the server itself. This encrypted blob is the <strong>Session Ticket</strong>.</li><li>The server sends this Session Ticket to the client in a `NewSessionTicket` handshake message. The server does not need to store anything.</li><li>The client receives the opaque ticket and stores it. It cannot read the contents of the ticket.</li><li>On a subsequent connection, the client includes the Session Ticket in an extension in its `ClientHello`.</li><li>The server receives the ticket, decrypts it using its secret key, and retrieves the session information. If the ticket is valid, it agrees to resume the session and proceeds with an abbreviated handshake.</li></ol><h3>Advantages of Session Tickets:</h3><ul><li><strong>Stateless Servers:</strong> This method is stateless from the server's perspective, which simplifies deployment and scaling, especially in load-balanced environments.</li></ul><h3>Security Considerations:</h3><p>The security of Session Tickets relies on the server's secret ticket encryption key. This key must be carefully managed and rotated regularly. If the key is compromised, an attacker could potentially decrypt tickets and impersonate users or decrypt past sessions if forward secrecy isn't used properly.</p>",
            "image": "https://images.unsplash.com/photo-1542990253-a781e04c0623?w=800&h=400&fit=crop"
          }
        ],
        "codeExamples": [
          {
            "title": "Lab: Observe a Resumed Session with OpenSSL",
            "language": "bash",
            "code": "# The openssl s_client has a '-reconnect' flag that is perfect for testing session resumption.\n# It will connect 5 times to the same server, attempting to reuse the session.\n\n# We will also use '-sess_out' to save the session information and '-sess_in' to load it.\n\n# Step 1: Make an initial connection and save the session information (which may include an ID or ticket) to a file named 'session.pem'.\nopenssl s_client -connect www.google.com:443 -sess_out session.pem\n\n# Note the output. Look for a line like 'Session-ID:' and whether a 'TLS session ticket' was issued.\n# Quit the connection by typing Q and hitting Enter.\n\n# Step 2: Make a second connection, but this time, load the session information from the file.\n# This simulates a browser using a saved session to reconnect.\nopenssl s_client -connect www.google.com:443 -sess_in session.pem\n\n# Step 3: Analyze the output of the second command.\n# You should see a line that confirms 'Reused, <Cipher>'. This indicates that session resumption was successful and a full handshake was skipped.\n# The server recognized the session information provided by the client and agreed to resume the session."
          }
        ]
      },
      "quiz": {
        "passingScore": 75,
        "questions": [
          {
            "id": 1,
            "question": "What is the primary benefit of TLS session resumption?",
            "options": [
              "It increases the encryption strength.",
              "It reduces latency by skipping the full handshake for repeat connections.",
              "It allows the use of self-signed certificates.",
              "It eliminates the need for a Certificate Authority."
            ],
            "correct": 1,
            "explanation": "Session resumption avoids the computationally expensive key exchange and extra network round-trips of a full handshake, leading to faster connections."
          },
          {
            "id": 2,
            "question": "In the Session ID method, where is the session state stored?",
            "options": [
              "On the client's hard drive only",
              "In the server's session cache",
              "In the Certificate Authority's database",
              "In the public DNS records"
            ],
            "correct": 1,
            "explanation": "The Session ID method requires the server to maintain a cache of session details, which it looks up when a client presents a Session ID."
          },
          {
            "id": 3,
            "question": "What is the main advantage of using Session Tickets over Session IDs?",
            "options": [
              "Tickets are easier for clients to store.",
              "Tickets do not require encryption.",
              "It allows servers to be stateless, improving scalability.",
              "Tickets use stronger cryptography."
            ],
            "correct": 2,
            "explanation": "With Session Tickets, the encrypted session state is stored by the client, so the server doesn't need to keep a large session cache. This is a significant advantage in large, load-balanced environments."
          },
          {
            "id": 4,
            "question": "How does a client request to resume a session using a Session Ticket?",
            "options": [
              "It sends the server's public key.",
              "It includes the ticket in an extension of the ClientHello message.",
              "It sends a special 'ResumeSession' command.",
              "It waits for the server to offer resumption first."
            ],
            "correct": 1,
            "explanation": "The client includes the previously received opaque session ticket within the `ClientHello`, signaling to the server that it wishes to resume a previous session."
          }
        ]
      }
    },
    {
      "id": "lesson-10",
      "title": "TLS Cipher Suites",
      "duration": "60 min",
      "objectives": [
        "Understand that a cipher suite is a collection of algorithms",
        "Deconstruct the name of a cipher suite into its components",
        "Identify the purpose of each algorithm: key exchange, authentication, encryption, and hashing",
        "Differentiate between legacy and modern cipher suite naming conventions"
      ],
      "content": {
        "overview": "A cipher suite is a named combination of cryptographic algorithms that defines the security parameters for a TLS connection. Understanding how to read and interpret these names is essential for configuring a secure server. This lesson breaks down the components of a cipher suite and highlights the modern, secure options.",
        "sections": [
          {
            "title": "What is a Cipher Suite?",
            "content": "<p>A TLS cipher suite is not a single algorithm, but rather a set of algorithms that work together to secure the connection. During the `ClientHello`, the client sends a list of all the cipher suites it supports, in order of preference. The server then chooses one from that list that it also supports. This chosen cipher suite dictates how the entire TLS session will be secured.</p><h3>The components of a TLS 1.2 cipher suite name typically specify four things:</h3><ol><li><strong>Key Exchange Algorithm:</strong> How the shared secret (session key) will be established (e.g., ECDHE).</li><li><strong>Authentication Algorithm:</strong> How the server's identity will be verified (e.g., RSA or ECDSA).</li><li><strong>Bulk Encryption Cipher:</strong> The symmetric algorithm used for encrypting the application data (e.g., AES256-GCM).</li><li><strong>Message Authentication Code (MAC) Algorithm:</strong> The algorithm used for data integrity checks (e.g., SHA256).</li></ol>",
            "image": "https://images.unsplash.com/photo-1542382257-80ded13c79c8?w=800&h=400&fit=crop"
          },
          {
            "title": "Deconstructing a Cipher Suite Name",
            "content": "<p>Let's break down a common and strong TLS 1.2 cipher suite:</p><h3><code>TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384</code></h3><ul><li><strong><code>TLS_</code></strong>: A prefix indicating it's for the TLS protocol.</li><li><strong><code>ECDHE_</code></strong>: The key exchange algorithm is <strong>Elliptic Curve Diffie-Hellman Ephemeral</strong>. This provides Perfect Forward Secrecy.</li><li><strong><code>RSA_</code></strong>: The authentication algorithm is <strong>RSA</strong>. This means the server's certificate must contain an RSA public key and be signed using RSA.</li><li><strong><code>_WITH_</code></strong>: A separator.</li><li><strong><code>AES_256_GCM_</code></strong>: The bulk encryption cipher is <strong>AES</strong> with a 256-bit key, operating in <strong>Galois/Counter Mode (GCM)</strong>. GCM is an AEAD mode, so it provides both encryption and authenticity.</li><li><strong><code>SHA384</code></strong>: The hashing algorithm used for the Pseudo-Random Function (PRF) in the handshake is <strong>SHA-384</strong>. Because GCM is an AEAD cipher, this does not represent a separate MAC; its role here is related to internal handshake calculations.</li></ul><h3>Simplified TLS 1.3 Cipher Suites:</h3><p>TLS 1.3 greatly simplifies things. The key exchange (always ephemeral Diffie-Hellman) and authentication (dictated by the certificate type) are no longer specified in the cipher suite name. The name now only defines the symmetric encryption and hashing algorithms.</p><h4>Example: <code>TLS_AES_256_GCM_SHA384</code></h4><ul><li><strong><code>AES_256_GCM</code></strong>: This defines the AEAD cipher used for bulk data encryption and integrity.</li><li><strong><code>SHA384</code></strong>: This defines the hashing algorithm used for the HMAC-based Key Derivation Function (HKDF).</li></ul>",
            "image": "https://images.unsplash.com/photo-1614064548237-02f4d3544d42?w=800&h=400&fit=crop"
          }
        ],
        "codeExamples": [
          {
            "title": "Lab: List Supported Ciphers with OpenSSL",
            "language": "bash",
            "code": "# The `openssl ciphers` command can be used to see the list of cipher suites that your version of OpenSSL supports.\n\n# List all supported cipher suites in a colon-separated list\nopenssl ciphers 'ALL'\n\n# Get a more verbose, human-readable list of supported ciphers for TLS 1.2 and below. [32]\n# This shows details for each cipher, including protocol version, key exchange, encryption, and MAC.\nopenssl ciphers -v 'ALL'\n\n# You can also use this command to build specific cipher strings for server configuration.\n# For example, to list only high-security ciphers that use ECDHE and AES-GCM, excluding old protocols:\nopenssl ciphers -v 'ECDHE+AESGCM:!SSLv3:!TLSv1:!TLSv1.1'\n\n# To specifically list the supported cipher suites for TLS 1.3:\nopenssl ciphers -v -s -tls1_3\n\n# Use 'man openssl-ciphers' to see the full documentation for the cipher string syntax. [13, 45]"
          }
        ]
      },
      "quiz": {
        "passingScore": 75,
        "questions": [
          {
            "id": 1,
            "question": "What is a TLS cipher suite?",
            "options": [
              "A single encryption algorithm",
              "A named combination of algorithms for key exchange, authentication, and encryption",
              "A type of security certificate",
              "A software package for managing TLS"
            ],
            "correct": 1,
            "explanation": "A cipher suite is a collection of specific algorithms that, together, define how a TLS session is secured."
          },
          {
            "id": 2,
            "question": "In the cipher suite `TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256`, what does 'ECDHE' stand for?",
            "options": [
              "The bulk encryption algorithm",
              "The authentication method",
              "The key exchange algorithm",
              "The MAC algorithm"
            ],
            "correct": 2,
            "explanation": "ECDHE (Elliptic Curve Diffie-Hellman Ephemeral) is a modern key exchange mechanism that provides Perfect Forward Secrecy."
          },
          {
            "id": 3,
            "question": "How did TLS 1.3 change the structure of cipher suites?",
            "options": [
              "It removed all cipher suites and uses a single fixed algorithm.",
              "It simplified the names to only define the symmetric encryption and hashing algorithms.",
              "It added more components to the name for greater detail.",
              "It requires using two cipher suites at the same time."
            ],
            "correct": 1,
            "explanation": "TLS 1.3 simplifies cipher suites by removing the key exchange and authentication parts from the name, as they are handled separately in the handshake."
          },
          {
            "id": 4,
            "question": "An 'AEAD' cipher like AES-GCM provides which two functions simultaneously?",
            "options": [
              "Key Exchange and Authentication",
              "Authentication and Hashing",
              "Encryption and Data Integrity",
              "Compression and Fragmentation"
            ],
            "correct": 2,
            "explanation": "Authenticated Encryption with Associated Data (AEAD) ciphers combine confidentiality (encryption) and authenticity/integrity (message authentication) into a single, highly secure operation."
          }
        ]
      }
    },
    {
      "id": "lesson-11",
      "title": "TLS 1.3 Improvements",
      "duration": "60 min",
      "objectives": [
        "Identify the primary motivations for creating TLS 1.3: speed and security",
        "Explain how the TLS 1.3 handshake is faster (1-RTT)",
        "Define 0-RTT (Zero Round Trip Time) and its use case",
        "List cryptographic algorithms and features removed in TLS 1.3"
      ],
      "content": {
        "overview": "Published in 2018, TLS 1.3 is a major overhaul of the protocol, designed to be faster, simpler, and more secure. This lesson focuses on the key enhancements it brings, such as the streamlined handshake, the concept of Zero Round-Trip Time Resumption, and the aggressive removal of legacy and vulnerable cryptographic primitives.",
        "sections": [
          {
            "title": "Faster Handshake: From 2-RTT to 1-RTT",
            "content": "<p>One of the most significant performance improvements in TLS 1.3 is the reduction in handshake latency. A standard TLS 1.2 handshake requires two full round-trips (2-RTT) between the client and server before the first piece of application data can be sent.</p><p>TLS 1.3 redesigns the handshake so that it only requires one round-trip (1-RTT). It achieves this by having the client send more information in its initial `ClientHello` message. The client speculatively sends its key exchange information (its Diffie-Hellman public key) and guesses which cipher the server will choose. If it guesses correctly, the server has everything it needs to calculate the session key and can send its own key exchange info and the `Finished` message in its first flight of responses. This effectively halves the handshake time, which is a significant improvement for web performance.</p>",
            "image": "https://images.unsplash.com/photo-1543141124-cf1808b0a1d4?w=800&h=400&fit=crop"
          },
          {
            "title": "Zero Round-Trip Time (0-RTT) Resumption",
            "content": "<p>For clients reconnecting to a site they've recently visited, TLS 1.3 introduces a powerful new feature called 0-RTT, or Zero Round-Trip Time Resumption. After a successful initial 1-RTT handshake, the server can provide the client with a special pre-shared key (PSK).</p><p>On a subsequent connection, the client can use this PSK to send encrypted application data (like an HTTP GET request) along with its very first `ClientHello` message. This means the server can immediately process the request and begin sending back the response without any handshake round-trips at all. This can dramatically improve perceived load times for returning visitors.</p><h3>Security Caveat for 0-RTT:</h3><p>0-RTT data is not fully forward secret and is vulnerable to 'replay attacks', where an attacker could capture the 0-RTT data and send it to the server again. For this reason, it should only be used for data that is 'idempotent'—meaning that receiving it multiple times has no negative side effects (e.g., fetching a static webpage is safe, but making a purchase is not).</p>",
            "image": "https://images.unsplash.com/photo-1611078489816-43c2d49a37e8?w=800&h=400&fit=crop"
          },
          {
            "title": "Enhanced Security Through Simplification",
            "content": "<p>A core design philosophy of TLS 1.3 was to improve security by removing old and problematic features. This makes the protocol simpler to implement correctly and harder to misconfigure.</p><h3>Key Features Removed in TLS 1.3:</h3><ul><li><strong>Legacy Algorithms:</strong> RSA key exchange, CBC mode ciphers, RC4, SHA-1, MD5, and various other primitives with known weaknesses are completely gone.</li><li><strong>Static Key Exchange:</strong> All key exchange methods must provide Perfect Forward Secrecy. Ephemeral Diffie-Hellman is now mandatory.</li><li><strong>Compression:</strong> Data compression at the TLS layer has been forbidden to prevent attacks like CRIME.</li><li><strong>Renegotiation:</strong> The complex and sometimes problematic mechanism for changing session parameters mid-stream has been removed.</li><li><strong>`ChangeCipherSpec` record:</strong> These records are no longer needed for state transitions and are simply ignored for compatibility.</li></ul><p>By removing these legacy features, TLS 1.3 presents a much smaller attack surface and establishes a significantly higher baseline for security.</p>",
            "image": "https://images.unsplash.com/photo-1599507578794-279213135e13?w=800&h=400&fit=crop"
          }
        ],
        "codeExamples": [
          {
            "title": "Lab: Compare TLS 1.2 vs TLS 1.3 Handshake in Wireshark",
            "language": "bash",
            "code": "# To see the difference in round trips, you can use Wireshark or the `openssl s_client` tool, though Wireshark is more visual.\n\n# Step 1: Launch Wireshark and start capturing.\n\n# Step 2: Use openssl to force a TLS 1.2 connection.\nopenssl s_client -connect www.cloudflare.com:443 -tls1_2\n\n# Step 3: Stop the capture and filter for 'tls'. Observe the sequence:\n# 1. ClientHello (Client -> Server)\n# 2. ServerHello, Certificate, Server Key Exchange, Server Hello Done (Server -> Client)\n# --- ROUND TRIP 1 COMPLETE ---\n# 3. Client Key Exchange, Change Cipher Spec, Encrypted Handshake Message (Client -> Server)\n# 4. New Session Ticket, Change Cipher Spec, Encrypted Handshake Message (Server -> Client)\n# --- ROUND TRIP 2 COMPLETE ---\n# Application data can now flow.\n\n# Step 4: Start a new capture and force a TLS 1.3 connection.\nopenssl s_client -connect www.cloudflare.com:443 -tls1_3\n\n# Step 5: Stop and filter. Observe the much shorter sequence:\n# 1. ClientHello (Client -> Server)\n# 2. ServerHello, Encrypted Extensions, Certificate, Certificate Verify, Finished (Server -> Client)\n# --- ROUND TRIP 1 COMPLETE ---\n# Client sends its own encrypted 'Finished' and then application data.\n# The difference is clear: TLS 1.3 completes the negotiation in one round trip."
          }
        ]
      },
      "quiz": {
        "passingScore": 75,
        "questions": [
          {
            "id": 1,
            "question": "What is the main performance benefit of the TLS 1.3 handshake compared to TLS 1.2?",
            "options": [
              "It uses less bandwidth.",
              "It requires one round-trip (1-RTT) instead of two (2-RTT).",
              "It doesn't require a certificate.",
              "It uses faster encryption algorithms."
            ],
            "correct": 1,
            "explanation": "The TLS 1.3 handshake was redesigned to be completed in a single round-trip, which halves the setup latency compared to TLS 1.2."
          },
          {
            "id": 2,
            "question": "What is 0-RTT (Zero Round-Trip Time)?",
            "options": [
              "A handshake that doesn't use TCP.",
              "A feature allowing a client to send encrypted data on its very first message when resuming a session.",
              "A TLS mode that does not use encryption.",
              "A new type of certificate."
            ],
            "correct": 1,
            "explanation": "0-RTT allows a client with a pre-shared key (from a previous session) to send early application data along with its first handshake message, eliminating handshake latency entirely for resumed connections."
          },
          {
            "id": 3,
            "question": "What is a significant security risk associated with 0-RTT?",
            "options": [
              "It can be decrypted by anyone.",
              "It is vulnerable to replay attacks.",
              "It uses a weak encryption cipher.",
              "It doesn't work with modern browsers."
            ],
            "correct": 1,
            "explanation": "Because 0-RTT data is sent before the server can provide a unique session nonce, an attacker could potentially capture this data and 'replay' it to the server. Thus, it should only be used for non-sensitive, idempotent requests."
          },
          {
            "id": 4,
            "question": "Which of the following was explicitly REMOVED in the TLS 1.3 specification?",
            "options": [
              "RSA for digital signatures",
              "AES encryption",
              "RSA key exchange",
              "Elliptic Curve Cryptography (ECC)"
            ],
            "correct": 2,
            "explanation": "The static RSA key exchange (where the client encrypts a secret with the server's public key) was removed because it doesn't provide forward secrecy. RSA can still be used for digital signatures to authenticate the server."
          }
        ]
      }
    },
    {
      "id": "lesson-12",
      "title": "Certificate Authorities (CAs)",
      "duration": "75 min",
      "objectives": [
        "Define the role and responsibility of a Certificate Authority",
        "Explain the certificate hierarchy: Root, Intermediate, and End-entity",
        "Understand the purpose of the Chain of Trust",
        "Describe the different validation levels: DV, OV, and EV"
      ],
      "content": {
        "overview": "Certificate Authorities are the backbone of trust for HTTPS and secure communication on the internet. This lesson explains how CAs function as trusted third parties, the hierarchical structure they use to issue certificates, and the different levels of validation they perform to verify identity.",
        "sections": [
          {
            "title": "The Role of a Certificate Authority",
            "content": "<p>A Certificate Authority (CA) is a company or organization that acts as a trusted third party to validate the identities of entities (such as websites, email addresses, companies, or individuals) and bind them to cryptographic keys through the issuance of digital certificates. The CA signs these certificates with its own private key, allowing anyone with the CA's public key to verify that the certificate is authentic.</p><h3>Core Responsibilities of a CA:</h3><ul><li><strong>Verification:</strong> Verifying the identity of the person or organization requesting a certificate.</li><li><strong>Issuance:</strong> Creating and signing a certificate for the verified entity.</li><li><strong>Revocation:</strong> Maintaining and publishing lists of certificates that are no longer valid (e.g., if they have been compromised). This is done via Certificate Revocation Lists (CRLs) or the Online Certificate Status Protocol (OCSP).</li></ul><p>Your browser and operating system come pre-installed with a set of public keys from trusted Root CAs, which is known as a 'trust store'. This is the foundation upon which all of TLS trust is built.</p>",
            "image": "https://images.unsplash.com/photo-1594980598282-53b754e8c14f?w=800&h=400&fit=crop"
          },
          {
            "title": "The Certificate Hierarchy: Root, Intermediate, and Chain of Trust",
            "content": "<p>For security and operational reasons, CAs use a tiered hierarchy to issue certificates. Directly signing end-entity (server) certificates with a highly-guarded root key would be very risky. Instead, they use a chain of trust. [35, 41]</p><ol><li><strong>Root CA:</strong> This is the top of the hierarchy. The Root CA has a self-signed certificate. Its private key is kept extremely secure, often in an offline hardware security module, and is used very rarely, primarily to sign Intermediate CA certificates. Root CA certificates are the ones included in your browser's trust store.</li><li><strong>Intermediate CA:</strong> The Root CA issues certificates for one or more Intermediate CAs. These intermediates act on behalf of the root. Their private keys are used for the day-to-day task of signing end-entity certificates. This creates a buffer: if an intermediate key is compromised, the root can revoke its certificate, and all certificates issued by it become invalid, without affecting the entire root's trustworthiness.</li><li><strong>End-entity Certificate:</strong> This is the certificate installed on a web server (e.g., `www.yourwebsite.com`). It is signed by an Intermediate CA.</li></ol><p>When your browser receives a server's certificate, it also receives the intermediate certificate(s). It then validates the chain: it checks that the server certificate was signed by the intermediate, and that the intermediate was signed by a root CA that is in its trust store. [31]</p>",
            "image": "https://images.unsplash.com/photo-1621640348395-502f04b2e811?w=800&h=400&fit=crop"
          },
          {
            "title": "Certificate Validation Levels",
            "content": "<p>CAs offer different types of certificates based on the level of validation they perform before issuing one. The more thorough the validation, the more trust is conferred to the certificate.</p><ul><li><strong>Domain Validated (DV):</strong> This is the most basic and common type of validation. The CA only verifies that the applicant controls the domain name for which they are requesting the certificate. This is usually done by responding to an email sent to the domain, adding a specific DNS record, or uploading a file to the website. Let's Encrypt is a popular provider of free DV certificates.</li><li><strong>Organization Validated (OV):</strong> This requires more validation. The CA investigates the requesting organization to verify its legal existence, physical address, and other details. The organization's verified name and location are included in the certificate, providing a higher level of trust.</li><li><strong>Extended Validation (EV):</strong> This is the most rigorous level of validation, requiring a strict vetting process defined by the CA/Browser Forum. The CA performs a thorough background check on the organization. In the past, browsers displayed the verified organization's name in a green bar next to the URL for EV certificates, although most have since retired this special UI feature. EV certificates still represent the highest level of trust and identity verification.</li></ul>",
            "image": "https://images.unsplash.com/photo-1579226903282-c0e4821d4c38?w=800&h=400&fit=crop"
          }
        ],
        "codeExamples": [
          {
            "title": "Lab: Build a Certificate Chain",
            "language": "bash",
            "code": "# A server should always present the full certificate chain (end-entity + intermediate(s)) to the client.\n# CAs will provide you with these separate files. You typically need to concatenate them into a single file for server configuration.\n\n# Let's assume you have received three files from your CA:\n# 1. your_domain.crt (your server's certificate)\n# 2. intermediate_ca.crt (the intermediate CA's certificate)\n# 3. root_ca.crt (the root CA's certificate - not always needed, but good to have)\n\n# The correct order for a chain file is crucial: Server Cert -> Intermediate(s) -> Root.\n# The server's own certificate must come first. [35]\n\n# Step 1: Create an empty chain file.\n> fullchain.pem\n\n# Step 2: Add the end-entity (server) certificate to the file first.\ncat your_domain.crt >> fullchain.pem\n\n# Step 3: Add the intermediate certificate(s) to the file. If there are multiple, add them in order, leading back to the root.\ncat intermediate_ca.crt >> fullchain.pem\n\n# Step 4 (Optional but good practice): Add the root certificate at the end.\ncat root_ca.crt >> fullchain.pem\n\n# Now, the 'fullchain.pem' file can be used in your web server (e.g., Nginx's `ssl_certificate` directive) and will present a valid chain to connecting clients."
          }
        ]
      },
      "quiz": {
        "passingScore": 75,
        "questions": [
          {
            "id": 1,
            "question": "What is the primary role of a Certificate Authority (CA)?",
            "options": [
              "To host websites securely.",
              "To issue and sign digital certificates, verifying the identity of the owner.",
              "To encrypt all internet traffic.",
              "To provide DNS services."
            ],
            "correct": 1,
            "explanation": "CAs act as trusted third parties that vouch for the identity of certificate holders by digitally signing their certificates."
          },
          {
            "id": 2,
            "question": "In a certificate hierarchy, which certificate is self-signed?",
            "options": [
              "The End-entity certificate",
              "The Intermediate CA certificate",
              "The Root CA certificate",
              "No certificate is self-signed"
            ],
            "correct": 2,
            "explanation": "The Root CA certificate is the anchor of trust. It is self-signed, and its public key is pre-distributed in browsers and operating systems' trust stores."
          },
          {
            "id": 3,
            "question": "What is the purpose of using Intermediate CAs?",
            "options": [
              "They are cheaper than Root CAs.",
              "They improve security by allowing the Root CA's private key to be kept offline and secure.",
              "They are faster at signing certificates.",
              "They provide a different type of encryption."
            ],
            "correct": 1,
            "explanation": "Using intermediates for day-to-day signing operations protects the highly valuable Root CA key. If an intermediate is compromised, it can be revoked without compromising the entire trust infrastructure."
          },
          {
            "id": 4,
            "question": "Which validation level only verifies control over a domain name?",
            "options": [
              "Organization Validated (OV)",
              "Extended Validation (EV)",
              "Domain Validated (DV)",
              "Control Validated (CV)"
            ],
            "correct": 2,
            "explanation": "Domain Validated (DV) is the lowest level of validation, confirming only that the certificate applicant has administrative control over the domain in question, usually via an automated check."
          }
        ]
      }
    },
    {
      "id": "lesson-13",
      "title": "Self-Signed vs. Trusted Certificates",
      "duration": "60 min",
      "objectives": [
        "Define a self-signed certificate",
        "Identify appropriate use cases for self-signed certificates (e.g., testing, internal networks)",
        "Understand the significant security risks of using self-signed certificates in public-facing applications",
        "Explain why browsers display prominent trust warnings for self-signed certificates"
      ],
      "content": {
        "overview": "While certificates from trusted CAs are the standard for public websites, self-signed certificates have a role in specific scenarios. This lesson contrasts these two types, highlighting the inherent risks of self-signed certificates and explaining why they should never be used for production services accessible to the public.",
        "sections": [
          {
            "title": "What is a Self-Signed Certificate?",
            "content": "<p>A self-signed certificate is an identity certificate that is signed by its own private key, rather than by a trusted Certificate Authority. [3, 7] In essence, the creator is vouching for their own identity. There is no external, trusted third party involved in verifying the certificate's subject information. The issuer and the subject of the certificate are the same entity. [7]</p><h3>Appropriate Use Cases:</h3><p>Despite their risks in public contexts, self-signed certificates are useful in specific, controlled environments:</p><ul><li><strong>Development and Testing:</strong> Developers can quickly generate self-signed certificates to test applications that require HTTPS without the cost and time of obtaining a CA-signed certificate. [6, 9]</li><li><strong>Internal (LAN-only) Services:</strong> For services on a private network where all users are part of the same organization and can be instructed to manually trust the certificate, a self-signed cert can provide encryption. [6] However, an internal CA is often a better solution.</li><li><strong>Device-to-Device Communication:</strong> In some IoT or embedded systems, self-signed certificates may be used for secure communication where a public CA infrastructure is not feasible.</li></ul>",
            "image": "https://images.unsplash.com/photo-1594402633342-a08b3c31fad1?w=800&h=400&fit=crop"
          },
          {
            "title": "The Dangers and Risks in Production",
            "content": "<p>Using a self-signed certificate on a public-facing website or service is extremely dangerous and negates the 'Trust' aspect of TLS. [3, 4]</p><h3>Key Risks:</h3><ul><li><strong>No Trust Validation / Browser Warnings:</strong> Since the certificate is not signed by a CA in the user's trust store, every browser and client will display a severe security warning (e.g., \"Your connection is not private\"). [3, 6, 9] This erodes user trust and drives visitors away.</li><li><strong>Vulnerability to Man-in-the-Middle (MITM) Attacks:</strong> The primary purpose of CA validation is to prevent MITM attacks. With a self-signed certificate, an attacker can easily intercept the connection, present their own self-signed certificate to the user, and the user has no way of knowing they are connecting to a malicious server instead of the real one. They will see a security warning either way. [4, 9]</li><li><strong>No Revocation Support:</strong> If the private key for a self-signed certificate is compromised, there is no mechanism to revoke it. [7, 9] A CA can add a compromised certificate to a Certificate Revocation List (CRL) or OCSP, but this infrastructure doesn't exist for self-signed certificates.</li><li><strong>Training Users for Bad Behavior:</strong> Encouraging users to click through security warnings trains them to ignore these warnings in the future, even when they might indicate a legitimate attack in progress.</li></ul><div class=\"info-box warning\"><div class=\"info-box-header\"><i class=\"fas fa-exclamation-triangle\"></i><strong>Conclusion</strong></div><p>Self-signed certificates provide encryption, but they provide zero authentication. A user has no way to know if the entity they are communicating with is legitimate. For any public service, a certificate from a trusted CA is mandatory.</p></div>",
            "image": "https://images.unsplash.com/photo-1563206410-182f5b5f8845?w=800&h=400&fit=crop"
          }
        ],
        "codeExamples": [
          {
            "title": "Lab: Configure Apache with a Self-Signed Certificate",
            "language": "bash",
            "code": "# Prerequisite: You should have a self-signed certificate and key pair from Lesson 5. (server.crt, server.key)\n# Prerequisite: Apache web server installed.\n\n# Step 1: Enable the SSL module in Apache.\n# (On Debian/Ubuntu)\nsudo a2enmod ssl\nsudo systemctl restart apache2\n\n# Step 2: Create a directory for your certificate and key.\nsudo mkdir -p /etc/apache2/ssl\nsudo cp server.crt /etc/apache2/ssl/server.crt\nsudo cp server.key /etc/apache2/ssl/server.key\n\n# Step 3: Configure an SSL Virtual Host.\n# Edit the default SSL configuration file.\n# (On Debian/Ubuntu)\nsudo nano /etc/apache2/sites-available/default-ssl.conf\n\n# Inside the <VirtualHost _default_:443> block, find and update these lines:\n# SSLEngine on\n# SSLCertificateFile    /etc/apache2/ssl/server.crt\n# SSLCertificateKeyFile /etc/apache2/ssl/server.key\n\n# Step 4: Enable the new SSL site configuration. [19, 36]\nsudo a2ensite default-ssl\nsudo systemctl restart apache2\n\n# Step 5: Test it. Open your browser and navigate to 'https://localhost'. \n# You will be presented with a prominent security warning about the untrusted certificate. You must manually accept the risk to proceed."
          }
        ]
      },
      "quiz": {
        "passingScore": 75,
        "questions": [
          {
            "id": 1,
            "question": "Who signs a 'self-signed' certificate?",
            "options": [
              "A trusted Certificate Authority",
              "Let's Encrypt",
              "The certificate's own private key",
              "Your Internet Service Provider"
            ],
            "correct": 2,
            "explanation": "A self-signed certificate is signed by its own creator, meaning the issuer and subject are the same and there is no third-party validation. [3]"
          },
          {
            "id": 2,
            "question": "Why do browsers show a security warning for self-signed certificates?",
            "options": [
              "Because they use weak encryption.",
              "Because the certificate is not signed by a CA that the browser trusts.",
              "Because they are usually expired.",
              "Because they are not formatted correctly."
            ],
            "correct": 1,
            "explanation": "Browsers' trust is based on the certificate being traceable to a root CA in their trust store. A self-signed certificate has no such chain of trust, so it is inherently untrusted. [6]"
          },
          {
            "id": 3,
            "question": "What is the most significant security risk of using a self-signed certificate on a public website?",
            "options": [
              "Poor website performance.",
              "Incompatibility with search engines.",
              "Susceptibility to Man-in-the-Middle (MITM) attacks.",
              "Increased server resource usage."
            ],
            "correct": 2,
            "explanation": "Without a trusted third party, an attacker can easily present their own fake certificate, and the end-user has no way to verify if they are connecting to the legitimate server, which is the definition of a MITM attack. [4, 9]"
          },
          {
            "id": 4,
            "question": "Which of the following is an appropriate use case for a self-signed certificate?",
            "options": [
              "An e-commerce website.",
              "A public-facing corporate homepage.",
              "A personal blog you want to share with the world.",
              "A local development server for testing an application that requires HTTPS."
            ],
            "correct": 3,
            "explanation": "For internal development, testing, or services on a completely private network, a self-signed certificate can provide the necessary encryption layer without the overhead of getting a publicly trusted certificate. [9]"
          }
        ]
      }
    },
    {
      "id": "lesson-14",
      "title": "HTTPS in Web Servers",
      "duration": "75 min",
      "objectives": [
        "Identify common web server software (Apache, Nginx)",
        "Understand the basic configuration directives for enabling SSL/TLS",
        "Specify the locations of the certificate and private key files",
        "Configure the server to listen on the standard HTTPS port (443)"
      ],
      "content": {
        "overview": "Implementing HTTPS requires configuring your web server software to use a TLS certificate and private key. This practical lesson covers the essential configuration steps for two of the most popular web servers in the world: Apache and Nginx. We will walk through a basic SSL/TLS setup for both.",
        "sections": [
          {
            "title": "Core Concepts of Web Server SSL/TLS Configuration",
            "content": "<p>Regardless of the specific web server software you use, the core requirements for enabling HTTPS are the same. You need to tell the server three key pieces of information:</p><ol><li><strong>The Certificate File:</strong> This is the public certificate that will be presented to clients. For maximum compatibility, this should be the full chain file, containing your server certificate followed by the intermediate CA certificate(s).</li><li><strong>The Private Key File:</strong> This is the secret private key corresponding to your public certificate. Access to this file must be tightly restricted.</li><li><strong>The Listening Port:</strong> The server must be configured to listen for incoming connections on the standard HTTPS port, which is TCP port 443.</li></ol><p>You will typically configure these settings within a specific `VirtualHost` (in Apache) or `server` (in Nginx) block, allowing you to have different SSL/TLS configurations for different websites hosted on the same machine.</p>",
            "image": "https://images.unsplash.com/photo-1544197150-b2c4c47b0a34?w=800&h=400&fit=crop"
          },
          {
            "title": "Configuring Apache for HTTPS",
            "content": "<p>Apache HTTP Server uses the `mod_ssl` module to provide TLS functionality. The configuration is typically done within a `<VirtualHost>` block in your site's configuration file.</p><h3>Example Apache Configuration:</h3><pre><code>&lt;VirtualHost *:443&gt;\n    ServerName www.example.com\n\n    SSLEngine on\n    SSLCertificateFile    /path/to/your/fullchain.pem\n    SSLCertificateKeyFile /path/to/your/privatekey.pem\n\n    # Further configuration (DocumentRoot, logs, etc.) goes here...\n&lt;/VirtualHost&gt;</code></pre><h3>Key Directives:</h3><ul><li><strong><code>&lt;VirtualHost *:443&gt;</code>:</strong> Defines a virtual host that listens on port 443 for all IP addresses.</li><li><strong><code>SSLEngine on</code>:</strong> This is the master switch that enables SSL/TLS for this virtual host. [33, 42]</li><li><strong><code>SSLCertificateFile</code>:</strong> Specifies the path to your certificate file (preferably the full chain). [33]</li><li><strong><code>SSLCertificateKeyFile</code>:</strong> Specifies the path to your corresponding private key. [33]</li></ul><p>After saving the configuration, you typically need to enable the SSL module (`a2enmod ssl`) and the site (`a2ensite`), then restart Apache for the changes to take effect. [19, 36]</p>",
            "image": "https://images.unsplash.com/photo-1629834465737-f1c52b34a6c3?w=800&h=400&fit=crop"
          },
          {
            "title": "Configuring Nginx for HTTPS",
            "content": "<p>Nginx is another extremely popular web server, known for its high performance. Its SSL/TLS configuration is handled within a `server` block and is generally considered very straightforward.</p><h3>Example Nginx Configuration:</h3><pre><code>server {\n    listen 443 ssl;\n    server_name www.example.com;\n\n    ssl_certificate /path/to/your/fullchain.pem;\n    ssl_certificate_key /path/to/your/privatekey.pem;\n\n    # Further configuration (root, location blocks, etc.) goes here...\n}</code></pre><h3>Key Directives:</h3><ul><li><strong><code>listen 443 ssl</code>:</strong> Tells Nginx to listen on port 443 and to expect SSL/TLS (HTTPS) traffic on this port.</li><li><strong><code>server_name</code>:</strong> Defines which domain this `server` block should handle traffic for.</li><li><strong><code>ssl_certificate</code>:</strong> Specifies the path to your full chain certificate file. [2]</li><li><strong><code>ssl_certificate_key</code>:</strong> Specifies the path to your private key file. [2]</li></ul><p>After saving the configuration, you must reload or restart the Nginx service for the changes to apply.</p>",
            "image": "https://images.unsplash.com/photo-1594708911226-9f874ce5a535?w=800&h=400&fit=crop"
          }
        ],
        "codeExamples": [
          {
            "title": "Lab: Enable a Basic HTTPS Site on Apache",
            "language": "bash",
            "code": "# This lab assumes Apache is installed and you have a self-signed certificate and key.\n# (See Lesson 13 for steps to create the cert and configure a self-signed site).\n\n# GOAL: Redirect all HTTP traffic to HTTPS for your site.\n\n# Step 1: Ensure your port 443 Virtual Host is working from the previous lab.\n\n# Step 2: Edit your NON-SSL Virtual Host file for port 80.\n# (On Debian/Ubuntu) sudo nano /etc/apache2/sites-available/000-default.conf\n\n# Step 3: Inside the <VirtualHost *:80> block, add a redirect rule.\n# Remove any DocumentRoot or other directives. The only purpose of this block is to redirect.\n\n# <VirtualHost *:80>\n#     ServerName www.example.com\n#     Redirect permanent / https://www.example.com/\n# </VirtualHost>\n\n# The 'Redirect permanent' line sends a 301 HTTP status code to the browser, telling it to go to the HTTPS version of the site.\n\n# Step 4: Enable the rewrite module (if not already enabled).\nsudo a2enmod rewrite\n\n# Step 5: Restart Apache.\nsudo systemctl restart apache2\n\n# Step 6: Test it. Open your browser and navigate to 'http://localhost'. \n# You should be automatically and immediately redirected to 'https://localhost'."
          }
        ]
      },
      "quiz": {
        "passingScore": 75,
        "questions": [
          {
            "id": 1,
            "question": "What is the standard TCP port for HTTPS traffic?",
            "options": [
              "80",
              "8080",
              "22",
              "443"
            ],
            "correct": 3,
            "explanation": "Port 80 is for standard HTTP, while port 443 is the universally recognized port for HTTPS."
          },
          {
            "id": 2,
            "question": "In an Apache configuration, which directive is the main switch to turn on SSL/TLS for a virtual host?",
            "options": [
              "SSL on",
              "SSLEngine on",
              "EnableSSL true",
              "HTTPS enable"
            ],
            "correct": 1,
            "explanation": "The `SSLEngine on` directive is required to activate the SSL/TLS processing engine for the specified virtual host. [33, 44]"
          },
          {
            "id": 3,
            "question": "In an Nginx configuration, which file should the `ssl_certificate` directive point to?",
            "options": [
              "Only the private key file.",
              "Only the server's end-entity certificate.",
              "The full chain file (server certificate + intermediate certificates).",
              "The root CA's certificate only."
            ],
            "correct": 2,
            "explanation": "For best practice and to avoid client trust issues, the `ssl_certificate` directive should point to a single file containing your server's certificate followed by the full chain of intermediate CA certificates. [2]"
          },
          {
            "id": 4,
            "question": "What is the purpose of setting up a redirect from HTTP to HTTPS?",
            "options": [
              "To make the website load faster.",
              "To ensure all users connect to the secure version of the site, even if they type or link to the http:// address.",
              "To support older web browsers.",
              "To balance the load between two servers."
            ],
            "correct": 1,
            "explanation": "A permanent redirect ensures 'HTTPS-by-default', protecting users who might navigate to the insecure version of the site by automatically upgrading their connection to be secure."
          }
        ]
      }
    },
    {
      "id": "lesson-15",
      "title": "Mutual TLS (mTLS)",
      "duration": "75 min",
      "objectives": [
        "Define Mutual TLS (mTLS) authentication",
        "Contrast mTLS with standard one-way TLS",
        "Understand the role of client certificates",
        "Identify use cases where mTLS is beneficial (e.g., API security, IoT)"
      ],
      "content": {
        "overview": "Standard TLS authenticates only the server to the client. Mutual TLS (mTLS) takes security a step further by requiring the client to also present a certificate and prove its identity to the server. This lesson explores the concept of two-way authentication and how it's used to secure communications between services and devices.",
        "sections": [
          {
            "title": "Beyond Server Authentication: Two-Way Trust",
            "content": "<p>In a standard HTTPS connection, your browser (the client) verifies the identity of the web server. It checks the server's certificate to ensure it's talking to the legitimate `google.com` and not an imposter. However, the server has no cryptographic proof of the client's identity. It might use passwords or API keys for authentication, but the TLS layer itself doesn't verify the client.</p><p><strong>Mutual TLS (mTLS)</strong>, also known as two-way TLS authentication, closes this gap. In an mTLS handshake, not only does the server present a certificate to the client, but the <strong>client also presents a certificate to the server.</strong> Each party verifies the other's identity, establishing a mutually authenticated and trusted channel. [18]</p>",
            "image": "https://images.unsplash.com/photo-1542382257-80ded13c79c8?w=800&h=400&fit=crop"
          },
          {
            "title": "The mTLS Handshake",
            "content": "<p>The mTLS handshake is an extension of the standard TLS handshake. It includes a few additional steps:</p><ol><li>The handshake begins as usual (ClientHello, ServerHello, Server Certificate).</li><li><strong>CertificateRequest:</strong> After sending its own certificate, the server sends a `CertificateRequest` message to the client. This message specifies the types of certificates it's willing to accept and which Certificate Authorities it trusts.</li><li><strong>Client Certificate:</strong> The client responds by sending its own certificate to the server.</li><li><strong>CertificateVerify:</strong> The client must then prove it possesses the private key corresponding to its certificate. It does this by creating a digital signature over all the previous handshake messages and sending it in a `CertificateVerify` message.</li><li>The server validates the client's certificate against its list of trusted CAs and verifies the `CertificateVerify` signature. If both are successful, the handshake continues and the secure channel is established.</li></ol>",
            "image": "https://images.unsplash.com/photo-1584988228221-82dd9848521a?w=800&h=400&fit=crop"
          },
          {
            "title": "Use Cases for mTLS",
            "content": "<p>mTLS is generally not used for public websites browsed by humans, as distributing and managing certificates for millions of users would be impractical. Instead, it's a powerful tool for 'zero-trust' security models where you can't automatically trust any connection, even within your own network.</p><h3>Common Applications:</h3><ul><li><strong>Service-to-Service Communication:</strong> In microservices architectures, mTLS ensures that only authorized services can communicate with each other. This prevents a compromised service from easily accessing other internal APIs.</li><li><strong>IoT Devices:</strong> mTLS is ideal for authenticating IoT devices connecting to a central server. It provides a strong identity for each device, ensuring that only legitimate, trusted devices can send data or receive commands.</li><li><strong>Securing APIs:</strong> For business-to-business (B2B) APIs, mTLS provides strong client authentication, ensuring that only trusted partners can access sensitive endpoints.</li><li><strong>Mobile Application Security:</strong> mTLS can be used to 'pin' a mobile app to a backend service, preventing reverse-engineered or malicious apps from communicating with the API.</li></ul>",
            "image": "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit=crop"
          }
        ],
        "codeExamples": [
          {
            "title": "Lab: Basic Nginx Configuration for mTLS",
            "language": "bash",
            "code": "# This lab requires a CA, server, and client certificate/key pairs.\n# You would typically set up your own private CA (using OpenSSL or other tools) to issue client certs.\n\n# ASSUMPTIONS:\n# - ca.crt: The public certificate of the CA that signs client certificates.\n# - server.crt / server.key: Your Nginx server's certificate and key.\n\n# Nginx Server Block for mTLS:\n# server {\n#     listen 443 ssl;\n#     server_name secure.api.example.com;\n#\n#     ssl_certificate /path/to/server.crt;\n#     ssl_certificate_key /path/to/server.key;\n#\n#     # --- mTLS Configuration --- #\n#\n#     # 1. Specify the CA certificate to use for verifying client certificates.\n#     ssl_client_certificate /path/to/ca.crt;\n#\n#     # 2. Enforce client certificate verification. 'on' is mandatory, 'optional' allows but doesn't require.\n#     ssl_verify_client on; [18]\n#\n#     # 3. (Optional) Increase the verification depth for intermediate CAs.\n#     ssl_verify_depth 2;\n#\n#     location / {\n#         # You can perform additional checks here if needed.\n#         if ($ssl_client_verify != SUCCESS) {\n#             return 403;\n#         }\n#         proxy_pass http://backend_service;\n#     }\n# }\n\n# --- Testing with cURL ---\n# To test this setup, you need a client certificate and key (client.crt, client.key) issued by your CA.\n# curl --cert client.crt --key client.key https://secure.api.example.com\n\n# A request without a valid client certificate will be rejected by Nginx with an error (e.g., 400 Bad Request)."
          }
        ]
      },
      "quiz": {
        "passingScore": 75,
        "questions": [
          {
            "id": 1,
            "question": "What is the key difference between standard TLS and Mutual TLS (mTLS)?",
            "options": [
              "mTLS uses stronger encryption.",
              "In mTLS, both the client and the server must present certificates to authenticate each other.",
              "mTLS is an older, less secure version of TLS.",
              "mTLS does not require a Certificate Authority."
            ],
            "correct": 1,
            "explanation": "Standard TLS involves one-way authentication (server proves identity to client), while mTLS involves two-way, or mutual, authentication where the client also proves its identity to the server. [18]"
          },
          {
            "id": 2,
            "question": "In an mTLS handshake, which message does the server send to request a certificate from the client?",
            "options": [
              "ClientHello",
              "ServerHello",
              "CertificateRequest",
              "CertificateVerify"
            ],
            "correct": 2,
            "explanation": "The `CertificateRequest` message is the explicit signal from the server to the client, indicating that client authentication is required and specifying the server's trust parameters."
          },
          {
            "id": 3,
            "question": "What does the client send in the `CertificateVerify` message?",
            "options": [
              "Its public key certificate.",
              "A list of cipher suites.",
              "A digital signature over the previous handshake messages to prove it owns the private key.",
              "A session ticket for resumption."
            ],
            "correct": 2,
            "explanation": "The `CertificateVerify` message is the client's proof-of-possession of the private key. By signing the handshake transcript, it proves it's the legitimate owner of the certificate it just presented."
          },
          {
            "id": 4,
            "question": "Which of the following is a common use case for mTLS?",
            "options": [
              "Securing a public-facing blog for general readers.",
              "Providing strong authentication for service-to-service communication in a microservices architecture.",
              "Replacing the need for a web server.",
              "Encrypting data at rest in a database."
            ],
            "correct": 1,
            "explanation": "mTLS is ideal for non-interactive systems like backend services or IoT devices, where cryptographic identity is superior to shared secrets like passwords or API keys."
          }
        ]
      }
    },
    {
      "id": "lesson-16",
      "title": "Certificate Revocation (CRL, OCSP)",
      "duration": "60 min",
      "objectives": [
        "Understand why certificate revocation is a necessary security mechanism",
        "Explain the process of a Certificate Revocation List (CRL)",
        "Explain the process of the Online Certificate Status Protocol (OCSP)",
        "Compare the advantages and disadvantages of CRL vs. OCSP"
      ],
      "content": {
        "overview": "What happens when a private key is compromised before its certificate expires? The certificate needs to be revoked. This lesson covers the two primary mechanisms CAs use to signal that a certificate should no longer be trusted: Certificate Revocation Lists (CRLs) and the Online Certificate Status Protocol (OCSP).",
        "sections": [
          {
            "title": "The Need for Revocation",
            "content": "<p>A TLS certificate is issued with a specific validity period, which could be up to a year or more. However, many situations can arise during that period that require a certificate to be invalidated early. The most critical reason is a <strong>private key compromise</strong>. If an attacker gains access to a server's private key, they can impersonate that server, and the corresponding certificate must be revoked immediately.</p><h3>Other reasons for revocation include:</h3><ul><li>The domain name associated with the certificate has changed ownership.</li><li>The certificate was issued improperly by the CA.</li><li>The organization that owned the certificate has ceased operations.</li></ul><p>Without a revocation mechanism, clients would continue to trust a compromised certificate until its natural expiration date, creating a massive window of vulnerability.</p>",
            "image": "https://images.unsplash.com/photo-1548092372-2d987bde898b?w=800&h=400&fit=crop"
          },
          {
            "title": "Method 1: Certificate Revocation Lists (CRL)",
            "content": "<p>A CRL is the older method for revocation. It is simply a list, maintained and periodically published by a Certificate Authority, of the serial numbers of all the certificates it has revoked. When a client validates a server's certificate, it must also:</p><ol><li>Download the latest CRL from the CA (the URL for the CRL is usually listed in the certificate itself).</li><li>Check if the serial number of the certificate it's evaluating is on that list.</li></ol><h3>Drawbacks of CRLs:</h3><ul><li><strong>Timeliness:</strong> The client only has revocation information that is as fresh as the last published CRL. If a certificate is revoked right after a new CRL is published, there can be a significant delay before clients are notified.</li><li><strong>Size:</strong> As a CA revokes more certificates, the CRL file can grow very large, leading to significant bandwidth consumption and processing overhead for clients.</li></ul>",
            "image": "https://images.unsplash.com/photo-1550751827-463d1a88439e?w=800&h=400&fit=crop"
          },
          {
            "title": "Method 2: Online Certificate Status Protocol (OCSP)",
            "content": "<p>OCSP was designed to address the shortcomings of CRLs. Instead of downloading a potentially huge list, the client can query the CA's OCSP responder (a dedicated server) for the status of a single certificate.</p><p>The process works as follows:</p><ol><li>The client sends a request to the OCSP responder containing the serial number of the certificate in question.</li><li>The responder checks its database and sends back a digitally signed response containing one of three statuses: <strong>Good</strong>, <strong>Revoked</strong>, or <strong>Unknown</strong>.</li></ol><h3>Advantages and Disadvantages of OCSP:</h3><ul><li><strong>Advantage - Timeliness:</strong> OCSP provides much more up-to-date revocation information compared to CRLs.</li><li><strong>Disadvantage - Privacy:</strong> The OCSP request tells the CA exactly which website the user is visiting at that moment, which has significant privacy implications.</li><li><strong>Disadvantage - Performance and Reliability:</strong> The browser must make an additional request to the OCSP responder during the initial connection, which can add latency. If the OCSP responder is down, it can cause the connection to fail (hard-fail) or proceed without a check (soft-fail), creating a difficult trade-off between availability and security.</li></ul><h3>OCSP Stapling:</h3><p>To solve the performance and privacy issues of OCSP, <strong>OCSP Stapling</strong> was developed. With stapling, the web server itself periodically queries the OCSP responder for its certificate's status. It then 'staples' this signed, timestamped OCSP response to its own certificate and sends both to the client during the TLS handshake. This allows the client to get proof of certificate status directly from the server, without needing to contact the CA itself.</p>",
            "image": "https://images.unsplash.com/photo-1594708911226-9f874ce5a535?w=800&h=400&fit=crop"
          }
        ],
        "codeExamples": [
          {
            "title": "Lab: Test OCSP Response for a Certificate",
            "language": "bash",
            "code": "# We can use OpenSSL to act as an OCSP client and query the status of a certificate.\n\n# Step 1: Get the server's certificate and the issuer's (intermediate) certificate.\n# The openssl s_client command can show the full chain. We need to save the server cert and the intermediate cert to separate files.\n\n# First, connect and display the chain.\nopenssl s_client -connect www.google.com:443 -showcerts -servername www.google.com < /dev/null\n\n# Copy the server's certificate (the first one) into a file named 'cert.pem'.\n# Copy the next certificate in the chain (the issuer) into 'issuer.pem'.\n\n# Step 2: Find the OCSP responder URI from the certificate.\nopenssl x509 -in cert.pem -noout -ocsp_uri\n\n# This will print the URL of the OCSP server, for example: http://ocsp.pki.goog/gtsr1\n\n# Step 3: Send the OCSP request.\n# Use the `openssl ocsp` command with the issuer certificate, the server certificate, and the responder URL.\nopenssl ocsp -issuer issuer.pem -cert cert.pem -url `openssl x509 -in cert.pem -noout -ocsp_uri` -text\n\n# Step 4: Analyze the response.\n# The output will tell you the OCSP Response Status (e.g., successful) and the certificate status.\n# You should see: `cert.pem: good` indicating the certificate is valid and not revoked."
          }
        ]
      },
      "quiz": {
        "passingScore": 75,
        "questions": [
          {
            "id": 1,
            "question": "What is the primary reason for revoking a certificate?",
            "options": [
              "The website's content has changed.",
              "The certificate's corresponding private key has been compromised.",
              "The server's IP address has changed.",
              "The certificate is about to expire naturally."
            ],
            "correct": 1,
            "explanation": "If a private key is stolen, an attacker can impersonate the server. Revoking the certificate is the critical step to tell clients not to trust it anymore."
          },
          {
            "id": 2,
            "question": "What is a Certificate Revocation List (CRL)?",
            "options": [
              "A real-time query protocol for certificate status.",
              "A list of expired certificates.",
              "A file published by a CA containing the serial numbers of all certificates it has invalidated.",
              "A list of trusted Certificate Authorities."
            ],
            "correct": 2,
            "explanation": "A CRL is a list of revoked certificates. Clients must download this list and check it to ensure a certificate they are presented with has not been revoked."
          },
          {
            "id": 3,
            "question": "What is a major disadvantage of the standard OCSP protocol for clients?",
            "options": [
              "It is slower than CRLs because the lists are bigger.",
              "It leaks user privacy by telling the CA which sites are being visited.",
              "It only works for a few specific types of certificates.",
              "It is no longer supported by modern browsers."
            ],
            "correct": 1,
            "explanation": "Because the client directly queries the CA's OCSP responder about a specific certificate, it reveals the client's browsing habits to the CA, which is a significant privacy concern."
          },
          {
            "id": 4,
            "question": "How does OCSP Stapling improve upon the original OCSP protocol?",
            "options": [
              "It allows the web server to fetch the OCSP response itself and send it to the client, improving privacy and performance.",
              "It uses a stronger encryption algorithm for OCSP responses.",
              "It combines multiple CRLs into one file.",
              "It removes the need for a CA entirely."
            ],
            "correct": 0,
            "explanation": "With OCSP Stapling, the server takes on the burden of querying the OCSP responder. It then 'staples' the signed response to its certificate during the handshake, so the client doesn't need to make a separate, slow, and privacy-leaking connection to the CA."
          }
        ]
      }
    },
    {
      "id": "lesson-17",
      "title": "TLS Attacks",
      "duration": "60 min",
      "objectives": [
        "Recognize that even with strong cryptography, implementation flaws can lead to vulnerabilities",
        "Understand the high-level concepts behind historical attacks like Heartbleed, POODLE, and BEAST",
        "Explain how protocol downgrades can expose clients to older, weaker versions of TLS",
        "Appreciate the importance of keeping server software and libraries updated"
      ],
      "content": {
        "overview": "The history of SSL/TLS is marked by a continuous cycle of discovered vulnerabilities and protocol improvements. Understanding famous historical attacks is not just a history lesson; it provides crucial insights into why modern TLS is designed the way it is and the importance of proper configuration. This lesson covers some of the most impactful TLS attacks.",
        "sections": [
          {
            "title": "Implementation Flaws vs. Protocol Flaws",
            "content": "<p>Vulnerabilities in the TLS ecosystem can be broadly categorized into two types:</p><ul><li><strong>Protocol Flaws:</strong> These are weaknesses in the design of the SSL/TLS protocol itself. These often require a new version of the protocol to fix. The vulnerabilities in SSL 3.0 are an example.</li><li><strong>Implementation Flaws:</strong> These are bugs in a specific piece of software that implements the protocol, such as a library like OpenSSL or a web server like Apache. The cryptographic concepts might be sound, but the code written to perform them is flawed.</li></ul><p>The attacks below include examples of both, demonstrating the need for both strong protocol design and careful software engineering.</p>",
            "image": "https://images.unsplash.com/photo-1563206410-182f5b5f8845?w=800&h=400&fit=crop"
          },
          {
            "title": "Famous Historical Attacks",
            "content": "<h3>BEAST (Browser Exploit Against SSL/TLS) - 2011</h3><p>BEAST was an attack against TLS 1.0 that exploited a weakness in how Cipher Block Chaining (CBC) mode ciphers were used. By being able to predict the 'Initialization Vector' (IV) for the next block, an attacker in a Man-in-the-Middle position could slowly decrypt parts of an encrypted session, such as a session cookie. The primary fix was a move to more secure ciphers, and modern TLS 1.3 has removed CBC mode ciphers entirely.</p><h3>POODLE (Padding Oracle On Downgraded Legacy Encryption) - 2014</h3><p>POODLE was an attack that exploited a vulnerability in the SSL 3.0 protocol. It took advantage of the fact that when a modern client fails to connect to a server, it may attempt to 'downgrade' the protocol version and try again. An attacker could force a downgrade to the vulnerable SSL 3.0. POODLE, like BEAST, was a padding oracle attack that allowed an attacker to decrypt parts of the traffic byte-by-byte. The mitigation was decisive: completely disable SSL 3.0 on all clients and servers.</p><h3>Heartbleed - 2014</h3><p>Perhaps the most famous TLS bug, Heartbleed was not a flaw in the TLS protocol itself, but a catastrophic implementation bug in the OpenSSL library. A feature in OpenSSL called the 'Heartbeat Extension' allowed a client to send some data and request that the server send it back, to keep the connection alive. However, the code failed to check the length of the data. An attacker could send a small request but lie and claim it was much larger (e.g., 64 kilobytes). The vulnerable OpenSSL server would read the small request and then return 64 KB of whatever was in its memory at the time. This memory could contain private keys, passwords, session tokens, and other extremely sensitive data. The fix was to patch the OpenSSL software to properly check the data length.</p>",
            "image": "https://images.unsplash.com/photo-1548092372-2d987bde898b?w=800&h=400&fit=crop"
          }
        ],
        "codeExamples": [
          {
            "title": "Lab: Test for Weak Ciphers with SSL Labs",
            "language": "bash",
            "code": "# While we cannot (and should not) replicate these dangerous attacks, we can use tools to scan a server for weaknesses that might make it vulnerable.\n# The Qualys SSL Labs Server Test is the industry-standard online tool for this.\n\n# Step 1: Open a web browser and navigate to:\n# https://www.ssllabs.com/ssltest/\n\n# Step 2: Enter the hostname of a public website you want to test (e.g., your own blog, or a major site like www.google.com) and click 'Submit'.\n\n# The test may take a few minutes to run as it performs a comprehensive analysis.\n\n# Step 3: Analyze the results.\n# - You will get an overall grade (A+ is the best).\n# - Look at the 'Configuration' section.\n# - 'Protocols': This will show you if the server supports insecure protocols like SSL 2.0/3.0 or TLS 1.0/1.1.\n# - 'Cipher Suites': This section lists all the cipher suites the server offers. It will flag any that are considered 'WEAK'.\n# - The report also checks for vulnerability to major attacks like POODLE and includes details on certificate validity, handshake simulation with various clients, and more.\n\n# Using this tool is a critical step in auditing the security of any public-facing web server."
          }
        ]
      },
      "quiz": {
        "passingScore": 75,
        "questions": [
          {
            "id": 1,
            "question": "What was the nature of the Heartbleed vulnerability?",
            "options": [
              "A flaw in the design of the TLS 1.2 protocol.",
              "A software bug in the OpenSSL library that led to a memory leak.",
              "An attack that forced connections to downgrade to SSL 3.0.",
              "A weakness in the RSA encryption algorithm."
            ],
            "correct": 1,
            "explanation": "Heartbleed was a classic example of an implementation flaw, not a protocol flaw. A missing bounds check in the OpenSSL code allowed attackers to read sensitive data from a server's memory."
          },
          {
            "id": 2,
            "question": "The POODLE attack primarily targeted which insecure protocol?",
            "options": [
              "TLS 1.3",
              "TLS 1.2",
              "SSL 3.0",
              "HTTP"
            ],
            "correct": 2,
            "explanation": "POODLE exploited a vulnerability in the padding of SSL 3.0's CBC mode ciphers. The attack often began by tricking browsers into downgrading their connection to this vulnerable protocol."
          },
          {
            "id": 3,
            "question": "What is a 'protocol downgrade' attack?",
            "options": [
              "An attack that reduces the server's bandwidth.",
              "An attack where a malicious actor forces a client and server to negotiate a connection using an older, weaker version of a protocol like SSL 3.0.",
              "An attack that steals a server's private key.",
              "An attack that uses an invalid certificate."
            ],
            "correct": 1,
            "explanation": "Downgrade attacks are a serious threat. A server may support the secure TLS 1.3, but if it also allows insecure SSL 3.0 for legacy reasons, an attacker can actively interfere with the handshake to force the use of the weaker protocol."
          },
          {
            "id": 4,
            "question": "What is the single most effective defense against known TLS implementation vulnerabilities like Heartbleed?",
            "options": [
              "Using self-signed certificates.",
              "Disabling HTTPS entirely.",
              "Keeping your server software (e.g., OpenSSL, Nginx, Apache) and libraries patched and up-to-date.",
              "Using longer passwords."
            ],
            "correct": 2,
            "explanation": "Vulnerabilities in software are discovered regularly. Applying security patches and updates in a timely manner is the most critical operational security practice for defending against them."
          }
        ]
      }
    },
    {
      "id": "lesson-18",
      "title": "TLS in Email (SMTPS, STARTTLS)",
      "duration": "60 min",
      "objectives": [
        "Understand that TLS is used to secure more than just web traffic",
        "Differentiate between implicit TLS (SMTPS) and explicit TLS (STARTTLS)",
        "Identify the standard ports for secure email protocols (SMTPS, IMAPS, POP3S)",
        "Use OpenSSL to test a mail server's support for STARTTLS"
      ],
      "content": {
        "overview": "Transport Layer Security is a versatile protocol used to secure many forms of communication, not just HTTPS. This lesson explores its critical role in securing email transmission protocols like SMTP, IMAP, and POP3. We will cover the two primary methods for enabling TLS for email: implicit TLS on a dedicated port and explicit TLS via the STARTTLS command.",
        "sections": [
          {
            "title": "Securing Email Protocols",
            "content": "<p>By default, the core email protocols were designed as plaintext protocols, just like HTTP. Without encryption, anyone could intercept and read emails as they travel from your email client to your server, and between mail servers.</p><ul><li><strong>SMTP (Simple Mail Transfer Protocol):</strong> Used for sending email.</li><li><strong>IMAP (Internet Message Access Protocol):</strong> Used for retrieving and managing email on a server.</li><li><strong>POP3 (Post Office Protocol 3):</strong> A simpler protocol for downloading email from a server.</li></ul><p>To fix this, TLS is applied to these protocols to provide the same confidentiality, integrity, and authentication that it provides for web traffic.</p>",
            "image": "https://images.unsplash.com/photo-1596526131034-9b8d239102b4?w=800&h=400&fit=crop"
          },
          {
            "title": "Implicit vs. Explicit TLS",
            "content": "<p>There are two ways to initiate a TLS-secured email connection:</p><h3>1. Implicit TLS (SSL/TLS on a specific port)</h3><p>In this mode, a dedicated TCP port is assigned for a TLS-only version of the protocol. The client is expected to initiate a TLS handshake immediately upon connecting to this port. The connection is encrypted from the very beginning. These protocols are often denoted with an 'S' at the end.</p><ul><li><strong>SMTPS:</strong> SMTP over TLS, typically on port <strong>465</strong>.</li><li><strong>IMAPS:</strong> IMAP over TLS, typically on port <strong>993</strong>.</li><li><strong>POP3S:</strong> POP3 over TLS, typically on port <strong>995</strong>.</li></ul><h3>2. Explicit TLS (STARTTLS)</h3><p>In this mode, the client connects to the standard, unencrypted port for the protocol (e.g., port 25 or 587 for SMTP). The initial communication happens in plaintext. The client then issues a special command, `STARTTLS`, to signal that it wants to upgrade the connection to a secure one. [49] If the server supports it, they perform a TLS handshake, and all subsequent communication on that same connection is encrypted. [16] This method has the advantage of allowing a single port to serve both plaintext (legacy) and encrypted traffic.</p><ul><li><strong>SMTP with STARTTLS:</strong> Typically on ports <strong>25</strong> (server-to-server) and <strong>587</strong> (client submission).</li><li><strong>IMAP with STARTTLS:</strong> Typically on port <strong>143</strong>.</li><li><strong>POP3 with STARTTLS:</strong> Typically on port <strong>110</strong>.</li></ul><div class=\"info-box note\"><div class=\"info-box-header\"><i class=\"fas fa-info-circle\"></i><strong>Which to Use?</strong></div><p>Modern best practice strongly favors using Implicit TLS (ports 465, 993, 995) for client-to-server connections, as it guarantees encryption from the start and avoids the risk of misconfigurations that could leak credentials before STARTTLS is issued. The `STARTTLS` command on port 587 is also a very common and secure configuration. Port 25 is primarily for server-to-server mail exchange and also commonly uses STARTTLS.</p></div>",
            "image": "https://images.unsplash.com/photo-1587593226344-934a5a5448ee?w=800&h=400&fit=crop"
          }
        ],
        "codeExamples": [
          {
            "title": "Lab: Test STARTTLS with OpenSSL",
            "language": "bash",
            "code": "# We can use the openssl s_client command to test if a mail server supports STARTTLS.\n# The -starttls flag tells s_client to connect and then issue the appropriate command for the protocol.\n\n# --- Test SMTP STARTTLS on Port 587 ---\n# The `-starttls smtp` option will make the initial connection and then send the `STARTTLS` command.\n# If successful, it will perform a TLS handshake and show you the server's certificate.\nopenssl s_client -connect smtp.gmail.com:587 -starttls smtp\n\n# After connecting, the server will show a '220' greeting, and openssl will negotiate TLS. \n# Look for the '250 DSN' or similar response after the handshake, indicating success. [48]\n# You can then type `EHLO testing.com` and hit Enter to see the server's capabilities over the encrypted channel.\n\n# --- Test IMAP STARTTLS on Port 143 ---\n# The process is similar, but the protocol name changes.\nopenssl s_client -connect imap.gmail.com:143 -starttls imap\n\n# --- Test SMTPS (Implicit TLS) on Port 465 ---\n# For implicit TLS, no -starttls flag is needed, as the handshake starts immediately.\nopenssl s_client -connect smtp.gmail.com:465\n\n# Comparing the output of these commands demonstrates the difference between initiating an upgrade (STARTTLS) and connecting directly with encryption (Implicit TLS)."
          }
        ]
      },
      "quiz": {
        "passingScore": 75,
        "questions": [
          {
            "id": 1,
            "question": "What is the purpose of STARTTLS?",
            "options": [
              "To check if an email server is online.",
              "To upgrade an existing unencrypted connection to an encrypted one.",
              "To send email using HTTP.",
              "To connect directly to a dedicated encrypted port."
            ],
            "correct": 1,
            "explanation": "STARTTLS is a protocol command that allows a client and server to take an existing plaintext connection and elevate it to a secure, TLS-encrypted connection. [49]"
          },
          {
            "id": 2,
            "question": "What is the key difference between implicit TLS (e.g., SMTPS) and explicit TLS (e.g., STARTTLS)?",
            "options": [
              "Implicit TLS is less secure.",
              "Implicit TLS starts with an immediate TLS handshake on a dedicated port, while explicit TLS starts in plaintext and is then upgraded.",
              "Explicit TLS uses a different type of certificate.",
              "There is no difference; the terms are interchangeable."
            ],
            "correct": 1,
            "explanation": "Implicit TLS means the connection is encrypted from the very start on a special port (like 465 for SMTPS). Explicit TLS means the connection starts on a standard port (like 587) and is then explicitly upgraded to TLS via a command."
          },
          {
            "id": 3,
            "question": "Which TCP port is conventionally used for SMTPS (SMTP over implicit TLS)?",
            "options": [
              "25",
              "110",
              "587",
              "465"
            ],
            "correct": 3,
            "explanation": "Port 465 is the well-known port for implicit SMTP over SSL/TLS, where encryption begins immediately."
          },
          {
            "id": 4,
            "question": "Which `openssl s_client` flag is used to test a mail server's STARTTLS capability for SMTP?",
            "options": [
              "-implicit_tls",
              "-email",
              "-starttls smtp",
              "-upgrade_smtp"
            ],
            "correct": 2,
            "explanation": "The `-starttls` flag followed by the protocol name (smtp, imap, pop3, etc.) instructs `openssl s_client` to perform the explicit TLS upgrade procedure. [48]"
          }
        ]
      }
    },
    {
      "id": "lesson-19",
      "title": "TLS in VPNs & Applications",
      "duration": "60 min",
      "objectives": [
        "Understand that TLS is a general-purpose security protocol",
        "Explain how TLS is used as the control and data channel for modern VPNs like OpenVPN",
        "Recognize that many applications use TLS for secure communication without user interaction",
        "Contrast TLS-based VPNs with other types like IPsec"
      ],
      "content": {
        "overview": "Beyond browsers and email, TLS serves as a fundamental security building block for a vast range of applications, most notably Virtual Private Networks (VPNs). This lesson explores how TLS is used to create secure tunnels for network traffic in VPNs like OpenVPN and discusses its broader application in the software world.",
        "sections": [
          {
            "title": "TLS as a General-Purpose Protocol",
            "content": "<p>While HTTPS is the most visible use of TLS, it's important to remember that TLS is a transport-layer security protocol. It is designed to secure any communication protocol that runs over a reliable transport like TCP. This makes it incredibly versatile.</p><p>Any application that needs to establish a secure channel between a client and a server for sending arbitrary data can leverage TLS. The application's own protocol data is simply treated as the 'application data' that gets encrypted by the TLS record protocol after a successful handshake. This provides a standardized, well-vetted framework for adding encryption to any application, without having to reinvent the wheel.</p>",
            "image": "https://images.unsplash.com/photo-1526374965328-5f61d25c0e40?w=800&h=400&fit=crop"
          },
          {
            "title": "OpenVPN: A TLS-Powered VPN",
            "content": "<p>A Virtual Private Network (VPN) creates a secure, encrypted 'tunnel' over a public network (like the internet) to connect a user to a private network. Many modern VPN solutions, with OpenVPN being one of the most popular and respected, are built directly on top of SSL/TLS.</p><h3>How OpenVPN uses TLS:</h3><ul><li><strong>Control Channel:</strong> OpenVPN first establishes a TLS session between the client and the VPN server. This connection, known as the control channel, uses a standard TLS handshake (often with mTLS for strong client authentication) to exchange keys and configuration parameters. The certificates used here are critical for authenticating both the server and the client.</li><li><strong>Data Channel:</strong> The keys exchanged over the secure control channel are then used to encrypt the actual network traffic (the data channel). The user's IP packets are encapsulated, encrypted using a fast symmetric cipher (like AES), and sent through the TLS tunnel.</li></ul><p>This design effectively uses the TLS standard to create a robust and secure point-to-point connection, tunneling all the user's internet traffic through it. Because it uses TLS, OpenVPN traffic can run over any standard TCP or UDP port, making it very flexible and difficult to block.</p>",
            "image": "https://images.unsplash.com/photo-1584950333252-23c8a32a6881?w=800&h=400&fit=crop"
          },
          {
            "title": "Other VPN Protocols and Applications",
            "content": "<h3>IPsec: A Different Approach</h3><p>It's useful to contrast TLS-based VPNs with another major VPN protocol suite, <strong>IPsec (Internet Protocol Security)</strong>. IPsec operates at a lower level of the network stack (the IP layer) than TLS (the transport layer). This means it can encrypt all IP traffic transparently, regardless of the transport protocol (TCP, UDP, etc.). While very powerful and widely used, especially for site-to-site VPNs, IPsec is often considered more complex to configure than TLS-based solutions like OpenVPN.</p><h3>TLS in Everyday Applications:</h3><p>Countless applications use TLS behind the scenes every day. When your messaging app sends an end-to-end encrypted message, its connection to the server for relaying that message is almost certainly protected by TLS. When a desktop application checks for updates, it connects to the update server over a TLS-secured channel. Any time an application needs to securely exchange data with a remote server, TLS is the go-to solution.</p>",
            "image": "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit=crop"
          }
        ],
        "codeExamples": [
          {
            "title": "Lab: Basic OpenVPN Server Configuration Snippet",
            "language": "bash",
            "code": "# This is a conceptual example of a minimal OpenVPN server.conf file.\n# It highlights the directives that relate to TLS and certificate usage.\n\n# --- OpenVPN server.conf Example ---\n\n# Specify the port and protocol (TCP or UDP).\nport 1194\nproto udp\n\n# Specify the TUN/TAP device.\ndev tun\n\n# --- TLS Certificate Configuration ---\n\n# CA certificate that signs the server and client certificates.\nca /etc/openvpn/ca.crt\n\n# Server's public certificate.\ncert /etc/openvpn/server.crt\n\n# Server's private key. Must be kept secret.\nkey /etc/openvpn/server.key\n\n# Parameters for Diffie-Hellman key exchange (for forward secrecy).\ndh /etc/openvpn/dh.pem\n\n# Specify TLS authentication and cipher settings.\ntls-crypt /etc/openvpn/ta.key\ncipher AES-256-GCM\nauth SHA256\n\n# This configuration shows that at its core, an OpenVPN server is a TLS server that requires\n# a CA, a server certificate, and a server key, just like a web server."
          }
        ]
      },
      "quiz": {
        "passingScore": 75,
        "questions": [
          {
            "id": 1,
            "question": "Which popular VPN protocol is built directly on top of the SSL/TLS standards?",
            "options": [
              "IPsec",
              "PPTP",
              "L2TP",
              "OpenVPN"
            ],
            "correct": 3,
            "explanation": "OpenVPN is well-known for using the SSL/TLS library (like OpenSSL) to provide both the control channel (key exchange) and data channel (encryption) for its VPN tunnels."
          },
          {
            "id": 2,
            "question": "In OpenVPN, what is the 'control channel' used for?",
            "options": [
              "Transmitting the user's actual internet traffic.",
              "Establishing a TLS session to authenticate peers and exchange symmetric keys for the data channel.",
              "Routing packets on the local network.",
              "Compressing data before it is sent."
            ],
            "correct": 1,
            "explanation": "The control channel is the initial TLS connection that handles authentication and the secure generation/exchange of the keys that will be used to encrypt the user's bulk data."
          },
          {
            "id": 3,
            "question": "What is a major advantage of TLS-based VPNs compared to IPsec?",
            "options": [
              "They are generally considered less secure.",
              "They can operate at a lower level of the network stack.",
              "They are often simpler to configure and can run over standard ports like TCP 443, making them hard to block.",
              "They do not require certificates."
            ],
            "correct": 2,
            "explanation": "TLS's ability to run over common ports like TCP 443 (the same as HTTPS) makes it resilient to firewall blocking. IPsec, using different protocols, is sometimes easier to identify and block on restrictive networks."
          },
          {
            "id": 4,
            "question": "At which layer of the OSI model does TLS primarily operate?",
            "options": [
              "Layer 2 (Data Link)",
              "Layer 3 (Network)",
              "Layer 4/5 (Transport/Session)",
              "Layer 7 (Application)"
            ],
            "correct": 2,
            "explanation": "TLS operates above the Transport layer (TCP) to secure communications for Application layer protocols. It is often considered to exist between the Transport and Application layers, sometimes mapped to the Session layer."
          }
        ]
      }
    },
    {
      "id": "lesson-20",
      "title": "Best Practices for TLS Deployment",
      "duration": "75 min",
      "objectives": [
        "Understand the importance of a strong, modern TLS configuration",
        "Recognize the need to disable old protocols and weak ciphers",
        "Explain the purpose of HSTS (HTTP Strict Transport Security)",
        "Learn how to harden a web server's TLS configuration"
      ],
      "content": {
        "overview": "Implementing TLS is more than just installing a certificate; it's about configuring it correctly for maximum security. This final lesson synthesizes the course content into a set of actionable best practices for deploying TLS on a modern web server, focusing on protocol selection, cipher suite strength, and advanced security headers like HSTS.",
        "sections": [
          {
            "title": "The Principle of a Strong Configuration",
            "content": "<p>A TLS deployment is only as secure as its configuration. A server with a valid certificate can still be vulnerable if it supports weak protocols, insecure cipher suites, or is susceptible to downgrade attacks. The goal of a modern TLS configuration is to enforce the use of the strongest available security parameters that are compatible with the intended clients.</p><h3>Key Configuration Goals:</h3><ul><li><strong>Use Strong Protocols:</strong> Only enable TLS 1.2 and TLS 1.3. Explicitly disable SSLv2, SSLv3, TLS 1.0, and TLS 1.1.</li><li><strong>Use Strong Cipher Suites:</strong> Prioritize modern, forward-secret cipher suites. For TLS 1.2, this means ECDHE suites with AES-GCM or ChaCha20-Poly1305. For TLS 1.3, the default suites are already strong.</li><li><strong>Use Strong Keys:</strong> Server certificates should use at least a 2048-bit RSA key or a 256-bit ECC key. The Diffie-Hellman parameters should also be strong (at least 2048-bit).</li><li><strong>Protect the Private Key:</strong> The server's private key must be protected with strict file permissions, accessible only by the root user and the web server process.</li></ul>",
            "image": "https://images.unsplash.com/photo-1542382257-80ded13c79c8?w=800&h=400&fit=crop"
          },
          {
            "title": "HTTP Strict Transport Security (HSTS)",
            "content": "<p>Simply redirecting HTTP to HTTPS isn't enough to completely protect against some attacks. A user's very first visit to your site over HTTP could still be intercepted in a Man-in-the-Middle attack before the redirect to HTTPS happens. This is solved with HSTS.</p><p><strong>HTTP Strict Transport Security (HSTS)</strong> is a security policy mechanism that you configure on your server. It is delivered to the browser as an HTTP response header. The header tells the browser that it should <em>only</em> communicate with the site using HTTPS for a specified period.</p><h3>Example HSTS Header:</h3><p><code>Strict-Transport-Security: max-age=31536000; includeSubDomains</code></p><ul><li><strong><code>max-age=31536000</code>:</strong> This tells the browser to remember this policy for 31,536,000 seconds (1 year). During this time, if the user types `http://example.com` or follows an HTTP link, the browser will automatically change it to `https://example.com` internally, without ever sending the insecure request over the network.</li><li><strong><code>includeSubDomains</code>:</strong> This optional directive applies the policy to all of the site's subdomains as well.</li></ul><p>HSTS effectively eliminates the threat of SSL stripping MITM attacks for returning visitors.</p>",
            "image": "https://images.unsplash.com/photo-1510511459019-5dda7724fd87?w=800&h=400&fit=crop"
          },
          {
            "title": "Other Important Practices",
            "content": "<ul><li><strong>Enable OCSP Stapling:</strong> This improves performance and privacy for certificate revocation checks. Web servers like Nginx and Apache have simple directives to enable it.</li><li><strong>Regularly Audit Your Configuration:</strong> Use tools like the SSL Labs Server Test (from the previous lesson) periodically to check your configuration and ensure it remains strong and isn't vulnerable to new attacks.</li><li><strong>Automate Certificate Renewal:</strong> Use tools like Certbot for Let's Encrypt certificates to automatically handle the renewal process. This prevents outages due to expired certificates.</li><li><strong>Keep Software Updated:</strong> Regularly update your web server software, and especially your TLS/SSL library (like OpenSSL or LibreSSL), to ensure you have the latest security patches.</li></ul>",
            "image": "https://images.unsplash.com/photo-1594708911226-9f874ce5a535?w=800&h=400&fit=crop"
          }
        ],
        "codeExamples": [
          {
            "title": "Lab: Harden an Nginx TLS Configuration",
            "language": "bash",
            "code": "# This example shows a hardened TLS configuration block for Nginx.\n\n# server {\n#     listen 443 ssl http2;\n#     server_name www.example.com;\n#\n#     # Certificate and Key\n#     ssl_certificate /path/to/fullchain.pem;\n#     ssl_certificate_key /path/to/privatekey.pem;\n#\n#     # --- Hardening Directives ---\n#\n#     # 1. Only enable strong protocols.\n#     ssl_protocols TLSv1.2 TLSv1.3;\n#\n#     # 2. Set a strong, modern cipher list for TLS 1.2.\n#     # (TLS 1.3 ciphers are configured separately and are strong by default).\n#     ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384';\n#\n#     # 3. Tell the server to prefer its own cipher order over the client's.\n#     ssl_prefer_server_ciphers off; # In HTTP/2 and TLS 1.3, this is handled differently\n#\n#     # 4. Enable OCSP Stapling.\n#     ssl_stapling on;\n#     ssl_stapling_verify on;\n#     ssl_trusted_certificate /path/to/fullchain.pem; # Must point to the chain file for verification.\n#\n#     # 5. Add the HSTS header (start with a low max-age for testing).\n#     add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains\" always;\n#\n#     # Further configuration...\n# }\n\n# NOTE: Always test your configuration changes with `nginx -t` before reloading.\n# After applying these settings, run your domain through the SSL Labs test again to see the improvement."
          }
        ]
      },
      "quiz": {
        "passingScore": 75,
        "questions": [
          {
            "id": 1,
            "question": "Which of the following protocol combinations represents a modern, secure configuration?",
            "options": [
              "Enable SSLv3 and TLS 1.0 for compatibility.",
              "Enable only TLS 1.2 and TLS 1.3.",
              "Enable all versions of SSL and TLS.",
              "Enable only TLS 1.1."
            ],
            "correct": 1,
            "explanation": "Best practice is to disable all legacy protocols (SSLv2, SSLv3, TLS 1.0, TLS 1.1) as they have known vulnerabilities, and only permit connections via the secure TLS 1.2 and TLS 1.3 protocols."
          },
          {
            "id": 2,
            "question": "What is the purpose of the HTTP Strict Transport Security (HSTS) header?",
            "options": [
              "To report security errors to the server owner.",
              "To select which cipher suite the browser should use.",
              "To instruct the browser to only connect to the site using HTTPS for a specified period.",
              "To encrypt the HTTP headers."
            ],
            "correct": 2,
            "explanation": "HSTS is a crucial security mechanism that protects against SSL stripping attacks by forcing the browser to use HTTPS exclusively, preventing any initial insecure HTTP connections for returning visitors."
          },
          {
            "id": 3,
            "question": "What does 'Perfect Forward Secrecy' ensure?",
            "options": [
              "The connection will never drop.",
              "The server's certificate will never expire.",
              "If the server's long-term private key is compromised, past encrypted sessions cannot be decrypted.",
              "All data is compressed perfectly."
            ],
            "correct": 2,
            "explanation": "Forward secrecy, provided by ephemeral key exchange methods like ECDHE, is a critical feature that protects past sessions from future key compromises."
          },
          {
            "id": 4,
            "question": "What is OCSP Stapling?",
            "options": [
              "A method to combine multiple certificates into one file.",
              "A system where the web server fetches the certificate status for the client, improving performance and privacy.",
              "A new type of TLS attack.",
              "A requirement for using ECC certificates."
            ],
            "correct": 1,
            "explanation": "OCSP Stapling allows the server to proactively get its own certificate's revocation status from the CA and 'staple' it to the handshake. This saves the client from having to make a separate, privacy-compromising call to the CA."
             },
              ],
            },
          },
        ],
      };
// =====================================================
// GLOBAL VARIABLES
// =====================================================
let currentUser = null;
let currentLessonIndex = 0;
let courseProgress = {};
let userStats = {};
let quizState = {
    currentQuestion: 0,
    answers: [],
    score: 0,
    isComplete: false
};

// Enhanced session tracking
let courseSession = {
    startTime: null,
    totalStudyTime: 0,
    lessonsStarted: 0,
    lessonsCompleted: 0,
    pageLoadTime: new Date(),
    interactionCount: 0,
    lastActivityTime: new Date()
};

// Music Player Variables
let audioPlayer = new Audio();

// Achievement notification system
let notificationQueue = [];
let isShowingNotification = false;

// =====================================================
// INITIALIZATION
// =====================================================
document.addEventListener('DOMContentLoaded', async () => {
    try {
        showLoadingScreen();
        await checkAuth();
        
        if (currentUser) {
            // Initialize session tracking
            startCourseSession();
            
            // Load course data and progress
            await loadCourseData();
            await loadUserProfile();
            await loadProgress();
            
            // Initialize UI
            initializeEventListeners();
            renderSidebar();
            loadLesson(currentLessonIndex);
            
            // Initialize additional features
            initMusicPlayer();
            addMusicIndicator();
            initializeActivityTracking();
            
            hideLoadingScreen();
        } else {
            openAuthModal();
        }
    } catch (error) {
        console.error('Error initializing course:', error);
        hideLoadingScreen();
        showToast('Failed to initialize course system', 'error');
    }
});

// =====================================================
// AUTHENTICATION SYSTEM
// =====================================================
async function checkAuth() {
    try {
        const { data: { session }, error } = await supabase.auth.getSession();
        
        if (error) {
            console.error('Auth error:', error);
            currentUser = null;
            openAuthModal();
            return;
        }

        if (!session) {
            currentUser = null;
            openAuthModal();
            return;
        }

        currentUser = session.user;
        updateUIWithUser();
    } catch (error) {
        console.error('Error checking auth:', error);
        currentUser = null;
        openAuthModal();
    }
}

function updateUIWithUser() {
    if (!currentUser) return;
    
    const name = currentUser.user_metadata?.full_name || currentUser.email.split('@')[0];
    const userElements = document.querySelectorAll('[data-user-name]');
    userElements.forEach(el => el.textContent = name);
}

// =====================================================
// USER PROFILE & STATS MANAGEMENT
// =====================================================
async function loadUserProfile() {
  try {
    // 🔍 Step 1: Try to fetch existing profile
    const { data: profile, error } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', currentUser.id)
      .single();

    if (error && error.code !== 'PGRST116') {
      throw error;
    }

    if (!profile) {
      // 🆕 Step 2: Create new profile if missing
      await createUserProfile();
    } else {
      // ✅ Step 3: Use existing profile
      userStats = profile;
      await updateLastActivity();
    }

  } catch (error) {
    console.error('❌ Error loading user profile:', error);
    showToast('Failed to load user profile', 'error');
  }
}
async function createUserProfile() {
    try {
        const newProfile = {
            id: currentUser.id,
            full_name: currentUser.user_metadata?.full_name || '',
            email: currentUser.email,
            level: 'Script Kiddie',
            total_points: 0,
            completed_courses: 0,
            current_streak: 0,
            total_certificates: 0,
            total_achievements: 0,
            sections_visited: 0,
            bonus_points: 0,
            in_progress_courses: 0,
            settings_changed: 0,
            midnight_sessions: 0,
            early_sessions: 0,
            weekend_sessions: 0,
            last_activity: new Date().toISOString(),
            created_at: new Date().toISOString()
        };

        const { error } = await supabase
            .from('profiles')
            .insert([newProfile]);

        if (!error) {
            userStats = newProfile;
            // Award first login achievement
            setTimeout(() => checkAndUnlockAchievement('first_login'), 1000);
        }
    } catch (error) {
        console.error('Error creating user profile:', error);
    }
}

async function updateLastActivity() {
    try {
        const now = new Date();
        
        // Update activity tracking
        courseSession.lastActivityTime = now;
        
        // Update database
        await supabase
            .from('profiles')
            .update({ 
                last_activity: now.toISOString()
            })
            .eq('id', currentUser.id);

        // Check time-based achievements
        await checkTimeBasedAchievements(now);
        
    } catch (error) {
        console.error('Error updating last activity:', error);
    }
}

// =====================================================
// COURSE SESSION MANAGEMENT
// =====================================================
function startCourseSession() {
    courseSession.startTime = new Date();
    courseSession.pageLoadTime = new Date();
    
    logUserActivity('course_session_start', {
        course_id: COURSE_DATA.id,
        course_title: COURSE_DATA.title,
        user_agent: navigator.userAgent,
        screen_resolution: `${screen.width}x${screen.height}`
    });
    
    // Check daily streak
    checkDailyStreak();
}

function initializeActivityTracking() {
    // Track page focus/blur for accurate study time
    document.addEventListener('visibilitychange', handleVisibilityChange);
    
    // Track user interactions
    ['click', 'keydown', 'scroll', 'mousemove'].forEach(event => {
        document.addEventListener(event, trackUserInteraction, { passive: true });
    });
    
    // Periodic activity updates
    setInterval(updateStudyTime, 60000); // Every minute
    
    // Save session data before page unload
    window.addEventListener('beforeunload', saveSessionData);
}

function handleVisibilityChange() {
    if (document.hidden) {
        courseSession.lastActivityTime = new Date();
    } else {
        // Page became visible again - update activity
        updateLastActivity();
    }
}

function trackUserInteraction() {
    courseSession.interactionCount++;
    courseSession.lastActivityTime = new Date();
    
    // Throttle activity updates
    if (courseSession.interactionCount % 50 === 0) {
        updateLastActivity();
    }
}

function updateStudyTime() {
    if (!courseSession.startTime || document.hidden) return;
    
    const now = new Date();
    const sessionDuration = now - courseSession.startTime;
    courseSession.totalStudyTime = Math.floor(sessionDuration / 1000 / 60); // in minutes
    
    // Update progress with study time
    saveProgress();
}

function saveSessionData() {
    if (!currentUser || !courseSession.startTime) return;
    
    const sessionData = {
        user_id: currentUser.id,
        course_id: COURSE_DATA.id,
        session_duration: courseSession.totalStudyTime,
        lessons_viewed: courseSession.lessonsStarted,
        lessons_completed: courseSession.lessonsCompleted,
        interactions: courseSession.interactionCount,
        session_date: courseSession.startTime.toISOString().split('T')[0]
    };
    
    // Store in localStorage as backup
    localStorage.setItem('course_session_backup', JSON.stringify(sessionData));
    
    // Try to save to database
    logUserActivity('course_session_end', sessionData);
}

// =====================================================
// COURSE DATA & PROGRESS MANAGEMENT
// =====================================================
async function loadCourseData() {
    try {
        // Update course info in UI
        document.getElementById('courseTitle').textContent = COURSE_DATA.title;
        document.getElementById('totalLessons').textContent = COURSE_DATA.lessons.length;
        
        // Log course access
        logUserActivity('course_access', {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title
        });
        
    } catch (error) {
        console.error('Error loading course data:', error);
    }
}

async function loadProgress() {
    try {
        // Get existing progress from database
        const { data, error } = await supabase
            .from('course_progress')
            .select('*')
            .eq('user_id', currentUser.id)
            .eq('course_id', COURSE_DATA.id)
            .single();

        if (error && error.code !== 'PGRST116') {
            throw error;
        }

        if (data) {
            courseProgress = JSON.parse(data.lesson_progress || '{}');
            currentLessonIndex = data.current_lesson || 0;
            
            // Update session tracking
            courseSession.lessonsStarted = Object.keys(courseProgress).length;
            courseSession.lessonsCompleted = Object.values(courseProgress).filter(p => p.completed).length;
        } else {
            // Initialize new progress
            courseProgress = {};
            currentLessonIndex = 0;
            await saveProgress();
            
            // Award first course start achievement
            await checkAndUnlockAchievement('first_course_start');
        }

        updateProgressDisplay();
        
    } catch (error) {
        console.error('Error loading progress:', error);
        showToast('Failed to load progress', 'error');
    }
}

async function saveProgress() {
    try {
        if (!currentUser) return;

        const now = new Date();
        const progressData = {
            user_id: currentUser.id,
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            current_lesson: currentLessonIndex,
            lesson_progress: JSON.stringify(courseProgress),
            progress: calculateOverallProgress(),
            lessons_completed: getCompletedLessonsCount(),
            lessons_started: Object.keys(courseProgress).length,
            study_time_minutes: courseSession.totalStudyTime,
            last_accessed: now.toISOString(),
            updated_at: now.toISOString()
        };

        // Upsert progress
        const { error } = await supabase
            .from('course_progress')
            .upsert([progressData]);

        if (error) throw error;

        // Update user stats
        await updateUserStats();
        
        updateProgressDisplay();

    } catch (error) {
        console.error('Error saving progress:', error);
        showToast('Failed to save progress', 'error');
    }
}

async function updateUserStats() {
    try {
        // Get all course progress for this user
        const { data: allProgress, error } = await supabase
            .from('course_progress')
            .select('progress, course_id, study_time_minutes')
            .eq('user_id', currentUser.id);

        if (error) throw error;

        // Calculate stats
        const completedCourses = allProgress?.filter(p => p.progress >= 100).length || 0;
        const inProgressCourses = allProgress?.filter(p => p.progress > 0 && p.progress < 100).length || 0;
        const totalStudyTime = allProgress?.reduce((sum, p) => sum + (p.study_time_minutes || 0), 0) || 0;

        // Calculate points (500 per completed course + achievement points)
        const coursePoints = completedCourses * 500;
        const bonusPoints = userStats.bonus_points || 0;
        const totalPoints = coursePoints + bonusPoints;

        // Update profile
        const updateData = {
            completed_courses: completedCourses,
            in_progress_courses: inProgressCourses,
            total_points: totalPoints,
            total_study_time: totalStudyTime,
            last_activity: new Date().toISOString()
        };

        const { error: updateError } = await supabase
            .from('profiles')
            .update(updateData)
            .eq('id', currentUser.id);

        if (updateError) throw updateError;

        // Update local stats
        Object.assign(userStats, updateData);

    } catch (error) {
        console.error('Error updating user stats:', error);
    }
}

function calculateOverallProgress() {
    const completedLessons = getCompletedLessonsCount();
    return Math.round((completedLessons / COURSE_DATA.lessons.length) * 100);
}

function getCompletedLessonsCount() {
    return Object.values(courseProgress).filter(lesson => lesson.completed).length;
}

function updateProgressDisplay() {
    const completedCount = getCompletedLessonsCount();
    const progressPercent = calculateOverallProgress();
    
    // Update UI elements
    const elements = {
        'completedLessons': completedCount,
        'courseProgressPercent': `${progressPercent}%`
    };
    
    Object.entries(elements).forEach(([id, value]) => {
        const element = document.getElementById(id);
        if (element) element.textContent = value;
    });
    
    // Update progress bar
    const progressBar = document.getElementById('courseProgressFill');
    if (progressBar) progressBar.style.width = `${progressPercent}%`;
}

// =====================================================
// LESSON MANAGEMENT
// =====================================================
function loadLesson(index) {
    if (index < 0 || index >= COURSE_DATA.lessons.length) return;

    const lesson = COURSE_DATA.lessons[index];
    currentLessonIndex = index;

    // Mark lesson as started and track activity
    if (!courseProgress[lesson.id]) {
        courseProgress[lesson.id] = { 
            started: true, 
            completed: false,
            startedAt: new Date().toISOString(),
            timeSpent: 0
        };
        
        courseSession.lessonsStarted++;
        saveProgress();
        
        // Log lesson start
        logUserActivity('lesson_start', {
            lesson_id: lesson.id,
            lesson_title: lesson.title,
            lesson_index: index
        });
    }

    // Update lesson start time for time tracking
    courseProgress[lesson.id].currentSessionStart = new Date();

    // Update sidebar and navigation
    renderSidebar();
    updateNavigationButtons();

    // Update header info
    updateLessonHeader(lesson, index);

    // Render lesson content
    renderLessonContent(lesson);

    // Smooth scroll and animations
    window.scrollTo({ top: 0, behavior: 'smooth' });
    document.getElementById('contentBody').scrollTop = 0;

    const contentBody = document.getElementById('contentBody');
    contentBody.classList.add('fade-in');
    setTimeout(() => contentBody.classList.remove('fade-in'), 500);
    
    // Check lesson-based achievements
    checkLessonAchievements(index + 1);
}

function updateLessonHeader(lesson, index) {
    const elements = {
        'currentLessonNumber': index + 1,
        'currentLessonTitle': lesson.title,
        'navInfo': `Lesson ${index + 1} of ${COURSE_DATA.lessons.length}`
    };
    
    Object.entries(elements).forEach(([id, value]) => {
        const element = document.getElementById(id);
        if (element) element.textContent = value;
    });
}

function renderSidebar() {
    const lessonNav = document.getElementById('lessonNav');
    if (!lessonNav) return;
    
    lessonNav.innerHTML = '';

    COURSE_DATA.lessons.forEach((lesson, index) => {
        const lessonItem = document.createElement('div');
        lessonItem.className = 'lesson-item';
        
        // Determine lesson status
        const lessonProgress = courseProgress[lesson.id];
        const isCompleted = lessonProgress?.completed || false;
        const isInProgress = lessonProgress?.started || false;
        const isLocked = !isCompleted && !canAccessLesson(index);
        const isActive = index === currentLessonIndex;

        // Apply status classes
        if (isCompleted) lessonItem.classList.add('completed');
        if (isLocked) lessonItem.classList.add('locked');
        if (isActive) lessonItem.classList.add('active');

        // Determine status display
        let statusClass = 'not-started';
        let statusIcon = index + 1;
        
        if (isCompleted) {
            statusClass = 'completed';
            statusIcon = '✓';
        } else if (isInProgress) {
            statusClass = 'in-progress';
            statusIcon = '◐';
        }

        // Create lesson item HTML
        lessonItem.innerHTML = `
            <div class="lesson-status ${statusClass}">${statusIcon}</div>
            <div class="lesson-info">
                <div class="lesson-title">${lesson.title}</div>
                <div class="lesson-meta">
                    ${isCompleted ? 'Completed' : 
                      isInProgress ? 'In Progress' : 
                      isLocked ? 'Locked' : 'Not Started'}
                </div>
            </div>
            <div class="lesson-duration">${lesson.duration}</div>
        `;

        // Add click handler if not locked
        if (!isLocked) {
            lessonItem.addEventListener('click', () => {
                if (index !== currentLessonIndex) {
                    // Track lesson time before switching
                    trackLessonTime();
                    
                    currentLessonIndex = index;
                    loadLesson(index);
                    closeSidebar();
                }
            });
        }

        lessonNav.appendChild(lessonItem);
    });
}

function canAccessLesson(index) {
    if (index === 0) return true; // First lesson always accessible
    
    // Can access if previous lesson is completed
    const previousLessonId = COURSE_DATA.lessons[index - 1].id;
    return courseProgress[previousLessonId]?.completed || false;
}

function trackLessonTime() {
    const currentLesson = COURSE_DATA.lessons[currentLessonIndex];
    const lessonProgress = courseProgress[currentLesson.id];
    
    if (lessonProgress?.currentSessionStart) {
        const sessionTime = Math.floor((new Date() - new Date(lessonProgress.currentSessionStart)) / 1000 / 60);
        lessonProgress.timeSpent = (lessonProgress.timeSpent || 0) + sessionTime;
        delete lessonProgress.currentSessionStart;
    }
}

// =====================================================
// LESSON CONTENT RENDERING
// =====================================================
function renderLessonContent(lesson) {
    const contentContainer = document.getElementById('lessonContent');
    if (!contentContainer) return;
    
    let contentHTML = `
        <div class="content-section">
            <h2>Learning Objectives</h2>
            <ul>
                ${lesson.objectives.map(obj => `<li>${obj}</li>`).join('')}
            </ul>
        </div>
        
        <div class="content-section">
            <h2>Overview</h2>
            <p>${lesson.content.overview}</p>
        </div>
    `;

    // Render content sections
    lesson.content.sections.forEach(section => {
        contentHTML += `
            <div class="content-section">
                <h2>${section.title}</h2>
                ${section.content}
                ${section.image ? `<img src="${section.image}" alt="${section.title}" class="content-image" loading="lazy">` : ''}
            </div>
        `;
    });

    // Render code examples
    if (lesson.content.codeExamples && lesson.content.codeExamples.length > 0) {
        contentHTML += `<div class="content-section"><h2>Code Examples</h2></div>`;
        
        lesson.content.codeExamples.forEach((example, index) => {
            const codeId = `code-${lesson.id}-${index}`;
            contentHTML += `
                <div class="code-section">
                    <div class="code-header">
                        <span class="code-title">${example.title}</span>
                        <button class="copy-btn" onclick="copyCode('${codeId}')">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <pre class="code-block"><code id="${codeId}" class="language-${example.language}">${escapeHtml(example.code)}</code></pre>
                </div>
            `;
        });
    }

    // Render quiz
    contentHTML += renderQuiz(lesson.quiz);

    contentContainer.innerHTML = contentHTML;

    // Highlight code syntax if Prism is available
    setTimeout(() => {
        if (window.Prism) {
            Prism.highlightAll();
        }
    }, 100);
}

// =====================================================
// QUIZ SYSTEM
// =====================================================
function renderQuiz(quiz) {
    const currentLessonProgress = courseProgress[COURSE_DATA.lessons[currentLessonIndex].id];
    const isCompleted = currentLessonProgress?.completed || false;
    
    let quizHTML = `
        <div class="quiz-section" id="quizSection">
            <div class="quiz-header">
                <h2 class="quiz-title">
                    <i class="fas fa-clipboard-check"></i>
                    Knowledge Check
                </h2>
                <p class="quiz-info">
                    Complete this quiz with ${quiz.passingScore}% or higher to unlock the next lesson.
                </p>
            </div>
    `;

    if (isCompleted) {
        const savedScore = currentLessonProgress.quizScore || 0;
        quizHTML += `
            <div class="quiz-results show">
                <div class="quiz-score pass">${savedScore}%</div>
                <div class="quiz-message">
                    <strong>Lesson Completed!</strong><br>
                    You've successfully passed this lesson's quiz.
                </div>
            </div>
        `;
    } else {
        // Render quiz questions
        quiz.questions.forEach((question, qIndex) => {
            quizHTML += `
                <div class="quiz-question ${qIndex === 0 ? 'active' : ''}" data-question="${qIndex}">
                    <div class="question-header">
                        <span class="question-number">Question ${qIndex + 1}</span>
                        <span class="question-progress">${qIndex + 1}/${quiz.questions.length}</span>
                    </div>
                    <div class="question-text">${question.question}</div>
                    <div class="question-options">
                        ${question.options.map((option, oIndex) => `
                            <div class="option" data-option="${oIndex}" onclick="selectOption(${qIndex}, ${oIndex})">
                                <span class="option-letter">${String.fromCharCode(65 + oIndex)}</span>
                                <span class="option-text">${option}</span>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        });

        quizHTML += `
            <div class="quiz-controls">
                <button class="btn btn-secondary" id="prevQuestionBtn" onclick="previousQuestion()" disabled>
                    <i class="fas fa-chevron-left"></i>
                    Previous
                </button>
                <div>
                    <button class="btn btn-secondary" id="nextQuestionBtn" onclick="nextQuestion()" disabled>
                        Next
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <button class="btn btn-primary" id="submitQuizBtn" onclick="submitQuiz()" style="display: none;">
                        <i class="fas fa-check"></i>
                        Submit Quiz
                    </button>
                </div>
            </div>

            <div class="quiz-results" id="quizResults">
                <div class="quiz-score" id="quizScore">0%</div>
                <div class="quiz-message" id="quizMessage"></div>
                <div class="quiz-actions">
                    <button class="btn btn-primary" id="continueBtn" onclick="completeLesson()" style="display: none;">
                        <i class="fas fa-arrow-right"></i>
                        Continue to Next Lesson
                    </button>
                    <button class="btn btn-secondary" onclick="retakeQuiz()">
                        <i class="fas fa-redo"></i>
                        Retake Quiz
                    </button>
                </div>
            </div>
        `;
    }

    quizHTML += '</div>';
    return quizHTML;
}

// Quiz interaction functions
function selectOption(questionIndex, optionIndex) {
    // Clear previous selections
    document.querySelectorAll(`[data-question="${questionIndex}"] .option`).forEach(opt => {
        opt.classList.remove('selected');
    });

    // Select current option
    const selectedOption = document.querySelector(`[data-question="${questionIndex}"] [data-option="${optionIndex}"]`);
    selectedOption.classList.add('selected');

    // Store answer
    quizState.answers[questionIndex] = optionIndex;

    // Update navigation
    const isLastQuestion = questionIndex === COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length - 1;
    if (isLastQuestion) {
        document.getElementById('submitQuizBtn').style.display = 'inline-flex';
        document.getElementById('nextQuestionBtn').style.display = 'none';
    } else {
        document.getElementById('nextQuestionBtn').disabled = false;
    }
}

function nextQuestion() {
    const currentQuestionEl = document.querySelector('.quiz-question.active');
    const nextQuestionEl = currentQuestionEl.nextElementSibling;
    
    if (nextQuestionEl && nextQuestionEl.classList.contains('quiz-question')) {
        currentQuestionEl.classList.remove('active');
        nextQuestionEl.classList.add('active');
        quizState.currentQuestion++;
        updateQuizNavigation();
    }
}

function previousQuestion() {
    const currentQuestionEl = document.querySelector('.quiz-question.active');
    const prevQuestionEl = currentQuestionEl.previousElementSibling;
    
    if (prevQuestionEl && prevQuestionEl.classList.contains('quiz-question')) {
        currentQuestionEl.classList.remove('active');
        prevQuestionEl.classList.add('active');
        quizState.currentQuestion--;
        updateQuizNavigation();
    }
}

function updateQuizNavigation() {
    const totalQuestions = COURSE_DATA.lessons[currentLessonIndex].quiz.questions.length;
    const prevBtn = document.getElementById('prevQuestionBtn');
    const nextBtn = document.getElementById('nextQuestionBtn');
    const submitBtn = document.getElementById('submitQuizBtn');

    prevBtn.disabled = quizState.currentQuestion === 0;
    
    const hasAnswer = quizState.answers[quizState.currentQuestion] !== undefined;
    const isLastQuestion = quizState.currentQuestion === totalQuestions - 1;
    
    if (isLastQuestion) {
        nextBtn.style.display = 'none';
        submitBtn.style.display = hasAnswer ? 'inline-flex' : 'none';
    } else {
        nextBtn.style.display = 'inline-flex';
        nextBtn.disabled = !hasAnswer;
        submitBtn.style.display = 'none';
    }
}

async function submitQuiz() {
    const lesson = COURSE_DATA.lessons[currentLessonIndex];
    const quiz = lesson.quiz;
    let correctAnswers = 0;

    // Hide questions and controls
    document.querySelectorAll('.quiz-question').forEach(q => q.style.display = 'none');
    document.querySelector('.quiz-controls').style.display = 'none';

    // Calculate score and highlight answers
    quiz.questions.forEach((question, index) => {
        const userAnswer = quizState.answers[index];
        const correctAnswer = question.correct;
        const isCorrect = userAnswer === correctAnswer;
        
        if (isCorrect) correctAnswers++;

        // Highlight answers
        const questionEl = document.querySelector(`[data-question="${index}"]`);
        const options = questionEl.querySelectorAll('.option');
        
        options[correctAnswer].classList.add('correct');
        if (userAnswer !== correctAnswer && userAnswer !== undefined) {
            options[userAnswer].classList.add('incorrect');
        }
    });

    const score = Math.round((correctAnswers / quiz.questions.length) * 100);
    const passed = score >= quiz.passingScore;

    // Update quiz results UI
    const quizScore = document.getElementById('quizScore');
    const quizMessage = document.getElementById('quizMessage');
    const quizActions = document.querySelector('.quiz-actions');

    quizScore.textContent = `${score}%`;
    quizScore.className = `quiz-score ${passed ? 'pass' : 'fail'}`;

    if (passed) {
        quizMessage.innerHTML = `
            <strong>Congratulations!</strong><br>
            You passed with ${score}%. You can now proceed to the next lesson.
        `;
        
        quizActions.innerHTML = `
            <button class="btn btn-primary" onclick="completeLesson()">
                <i class="fas fa-arrow-right"></i>
                Continue to Next Lesson
            </button>
        `;
        
        // Mark lesson as completed
        await markLessonComplete(score);
        
    } else {
        quizMessage.innerHTML = `
            <strong>Not quite there yet.</strong><br>
            You scored ${score}%. You need ${quiz.passingScore}% to pass. Review the material and try again.
        `;
        
        quizActions.innerHTML = `
            <button class="btn btn-secondary" onclick="retakeQuiz()">
                <i class="fas fa-redo"></i>
                Retake Quiz
            </button>
        `;
    }

    document.getElementById('quizResults').classList.add('show');
    
    // Log quiz completion
    logUserActivity('quiz_completed', {
        lesson_id: lesson.id,
        lesson_title: lesson.title,
        score: score,
        passed: passed,
        attempts: (courseProgress[lesson.id]?.quizAttempts || 0) + 1
    });

    // Scroll to results
    document.getElementById('quizResults').scrollIntoView({ behavior: 'smooth' });
}

function retakeQuiz() {
    // Reset quiz state
    quizState = {
        currentQuestion: 0,
        answers: [],
        score: 0,
        isComplete: false
    };

    // Track quiz retry
    const lessonId = COURSE_DATA.lessons[currentLessonIndex].id;
    if (!courseProgress[lessonId]) courseProgress[lessonId] = {};
    courseProgress[lessonId].quizAttempts = (courseProgress[lessonId].quizAttempts || 0) + 1;

    // Reload lesson content
    loadLesson(currentLessonIndex);
    
    // Scroll to quiz
    setTimeout(() => {
        document.getElementById('quizSection').scrollIntoView({ behavior: 'smooth' });
    }, 500);
}

async function markLessonComplete(score) {
    const lesson = COURSE_DATA.lessons[currentLessonIndex];
    const lessonId = lesson.id;
    
    // Track lesson completion time
    trackLessonTime();
    
    // Update lesson progress
    courseProgress[lessonId] = {
        ...courseProgress[lessonId],
        completed: true,
        quizScore: score,
        completedAt: new Date().toISOString(),
        finalScore: score
    };

    // Update session tracking
    courseSession.lessonsCompleted++;

    // Save progress to database
    await saveProgress();
    
    // Update UI
    renderSidebar();
    updateNavigationButtons();

    // Check various achievements
    await checkLessonCompletionAchievements();
    await checkPerfectScoreAchievements(score);
    await checkStudyTimeAchievements();
    
    // Log lesson completion
    logUserActivity('lesson_completed', {
        lesson_id: lessonId,
        lesson_title: lesson.title,
        final_score: score,
        time_spent: courseProgress[lessonId].timeSpent || 0,
        lesson_number: currentLessonIndex + 1
    });
    
    showToast('Lesson completed successfully!', 'success');
}

async function completeLesson() {
    if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
        // Move to next lesson
        currentLessonIndex++;
        loadLesson(currentLessonIndex);
        
    } else {
        // Course completion
        await completeCourse();
    }
}

async function completeCourse() {
    try {
        const completionTime = courseSession.totalStudyTime;
        
        // Update course progress to 100% completed
        await supabase
            .from('course_progress')
            .update({
                progress: 100,
                completed_at: new Date().toISOString(),
                completion_time_minutes: completionTime
            })
            .eq('user_id', currentUser.id)
            .eq('course_id', COURSE_DATA.id);

        // Award course completion achievements
        await checkAndUnlockAchievement('course_completion_1');
        await checkSpeedCompletionAchievements(completionTime);
        await checkCourseStreakAchievements();
        
        // Update user stats
        await updateUserStats();
        
        // Show completion message
        showToast('Congratulations! Course completed successfully!', 'certificate');
        
        // Log course completion
        logUserActivity('course_completed', {
            course_id: COURSE_DATA.id,
            course_title: COURSE_DATA.title,
            completion_time_minutes: completionTime,
            total_lessons: COURSE_DATA.lessons.length,
            average_quiz_score: calculateAverageQuizScore()
        });
        
        // Redirect to dashboard after delay
        setTimeout(() => {
            window.location.href = '/dashboard.html';
        }, 3000);
        
    } catch (error) {
        console.error('Error completing course:', error);
        showToast('Error marking course as complete', 'error');
    }
}

// =====================================================
// ACHIEVEMENT INTEGRATION SYSTEM
// =====================================================
async function checkAndUnlockAchievement(achievementId, skipNotification = false) {
    try {
        // Prevent duplicate checks
        const cacheKey = `achievement_${achievementId}_${currentUser.id}`;
        if (sessionStorage.getItem(cacheKey)) return false;

        // Check if already unlocked
        const { data: existing, error } = await supabase
            .from('user_achievements')
            .select('id')
            .eq('user_id', currentUser.id)
            .eq('achievement_id', achievementId)
            .single();

        if (existing) {
            sessionStorage.setItem(cacheKey, 'true');
            return false;
        }

        // Award achievement
        const achievementData = {
            user_id: currentUser.id,
            achievement_id: achievementId,
            unlocked_at: new Date().toISOString(),
            points_awarded: getAchievementPoints(achievementId),
            context: 'course_system'
        };

        const { data, error: insertError } = await supabase
            .from('user_achievements')
            .insert([achievementData])
            .select()
            .single();

        if (insertError) {
            if (insertError.code === '23505') return false; // Already exists
            throw insertError;
        }

        // Update user points
        await supabase.rpc('increment_user_stats', {
  user_id_param: currentUser.id,
  points_to_add: achievementData.points_awarded,
  achievements_to_add: 1
});

        // Cache and queue notification
        sessionStorage.setItem(cacheKey, 'true');
        
        if (!skipNotification) {
            queueAchievementNotification({
                id: achievementId,
                name: getAchievementName(achievementId),
                description: getAchievementDescription(achievementId),
                points: achievementData.points_awarded,
                rarity: getAchievementRarity(achievementId),
                icon: getAchievementIcon(achievementId)
            });
        }

        return true;

    } catch (error) {
        console.error('Error unlocking achievement:', error);
        return false;
    }
}

// Helper functions for achievement data (replace with your actual achievement definitions)
function getAchievementPoints(id) {
    const pointsMap = {
        'first_course_start': 75,
        'first_lesson': 100,
        'course_completion_1': 500,
        'perfect_score': 250,
        'speed_demon': 750,
        'marathon_learner': 500,
        'night_owl': 200,
        'early_bird': 200,
        'weekend_warrior': 150,
        // Add more as needed
    };
    return pointsMap[id] || 100;
}

function getAchievementName(id) {
    const nameMap = {
        'first_course_start': 'Learning Initiated',
        'first_lesson': 'First Steps',
        'course_completion_1': 'Course Conqueror',
        'perfect_score': 'Perfectionist',
        'speed_demon': 'Speed Demon',
        // Add more as needed
    };
    return nameMap[id] || 'Achievement Unlocked';
}

function getAchievementDescription(id) {
    const descMap = {
        'first_course_start': 'Start your first cybersecurity course',
        'first_lesson': 'Complete your first lesson',
        'course_completion_1': 'Complete your first course',
        'perfect_score': 'Score 100% on any quiz',
        'speed_demon': 'Complete a course in under 2 hours',
        // Add more as needed
    };
    return descMap[id] || 'Achievement description';
}

function getAchievementRarity(id) {
    const rarityMap = {
        'first_course_start': 'common',
        'first_lesson': 'bronze',
        'course_completion_1': 'silver',
        'perfect_score': 'gold',
        'speed_demon': 'legendary',
        // Add more as needed
    };
    return rarityMap[id] || 'common';
}

function getAchievementIcon(id) {
    const iconMap = {
        'first_course_start': 'fas fa-play',
        'first_lesson': 'fas fa-baby',
        'course_completion_1': 'fas fa-trophy',
        'perfect_score': 'fas fa-star',
        'speed_demon': 'fas fa-rocket',
        // Add more as needed
    };
    return iconMap[id] || 'fas fa-award';
}

async function checkLessonAchievements(lessonNumber) {
    if (lessonNumber === 1) {
        await checkAndUnlockAchievement('first_lesson');
    }
    
    // Check if user has completed multiple lessons in one day
    const today = new Date().toISOString().split('T')[0];
    const todayCompletions = Object.values(courseProgress).filter(p => 
        p.completed && p.completedAt?.startsWith(today)
    ).length;
    
    if (todayCompletions >= 3) {
        await checkAndUnlockAchievement('lesson_marathon');
    }
}

async function checkLessonCompletionAchievements() {
    const completedCount = getCompletedLessonsCount();
    
    // Lesson-based achievements
    const lessonMilestones = [1, 5, 10, 25, 50, 100];
    for (const milestone of lessonMilestones) {
        if (completedCount >= milestone) {
            await checkAndUnlockAchievement(`lessons_${milestone}`);
        }
    }
    
    // Course completion achievements
    if (completedCount === COURSE_DATA.lessons.length) {
        await checkAndUnlockAchievement('course_completion_1');
        
        // Check for additional course completion achievements
        const { data: allCourses } = await supabase
            .from('course_progress')
            .select('course_id')
            .eq('user_id', currentUser.id)
            .eq('progress', 100);
        
        const totalCompleted = allCourses?.length || 0;
        
        const courseMilestones = [1, 5, 10, 25];
        for (const milestone of courseMilestones) {
            if (totalCompleted >= milestone) {
                await checkAndUnlockAchievement(`course_completion_${milestone}`);
            }
        }
    }
}

async function checkPerfectScoreAchievements(score) {
    if (score === 100) {
        await checkAndUnlockAchievement('perfect_score');
        
        // Check for consecutive perfect scores
        const recentScores = Object.values(courseProgress)
            .filter(p => p.completed && p.quizScore)
            .slice(-5) // Last 5 completed
            .map(p => p.quizScore);
        
        if (recentScores.length >= 3 && recentScores.every(s => s === 100)) {
            await checkAndUnlockAchievement('perfectionist_streak');
        }
    }
}

async function checkSpeedCompletionAchievements(completionTime) {
    // Speed demon: Complete course in under 2 hours (120 minutes)
    if (completionTime <= 120) {
        await checkAndUnlockAchievement('speed_demon');
    }
    
    // Quick learner: Complete course in under 4 hours (240 minutes)
    if (completionTime <= 240) {
        await checkAndUnlockAchievement('quick_learner');
    }
}

async function checkStudyTimeAchievements() {
    const totalTime = courseSession.totalStudyTime;
    
    // Marathon learner: Study for 8+ hours in a course session
    if (totalTime >= 480) { // 8 hours
        await checkAndUnlockAchievement('marathon_learner');
    }
    
    // Dedicated learner: Study for 4+ hours
    if (totalTime >= 240) { // 4 hours
        await checkAndUnlockAchievement('dedicated_learner');
    }
}

async function checkCourseStreakAchievements() {
    try {
        // Check for consecutive course completions
        const { data: recentCourses, error } = await supabase
            .from('course_progress')
            .select('completed_at, course_id')
            .eq('user_id', currentUser.id)
            .eq('progress', 100)
            .order('completed_at', { ascending: false })
            .limit(10);

        if (error || !recentCourses) return;

        // Check for courses completed on consecutive days
        let consecutiveDays = 1;
        for (let i = 1; i < recentCourses.length; i++) {
            const prevDate = new Date(recentCourses[i-1].completed_at).toDateString();
            const currentDate = new Date(recentCourses[i].completed_at).toDateString();
            const dayDiff = Math.abs(new Date(prevDate) - new Date(currentDate)) / (1000 * 60 * 60 * 24);
            
            if (dayDiff <= 1) {
                consecutiveDays++;
            } else {
                break;
            }
        }

        if (consecutiveDays >= 3) {
            await checkAndUnlockAchievement('learning_streak');
        }

    } catch (error) {
        console.error('Error checking course streak achievements:', error);
    }
}

// =====================================================
// TIME-BASED ACHIEVEMENTS
// =====================================================
async function checkTimeBasedAchievements(timestamp) {
    const hour = timestamp.getHours();
    const dayOfWeek = timestamp.getDay();

    // Night owl (after midnight, before 6 AM)
    if (hour >= 0 && hour < 6) {
        await incrementTimeBasedCounter('midnight_sessions', 'night_owl');
    }

    // Early bird (4 AM to 6 AM)
    if (hour >= 4 && hour < 6) {
        await incrementTimeBasedCounter('early_sessions', 'early_bird');
    }

    // Weekend warrior (Saturday = 6, Sunday = 0)
    if (dayOfWeek === 0 || dayOfWeek === 6) {
        await incrementTimeBasedCounter('weekend_sessions', 'weekend_warrior');
    }
}

async function incrementTimeBasedCounter(counterType, achievementId) {
    try {
        const dateStr = new Date().toISOString().split('T')[0];
        const cacheKey = `${counterType}_${currentUser.id}_${dateStr}`;

        // Prevent multiple increments per day
        if (sessionStorage.getItem(cacheKey)) return;

        // Update counter
   await supabase.rpc('increment_profile_counter', {
  user_id_param: currentUser.id,
  counter_field: counterType,
  increment_value: 1
});

        // Cache to prevent double counting
        sessionStorage.setItem(cacheKey, 'true');

        // Check related achievement
        if (achievementId) {
            await checkAndUnlockAchievement(achievementId, true);
        }

    } catch (error) {
        console.error(`Error incrementing ${counterType}:`, error);
    }
}

async function checkDailyStreak() {
    try {
        const { data: profile, error } = await supabase
            .from('profiles')
            .select('last_activity, current_streak, last_streak_date')
            .eq('id', currentUser.id)
            .single();

        if (error) throw error;

        const now = new Date();
        const today = now.toDateString();
        const lastActivity = profile.last_activity ? new Date(profile.last_activity) : null;
        const lastStreakDate = profile.last_streak_date ? new Date(profile.last_streak_date).toDateString() : null;

        let newStreak = profile.current_streak || 0;
        let shouldUpdateStreak = false;

        if (!lastActivity) {
            // First time user
            newStreak = 1;
            shouldUpdateStreak = true;
        } else {
            const daysSinceLastActivity = Math.floor((now - lastActivity) / (1000 * 60 * 60 * 24));
            
            if (lastStreakDate === today) {
                // Already counted today's streak
                return newStreak;
            } else if (daysSinceLastActivity === 1 || (daysSinceLastActivity === 0 && lastStreakDate !== today)) {
                // Consecutive day or same day but not counted yet
                newStreak += 1;
                shouldUpdateStreak = true;
            } else if (daysSinceLastActivity > 1) {
                // Streak broken
                newStreak = 1;
                shouldUpdateStreak = true;
            }
        }

        if (shouldUpdateStreak) {
            await supabase
                .from('profiles')
                .update({
                    current_streak: newStreak,
                    last_activity: now.toISOString(),
                    last_streak_date: now.toISOString()
                })
                .eq('id', currentUser.id);

            userStats.current_streak = newStreak;
            
            showToast(`Daily streak: ${newStreak} days!`, 'success');
            await checkStreakAchievements(newStreak);
        }

        return newStreak;
        
    } catch (error) {
        console.error('Error checking daily streak:', error);
        return 0;
    }
}

async function checkStreakAchievements(currentStreak) {
    const streakMilestones = [3, 7, 14, 30, 100, 365];
    
    for (const milestone of streakMilestones) {
        if (currentStreak >= milestone) {
            await checkAndUnlockAchievement(`streak_${milestone}`);
        }
    }
}

// =====================================================
// USER ACTIVITY LOGGING
// =====================================================
async function logUserActivity(activityType, metadata = {}) {
    try {
        const now = new Date();
        
        const activityData = {
            user_id: currentUser.id,
            activity_type: activityType,
            timestamp: now.toISOString(),
            course_id: COURSE_DATA.id,
            lesson_index: currentLessonIndex,
            session_duration: courseSession.totalStudyTime,
            metadata: JSON.stringify(metadata),
            created_at: now.toISOString()
        };

        // Try to log to activities table
        const { error } = await supabase
            .from('user_activities')
            .insert([activityData]);

        if (error && error.code !== '42P01') {
            console.warn('Activity logging failed:', error.message);
        }

        // Always update last activity in profile
        await supabase
            .from('profiles')
            .update({ last_activity: now.toISOString() })
            .eq('id', currentUser.id);

    } catch (error) {
        console.error('Error logging user activity:', error);
    }
}

// =====================================================
// NAVIGATION SYSTEM
// =====================================================
function updateNavigationButtons() {
    const prevBtn = document.getElementById('prevLessonBtn');
    const nextBtn = document.getElementById('nextLessonBtn');
    
    if (!prevBtn || !nextBtn) return;

    // Previous button
    prevBtn.disabled = currentLessonIndex === 0;
    
    // Next button logic
    const isLastLesson = currentLessonIndex === COURSE_DATA.lessons.length - 1;
    const canGoNext = currentLessonIndex < COURSE_DATA.lessons.length - 1 && 
                     canAccessLesson(currentLessonIndex + 1);
    
    if (isLastLesson) {
        const isCurrentCompleted = courseProgress[COURSE_DATA.lessons[currentLessonIndex].id]?.completed;
        nextBtn.disabled = !isCurrentCompleted;
        nextBtn.innerHTML = '<i class="fas fa-trophy"></i> Complete Course';
    } else {
        nextBtn.disabled = !canGoNext;
        nextBtn.innerHTML = 'Next <i class="fas fa-chevron-right"></i>';
    }
}

// Navigation button event handlers
function goToPreviousLesson() {
    if (currentLessonIndex > 0) {
        trackLessonTime(); // Track time spent on current lesson
        currentLessonIndex--;
        loadLesson(currentLessonIndex);
    }
}

function goToNextLesson() {
    if (currentLessonIndex < COURSE_DATA.lessons.length - 1) {
        const canGoNext = canAccessLesson(currentLessonIndex + 1);
        if (canGoNext) {
            trackLessonTime();
            currentLessonIndex++;
            loadLesson(currentLessonIndex);
        } else {
            showToast('Complete the current lesson quiz to proceed', 'warning');
        }
    } else {
        // Complete course
        completeCourse();
    }
}

// =====================================================
// SIDEBAR FUNCTIONS
// =====================================================
function toggleSidebar() {
    const sidebar = document.getElementById('sidebar');
    const overlay = document.getElementById('sidebarOverlay');
    
    if (sidebar) sidebar.classList.toggle('open');
    if (overlay) overlay.classList.toggle('active');
}

function closeSidebar() {
    const sidebar = document.getElementById('sidebar');
    const overlay = document.getElementById('sidebarOverlay');
    
    if (sidebar) sidebar.classList.remove('open');
    if (overlay) overlay.classList.remove('active');
}

// =====================================================
// ACHIEVEMENT NOTIFICATION SYSTEM
// =====================================================
function queueAchievementNotification(achievement) {
    notificationQueue.push(achievement);
    processNotificationQueue();
}

function processNotificationQueue() {
    if (isShowingNotification || notificationQueue.length === 0) return;

    isShowingNotification = true;
    const achievement = notificationQueue.shift();
    showAchievementNotification(achievement);

    const duration = achievement.rarity === 'mythic' ? 8000 :
                     achievement.rarity === 'legendary' ? 7000 : 6000;

    setTimeout(() => {
        isShowingNotification = false;
        processNotificationQueue();
    }, duration + 500);
}

function showAchievementNotification(achievement) {
    const notification = document.getElementById('achievementNotification');
    if (!notification) return;

    const icon = document.getElementById('notificationIcon');
    const title = document.getElementById('notificationTitle');
    const description = document.getElementById('notificationDescription');
    const points = document.getElementById('notificationPoints');

    if (icon) {
        icon.innerHTML = `<i class="${achievement.icon}"></i>`;
        icon.className = `notification-icon ${achievement.rarity}`;
    }
    if (title) title.textContent = achievement.name;
    if (description) description.textContent = achievement.description;
    if (points) points.textContent = `+${achievement.points} Points`;

    notification.className = `achievement-notification ${achievement.rarity}`;
    notification.classList.add('show');

    const duration = achievement.rarity === 'mythic' ? 8000 :
                     achievement.rarity === 'legendary' ? 7000 : 6000;

    setTimeout(() => {
        notification.classList.remove('show');
    }, duration);
}

// =====================================================
// UTILITY FUNCTIONS
// =====================================================
function calculateAverageQuizScore() {
    const scores = Object.values(courseProgress)
        .filter(p => p.completed && p.quizScore)
        .map(p => p.quizScore);
    
    if (scores.length === 0) return 0;
    return Math.round(scores.reduce((sum, score) => sum + score, 0) / scores.length);
}

async function resetProgress() {
    if (!confirm('Are you sure you want to reset your progress? This action cannot be undone.')) {
        return;
    }

    try {
        // Track lesson time before reset
        trackLessonTime();
        
        // Reset local state
        courseProgress = {};
        currentLessonIndex = 0;
        courseSession = {
            startTime: new Date(),
            totalStudyTime: 0,
            lessonsStarted: 0,
            lessonsCompleted: 0,
            pageLoadTime: new Date(),
            interactionCount: 0,
            lastActivityTime: new Date()
        };
        
        // Delete from database
        await supabase
            .from('course_progress')
            .delete()
            .eq('user_id', currentUser.id)
            .eq('course_id', COURSE_DATA.id);

        // Log reset activity
        logUserActivity('progress_reset', {
            course_id: COURSE_DATA.id,
            reset_reason: 'manual'
        });

        // Reinitialize
        await saveProgress();
        renderSidebar();
        loadLesson(0);
        
        showToast('Progress reset successfully', 'success');
        
    } catch (error) {
        console.error('Error resetting progress:', error);
        showToast('Failed to reset progress', 'error');
    }
}

function copyCode(codeId) {
    const codeElement = document.getElementById(codeId);
    if (!codeElement) return;
    
    const text = codeElement.textContent;
    
    navigator.clipboard.writeText(text).then(() => {
        showToast('Code copied to clipboard!', 'success');
        
        // Track code copy for achievements
        logUserActivity('code_copied', {
            code_section: codeId,
            lesson_id: COURSE_DATA.lessons[currentLessonIndex].id
        });
        
    }).catch(err => {
        console.error('Failed to copy code:', err);
        showToast('Failed to copy code', 'error');
        
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.select();
        try {
            document.execCommand('copy');
            showToast('Code copied to clipboard!', 'success');
        } catch (fallbackError) {
            showToast('Copy failed - please select and copy manually', 'error');
        }
        document.body.removeChild(textArea);
    });
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// =====================================================
// UI FEEDBACK SYSTEMS
// =====================================================
function showToast(message, type = 'success') {
    const toast = document.getElementById('toast');
    const messageEl = document.getElementById('toastMessage');
    
    if (!toast || !messageEl) {
        console.log(`Toast: ${message} (${type})`);
        return;
    }
    
    messageEl.textContent = message;
    toast.className = `toast ${type} show`;

    setTimeout(() => {
        toast.classList.remove('show');
    }, 4000);
}

function showLoadingScreen() {
    const loadingScreen = document.getElementById('loadingScreen');
    if (loadingScreen) loadingScreen.classList.remove('hidden');
}

function hideLoadingScreen() {
    const loadingScreen = document.getElementById('loadingScreen');
    if (loadingScreen) {
        setTimeout(() => {
            loadingScreen.classList.add('hidden');
        }, 1000);
    }
}

// =====================================================
// MUSIC PLAYER INTEGRATION
// =====================================================
function initMusicPlayer() {
    const btnText = document.getElementById('music-button-text');
    const icon = document.getElementById('music-icon');
    const dropdown = document.getElementById('music-dropdown-content');
    
    if (!btnText || !icon || !dropdown) return;
    
    function setUI(state) {
        btnText.textContent = state === "Playing" ? "PAUSE MUSIC" : "STUDY MUSIC";
        icon.className = state === "Playing" ? "fa-solid fa-circle-pause" : "fa-solid fa-music";
    }

    // Load saved music state
    const savedSrc = localStorage.getItem("cybersec_music_src");
    const savedTime = parseFloat(localStorage.getItem("cybersec_music_time") || 0);
    
    if (savedSrc) {
        audioPlayer.src = savedSrc;
        audioPlayer.currentTime = savedTime;
        audioPlayer.play()
            .then(() => setUI("Playing"))
            .catch(() => setUI("Stopped"));
    }

    // Music button click handler
    document.getElementById('music-dropdown').querySelector('button').addEventListener('click', (e) => {
        e.stopPropagation();
        dropdown.style.display = dropdown.style.display === "block" ? "none" : "block";
        
        if (audioPlayer.src && !audioPlayer.paused) {
            audioPlayer.pause();
            setUI("Stopped");
        } else if (audioPlayer.src) {
            audioPlayer.play().then(() => setUI("Playing"));
        }
    });

    // Music selection handlers
    dropdown.querySelectorAll("a[data-src]").forEach((link) => {
        link.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.src = link.dataset.src;
            audioPlayer.play().then(() => setUI("Playing"));
            localStorage.setItem("cybersec_music_src", link.dataset.src);
            dropdown.style.display = "none";
        });
    });

    // Stop music handler
    const stopLink = document.getElementById("stop-music-link");
    if (stopLink) {
        stopLink.addEventListener("click", (e) => {
            e.preventDefault();
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            audioPlayer.removeAttribute("src");
            setUI("Stopped");
            localStorage.removeItem("cybersec_music_src");
            localStorage.removeItem("cybersec_music_time");
            dropdown.style.display = "none";
        });
    }

    // Save music state before page unload
    window.addEventListener("beforeunload", () => {
        if (!audioPlayer.paused && audioPlayer.src) {
            localStorage.setItem("cybersec_music_src", audioPlayer.src);
            localStorage.setItem(
                "cybersec_music_time",
                audioPlayer.currentTime
            );
        }
    });

    // Close dropdown when clicking outside
    window.addEventListener("click", (e) => {
        if (!e.target.closest("#music-dropdown")) {
            dropdown.style.display = "none";
        }
    });
}

// Show initial music indicator
function addMusicIndicator() {
    const musicBtn = document.querySelector("#music-dropdown");
    if (musicBtn) {
        const indicator = document.createElement("div");
        indicator.className = "music-indicator";
        indicator.innerHTML = `<i class="fa-solid fa-music"></i> Try Study Music!`;

        musicBtn.style.position = "relative";
        musicBtn.appendChild(indicator);

        setTimeout(() => indicator.remove(), 3000);
    }
}

// Initialize Event Listeners
function initializeEventListeners() {
    // Navigation buttons
    document.getElementById('prevLessonBtn')?.addEventListener('click', goToPreviousLesson);
    document.getElementById('nextLessonBtn')?.addEventListener('click', goToNextLesson);

    // Reset progress button
    document.getElementById('resetProgressBtn')?.addEventListener('click', resetProgress);

    // Mobile menu toggle
    document.getElementById('menuToggle')?.addEventListener('click', toggleSidebar);
    document.getElementById('sidebarOverlay')?.addEventListener('click', closeSidebar);

    // Keyboard shortcuts
    document.addEventListener('keydown', handleKeyboardShortcuts);

    // Window resize handler
    window.addEventListener('resize', handleWindowResize);

    // Content interaction tracking
    document.getElementById('contentBody')?.addEventListener('scroll', debounce(() => {
        trackUserInteraction();
    }, 1000));
}

// Keyboard Shortcuts
function handleKeyboardShortcuts(e) {
    if (document.querySelector('.quiz-question.active')) return;

    if (e.key === 'ArrowLeft' && e.ctrlKey) {
        e.preventDefault();
        goToPreviousLesson();
    } else if (e.key === 'ArrowRight' && e.ctrlKey) {
        e.preventDefault();
        goToNextLesson();
    }
}

// Window Resize Handler
function handleWindowResize() {
    if (window.innerWidth > 768) {
        closeSidebar();
    }
}

// Debounce Helper
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// Initialize responsive behavior
if (window.innerWidth <= 768) {
    document.getElementById('menuToggle').style.display = 'inline-flex';
}

// Auto-save progress periodically
setInterval(async () => {
    if (currentUser && Object.keys(courseProgress).length > 0) {
        await saveProgress();
    }
}, 60000); // Save every minute

// System initialization logging
console.log('CyberSec Academy Course System Initialized');
console.log('Current Course:', COURSE_DATA.title);
console.log('Total Lessons:', COURSE_DATA.lessons.length);

// Google OAuth Integration
const googleBtn = document.querySelector(".btn-google");
if (googleBtn) {
    googleBtn.addEventListener("click", async () => {
        const { data, error } = await supabase.auth.signInWithOAuth({
            provider: "google",
            options: {
                redirectTo: window.location.origin + "/courses/ssl-tls-basics.html",
            },
        });

        if (error) {
            console.error("Google login error:", error.message);
            showToast("Google login failed: " + error.message, "error");
        }
    });
}

// Check for existing session
supabase.auth.getSession().then(({ data }) => {
    if (data.session) {
        console.log("User already logged in:", data.session.user);
        currentUser = data.session.user;
        startCourseSession();
    }
});


// Add missing auth modal functions
function openAuthModal() {
    const modal = document.getElementById('authModal');
    if (modal) {
        modal.style.display = 'flex';
    }
}

function closeAuthModal() {
    const modal = document.getElementById('authModal');
    if (modal) {
        modal.style.display = 'none';
    }
}

// Add auth tab switching functionality
document.getElementById('tabSignIn')?.addEventListener('click', () => {
    document.getElementById('tabSignIn').classList.add('active');
    document.getElementById('tabSignUp').classList.remove('active');
    document.getElementById('signInForm').style.display = 'block';
    document.getElementById('signUpForm').style.display = 'none';
});

document.getElementById('tabSignUp')?.addEventListener('click', () => {
    document.getElementById('tabSignUp').classList.add('active');
    document.getElementById('tabSignIn').classList.remove('active');
    document.getElementById('signUpForm').style.display = 'block';
    document.getElementById('signInForm').style.display = 'none';
});

document.getElementById('closeAuthModal')?.addEventListener('click', closeAuthModal);

// Improved error handling for auth session
supabase.auth.onAuthStateChange((event, session) => {
    if (event === 'SIGNED_IN') {
        currentUser = session.user;
        closeAuthModal();
        startCourseSession();
    } else if (event === 'SIGNED_OUT') {
        currentUser = null;
        openAuthModal();
    }
});

// Add form submission handlers
document.getElementById('emailSignInForm')?.addEventListener('submit', async (e) => {
    e.preventDefault();
    const email = document.getElementById('signInEmail').value;
    const password = document.getElementById('signInPassword').value;
    
    try {
        const { data, error } = await supabase.auth.signInWithPassword({
            email,
            password
        });
        
        if (error) throw error;
        
        closeAuthModal();
    } catch (error) {
        showToast(error.message, 'error');
    }
});

document.getElementById('emailSignUpForm')?.addEventListener('submit', async (e) => {
    e.preventDefault();
    const email = document.getElementById('signUpEmail').value;
    const password = document.getElementById('signUpPassword').value;
    const name = document.getElementById('signUpName').value;
    
    try {
        const { data, error } = await supabase.auth.signUp({
            email,
            password,
            options: {
                data: {
                    full_name: name
                }
            }
        });
        
        if (error) throw error;
        
        showToast('Account created successfully! Please check your email.', 'success');
    } catch (error) {
        showToast(error.message, 'error');
    }
});
    </script>
</body>

</html>
